begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*matcd.c--------------------------------------------------------------------  	Matsushita(Panasonic) / Creative CD-ROM Driver	(matcd) 	Authored by Frank Durda IV  	Copyright 1994, 1995  Frank Durda IV.  All rights reserved. 	"FDIV" is a trademark of Frank Durda IV.   	Redistribution and use in source and binary forms, with or 	without modification, are permitted provided that the following 	conditions are met: 	1.  Redistributions of source code must retain the above copyright 	    notice positioned at the very beginning of this file without 	    modification, all copyright strings, all related programming 	    codes that display the copyright strings, this list of 	    conditions and the following disclaimer. 	2.  Redistributions in binary form must contain all copyright strings 	    and related programming code that display the copyright strings. 	3.  Redistributions in binary form must reproduce the above copyright 	    notice, this list of conditions and the following disclaimer in 	    the documentation and/or other materials provided with the 	    distribution. 	4.  All advertising materials mentioning features or use of this 	    software must display the following acknowledgement: 		"The Matsushita/Panasonic CD-ROM driver  was developed 		 by Frank Durda IV for use with "FreeBSD" and similar 		 operating systems." 	    "Similar operating systems" includes mainly non-profit oriented 	    systems for research and education, including but not restricted 	    to "NetBSD", "386BSD", and "Mach" (by CMU).  The wording of the 	    acknowledgement (in electronic form or printed text) may not be 	    changed without permission from the author. 	5.  Absolutely no warranty of function, fitness or purpose is made 	    by the author Frank Durda IV. 	6.  Neither the name of the author nor the name "FreeBSD" may 	    be used to endorse or promote products derived from this software 	    without specific prior written permission. 	    (The author can be reached at   bsdmail@nemesis.lonestar.org) 	7.  The product containing this software must meet all of these 	    conditions even if it is unsupported, not a complete system 	    and/or does not contain compiled code. 	8.  These conditions will be in force for the full life of the 	    copyright. 	9.  If all the above conditions are met, modifications to other 	    parts of this file may be freely made, although any person 	    or persons making changes do not receive the right to add their 	    name or names to the copyright strings and notices in this 	    software.  Persons making changes are encouraged to insert edit 	    history in matcd.c and to put your name and details of the 	    change there. 	10. You must have prior written permission from the author to 	    deviate from these terms.  	Vendors who produce product(s) containing this code are encouraged 	(but not required) to provide copies of the finished product(s) to 	the author and to correspond with the author about development 	activity relating to this code.   Donations of development hardware 	and/or software are also welcome.  (This is one of the faster ways 	to get a driver developed for a device.)   	THIS SOFTWARE IS PROVIDED BY THE DEVELOPER(S) ``AS IS'' AND ANY  	EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  	PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER(S) BE  	LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  	OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  	OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  	OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  	LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.   ----------------------------------------------------------------------------- Dedicated to:	My family, my Grandfather, 		and Max, my Golden Retriever  Thanks to:	Jordan Hubbard (jkh) for getting me ramped-up to 2.x system 		quickly enough to make the 2.1 release.  He put up with 		plenty of silly questions and might get the post of 		ambassador some day.  and 		The people who donated equipment and other material to make 		development of this driver possible.  Donations and 		sponsors for projects are appreciated.   -----No changes are allowed above this line------------------------------------  Edit History - (should be in sync with any source control log entries)  	Never seen one of these before?  Ok, here is how it works. 	Every time you change the code, you increment the edit number, 	that number over there in the<%d> and in the (%d) in the 	version string.  You never set this number lower than it is. 	Near, or preferably on lines that change, insert the edit 	number.  If there is a number there already, you can replace it 	with a newer one.  This makes searches for code changes very fast.  	In the edit history, start with the edit number, and a good 	description of what changes were made.  Then follow it with 	the date, your name and an EMAIL address where you can be reached.  	Please follow this practice; it helps leave understandable code in 	your wake.  	FYI, you have major and minor release codes.  Major releases numbered 	1 thru n.  Major feature additions should get a new major release 	number.  Minor releases start with a null and then letters 	A thru Z.  So  3A(456) is Major release 3, Minor release 1, 	Edit 456 (in Microsoft-ese that would be 03.01.456), and 5(731) 	is Major release 5, Minor release 0, Edit 731.  Typically only the 	author will change the major and minor release codes in small 	projects.  				EDIT edit Edit HISTORY history History<1>	This initial version is to get basic filesystem I/O working 	using the SoundBlaster 16 interface.  The stand-alone adapter 	card doesn't work yet. 	December 1994  Frank Durda IV	bsdmail@nemesis.lonestar.org<2>	Corrections to resolve a race condition when multiple drives 	on the same controller was active.  Fixed drive 1& 2 swap 	problem.  See selectdrive(). 	21-Jan-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<3>	Added automatic probing and support for all Creative Labs sound 	cards with the Creative/Panasonic interface and the stand-alone 	interface adapters.  See AUTOHUNT and FULLCONFIG conditionals 	for more information. 	21-Jan-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<4>	Rebundled debug conditionals. 	14-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<5>	Changes needed to work on FreeBSD 2.1.  Also added draincmd 	since some conditions cause the drive to produce surprise data. 	See setmode and draincmd 	19-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<6>	Got rid of some redundant error code by creating chk_error(). 	Also built a nice generic bus-lock function. 	20-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<7>	Improved comments, general structuring. 	Fixed a problem with disc eject not working if LOCKDRIVE was set. 	Apparently the drive will reject an EJECT command if the drive 	is LOCKED. 	21-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org  Edit number code marking begins here - earlier edits were during development.<8>	Final device name selected and actually made to compile under>2.0. For newer systems, it is "matcd", for older it is "mat". 	24-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<9>	Added some additional disk-related ioctl functions that didn't 	make it into earlier versions. 	26-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<10>	Updated some conditionals so the code will compile under 	1.1.5.1, although this is not the supported platform. 	Also found that some other devices probe code was changing the 	settings for the port 0x302 debug board, so added code to set it 	to a sane state before we use it. 	26-Feb-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<11>	The Copyright and Use statement has been replaced in all files 	with a new version. 	1-Mar-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<12>	Added ioctls having to do with audio volume, routing and playback 	speed.  Also added some code I think is for dynamic loading. 	12-Mar-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<13>	Added ioctls to return TOC headers and entries. 	19-Mar-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<14>	More ioctls to finish out general audio support and some clean-up. 	Also fixed a bug in open where CD label information would not 	always be cleared after a disc change.  	Added a check to block attempts to resume audio if already playing. 	The resulting sound is a cross between Kryten and Max Headroom. 	But, if you *want* this "feature", enable #define KRYTEN 	in options.h.  	So it is not BSD-ish enough, eh?  What, too many comments?  :-) 	21-Mar-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<15>	LOCKDRIVE has been modified so that a new series of minor 	numbers are created.  When these are opened, the selected 	drive will have its door locked and the device must be completely 	closed to unlock the media.  The EJECT ioctl will be refused 	when the drive is locked this way.   This is useful for 	servers and other places where the media needs to remain in the 	drive.  Bit 7 of the minor number controls locking.  	As of this edit, the code compiles with no warnings with -Wall set. 	22-Mar-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<16>	Added a new check in the probe code that looks for the drive 	interface being in an idle state after issuing a reset.  If this 	isn't the case, then the device at this location isn't a 	Matsushita CD-ROM drive.  This will prevent hangs in draincmd later. 	Added the tray close ioctl.  This required modifications to open 	to allow the character devices to be "partially" opened so that 	the close ioctl could be issued when the open would otherwise fail. 	Close also delays slightly after completing because the drive 	doesn't update its disc and media status instantly. 	Also created the capability ioctl that lets an application find out 	up front what things a drive can do. 	Fixed a global spelling error. 	Changed matcddriver structure to simply say "matcd".  The original 	string "matcd interface " broke the kernel -c boot mechanism. 	Updated the #includes in response to a complaint in first release. 	Updated and tested conditionals so that driver will still compile 	under FreeBSD 1.1.5.1 as well as 2.0 and early 2.1. 	4-Apr-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<17>	The function matcd_toc_entries which is executed in response to 	the CDIOREADTOCENTRYS ioctl didn't cope with programs that only 	requested part of the TOC.  This change is based on code submitted 	by Doug Robson (dfr@render.com). 	(This change was introduced out of order and exists in FreeBSD 	 2.0.5 without the version stamp being updated.  I.N.M.F.) 	1-Jun-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<18>	While working on the TEAC CD-ROM driver (teaccd) that is reusing 	chunks of code from this driver, I discovered several functions, 	arrays and other things that should have been declared 'static'. 	These changes are necessary if the TEAC CD-ROM driver is to be 	present at the same time as matcd. 	Also fixed the residual buss vs bus symbols and strings. 	There are no functional code changes in this edit. 	2-May-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<19>	Creative has changed the Status port slightly in their 	sound boards based on the Vibra-16 (and probably the Vibra-16S) 	chipset.  This change masks some unused bits that were formally 	on all the time and are doing different things in this design. 	The changes are transparent to all other supported boards. 	20-Jun-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<20>	Code was added to detect non-Creative (SoundBlaster) host 	interfaces, and the driver will  switch to code compatible with the 	detected host interface.  This should add support for MediaVision, 	IBM, Reveal, and other compatible adapters with split 	data/status-ports.  This code allows a mix of SoundBlaster (Type 0) 	and non-SoundBlaster (Type 1) boards in the same system with no 	special configuration.    	I also updated the attach code to display the interface type and 	changed the host interface probe messages to reflect the "c" for 	controller in controller-specific messages as the existing messages 	were confusing when a second card was in place .  The kernel -c 	tables have been updated accordingly, so you now have a matcdc%d 	controller to change settings on. 	24-Jun-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<21>	Added interface handling code in two of those "this should not 	happen" routines, draincmd and get_stat.   Since these routines are 	called by functions during probing that may not know what type 	interface is out there, the code assumes that a given adapter is  	both a type 0 and a type 1 adapter at the same time.  Plus, 	this code gets executed once in a very long time so the cost of 	assuming both host adapter types is not significant. 	4-Jul-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<22>	Four external interface prototypes were altered by someone else. 	I believe these changes are for making GCC and/or the linker shut-up 	when building some other part of the system since matcd already 	compiles -Wall with no warnings... 	8-Sep-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<23>	This change implements the ioctls for preventing media removal 	and allowing media removal. 	Currently, these calls will work according to the following rules: 			No "l" devs opened	Any "l" dev open 	CDALLOW		accepted always		rejected always 	CDPREVENT	accepted always		accepted always  	One refinement might be to allow CDALLOW/CDPREVENT to always 	work if UID 0 issued the ioctl, but that will wait for later.  	I also made a change to the information that the toc_entry code 	returns so that xcdplayer won't malfunction.  (It would not play 	the last track on a non-mixed mode audio CD.)  Unlike cdplayer, 	xcdplayer asks for track information one track at a time, and 	calls for information on the lead-out track by its official 	number (0xaa), rather than referring to the "after last" (n+1) track 	as cdplayer does.  Anyway, this change should make both players 	happy.  	16-Sep-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<24>	In Edit 15 when the extra devs were created for selective locking, 	the door locking was broken if a non-locking dev on the drive is 	closed.  The problem was caused by not tracking locked devs and 	non-locking devs as being different partitions.   The change is to 	simply use the locking dev bit to flag a set of shadow partitions 	when it comes to lock operations.  All other operations treat the 	locked and unlocked partitions as being identical. 	18-Sep-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<25>	During work on Edit 23, I noted that on slow and very busy systems, 	sometimes the driver would go to sleep forever.  The problem appears 	to have been a race condition caused by doing separate timeout/sleep 	calls without using SPL first.  The change here is to use tsleep 	which provides the equivalent of timeout/sleep timeout/tsleep if the 	last paremeter is tsleep is set to the time value that would have been 	given to timeout. 	I also fixed some duplicate location strings in the tsleep calls. 	24-Sep-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<26>	Moved a function declaration that generated two warnings with 	the FULLCONFIG/FULLDRIVER conditionals disabled. 	Updated the igot function so that it correctly reports limited 	functions when a sub-set driver is compiled. 	Eliminated FULLCONFIG conditional and now set controller counts 	based on the NMATCD #define produced by the config process. 	Also, disable the audio-related ioctls based on the BOOTMFS 	conditional to help make the boot floppy kernel smaller. 	18-Oct-95  Frank Durda IV	bsdmail@nemesis.lonestar.org<27>	Incorporated changes needed to move the cdevsw and bdevsw 	entries into the drivers (including this one). Also 	include a quick first pass cut at DEVFS suppport. (removed later)  ---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*Match this format:		Version_dc(d)__dd-mmm-yy	*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|MATCDVERSION
index|[]
init|=
literal|"Version  1(26) 18-Oct-95"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	The following strings may not be changed*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|MATCDCOPYRIGHT
index|[]
init|=
literal|"Matsushita CD-ROM driver, Copr. 1994,1995 Frank Durda IV"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*	The proceeding strings may not be changed*/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Include declarations ---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"matcd.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|"i386/isa/matcd/options.h"
end_include

begin_comment
comment|/*Conditional compile options 						  and probe port hints*/
end_comment

begin_include
include|#
directive|include
file|"i386/isa/matcd/matcddrv.h"
end_include

begin_comment
comment|/*Drive-related defs& strings*/
end_comment

begin_include
include|#
directive|include
file|"i386/isa/matcd/creative.h"
end_include

begin_comment
comment|/*Host interface related defs*/
end_comment

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_OLDISA
end_ifndef

begin_error
error|#
directive|error
literal|"The matcd device requires the old isa compatibility shims"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*--------------------------------------------------------------------------- 	Defines and structures ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|DRIVESPERC
value|4
end_define

begin_comment
comment|/*This is a constant*/
end_comment

begin_define
define|#
directive|define
name|TOTALDRIVES
value|NUMCTRLRS*DRIVESPERC
end_define

begin_comment
comment|/*Max possible drives*/
end_comment

begin_define
define|#
directive|define
name|TICKRES
value|10
end_define

begin_comment
comment|/*Our coarse timer resolution*/
end_comment

begin_define
define|#
directive|define
name|ISABUSKHZ
value|8330
end_define

begin_comment
comment|/*Number of IN/OUT ISA/sec*/
end_comment

begin_define
define|#
directive|define
name|MAXTRKS
value|101
end_define

begin_comment
comment|/*Maximum possible tracks*/
end_comment

begin_define
define|#
directive|define
name|RAW_DEVICE
value|46
end_define

begin_comment
comment|/*<16>Dev number for raw device*/
end_comment

begin_define
define|#
directive|define
name|MATCDBLK
value|2048
end_define

begin_comment
comment|/*Standard block size*/
end_comment

begin_define
define|#
directive|define
name|MATCDRBLK
value|2352
end_define

begin_comment
comment|/*Raw and/or DA block size*/
end_comment

begin_define
define|#
directive|define
name|MATCD_RETRYS
value|5
end_define

begin_comment
comment|/*Number of retries for read ops*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_1
value|0x80
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_define
define|#
directive|define
name|MATCD_READ_2
value|0x90
end_define

begin_comment
comment|/*Read state machine defines*/
end_comment

begin_struct
struct|struct
name|matcd_volinfo
block|{
name|unsigned
name|char
name|type
decl_stmt|;
comment|/*00 CD-DA or CD-ROM 					  10 CD-I 					  20 XA */
name|unsigned
name|char
name|trk_low
decl_stmt|;
comment|/*Normally 1*/
name|unsigned
name|char
name|trk_high
decl_stmt|;
comment|/*Highest track number*/
name|unsigned
name|char
name|vol_msf
index|[
literal|3
index|]
decl_stmt|;
comment|/*Size of disc in min/sec/frame*/
block|}
struct|;
end_struct

begin_struct
struct|struct
name|matcd_mbx
block|{
name|short
name|controller
decl_stmt|;
name|short
name|ldrive
decl_stmt|;
name|short
name|partition
decl_stmt|;
name|short
name|port
decl_stmt|;
name|short
name|iftype
decl_stmt|;
comment|/*<20>Host interface type*/
name|short
name|retry
decl_stmt|;
name|short
name|nblk
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|u_long
name|skip
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|p_offset
decl_stmt|;
name|short
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|matcd_data
block|{
name|short
name|drivemode
decl_stmt|;
comment|/*Last state drive was set to*/
name|short
name|flags
decl_stmt|;
name|short
name|status
decl_stmt|;
comment|/*Last audio-related function*/
name|int
name|blksize
decl_stmt|;
name|u_long
name|disksize
decl_stmt|;
name|short
name|iobase
decl_stmt|;
name|short
name|iftype
decl_stmt|;
comment|/*<20>Host interface type*/
name|struct
name|disklabel
name|dlabel
decl_stmt|;
name|unsigned
name|int
name|partflags
index|[
name|MAXPARTITIONS
index|]
decl_stmt|;
name|unsigned
name|int
name|openflags
decl_stmt|;
name|struct
name|matcd_volinfo
name|volinfo
decl_stmt|;
name|struct
name|matcd_mbx
name|mbx
decl_stmt|;
name|u_char
name|patch
index|[
literal|2
index|]
decl_stmt|;
comment|/*<12>Last known audio routing*/
name|u_char
name|volume
index|[
literal|2
index|]
decl_stmt|;
comment|/*<12>Last known volume setting*/
block|}
name|matcd_data
index|[
name|TOTALDRIVES
index|]
struct|;
end_struct

begin_comment
comment|/*	Bit equates for matcd_data.flags*/
end_comment

begin_define
define|#
directive|define
name|MATCDINIT
value|0x0001
end_define

begin_comment
comment|/*Probe ran on host adapter*/
end_comment

begin_define
define|#
directive|define
name|MATCDLABEL
value|0x0004
end_define

begin_comment
comment|/*Valid TOC exists*/
end_comment

begin_define
define|#
directive|define
name|MATCDLOCK
value|0x0008
end_define

begin_comment
comment|/*<15>Drive door is locked*/
end_comment

begin_define
define|#
directive|define
name|MATCDWARN
value|0x0020
end_define

begin_comment
comment|/*Have reported an open disc change*/
end_comment

begin_comment
comment|/*	Bit equates for matcd_data.partflags*/
end_comment

begin_define
define|#
directive|define
name|MATCDOPEN
value|0x0001
end_define

begin_define
define|#
directive|define
name|MATCDREADRAW
value|0x0002
end_define

begin_comment
comment|/*	Error classes returned by chk_error()*/
end_comment

begin_define
define|#
directive|define
name|ERR_RETRY
value|1
end_define

begin_comment
comment|/*A retry might recover this*/
end_comment

begin_define
define|#
directive|define
name|ERR_INIT
value|2
end_define

begin_comment
comment|/*A retry certainly will get this*/
end_comment

begin_define
define|#
directive|define
name|ERR_FATAL
value|3
end_define

begin_comment
comment|/*This cannot be recovered from*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bio_queue_head
name|request_head
index|[
name|NUMCTRLRS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<18>A queue for each host interface*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|nextcontroller
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<18>Number of interface units found*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|drivepresent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<18>Don't change this - see license*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|iftype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<20>Probe/Attach i.f. type relay*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|if_state
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*<18>State of the host I/F and bus*/
end_comment

begin_comment
comment|/*	Flags in the if_state array */
end_comment

begin_define
define|#
directive|define
name|BUSBUSY
value|0x01
end_define

begin_comment
comment|/*<18>Bus is already busy*/
end_comment

begin_struct
struct|struct
name|matcd_read2
block|{
name|unsigned
name|char
name|start_msf
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|end_msf
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*	This mystery structure is supposed to make dynamic driver 	loading possible. */
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	These macros take apart the minor number and yield the 	partition, drive on controller, and controller. 	This must match the settings in /dev/MAKEDEV. ---------------------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|matcd_partition
parameter_list|(
name|dev
parameter_list|)
value|((minor(dev))& 0x07)
end_define

begin_define
define|#
directive|define
name|matcd_ldrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x78)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_cdrive
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x18)>> 3)
end_define

begin_define
define|#
directive|define
name|matcd_controller
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x60)>> 5)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKDRIVE
end_ifdef

begin_define
define|#
directive|define
name|matcd_lockable
parameter_list|(
name|dev
parameter_list|)
value|(((minor(dev))& 0x80)>> 5)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*LOCKDRIVE*/
end_comment

begin_comment
comment|/*--------------------------------------------------------------------------- 	Entry points and other connections to/from kernel - see also conf.h            --- not any more :) ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
specifier|static
name|int
name|matcd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|matcddriver
init|=
block|{
name|INTR_TYPE_BIO
block|,
name|matcd_probe
block|,
name|matcd_attach
block|,
literal|"matcd"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|COMPAT_ISA_DRIVER
argument_list|(
name|matcd
argument_list|,
name|matcddriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|matcdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|matcdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|matcdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|matcdsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|matcdstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|46
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|matcd_cdevsw
init|=
block|{
comment|/* open */
name|matcdopen
block|,
comment|/* close */
name|matcdclose
block|,
comment|/* read */
name|physread
block|,
comment|/* write */
name|nowrite
block|,
comment|/* ioctl */
name|matcdioctl
block|,
comment|/* poll */
name|nopoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|matcdstrategy
block|,
comment|/* name */
literal|"matcd"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
name|D_DISK
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------------------------- 	Internal function declarations ---------------------------------------------------------------------------*/
end_comment

begin_function_decl
specifier|static
name|void
name|matcd_start
parameter_list|(
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|matcd_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unlockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_function_decl
specifier|static
name|int
name|matcd_playtracks
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_track
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_playmsf
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_play_msf
modifier|*
name|pt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_pause
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_stop
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_level
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_vol
modifier|*
name|volume
parameter_list|,
name|unsigned
name|long
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_patch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_patch
modifier|*
name|routing
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_route
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|unsigned
name|long
name|command
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_pitch
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_pitch
modifier|*
name|speed
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_function_decl
specifier|static
name|int
name|matcd_toc_header
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_toc_header
modifier|*
name|toc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_toc_entries
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_entry
modifier|*
name|ioc_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_toc_entry
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_single_entry
modifier|*
name|ioc_entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_read_subq
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_subchannel
modifier|*
name|sqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_igot
parameter_list|(
name|struct
name|ioc_capability
modifier|*
name|sqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|test
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_doorclose
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matcd_dlock
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdopen - Open the device  	This routine actually gets called every time anybody opens 	any partition on a drive.  But the first call is the one that 	does all the work.<15>	If LOCKDRIVE is enabled, additional minor number devices allow<15>	the drive to be locked while being accessed. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|cdrive
decl_stmt|,
name|ldrive
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|,
name|lock
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lock
operator|=
name|matcd_lockable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open: dev %x partition %x controller %x flags %x cdrive %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
name|partition
argument_list|,
name|controller
argument_list|,
name|cd
operator|->
name|flags
argument_list|,
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
block|{
comment|/*Did probe find this drive*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|&&
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Has drive completely closed?*/
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*No, all partitions must close*/
block|}
comment|/*	Now, test to see if the media is ready */
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*Test drive*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matopen"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d Result of NOP is %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_DSKIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*Is there a disc in the drive?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: No Disc in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*<16>Mark label as invalid*/
if|if
condition|(
name|major
argument_list|(
name|dev
argument_list|)
operator|==
name|RAW_DEVICE
condition|)
block|{
comment|/*<16>Is the char device?*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*<16>Allow Semi open*/
block|}
else|else
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*<16>Normally blow off*/
block|}
block|}
if|if
condition|(
name|z
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
comment|/*Was there an error*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Find out what it was*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d NOP Error was %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
name|cd
operator|->
name|openflags
condition|)
block|{
comment|/*Any parts open?*/
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/*<14>Was it a disc chg?*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Disc change detected i %x z %x\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
else|else
block|{
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*<14>Was it a disc chg?*/
comment|/*<14>Clear volume info*/
block|}
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
comment|/*	Here we fill in the disklabel structure although most is 	hardcoded. */
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|)
expr_stmt|;
comment|/*	Now we query the drive for the actual size of the media. 	This is where we find out of there is any media or if the 	media isn't a Mode 1 or Mode 2/XA disc. 	See version information about Mode 2/XA support. */
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|i
operator|=
name|matcdsize
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Bus unlocked in open\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Could not read the disc size\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*matcdsize filled in rest of dlabel*/
comment|/*	Based on the results, fill in the variable entries in the disklabel */
name|cd
operator|->
name|dlabel
operator|.
name|d_secsize
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ncylinders
operator|=
operator|(
name|cd
operator|->
name|disksize
operator|/
literal|100
operator|)
operator|+
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secperunit
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_size
operator|=
name|cd
operator|->
name|disksize
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_checksum
operator|=
name|dkcksum
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|)
expr_stmt|;
comment|/*	Now fill in the hardcoded section */
comment|/*123456789012345678*/
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_typename
argument_list|,
literal|"Matsushita CDR "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cd
operator|->
name|dlabel
operator|.
name|d_packname
argument_list|,
literal|"(c) 1994, fdiv "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_magic2
operator|=
name|DISKMAGIC
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_nsectors
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_secpercyl
operator|=
literal|100
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_ntracks
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_interleave
operator|=
literal|1
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_rpm
operator|=
literal|300
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|=
literal|1
expr_stmt|;
comment|/*See note below*/
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_offset
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
literal|0
index|]
operator|.
name|p_fstype
operator|=
literal|9
expr_stmt|;
name|cd
operator|->
name|dlabel
operator|.
name|d_flags
operator|=
name|D_REMOVABLE
expr_stmt|;
comment|/*	I originally considered allowing the partition match tracks or 	sessions on the media, but since you are allowed up to 99 	tracks in the RedBook world, this would not fit in with the 	BSD fixed partition count scheme.  So ioctls will be used to shift 	the track to be accessed into partition 1. */
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
comment|/*Mark drive as having TOC*/
block|}
name|dev
operator|->
name|si_bsize_phys
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d open2: partition=%d disksize=%d blksize=%x flags=%x\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|,
operator|(
name|int
operator|)
name|cd
operator|->
name|disksize
argument_list|,
name|cd
operator|->
name|blksize
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
operator|&&
name|lock
condition|)
block|{
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Lock drive*/
name|cmd
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*<15>Issue cmd*/
name|cd
operator|->
name|flags
operator||=
name|MATCDLOCK
expr_stmt|;
comment|/*<15>Drive is now locked*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|openflags
operator||=
operator|(
literal|1
operator|<<
operator|(
name|partition
operator|+
name|lock
operator|)
operator|)
expr_stmt|;
comment|/*<24>Mark partition open*/
if|if
condition|(
name|partition
operator|==
name|RAW_PART
operator|||
operator|(
name|partition
operator|<
name|cd
operator|->
name|dlabel
operator|.
name|d_npartitions
operator|&&
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
index|[
name|partition
index|]
operator|.
name|p_fstype
operator|!=
name|FS_UNUSED
operator|)
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDOPEN
expr_stmt|;
if|if
condition|(
name|partition
operator|==
name|RAW_PART
condition|)
block|{
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator||=
name|MATCDREADRAW
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open is complete - openflags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|cd
operator|->
name|openflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Open FAILED\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdclose - Close the device  	Close may not do much other than clear some driver settings. 	Note that audio playback will continue.<15>	If you define LOCKDRIVE, and the drive has been opened using<15>	one of the locking minor numbers, code in close will unlock<15>	the drive. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|port
decl_stmt|,
name|partition
decl_stmt|,
name|controller
decl_stmt|,
name|lock
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKDRIVE
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|lock
operator|=
name|matcd_lockable
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Close partition=%d flags %x openflags %x partflags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|partition
argument_list|,
name|cd
operator|->
name|flags
argument_list|,
name|cd
operator|->
name|openflags
argument_list|,
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDINIT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|cd
operator|->
name|partflags
index|[
name|partition
index|]
operator|&=
operator|~
operator|(
name|MATCDOPEN
operator||
name|MATCDREADRAW
operator|)
expr_stmt|;
name|cd
operator|->
name|openflags
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|partition
operator|+
name|lock
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|openflags
operator|==
literal|0
condition|)
block|{
comment|/*<24>Really last close?*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLOCK
condition|)
block|{
comment|/*<24>Was drive locked?*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Yes, so unlock it*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDWARN
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*<15>Clear warning flag*/
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdstrategy - Accepts I/O requests from kernel for processing  	This routine accepts a read request block pointer (historically 	but somewhat inaccurately called *bp for buffer pointer). 	Various sanity checks are performed on the request. 	When we are happy with the request and the state of the device, 	the request is added to the queue of requests for the interface 	that the drive is connected to.  We support multiple interfaces 	so there are multiple queues.  Once the request is added, we 	call the matcd_start routine to start the device in case it isn't 	doing something already.   All I/O including ioctl requests 	rely on the current request starting the next one before exiting. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcdstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|controller
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|matcd_controller
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Strategy: buf=0x%lx, block#=%ld bcount=%ld\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|bp
argument_list|,
name|bp
operator|->
name|bio_blkno
argument_list|,
name|bp
operator|->
name|bio_bcount
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|ldrive
operator|>=
name|TOTALDRIVES
operator|||
name|bp
operator|->
name|bio_blkno
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Bogus parameters received - kernel may be corrupted\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
comment|/*Request is zero-length - all done*/
goto|goto
name|done
goto|;
if|if
condition|(
name|matcd_partition
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
block|{
if|if
condition|(
name|bounds_check_with_label
argument_list|(
name|bp
argument_list|,
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
name|bp
operator|->
name|bio_pblkno
operator|=
name|bp
operator|->
name|bio_blkno
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*Make sure we don't get intr'ed*/
name|bioqdisksort
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/*Add new request (bp) to queue (dp 					  and sort the requests in a way that 					  may not be ideal for CD-ROM media*/
name|matcd_start
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|/*Ok, with our newly sorted queue, 					  see if we can start an I/O operation 					  right now*/
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*Return priorities to normal*/
return|return;
comment|/*All done*/
name|bad
label|:
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
comment|/*Request bad in some way*/
name|done
label|:
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
comment|/*Show amount of data un read*/
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*Signal we have done all we plan to*/
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_start - Pull a request from the queue and consider doing it. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_start
parameter_list|(
name|int
name|controller
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|partition
modifier|*
name|p
decl_stmt|;
name|int
name|part
decl_stmt|,
name|ldrive
decl_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/*Nothing on read queue to do?*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup any blocked*/
return|return;
comment|/* opens, ioctls, etc*/
block|}
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
comment|/*Get logical drive#*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
comment|/*Get pointer to data for this drive*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In start controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSBUSY
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Dropping thread in start,  controller %d\n"
argument_list|,
name|ldrive
argument_list|,
name|controller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
return|return;
block|}
comment|/*	Ok, the controller is idle (not necessarily the drive) and so 	get the command to do and issue it */
name|bioq_remove
argument_list|(
operator|&
name|request_head
index|[
name|controller
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|part
operator|=
name|matcd_partition
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|cd
operator|->
name|dlabel
operator|.
name|d_partitions
operator|+
name|part
expr_stmt|;
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSBUSY
expr_stmt|;
comment|/*<18>Mark bus as busy*/
name|cd
operator|->
name|mbx
operator|.
name|ldrive
operator|=
name|ldrive
expr_stmt|;
comment|/*Save current logical drive*/
name|cd
operator|->
name|mbx
operator|.
name|controller
operator|=
name|controller
expr_stmt|;
comment|/*and controller*/
name|cd
operator|->
name|mbx
operator|.
name|partition
operator|=
name|part
expr_stmt|;
comment|/*and partition (2048 vs 2532)*/
name|cd
operator|->
name|mbx
operator|.
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*and port#*/
name|cd
operator|->
name|mbx
operator|.
name|iftype
operator|=
name|cd
operator|->
name|iftype
expr_stmt|;
comment|/*<20>interface type*/
name|cd
operator|->
name|mbx
operator|.
name|retry
operator|=
name|MATCD_RETRYS
expr_stmt|;
comment|/*and the retry count*/
name|cd
operator|->
name|mbx
operator|.
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*and the bp*/
name|cd
operator|->
name|mbx
operator|.
name|p_offset
operator|=
name|p
operator|->
name|p_offset
expr_stmt|;
comment|/*and where the data will go*/
name|matcd_blockread
argument_list|(
name|MATCD_READ_1
operator|+
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Actually start the read*/
return|return;
comment|/*Dropping thread.  matcd_blockread 					  must have scheduled a timeout or 					  we will go to sleep forever*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdioctl - Process things that aren't block reads  	In this driver, ioctls are used mainly to change 	the mode the drive is running in, play audio and other 	things that don't fit into the block read scheme of things. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|,
name|partition
decl_stmt|;
name|int
name|port
decl_stmt|,
name|controller
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cdrive
operator|=
name|matcd_cdrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|partition
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|controller
operator|=
name|ldrive
operator|>>
literal|2
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"matcd%d: ioctl %lx cdrive %x parms "
argument_list|,
name|ldrive
argument_list|,
name|command
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  flags %x\n"
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|command
operator|==
name|CDIOCCLOSE
condition|)
comment|/*<16>Allow close if door open*/
return|return
operator|(
name|matcd_doorclose
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
condition|)
comment|/*Did we read TOC OK?*/
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*<16>then drive really isn't ready*/
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|DIOCGDINFO
case|:
operator|*
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
operator|=
name|cd
operator|->
name|dlabel
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|DIOCWDINFO
case|:
case|case
name|DIOCSDINFO
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
else|else
block|{
return|return
name|setdisklabel
argument_list|(
operator|&
name|cd
operator|->
name|dlabel
argument_list|,
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
return|;
block|}
case|case
name|DIOCWLABEL
case|:
return|return
operator|(
name|EBADF
operator|)
return|;
case|case
name|CDIOCEJECT
case|:
return|return
operator|(
name|matcd_eject
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
case|case
name|CDIOCALLOW
case|:
return|return
operator|(
name|matcd_dlock
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|CDIOCPREVENT
case|:
return|return
operator|(
name|matcd_dlock
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|MATCDLOCK
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|FULLDRIVER
case|case
name|CDIOCPLAYTRACKS
case|:
return|return
operator|(
name|matcd_playtracks
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_track
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPLAYMSF
case|:
return|return
operator|(
name|matcd_playmsf
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_play_msf
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCRESUME
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|RESUME
argument_list|)
operator|)
return|;
case|case
name|CDIOCPAUSE
case|:
return|return
operator|(
name|matcd_pause
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|CDIOCSTOP
case|:
return|return
operator|(
name|matcd_stop
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|)
operator|)
return|;
case|case
name|CDIOCGETVOL
case|:
case|case
name|CDIOCSETVOL
case|:
return|return
operator|(
name|matcd_level
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_vol
operator|*
operator|)
name|addr
argument_list|,
name|command
argument_list|)
operator|)
return|;
case|case
name|CDIOCSETMONO
case|:
comment|/*<12>This drive can't do mono*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*<12>but it looks like it should*/
comment|/*<12>SRC OUT	SRC OUT*/
case|case
name|CDIOCSETSTEREO
case|:
comment|/*<12>0 -> L	1 -> R*/
case|case
name|CDIOCSETMUTE
case|:
comment|/*<12>0 -> NULL	1 -> NULL*/
case|case
name|CDIOCSETLEFT
case|:
comment|/*<12>0 -> L&R	1 -> NULL*/
case|case
name|CDIOCSETRIGHT
case|:
comment|/*<12>0 -> NULL	1 -> L&R*/
comment|/*<12>Adjust audio routing*/
return|return
operator|(
name|matcd_route
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|command
argument_list|)
operator|)
return|;
case|case
name|CDIOCSETPATCH
case|:
comment|/*<12>Allow precise routing*/
return|return
operator|(
name|matcd_patch
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_patch
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCPITCH
case|:
comment|/*<12>Adjust playback speed*/
return|return
operator|(
name|matcd_pitch
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_pitch
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCSTART
case|:
comment|/*<12>Only reason this isn't*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*<12>implemented is I can't find out*/
comment|/*<12>what it should do!*/
endif|#
directive|endif
comment|/*FULLDRIVER*/
case|case
name|CDIOREADTOCHEADER
case|:
return|return
operator|(
name|matcd_toc_header
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_toc_header
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOREADTOCENTRYS
case|:
return|return
operator|(
name|matcd_toc_entries
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_read_toc_entry
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOREADTOCENTRY
case|:
return|return
operator|(
name|matcd_toc_entry
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_read_toc_single_entry
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCREADSUBCHANNEL
case|:
return|return
operator|(
name|matcd_read_subq
argument_list|(
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
operator|(
expr|struct
name|ioc_read_subchannel
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCCAPABILITY
case|:
comment|/*<16>Request drive/driver capability*/
return|return
operator|(
name|matcd_igot
argument_list|(
operator|(
expr|struct
name|ioc_capability
operator|*
operator|)
name|addr
argument_list|)
operator|)
return|;
case|case
name|CDIOCRESET
case|:
comment|/*<12>There is no way to hard reset*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*<12>just one drive*/
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcdsize - Reports how many blocks exist on the disc. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|size
decl_stmt|,
name|blksize
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|part
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|ldrive
operator|=
name|matcd_ldrive
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|part
operator|=
name|matcd_partition
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|==
name|RAW_PART
condition|)
name|blksize
operator|=
name|MATCDRBLK
expr_stmt|;
comment|/*2352*/
else|else
name|blksize
operator|=
name|MATCDBLK
expr_stmt|;
comment|/*2048*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
if|if
condition|(
name|matcd_volinfo
argument_list|(
name|ldrive
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|cd
operator|->
name|blksize
operator|=
name|blksize
expr_stmt|;
name|size
operator|=
name|msf_to_blk
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
name|cd
operator|->
name|disksize
operator|=
name|size
operator|*
operator|(
name|blksize
operator|/
name|DEV_BSIZE
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Media size %d\n"
argument_list|,
name|ldrive
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_probe - Search for host interface/adapters  	The probe routine hunts for the first drive on the interface since 	there is no way to locate just the adapter.   It also resets the 	entire drive chain while it is there.  matcd_attach() takes care of 	the rest of the initialization.  	The probe routine can be compiled two ways.  In AUTOHUNT mode, 	the kernel config file can say "port?" and we will check all ports 	listed in the port_hint array (see above).  	Without AUTOHUNT set, the config file must list a specific port 	address to check.  	Note that specifying the explicit addresses makes boot-up a lot 	faster.  	The probe will locate Panasonic/Creative interface on the following 	Creative adapter boards: 		#1330A	Sound Blaster PRO 		#1730	Sound Blaster 16 		#1740	Sound Blaster 16 (cost reduced) 		#2230	Sound Blaster 16 (cost reduced) 		#2770	Sound Blaster 16 Value (cost reduced) 		#1810	omniCD upgrade kit adapter card (stand-alone CD) 		#3100	PhoneBlaster SB16 + Sierra 14.4K modem combo 	Creative releases a newer and cheaper-to-make Sound Blaster 	board every few months, so by the original release date of this 	software, there are probably 8 different board models called 	Sound Blaster 16.  These include "Vibra", "Value", etc.  	Please report additional part numbers and board descriptions 	and new port numbers that work to the author.  ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|y
decl_stmt|;
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
comment|/*Take port hint from config file*/
name|cdrive
operator|=
name|nextcontroller
expr_stmt|;
comment|/*Controller defined by pass for now*/
if|if
condition|(
name|nextcontroller
operator|==
name|NUMCTRLRS
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: - Too many interfaces specified in config\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nextcontroller
operator|==
literal|0
condition|)
block|{
comment|/*Very first time to be called*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TOTALDRIVES
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
name|matcd_data
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|i
operator|=
name|nextcontroller
operator|*
name|DRIVESPERC
expr_stmt|;
comment|/*Precompute controller offset*/
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|DRIVESPERC
condition|;
name|y
operator|++
control|)
block|{
name|matcd_data
index|[
name|i
operator|+
name|y
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: In probe i %d y %d port %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|i
argument_list|,
name|y
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
ifdef|#
directive|ifdef
name|AUTOHUNT
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: size of port_hints %d\n"
argument_list|,
name|nextcontroller
argument_list|,
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|port_hints
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|port
operator|=
name|port_hints
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Port hint %x\n"
argument_list|,
name|nextcontroller
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Nothing left to try*/
block|}
if|if
condition|(
name|port
operator|!=
literal|0
condition|)
block|{
comment|/*Untested port found*/
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Don't use that port again*/
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
block|}
block|}
name|dev
operator|->
name|id_iobase
operator|=
operator|-
literal|1
expr_stmt|;
comment|/*Put port ? back as it was*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Interface not found*/
block|}
else|else
block|{
comment|/*Config specified a port*/
name|i
operator|=
literal|0
expr_stmt|;
comment|/*so eliminate it from the hint list*/
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
comment|/*or we might try to assign it again*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/*End of list*/
if|if
condition|(
name|port_hints
index|[
name|i
index|]
operator|==
name|port
condition|)
block|{
name|port_hints
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Clear duplicate*/
break|break;
block|}
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|#
directive|else
comment|/*AUTOHUNT*/
if|if
condition|(
name|port
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: AUTOHUNT disabled but port? specified in config\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|doprobe
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NUMPORTS
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/*AUTOHUNT*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	doprobe - Common probe code that actually checks the ports we 		have decided to test.<20>	Edit 20 changes adds code to determine if the host interface 	is one that behaves like the Creative SoundBlaster cards, 	or whether the host interface like those used by some boards 	made by Media Vision and a version known as Lasermate. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|doprobe
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|RESETONBOOT
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
endif|#
directive|endif
comment|/*RESETONBOOT*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*<16>Guarantee status phase*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 				  	  This command will fail after 				  	  power-up or after reset. That's OK*/
ifdef|#
directive|ifdef
name|RESETONBOOT
if|if
condition|(
operator|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|||
operator|(
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
operator|!=
literal|0xff
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/*<20>Something detected but it isn't 					      the device we wanted*/
endif|#
directive|endif
comment|/*RESETONBOOT*/
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue command*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*<20>Switch to Creative Data phase*/
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*<20>Read a byte in data phase*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*<20>Switch to Creative Status phase*/
if|if
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
comment|/*<20>Drive went idle*/
name|iftype
operator|=
literal|1
expr_stmt|;
comment|/*<20>It is not a Creative interface.*/
block|}
else|else
block|{
comment|/*<20>Status byte still available*/
name|iftype
operator|=
literal|0
expr_stmt|;
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*<20>Read status byte*/
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Probe found something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
comment|/*------Don't change anything below this line - see license -----------------*/
if|if
condition|(
name|drivepresent
operator|==
literal|0
condition|)
block|{
comment|/*Don't change*/
name|printf
argument_list|(
literal|"matcd - Matsushita (Panasonic) CD-ROM Driver by FDIV, %s\n"
argument_list|,
comment|/*Don't change*/
name|MATCDVERSION
argument_list|)
expr_stmt|;
comment|/*Don't change*/
name|drivepresent
operator|++
expr_stmt|;
comment|/*Don't change*/
if|if
condition|(
name|drivepresent
operator|==
literal|0
condition|)
comment|/*Don't change - make LINT happy*/
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|MATCDCOPYRIGHT
argument_list|)
expr_stmt|;
comment|/*Don't change*/
block|}
comment|/*Don't change*/
comment|/*------Don't change anything above this line - see license -----------------*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive 0 detected*/
block|}
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Probe DID NOT find something\n"
argument_list|,
name|nextcontroller
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_attach - Locates drives on the adapters that were located. 		If we got here, we located an interface and at least one 		drive.  Now we figure out how many drives are under that 		interface.  The Panasonic interface is too simple to call 		it a controller, but in the existing PDP model, that is 		what it would be. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
init|=
name|dev
operator|->
name|id_iobase
decl_stmt|;
comment|/*Take port ID selected in probe()*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd: Attach dev %x id_unit %d\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dev
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
name|printf
argument_list|(
literal|"matcd%d Host interface type %d\n"
argument_list|,
name|nextcontroller
argument_list|,
name|iftype
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|request_head
index|[
name|nextcontroller
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|cdrive
operator|=
literal|0
init|;
name|cdrive
operator|<
literal|4
condition|;
name|cdrive
operator|++
control|)
block|{
comment|/*We're hunting drives...*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|NOP
expr_stmt|;
comment|/*A reasonably harmless command. 					  This command will fail after 					  power-up or after reset. It's OK*/
name|i
operator|=
name|cdrive
operator|+
operator|(
name|DRIVESPERC
operator|*
name|nextcontroller
operator|)
expr_stmt|;
if|if
condition|(
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/*Issue cmd*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*If there was an error, 						  we must ask for error info 						  or subsequent cmds fail*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Inquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGPROBE
name|printf
argument_list|(
literal|"matcd%d: Status byte %x "
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGPROBE*/
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READID
expr_stmt|;
comment|/*Get drive ID*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|i
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|10
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read Drive Parm*/
name|get_stat
argument_list|(
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
name|data
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
comment|/*Build ASCIZ string*/
name|printf
argument_list|(
literal|"matcd%d: [%s]  "
argument_list|,
name|i
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|i
index|]
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDINIT
expr_stmt|;
name|cd
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
name|cd
operator|->
name|iftype
operator|=
name|iftype
expr_stmt|;
name|cd
operator|->
name|openflags
operator|=
literal|0
expr_stmt|;
name|cd
operator|->
name|volume
index|[
literal|0
index|]
operator|=
name|cd
operator|->
name|volume
index|[
literal|1
index|]
operator|=
name|DEFVOL
expr_stmt|;
comment|/*<12>Match volume drive resets to*/
name|cd
operator|->
name|patch
index|[
literal|0
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/*<12>Channel 0 to Left*/
name|cd
operator|->
name|patch
index|[
literal|1
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/*<12>Channel 1 to Right*/
name|cd
operator|->
name|status
operator|=
name|CD_AS_NO_STATUS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXPARTITIONS
condition|;
name|i
operator|++
control|)
block|{
name|cd
operator|->
name|partflags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rmatcd%da"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
name|dkmakeminor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rmatcd%dc"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
literal|0x80
operator||
name|dkmakeminor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rmatcd%dla"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|make_dev
argument_list|(
operator|&
name|matcd_cdevsw
argument_list|,
literal|0x80
operator||
name|dkmakeminor
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rmatcd%dc"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|nextcontroller
operator|++
expr_stmt|;
comment|/*Bump ctlr assign to next number*/
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/*End line of drive reports*/
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	zero_cmd - Initialize command buffer ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|zero_cmd
parameter_list|(
name|char
modifier|*
name|lcmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCMDSIZ
condition|;
name|lcmd
index|[
name|i
operator|++
index|]
operator|=
literal|0
control|)
empty_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	doreset - Resets all the drives connected to a interface ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|doreset
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|RESET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Reset what might be our device*/
comment|/*Although this ensures a known 					  state, it does close the drive 					  door (if open) and aborts any 					  audio playback in progress. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|125
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/*DELAY 500msec minimum. Worst 					  case is door open and none or 					  unreadable media */
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
comment|/*This makes the loop run at a 					  known speed.  This value is ok 					  for 8.33MHz bus*/
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|matcd_data
index|[
operator|(
name|cdrive
operator|*
literal|4
operator|)
operator|+
name|i
index|]
operator|.
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_fastcmd - Send a command to a drive  	This routine executed commands that return instantly (or reasonably 	quick), such as RESET, NOP, READ ERROR, etc.  The only difference 	between it and handling for slower commands, is the slower commands 	will invoke a timeout/sleep if they don't get an instant response.  	Fastcmd is mainly used in probe(), attach() and error related 	functions.  Every attempt should be made to NOT use this 	function for any command that might be executed when the system 	is up. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_fastcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|z
decl_stmt|;
name|int
name|level
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure bus is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Fast Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
name|level
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*----------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|splx
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------*/
comment|/*	Now we wait a maximum of 240msec for a response. 	Only in a few rare cases does it take this long. 	If it is longer, the command should probably be slept on 	rather than increasing the timing value */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|60
operator|*
name|ISABUSKHZ
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|z
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
if|if
condition|(
name|z
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
break|break;
block|}
comment|/*	We are now either in a data or status phase, OR we timed-out.*/
if|if
condition|(
name|z
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Command time-out\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|z
operator|!=
name|DTEN
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_slowcmd - Issue a command to the drive  	This routine is for commands that might take a long time, such 	as a read or seek.  The caller must determine if the command 	completes instantly or schedule a poll later on. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_slowcmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|unsigned
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|level
decl_stmt|,
name|size
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|unsigned
name|char
modifier|*
name|cx
decl_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|draincmd
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Make sure bus is really idle*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|cx
operator|=
name|cp
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: Slow Send port %x sel %d command %x %x %x %x %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|,
name|cdrive
argument_list|,
name|cx
index|[
literal|0
index|]
argument_list|,
name|cx
index|[
literal|1
index|]
argument_list|,
name|cx
index|[
literal|2
index|]
argument_list|,
name|cx
index|[
literal|3
index|]
argument_list|,
name|cx
index|[
literal|4
index|]
argument_list|,
name|cx
index|[
literal|5
index|]
argument_list|,
name|cx
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|selectdrive
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
comment|/*Enable the desired target drive*/
if|if
condition|(
operator|*
name|cp
operator|==
name|ABORT
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
name|size
operator|=
literal|7
expr_stmt|;
name|level
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/*----------------------------------------*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
comment|/*The seven bytes of the command*/
name|outb
argument_list|(
name|port
operator|+
name|CMD
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/*must be sent within 10msec or*/
block|}
comment|/*the drive will ignore the cmd*/
name|splx
argument_list|(
name|level
argument_list|)
expr_stmt|;
comment|/*------------------------------------------------*/
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	draincmd - Makes certain the bus is idle and throws away 		any residual data from the drive if there is any. 		Called as preface to most commands. 		Added in Edit 5.  		This was added because switching drive modes causes 		the drive to emit buffers that were meant to be sent 		to the D-to-A to be sent to the host.  See setmode. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|draincmd
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|z
decl_stmt|;
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
return|return;
name|printf
argument_list|(
literal|"matcd%d: in draincmd: bus not idle %x - trying to fix\n"
argument_list|,
name|ldrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Data present READING - "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*<16>Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*<21>Ok for Creative*/
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
comment|/*<21>Ok for others*/
name|i
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"%d bytes read\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Now read status: "
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|i
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|z
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
comment|/*Read bus status*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"Data byte %x and status is now %x\n"
argument_list|,
name|i
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
operator|(
name|z
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: Bus not idle %x - resetting\n"
argument_list|,
name|cdrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|doreset
argument_list|(
name|port
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	selectdrive - Swaps drive select bits  	On Creative SB/SB16/stand-alone adapters, possibly to make them 	hard to reverse engineer, the drive select signals are swapped. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|selectdrive
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|drive
parameter_list|)
block|{
switch|switch
condition|(
name|drive
condition|)
block|{
case|case
literal|0
case|:
comment|/*0x00 -> 0x00*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*0x01 -> 0x02*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/*0x02 -> 0x01*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/*0x03 -> 0x03*/
name|outb
argument_list|(
name|port
operator|+
name|SELECT
argument_list|,
name|CRDRIVE3
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_pread - Read small blocks of control data from a drive ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|matcd_pread
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|data
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|CMD
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_setmode - Configures disc to run in the desired data mode  	This routine assumes the drive is already idle.  NOTE -	Undocumented action of hardware:  If you change (or reaffirm) data 	modes with MODESELECT + BLOCKPARAM immediately after a command was 	issued that aborted a DA play operation, the drive will unexpectedly 	return 2532 bytes of data in a data phase on the first or second 	subsequent command.  	Original Symptom: drive will refuse to go idle after reading data 	and status expected for a command.  State mechanics for this are 	not fully understood. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_setmode
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|i
decl_stmt|,
name|port
decl_stmt|,
name|cdrive
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
name|matcd_data
operator|+
name|ldrive
expr_stmt|;
name|retries
operator|=
literal|3
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|drivemode
operator|==
name|mode
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Drive already set*/
block|}
comment|/*	The drive is not in the right mode, so we need to set it. */
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|MODESELECT
expr_stmt|;
comment|/*Set drive transfer modes*/
comment|/*	cmd[1]=BLOCKPARAM;		  BLOCKPARAM==0*/
name|cmd
index|[
literal|2
index|]
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|MODE_DATA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x08
expr_stmt|;
comment|/*2048 bytes*/
break|break;
case|case
name|MODE_USER
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
case|case
name|MODE_DA
case|:
name|cmd
index|[
literal|3
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/*2352 bytes*/
name|cmd
index|[
literal|4
index|]
operator|=
literal|0x30
expr_stmt|;
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read and toss status byte*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cd
operator|->
name|drivemode
operator|=
name|mode
expr_stmt|;
comment|/*Set new mode*/
return|return
operator|(
name|i
operator|)
return|;
block|}
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
block|}
name|cd
operator|->
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
comment|/*We failed*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_volinfo - Read information from disc Table of Contents ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_volinfo
parameter_list|(
name|int
name|ldrive
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|port
decl_stmt|,
name|i
decl_stmt|;
name|int
name|z
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|retry
operator|=
literal|10
expr_stmt|;
comment|/*<16>This may take a long time*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: In volinfo, port %x\n"
argument_list|,
name|ldrive
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
while|while
condition|(
name|retry
operator|>
literal|0
condition|)
block|{
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READDINFO
expr_stmt|;
comment|/*Read Disc Info*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matvinf"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
comment|/*THIS SHOULD NOT HAPPEN*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|6
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Data got was %x %x %x %x %x %x   "
argument_list|,
name|ldrive
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status byte %x\n"
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/*No Error*/
comment|/*	If media change or other error, you have to read error data or 	the drive will reject subsequent commands. */
if|if
condition|(
name|chk_error
argument_list|(
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
argument_list|)
operator|==
name|ERR_FATAL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: command failed, status %x\n"
argument_list|,
name|ldrive
argument_list|,
name|z
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
literal|"matvi2"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|retry
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Retrying"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
block|}
ifdef|#
directive|ifdef
name|DEBUGOPEN
name|printf
argument_list|(
literal|"matcd%d: Status port %x  \n"
argument_list|,
name|ldrive
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGOPEN*/
name|cd
operator|->
name|volinfo
operator|.
name|type
operator|=
name|data
index|[
literal|0
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
if|if
condition|(
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|+
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|)
block|{
name|cd
operator|->
name|flags
operator||=
name|MATCDLABEL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	blk_to_msf - Convert block numbers into CD disk block ids ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|blk_to_msf
parameter_list|(
name|int
name|blk
parameter_list|,
name|unsigned
name|char
modifier|*
name|msf
parameter_list|)
block|{
name|blk
operator|=
name|blk
operator|+
literal|150
expr_stmt|;
comment|/*2 seconds skip required to 					  reach ISO data*/
name|msf
index|[
literal|0
index|]
operator|=
name|blk
operator|/
literal|4500
expr_stmt|;
name|blk
operator|=
name|blk
operator|%
literal|4500
expr_stmt|;
name|msf
index|[
literal|1
index|]
operator|=
name|blk
operator|/
literal|75
expr_stmt|;
name|msf
index|[
literal|2
index|]
operator|=
name|blk
operator|%
literal|75
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	msf_to_blk - Convert CD disk block ids into block numbers ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|msf_to_blk
parameter_list|(
name|unsigned
name|char
modifier|*
name|cd
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|cd
index|[
literal|0
index|]
operator|*
literal|60
operator|)
comment|/*Convert MSF to*/
operator|+
name|cd
index|[
literal|1
index|]
operator|)
operator|*
literal|75
comment|/*Blocks minus 2*/
operator|+
name|cd
index|[
literal|2
index|]
operator|-
literal|150
operator|)
return|;
comment|/*seconds*/
block|}
end_function

begin_function
specifier|static
name|void
name|matcd_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|matcd_blockread
argument_list|(
operator|(
name|int
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_blockread - Performs actual background disc I/O operations  	This routine is handed the block number to read, issues the 	command to the drive, waits for it to complete, reads the 	data or error, retries if needed, and returns the results 	to the host. ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|matcd_blockread
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|matcd_mbx
modifier|*
name|mbx
decl_stmt|;
name|int
name|ldrive
decl_stmt|,
name|cdrive
decl_stmt|;
name|int
name|port
decl_stmt|,
name|controller
decl_stmt|;
name|short
name|iftype
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|matcd_read2
name|rbuf
decl_stmt|;
name|int
name|blknum
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|errtyp
decl_stmt|;
name|int
name|phase
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|mbx
operator|=
operator|&
name|matcd_data
index|[
name|state
operator|&
literal|0x0f
index|]
operator|.
name|mbx
expr_stmt|;
name|ldrive
operator|=
name|mbx
operator|->
name|ldrive
expr_stmt|;
comment|/*ldrive is logical drive #*/
name|cdrive
operator|=
name|ldrive
operator|&
literal|0x03
expr_stmt|;
comment|/*cdrive is drive # on a controller*/
name|port
operator|=
name|mbx
operator|->
name|port
expr_stmt|;
comment|/*port is base port for i/f*/
name|iftype
operator|=
name|mbx
operator|->
name|iftype
expr_stmt|;
name|bp
operator|=
name|mbx
operator|->
name|bp
expr_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|controller
operator|=
name|cd
operator|->
name|mbx
operator|.
name|controller
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Show state %x cdrive %d partition %d\n"
argument_list|,
name|ldrive
argument_list|,
name|state
argument_list|,
name|cdrive
argument_list|,
name|mbx
operator|->
name|partition
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|loop
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Top  dp %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
switch|switch
condition|(
name|state
operator|&
literal|0xf0
condition|)
block|{
case|case
name|MATCD_READ_1
case|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: State 1 cd->flags %x\n"
argument_list|,
name|ldrive
argument_list|,
name|cd
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/* to check for raw/cooked mode */
if|if
condition|(
name|cd
operator|->
name|partflags
index|[
name|mbx
operator|->
name|partition
index|]
operator|&
name|MATCDREADRAW
condition|)
block|{
name|mbx
operator|->
name|sz
operator|=
name|MATCDRBLK
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
else|else
block|{
name|mbx
operator|->
name|sz
operator|=
name|cd
operator|->
name|blksize
expr_stmt|;
name|i
operator|=
name|matcd_setmode
argument_list|(
name|ldrive
argument_list|,
name|MODE_DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Set MODE_DATA result %d\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
comment|/*for first block*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: A mbx %x bp %x b_bcount %x sz %x\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mbx
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bp
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bp
operator|->
name|bio_bcount
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|mbx
operator|->
name|nblk
operator|=
operator|(
name|bp
operator|->
name|bio_bcount
operator|+
operator|(
name|mbx
operator|->
name|sz
operator|-
literal|1
operator|)
operator|)
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|mbx
operator|->
name|skip
operator|=
literal|0
expr_stmt|;
name|nextblock
label|:
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: at Nextblock b_blkno %d\n"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|blknum
operator|=
operator|(
name|bp
operator|->
name|bio_blkno
operator|/
operator|(
name|mbx
operator|->
name|sz
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|+
name|mbx
operator|->
name|p_offset
operator|+
name|mbx
operator|->
name|skip
operator|/
name|mbx
operator|->
name|sz
expr_stmt|;
name|blk_to_msf
argument_list|(
name|blknum
argument_list|,
name|rbuf
operator|.
name|start_msf
argument_list|)
expr_stmt|;
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READ
expr_stmt|;
comment|/*Get drive ID*/
name|cmd
index|[
literal|1
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|0
index|]
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|1
index|]
expr_stmt|;
name|cmd
index|[
literal|3
index|]
operator|=
name|rbuf
operator|.
name|start_msf
index|[
literal|2
index|]
expr_stmt|;
name|cmd
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
comment|/*Xfer only one block*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*	Now that we have issued the command, check immediately to 	see if data is ready.   The drive has read-ahead caching, so 	it is possible the data is already in the drive buffer.  	If the data is not ready, schedule a wakeup and later on this 	code will run again to see if the data is ready then. */
case|case
name|MATCD_READ_2
case|:
name|state
operator|=
name|MATCD_READ_2
operator|+
name|ldrive
expr_stmt|;
name|phase
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: In state 2 status %x  "
argument_list|,
name|ldrive
argument_list|,
name|phase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
switch|switch
condition|(
name|phase
condition|)
block|{
case|case
operator|(
name|DTEN
operator||
name|STEN
operator|)
case|:
comment|/*DTEN==H  STEN==H*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Sleeping\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|timeout
argument_list|(
name|matcd_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|MATCD_READ_2
operator|+
name|ldrive
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
return|return;
case|case
name|STEN
case|:
comment|/*DTEN=L STEN=H*/
case|case
literal|0
case|:
comment|/*DTEN=L STEN=L*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Data Phase\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
name|addr
operator|=
name|bp
operator|->
name|bio_data
operator|+
name|mbx
operator|->
name|skip
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Xfer Addr %x  size %x"
argument_list|,
name|ldrive
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
name|mbx
operator|->
name|sz
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/*<20>Reset read count*/
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|iftype
operator|==
literal|0
condition|)
block|{
comment|/*<20>Creative host I/F*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
operator|*
name|addr
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*Disable read*/
block|}
else|else
block|{
comment|/*<20>Not Creative interface*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
operator|*
name|addr
operator|++
operator|=
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|i
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Read %d bytes\n"
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/*	Now, wait for the Status phase to arrive.   This will also 	tell us if any went wrong with the request. */
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
name|DTEN
condition|)
empty_stmt|;
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Status port %x byte %x  "
argument_list|,
name|ldrive
argument_list|,
name|i
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
if|if
condition|(
name|status
operator|&
name|MATCD_ST_ERROR
condition|)
block|{
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading block %d [Soft]\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|i
index|]
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|)
expr_stmt|;
name|media_chk
argument_list|(
name|cd
argument_list|,
name|i
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*<14>was wrong place*/
block|}
if|if
condition|(
operator|--
name|mbx
operator|->
name|nblk
operator|>
literal|0
condition|)
block|{
name|mbx
operator|->
name|skip
operator|+=
name|mbx
operator|->
name|sz
expr_stmt|;
goto|goto
name|nextblock
goto|;
comment|/*Oooooh, you flunk the course*/
block|}
name|bp
operator|->
name|bio_resid
operator|=
literal|0
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/*Signal transfer complete*/
name|unlockbus
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus lock*/
name|matcd_start
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|/*See if other drives have work*/
return|return;
comment|/*	Here we skipped the data phase and went directly to status. 	This indicates a hard error. */
case|case
name|DTEN
case|:
comment|/*DTEN=H STEN=L*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: error, status was %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
comment|/*	Ok, we need more details, so read error.  This is needed to issue 	any further commands anyway */
name|errtyp
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"matcd%d: %s while reading block %d\n"
argument_list|,
name|ldrive
argument_list|,
name|matcderrors
index|[
name|errtyp
index|]
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|media_chk
argument_list|(
name|cd
argument_list|,
name|errtyp
argument_list|,
name|ldrive
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|errtyp
operator|=
name|chk_error
argument_list|(
name|errtyp
argument_list|)
expr_stmt|;
if|if
condition|(
name|errtyp
operator|==
name|ERR_RETRY
condition|)
block|{
comment|/*<14>We can retry*/
comment|/*<14>this error but the drive*/
comment|/*<14>probably has already*/
if|if
condition|(
name|mbx
operator|->
name|retry
operator|--
operator|>
literal|0
condition|)
block|{
name|state
operator|=
name|MATCD_READ_1
operator|+
name|ldrive
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGIO
name|printf
argument_list|(
literal|"matcd%d: Attempting retry\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIO*/
goto|goto
name|loop
goto|;
block|}
block|}
block|}
comment|/*<14>	The other error types are either something very bad or the media<14>	has been removed by the user.  In both cases there is no retry<14>	for this call.  We will invalidate the label in both cases. */
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_ERROR
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|ldrive
operator|>>
literal|2
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|matcd_start
argument_list|(
name|controller
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	docmd - Get the bus, do the command, wait for completion, 		attempt retries, give up the bus. 		For commands that do not return data. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|docmd
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|retries
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|,
name|z
decl_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|retries
operator|=
literal|3
expr_stmt|;
while|while
condition|(
name|retries
operator|--
operator|>
literal|0
condition|)
block|{
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|80
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"matcmd"
argument_list|)
expr_stmt|;
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
operator|==
literal|0
condition|)
break|break;
name|i
operator|=
name|chk_error
argument_list|(
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|ERR_INIT
condition|)
block|{
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	get_error - Read the error that aborted a command. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_error
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|errnum
decl_stmt|;
name|unsigned
name|char
name|cmd1
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|zero_cmd
argument_list|(
name|cmd1
argument_list|)
expr_stmt|;
name|cmd1
index|[
literal|0
index|]
operator|=
name|READERROR
expr_stmt|;
comment|/*Enquire*/
name|matcd_fastcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd1
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|errnum
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Caller wants it classified*/
name|status
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Chkerror found %x on command %x addrval %x statusdata %x statusport %x\n"
argument_list|,
name|ldrive
argument_list|,
name|errnum
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|status
argument_list|,
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
name|errnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	chk_error - Classify the error that the drive reported 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|chk_error
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
switch|switch
condition|(
name|errnum
condition|)
block|{
comment|/*	These are errors we can attempt a retry for, although the drive 	has already done so. */
case|case
name|UNRECV_ERROR
case|:
case|case
name|SEEK_ERROR
case|:
case|case
name|TRACK_ERROR
case|:
case|case
name|FOCUS_ERROR
case|:
case|case
name|CLV_ERROR
case|:
case|case
name|DATA_ERROR
case|:
case|case
name|MODE_ERROR
case|:
comment|/*<16>Make this retryable*/
return|return
operator|(
name|ERR_RETRY
operator|)
return|;
comment|/*	These errors usually indicate the user took the media from the 	drive while the dev was open.  We will invalidate the unit 	until it closes when we see this. */
case|case
name|NOT_READY
case|:
case|case
name|MEDIA_CHANGED
case|:
case|case
name|DISC_OUT
case|:
case|case
name|HARD_RESET
case|:
return|return
operator|(
name|ERR_INIT
operator|)
return|;
comment|/*	These errors indicate the system is confused about the drive 	or media, and point to bugs in the driver or OS.  These errors 	cannot be retried since you will always get the same error. */
case|case
name|RAM_ERROR
case|:
case|case
name|DIAG_ERROR
case|:
case|case
name|CDB_ERROR
case|:
case|case
name|END_ADDRESS
case|:
case|case
name|ILLEGAL_REQ
case|:
case|case
name|ADDRESS_ERROR
case|:
default|default:
return|return
operator|(
name|ERR_FATAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	get_stat - Reads status byte  	This routine should be totally unnecessary, performing the 	task with a single line of in-line code.  However in special 	cases, the drives return blocks of data that are not associated 	with the command in question.  This appears to be at least one 	firmware error and the rest of the driver makes an effort to avoid 	triggering the fault.  However, reading and throwing this 	bogus data is faster and less destructive than resetting all 	the drives on a given controller, plus it leaves the other drives 	unaffected. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|get_stat
parameter_list|(
name|int
name|port
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|busstat
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read status byte, last step of cmd*/
name|busstat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
comment|/*<16>Get bus status - should be 0xff*/
while|while
condition|(
operator|(
name|busstat
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|!=
operator|(
name|DTEN
operator||
name|STEN
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"matcd%d: get_stat: After reading status byte, bus didn't go idle %x %x %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|,
name|busstat
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|busstat
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|int
name|k
decl_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: DATA PRESENT!!!! DISCARDING\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*Enable data read*/
while|while
condition|(
operator|(
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|DTEN
operator||
name|STEN
operator|)
operator|)
operator|==
name|STEN
condition|)
block|{
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|port
operator|+
name|ALTDATA
argument_list|)
expr_stmt|;
comment|/*				printf("%2x ",inb(port+DATA));*/
name|k
operator|++
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|PHASE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"\nmatcd%d: BYTES READ IN DATA was %d\n"
argument_list|,
name|ldrive
argument_list|,
name|k
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
block|}
name|status
operator|=
name|inb
argument_list|(
name|port
operator|+
name|DATA
argument_list|)
expr_stmt|;
comment|/*Read the status byte again*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd%d: Next status byte is %x\n"
argument_list|,
name|ldrive
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
name|busstat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	waitforit - Waits for a command started by slowcmd to complete. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|waitforit
parameter_list|(
name|int
name|timelimit
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|port
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|j
operator|=
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: waitforit port %x timelimit %x hz %x\n"
argument_list|,
name|port
argument_list|,
name|timelimit
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
while|while
condition|(
name|i
operator|<
name|timelimit
condition|)
block|{
name|j
operator|=
name|inb
argument_list|(
name|port
operator|+
name|STATUS
argument_list|)
operator|&
operator|(
name|STEN
operator||
name|DTEN
operator|)
expr_stmt|;
comment|/*Read status*/
if|if
condition|(
name|j
operator|!=
operator|(
name|STEN
operator||
name|DTEN
operator|)
condition|)
break|break;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
name|where
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Count was %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
if|if
condition|(
name|j
operator|==
name|state
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*Command complete*/
ifdef|#
directive|ifdef
name|DEBUGCMD
name|printf
argument_list|(
literal|"matcd: Timeout!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGCMD*/
return|return
operator|(
literal|1
operator|)
return|;
comment|/*Timeout occurred*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	lockbus - Wait for the bus on the requested driver interface 		to go idle and acquire it. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|lockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
while|while
condition|(
operator|(
name|if_state
index|[
name|controller
index|]
operator|&
name|BUSBUSY
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: Can't do it now - going to sleep\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|,
name|PRIBIO
argument_list|,
literal|"matlck"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|if_state
index|[
name|controller
index|]
operator||=
name|BUSBUSY
expr_stmt|;
comment|/*<18>It's ours NOW*/
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: BUS locked in lockbus\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	unlockbus - Release the host interface bus we already have so 		someone else can use it. 	Created in Edit 6 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|unlockbus
parameter_list|(
name|int
name|controller
parameter_list|,
name|int
name|ldrive
parameter_list|)
block|{
name|if_state
index|[
name|controller
index|]
operator|&=
operator|~
name|BUSBUSY
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGSLEEP
name|printf
argument_list|(
literal|"matcd%d: bus unlocked\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGSLEEP*/
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|matcd_data
operator|->
name|status
argument_list|)
expr_stmt|;
comment|/*Wakeup other users*/
name|matcd_start
argument_list|(
name|controller
argument_list|)
expr_stmt|;
comment|/*Wake up any block I/O*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	media_chk - 	Checks error for types related to media 			changes. ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|media_chk
parameter_list|(
name|struct
name|matcd_data
modifier|*
name|cd
parameter_list|,
name|int
name|errnum
parameter_list|,
name|int
name|ldrive
parameter_list|,
name|int
name|test
parameter_list|)
block|{
if|if
condition|(
name|errnum
operator|==
name|NOT_READY
operator|||
name|errnum
operator|==
name|MEDIA_CHANGED
operator|||
name|errnum
operator|==
name|HARD_RESET
operator|||
name|errnum
operator|==
name|DISC_OUT
condition|)
block|{
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLABEL
expr_stmt|;
comment|/*Mark label as invalid*/
if|if
condition|(
name|test
operator|==
literal|0
condition|)
block|{
comment|/*<14>Do warn by default*/
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDWARN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*<14>Msg already?*/
name|printf
argument_list|(
literal|"matcd%d: Media changed - Further I/O aborted until device closed\n"
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
name|cd
operator|->
name|flags
operator||=
name|MATCDWARN
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|errnum
operator|==
name|MODE_ERROR
condition|)
comment|/*<16>Maybe the setting is*/
name|cd
operator|->
name|drivemode
operator|=
name|MODE_UNKNOWN
expr_stmt|;
comment|/*<16>wrong so force a reset*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_eject - Open drive tray ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_eject
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
ifdef|#
directive|ifdef
name|LOCKDRIVE
if|if
condition|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLOCK
condition|)
block|{
comment|/*<15>Drive was locked via open*/
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*<15>so don't allow the eject*/
block|}
endif|#
directive|endif
comment|/*LOCKDRIVE*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*Unlock drive*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cmd
index|[
literal|0
index|]
operator|=
name|DOOROPEN
expr_stmt|;
comment|/*Open Door*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDLABEL
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*<15>Mark vol info invalid*/
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_doorclose - Close drive tray<16>	Added in Edit 16 ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_doorclose
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*Get I/O port base*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|DOORCLOSE
expr_stmt|;
comment|/*Open Door*/
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*Issue command*/
name|cd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MATCDLABEL
operator||
name|MATCDLOCK
operator|)
expr_stmt|;
comment|/*Mark vol info invalid*/
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|nextcontroller
argument_list|,
name|PRIBIO
argument_list|,
literal|"matclos"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
comment|/*Return result we got*/
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------<23>	matcd_dlock - Honor/Reject drive tray requests ---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|matcd_dlock
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|port
decl_stmt|;
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
comment|/*<23>Get I/O port base*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
comment|/*<23>Initialize command buffer*/
name|cmd
index|[
literal|0
index|]
operator|=
name|LOCK
expr_stmt|;
comment|/*<23>Unlock drive*/
if|if
condition|(
name|action
condition|)
block|{
comment|/*<23>They want to lock the door?*/
name|cd
operator|->
name|flags
operator||=
name|MATCDLOCK
expr_stmt|;
comment|/*<23>Remember we did this*/
name|cmd
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/*<23>Lock Door command*/
block|}
else|else
block|{
name|cd
operator|->
name|flags
operator|&=
operator|~
name|MATCDLOCK
expr_stmt|;
comment|/*<23>Remember we did this*/
comment|/*<23>Unlock Door command*/
block|}
name|i
operator|=
name|docmd
argument_list|(
name|cmd
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|controller
argument_list|,
name|port
argument_list|)
expr_stmt|;
comment|/*<23>Issue command*/
return|return
operator|(
name|i
operator|)
return|;
comment|/*<23>Return result we got*/
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_toc_header - Return Table of Contents header to caller<13>	New for Edit 13 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_toc_header
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_toc_header
modifier|*
name|toc
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|toc
operator|->
name|len
operator|=
name|msf_to_blk
argument_list|(
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
argument_list|)
expr_stmt|;
comment|/*In frames*/
name|toc
operator|->
name|starting_track
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
expr_stmt|;
comment|/*1*/
name|toc
operator|->
name|ending_track
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
expr_stmt|;
comment|/*Last track*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_toc_entries - Read all of the TOC entries  	These entries are cached by the drive, but it might be worth 	the space investment to have the driver cache these as well. 	For a disc with 40 tracks, it means 41 command calls to get 	this information from the drive.<13>	New for Edit 13 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_toc_entries
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_entry
modifier|*
name|ioc_entry
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|struct
name|cd_toc_entry
name|entries
index|[
name|MAXTRKS
index|]
decl_stmt|;
name|struct
name|cd_toc_entry
modifier|*
name|from
decl_stmt|;
name|struct
name|cd_toc_entry
modifier|*
name|to
decl_stmt|;
name|int
name|len
decl_stmt|,
name|trk
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|8
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READTOC
expr_stmt|;
for|for
control|(
name|trk
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_low
operator|-
literal|1
init|;
name|trk
operator|<
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
condition|;
name|trk
operator|++
control|)
block|{
name|cmd
index|[
literal|2
index|]
operator|=
name|trk
operator|+
literal|1
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"mats1"
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"Track %d addr/ctrl %x  m %x s %x f %x\n"
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|entries
index|[
name|trk
index|]
operator|.
name|control
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
comment|/*Track type*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr_type
operator|=
name|ioc_entry
operator|->
name|address_format
expr_stmt|;
comment|/*Type*/
name|entries
index|[
name|trk
index|]
operator|.
name|track
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Track #, can be Out of Order*/
if|if
condition|(
name|ioc_entry
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
comment|/*Min*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
comment|/*Sec*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
comment|/*Frame*/
block|}
block|}
name|entries
index|[
name|trk
index|]
operator|.
name|control
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Copy from last valid track*/
name|entries
index|[
name|trk
index|]
operator|.
name|track
operator|=
literal|0xaa
expr_stmt|;
comment|/*<23>Lead-out*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
comment|/*Fill*/
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
expr_stmt|;
name|entries
index|[
name|trk
index|]
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
expr_stmt|;
name|trk
operator|++
expr_stmt|;
comment|/*Bump to include leadout track*/
comment|/*	Now that we have read all the data from the drive, copy the 	array from the kernel address space into the user address space */
name|len
operator|=
name|ioc_entry
operator|->
name|data_len
expr_stmt|;
name|i
operator|=
name|ioc_entry
operator|->
name|starting_track
expr_stmt|;
comment|/*<23>What did they want?*/
if|if
condition|(
name|i
operator|==
literal|0xaa
condition|)
name|i
operator|=
name|trk
operator|-
literal|1
expr_stmt|;
comment|/*<23>Give them lead-out info*/
else|else
name|i
operator|=
name|ioc_entry
operator|->
name|starting_track
operator|-
literal|1
expr_stmt|;
comment|/*<23>start where they asked*/
name|from
operator|=
operator|&
name|entries
index|[
name|i
index|]
expr_stmt|;
name|to
operator|=
name|ioc_entry
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|trk
operator|&&
name|len
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
condition|)
block|{
if|if
condition|(
name|copyout
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|cd_toc_entry
argument_list|)
expr_stmt|;
name|from
operator|++
expr_stmt|;
name|to
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_toc_entriy - Read a single TOC entry ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_toc_entry
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_toc_single_entry
modifier|*
name|ioc_entry
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|trk
decl_stmt|,
name|origtrk
decl_stmt|,
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|5
index|]
decl_stmt|;
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READTOC
expr_stmt|;
name|origtrk
operator|=
name|trk
operator|=
name|ioc_entry
operator|->
name|track
expr_stmt|;
if|if
condition|(
name|trk
operator|==
literal|0xaa
condition|)
comment|/* leadout */
name|trk
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|trk_high
operator|-
literal|1
expr_stmt|;
name|cmd
index|[
literal|2
index|]
operator|=
name|trk
operator|+
literal|1
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"mats1"
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|8
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"Track %d addr/ctrl %x  m %x s %x f %x\n"
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
name|ioc_entry
operator|->
name|entry
operator|.
name|control
operator|=
name|data
index|[
literal|1
index|]
expr_stmt|;
comment|/*Track type*/
name|ioc_entry
operator|->
name|entry
operator|.
name|addr_type
operator|=
name|ioc_entry
operator|->
name|address_format
expr_stmt|;
comment|/*Type*/
name|ioc_entry
operator|->
name|entry
operator|.
name|track
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Track #, can be Out of Order*/
if|if
condition|(
name|ioc_entry
operator|->
name|address_format
operator|==
name|CD_MSF_FORMAT
condition|)
block|{
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
comment|/*Min*/
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
comment|/*Sec*/
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
comment|/*Frame*/
block|}
if|if
condition|(
name|origtrk
operator|==
literal|0xaa
condition|)
block|{
comment|/* Handle leadout */
name|ioc_entry
operator|->
name|entry
operator|.
name|control
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
comment|/*Copy from last valid track*/
name|ioc_entry
operator|->
name|entry
operator|.
name|track
operator|=
literal|0xaa
expr_stmt|;
comment|/*Lead-out*/
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
comment|/*Fill*/
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|minute
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|0
index|]
expr_stmt|;
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|second
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|1
index|]
expr_stmt|;
name|ioc_entry
operator|->
name|entry
operator|.
name|addr
operator|.
name|msf
operator|.
name|frame
operator|=
name|cd
operator|->
name|volinfo
operator|.
name|vol_msf
index|[
literal|2
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_subq - Read the Sub-Q packet - (where are we?)  	This call gives a snapshot state of where the optical 	pick-up is when the command is issued.<14>	New for Edit 14 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_read_subq
parameter_list|(
name|int
name|ldrive
parameter_list|,
name|int
name|cdrive
parameter_list|,
name|int
name|controller
parameter_list|,
name|struct
name|ioc_read_subchannel
modifier|*
name|sqp
parameter_list|)
block|{
name|struct
name|matcd_data
modifier|*
name|cd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|z
decl_stmt|,
name|port
decl_stmt|;
name|unsigned
name|char
name|cmd
index|[
name|MAXCMDSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|data
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|cd_sub_channel_info
name|subq
decl_stmt|;
comment|/*Build result here*/
name|cd
operator|=
operator|&
name|matcd_data
index|[
name|ldrive
index|]
expr_stmt|;
name|port
operator|=
name|cd
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
operator|(
name|cd
operator|->
name|flags
operator|&
name|MATCDLABEL
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/*Refuse after chg error*/
comment|/*	We only support the ioctl functions we could get information 	on, so test for the things we can do */
if|if
condition|(
name|sqp
operator|->
name|data_format
operator|!=
name|CD_CURRENT_POSITION
operator|||
name|sqp
operator|->
name|address_format
operator|!=
name|CD_MSF_FORMAT
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|zero_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|READSUBQ
expr_stmt|;
name|lockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Request bus*/
name|matcd_slowcmd
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/*	While we wait, fill in the hard-coded entries of the table*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|data_format
operator|=
name|CD_MSF_FORMAT
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|unused
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|waitforit
argument_list|(
literal|10
operator|*
name|TICKRES
argument_list|,
name|DTEN
argument_list|,
name|port
argument_list|,
literal|"mats2"
argument_list|)
expr_stmt|;
name|matcd_pread
argument_list|(
name|port
argument_list|,
literal|11
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/*Read data returned*/
name|z
operator|=
name|get_stat
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Read status byte*/
if|if
condition|(
operator|(
name|z
operator|&
name|MATCD_ST_ERROR
operator|)
condition|)
block|{
comment|/*Something went wrong*/
name|i
operator|=
name|get_error
argument_list|(
name|port
argument_list|,
name|ldrive
argument_list|,
name|cdrive
argument_list|)
expr_stmt|;
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|unlockbus
argument_list|(
name|controller
argument_list|,
name|ldrive
argument_list|)
expr_stmt|;
comment|/*Release bus*/
ifdef|#
directive|ifdef
name|DEBUGIOCTL
name|printf
argument_list|(
literal|"Subq track %d index %d adr/ctl %x  abs %d:%2d:%2d  rel %d:%2d:%2d UPC %x\n"
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|4
index|]
argument_list|,
name|data
index|[
literal|5
index|]
argument_list|,
name|data
index|[
literal|6
index|]
argument_list|,
name|data
index|[
literal|7
index|]
argument_list|,
name|data
index|[
literal|8
index|]
argument_list|,
name|data
index|[
literal|9
index|]
argument_list|,
name|data
index|[
literal|10
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUGIOCTL*/
if|if
condition|(
name|z
operator|&
name|MATCD_ST_AUDIOBSY
condition|)
block|{
comment|/*Drive playing or paused*/
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_PAUSED
condition|)
block|{
comment|/*Have we issued*/
name|i
operator|=
name|cd
operator|->
name|status
expr_stmt|;
comment|/*a pause command?*/
block|}
else|else
block|{
name|i
operator|=
name|CD_AS_PLAY_IN_PROGRESS
expr_stmt|;
comment|/*No, we really are playing*/
block|}
block|}
else|else
block|{
if|if
condition|(
name|cd
operator|->
name|status
operator|==
name|CD_AS_PLAY_IN_PROGRESS
condition|)
block|{
comment|/*It was playing*/
name|i
operator|=
name|CD_AS_PLAY_COMPLETED
expr_stmt|;
comment|/*so it finished*/
block|}
else|else
block|{
comment|/*Any other status reported*/
name|i
operator|=
name|cd
operator|->
name|status
expr_stmt|;
comment|/*as we get it*/
block|}
block|}
name|subq
operator|.
name|header
operator|.
name|audio_status
operator|=
name|cd
operator|->
name|status
operator|=
name|i
expr_stmt|;
comment|/*Store status we selected*/
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|track_number
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|index_number
operator|=
name|data
index|[
literal|3
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|4
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|5
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|absaddr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|6
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|minute
operator|=
name|data
index|[
literal|7
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|second
operator|=
name|data
index|[
literal|8
index|]
expr_stmt|;
name|subq
operator|.
name|what
operator|.
name|position
operator|.
name|reladdr
operator|.
name|msf
operator|.
name|frame
operator|=
name|data
index|[
literal|9
index|]
expr_stmt|;
comment|/*	Ok, now copy our nicely-built structure from the kernel address 	space into the user address space (we hope) */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|subq
argument_list|,
name|sqp
operator|->
name|data
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cd_sub_channel_info
argument_list|)
argument_list|,
name|sqp
operator|->
name|data_len
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*--------------------------------------------------------------------------- 	matcd_igot - Like the song, report the capabilities that the 		     drive/driver has available.  	This call returns a structure of flags indicating what 	functions are available so that the application can offer 	only the functions the drive is actually capable of.<16>	New for Edit 16 ---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|matcd_igot
parameter_list|(
name|struct
name|ioc_capability
modifier|*
name|sqp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FULLDRIVER
name|sqp
operator|->
name|play_function
operator|=
operator|(
name|CDDOPLAYTRK
operator||
comment|/*Can play trks/indx*/
name|CDDOPLAYMSF
operator||
comment|/*Can play msf to msf*/
name|CDDOPAUSE
operator||
comment|/*Can pause playback*/
name|CDDORESUME
operator||
comment|/*Can resume playback*/
name|CDDOSTOP
operator||
comment|/*Can stop playback*/
name|CDDOPITCH
operator|)
expr_stmt|;
comment|/*Can change play pitch*/
name|sqp
operator|->
name|routing_function
operator|=
operator|(
name|CDREADVOLUME
operator||
comment|/*Can read volume*/
name|CDSETVOLUME
operator||
comment|/*Can set volume*/
name|CDSETSTEREO
operator||
comment|/*Can select stereo play*/
name|CDSETLEFT
operator||
comment|/*Can select left-only*/
name|CDSETRIGHT
operator||
comment|/*Can select right-only*/
name|CDSETMUTE
operator||
comment|/*Can mute audio*/
name|CDSETPATCH
operator|)
expr_stmt|;
comment|/*Direct patch settings*/
else|#
directive|else
comment|/*FULLDRIVER*/
name|sqp
operator|->
name|play_function
operator|=
literal|0
expr_stmt|;
comment|/*No audio capability*/
name|sqp
operator|->
name|routing_function
operator|=
literal|0
expr_stmt|;
comment|/*No audio capability*/
endif|#
directive|endif
comment|/*FULLDRIVER*/
name|sqp
operator|->
name|special_function
operator|=
operator|(
name|CDDOEJECT
operator||
comment|/*Door can be opened*/
name|CDDOCLOSE
operator||
comment|/*Door can be closed*/
name|CDDOLOCK
operator||
comment|/*Door can be locked*/
name|CDREADSUBQ
operator||
comment|/*Can read subchannel*/
name|CDREADENTRIES
operator||
comment|/*Can read TOC entries*/
name|CDREADHEADER
operator|)
expr_stmt|;
comment|/*Can read TOC*/
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FULLDRIVER
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/matcd/audio.c>
end_include

begin_comment
comment|/*<15>ioctls related to 						      audio are here*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*FULLDRIVER*/
end_comment

begin_comment
comment|/*End of matcd.c*/
end_comment

end_unit

