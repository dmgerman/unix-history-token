begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.  *  * Copyright (C) 1992, 1993 Soeren Schmidt.  *  * All rights reserved.  *  * For the sake of compatibility, portions of this code regarding the  * X server interface are taken from Soeren Schmidt's syscons driver.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by  *	Hellmuth Michaelis, Joerg Wunsch and Soeren Schmidt.  * 4. The name authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * @(#)pcvt_ext.c, 3.20, Last Edit-Date: [Fri Mar 24 20:58:28 1995]  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	pcvt_ext.c	VT220 Driver Extended Support Routines  *	------------------------------------------------------  *  *	-hm	------------ Release 3.00 --------------  *	-hm	integrating NetBSD-current patches  *	-hm	applied Onno van der Linden's patch for Cirrus BIOS upgrade  *	-hm	pcvt_x_hook has to care about fkey labels now  *	-hm	changed some bcopyb's to bcopy's  *	-hm	TS_INDEX -> TS_DATA for cirrus (mail from Onno/Charles)  *	-jw	removed kbc_8042(), and replaced by kbd_emulate_pc()  *	-hm	X server patch from John Kohl<jtk@kolvir.blrc.ma.us>  *	-hm	applying Joerg's patch for FreeBSD 2.0  *	-hm	enable 132 col support for Trident TVGA8900CL  *	-hm	applying patch from Joerg fixing Crtat bug  *	-hm	removed PCVT_FAKE_SYSCONS10  *	-hm	fastscroll/Crtat bugfix from Lon Willett  *	-hm	bell patch from Thomas Eberhardt for NetBSD  *	-hm	multiple X server bugfixes from Lon Willett  *	-hm	patch from John Kohl fixing tsleep bug in usl_vt_ioctl()  *	-hm	bugfix: clear 25th line when switching to a force 24 lines vt  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"vt.h"
end_include

begin_if
if|#
directive|if
name|NVT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"pcvt_hdr.h"
end_include

begin_comment
comment|/* global include */
end_comment

begin_function_decl
specifier|static
name|int
name|s3testwritable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|et4000_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wd90c11_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tri9000_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|v7_1024i_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|s3_928_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|cl_gd542x_col
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* storage to save video timing values of 80 columns text mode */
end_comment

begin_union
specifier|static
union|union
block|{
name|u_char
name|generic
index|[
literal|11
index|]
decl_stmt|;
name|u_char
name|et4000
index|[
literal|11
index|]
decl_stmt|;
name|u_char
name|wd90c11
index|[
literal|12
index|]
decl_stmt|;
name|u_char
name|tri9000
index|[
literal|13
index|]
decl_stmt|;
name|u_char
name|v7_1024i
index|[
literal|17
index|]
decl_stmt|;
name|u_char
name|s3_928
index|[
literal|32
index|]
decl_stmt|;
name|u_char
name|cirrus
index|[
literal|13
index|]
decl_stmt|;
block|}
name|savearea
union|;
end_union

begin_decl_stmt
specifier|static
name|int
name|regsaved
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* registers are saved to savearea */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	Find out which video board we are running on, taken from:  *	Richard Ferraro: Programmers Guide to the EGA and VGA Cards  *	and from David E. Wexelblat's SuperProbe Version 1.0.  *	When a board is found, for which 132 column switching is  *	provided, the global variable "can_do_132col" is set to 1,  *	also the global variable vga_family is set to what we found.  *  *	###############################################################  *	## THIS IS GETTING MORE AND MORE A LARGE SPAGHETTI HACK !!!! ##  *	###############################################################  *  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|u_char
name|vga_chipset
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|u_char
name|byte
decl_stmt|,
name|oldbyte
decl_stmt|,
name|old1byte
decl_stmt|,
name|newbyte
decl_stmt|;
if|#
directive|if
name|PCVT_132GENERIC
name|can_do_132col
operator|=
literal|1
expr_stmt|;
comment|/* assumes everyone can do 132 col */
else|#
directive|else
name|can_do_132col
operator|=
literal|0
expr_stmt|;
comment|/* assumes noone can do 132 col */
endif|#
directive|endif
comment|/* PCVT_132GENERIC */
name|vga_family
operator|=
name|VGA_F_NONE
expr_stmt|;
comment|/*---------------------------------------------------------------------------*  * 	check for Western Digital / Paradise chipsets  *---------------------------------------------------------------------------*/
name|ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Crtat
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|ptr
operator|+=
operator|(
literal|0xc007d
operator|-
literal|0xb8000
operator|)
expr_stmt|;
else|else
name|ptr
operator|+=
operator|(
literal|0xc007d
operator|-
literal|0xb0000
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|ptr
operator|++
operator|==
literal|'V'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|++
operator|==
literal|'G'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|++
operator|==
literal|'A'
operator|)
operator|&&
operator|(
operator|*
name|ptr
operator|++
operator|==
literal|'='
operator|)
condition|)
block|{
name|int
name|wd90c10
decl_stmt|;
name|vga_family
operator|=
name|VGA_F_WD
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2b
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0xaa
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbyte
operator|!=
literal|0xaa
condition|)
return|return
operator|(
name|VGA_PVGA
operator|)
return|;
comment|/* PVGA1A chip */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
operator|&
literal|0xbf
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
operator|&
literal|0x40
expr_stmt|;
if|if
condition|(
name|newbyte
operator|!=
literal|0
condition|)
return|return
operator|(
name|VGA_WD90C00
operator|)
return|;
comment|/* WD90C00 chip */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
operator||
literal|0x40
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
operator|&
literal|0x40
expr_stmt|;
if|if
condition|(
name|newbyte
operator|==
literal|0
condition|)
return|return
operator|(
name|VGA_WD90C00
operator|)
return|;
comment|/* WD90C00 chip */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
name|wd90c10
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
operator|&
literal|0xfb
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
operator|&
literal|0x04
expr_stmt|;
if|if
condition|(
name|newbyte
operator|!=
literal|0
condition|)
name|wd90c10
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
operator||
literal|0x04
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
operator|&
literal|0x04
expr_stmt|;
if|if
condition|(
name|newbyte
operator|==
literal|0
condition|)
name|wd90c10
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|wd90c10
condition|)
return|return
operator|(
name|VGA_WD90C10
operator|)
return|;
else|else
block|{
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_WD90C11
operator|)
return|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	check for Trident chipsets  *---------------------------------------------------------------------------*/
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* chipset type */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
name|old1byte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|(
name|old1byte
operator|^
literal|0x02
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x0b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newbyte
operator|&
literal|0x0f
operator|)
operator|==
literal|0x02
condition|)
block|{
comment|/* is a trident chip */
name|vga_family
operator|=
name|VGA_F_TRI
expr_stmt|;
switch|switch
condition|(
name|byte
condition|)
block|{
case|case
literal|0x01
case|:
return|return
operator|(
name|VGA_TR8800BR
operator|)
return|;
case|case
literal|0x02
case|:
return|return
operator|(
name|VGA_TR8800CS
operator|)
return|;
case|case
literal|0x03
case|:
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_TR8900B
operator|)
return|;
case|case
literal|0x04
case|:
case|case
literal|0x13
case|:
comment|/* Haven't tried, but should work */
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_TR8900C
operator|)
return|;
case|case
literal|0x23
case|:
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_TR9000
operator|)
return|;
case|case
literal|0x33
case|:
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_TR8900CL
operator|)
return|;
case|case
literal|0x83
case|:
return|return
operator|(
name|VGA_TR9200
operator|)
return|;
case|case
literal|0x93
case|:
return|return
operator|(
name|VGA_TR9100
operator|)
return|;
default|default:
return|return
operator|(
name|VGA_TRUNKNOWN
operator|)
return|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	check for Tseng Labs ET3000/4000 chipsets  *---------------------------------------------------------------------------*/
name|outb
argument_list|(
name|GN_HERCOMPAT
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|outb
argument_list|(
name|GN_DMCNTLC
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|GN_DMCNTLM
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
comment|/* read old value */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MISC
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
comment|/* write new value */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MISC
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|oldbyte
operator|^
literal|0x10
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
name|newbyte
argument_list|)
expr_stmt|;
comment|/* read back new value */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MISC
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
comment|/* write back old value */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MISC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|==
name|newbyte
condition|)
comment|/* ET3000 or ET4000 */
block|{
name|vga_family
operator|=
name|VGA_F_TSENG
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_EXTSTART
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|oldbyte
operator|^
literal|0x0f
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|newbyte
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|==
name|newbyte
condition|)
block|{
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_ET4000
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|VGA_ET3000
operator|)
return|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	check for Video7 VGA chipsets  *---------------------------------------------------------------------------*/
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* enable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xea
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRH
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x55
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_V7ID
argument_list|)
expr_stmt|;
comment|/* id register */
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* read id */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* disable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xae
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|==
operator|(
literal|0x55
operator|^
literal|0xea
operator|)
condition|)
block|{
comment|/* is Video 7 */
name|vga_family
operator|=
name|VGA_F_V7
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* enable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xea
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_V7CHIPREV
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* disable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xae
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte
operator|<
literal|0xff
operator|&&
name|byte
operator|>=
literal|0x80
condition|)
return|return
operator|(
name|VGA_V7VEGA
operator|)
return|;
if|if
condition|(
name|byte
operator|<
literal|0x7f
operator|&&
name|byte
operator|>=
literal|0x70
condition|)
return|return
operator|(
name|VGA_V7FWVR
operator|)
return|;
if|if
condition|(
name|byte
operator|<
literal|0x5a
operator|&&
name|byte
operator|>=
literal|0x50
condition|)
return|return
operator|(
name|VGA_V7V5
operator|)
return|;
if|if
condition|(
name|byte
operator|<
literal|0x4a
operator|&&
name|byte
operator|>
literal|0x40
condition|)
block|{
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|VGA_V71024I
operator|)
return|;
block|}
return|return
operator|(
name|VGA_V7UNKNOWN
operator|)
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	check for S3 chipsets  *---------------------------------------------------------------------------*/
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
comment|/* reg 1 lock register */
name|old1byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get old value */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* lock registers */
if|if
condition|(
name|s3testwritable
argument_list|()
operator|==
literal|0
condition|)
comment|/* check if locked */
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/* unlock registers */
if|if
condition|(
name|s3testwritable
argument_list|()
operator|==
literal|1
condition|)
comment|/* check if unlocked */
block|{
name|vga_family
operator|=
name|VGA_F_S3
expr_stmt|;
comment|/* FAMILY S3  */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* chip id/rev reg */
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|byte
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x80
case|:
switch|switch
condition|(
name|byte
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0x01
case|:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
return|return
name|VGA_S3_911
return|;
case|case
literal|0x02
case|:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
return|return
name|VGA_S3_924
return|;
default|default:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
return|return
name|VGA_S3_UNKNOWN
return|;
block|}
break|break;
case|case
literal|0xA0
case|:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
return|return
name|VGA_S3_80x
return|;
case|case
literal|0x90
case|:
case|case
literal|0xb0
case|:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
name|can_do_132col
operator|=
literal|1
expr_stmt|;
return|return
name|VGA_S3_928
return|;
default|default:
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old1byte
argument_list|)
expr_stmt|;
return|return
name|VGA_S3_UNKNOWN
return|;
block|}
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	check for Cirrus chipsets  *---------------------------------------------------------------------------*/
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|oldbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|newbyte
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x27
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|oldbyte
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbyte
operator|==
literal|0x12
condition|)
block|{
name|vga_family
operator|=
name|VGA_F_CIR
expr_stmt|;
name|can_do_132col
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
operator|(
name|byte
operator|&
literal|0xfc
operator|)
operator|>>
literal|2
condition|)
block|{
case|case
literal|0x22
case|:
switch|switch
condition|(
name|byte
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
return|return
name|VGA_CL_GD5402
return|;
case|case
literal|1
case|:
return|return
name|VGA_CL_GD5402r1
return|;
case|case
literal|2
case|:
return|return
name|VGA_CL_GD5420
return|;
case|case
literal|3
case|:
return|return
name|VGA_CL_GD5420r1
return|;
block|}
break|break;
case|case
literal|0x23
case|:
return|return
name|VGA_CL_GD5422
return|;
case|case
literal|0x25
case|:
return|return
name|VGA_CL_GD5424
return|;
case|case
literal|0x24
case|:
return|return
name|VGA_CL_GD5426
return|;
case|case
literal|0x26
case|:
return|return
name|VGA_CL_GD5428
return|;
block|}
block|}
return|return
operator|(
name|VGA_UNKNOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------  * test if index 35 lower nibble is writable (taken from SuperProbe 1.0)  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|s3testwritable
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|old
decl_stmt|,
name|new1
decl_stmt|,
name|new2
decl_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|old
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* save */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|old
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
comment|/* write 0 */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|new1
operator|=
operator|(
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* must read 0 */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|old
operator||
literal|0x0f
operator|)
argument_list|)
expr_stmt|;
comment|/* write 1 */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|new2
operator|=
operator|(
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
operator|)
operator|&
literal|0x0f
expr_stmt|;
comment|/* must read 1 */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x35
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* restore */
return|return
operator|(
operator|(
name|new1
operator|==
literal|0
operator|)
operator|&&
operator|(
name|new2
operator|==
literal|0x0f
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	return ptr to string describing vga type  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|char
modifier|*
name|vga_string
parameter_list|(
name|int
name|number
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|vga_tab
index|[]
init|=
block|{
literal|"generic"
block|,
literal|"et4000"
block|,
literal|"et3000"
block|,
literal|"pvga1a"
block|,
literal|"wd90c00"
block|,
literal|"wd90c10"
block|,
literal|"wd90c11"
block|,
literal|"v7 vega"
block|,
literal|"v7 fast"
block|,
literal|"v7 ver5"
block|,
literal|"v7 1024i"
block|,
literal|"unknown v7"
block|,
literal|"tvga 8800br"
block|,
literal|"tvga 8800cs"
block|,
literal|"tvga 8900b"
block|,
literal|"tvga 8900c"
block|,
literal|"tvga 8900cl"
block|,
literal|"tvga 9000"
block|,
literal|"tvga 9100"
block|,
literal|"tvga 9200"
block|,
literal|"unknown trident"
block|,
literal|"s3 911"
block|,
literal|"s3 924"
block|,
literal|"s3 801/805"
block|,
literal|"s3 928"
block|,
literal|"unkown s3"
block|,
literal|"cl-gd5402"
block|,
literal|"cl-gd5402r1"
block|,
literal|"cl-gd5420"
block|,
literal|"cl-gd5420r1"
block|,
literal|"cl-gd5422"
block|,
literal|"cl-gd5424"
block|,
literal|"cl-gd5426"
block|,
literal|"cl-gd5428"
block|}
decl_stmt|;
return|return
operator|(
name|vga_tab
index|[
name|number
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle vga 80/132 column operation  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|vga_col
parameter_list|(
name|struct
name|video_state
modifier|*
name|svsp
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|vga_type
condition|)
block|{
case|case
name|VGA_ET4000
case|:
name|ret
operator|=
name|et4000_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_WD90C11
case|:
name|ret
operator|=
name|wd90c11_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_TR8900B
case|:
case|case
name|VGA_TR8900C
case|:
case|case
name|VGA_TR8900CL
case|:
case|case
name|VGA_TR9000
case|:
name|ret
operator|=
name|tri9000_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_V71024I
case|:
name|ret
operator|=
name|v7_1024i_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_S3_928
case|:
name|ret
operator|=
name|s3_928_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_CL_GD5402
case|:
case|case
name|VGA_CL_GD5402r1
case|:
case|case
name|VGA_CL_GD5420
case|:
case|case
name|VGA_CL_GD5420r1
case|:
case|case
name|VGA_CL_GD5422
case|:
case|case
name|VGA_CL_GD5424
case|:
case|case
name|VGA_CL_GD5426
case|:
case|case
name|VGA_CL_GD5428
case|:
name|ret
operator|=
name|cl_gd542x_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|PCVT_132GENERIC
name|ret
operator|=
name|generic_col
argument_list|(
name|cols
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_132GENERIC */
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* failed */
name|svsp
operator|->
name|maxcol
operator|=
name|cols
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|PCVT_132GENERIC
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for "generic" SVGAs  *	NB: this is supposed to work on any (S)VGA as long as the monitor  *	is able to sync down to 21.5 kHz horizontally. The resulting  *	vertical frequency is only 50 Hz, so if there is some better board  *	specific algorithm, we avoid using this generic one.  *	REPORT ANY FAILURES SO WE CAN IMPROVE THIS  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|PCVT_EXP_132COL
end_if

begin_comment
comment|/*  *	Some improved (i.e. higher scan rates) figures for the horizontal  *	timing. USE AT YOUR OWN RISK, THIS MIGHT DAMAGE YOUR MONITOR DUE  *	TO A LOSS OF HORIZONTAL SYNC!  *	The figures have been tested with an ET3000 board along with a  *	NEC MultiSync 3D monitor. If you are playing here, consider  *	testing with several screen pictures (dark background vs. light  *	background, even enlightening the border color may impact the  *	result - you can do this e.g. by "scon -p black,42,42,42")  *	Remember that all horizontal timing values must be dividable  *	by 8! (The scheme below is taken so that nifty kernel hackers  *	are able to patch the figures at run-time.)  *  *	The actual numbers result in 23 kHz line scan and 54 Hz vertical  *	scan.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_EXP_132COL */
end_comment

begin_function
name|int
name|generic_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
if|#
directive|if
operator|!
name|PCVT_EXP_132COL
comment|/* stable figures for any multisync monitor that syncs down to 22 kHz*/
specifier|static
specifier|volatile
name|u_short
name|htotal
init|=
literal|1312
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|displayend
init|=
literal|1056
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|blankstart
init|=
literal|1072
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|syncstart
init|=
literal|1112
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|syncend
init|=
literal|1280
decl_stmt|;
else|#
directive|else
comment|/* PCVT_EXP_132COL */
comment|/* reduced sync-pulse width and sync delays */
specifier|static
specifier|volatile
name|u_short
name|htotal
init|=
literal|1232
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|displayend
init|=
literal|1056
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|blankstart
init|=
literal|1056
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|syncstart
init|=
literal|1104
decl_stmt|;
specifier|static
specifier|volatile
name|u_short
name|syncend
init|=
literal|1168
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_EXP_132COL */
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|generic
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|htotal
operator|/
literal|8
operator|)
operator|-
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|displayend
operator|/
literal|8
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|blankstart
operator|/
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|syncend
operator|/
literal|8
operator|)
operator|&
literal|0x1f
operator|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|syncstart
operator|/
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
operator|(
operator|(
name|syncend
operator|/
literal|8
operator|)
operator|&
literal|0x20
operator|)
operator|*
literal|4
operator|)
operator||
operator|(
operator|(
name|syncend
operator|/
literal|8
operator|)
operator|&
literal|0x1f
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Misc output register */
comment|/* use the 28.322 MHz clock */
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|generic
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_132GENERIC */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for ET4000 based boards  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|et4000_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|et4000
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* 6845 Compatibility */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9f
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x8b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* 6845 Compatibility */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|et4000
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* 6845 Compatibility */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for WD/Paradise based boards  *  *	when this card does 132 cols, the char map select register (TS_INDEX,  *	TS_FONTSEL) function bits get REDEFINED. whoever did design this,  *	please don't cross my way ever .......  *  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|wd90c11_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
if|#
directive|if
operator|!
name|PCVT_BACKUP_FONTS
specifier|static
name|unsigned
name|char
modifier|*
name|sv_fontwd
index|[
name|NVGAFONTS
index|]
decl_stmt|;
endif|#
directive|endif
comment|/*  !PCVT_BACKUP_FONTS */
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* enable access to WD/Paradise "control extensions" */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_PR5GPLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_PR10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x85
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_UNLOCKSEQ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
comment|/* save current fonts */
if|#
directive|if
operator|!
name|PCVT_BACKUP_FONTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vgacs
index|[
name|i
index|]
operator|.
name|loaded
condition|)
block|{
if|if
condition|(
operator|(
name|sv_fontwd
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
literal|32
operator|*
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"pcvt: no font buffer\n"
argument_list|)
expr_stmt|;
else|else
name|vga_move_charset
argument_list|(
name|i
argument_list|,
name|sv_fontwd
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sv_fontwd
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !PCVT_BACKUP_FONTS */
name|sp
operator|=
name|savearea
operator|.
name|wd90c11
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2e
argument_list|)
expr_stmt|;
comment|/* misc 1 */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2f
argument_list|)
expr_stmt|;
comment|/* misc 2 */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9f
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x8a
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2e
argument_list|)
expr_stmt|;
comment|/* misc 1 */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2f
argument_list|)
expr_stmt|;
comment|/* misc 2 */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x21
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator||
literal|0x08
operator|)
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|vsp
operator|->
name|wd132col
operator|=
literal|1
expr_stmt|;
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disable access to WD/Paradise "control extensions" */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_PR5GPLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_PR10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_UNLOCKSEQ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|wd90c11
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2e
argument_list|)
expr_stmt|;
comment|/* misc 1 */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x2f
argument_list|)
expr_stmt|;
comment|/* misc 2 */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|vsp
operator|->
name|wd132col
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore fonts */
if|#
directive|if
operator|!
name|PCVT_BACKUP_FONTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sv_fontwd
index|[
name|i
index|]
condition|)
name|vga_move_charset
argument_list|(
name|i
argument_list|,
name|sv_fontwd
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|saved_charsets
index|[
name|i
index|]
condition|)
name|vga_move_charset
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_BACKUP_FONTS */
name|select_vga_charset
argument_list|(
name|vsp
operator|->
name|vga_charset
argument_list|)
expr_stmt|;
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disable access to WD/Paradise "control extensions" */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_PR5GPLOCK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_PR10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_UNLOCKSEQ
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for TRIDENT 9000 based boards  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|tri9000_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* sync reset is necessary to preserve memory contents ... */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
comment|/* disable protection of misc out and other regs */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_MTEST
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_MTEST
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
operator|~
literal|0x50
argument_list|)
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|tri9000
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* write ANYTHING switches to OLD */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* read switches to NEW */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x1e
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x87
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x1a
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* write ANYTHING switches to OLD */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* read switches to NEW */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|tri9000
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* write ANYTHING switches to OLD */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_HWVERS
argument_list|)
expr_stmt|;
comment|/* Hardware Version register */
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* read switches to NEW */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODEC2
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for Video7 VGA 1024i  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|v7_1024i_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|u_char
name|save__byte
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
comment|/* first, enable read access to vertical retrace start/end */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_HBLANKE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_HBLANKE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|byte
operator||
literal|0x80
operator|)
argument_list|)
expr_stmt|;
comment|/* second, enable access to protected registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|save__byte
operator|=
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|byte
operator||=
literal|0x20
expr_stmt|;
comment|/* no irq 2 */
name|byte
operator|&=
literal|0x6f
expr_stmt|;
comment|/* wr enable, clr irq flag */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* enable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xea
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|v7_1024i
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xa4
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe4
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xf8
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xfd
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x86
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9e
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x89
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xa4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x1c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xfe
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xf8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x1b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xfd
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x33
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
name|byte
operator||=
literal|0x0c
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* disable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xae
argument_list|)
expr_stmt|;
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|v7_1024i
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xa4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xe4
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xf8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xfd
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
block|}
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_EXTCNTL
argument_list|)
expr_stmt|;
comment|/* disable extensions */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0xae
argument_list|)
expr_stmt|;
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|save__byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for S3 86C928 based boards  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|s3_928_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
comment|/* unlock registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x39
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0xa0
argument_list|)
expr_stmt|;
comment|/* unlock registers */
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|s3_928
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
comment|/* Backward Compat 3 Reg */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
comment|/* Data Xfer Exec Position */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
comment|/* (Clock) Mode Control */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9a
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x86
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x87
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x1b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* enable data xfer pos control */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x90
argument_list|)
expr_stmt|;
comment|/* set data xfer pos value */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
comment|/* (Clock) Mode Control */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Select 40MHz Clock */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Misc output register */
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator||
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* lock registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x39
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* lock registers */
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|s3_928
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x34
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x3b
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
comment|/* Mode control */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x38
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* lock registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x39
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* lock registers */
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	toggle 80/132 column operation for Cirrus Logic 542x based boards  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|cl_gd542x_col
parameter_list|(
name|int
name|cols
parameter_list|)
block|{
name|u_char
modifier|*
name|sp
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
name|vga_screen_off
argument_list|()
expr_stmt|;
comment|/* enable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|byte
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* enable access to cirrus extension registers */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x12
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
operator|==
name|SCR_COL132
condition|)
comment|/* switch 80 -> 132 */
block|{
comment|/* save state of board for 80 columns */
if|if
condition|(
operator|!
name|regsaved
condition|)
block|{
name|regsaved
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|savearea
operator|.
name|cirrus
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|ATC_DATAR
argument_list|)
expr_stmt|;
comment|/* VCLK2 Numerator Register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* VCLK2 Denominator and Post-Scalar Value Register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x1d
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* Misc output register */
operator|*
name|sp
operator|++
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
block|}
comment|/* setup chipset for 132 column operation */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9f
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x82
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x8a
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x9e
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0x42
argument_list|)
expr_stmt|;
comment|/* set VCLK2 to 41.164 MHz ..... */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
comment|/* VCLK2 Numerator Register */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x45
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x1d
argument_list|)
expr_stmt|;
comment|/* VCLK2 Denominator and */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x30
argument_list|)
expr_stmt|;
comment|/* Post-Scalar Value Register */
comment|/* and use it. */
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|(
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
operator|&
operator|~
literal|0x0c
operator|)
operator||
operator|(
literal|2
operator|<<
literal|2
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* 8 dot char clock */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* Line graphics disable */
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* switch 132 -> 80 */
block|{
if|if
condition|(
operator|!
name|regsaved
condition|)
comment|/* failsafe */
block|{
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disable access to cirrus extension registers */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sp
operator|=
name|savearea
operator|.
name|cirrus
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Horizontal Total */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Horizontal Display End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* Horizontal Blank End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace Start */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
comment|/* Horizontal Retrace End */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|0x13
argument_list|)
expr_stmt|;
comment|/* Row Offset Register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* Timing Sequencer */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Mode control */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_MODE
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* ATC Horizontal Pixel Panning */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
name|ATC_HORPIXPAN
operator||
name|ATC_ACCESS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* VCLK2 Numerator Register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0xd
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* VCLK2 Denominator and Post-Scalar Value Register */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|0x1d
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
comment|/* Misc output register */
block|}
comment|/* disable access to cirrus extension registers */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* disable access to first 7 CRTC registers */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VSYNCE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|vga_screen_on
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|PCVT_USL_VT_COMPAT
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch screen from text mode to X-mode and vice versa  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|switch_screen
parameter_list|(
name|int
name|n
parameter_list|,
name|int
name|oldgrafx
parameter_list|,
name|int
name|newgrafx
parameter_list|)
block|{
if|#
directive|if
name|PCVT_SCREENSAVER
specifier|static
name|unsigned
name|saved_scrnsv_tmo
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|int
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
name|int
name|cols
init|=
name|vsp
operator|->
name|maxcol
decl_stmt|;
comment|/* get current col val */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|totalscreens
condition|)
return|return;
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* protect us */
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
if|if
condition|(
operator|!
name|oldgrafx
operator|&&
name|newgrafx
condition|)
block|{
comment|/* switch from text to graphics */
if|#
directive|if
name|PCVT_SCREENSAVER
if|if
condition|(
operator|(
name|saved_scrnsv_tmo
operator|=
name|scrnsv_timeout
operator|)
condition|)
name|pcvt_set_scrnsv_tmo
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* screensaver off */
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
name|async_update
argument_list|(
name|UPDATE_STOP
argument_list|)
expr_stmt|;
comment|/* status display off */
block|}
if|if
condition|(
operator|!
name|oldgrafx
condition|)
block|{
comment|/* switch from text mode */
comment|/* video board memory -> kernel memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|vsp
operator|->
name|Memory
argument_list|,
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|vsp
operator|->
name|Memory
expr_stmt|;
comment|/* operate in memory now */
block|}
comment|/* update global screen pointers/variables */
name|current_video_screen
operator|=
name|n
expr_stmt|;
comment|/* current screen no */
if|#
directive|if
operator|!
name|PCVT_NETBSD
operator|&&
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
name|pcconsp
operator|=
operator|&
name|pccons
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
elif|#
directive|elif
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
name|pcconsp
operator|=
name|pccons
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
else|#
directive|else
name|pcconsp
operator|=
name|pc_tty
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
endif|#
directive|endif
name|vsp
operator|=
operator|&
name|vs
index|[
name|n
index|]
expr_stmt|;
comment|/* current video state ptr */
if|if
condition|(
name|oldgrafx
operator|&&
operator|!
name|newgrafx
condition|)
block|{
comment|/* switch from graphics to text mode */
name|unsigned
name|i
decl_stmt|;
comment|/* restore fonts */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|saved_charsets
index|[
name|i
index|]
condition|)
name|vga_move_charset
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_SCREENSAVER
comment|/* activate screen saver */
if|if
condition|(
name|saved_scrnsv_tmo
condition|)
name|pcvt_set_scrnsv_tmo
argument_list|(
name|saved_scrnsv_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
comment|/* re-initialize lost MDA information */
if|if
condition|(
name|adaptor_type
operator|==
name|MDA_ADAPTOR
condition|)
block|{
comment|/* 			 * Due to the fact that HGC registers are 			 * write-only, the Xserver can only make 			 * guesses about the state the HGC adaptor 			 * has been before turning on X mode. Thus, 			 * the display must be re-enabled now, and 			 * the cursor shape and location restored. 			 */
comment|/* enable display, text mode */
name|outb
argument_list|(
name|GN_DMCNTLM
argument_list|,
literal|0x28
argument_list|)
expr_stmt|;
comment|/* XXX - something missing here ? Joerg ??? */
block|}
comment|/* make status display happy */
name|async_update
argument_list|(
name|UPDATE_START
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newgrafx
condition|)
block|{
comment|/* to text mode */
comment|/* kernel memory -> video board memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|Crtat
argument_list|,
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|Crtat
expr_stmt|;
comment|/* operate on screen now */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
name|select_vga_charset
argument_list|(
name|vsp
operator|->
name|vga_charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|maxcol
operator|!=
name|cols
condition|)
name|vga_col
argument_list|(
name|vsp
argument_list|,
name|vsp
operator|->
name|maxcol
argument_list|)
expr_stmt|;
comment|/* select 80/132 columns */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORH
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cur_offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORL
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|cursor_on
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CUREND
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sw_cursor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* switch VGA DAC palette entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVGAPEL
condition|;
name|i
operator|++
control|)
name|vgapaletteio
argument_list|(
name|i
argument_list|,
operator|&
name|vsp
operator|->
name|palette
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newgrafx
condition|)
block|{
name|update_led
argument_list|()
expr_stmt|;
comment|/* update led's */
name|update_hp
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
comment|/* update fkey labels, if present */
comment|/* if we switch to a vt with force 24 lines mode and	*/
comment|/* pure VT emulation and 25 rows charset, then we have	*/
comment|/* to clear the last line on display ...		*/
if|if
condition|(
name|vsp
operator|->
name|force24
operator|&&
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|)
operator|&&
operator|(
name|vgacs
index|[
name|vsp
operator|->
name|vga_charset
index|]
operator|.
name|screen_size
operator|==
name|SIZ_25ROWS
operator|)
condition|)
block|{
name|fillw
argument_list|(
literal|' '
argument_list|,
name|vsp
operator|->
name|Crtat
operator|+
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
argument_list|,
name|vsp
operator|->
name|maxcol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Change specified vt to VT_AUTO mode  *	xxx Maybe this should also reset VT_GRAFX mode; since switching and  *	graphics modes are not going to work without VT_PROCESS mode.  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|set_auto_mode
parameter_list|(
name|struct
name|video_state
modifier|*
name|vsx
parameter_list|)
block|{
name|unsigned
name|ostatus
init|=
name|vsx
operator|->
name|vt_status
decl_stmt|;
name|vsx
operator|->
name|smode
operator|.
name|mode
operator|=
name|VT_AUTO
expr_stmt|;
name|vsx
operator|->
name|proc
operator|=
name|NULL
expr_stmt|;
name|vsx
operator|->
name|pid
operator|=
literal|0
expr_stmt|;
name|vsx
operator|->
name|vt_status
operator|&=
operator|~
operator|(
name|VT_WAIT_REL
operator||
name|VT_WAIT_ACK
operator|)
expr_stmt|;
if|if
condition|(
name|ostatus
operator|&
name|VT_WAIT_ACK
condition|)
block|{
if|#
directive|if
literal|0
block|assert (!(ostatus&VT_WAIT_REL)); 		assert (vsp == vsx&& 			vt_switch_pending == current_video_screen + 1); 		vt_switch_pending = 0;
else|#
directive|else
if|if
condition|(
name|vsp
operator|==
name|vsx
operator|&&
name|vt_switch_pending
operator|==
name|current_video_screen
operator|+
literal|1
condition|)
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|ostatus
operator|&
name|VT_WAIT_REL
condition|)
block|{
name|int
name|new_screen
init|=
name|vt_switch_pending
operator|-
literal|1
decl_stmt|;
if|#
directive|if
literal|0
block|assert(vsp == vsx&& vt_switch_pending); 		vt_switch_pending = 0; 		vgapage (new_screen);
else|#
directive|else
if|if
condition|(
name|vsp
operator|==
name|vsx
operator|&&
name|vt_switch_pending
condition|)
block|{
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
name|vgapage
argument_list|(
name|new_screen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Exported function; to be called when a vt is closed down.  *  *	Ideally, we would like to be able to recover from an X server crash;  *	but in reality, if the server crashes hard while in control of the  *	vga board, then you're not likely to be able to use pcvt ttys  *	without rebooting.  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|reset_usl_modes
parameter_list|(
name|struct
name|video_state
modifier|*
name|vsx
parameter_list|)
block|{
comment|/* Clear graphics mode */
if|if
condition|(
name|vsx
operator|->
name|vt_status
operator|&
name|VT_GRAFX
condition|)
block|{
name|vsx
operator|->
name|vt_status
operator|&=
operator|~
name|VT_GRAFX
expr_stmt|;
if|if
condition|(
name|vsp
operator|==
name|vsx
condition|)
name|switch_screen
argument_list|(
name|current_video_screen
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Take kbd out of raw mode */
if|if
condition|(
name|pcvt_kbd_raw
operator|&&
name|vsp
operator|==
name|vsx
condition|)
block|{
if|#
directive|if
name|PCVT_SCANSET
operator|>
literal|1
name|kbd_emulate_pc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET> 1 */
name|pcvt_kbd_raw
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear process controlled mode */
name|set_auto_mode
argument_list|(
name|vsx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch to virtual screen n (0 ... PCVT_NSCREENS-1), VT_USL version  *	(the name vgapage() stands for historical reasons)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|vgapage
parameter_list|(
name|int
name|new_screen
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|new_screen
operator|<
literal|0
operator|||
name|new_screen
operator|>=
name|totalscreens
condition|)
return|return
name|EINVAL
return|;
comment|/* fallback to VT_AUTO if controlling processes died */
if|if
condition|(
name|vsp
operator|->
name|proc
operator|&&
name|vsp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|vsp
operator|->
name|pid
argument_list|)
condition|)
name|set_auto_mode
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vs
index|[
name|new_screen
index|]
operator|.
name|proc
operator|&&
name|vs
index|[
name|new_screen
index|]
operator|.
name|proc
operator|!=
name|pfind
argument_list|(
name|vs
index|[
name|new_screen
index|]
operator|.
name|pid
argument_list|)
condition|)
name|set_auto_mode
argument_list|(
operator|&
name|vs
index|[
name|new_screen
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vt_switch_pending
operator|&&
name|new_screen
operator|==
name|current_video_screen
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vt_switch_pending
operator|&&
name|vt_switch_pending
operator|!=
name|new_screen
operator|+
literal|1
condition|)
block|{
comment|/* Try resignaling uncooperative X-window servers */
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_REL
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|relsig
condition|)
name|psignal
argument_list|(
name|vsp
operator|->
name|proc
argument_list|,
name|vsp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACK
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|acqsig
condition|)
name|psignal
argument_list|(
name|vsp
operator|->
name|proc
argument_list|,
name|vsp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|EAGAIN
return|;
block|}
name|vt_switch_pending
operator|=
name|new_screen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
comment|/* we cannot switch immediately here */
name|vsp
operator|->
name|vt_status
operator||=
name|VT_WAIT_REL
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|relsig
condition|)
name|psignal
argument_list|(
name|vsp
operator|->
name|proc
argument_list|,
name|vsp
operator|->
name|smode
operator|.
name|relsig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|video_state
modifier|*
name|old_vsp
init|=
name|vsp
decl_stmt|;
name|switch_screen
argument_list|(
name|new_screen
argument_list|,
name|vsp
operator|->
name|vt_status
operator|&
name|VT_GRAFX
argument_list|,
name|vs
index|[
name|new_screen
index|]
operator|.
name|vt_status
operator|&
name|VT_GRAFX
argument_list|)
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACT
condition|)
block|{
name|old_vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_ACT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|old_vsp
operator|->
name|smode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACT
condition|)
block|{
name|vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_ACT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vsp
operator|->
name|smode
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
comment|/* if _new_ vt is under process control... */
name|vsp
operator|->
name|vt_status
operator||=
name|VT_WAIT_ACK
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|acqsig
condition|)
name|psignal
argument_list|(
name|vsp
operator|->
name|proc
argument_list|,
name|vsp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we are committed */
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ioctl handling for VT_USL mode  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usl_vt_ioctl
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|,
name|opri
decl_stmt|;
name|struct
name|vt_mode
name|newmode
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VT_SETMODE
case|:
name|newmode
operator|=
operator|*
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
expr_stmt|;
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|newmode
operator|.
name|mode
operator|!=
name|VT_PROCESS
condition|)
block|{
name|struct
name|video_state
modifier|*
name|vsx
init|=
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|vsx
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
if|if
condition|(
name|vsx
operator|->
name|proc
operator|!=
name|p
condition|)
block|{
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|set_auto_mode
argument_list|(
name|vsx
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * NB: XFree86-3.1.1 does the following: 		 *		VT_ACTIVATE (vtnum) 		 *		VT_WAITACTIVE (vtnum) 		 *		VT_SETMODE (VT_PROCESS) 		 * So it is possible that the screen was switched 		 * between the WAITACTIVE and the SETMODE (here).  This 		 * can actually happen quite frequently, and it was 		 * leading to dire consequences. Now it is detected by 		 * requiring that minor(dev) match current_video_screen. 		 * An alternative would be to operate on vs[minor(dev)] 		 * instead of *vsp, but that would leave the server 		 * confused, because it would believe that its vt was 		 * currently activated. 		 */
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
name|current_video_screen
condition|)
block|{
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
comment|/* Check for server died */
if|if
condition|(
name|vsp
operator|->
name|proc
operator|&&
name|vsp
operator|->
name|proc
operator|!=
name|pfind
argument_list|(
name|vsp
operator|->
name|pid
argument_list|)
condition|)
name|set_auto_mode
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
comment|/* Check for server already running */
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
operator|&&
name|vsp
operator|->
name|proc
operator|!=
name|p
condition|)
block|{
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
comment|/* already in use on this VT */
block|}
name|vsp
operator|->
name|smode
operator|=
name|newmode
expr_stmt|;
name|vsp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|vsp
operator|->
name|pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_GETMODE
case|:
operator|*
operator|(
expr|struct
name|vt_mode
operator|*
operator|)
name|data
operator|=
name|vsp
operator|->
name|smode
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_RELDISP
case|:
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
name|current_video_screen
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|!=
name|VT_PROCESS
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vsp
operator|->
name|proc
operator|!=
name|p
condition|)
return|return
name|EPERM
return|;
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|VT_FALSE
case|:
comment|/* process refuses to release screen; abort */
if|if
condition|(
name|vt_switch_pending
operator|&&
operator|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_REL
operator|)
condition|)
block|{
name|vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_REL
expr_stmt|;
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|VT_TRUE
case|:
comment|/* process releases its VT */
if|if
condition|(
name|vt_switch_pending
operator|&&
operator|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_REL
operator|)
condition|)
block|{
name|int
name|new_screen
init|=
name|vt_switch_pending
operator|-
literal|1
decl_stmt|;
name|struct
name|video_state
modifier|*
name|old_vsp
init|=
name|vsp
decl_stmt|;
name|vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_REL
expr_stmt|;
name|switch_screen
argument_list|(
name|new_screen
argument_list|,
name|vsp
operator|->
name|vt_status
operator|&
name|VT_GRAFX
argument_list|,
name|vs
index|[
name|new_screen
index|]
operator|.
name|vt_status
operator|&
name|VT_GRAFX
argument_list|)
expr_stmt|;
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|old_vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACT
condition|)
block|{
name|old_vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_ACT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|old_vsp
operator|->
name|smode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACT
condition|)
block|{
name|vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_ACT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vsp
operator|->
name|smode
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|mode
operator|==
name|VT_PROCESS
condition|)
block|{
comment|/* 					 * if the new vt is also in process 					 * mode, we have to wait until its 					 * controlling process acknowledged 					 * the switch 					 */
name|vsp
operator|->
name|vt_status
operator||=
name|VT_WAIT_ACK
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|smode
operator|.
name|acqsig
condition|)
name|psignal
argument_list|(
name|vsp
operator|->
name|proc
argument_list|,
name|vsp
operator|->
name|smode
operator|.
name|acqsig
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* we are committed */
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
case|case
name|VT_ACKACQ
case|:
comment|/* new vts controlling process acknowledged */
if|if
condition|(
name|vsp
operator|->
name|vt_status
operator|&
name|VT_WAIT_ACK
condition|)
block|{
name|vt_switch_pending
operator|=
literal|0
expr_stmt|;
name|vsp
operator|->
name|vt_status
operator|&=
operator|~
name|VT_WAIT_ACK
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
return|return
name|EINVAL
return|;
comment|/* end case VT_RELDISP */
case|case
name|VT_OPENQRY
case|:
comment|/* return free vt */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCVT_NSCREENS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|vs
index|[
name|i
index|]
operator|.
name|openf
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EAGAIN
return|;
case|case
name|VT_GETACTIVE
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|current_video_screen
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|VT_ACTIVATE
case|:
return|return
name|vgapage
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
argument_list|)
return|;
case|case
name|VT_WAITACTIVE
case|:
comment|/* sleep until vt switch happened */
name|i
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|PCVT_NSCREENS
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|i
operator|!=
operator|-
literal|1
operator|&&
name|current_video_screen
operator|==
name|i
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* xxx Is this what it is supposed to do? */
name|int
name|x
init|=
name|spltty
argument_list|()
decl_stmt|;
name|i
operator|=
name|current_video_screen
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_video_screen
operator|==
name|i
operator|&&
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ERESTART
operator|)
condition|)
block|{
name|vs
index|[
name|i
index|]
operator|.
name|vt_status
operator||=
name|VT_WAIT_ACT
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vs
index|[
name|i
index|]
operator|.
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|x
init|=
name|spltty
argument_list|()
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|current_video_screen
operator|!=
name|i
operator|&&
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ERESTART
operator|)
condition|)
block|{
name|vs
index|[
name|i
index|]
operator|.
name|vt_status
operator||=
name|VT_WAIT_ACT
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vs
index|[
name|i
index|]
operator|.
name|smode
argument_list|,
name|PZERO
operator||
name|PCATCH
argument_list|,
literal|"waitvt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
case|case
name|KDENABIO
case|:
comment|/* grant the process IO access; only allowed if euid == 0 */
block|{
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
name|struct
name|trapframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
elif|#
directive|elif
name|PCVT_NETBSD
operator|||
operator|(
name|PCVT_FREEBSD
operator|&&
name|PCVT_FREEBSD
operator|>
literal|102
operator|)
name|struct
name|trapframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_regs
decl_stmt|;
else|#
directive|else
name|struct
name|syscframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|syscframe
operator|*
operator|)
name|p
operator|->
name|p_regs
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|#
directive|if
name|PCVT_NETBSD
operator|||
operator|(
name|PCVT_FREEBSD
operator|&&
name|PCVT_FREEBSD
operator|>
literal|102
operator|)
name|fp
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
else|#
directive|else
name|fp
operator|->
name|sf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
case|case
name|KDDISABIO
case|:
comment|/* abandon IO access permission */
block|{
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
name|struct
name|trapframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
name|fp
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
elif|#
directive|elif
name|PCVT_NETBSD
operator|||
operator|(
name|PCVT_FREEBSD
operator|&&
name|PCVT_FREEBSD
operator|>
literal|102
operator|)
name|struct
name|trapframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_regs
decl_stmt|;
name|fp
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
else|#
directive|else
name|struct
name|syscframe
modifier|*
name|fp
init|=
operator|(
expr|struct
name|syscframe
operator|*
operator|)
name|p
operator|->
name|p_regs
decl_stmt|;
name|fp
operator|->
name|sf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
case|case
name|KDSETMODE
case|:
block|{
name|struct
name|video_state
modifier|*
name|vsx
init|=
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|haschanged
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|&&
name|adaptor_type
operator|!=
name|MDA_ADAPTOR
condition|)
comment|/* X will only run on those adaptors */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* set text/graphics mode of current vt */
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|KD_TEXT
case|:
name|haschanged
operator|=
operator|(
name|vsx
operator|->
name|vt_status
operator|&
name|VT_GRAFX
operator|)
operator|!=
literal|0
expr_stmt|;
name|vsx
operator|->
name|vt_status
operator|&=
operator|~
name|VT_GRAFX
expr_stmt|;
if|if
condition|(
name|haschanged
operator|&&
name|vsx
operator|==
name|vsp
condition|)
name|switch_screen
argument_list|(
name|current_video_screen
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|KD_GRAPHICS
case|:
comment|/* xxx It might be a good idea to require that 			   the vt be in process controlled mode here, 			   and that the calling process is the owner */
name|haschanged
operator|=
operator|(
name|vsx
operator|->
name|vt_status
operator|&
name|VT_GRAFX
operator|)
operator|==
literal|0
expr_stmt|;
name|vsx
operator|->
name|vt_status
operator||=
name|VT_GRAFX
expr_stmt|;
if|if
condition|(
name|haschanged
operator|&&
name|vsx
operator|==
name|vsp
condition|)
name|switch_screen
argument_list|(
name|current_video_screen
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
comment|/* end case KDSETMODE */
block|}
case|case
name|KDSETRAD
case|:
comment|/* set keyboard repeat and delay */
return|return
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|KBDSTPMAT
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
return|;
case|case
name|KDSKBMODE
case|:
switch|switch
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
case|case
name|K_RAW
case|:
if|#
directive|if
name|PCVT_SCANSET
operator|>
literal|1
comment|/* put keyboard to return ancient PC scan codes */
name|kbd_emulate_pc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET> 1 */
name|pcvt_kbd_raw
operator|=
literal|1
expr_stmt|;
name|shift_down
operator|=
name|meta_down
operator|=
name|altgr_down
operator|=
name|ctrl_down
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
case|case
name|K_XLATE
case|:
if|#
directive|if
name|PCVT_SCANSET
operator|>
literal|1
name|kbd_emulate_pc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET> 1 */
name|pcvt_kbd_raw
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
comment|/* end KDSKBMODE */
case|case
name|KDMKTONE
case|:
comment|/* ring the speaker */
if|if
condition|(
name|data
condition|)
block|{
name|int
name|duration
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|>>
literal|16
decl_stmt|;
name|int
name|pitch
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
literal|0xffff
decl_stmt|;
if|#
directive|if
name|PCVT_NETBSD
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
name|pitch
argument_list|,
name|duration
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCVT_NETBSD */
name|sysbeep
argument_list|(
name|pitch
argument_list|,
name|duration
operator|*
name|hz
operator|/
literal|3000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
block|}
else|else
block|{
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
literal|1493
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|KDSETLED
case|:
comment|/* set kbd LED status */
comment|/* unfortunately, the LED definitions between pcvt and */
comment|/* USL differ some way :-( */
name|i
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
name|j
operator|=
operator|(
name|i
operator|&
name|LED_CAP
condition|?
name|KBD_CAPSLOCK
else|:
literal|0
operator|)
operator|+
operator|(
name|i
operator|&
name|LED_NUM
condition|?
name|KBD_NUMLOCK
else|:
literal|0
operator|)
operator|+
operator|(
name|i
operator|&
name|LED_SCR
condition|?
name|KBD_SCROLLLOCK
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|KBDSLOCK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|j
argument_list|,
name|flag
argument_list|)
return|;
case|case
name|KDGETLED
case|:
comment|/* get kbd LED status */
if|if
condition|(
operator|(
name|error
operator|=
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|KBDGLOCK
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|j
argument_list|,
name|flag
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|i
operator|=
operator|(
name|j
operator|&
name|KBD_CAPSLOCK
condition|?
name|LED_CAP
else|:
literal|0
operator|)
operator|+
operator|(
name|j
operator|&
name|KBD_NUMLOCK
condition|?
name|LED_NUM
else|:
literal|0
operator|)
operator|+
operator|(
name|j
operator|&
name|KBD_SCROLLLOCK
condition|?
name|LED_SCR
else|:
literal|0
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
case|case
name|GIO_KEYMAP
case|:
name|get_usl_keymap
argument_list|(
operator|(
name|keymap_t
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* end case cmd */
return|return
operator|-
literal|1
return|;
comment|/* inappropriate usl_vt_compat ioctl */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_USL_VT_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVT> 0 */
end_comment

begin_comment
comment|/* ------------------------- E O F ------------------------------------------*/
end_comment

end_unit

