begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.  *  * Copyright (c) 1992, 1993 Brian Dunford-Shore and Scott Turner.  *  * Copyright (C) 1992, 1993 Soeren Schmidt.  *  * All rights reserved.  *  * For the sake of compatibility, portions of this code regarding the  * X server interface are taken from Soeren Schmidt's syscons driver.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Hellmuth Michaelis,  *	Brian Dunford-Shore, Joerg Wunsch, Scott Turner and Soeren Schmidt.  * 4. The name authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * @(#)pcvt_sup.c, 3.20, Last Edit-Date: [Thu Apr  6 10:49:44 1995]  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	pcvt_sup.c	VT220 Driver Support Routines  *	---------------------------------------------  *	-hm	------------ Release 3.00 --------------  *	-hm	integrating NetBSD-current patches  *	-hm	removed paranoid delay()/DELAY() from vga_test()  *	-hm	removing vgapage() protection if PCVT_KBD_FIFO  *	-hm	some new CONF_ - values  *	-hm	Joerg's patches for FreeBSD ttymalloc  *	-hm	applying Joerg's patches for FreeBSD 2.0  *	-hm	applying Lon Willet's patches for NetBSD  *	-hm	NetBSD PR #400: patch to short-circuit TIOCSWINSZ  *	-hm	getting PCVT_BURST reported correctly for FreeBSD 2.0  *	-hm	applying patch from Joerg fixing Crtat bug  *	-hm	moving ega/vga coldinit support code to mda2egaorvga()  *	-hm	patch from Thomas Eberhardt fixing force 24 lines fkey update  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"vt.h"
end_include

begin_if
if|#
directive|if
name|NVT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<i386/isa/pcvt/pcvt_hdr.h>
end_include

begin_comment
comment|/* global include */
end_comment

begin_function_decl
specifier|static
name|void
name|vid_cursor
parameter_list|(
name|struct
name|cursorshape
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgasetfontattr
parameter_list|(
name|struct
name|vgafontattr
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgagetfontattr
parameter_list|(
name|struct
name|vgafontattr
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgaloadchar
parameter_list|(
name|struct
name|vgaloadchar
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vid_getscreen
parameter_list|(
name|struct
name|screeninfo
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vid_setscreen
parameter_list|(
name|struct
name|screeninfo
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setchargen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setchargen3
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resetchargen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgareadpel
parameter_list|(
name|struct
name|vgapel
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgawritepel
parameter_list|(
name|struct
name|vgapel
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgapcvtid
parameter_list|(
name|struct
name|pcvtid
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vgapcvtinfo
parameter_list|(
name|struct
name|pcvtinfo
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|XSERVER
end_ifdef

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|compute_charset_base
parameter_list|(
name|unsigned
name|fontset
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER */
end_comment

begin_if
if|#
directive|if
name|PCVT_SCREENSAVER
end_if

begin_function_decl
specifier|static
name|void
name|scrnsv_timedout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_short
modifier|*
name|savedscreen
init|=
operator|(
name|u_short
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to screen contents */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|scrnsv_size
init|=
operator|(
name|size_t
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of saved image */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XSERVER
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|scrnsv_timeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initially off */
end_comment

begin_function_decl
specifier|static
name|void
name|pcvt_set_scrnsv_tmo
parameter_list|(
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* else declared global */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER */
end_comment

begin_if
if|#
directive|if
name|PCVT_PRETTYSCRNS
end_if

begin_decl_stmt
specifier|static
name|u_short
modifier|*
name|scrnsv_current
init|=
operator|(
name|u_short
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* attention char ptr */
end_comment

begin_function_decl
specifier|static
name|void
name|scrnsv_blink
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|getrand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_PRETTYSCRNS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_SCREENSAVER */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	execute vga ioctls  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|vgaioctl
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|PCVT_NSCREENS
condition|)
return|return
operator|-
literal|1
return|;
comment|/*  * Some of the commands are not applicable if the vt in question, or the  * current vt is in graphics mode (i.e., the X server acts on it); they  * will cause an EAGAIN (resource temporarily unavailable) to be returned.  */
ifdef|#
directive|ifdef
name|XSERVER
if|#
directive|if
name|PCVT_USL_VT_COMPAT
define|#
directive|define
name|is_dev_grafx
value|vs[minor(dev)].vt_status& VT_GRAFX
define|#
directive|define
name|is_current_grafx
value|vsp->vt_status& VT_GRAFX
else|#
directive|else
comment|/* old X interface */
define|#
directive|define
name|is_dev_grafx
value|pcvt_xmode
define|#
directive|define
name|is_current_grafx
value|pcvt_xmode
endif|#
directive|endif
comment|/* PCVT_USL_VT_COMPAT */
else|#
directive|else
comment|/* !XSERVER */
define|#
directive|define
name|is_dev_grafx
value|0
comment|/* not applicable */
define|#
directive|define
name|is_current_grafx
value|0
endif|#
directive|endif
comment|/* XSERVER */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|VGACURSOR
case|:
if|if
condition|(
name|is_current_grafx
condition|)
return|return
name|EAGAIN
return|;
name|vid_cursor
argument_list|(
operator|(
expr|struct
name|cursorshape
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGALOADCHAR
case|:
if|if
condition|(
operator|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|)
operator|&&
operator|(
name|adaptor_type
operator|!=
name|EGA_ADAPTOR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|is_current_grafx
condition|)
return|return
name|EAGAIN
return|;
name|vgaloadchar
argument_list|(
operator|(
expr|struct
name|vgaloadchar
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGASETFONTATTR
case|:
if|if
condition|(
operator|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|)
operator|&&
operator|(
name|adaptor_type
operator|!=
name|EGA_ADAPTOR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
name|PCVT_SCREENSAVER
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
name|vgasetfontattr
argument_list|(
operator|(
expr|struct
name|vgafontattr
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGAGETFONTATTR
case|:
if|if
condition|(
operator|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|)
operator|&&
operator|(
name|adaptor_type
operator|!=
name|EGA_ADAPTOR
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|vgagetfontattr
argument_list|(
operator|(
expr|struct
name|vgafontattr
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGASETSCREEN
case|:
if|#
directive|if
name|defined
name|XSERVER
operator|&&
operator|!
name|PCVT_USL_VT_COMPAT
comment|/* avoid screen switch if using old X mode */
if|if
condition|(
name|is_dev_grafx
condition|)
return|return
name|EAGAIN
return|;
endif|#
directive|endif
comment|/* XSERVER&& !PCVT_USL_VT_COMPAT */
if|#
directive|if
name|PCVT_SCREENSAVER
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
name|vid_setscreen
argument_list|(
operator|(
expr|struct
name|screeninfo
operator|*
operator|)
name|data
argument_list|,
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGAGETSCREEN
case|:
name|vid_getscreen
argument_list|(
operator|(
expr|struct
name|screeninfo
operator|*
operator|)
name|data
argument_list|,
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGAREADPEL
case|:
if|if
condition|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|is_dev_grafx
condition|)
return|return
name|EAGAIN
return|;
name|vgareadpel
argument_list|(
operator|(
expr|struct
name|vgapel
operator|*
operator|)
name|data
argument_list|,
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGAWRITEPEL
case|:
if|if
condition|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|is_dev_grafx
condition|)
return|return
name|EAGAIN
return|;
name|vgawritepel
argument_list|(
operator|(
expr|struct
name|vgapel
operator|*
operator|)
name|data
argument_list|,
name|dev
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|PCVT_SCREENSAVER
case|case
name|VGASCREENSAVER
case|:
if|if
condition|(
name|is_current_grafx
condition|)
return|return
name|EAGAIN
return|;
name|pcvt_set_scrnsv_tmo
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
case|case
name|VGAPCVTID
case|:
name|vgapcvtid
argument_list|(
operator|(
expr|struct
name|pcvtid
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGAPCVTINFO
case|:
name|vgapcvtinfo
argument_list|(
operator|(
expr|struct
name|pcvtinfo
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGASETCOLMS
case|:
if|if
condition|(
name|is_dev_grafx
condition|)
return|return
name|EAGAIN
return|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|80
condition|)
operator|(
name|void
operator|)
name|vt_col
argument_list|(
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|SCR_COL80
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|132
condition|)
block|{
if|if
condition|(
name|vt_col
argument_list|(
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|SCR_COL132
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* not a VGA */
block|}
else|else
return|return
name|EINVAL
return|;
break|break;
case|case
name|TIOCSWINSZ
case|:
comment|/* do nothing here */
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
undef|#
directive|undef
name|is_dev_grafx
undef|#
directive|undef
name|is_current_grafx
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	video ioctl - return driver id  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgapcvtid
parameter_list|(
name|struct
name|pcvtid
modifier|*
name|data
parameter_list|)
block|{
name|strcpy
argument_list|(
name|data
operator|->
name|name
argument_list|,
name|PCVTIDNAME
argument_list|)
expr_stmt|;
name|data
operator|->
name|rmajor
operator|=
name|PCVTIDMAJOR
expr_stmt|;
name|data
operator|->
name|rminor
operator|=
name|PCVTIDMINOR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	video ioctl - return driver compile time options data  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgapcvtinfo
parameter_list|(
name|struct
name|pcvtinfo
modifier|*
name|data
parameter_list|)
block|{
if|#
directive|if
name|PCVT_NETBSD
name|data
operator|->
name|opsys
operator|=
name|CONF_NETBSD
expr_stmt|;
name|data
operator|->
name|opsysrel
operator|=
name|PCVT_NETBSD
expr_stmt|;
elif|#
directive|elif
name|PCVT_FREEBSD
name|data
operator|->
name|opsys
operator|=
name|CONF_FREEBSD
expr_stmt|;
name|data
operator|->
name|opsysrel
operator|=
name|PCVT_FREEBSD
expr_stmt|;
else|#
directive|else
name|data
operator|->
name|opsys
operator|=
name|CONF_UNKNOWNOPSYS
expr_stmt|;
name|data
operator|->
name|opsysrel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|nscreens
operator|=
name|PCVT_NSCREENS
expr_stmt|;
name|data
operator|->
name|scanset
operator|=
name|PCVT_SCANSET
expr_stmt|;
name|data
operator|->
name|updatefast
operator|=
name|PCVT_UPDATEFAST
expr_stmt|;
name|data
operator|->
name|updateslow
operator|=
name|PCVT_UPDATESLOW
expr_stmt|;
name|data
operator|->
name|sysbeepf
operator|=
name|PCVT_SYSBEEPF
expr_stmt|;
if|#
directive|if
name|PCVT_NETBSD
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
name|data
operator|->
name|pcburst
operator|=
name|PCVT_PCBURST
expr_stmt|;
else|#
directive|else
name|data
operator|->
name|pcburst
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|PCVT_KBD_FIFO
name|data
operator|->
name|kbd_fifo_sz
operator|=
name|PCVT_KBD_FIFO_SZ
expr_stmt|;
else|#
directive|else
name|data
operator|->
name|kbd_fifo_sz
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|data
operator|->
name|compile_opts
operator|=
operator|(
literal|0
if|#
directive|if
name|PCVT_VT220KEYB
operator||
name|CONF_VT220KEYB
endif|#
directive|endif
if|#
directive|if
name|PCVT_SCREENSAVER
operator||
name|CONF_SCREENSAVER
endif|#
directive|endif
if|#
directive|if
name|PCVT_PRETTYSCRNS
operator||
name|CONF_PRETTYSCRNS
endif|#
directive|endif
if|#
directive|if
name|PCVT_CTRL_ALT_DEL
operator||
name|CONF_CTRL_ALT_DEL
endif|#
directive|endif
if|#
directive|if
name|PCVT_USEKBDSEC
operator||
name|CONF_USEKBDSEC
endif|#
directive|endif
if|#
directive|if
name|PCVT_24LINESDEF
operator||
name|CONF_24LINESDEF
endif|#
directive|endif
if|#
directive|if
name|PCVT_EMU_MOUSE
operator||
name|CONF_EMU_MOUSE
endif|#
directive|endif
if|#
directive|if
name|PCVT_SHOWKEYS
operator||
name|CONF_SHOWKEYS
endif|#
directive|endif
if|#
directive|if
name|PCVT_KEYBDID
operator||
name|CONF_KEYBDID
endif|#
directive|endif
if|#
directive|if
name|PCVT_SIGWINCH
operator||
name|CONF_SIGWINCH
endif|#
directive|endif
if|#
directive|if
name|PCVT_NULLCHARS
operator||
name|CONF_NULLCHARS
endif|#
directive|endif
if|#
directive|if
name|PCVT_BACKUP_FONTS
operator||
name|CONF_BACKUP_FONTS
endif|#
directive|endif
if|#
directive|if
name|PCVT_SW0CNOUTP
comment|/* was FORCE8BIT */
operator||
name|CONF_SW0CNOUTP
endif|#
directive|endif
if|#
directive|if
name|PCVT_SETCOLOR
operator||
name|CONF_SETCOLOR
endif|#
directive|endif
if|#
directive|if
name|PCVT_132GENERIC
operator||
name|CONF_132GENERIC
endif|#
directive|endif
if|#
directive|if
name|PCVT_PALFLICKER
operator||
name|CONF_PALFLICKER
endif|#
directive|endif
if|#
directive|if
name|PCVT_WAITRETRACE
operator||
name|CONF_WAITRETRACE
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XSERVER
operator||
name|CONF_XSERVER
endif|#
directive|endif
if|#
directive|if
name|PCVT_USL_VT_COMPAT
operator||
name|CONF_USL_VT_COMPAT
endif|#
directive|endif
if|#
directive|if
name|PCVT_PORTIO_DELAY
operator||
name|CONF_PORTIO_DELAY
endif|#
directive|endif
if|#
directive|if
name|PCVT_INHIBIT_NUMLOCK
operator||
name|CONF_INHIBIT_NUMLOCK
endif|#
directive|endif
if|#
directive|if
name|PCVT_META_ESC
operator||
name|CONF_META_ESC
endif|#
directive|endif
if|#
directive|if
name|PCVT_KBD_FIFO
operator||
name|CONF_KBD_FIFO
endif|#
directive|endif
if|#
directive|if
name|PCVT_NOFASTSCROLL
operator||
name|CONF_NOFASTSCROLL
endif|#
directive|endif
if|#
directive|if
name|PCVT_SLOW_INTERRUPT
operator||
name|CONF_SLOW_INTERRUPT
endif|#
directive|endif
if|#
directive|if
name|PCVT_NO_LED_UPDATE
operator||
name|CONF_NO_LED_UPDATE
endif|#
directive|endif
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	video ioctl - set cursor appearence  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vid_cursor
parameter_list|(
name|struct
name|cursorshape
modifier|*
name|data
parameter_list|)
block|{
name|int
name|screen
decl_stmt|;
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
name|int
name|line_height
decl_stmt|;
name|int
name|character_set
decl_stmt|;
comment|/* for which virtual screen, -1 for current */
name|screen
operator|=
name|data
operator|->
name|screen_no
expr_stmt|;
if|if
condition|(
name|screen
operator|==
operator|-
literal|1
condition|)
comment|/* current ? */
name|screen
operator|=
name|current_video_screen
expr_stmt|;
elseif|else
if|if
condition|(
name|screen
operator|>
name|totalscreens
operator|-
literal|1
condition|)
name|screen
operator|=
name|totalscreens
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|screen
operator|<
literal|0
condition|)
name|screen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
operator|||
name|adaptor_type
operator|==
name|EGA_ADAPTOR
condition|)
block|{
name|character_set
operator|=
name|vs
index|[
name|screen
index|]
operator|.
name|vga_charset
expr_stmt|;
name|character_set
operator|=
operator|(
name|character_set
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|character_set
operator|<
name|totalfonts
operator|)
condition|?
name|character_set
else|:
name|totalfonts
operator|-
literal|1
operator|)
expr_stmt|;
name|line_height
operator|=
name|vgacs
index|[
name|character_set
index|]
operator|.
name|char_scanlines
operator|&
literal|0x1F
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adaptor_type
operator|==
name|MDA_ADAPTOR
condition|)
block|{
name|line_height
operator|=
literal|14
expr_stmt|;
block|}
else|else
block|{
name|line_height
operator|=
literal|8
expr_stmt|;
comment|/* CGA */
block|}
name|start
operator|=
operator|(
name|data
operator|->
name|start
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|data
operator|->
name|start
operator|>
name|line_height
operator|)
condition|?
name|line_height
else|:
name|data
operator|->
name|start
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vga_family
operator|==
name|VGA_F_TRI
operator|)
operator|&&
operator|(
name|start
operator|==
literal|0
operator|)
condition|)
name|start
operator|=
literal|1
expr_stmt|;
name|end
operator|=
operator|(
name|data
operator|->
name|end
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|data
operator|->
name|end
operator|>
name|line_height
operator|)
condition|?
name|line_height
else|:
name|data
operator|->
name|end
operator|)
expr_stmt|;
name|vs
index|[
name|screen
index|]
operator|.
name|cursor_start
operator|=
name|start
expr_stmt|;
name|vs
index|[
name|screen
index|]
operator|.
name|cursor_end
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|screen
operator|==
name|current_video_screen
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CUREND
argument_list|)
expr_stmt|;
comment|/* cursor end reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ega/vga ioctl - set font attributes  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgasetfontattr
parameter_list|(
name|struct
name|vgafontattr
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|vga_character_set
decl_stmt|;
name|int
name|lines_per_character
decl_stmt|;
name|int
name|totscanlines
decl_stmt|;
name|int
name|size
decl_stmt|;
name|vga_character_set
operator|=
name|data
operator|->
name|character_set
expr_stmt|;
name|vga_character_set
operator|=
operator|(
name|vga_character_set
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|vga_character_set
operator|<
name|totalfonts
operator|)
condition|?
name|vga_character_set
else|:
name|totalfonts
operator|-
literal|1
operator|)
expr_stmt|;
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|loaded
operator|=
name|data
operator|->
name|font_loaded
expr_stmt|;
comment|/* Limit Characters to 32 scanlines doubled */
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|char_scanlines
operator|=
operator|(
name|data
operator|->
name|character_scanlines
operator|&
literal|0x1F
operator|)
operator||
literal|0x40
expr_stmt|;
comment|/* always set bit 9 of line cmp reg */
if|if
condition|(
name|adaptor_type
operator|==
name|EGA_ADAPTOR
condition|)
comment|/* ...and screen height to scan 350 lines */
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|scr_scanlines
operator|=
operator|(
name|data
operator|->
name|screen_scanlines
operator|>
literal|0x5d
operator|)
condition|?
literal|0x5d
else|:
name|data
operator|->
name|screen_scanlines
expr_stmt|;
else|else
comment|/* ...and screen height to scan 480 lines */
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|scr_scanlines
operator|=
operator|(
name|data
operator|->
name|screen_scanlines
operator|>
literal|0xdF
operator|)
condition|?
literal|0xdF
else|:
name|data
operator|->
name|screen_scanlines
expr_stmt|;
name|lines_per_character
operator|=
call|(
name|int
call|)
argument_list|(
literal|0x1F
operator|&
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|char_scanlines
argument_list|)
operator|+
literal|1
expr_stmt|;
name|totscanlines
operator|=
literal|0x101
operator|+
operator|(
name|int
operator|)
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|scr_scanlines
expr_stmt|;
name|size
operator|=
name|data
operator|->
name|screen_size
expr_stmt|;
if|if
condition|(
name|adaptor_type
operator|==
name|EGA_ADAPTOR
condition|)
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|SIZ_25ROWS
case|:
comment|/* This case is always OK */
break|break;
case|case
name|SIZ_35ROWS
case|:
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|35
condition|)
name|size
operator|=
name|SIZ_35ROWS
expr_stmt|;
else|else
name|size
operator|=
name|SIZ_25ROWS
expr_stmt|;
break|break;
case|case
name|SIZ_43ROWS
case|:
default|default:
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|43
condition|)
name|size
operator|=
name|SIZ_43ROWS
expr_stmt|;
elseif|else
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|35
condition|)
name|size
operator|=
name|SIZ_35ROWS
expr_stmt|;
else|else
name|size
operator|=
name|SIZ_25ROWS
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|size
condition|)
block|{
case|case
name|SIZ_25ROWS
case|:
comment|/* This case is always OK */
break|break;
case|case
name|SIZ_28ROWS
case|:
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|28
condition|)
name|size
operator|=
name|SIZ_28ROWS
expr_stmt|;
else|else
name|size
operator|=
name|SIZ_25ROWS
expr_stmt|;
break|break;
case|case
name|SIZ_40ROWS
case|:
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|40
condition|)
name|size
operator|=
name|SIZ_40ROWS
expr_stmt|;
elseif|else
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|28
condition|)
name|size
operator|=
name|SIZ_28ROWS
expr_stmt|;
else|else
name|size
operator|=
name|SIZ_25ROWS
expr_stmt|;
break|break;
case|case
name|SIZ_50ROWS
case|:
default|default:
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|50
condition|)
name|size
operator|=
name|SIZ_50ROWS
expr_stmt|;
elseif|else
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|40
condition|)
name|size
operator|=
name|SIZ_40ROWS
expr_stmt|;
elseif|else
if|if
condition|(
name|totscanlines
operator|/
name|lines_per_character
operator|>=
literal|28
condition|)
name|size
operator|=
name|SIZ_28ROWS
expr_stmt|;
else|else
name|size
operator|=
name|SIZ_25ROWS
expr_stmt|;
break|break;
block|}
block|}
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|screen_size
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCVT_NSCREENS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vga_character_set
operator|==
name|vs
index|[
name|i
index|]
operator|.
name|vga_charset
condition|)
name|set_charset
argument_list|(
operator|&
operator|(
name|vs
index|[
name|i
index|]
operator|)
argument_list|,
name|vga_character_set
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
name|vgapage
argument_list|(
name|current_video_screen
argument_list|)
expr_stmt|;
else|#
directive|else
name|switch_screen
argument_list|(
name|current_video_screen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_USL_VT_COMPAT */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ega/vga ioctl - get font attributes  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgagetfontattr
parameter_list|(
name|struct
name|vgafontattr
modifier|*
name|data
parameter_list|)
block|{
name|int
name|vga_character_set
decl_stmt|;
name|vga_character_set
operator|=
name|data
operator|->
name|character_set
expr_stmt|;
name|vga_character_set
operator|=
operator|(
name|vga_character_set
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|vga_character_set
operator|<
operator|(
name|int
operator|)
name|totalfonts
operator|)
condition|?
name|vga_character_set
else|:
call|(
name|int
call|)
argument_list|(
name|totalfonts
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|data
operator|->
name|character_set
operator|=
operator|(
name|int
operator|)
name|vga_character_set
expr_stmt|;
name|data
operator|->
name|font_loaded
operator|=
operator|(
name|int
operator|)
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|loaded
expr_stmt|;
name|data
operator|->
name|character_scanlines
operator|=
operator|(
name|int
operator|)
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|char_scanlines
operator|&
literal|0x1f
expr_stmt|;
comment|/* do not display the overflow bits */
name|data
operator|->
name|screen_scanlines
operator|=
operator|(
name|int
operator|)
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|scr_scanlines
expr_stmt|;
name|data
operator|->
name|screen_size
operator|=
operator|(
name|int
operator|)
name|vgacs
index|[
name|vga_character_set
index|]
operator|.
name|screen_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	ega/vga ioctl - load a character shape into character set  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgaloadchar
parameter_list|(
name|struct
name|vgaloadchar
modifier|*
name|data
parameter_list|)
block|{
name|int
name|vga_character_set
decl_stmt|;
name|int
name|character
decl_stmt|;
name|int
name|lines_per_character
decl_stmt|;
name|vga_character_set
operator|=
name|data
operator|->
name|character_set
expr_stmt|;
name|vga_character_set
operator|=
operator|(
name|vga_character_set
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|vga_character_set
operator|<
operator|(
name|int
operator|)
name|totalfonts
operator|)
condition|?
name|vga_character_set
else|:
call|(
name|int
call|)
argument_list|(
name|totalfonts
operator|-
literal|1
argument_list|)
operator|)
expr_stmt|;
name|character
operator|=
operator|(
name|data
operator|->
name|character
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|data
operator|->
name|character
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
name|data
operator|->
name|character
operator|)
expr_stmt|;
name|lines_per_character
operator|=
operator|(
name|int
operator|)
name|data
operator|->
name|character_scanlines
expr_stmt|;
name|lines_per_character
operator|=
operator|(
name|lines_per_character
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|lines_per_character
operator|>
literal|32
operator|)
condition|?
literal|32
else|:
name|lines_per_character
operator|)
expr_stmt|;
name|loadchar
argument_list|(
name|vga_character_set
argument_list|,
name|character
argument_list|,
name|lines_per_character
argument_list|,
name|data
operator|->
name|char_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	video ioctl - get screen information  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vid_getscreen
parameter_list|(
name|struct
name|screeninfo
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
block|{
name|int
name|device
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|data
operator|->
name|adaptor_type
operator|=
name|adaptor_type
expr_stmt|;
comment|/* video adapter installed */
name|data
operator|->
name|monitor_type
operator|=
name|color
expr_stmt|;
comment|/* monitor type installed */
name|data
operator|->
name|totalfonts
operator|=
name|totalfonts
expr_stmt|;
comment|/* no of downloadble fonts */
name|data
operator|->
name|totalscreens
operator|=
name|totalscreens
expr_stmt|;
comment|/* no of virtual screens */
name|data
operator|->
name|screen_no
operator|=
name|device
expr_stmt|;
comment|/* this screen number */
name|data
operator|->
name|current_screen
operator|=
name|current_video_screen
expr_stmt|;
comment|/* displayed screen no */
comment|/* screen size */
name|data
operator|->
name|screen_size
operator|=
name|vgacs
index|[
operator|(
name|vs
index|[
name|device
index|]
operator|.
name|vga_charset
operator|)
index|]
operator|.
name|screen_size
expr_stmt|;
comment|/* pure VT mode or HP/VT mode */
name|data
operator|->
name|pure_vt_mode
operator|=
name|vs
index|[
name|device
index|]
operator|.
name|vt_pure_mode
expr_stmt|;
name|data
operator|->
name|vga_family
operator|=
name|vga_family
expr_stmt|;
comment|/* manufacturer, family */
name|data
operator|->
name|vga_type
operator|=
name|vga_type
expr_stmt|;
comment|/* detected chipset type */
name|data
operator|->
name|vga_132
operator|=
name|can_do_132col
expr_stmt|;
comment|/* 132 column support */
name|data
operator|->
name|force_24lines
operator|=
name|vs
index|[
name|device
index|]
operator|.
name|force24
expr_stmt|;
comment|/* force 24 lines */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	video ioctl - set screen information  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vid_setscreen
parameter_list|(
name|struct
name|screeninfo
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
block|{
name|int
name|screen
decl_stmt|;
if|if
condition|(
name|data
operator|->
name|current_screen
operator|==
operator|-
literal|1
condition|)
block|{
name|screen
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|data
operator|->
name|current_screen
operator|>=
name|PCVT_NSCREENS
condition|)
return|return;
comment|/* XXXXXX */
name|screen
operator|=
name|data
operator|->
name|current_screen
expr_stmt|;
block|}
name|vgapage
argument_list|(
name|screen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
name|XSERVER
operator|&&
name|PCVT_USL_VT_COMPAT
block|{
name|int
name|x
init|=
name|spltty
argument_list|()
decl_stmt|,
name|waitfor
init|=
name|screen
operator|+
literal|1
decl_stmt|;
comment|/* if the vt is yet to be released by a process, wait here */
if|if
condition|(
name|vs
index|[
name|screen
index|]
operator|.
name|vt_status
operator|&
name|VT_WAIT_REL
condition|)
operator|(
name|void
operator|)
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|VT_WAITACTIVE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|waitfor
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
comment|/* make sure the switch really happened */
if|if
condition|(
name|screen
operator|!=
name|current_video_screen
condition|)
return|return;
comment|/* XXX should say "EAGAIN" here */
endif|#
directive|endif
comment|/* defined XSERVER&& PCVT_USL_VT_COMPAT */
if|if
condition|(
operator|(
name|data
operator|->
name|screen_size
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|data
operator|->
name|force_24lines
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|screen_size
operator|==
operator|-
literal|1
condition|)
name|data
operator|->
name|screen_size
operator|=
name|vgacs
index|[
operator|(
name|vs
index|[
name|screen
index|]
operator|.
name|vga_charset
operator|)
index|]
operator|.
name|screen_size
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|force_24lines
operator|!=
operator|-
literal|1
condition|)
block|{
name|vs
index|[
name|screen
index|]
operator|.
name|force24
operator|=
name|data
operator|->
name|force_24lines
expr_stmt|;
if|if
condition|(
name|vs
index|[
name|screen
index|]
operator|.
name|force24
condition|)
block|{
name|swritefkl
argument_list|(
literal|2
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"FORCE24 ENABLE *"
argument_list|,
operator|&
name|vs
index|[
name|screen
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|swritefkl
argument_list|(
literal|2
argument_list|,
operator|(
name|u_char
operator|*
operator|)
literal|"FORCE24 ENABLE  "
argument_list|,
operator|&
name|vs
index|[
name|screen
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_25ROWS
operator|)
operator|||
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_28ROWS
operator|)
operator|||
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_35ROWS
operator|)
operator|||
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_40ROWS
operator|)
operator|||
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_43ROWS
operator|)
operator|||
operator|(
name|data
operator|->
name|screen_size
operator|==
name|SIZ_50ROWS
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|screen_no
operator|==
operator|-
literal|1
condition|)
name|set_screen_size
argument_list|(
name|vsp
argument_list|,
name|data
operator|->
name|screen_size
argument_list|)
expr_stmt|;
else|else
name|set_screen_size
argument_list|(
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|data
operator|->
name|screen_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|data
operator|->
name|pure_vt_mode
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|data
operator|->
name|pure_vt_mode
operator|==
name|M_HPVT
operator|)
operator|||
operator|(
name|data
operator|->
name|pure_vt_mode
operator|==
name|M_PUREVT
operator|)
condition|)
block|{
if|if
condition|(
name|data
operator|->
name|screen_no
operator|==
operator|-
literal|1
condition|)
name|set_emulation_mode
argument_list|(
name|vsp
argument_list|,
name|data
operator|->
name|pure_vt_mode
argument_list|)
expr_stmt|;
else|else
name|set_emulation_mode
argument_list|(
operator|&
name|vs
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
argument_list|,
name|data
operator|->
name|pure_vt_mode
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set screen size/resolution for a virtual screen  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|set_screen_size
parameter_list|(
name|struct
name|video_state
modifier|*
name|svsp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vgacs
index|[
name|i
index|]
operator|.
name|screen_size
operator|==
name|size
condition|)
block|{
name|set_charset
argument_list|(
name|svsp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|clr_parms
argument_list|(
name|svsp
argument_list|)
expr_stmt|;
comment|/* escape parameter init */
name|svsp
operator|->
name|state
operator|=
name|STATE_INIT
expr_stmt|;
comment|/* initial state */
name|svsp
operator|->
name|scrr_beg
operator|=
literal|0
expr_stmt|;
comment|/* start of scrolling region */
name|svsp
operator|->
name|sc_flag
operator|=
literal|0
expr_stmt|;
comment|/* invalidate saved cursor 						 * position */
name|svsp
operator|->
name|transparent
operator|=
literal|0
expr_stmt|;
comment|/* disable control code 						 * processing */
comment|/* Update tty to reflect screen size */
if|if
condition|(
name|svsp
operator|->
name|vs_tty
condition|)
block|{
name|svsp
operator|->
name|vs_tty
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|svsp
operator|->
name|maxcol
expr_stmt|;
name|svsp
operator|->
name|vs_tty
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|=
operator|(
name|svsp
operator|->
name|maxcol
operator|==
literal|80
operator|)
condition|?
literal|720
else|:
literal|1056
expr_stmt|;
name|svsp
operator|->
name|vs_tty
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|=
literal|400
expr_stmt|;
name|svsp
operator|->
name|vs_tty
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|svsp
operator|->
name|screen_rows
expr_stmt|;
block|}
comment|/* screen_rows already calculated in set_charset() */
if|if
condition|(
name|svsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|&&
name|svsp
operator|->
name|labels_on
condition|)
block|{
if|if
condition|(
name|svsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|sw_sfkl
argument_list|(
name|svsp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|svsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
condition|)
name|sw_ufkl
argument_list|(
name|svsp
argument_list|)
expr_stmt|;
block|}
name|svsp
operator|->
name|scrr_len
operator|=
name|svsp
operator|->
name|screen_rows
expr_stmt|;
name|svsp
operator|->
name|scrr_end
operator|=
name|svsp
operator|->
name|scrr_len
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|PCVT_SIGWINCH
if|if
condition|(
name|svsp
operator|->
name|vs_tty
operator|&&
name|svsp
operator|->
name|vs_tty
operator|->
name|t_pgrp
condition|)
name|pgsignal
argument_list|(
name|svsp
operator|->
name|vs_tty
operator|->
name|t_pgrp
argument_list|,
name|SIGWINCH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SIGWINCH */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	VGA ioctl - read DAC palette entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgareadpel
parameter_list|(
name|struct
name|vgapel
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|unsigned
name|vpage
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|idx
init|=
name|data
operator|->
name|idx
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|NVGAPEL
condition|)
return|return;
comment|/* no such entry */
comment|/* do not read VGA palette directly, use saved values */
name|data
operator|->
name|r
operator|=
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|r
expr_stmt|;
name|data
operator|->
name|g
operator|=
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|g
expr_stmt|;
name|data
operator|->
name|b
operator|=
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|b
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	VGA ioctl - write DAC palette entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|vgawritepel
parameter_list|(
name|struct
name|vgapel
modifier|*
name|data
parameter_list|,
name|Dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|unsigned
name|vpage
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|idx
init|=
name|data
operator|->
name|idx
decl_stmt|;
if|if
condition|(
name|idx
operator|>=
name|NVGAPEL
condition|)
return|return;
comment|/* no such entry */
comment|/* first, update saved values for this video screen */
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|r
operator|=
name|data
operator|->
name|r
expr_stmt|;
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|g
operator|=
name|data
operator|->
name|g
expr_stmt|;
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
operator|.
name|b
operator|=
name|data
operator|->
name|b
expr_stmt|;
comment|/* if this happens on active screen, update VGA DAC, too */
if|if
condition|(
name|vpage
operator|==
name|current_video_screen
condition|)
name|vgapaletteio
argument_list|(
name|idx
argument_list|,
operator|&
name|vs
index|[
name|vpage
index|]
operator|.
name|palette
index|[
name|idx
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	VGA physical IO - read/write one palette entry  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vgapaletteio
parameter_list|(
name|unsigned
name|idx
parameter_list|,
name|struct
name|rgb
modifier|*
name|val
parameter_list|,
name|int
name|writeit
parameter_list|)
block|{
if|#
directive|if
name|PCVT_PALFLICKER
name|vga_screen_off
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_PALFLICKER */
if|if
condition|(
name|writeit
condition|)
block|{
name|outb
argument_list|(
name|VGA_DAC
operator|+
literal|2
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|outb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|,
name|val
operator|->
name|r
operator|&
name|VGA_PMSK
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|outb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|,
name|val
operator|->
name|g
operator|&
name|VGA_PMSK
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|outb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|,
name|val
operator|->
name|b
operator|&
name|VGA_PMSK
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* read it */
block|{
name|outb
argument_list|(
name|VGA_DAC
operator|+
literal|1
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|val
operator|->
name|r
operator|=
name|inb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|)
operator|&
name|VGA_PMSK
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|val
operator|->
name|g
operator|=
name|inb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|)
operator|&
name|VGA_PMSK
expr_stmt|;
if|#
directive|if
name|PCVT_WAITRETRACE
name|wait_retrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_WAITRETRACE */
name|val
operator|->
name|b
operator|=
name|inb
argument_list|(
name|VGA_DAC
operator|+
literal|3
argument_list|)
operator|&
name|VGA_PMSK
expr_stmt|;
block|}
if|#
directive|if
name|PCVT_PALFLICKER
name|vga_screen_on
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_PALFLICKER */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	update asynchronous: cursor, cursor pos displ, sys load, keyb scan  *  *	arg is:  *		UPDATE_START = 0 = do update; requeue  *		UPDATE_STOP  = 1 = suspend updates  *		UPDATE_KERN  = 2 = do update for kernel printfs  *  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|async_update
parameter_list|(
name|int
name|arg
parameter_list|)
block|{
specifier|static
name|int
name|lastpos
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|counter
init|=
name|PCVT_UPDATESLOW
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
comment|/* need a method to suspend the updates */
if|if
condition|(
name|arg
operator|==
name|UPDATE_STOP
condition|)
block|{
name|untimeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|async_update
argument_list|,
name|UPDATE_START
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* XSERVER */
comment|/* first check if update is possible */
if|if
condition|(
name|chargen_access
comment|/* does no-one load characters? */
ifdef|#
directive|ifdef
name|XSERVER
comment|/* is vt0 not in graphics mode? */
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
operator|||
name|pcvt_xmode
comment|/* XXX necessary ????? */
endif|#
directive|endif
comment|/* PCVT_USL_VT_COMPAT */
endif|#
directive|endif
comment|/* XSERVER */
condition|)
block|{
goto|goto
name|async_update_exit
goto|;
comment|/* do not update anything */
block|}
if|#
directive|if
name|PCVT_SCREENSAVER
if|if
condition|(
name|reset_screen_saver
operator|&&
operator|(
name|counter
operator|==
name|PCVT_UPDATESLOW
operator|)
condition|)
block|{
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
comment|/* yes, do it */
name|reset_screen_saver
operator|=
literal|0
expr_stmt|;
comment|/* re-init */
block|}
elseif|else
if|if
condition|(
name|scrnsv_active
condition|)
comment|/* is the screen not blanked? */
block|{
goto|goto
name|async_update_exit
goto|;
comment|/* do not update anything */
block|}
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
comment|/*-------------------------------------------------------------------*/
comment|/* this takes place on EVERY virtual screen (if not in X mode etc...)*/
comment|/*-------------------------------------------------------------------*/
if|if
condition|(
name|cursor_pos_valid
operator|&&
operator|(
name|lastpos
operator|!=
operator|(
name|vsp
operator|->
name|Crtat
operator|+
name|vsp
operator|->
name|cur_offset
operator|-
name|Crtat
operator|)
operator|)
condition|)
block|{
name|lastpos
operator|=
name|vsp
operator|->
name|Crtat
operator|+
name|vsp
operator|->
name|cur_offset
operator|-
name|Crtat
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORH
argument_list|)
expr_stmt|;
comment|/* high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|lastpos
operator|)
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORL
argument_list|)
expr_stmt|;
comment|/* low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|lastpos
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arg
operator|==
name|UPDATE_KERN
condition|)
comment|/* Magic arg: for kernel printfs */
return|return;
if|if
condition|(
operator|--
name|counter
condition|)
comment|/* below is possible update */
goto|goto
name|async_update_exit
goto|;
comment|/*  just now and then ..... */
name|counter
operator|=
name|PCVT_UPDATESLOW
expr_stmt|;
comment|/* caution, see screensaver above !! */
comment|/*-------------------------------------------------------------------*/
comment|/* this takes place ONLY on screen 0 if in HP mode, labels on, !X    */
comment|/*-------------------------------------------------------------------*/
comment|/* additional processing for HP necessary ? */
if|if
condition|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|labels_on
operator|)
condition|)
block|{
specifier|static
specifier|volatile
name|u_char
name|buffer
index|[]
init|=
literal|"System Load: 1min: 0.00 5min: 0.00 15min: 0.00"
decl_stmt|;
specifier|register
name|int
name|tmp
decl_stmt|,
name|i
decl_stmt|;
if|#
directive|if
name|PCVT_SHOWKEYS
specifier|extern
name|u_char
name|rawkeybuf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|keyboard_show
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|80
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|Crtat
operator|+
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|screen_rows
operator|+
literal|2
operator|)
operator|*
name|vs
index|[
literal|0
index|]
operator|.
name|maxcol
operator|)
operator|)
operator|+
name|i
operator|)
operator|=
name|user_attr
operator||
name|rawkeybuf
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
comment|/* display load averages in last line (taken from tty.c) */
name|i
operator|=
literal|18
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_AVERUNNABLE
name|tmp
operator|=
operator|(
name|averunnable
operator|.
name|ldavg
index|[
literal|0
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
operator|(
name|averunnable
index|[
literal|0
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
endif|#
directive|endif
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|==
literal|0
operator|)
condition|?
literal|' '
else|:
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
operator|)
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|i
operator|+=
literal|6
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_AVERUNNABLE
name|tmp
operator|=
operator|(
name|averunnable
operator|.
name|ldavg
index|[
literal|1
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
operator|(
name|averunnable
index|[
literal|1
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
endif|#
directive|endif
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|==
literal|0
operator|)
condition|?
literal|' '
else|:
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
operator|)
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|i
operator|+=
literal|7
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_AVERUNNABLE
name|tmp
operator|=
operator|(
name|averunnable
operator|.
name|ldavg
index|[
literal|2
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
operator|(
name|averunnable
index|[
literal|2
index|]
operator|*
literal|100
operator|+
name|FSCALE
operator|/
literal|2
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
endif|#
directive|endif
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|==
literal|0
operator|)
condition|?
literal|' '
else|:
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
operator|)
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|/
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
literal|'.'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
operator|++
index|]
operator|=
operator|(
operator|(
name|tmp
operator|%
literal|100
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buffer
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|Crtat
operator|+
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|screen_rows
operator|+
literal|2
operator|)
operator|*
name|vs
index|[
literal|0
index|]
operator|.
name|maxcol
operator|)
operator|)
operator|+
name|i
operator|)
operator|=
name|user_attr
operator||
name|buffer
index|[
name|i
index|]
expr_stmt|;
block|}
if|#
directive|if
name|PCVT_SHOWKEYS
for|for
control|(
init|;
name|i
operator|<
literal|77
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|Crtat
operator|+
operator|(
operator|(
name|vs
index|[
literal|0
index|]
operator|.
name|screen_rows
operator|+
literal|2
operator|)
operator|*
name|vs
index|[
literal|0
index|]
operator|.
name|maxcol
operator|)
operator|)
operator|+
name|i
operator|)
operator|=
name|user_attr
operator||
literal|' '
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
block|}
comment|/*-------------------------------------------------------------------*/
comment|/* this takes place on EVERY screen which is in HP mode, labels on,!X*/
comment|/*-------------------------------------------------------------------*/
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|labels_on
operator|)
condition|)
block|{
specifier|register
name|int
name|col
init|=
name|vsp
operator|->
name|col
operator|+
literal|1
decl_stmt|;
specifier|register
name|u_short
modifier|*
name|p
init|=
name|vsp
operator|->
name|Crtat
operator|+
operator|(
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
operator|)
decl_stmt|;
comment|/* update column display between labels */
if|if
condition|(
name|vsp
operator|->
name|maxcol
operator|==
name|SCR_COL132
condition|)
block|{
name|p
operator|+=
operator|(
name|SCR_COL132
operator|-
name|SCR_COL80
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|col
operator|>=
literal|100
condition|)
block|{
operator|*
operator|(
name|p
operator|+
name|LABEL_COLU
operator|)
operator|=
name|user_attr
operator||
literal|'1'
expr_stmt|;
name|col
operator|-=
literal|100
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|p
operator|+
name|LABEL_COLU
operator|)
operator|=
name|user_attr
operator||
literal|'0'
expr_stmt|;
block|}
block|}
operator|*
operator|(
name|p
operator|+
name|LABEL_COLH
operator|)
operator|=
name|user_attr
operator||
operator|(
operator|(
name|col
operator|/
literal|10
operator|)
operator|+
literal|'0'
operator|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
name|LABEL_COLL
operator|)
operator|=
name|user_attr
operator||
operator|(
operator|(
name|col
operator|%
literal|10
operator|)
operator|+
literal|'0'
operator|)
expr_stmt|;
comment|/* update row display between labels */
operator|*
operator|(
name|p
operator|+
name|LABEL_ROWH
operator|)
operator|=
operator|(
name|user_attr
operator||
operator|(
operator|(
operator|(
name|vsp
operator|->
name|row
operator|+
literal|1
operator|)
operator|/
literal|10
operator|)
operator|+
literal|'0'
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
name|p
operator|+
name|LABEL_ROWL
operator|)
operator|=
operator|(
name|user_attr
operator||
operator|(
operator|(
operator|(
name|vsp
operator|->
name|row
operator|+
literal|1
operator|)
operator|%
literal|10
operator|)
operator|+
literal|'0'
operator|)
operator|)
expr_stmt|;
block|}
name|async_update_exit
label|:
if|if
condition|(
name|arg
operator|==
name|UPDATE_START
condition|)
block|{
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|async_update
argument_list|,
name|UPDATE_START
argument_list|,
name|PCVT_UPDATEFAST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set character set for virtual screen  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|set_charset
parameter_list|(
name|struct
name|video_state
modifier|*
name|svsp
parameter_list|,
name|int
name|curvgacs
parameter_list|)
block|{
specifier|static
name|int
name|sizetab
index|[]
init|=
block|{
literal|25
block|,
literal|28
block|,
literal|35
block|,
literal|40
block|,
literal|43
block|,
literal|50
block|}
decl_stmt|;
name|int
name|oldsize
decl_stmt|,
name|oldrows
decl_stmt|,
name|newsize
decl_stmt|,
name|newrows
decl_stmt|;
if|if
condition|(
operator|(
name|curvgacs
operator|<
literal|0
operator|)
operator|||
operator|(
name|curvgacs
operator|>
operator|(
name|NVGAFONTS
operator|-
literal|1
operator|)
operator|)
condition|)
return|return;
name|svsp
operator|->
name|vga_charset
operator|=
name|curvgacs
expr_stmt|;
name|select_vga_charset
argument_list|(
name|curvgacs
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|svsp
operator|->
name|screen_rowsize
expr_stmt|;
name|oldrows
operator|=
name|svsp
operator|->
name|screen_rows
expr_stmt|;
name|newsize
operator|=
name|sizetab
index|[
operator|(
name|vgacs
index|[
name|curvgacs
index|]
operator|.
name|screen_size
operator|)
index|]
expr_stmt|;
name|newrows
operator|=
name|newsize
expr_stmt|;
if|if
condition|(
name|svsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
condition|)
name|newrows
operator|-=
literal|3
expr_stmt|;
if|if
condition|(
name|newrows
operator|==
literal|25
operator|&&
name|svsp
operator|->
name|force24
condition|)
name|newrows
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|newrows
operator|<
name|oldrows
condition|)
block|{
name|int
name|nscroll
init|=
name|svsp
operator|->
name|row
operator|+
literal|1
operator|-
name|newrows
decl_stmt|;
if|if
condition|(
name|svsp
operator|->
name|row
operator|>=
name|oldrows
condition|)
comment|/* Sanity check */
name|nscroll
operator|=
name|oldrows
operator|-
name|newrows
expr_stmt|;
if|if
condition|(
name|nscroll
operator|>
literal|0
condition|)
block|{
comment|/* Scroll up */
name|bcopy
argument_list|(
name|svsp
operator|->
name|Crtat
operator|+
name|nscroll
operator|*
name|svsp
operator|->
name|maxcol
argument_list|,
name|svsp
operator|->
name|Crtat
argument_list|,
name|newrows
operator|*
name|svsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|svsp
operator|->
name|row
operator|-=
name|nscroll
expr_stmt|;
name|svsp
operator|->
name|cur_offset
operator|-=
name|nscroll
operator|*
name|svsp
operator|->
name|maxcol
expr_stmt|;
block|}
if|if
condition|(
name|newrows
operator|<
name|newsize
condition|)
name|fillw
argument_list|(
name|user_attr
operator||
literal|' '
argument_list|,
name|svsp
operator|->
name|Crtat
operator|+
name|newrows
operator|*
name|svsp
operator|->
name|maxcol
argument_list|,
operator|(
name|newsize
operator|-
name|newrows
operator|)
operator|*
name|svsp
operator|->
name|maxcol
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oldrows
operator|<
name|newsize
condition|)
name|fillw
argument_list|(
name|user_attr
operator||
literal|' '
argument_list|,
name|svsp
operator|->
name|Crtat
operator|+
name|oldrows
operator|*
name|svsp
operator|->
name|maxcol
argument_list|,
operator|(
name|newsize
operator|-
name|oldrows
operator|)
operator|*
name|svsp
operator|->
name|maxcol
argument_list|)
expr_stmt|;
name|svsp
operator|->
name|screen_rowsize
operator|=
name|newsize
expr_stmt|;
name|svsp
operator|->
name|screen_rows
operator|=
name|newrows
expr_stmt|;
comment|/* Clip scrolling region */
if|if
condition|(
name|svsp
operator|->
name|scrr_end
operator|>
name|svsp
operator|->
name|screen_rows
operator|-
literal|1
condition|)
name|svsp
operator|->
name|scrr_end
operator|=
name|svsp
operator|->
name|screen_rows
operator|-
literal|1
expr_stmt|;
name|svsp
operator|->
name|scrr_len
operator|=
name|svsp
operator|->
name|scrr_end
operator|-
name|svsp
operator|->
name|scrr_beg
operator|+
literal|1
expr_stmt|;
comment|/* Clip cursor pos */
if|if
condition|(
name|svsp
operator|->
name|cur_offset
operator|>
operator|(
name|svsp
operator|->
name|scrr_len
operator|*
name|svsp
operator|->
name|maxcol
operator|)
condition|)
name|svsp
operator|->
name|cur_offset
operator|=
operator|(
name|svsp
operator|->
name|scrr_len
operator|*
name|svsp
operator|->
name|maxcol
operator|)
operator|+
name|svsp
operator|->
name|col
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	select a vga character set  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|select_vga_charset
parameter_list|(
name|int
name|vga_charset
parameter_list|)
block|{
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
name|int
name|fflag
init|=
literal|0
decl_stmt|;
name|int
name|sflag
init|=
literal|0
decl_stmt|;
name|u_char
name|cmap
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|cmaptaba
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x01
block|,
literal|0x02
block|,
literal|0x03
block|,
literal|0x10
block|,
literal|0x11
block|,
literal|0x12
block|,
literal|0x13
block|}
decl_stmt|;
specifier|static
name|u_char
name|cmaptabb
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x0c
block|,
literal|0x20
block|,
literal|0x24
block|,
literal|0x28
block|,
literal|0x2c
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|adaptor_type
operator|!=
name|EGA_ADAPTOR
operator|)
operator|&&
operator|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|vga_charset
operator|<
literal|0
operator|)
operator|||
operator|(
name|vga_charset
operator|>=
name|totalfonts
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|loaded
condition|)
return|return;
comment|/*-------------------------------------------------------------- 	   find the the first and second charset of a given resolution. 	   the first is used for lower 256 and the second (if any) is 	   used for the upper 256 entries of a complete 512 entry ega/ 	   vga charset. 	--------------------------------------------------------------*/
for|for
control|(
name|first
operator|=
literal|0
init|;
name|first
operator|<
name|totalfonts
condition|;
name|first
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vgacs
index|[
name|first
index|]
operator|.
name|loaded
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|first
index|]
operator|.
name|screen_size
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|screen_size
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|first
index|]
operator|.
name|char_scanlines
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|char_scanlines
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|first
index|]
operator|.
name|scr_scanlines
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|scr_scanlines
condition|)
continue|continue;
name|fflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fflag
operator|!=
literal|1
condition|)
return|return;
for|for
control|(
name|second
operator|=
name|first
operator|+
literal|1
init|;
name|second
operator|<
name|totalfonts
condition|;
name|second
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vgacs
index|[
name|second
index|]
operator|.
name|loaded
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|second
index|]
operator|.
name|screen_size
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|screen_size
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|second
index|]
operator|.
name|char_scanlines
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|char_scanlines
condition|)
continue|continue;
if|if
condition|(
name|vgacs
index|[
name|second
index|]
operator|.
name|scr_scanlines
operator|!=
name|vgacs
index|[
name|vga_charset
index|]
operator|.
name|scr_scanlines
condition|)
continue|continue;
name|sflag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|cmap
operator|=
name|cmaptaba
index|[
name|first
index|]
expr_stmt|;
if|if
condition|(
name|sflag
condition|)
block|{
name|cmap
operator||=
name|cmaptabb
index|[
name|second
index|]
expr_stmt|;
name|vgacs
index|[
name|first
index|]
operator|.
name|secondloaded
operator|=
name|second
expr_stmt|;
block|}
else|else
block|{
name|vgacs
index|[
name|first
index|]
operator|.
name|secondloaded
operator|=
literal|0
expr_stmt|;
comment|/*cs 0 can never become a 2nd!*/
block|}
if|if
condition|(
name|vsp
operator|->
name|wd132col
condition|)
block|{
name|cmap
operator|=
operator|(
name|vga_charset
operator|&
literal|0x07
operator|)
expr_stmt|;
name|cmap
operator||=
literal|0x10
expr_stmt|;
block|}
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_FONTSEL
argument_list|)
expr_stmt|;
comment|/* character map select register */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
name|cmap
argument_list|)
expr_stmt|;
comment|/* new char map */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_MAXROW
argument_list|)
expr_stmt|;
comment|/* max scan line reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vgacs
index|[
name|first
index|]
operator|.
name|char_scanlines
argument_list|)
expr_stmt|;
comment|/* scanlines/char */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_VDE
argument_list|)
expr_stmt|;
comment|/* vert display enable end */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vgacs
index|[
name|first
index|]
operator|.
name|scr_scanlines
argument_list|)
expr_stmt|;
comment|/* low byte of scr scanlines */
if|if
condition|(
operator|(
name|color
operator|==
literal|0
operator|)
operator|&&
operator|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
operator|)
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_ULOC
argument_list|)
expr_stmt|;
comment|/* underline location reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|vgacs
index|[
name|first
index|]
operator|.
name|char_scanlines
operator|&
literal|0x1F
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch vga-card to load a character set  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|setchargen
parameter_list|(
name|void
parameter_list|)
block|{
name|chargen_access
operator|=
literal|1
expr_stmt|;
comment|/* flag we are accessing the chargen ram */
comment|/* program sequencer to access character generator */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_WRPLMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
comment|/* write to map 2 */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MEMMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* sequential addressing */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
comment|/* program graphics controller to access character generator */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_RDPLANESEL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
comment|/* select map 2 for cpu reads */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* disable odd-even addressing */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MISC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* map starts at 0xA000 */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch vga-card to load a character set to plane 3  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|setchargen3
parameter_list|(
name|void
parameter_list|)
block|{
name|chargen_access
operator|=
literal|1
expr_stmt|;
comment|/* flag we are accessing the chargen ram */
comment|/* program sequencer to access character generator */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_WRPLMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x08
argument_list|)
expr_stmt|;
comment|/* write to map 3 */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MEMMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* sequential addressing */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
comment|/* program graphics controller to access character generator */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_RDPLANESEL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* select map 3 for cpu reads */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* disable odd-even addressing */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MISC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* map starts at 0xA000 */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch back vga-card to normal operation  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|resetchargen
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* program sequencer to access video ram */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_WRPLMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* write to map 0& 1 */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MEMMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* odd-even addressing */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
comment|/* program graphics controller to access character generator */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_RDPLANESEL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* select map 0 for cpu reads */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* enable odd-even addressing */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MISC
argument_list|)
expr_stmt|;
if|if
condition|(
name|color
condition|)
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x0e
argument_list|)
expr_stmt|;
comment|/* map starts at 0xb800 */
else|else
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
comment|/* map starts at 0xb000 */
name|chargen_access
operator|=
literal|0
expr_stmt|;
comment|/* flag we are NOT accessing the chargen ram */
block|}
end_function

begin_if
if|#
directive|if
name|PCVT_WAITRETRACE
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	wait for being in a retrace time window  *	NOTE: this is __VERY__ bad programming practice in this environment !!  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|wait_retrace
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|color
condition|)
block|{
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
empty_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
operator|&
literal|0x01
operator|)
condition|)
empty_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_WAITRETRACE */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch screen off (VGA only)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga_screen_off
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|old
decl_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* clocking mode reg */
name|old
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* get current value */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* clocking mode reg */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|(
name|old
operator||
literal|0x20
operator|)
argument_list|)
expr_stmt|;
comment|/* screen off bit on */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch screen back on (VGA only)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga_screen_on
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|old
decl_stmt|;
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* clocking mode reg */
name|old
operator|=
name|inb
argument_list|(
name|TS_DATA
argument_list|)
expr_stmt|;
comment|/* get current value */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MODE
argument_list|)
expr_stmt|;
comment|/* clocking mode reg */
name|outb
argument_list|(
name|TS_DATA
argument_list|,
operator|(
name|old
operator|&
operator|~
literal|0x20
operator|)
argument_list|)
expr_stmt|;
comment|/* screen off bit off */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	compute character set base address (in kernel map)  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|compute_charset_base
parameter_list|(
name|unsigned
name|fontset
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|d
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|Crtat
decl_stmt|;
specifier|static
name|int
name|charset_offset
index|[
literal|8
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x4000
block|,
literal|0x8000
block|,
literal|0xC000
block|,
literal|0x2000
block|,
literal|0x6000
block|,
literal|0xA000
block|,
literal|0xE000
block|}
decl_stmt|;
specifier|static
name|int
name|charsetw_offset
index|[
literal|8
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x2000
block|,
literal|0x4000
block|,
literal|0x6000
block|,
literal|0x8000
block|,
literal|0xA000
block|,
literal|0xC000
block|,
literal|0xE000
block|}
decl_stmt|;
switch|switch
condition|(
name|adaptor_type
condition|)
block|{
case|case
name|EGA_ADAPTOR
case|:
name|fontset
operator|=
operator|(
name|fontset
operator|>
literal|3
operator|)
condition|?
literal|3
else|:
name|fontset
expr_stmt|;
break|break;
case|case
name|VGA_ADAPTOR
case|:
name|fontset
operator|=
operator|(
name|fontset
operator|>
literal|7
operator|)
condition|?
literal|7
else|:
name|fontset
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
if|if
condition|(
name|color
condition|)
name|d
operator|-=
operator|(
literal|0xB8000
operator|-
literal|0xA0000
operator|)
expr_stmt|;
comment|/* Point to 0xA0000 */
else|else
name|d
operator|-=
operator|(
literal|0xB0000
operator|-
literal|0xA0000
operator|)
expr_stmt|;
comment|/* Point to 0xA0000 */
if|if
condition|(
name|vsp
operator|->
name|wd132col
condition|)
name|d
operator|+=
name|charsetw_offset
index|[
name|fontset
index|]
expr_stmt|;
comment|/* Load into Character set n */
else|else
name|d
operator|+=
name|charset_offset
index|[
name|fontset
index|]
expr_stmt|;
comment|/* Load into Character set n */
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	load a char into ega/vga character generator ram  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|loadchar
parameter_list|(
name|int
name|fontset
parameter_list|,
name|int
name|character
parameter_list|,
name|int
name|char_scanlines
parameter_list|,
name|u_char
modifier|*
name|char_table
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|d
decl_stmt|;
if|#
directive|if
name|PCVT_BACKUP_FONTS
name|unsigned
name|char
modifier|*
name|bak
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_BACKUP_FONTS */
name|int
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
operator|(
name|d
operator|=
name|compute_charset_base
argument_list|(
name|fontset
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|d
operator|+=
operator|(
name|character
operator|*
literal|32
operator|)
expr_stmt|;
comment|/* 32 bytes per character */
if|if
condition|(
name|vsp
operator|->
name|wd132col
operator|&&
operator|(
name|fontset
operator|==
literal|1
operator|||
name|fontset
operator|==
literal|3
operator|||
name|fontset
operator|==
literal|5
operator|||
name|fontset
operator|==
literal|7
operator|)
condition|)
name|setchargen3
argument_list|()
expr_stmt|;
comment|/* access chargen ram */
else|else
name|setchargen
argument_list|()
expr_stmt|;
comment|/* access chargen ram */
for|for
control|(
name|j
operator|=
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|char_scanlines
condition|;
name|j
operator|++
control|)
comment|/* x bit high characters */
block|{
operator|*
name|d
operator|=
name|char_table
index|[
name|k
index|]
expr_stmt|;
name|d
operator|++
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
comment|/* Up to 32 bytes per character image*/
block|{
operator|*
name|d
operator|=
literal|0x00
expr_stmt|;
name|d
operator|++
expr_stmt|;
block|}
name|resetchargen
argument_list|()
expr_stmt|;
comment|/* access video ram */
if|#
directive|if
name|PCVT_BACKUP_FONTS
if|if
condition|(
name|saved_charsets
index|[
name|fontset
index|]
operator|==
literal|0
condition|)
name|saved_charsets
index|[
name|fontset
index|]
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
literal|32
operator|*
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bak
operator|=
name|saved_charsets
index|[
name|fontset
index|]
operator|)
condition|)
block|{
comment|/* make a backup copy of this char */
name|bak
operator|+=
operator|(
name|character
operator|*
literal|32
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|bak
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|char_table
argument_list|,
name|bak
argument_list|,
name|char_scanlines
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
else|else
name|panic
argument_list|(
literal|"pcvt loadchar: no backup buffer"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DIAGNOSTIC */
endif|#
directive|endif
comment|/* PCVT_BACKUP_FONTS */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	save/restore character set n to addr b  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
operator|!
name|PCVT_BACKUP_FONTS
end_if

begin_function
name|void
name|vga_move_charset
parameter_list|(
name|unsigned
name|n
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|int
name|save_it
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|d
init|=
name|compute_charset_base
argument_list|(
name|n
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vga_move_charset: wrong adaptor"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsp
operator|->
name|wd132col
operator|&&
operator|(
name|n
operator|==
literal|1
operator|||
name|n
operator|==
literal|3
operator|||
name|n
operator|==
literal|5
operator|||
name|n
operator|==
literal|7
operator|)
condition|)
block|{
name|setchargen3
argument_list|()
expr_stmt|;
name|d
operator|-=
literal|0x2000
expr_stmt|;
block|}
else|else
block|{
name|setchargen
argument_list|()
expr_stmt|;
block|}
comment|/* PLEASE, leave the following alone using bcopyb, as several	*/
comment|/* chipsets have problems if their memory is accessed with 32	*/
comment|/* or 16 bits wide, don't change this to using bcopy for speed!	*/
if|if
condition|(
name|save_it
condition|)
name|bcopyb
argument_list|(
name|d
argument_list|,
name|b
argument_list|,
literal|256
comment|/* chars */
operator|*
literal|32
comment|/* bytes per char */
argument_list|)
expr_stmt|;
else|else
name|bcopyb
argument_list|(
name|b
argument_list|,
name|d
argument_list|,
literal|256
comment|/* chars */
operator|*
literal|32
comment|/* bytes per char */
argument_list|)
expr_stmt|;
name|resetchargen
argument_list|()
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PCVT_BACKUP_FONTS */
end_comment

begin_comment
comment|/* since there are always backed up copies, we do not save anything here */
end_comment

begin_comment
comment|/* parameter "b" is totally ignored */
end_comment

begin_function
name|void
name|vga_move_charset
parameter_list|(
name|unsigned
name|n
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|int
name|save_it
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|d
init|=
name|compute_charset_base
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|save_it
condition|)
return|return;
if|if
condition|(
name|saved_charsets
index|[
name|n
index|]
operator|==
literal|0
condition|)
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"pcvt: restoring unbuffered charset"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"vga_move_charset: wrong adaptor"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vsp
operator|->
name|wd132col
operator|&&
operator|(
name|n
operator|==
literal|1
operator|||
name|n
operator|==
literal|3
operator|||
name|n
operator|==
literal|5
operator|||
name|n
operator|==
literal|7
operator|)
condition|)
block|{
name|setchargen3
argument_list|()
expr_stmt|;
name|d
operator|-=
literal|0x2000
expr_stmt|;
block|}
else|else
block|{
name|setchargen
argument_list|()
expr_stmt|;
block|}
comment|/* PLEASE, leave the following alone using bcopyb, as several	*/
comment|/* chipsets have problems if their memory is accessed with 32	*/
comment|/* or 16 bits wide, don't change this to using bcopy for speed!	*/
name|bcopyb
argument_list|(
name|saved_charsets
index|[
name|n
index|]
argument_list|,
name|d
argument_list|,
literal|256
comment|/* chars */
operator|*
literal|32
comment|/* bytes per char */
argument_list|)
expr_stmt|;
name|resetchargen
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_BACKUP_FONTS */
end_comment

begin_if
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch to virtual screen n (0 ... PCVT_NSCREENS-1)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vgapage
parameter_list|(
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|int
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
name|int
name|cols
init|=
name|vsp
operator|->
name|maxcol
decl_stmt|;
comment|/* get current col val */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|totalscreens
condition|)
return|return;
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* protect us */
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
comment|/* video board memory -> kernel memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|vsp
operator|->
name|Memory
argument_list|,
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|vsp
operator|->
name|Memory
expr_stmt|;
comment|/* operate in memory now */
comment|/* update global screen pointers/variables */
name|current_video_screen
operator|=
name|n
expr_stmt|;
comment|/* current screen no */
if|#
directive|if
operator|!
name|PCVT_NETBSD
operator|&&
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
name|pcconsp
operator|=
operator|&
name|pccons
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
elif|#
directive|elif
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
name|pcconsp
operator|=
name|pccons
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
else|#
directive|else
name|pcconsp
operator|=
name|pc_tty
index|[
name|n
index|]
expr_stmt|;
comment|/* current tty */
endif|#
directive|endif
name|vsp
operator|=
operator|&
name|vs
index|[
name|n
index|]
expr_stmt|;
comment|/* current video state ptr */
comment|/* kernel memory -> video board memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|Crtat
argument_list|,
name|vsp
operator|->
name|screen_rows
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|Crtat
expr_stmt|;
comment|/* operate on screen now */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|PCVT_KBD_FIFO
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
name|select_vga_charset
argument_list|(
name|vsp
operator|->
name|vga_charset
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|maxcol
operator|!=
name|cols
condition|)
name|vga_col
argument_list|(
name|vsp
argument_list|,
name|vsp
operator|->
name|maxcol
argument_list|)
expr_stmt|;
comment|/* select 80/132 columns */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORH
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cur_offset
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORL
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cur_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|cursor_on
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CUREND
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sw_cursor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* switch VGA DAC palette entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NVGAPEL
condition|;
name|i
operator|++
control|)
name|vgapaletteio
argument_list|(
name|i
argument_list|,
operator|&
name|vsp
operator|->
name|palette
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|update_led
argument_list|()
expr_stmt|;
comment|/* update led's */
name|update_hp
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
comment|/* update fkey labels, if present */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !PCVT_USL_VT_COMPAT */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	test if it is a vga  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|vga_test
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|old
decl_stmt|,
name|new
decl_stmt|,
name|check
decl_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|old
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get current value */
name|new
operator|=
name|old
operator||
name|CURSOR_ON_BIT
expr_stmt|;
comment|/* set cursor on by setting bit 5 on */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* cursor should be on now */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|check
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get current value */
if|if
condition|(
name|check
operator|!=
name|new
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* failsafe */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* must be ega */
block|}
name|new
operator|=
name|old
operator|&
operator|~
name|CURSOR_ON_BIT
expr_stmt|;
comment|/* turn cursor off by clearing bit 5 */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* cursor should be off now */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|check
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* get current value */
if|if
condition|(
name|check
operator|!=
name|new
condition|)
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* failsafe */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* must be ega */
block|}
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* failsafe */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* vga */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	convert upper/lower sixel font array to vga font array  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|sixel_vga
parameter_list|(
name|struct
name|sixels
modifier|*
name|sixelp
parameter_list|,
name|u_char
modifier|*
name|vgachar
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|int
name|shift
decl_stmt|;
specifier|register
name|u_char
name|mask
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|vgachar
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
literal|0x01
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|6
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shift
operator|=
literal|7
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|shift
operator|--
control|)
name|vgachar
index|[
name|j
index|]
operator||=
operator|(
operator|(
operator|(
operator|(
name|sixelp
operator|->
name|upper
index|[
name|i
index|]
operator|)
operator|&
name|mask
operator|)
operator|>>
name|j
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
name|mask
operator|=
literal|0x01
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|shift
operator|=
literal|7
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|shift
operator|--
control|)
name|vgachar
index|[
name|j
operator|+
literal|6
index|]
operator||=
operator|(
operator|(
operator|(
operator|(
name|sixelp
operator|->
name|lower
index|[
name|i
index|]
operator|)
operator|&
name|mask
operator|)
operator|>>
name|j
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|mask
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Expand 8x10 EGA/VGA characters to 8x16 EGA/VGA characters  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga10_vga16
parameter_list|(
name|u_char
modifier|*
name|invga
parameter_list|,
name|u_char
modifier|*
name|outvga
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Keep the top and bottom scanlines the same and double every scan 	 * line in between. 	 */
name|outvga
index|[
literal|0
index|]
operator|=
name|invga
index|[
literal|0
index|]
expr_stmt|;
name|outvga
index|[
literal|1
index|]
operator|=
name|invga
index|[
literal|1
index|]
expr_stmt|;
name|outvga
index|[
literal|14
index|]
operator|=
name|invga
index|[
literal|8
index|]
expr_stmt|;
name|outvga
index|[
literal|15
index|]
operator|=
name|invga
index|[
literal|9
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|2
init|;
name|i
operator|<
literal|8
operator|&&
name|j
operator|<
literal|14
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|outvga
index|[
name|j
index|]
operator|=
name|invga
index|[
name|i
index|]
expr_stmt|;
name|outvga
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|invga
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Expand 8x10 EGA/VGA characters to 8x14 EGA/VGA characters  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga10_vga14
parameter_list|(
name|u_char
modifier|*
name|invga
parameter_list|,
name|u_char
modifier|*
name|outvga
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Double the top two and bottom two scanlines and copy everything 	 * in between. 	 */
name|outvga
index|[
literal|0
index|]
operator|=
name|invga
index|[
literal|0
index|]
expr_stmt|;
name|outvga
index|[
literal|1
index|]
operator|=
name|invga
index|[
literal|0
index|]
expr_stmt|;
name|outvga
index|[
literal|2
index|]
operator|=
name|invga
index|[
literal|1
index|]
expr_stmt|;
name|outvga
index|[
literal|3
index|]
operator|=
name|invga
index|[
literal|1
index|]
expr_stmt|;
name|outvga
index|[
literal|10
index|]
operator|=
name|invga
index|[
literal|8
index|]
expr_stmt|;
name|outvga
index|[
literal|11
index|]
operator|=
name|invga
index|[
literal|8
index|]
expr_stmt|;
name|outvga
index|[
literal|12
index|]
operator|=
name|invga
index|[
literal|9
index|]
expr_stmt|;
name|outvga
index|[
literal|13
index|]
operator|=
name|invga
index|[
literal|9
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|outvga
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|invga
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Expand 8x10 EGA/VGA characters to 8x10 EGA/VGA characters  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga10_vga10
parameter_list|(
name|u_char
modifier|*
name|invga
parameter_list|,
name|u_char
modifier|*
name|outvga
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|outvga
index|[
name|i
index|]
operator|=
name|invga
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Contract 8x10 EGA/VGA characters to 8x8 EGA/VGA characters  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|vga10_vga8
parameter_list|(
name|u_char
modifier|*
name|invga
parameter_list|,
name|u_char
modifier|*
name|outvga
parameter_list|)
block|{
comment|/* Skip scanlines 3 and 7 */
name|outvga
index|[
literal|0
index|]
operator|=
name|invga
index|[
literal|0
index|]
expr_stmt|;
name|outvga
index|[
literal|1
index|]
operator|=
name|invga
index|[
literal|1
index|]
expr_stmt|;
name|outvga
index|[
literal|2
index|]
operator|=
name|invga
index|[
literal|2
index|]
expr_stmt|;
name|outvga
index|[
literal|3
index|]
operator|=
name|invga
index|[
literal|4
index|]
expr_stmt|;
name|outvga
index|[
literal|4
index|]
operator|=
name|invga
index|[
literal|5
index|]
expr_stmt|;
name|outvga
index|[
literal|5
index|]
operator|=
name|invga
index|[
literal|6
index|]
expr_stmt|;
name|outvga
index|[
literal|6
index|]
operator|=
name|invga
index|[
literal|8
index|]
expr_stmt|;
name|outvga
index|[
literal|7
index|]
operator|=
name|invga
index|[
literal|9
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	force a vga card to behave like an ega for debugging  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|FORCE_EGA
end_if

begin_function
name|void
name|force_ega
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|vgareg
decl_stmt|;
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
block|{
name|adaptor_type
operator|=
name|EGA_ADAPTOR
expr_stmt|;
name|totalfonts
operator|=
literal|4
expr_stmt|;
name|vgareg
operator|=
name|inb
argument_list|(
name|GN_MISCOUTR
argument_list|)
expr_stmt|;
comment|/* Miscellaneous Output Register */
name|vgareg
operator||=
literal|128
expr_stmt|;
comment|/* Set 350 scanline mode */
name|vgareg
operator|&=
operator|~
literal|64
expr_stmt|;
name|outb
argument_list|(
name|GN_MISCOUTW
argument_list|,
name|vgareg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FORCE_EGA */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	disconnect attribute bit 3 from generating intensity  *	(and use it for a second character set !)  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|set_2ndcharset
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|color
condition|)
comment|/* prepare to access index register! */
name|inb
argument_list|(
name|GN_INPSTAT1C
argument_list|)
expr_stmt|;
else|else
name|inb
argument_list|(
name|GN_INPSTAT1M
argument_list|)
expr_stmt|;
comment|/* select color plane enable reg, caution: set ATC access bit ! */
name|outb
argument_list|(
name|ATC_INDEX
argument_list|,
operator|(
name|ATC_COLPLEN
operator||
name|ATC_ACCESS
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC_DATAW
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* disable plane 3 */
block|}
end_function

begin_if
if|#
directive|if
name|PCVT_SCREENSAVER
end_if

begin_if
if|#
directive|if
name|PCVT_PRETTYSCRNS
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  * produce some kinda random number, had a look into the system library...  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_short
name|getrand
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|PCVT_FREEBSD
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
comment|/* time-of-day register */
endif|#
directive|endif
specifier|static
name|unsigned
name|long
name|seed
init|=
literal|1
decl_stmt|;
specifier|register
name|u_short
name|res
init|=
operator|(
name|u_short
operator|)
name|seed
decl_stmt|;
name|seed
operator|=
name|seed
operator|*
literal|1103515245L
operator|+
name|time
operator|.
name|tv_sec
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	produce "nice" screensaving ....  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|scrnsv_blink
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|rgb
name|blink_rgb
index|[
literal|8
index|]
init|=
block|{
block|{
literal|63
block|,
literal|63
block|,
literal|63
block|}
block|,
comment|/* white */
block|{
literal|0
block|,
literal|63
block|,
literal|42
block|}
block|,
comment|/* pale green */
block|{
literal|63
block|,
literal|63
block|,
literal|0
block|}
block|,
comment|/* yellow */
block|{
literal|63
block|,
literal|21
block|,
literal|63
block|}
block|,
comment|/* violet */
block|{
literal|42
block|,
literal|63
block|,
literal|0
block|}
block|,
comment|/* yellow-green */
block|{
literal|63
block|,
literal|42
block|,
literal|0
block|}
block|,
comment|/* amber */
block|{
literal|63
block|,
literal|42
block|,
literal|42
block|}
block|,
comment|/* rose */
block|{
literal|21
block|,
literal|42
block|,
literal|42
block|}
comment|/* cyan */
block|}
decl_stmt|;
specifier|register
name|u_short
name|r
init|=
name|getrand
argument_list|()
decl_stmt|;
name|unsigned
name|pos
init|=
operator|(
name|r
operator|%
operator|(
name|scrnsv_size
operator|/
literal|2
operator|)
operator|)
decl_stmt|;
operator|*
name|scrnsv_current
operator|=
comment|/* (0<< 8) + */
literal|' '
expr_stmt|;
name|scrnsv_current
operator|=
name|vsp
operator|->
name|Crtat
operator|+
name|pos
expr_stmt|;
operator|*
name|scrnsv_current
operator|=
operator|(
literal|7
comment|/* LIGHTGRAY */
operator|<<
literal|8
operator|)
operator|+
literal|'*'
expr_stmt|;
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
name|vgapaletteio
argument_list|(
literal|7
comment|/* LIGHTGRAY */
argument_list|,
operator|&
name|blink_rgb
index|[
operator|(
name|r
operator|>>
literal|4
operator|)
operator|&
literal|7
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_blink
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_PRETTYSCRNS */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set timeout time  *---------------------------------------------------------------------------*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XSERVER
end_ifndef

begin_decl_stmt
specifier|static
name|void
name|pcvt_set_scrnsv_tmo
argument_list|(
name|int
name|timeout
argument_list|)
else|#
directive|else
name|void
name|pcvt_set_scrnsv_tmo
argument_list|(
name|int
name|timeout
argument_list|)
endif|#
directive|endif
comment|/* XSERVER */
block|{
name|int
name|x
init|=
name|splhigh
argument_list|()
decl_stmt|;
if|if
condition|(
name|scrnsv_timeout
condition|)
name|untimeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_timedout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|scrnsv_timeout
operator|=
name|timeout
expr_stmt|;
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
comment|/* sanity */
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
operator|&&
name|savedscreen
condition|)
block|{
comment|/* release buffer when screen saver turned off */
name|free
argument_list|(
name|savedscreen
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|savedscreen
operator|=
operator|(
name|u_short
operator|*
operator|)
literal|0
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/*---------------------------------------------------------------------------*  *	we were timed out  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|scrnsv_timedout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* this function is called by timeout() */
comment|/* raise priority to avoid conflicts with kbd intr */
name|int
name|x
init|=
name|spltty
argument_list|()
decl_stmt|;
comment|/* 	 * due to some undefined problems with video adaptor RAM 	 * access timing, the following has been splitted into 	 * two pieces called subsequently with a time difference 	 * of 100 millisec 	 */
if|if
condition|(
operator|++
name|scrnsv_active
operator|==
literal|1
condition|)
block|{
specifier|register
name|size_t
name|s
decl_stmt|;
comment|/* 		 * first, allocate a buffer 		 * do only if none allocated yet or another size required 		 * this reduces malloc() overhead by avoiding successive 		 * calls to malloc() and free() if they would have requested 		 * the same buffer 		 * 		 * XXX This is inherited from old days where no buffering 		 * happened at all. Meanwhile we should use the standard 		 * screen buffer instead. Any volunteers? :-) [At least, 		 * this code proved to work...] 		 */
name|s
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|*
name|vsp
operator|->
name|screen_rowsize
operator|*
name|vsp
operator|->
name|maxcol
expr_stmt|;
if|if
condition|(
name|savedscreen
operator|==
operator|(
name|u_short
operator|*
operator|)
literal|0
operator|||
name|s
operator|!=
name|scrnsv_size
condition|)
block|{
comment|/* really need to allocate */
if|if
condition|(
name|savedscreen
condition|)
name|free
argument_list|(
name|savedscreen
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|scrnsv_size
operator|=
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|savedscreen
operator|=
operator|(
name|u_short
operator|*
operator|)
name|malloc
argument_list|(
name|s
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
operator|(
name|u_short
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* 				 * didn't get the buffer memory, 				 * turn off screen saver 				 */
name|scrnsv_timeout
operator|=
name|scrnsv_active
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* save current screen */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|savedscreen
argument_list|,
name|scrnsv_size
argument_list|)
expr_stmt|;
comment|/* on VGA's, make sure palette is set to blank screen */
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
block|{
name|struct
name|rgb
name|black
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|vgapaletteio
argument_list|(
literal|0
comment|/* BLACK */
argument_list|,
operator|&
name|black
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* prepare for next time... */
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_timedout
comment|/* me! */
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* second call, now blank the screen */
comment|/* fill screen with blanks */
name|fillw
argument_list|(
comment|/* (BLACK<<8) + */
literal|' '
argument_list|,
name|vsp
operator|->
name|Crtat
argument_list|,
name|scrnsv_size
operator|/
literal|2
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_PRETTYSCRNS
name|scrnsv_current
operator|=
name|vsp
operator|->
name|Crtat
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_blink
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_PRETTYSCRNS */
name|sw_cursor
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* cursor off on mda/cga */
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	interface to screensaver "subsystem"  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|pcvt_scrnsv_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * to save lotta time with superfluous timeout()/untimeout() calls 	 * when having massive output operations, we remember the last 	 * second of kernel timer we've rescheduled scrnsv_timedout() 	 */
specifier|static
name|long
name|last_schedule
init|=
literal|0L
decl_stmt|;
specifier|register
name|int
name|x
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|int
name|reschedule
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|scrnsv_active
operator|==
literal|1
operator|||
name|scrnsv_timeout
operator|)
operator|&&
name|last_schedule
operator|!=
name|time
operator|.
name|tv_sec
condition|)
block|{
name|last_schedule
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|reschedule
operator|=
literal|1
expr_stmt|;
name|untimeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_timedout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scrnsv_active
condition|)
block|{
if|#
directive|if
name|PCVT_PRETTYSCRNS
if|if
condition|(
name|scrnsv_active
operator|>
literal|1
condition|)
name|untimeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_blink
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_PRETTYSCRNS */
name|bcopy
argument_list|(
name|savedscreen
argument_list|,
name|vsp
operator|->
name|Crtat
argument_list|,
name|scrnsv_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|adaptor_type
operator|==
name|VGA_ADAPTOR
condition|)
block|{
comment|/* back up VGA palette info */
name|vgapaletteio
argument_list|(
literal|0
comment|/* BLACK */
argument_list|,
operator|&
name|vsp
operator|->
name|palette
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_PRETTYSCRNS
name|vgapaletteio
argument_list|(
literal|7
comment|/* LIGHTGRAY */
argument_list|,
operator|&
name|vsp
operator|->
name|palette
index|[
literal|7
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_PRETTYSCRNS */
block|}
name|scrnsv_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|cursor_on
condition|)
name|sw_cursor
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* cursor on */
block|}
if|if
condition|(
name|reschedule
condition|)
block|{
comment|/* mark next timeout */
name|timeout
argument_list|(
operator|(
name|TIMEOUT_FUNC_T
operator|)
name|scrnsv_timedout
argument_list|,
name|NULL
argument_list|,
name|scrnsv_timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_SCREENSAVER */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch cursor on/off  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|sw_cursor
parameter_list|(
name|int
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|adaptor_type
operator|==
name|EGA_ADAPTOR
condition|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|start
operator|=
name|vsp
operator|->
name|cursor_start
expr_stmt|;
name|end
operator|=
name|vsp
operator|->
name|cursor_end
expr_stmt|;
block|}
else|else
block|{
name|int
name|cs
init|=
name|vs
index|[
name|current_video_screen
index|]
operator|.
name|vga_charset
decl_stmt|;
name|cs
operator|=
operator|(
name|cs
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
operator|(
name|cs
operator|<
name|totalfonts
operator|)
condition|?
name|cs
else|:
name|totalfonts
operator|-
literal|1
operator|)
expr_stmt|;
name|start
operator|=
operator|(
name|vgacs
index|[
name|cs
index|]
operator|.
name|char_scanlines
operator|&
literal|0x1F
operator|)
operator|+
literal|1
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
block|}
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CUREND
argument_list|)
expr_stmt|;
comment|/* cursor end reg */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* mda, cga, vga */
block|{
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* cursor start reg */
if|if
condition|(
name|onoff
condition|)
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_start
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|CURSOR_ON_BIT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	cold init support, if a mono monitor is attached to a  *	vga or ega, it comes up with a mda emulation. switch  *	board to generic ega/vga mode in this case.  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|mda2egaorvga
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * program sequencer to access 	 * video ram 	 */
comment|/* synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* write to map 0& 1 */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_WRPLMASK
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* odd-even addressing */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_MEMMODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* clear synchronous reset */
name|outb
argument_list|(
name|TS_INDEX
argument_list|,
name|TS_SYNCRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TS_DATA
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* 	 * program graphics controller 	 * to access character 	 * generator 	 */
comment|/* select map 0 for cpu reads */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_RDPLANESEL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* enable odd-even addressing */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MODE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
comment|/* map starts at 0xb000 */
name|outb
argument_list|(
name|GDC_INDEX
argument_list|,
name|GDC_MISC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDC_DATA
argument_list|,
literal|0x0a
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVT> 0 */
end_comment

begin_comment
comment|/* ------------------------- E O F ------------------------------------------*/
end_comment

end_unit

