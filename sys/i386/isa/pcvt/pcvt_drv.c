begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.  *  * Copyright (c) 1992, 1993 Brian Dunford-Shore and Scott Turner.  *  * Copyright (c) 1993 Charles Hannum.  *  * All rights reserved.  *  * Parts of this code regarding the NetBSD interface were written  * by Charles Hannum.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by  *	Hellmuth Michaelis, Brian Dunford-Shore, Joerg Wunsch, Scott Turner  *	and Charles Hannum.  * 4. The name authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * @(#)pcvt_drv.c, 3.20, Last Edit-Date: [Sun Apr  2 19:09:19 1995]  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	pcvt_drv.c	VT220 Driver Main Module / OS - Interface  *	---------------------------------------------------------  *	-hm	------------ Release 3.00 --------------  *	-hm	integrating NetBSD-current patches  *	-hm	adding ttrstrt() proto for NetBSD 0.9  *	-hm	kernel/console output cursor positioning fixed  *	-hm	kernel/console output switches optional to screen 0  *	-hm	FreeBSD 1.1 porting  *	-hm	the NetBSD 0.9 compiler detected a nondeclared var which was  *		 NOT detected by neither the NetBSD-current nor FreeBSD 1.x!  *	-hm	including Michael's keyboard fifo code  *	-hm	Joergs patch for FreeBSD tty-malloc code  *	-hm	adjustments for NetBSD-current  *	-hm	FreeBSD bugfix from Joerg re timeout/untimeout casts  *	-jw	including Thomas Gellekum's FreeBSD 1.1.5 patch  *	-hm	adjusting #if's for NetBSD-current  *	-hm	applying Joerg's patch for FreeBSD 2.0  *	-hm	patch from Onno& Martin for NetBSD-current (post 1.0)  *	-hm	some adjustments for NetBSD 1.0  *	-hm	NetBSD PR #400: screen size report for new session  *	-hm	patch from Rafael Boni/Lon Willett for NetBSD-current  *	-hm	bell patch from Thomas Eberhardt for NetBSD  *	-hm	multiple X server bugfixes from Lon Willett  *	-hm	patch from joerg - pcdevtotty for FreeBSD pre-2.1  *	-hm	delay patch from Martin Husemann after port-i386 ml-discussion  *	-jw	add some code to provide more FreeBSD pre-2.1 support  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"vt.h"
end_include

begin_if
if|#
directive|if
name|NVT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/* allocate mem */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/pcvt/pcvt_hdr.h>
end_include

begin_comment
comment|/* global include */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAXCONS
argument_list|)
end_if

begin_define
define|#
directive|define
name|MAXCONS
value|16
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
modifier|*
name|pcvt_devfs_token
index|[
name|MAXCONS
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_if
if|#
directive|if
name|PCVT_FREEBSD
operator|>=
literal|200
end_if

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"machine/stdarg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|getchar
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|PCVT_NETBSD
end_if

begin_decl_stmt
specifier|extern
name|u_short
modifier|*
name|Crtat
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_NETBSD */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|__debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*0xffe */
end_comment

begin_expr_stmt
specifier|static
name|__color
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|nrow
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|vgapelinit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* read initial VGA DAC palette */
end_comment

begin_if
if|#
directive|if
name|defined
name|XSERVER
operator|&&
operator|!
name|PCVT_USL_VT_COMPAT
end_if

begin_function_decl
specifier|static
name|int
name|pcvt_xmode_set
parameter_list|(
name|int
name|on
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* initialize for X mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER&& !PCVT_USL_VT_COMPAT */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|pcopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|pcclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|pcread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|pcwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|pcioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|pcdevtotty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_mmap_t
name|pcmmap
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|12
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|pcdevsw
init|=
block|{
name|pcopen
block|,
name|pcclose
block|,
name|pcread
block|,
name|pcwrite
block|,
name|pcioctl
block|,
name|nullstop
block|,
name|noreset
block|,
name|pcdevtotty
block|,
name|ttpoll
block|,
name|pcmmap
block|,
name|nostrategy
block|,
literal|"vt"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|205
end_if

begin_function
name|struct
name|tty
modifier|*
name|pcdevtotty
parameter_list|(
name|Dev_t
name|dev
parameter_list|)
block|{
return|return
name|get_pccons
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_FREEBSD> 205 */
end_comment

begin_if
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|100
end_if

begin_comment
comment|/* NetBSD-current Feb 20 1995 */
end_comment

begin_decl_stmt
name|int
name|pcprobe
argument_list|(
expr|struct
name|device
operator|*
name|parent
argument_list|,
name|void
operator|*
name|match
argument_list|,
name|void
operator|*
name|aux
argument_list|)
else|#
directive|else
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|int
name|pcprobe
argument_list|(
expr|struct
name|device
operator|*
name|parent
argument_list|,
expr|struct
name|device
operator|*
name|self
argument_list|,
name|void
operator|*
name|aux
argument_list|)
else|#
directive|else
name|int
name|pcprobe
argument_list|(
expr|struct
name|isa_device
operator|*
name|dev
argument_list|)
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
endif|#
directive|endif
comment|/* PCVT_NETBSD> 100 */
block|{
ifdef|#
directive|ifdef
name|_I386_ISA_KBDIO_H_
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|IO_KBD
argument_list|)
expr_stmt|;
name|reset_keyboard
operator|=
literal|1
expr_stmt|;
comment|/* it's now safe to do kbd reset */
endif|#
directive|endif
comment|/* _I386_ISA_KBDIO_H_ */
name|kbd_code_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
operator|(
operator|(
expr|struct
name|isa_attach_args
operator|*
operator|)
name|aux
operator|)
operator|->
name|ia_iosize
operator|=
literal|16
expr_stmt|;
return|return
literal|1
return|;
else|#
directive|else
if|#
directive|if
name|PCVT_NETBSD
operator|||
name|PCVT_FREEBSD
return|return
operator|(
literal|16
operator|)
return|;
else|#
directive|else
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* PCVT_NETBSD || PCVT_FREEBSD */
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
block|}
end_decl_stmt

begin_if
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
end_if

begin_function
name|void
name|pcattach
parameter_list|(
name|struct
name|device
modifier|*
name|parent
parameter_list|,
name|struct
name|device
modifier|*
name|self
parameter_list|,
name|void
modifier|*
name|aux
parameter_list|)
block|{
name|struct
name|isa_attach_args
modifier|*
name|ia
init|=
name|aux
decl_stmt|;
specifier|static
name|struct
name|intrhand
name|vthand
decl_stmt|;
else|#
directive|else
name|int
name|pcattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|vt
decl_stmt|;
endif|#
directive|endif
comment|/*DEVFS*/
name|int
name|i
decl_stmt|;
name|vt_coldmalloc
argument_list|()
expr_stmt|;
comment|/* allocate memory for screens */
if|#
directive|if
name|PCVT_NETBSD
operator|||
name|PCVT_FREEBSD
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|printf
argument_list|(
literal|": "
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"vt%d: "
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
switch|switch
condition|(
name|adaptor_type
condition|)
block|{
case|case
name|MDA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"mda"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"cga"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"ega"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"%s, "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vga_string
argument_list|(
name|vga_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_do_132col
condition|)
name|printf
argument_list|(
literal|"80/132 col"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"80 col"
argument_list|)
expr_stmt|;
name|vgapelinit
argument_list|()
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|color
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|", mono"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", color"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d scr, "
argument_list|,
name|totalscreens
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|keyboard_type
condition|)
block|{
case|case
name|KB_AT
case|:
name|printf
argument_list|(
literal|"at-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KB_MFII
case|:
name|printf
argument_list|(
literal|"mf2-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"kbd, [R%s]\n"
argument_list|,
name|PCVT_REL
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_NETBSD
operator|||
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalscreens
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
name|PCVT_NETBSD
name|pc_tty
index|[
name|i
index|]
operator|=
name|ttymalloc
argument_list|()
expr_stmt|;
name|vs
index|[
name|i
index|]
operator|.
name|vs_tty
operator|=
name|pc_tty
index|[
name|i
index|]
expr_stmt|;
else|#
directive|else
comment|/* !PCVT_NETBSD */
name|pccons
index|[
name|i
index|]
operator|=
name|ttymalloc
argument_list|(
name|pccons
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vs
index|[
name|i
index|]
operator|.
name|vs_tty
operator|=
name|pccons
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
block|}
if|#
directive|if
name|PCVT_EMU_MOUSE
if|#
directive|if
name|PCVT_NETBSD
name|pc_tty
index|[
name|totalscreens
index|]
operator|=
name|ttymalloc
argument_list|()
expr_stmt|;
comment|/* the mouse emulator tty */
else|#
directive|else
comment|/* !PCVT_NETBSD */
comment|/* the mouse emulator tty */
name|pc_tty
index|[
name|totalscreens
index|]
operator|=
name|ttymalloc
argument_list|(
name|pccons
index|[
name|totalscreens
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
if|#
directive|if
name|PCVT_NETBSD
name|pcconsp
operator|=
name|pc_tty
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
comment|/* !PCVT_NETBSD */
name|pcconsp
operator|=
name|pccons
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
endif|#
directive|endif
comment|/* #if PCVT_NETBSD || (PCVT_FREEBSD> 110&& PCVT_FREEBSD< 200) */
else|#
directive|else
comment|/* !PCVT_NETBSD&& !PCVT_FREEBSD*/
switch|switch
condition|(
name|adaptor_type
condition|)
block|{
case|case
name|MDA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"<mda"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"<cga"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"<ega"
argument_list|)
expr_stmt|;
break|break;
case|case
name|VGA_ADAPTOR
case|:
name|printf
argument_list|(
literal|"<%s,"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|vga_string
argument_list|(
name|vga_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|can_do_132col
condition|)
name|printf
argument_list|(
literal|"80/132 col"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"80 col"
argument_list|)
expr_stmt|;
name|vgapelinit
argument_list|()
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"<unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|color
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|",mono"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|",color"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|",%d scr,"
argument_list|,
name|totalscreens
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|keyboard_type
condition|)
block|{
case|case
name|KB_AT
case|:
name|printf
argument_list|(
literal|"at-"
argument_list|)
expr_stmt|;
break|break;
case|case
name|KB_MFII
case|:
name|printf
argument_list|(
literal|"mf2-"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"kbd,[R%s]>"
argument_list|,
name|PCVT_REL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD || PCVT_FREEBSD */
if|#
directive|if
operator|!
name|PCVT_NETBSD
operator|&&
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalscreens
condition|;
name|i
operator|++
control|)
name|vs
index|[
name|i
index|]
operator|.
name|vs_tty
operator|=
operator|&
name|pccons
index|[
name|i
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_NETBSD&& !(PCVT_FREEBSD> 110&& PCVT_FREEBSD< 200) */
name|async_update
argument_list|(
name|UPDATE_START
argument_list|)
expr_stmt|;
comment|/* start asynchronous updates */
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|205
block|{
name|dev_t
name|dev
init|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|pcdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|vt
operator|=
literal|0
init|;
name|vt
operator|<
name|MAXCONS
condition|;
name|vt
operator|++
control|)
block|{
name|pcvt_devfs_token
index|[
name|vt
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|pcdevsw
argument_list|,
name|vt
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ttyv%n"
argument_list|,
name|vt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEVFS
endif|#
directive|endif
comment|/* PCVT_FREEBSD> 205 */
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|vthand
operator|.
name|ih_fun
operator|=
name|pcrint
expr_stmt|;
name|vthand
operator|.
name|ih_arg
operator|=
literal|0
expr_stmt|;
name|vthand
operator|.
name|ih_level
operator|=
name|IPL_TTY
expr_stmt|;
if|#
directive|if
operator|(
name|PCVT_NETBSD
operator|>
literal|100
operator|)
operator|&&
name|defined
argument_list|(
name|IST_EDGE
argument_list|)
name|intr_establish
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|,
name|IST_EDGE
argument_list|,
operator|&
name|vthand
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCVT_NETBSD> 100 */
name|intr_establish
argument_list|(
name|ia
operator|->
name|ia_irq
argument_list|,
operator|&
name|vthand
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 100 */
else|#
directive|else
comment|/* PCVT_NETBSD> 9 */
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
block|}
comment|/* had a look at the friedl driver */
if|#
directive|if
operator|!
name|PCVT_NETBSD
name|struct
name|tty
modifier|*
name|get_pccons
parameter_list|(
name|Dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|int
name|i
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
return|return
operator|(
operator|&
name|pccons
index|[
name|i
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|pccons
index|[
name|i
index|]
operator|)
return|;
endif|#
directive|endif
comment|/* !(PCVT_FREEBSD> 110&& PCVT_FREEBSD< 200) */
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
if|if
condition|(
name|i
operator|>=
name|PCVT_NSCREENS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
return|return
operator|(
operator|&
name|pccons
index|[
name|i
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|pccons
index|[
name|i
index|]
operator|)
return|;
endif|#
directive|endif
block|}
else|#
directive|else
name|struct
name|tty
modifier|*
name|get_pccons
parameter_list|(
name|Dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|int
name|i
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
return|return
operator|(
name|pc_tty
index|[
name|i
index|]
operator|)
return|;
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
if|if
condition|(
name|i
operator|>=
name|PCVT_NSCREENS
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pc_tty
index|[
name|i
index|]
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* !PCVT_NETBSD */
comment|/*---------------------------------------------------------------------------*  *		/dev/ttyc0, /dev/ttyc1, etc.  *---------------------------------------------------------------------------*/
name|int
name|pcopen
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|video_state
modifier|*
name|vsx
decl_stmt|;
name|int
name|s
decl_stmt|,
name|retval
decl_stmt|;
name|int
name|winsz
init|=
literal|0
decl_stmt|;
name|int
name|i
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
name|vsx
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
name|vsx
operator|=
operator|&
name|vs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|get_pccons
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
block|{
if|if
condition|(
name|mouse
operator|.
name|opened
operator|==
literal|0
condition|)
name|mouse
operator|.
name|buttons
operator|=
name|mouse
operator|.
name|extendedseen
operator|=
name|mouse
operator|.
name|breakseen
operator|=
name|mouse
operator|.
name|lastmove
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|mouse
operator|.
name|minor
operator|=
name|i
expr_stmt|;
name|mouse
operator|.
name|opened
operator|++
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
name|vsx
operator|->
name|openf
operator|++
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|pcstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|pcparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TS_WOPEN
comment|/* not (FreeBSD-1.1.5 or FreeBSD some time after 2.0.5) */
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
endif|#
directive|endif
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|pcparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
comment|/* fake connection */
name|winsz
operator|=
literal|1
expr_stmt|;
comment|/* set winsize later */
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|#
directive|if
name|PCVT_NETBSD
operator|||
operator|(
name|PCVT_FREEBSD
operator|>=
literal|200
operator|)
name|retval
operator|=
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
expr_stmt|;
else|#
directive|else
name|retval
operator|=
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|,
name|flag
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD || (PCVT_FREEBSD>= 200) */
if|if
condition|(
name|winsz
operator|==
literal|1
condition|)
block|{
comment|/* 		 * The line discipline has clobbered t_winsize if TS_ISOPEN 	         * was clear. (NetBSD PR #400 from Bill Sommerfeld) 	         * We have to do this after calling the open routine, because 	         * it does some other things in other/older *BSD releases -hm 		 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
operator|=
name|vsx
operator|->
name|maxcol
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
operator|=
name|vsx
operator|->
name|screen_rows
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
operator|=
operator|(
name|vsx
operator|->
name|maxcol
operator|==
literal|80
operator|)
condition|?
literal|720
else|:
literal|1056
expr_stmt|;
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
operator|=
literal|400
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|int
name|pcclose
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|video_state
modifier|*
name|vsx
decl_stmt|;
name|int
name|i
init|=
name|minor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
name|vsx
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
name|vsx
operator|=
operator|&
name|vs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|get_pccons
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
name|mouse
operator|.
name|opened
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
name|vsx
operator|->
name|openf
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|PCVT_USL_VT_COMPAT
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|i
operator|==
name|totalscreens
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
name|reset_usl_modes
argument_list|(
name|vsx
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_USL_VT_COMPAT */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|pcread
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|get_pccons
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
name|int
name|pcwrite
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|get_pccons
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
name|tp
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
name|int
name|pcioctl
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|register
name|error
expr_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|get_pccons
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* note that some ioctl's are global, e.g.  KBSTPMAT: There is 	 * only one keyboard and different repeat rates for instance between 	 * sessions are a suspicious wish. If you really need this make the 	 * appropriate variables arrays 	 */
if|#
directive|if
name|PCVT_EMU_MOUSE
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|==
name|totalscreens
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|mouse_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|error
return|;
goto|goto
name|do_standard
goto|;
block|}
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
ifdef|#
directive|ifdef
name|XSERVER
if|#
directive|if
name|PCVT_USL_VT_COMPAT
if|if
condition|(
operator|(
name|error
operator|=
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * just for compatibility: 	 * XFree86< 2.0 and SuperProbe still might use it 	 * 	 * NB: THIS IS A HACK! Do not use it unless you explicitly need. 	 * Especially, since the vty is not put into process-controlled 	 * mode (this would require the application to co-operate), any 	 * attempts to switch vtys while this kind of X mode is active 	 * may cause serious trouble. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONSOLE_X_MODE_ON
case|:
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDENABIO
argument_list|,
literal|0
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|error
return|;
name|i
operator|=
name|KD_GRAPHICS
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDSETMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
operator|>
literal|0
condition|)
return|return
name|error
return|;
name|i
operator|=
name|K_RAW
expr_stmt|;
name|error
operator|=
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
case|case
name|CONSOLE_X_MODE_OFF
case|:
block|{
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDDISABIO
argument_list|,
literal|0
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i
operator|=
name|KD_TEXT
expr_stmt|;
operator|(
name|void
operator|)
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDSETMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|i
operator|=
name|K_XLATE
expr_stmt|;
operator|(
name|void
operator|)
name|usl_vt_ioctl
argument_list|(
name|dev
argument_list|,
name|KDSKBMODE
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|i
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|CONSOLE_X_BELL
case|:
comment|/* 		 * If `data' is non-null, the first int value denotes 		 * the pitch, the second a duration. Otherwise, behaves 		 * like BEL. 		 */
if|if
condition|(
name|data
condition|)
block|{
if|#
directive|if
name|PCVT_NETBSD
name|sysbeep
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCVT_NETBSD */
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|*
name|hz
operator|/
literal|3000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
block|}
else|else
block|{
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
literal|1493
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* fall through */
empty_stmt|;
block|}
else|#
directive|else
comment|/* PCVT_USL_VT_COMPAT */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONSOLE_X_MODE_ON
case|:
return|return
name|pcvt_xmode_set
argument_list|(
literal|1
argument_list|,
name|p
argument_list|)
return|;
case|case
name|CONSOLE_X_MODE_OFF
case|:
return|return
name|pcvt_xmode_set
argument_list|(
literal|0
argument_list|,
name|p
argument_list|)
return|;
case|case
name|CONSOLE_X_BELL
case|:
comment|/* 		 * If `data' is non-null, the first int value denotes 		 * the pitch, the second a duration. Otherwise, behaves 		 * like BEL. 		 */
if|if
condition|(
name|data
condition|)
block|{
if|#
directive|if
name|PCVT_NETBSD
name|sysbeep
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|*
name|hz
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCVT_NETBSD */
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
index|[
literal|1
index|]
operator|*
name|hz
operator|/
literal|3000
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD */
block|}
else|else
block|{
name|sysbeep
argument_list|(
name|PCVT_SYSBEEPF
operator|/
literal|1493
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
default|default:
comment|/* fall through */
empty_stmt|;
block|}
endif|#
directive|endif
comment|/* PCVT_USL_VT_COMPAT */
endif|#
directive|endif
comment|/* XSERVER */
if|if
condition|(
operator|(
name|error
operator|=
name|kbdioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vgaioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|error
return|;
if|#
directive|if
name|PCVT_EMU_MOUSE
name|do_standard
label|:
endif|#
directive|endif
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
if|if
condition|(
operator|(
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
operator|)
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 || PCVT_FREEBSD>= 200 */
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
if|if
condition|(
operator|(
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
name|int
name|pcmmap
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
if|if
condition|(
name|offset
operator|>
literal|0x20000
operator|-
name|PAGE_SIZE
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|i386_btop
argument_list|(
operator|(
literal|0xa0000
operator|+
name|offset
operator|)
argument_list|)
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *  *	handle a keyboard receive interrupt  *  *	NOTE: the keyboard is multiplexed by means of "pcconsp"  *	between virtual screens. pcconsp - switching is done in  *	the vgapage() routine  *  *---------------------------------------------------------------------------*/
if|#
directive|if
name|PCVT_KBD_FIFO
name|u_char
name|pcvt_kbd_fifo
index|[
name|PCVT_KBD_FIFO_SZ
index|]
decl_stmt|;
specifier|static
name|int
name|pcvt_kbd_wptr
init|=
literal|0
decl_stmt|;
name|int
name|pcvt_kbd_rptr
init|=
literal|0
decl_stmt|;
name|short
name|pcvt_kbd_count
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|pcvt_timeout_scheduled
init|=
literal|0
decl_stmt|;
specifier|static
name|void
name|pcvt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
if|#
directive|if
name|PCVT_SLOW_INTERRUPT
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|pcvt_timeout_scheduled
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|PCVT_SCREENSAVER
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
while|while
condition|(
name|pcvt_kbd_count
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cp
operator|=
name|sgetc
argument_list|(
literal|1
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|vs
index|[
name|current_video_screen
index|]
operator|.
name|openf
operator|)
condition|)
block|{
if|#
directive|if
name|PCVT_NULLCHARS
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* pass a NULL character */
operator|(
operator|*
name|linesw
index|[
name|pcconsp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'\0'
operator|,
name|pcconsp
operator|)
expr_stmt|;
block|}
comment|/* XXX */
else|else
endif|#
directive|endif
comment|/* PCVT_NULLCHARS */
while|while
condition|(
operator|*
name|cp
condition|)
operator|(
operator|*
name|linesw
index|[
name|pcconsp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|,
name|pcconsp
operator|)
expr_stmt|;
block|}
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pcvt_kbd_count
condition|)
name|pcvt_timeout_scheduled
operator|=
literal|0
expr_stmt|;
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
endif|#
directive|endif
name|void
name|pcrint
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
if|#
directive|if
name|PCVT_KBD_FIFO
name|u_char
name|dt
decl_stmt|;
name|u_char
name|ret
init|=
operator|-
literal|1
decl_stmt|;
if|#
directive|if
name|PCVT_SLOW_INTERRUPT
name|int
name|s
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_I386_ISA_KBDIO_H_
name|int
name|c
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* !PCVT_KBD_FIFO */
name|u_char
modifier|*
name|cp
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_KBD_FIFO */
if|#
directive|if
name|PCVT_SCREENSAVER
name|pcvt_scrnsv_reset
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
if|#
directive|if
name|PCVT_KBD_FIFO
if|if
condition|(
name|kbd_polling
condition|)
block|{
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
while|while
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
condition|)
comment|/* check 8042 buffer */
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* got something */
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|dt
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
comment|/* get it 8042 data */
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|kbdc
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
comment|/* got something */
name|dt
operator|=
name|c
expr_stmt|;
endif|#
directive|endif
comment|/* _I386_ISA_KBDIO_H_ */
if|if
condition|(
name|pcvt_kbd_count
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
comment|/* fifo overflow ? */
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"pcvt: keyboard buffer overflow\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcvt_kbd_fifo
index|[
name|pcvt_kbd_wptr
operator|++
index|]
operator|=
name|dt
expr_stmt|;
comment|/* data -> fifo */
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
comment|/* XXX necessary ? */
name|pcvt_kbd_count
operator|++
expr_stmt|;
comment|/* update fifo count */
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcvt_kbd_wptr
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
name|pcvt_kbd_wptr
operator|=
literal|0
expr_stmt|;
comment|/* wraparound pointer */
block|}
block|}
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
comment|/* got data from keyboard ? */
block|{
if|if
condition|(
operator|!
name|pcvt_timeout_scheduled
condition|)
comment|/* if not already active .. */
block|{
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
name|pcvt_timeout_scheduled
operator|=
literal|1
expr_stmt|;
comment|/* flag active */
name|timeout
argument_list|(
name|pcvt_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|100
argument_list|)
expr_stmt|;
comment|/* fire off */
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !PCVT_KBD_FIFO */
if|if
condition|(
operator|(
name|cp
operator|=
name|sgetc
argument_list|(
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|kbd_polling
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|vs
index|[
name|current_video_screen
index|]
operator|.
name|openf
operator|)
condition|)
comment|/* XXX was vs[minor(dev)] */
return|return;
if|#
directive|if
name|PCVT_NULLCHARS
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* pass a NULL character */
operator|(
operator|*
name|linesw
index|[
name|pcconsp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
literal|'\0'
operator|,
name|pcconsp
operator|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* PCVT_NULLCHARS */
while|while
condition|(
operator|*
name|cp
condition|)
operator|(
operator|*
name|linesw
index|[
name|pcconsp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
operator|*
name|cp
operator|++
operator|&
literal|0xff
operator|,
name|pcconsp
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_KBD_FIFO */
block|}
if|#
directive|if
name|PCVT_NETBSD
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
name|void
name|pcstart
parameter_list|(
specifier|register
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
specifier|register
name|struct
name|clist
modifier|*
name|rbp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|PCVT_PCBURST
index|]
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|async_update
argument_list|(
name|UPDATE_KERN
argument_list|)
expr_stmt|;
name|rbp
operator|=
operator|&
name|tp
operator|->
name|t_outq
expr_stmt|;
comment|/* 	 * Call q_to_b() at spltty() to ensure that the queue is empty when 	 * the loop terminates. 	 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
while|while
condition|(
name|len
operator|=
name|q_to_b
argument_list|(
name|rbp
argument_list|,
name|buf
argument_list|,
name|PCVT_PCBURST
argument_list|)
condition|)
block|{
comment|/* 		 * We need to do this outside spl since it could be fairly 		 * expensive and we don't want our serial ports to overflow. 		 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sput
argument_list|(
operator|&
name|buf
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* FreeBSD some time after 2.0.5 */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|rbp
operator|->
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|rbp
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|void
name|pcstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{ }
else|#
directive|else
comment|/* PCVT_NETBSD || PCVT_FREEBSD>= 200 */
name|void
name|pcstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|114
operator|)
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|111
operator|)
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
else|#
directive|else
if|if
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|111
operator|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* PCVT_FREEBSD> 114 */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_SO_OCOMPLETE
operator||
name|TS_SO_OLOWAT
operator|)
operator|||
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !PCVT_FREEBSD> 114 */
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|111
operator|)
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
goto|goto
name|out
goto|;
block|}
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|111
operator|)
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
else|#
directive|else
name|c
operator|=
name|getc
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
comment|/* patch from Frank Maclachlan */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sput
argument_list|(
operator|&
name|c
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|minor
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
argument_list|)
expr_stmt|;
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
comment|/* patch from Frank Maclachlan */
block|}
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PCVT_NETBSD || PCVT_FREEBSD>= 200 */
comment|/*---------------------------------------------------------------------------*  *		/dev/console  *---------------------------------------------------------------------------*/
if|#
directive|if
operator|!
name|PCVT_NETBSD
comment|/* has moved to cons.c in netbsd-current */
name|void
name|consinit
parameter_list|()
comment|/* init for kernel messages during boot */
block|{ }
endif|#
directive|endif
comment|/* PCVT_NETBSD */
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|205
name|void
else|#
directive|else
name|int
endif|#
directive|endif
name|pccnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|isa_device
modifier|*
name|dvp
decl_stmt|;
ifdef|#
directive|ifdef
name|_I386_ISA_KBDIO_H_
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|IO_KBD
argument_list|)
expr_stmt|;
comment|/* 	 * Don't reset the keyboard via `kbdio' just yet. 	 * The system clock has not been calibrated... 	 */
name|reset_keyboard
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
comment|/* 	 * Turn off scancode translation early so that UserConfig  	 * and DDB can read the keyboard. 	 */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_TRANSLATION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
endif|#
directive|endif
comment|/* _I386_ISA_KBDIO_H_ */
comment|/* 	 * Take control if we are the highest priority enabled display device. 	 */
name|dvp
operator|=
name|find_display
argument_list|()
expr_stmt|;
if|if
condition|(
name|dvp
operator|==
name|NULL
operator|||
name|dvp
operator|->
name|id_driver
operator|!=
operator|&
name|vtdriver
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
if|#
directive|if
operator|!
name|PCVT_NETBSD
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>
literal|110
operator|&&
name|PCVT_FREEBSD
operator|<
literal|200
operator|)
name|cp
operator|->
name|cn_tp
operator|=
operator|&
name|pccons
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
name|cp
operator|->
name|cn_tp
operator|=
name|pccons
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* !(PCVT_FREEBSD> 110&& PCVT_FREEBSD< 200) */
endif|#
directive|endif
comment|/* !PCVT_NETBSD */
if|#
directive|if
name|PCVT_FREEBSD
operator|<=
literal|205
return|return
literal|1
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|205
name|void
else|#
directive|else
name|int
endif|#
directive|endif
name|pccninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|pcvt_is_console
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|PCVT_FREEBSD
operator|<=
literal|205
return|return
literal|0
return|;
endif|#
directive|endif
block|}
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|205
name|void
else|#
directive|else
name|int
endif|#
directive|endif
name|pccnputc
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|U_char
name|c
parameter_list|)
block|{
if|#
directive|if
name|PCVT_SW0CNOUTP
if|if
condition|(
name|current_video_screen
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
name|vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|switch_screen
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !PCVT_USL_VT_COMPAT */
block|}
endif|#
directive|endif
comment|/* PCVT_SW0CNOUTP */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|sput
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sput
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|c
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|async_update
argument_list|(
name|UPDATE_KERN
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_FREEBSD
operator|<=
literal|205
return|return
literal|0
return|;
endif|#
directive|endif
block|}
name|int
name|pccngetc
parameter_list|(
name|Dev_t
name|dev
parameter_list|)
block|{
specifier|register
name|int
name|s
decl_stmt|;
specifier|static
name|u_char
modifier|*
name|cp
decl_stmt|,
name|cbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Temp buf for multi-char key sequence. */
specifier|register
name|u_char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|XSERVER
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
if|if
condition|(
name|pcvt_xmode
condition|)
return|return
literal|0
return|;
else|#
directive|else
comment|/* !PCVT_USL_VT_COMPAT */
if|if
condition|(
name|pcvt_kbd_raw
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* !PCVT_USL_VT_COMPAT */
endif|#
directive|endif
comment|/* XSERVER */
if|if
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
comment|/* 		 * We still have a pending key sequence, e.g. 		 * from an arrow key.  Deliver this one first. 		 */
return|return
operator|(
operator|*
name|cp
operator|++
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block pcrint while we poll */
name|kbd_polling
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|kbd_polling
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|*
name|cp
condition|)
block|{
comment|/* Preserve the multi-char sequence for the next call. */
name|bcopy
argument_list|(
name|cp
argument_list|,
name|cbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* take care for a trailing '\0' */
name|cp
operator|=
name|cbuf
expr_stmt|;
block|}
else|else
name|cp
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|PCVT_FREEBSD
operator|>=
literal|201
operator|)
comment|/* this belongs to cons.c */
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
comment|/* ! (PCVT_FREEBSD>= 201) */
return|return
name|c
return|;
block|}
if|#
directive|if
name|PCVT_FREEBSD
operator|>=
literal|200
name|int
name|pccncheckc
parameter_list|(
name|Dev_t
name|dev
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|x
init|=
name|spltty
argument_list|()
decl_stmt|;
name|kbd_polling
operator|=
literal|1
expr_stmt|;
name|cp
operator|=
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|kbd_polling
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|==
name|NULL
condition|?
operator|-
literal|1
else|:
operator|*
name|cp
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* PCVT_FREEBSD>= 200 */
if|#
directive|if
name|PCVT_NETBSD
operator|>=
literal|100
name|void
name|pccnpollc
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|kbd_polling
operator|=
name|on
expr_stmt|;
if|if
condition|(
operator|!
name|on
condition|)
block|{
specifier|register
name|int
name|s
decl_stmt|;
comment|/* 		 * If disabling polling, make sure there are no bytes left in 		 * the FIFO, holding up the interrupt line.  Otherwise we 		 * won't get any further interrupts. 		 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pcrint
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* PCVT_NETBSD>= 100 */
comment|/*---------------------------------------------------------------------------*  *	Set line parameters  *---------------------------------------------------------------------------*/
name|int
name|pcparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* special characters */
define|#
directive|define
name|bs
value|8
define|#
directive|define
name|lf
value|10
define|#
directive|define
name|cr
value|13
define|#
directive|define
name|cntlc
value|3
define|#
directive|define
name|del
value|0177
define|#
directive|define
name|cntld
value|4
name|int
name|getchar
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|thechar
decl_stmt|;
name|int
name|x
decl_stmt|;
name|kbd_polling
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|sput
argument_list|(
literal|">"
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|async_update
argument_list|(
name|UPDATE_KERN
argument_list|)
expr_stmt|;
name|thechar
operator|=
operator|*
operator|(
name|sgetc
argument_list|(
literal|0
argument_list|)
operator|)
expr_stmt|;
name|kbd_polling
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|thechar
condition|)
block|{
default|default:
if|if
condition|(
name|thechar
operator|>=
literal|' '
condition|)
name|sput
argument_list|(
operator|&
name|thechar
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
case|case
name|cr
case|:
case|case
name|lf
case|:
name|sput
argument_list|(
literal|"\r\n"
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|lf
operator|)
return|;
case|case
name|bs
case|:
case|case
name|del
case|:
name|sput
argument_list|(
literal|"\b \b"
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
case|case
name|cntlc
case|:
name|sput
argument_list|(
literal|"^C\r\n"
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cpu_reset
argument_list|()
expr_stmt|;
case|case
name|cntld
case|:
name|sput
argument_list|(
literal|"^D\r\n"
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
define|#
directive|define
name|DPAUSE
value|1
name|void
name|dprintf
parameter_list|(
name|unsigned
name|flgs
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|flgs
operator|&
name|__debug
operator|)
operator|>
name|DPAUSE
condition|)
block|{
name|__color
operator|=
name|ffs
argument_list|(
name|flgs
operator|&
name|__debug
argument_list|)
operator|+
literal|1
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgs
operator|&
name|DPAUSE
operator|||
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
name|nrow
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|__color
operator|=
literal|0
expr_stmt|;
block|}
comment|/*----------------------------------------------------------------------*  *	read initial VGA palette (as stored by VGA ROM BIOS) into  *	palette save area  *----------------------------------------------------------------------*/
name|void
name|vgapelinit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
name|idx
decl_stmt|;
specifier|register
name|struct
name|rgb
modifier|*
name|val
decl_stmt|;
comment|/* first, read all and store to first screen's save buffer */
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|val
operator|=
name|vs
index|[
literal|0
index|]
operator|.
name|palette
init|;
name|idx
operator|<
name|NVGAPEL
condition|;
name|idx
operator|++
operator|,
name|val
operator|++
control|)
name|vgapaletteio
argument_list|(
name|idx
argument_list|,
name|val
argument_list|,
literal|0
comment|/* read it */
argument_list|)
expr_stmt|;
comment|/* now, duplicate for remaining screens */
for|for
control|(
name|idx
operator|=
literal|1
init|;
name|idx
operator|<
name|PCVT_NSCREENS
condition|;
name|idx
operator|++
control|)
name|bcopy
argument_list|(
name|vs
index|[
literal|0
index|]
operator|.
name|palette
argument_list|,
name|vs
index|[
name|idx
index|]
operator|.
name|palette
argument_list|,
name|NVGAPEL
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|rgb
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
name|XSERVER
operator|&&
operator|!
name|PCVT_USL_VT_COMPAT
comment|/*----------------------------------------------------------------------*  *	initialize for X mode  *	i.e.: grant current process (the X server) all IO privileges,  *	and mark in static variable so other hooks can test for it,  *	save all loaded fonts and screen pages to pageable buffers;  *	if parameter `on' is false, the same procedure is done reverse.  *----------------------------------------------------------------------*/
specifier|static
name|int
name|pcvt_xmode_set
parameter_list|(
name|int
name|on
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|saved_fonts
index|[
name|NVGAFONTS
index|]
decl_stmt|;
if|#
directive|if
name|PCVT_SCREENSAVER
specifier|static
name|unsigned
name|saved_scrnsv_tmo
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
if|#
directive|if
operator|(
name|PCVT_NETBSD
operator|>
literal|9
operator|)
operator|||
operator|(
name|PCVT_FREEBSD
operator|>
literal|102
operator|)
name|struct
name|trapframe
modifier|*
name|fp
decl_stmt|;
else|#
directive|else
name|struct
name|syscframe
modifier|*
name|fp
decl_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* X will only run on VGA and Hercules adaptors */
if|if
condition|(
name|adaptor_type
operator|!=
name|VGA_ADAPTOR
operator|&&
name|adaptor_type
operator|!=
name|MDA_ADAPTOR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|fp
operator|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_regs
expr_stmt|;
else|#
directive|else
name|fp
operator|=
operator|(
expr|struct
name|syscframe
operator|*
operator|)
name|p
operator|->
name|p_regs
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
if|if
condition|(
name|on
condition|)
block|{
comment|/* 		 * Test whether the calling process has super-user privileges 		 * and we're in insecure mode. 		 * This prevents us from granting the potential security hole 		 * `IO priv' to insufficiently privileged processes. 		 */
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|pcvt_xmode
condition|)
return|return
literal|0
return|;
name|pcvt_xmode
operator|=
name|pcvt_kbd_raw
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vgacs
index|[
name|i
index|]
operator|.
name|loaded
condition|)
block|{
name|saved_fonts
index|[
name|i
index|]
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|32
operator|*
literal|256
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_fonts
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcvt_xmode_set: no font buffer available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
else|else
block|{
name|vga_move_charset
argument_list|(
name|i
argument_list|,
name|saved_fonts
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|saved_fonts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
name|PCVT_SCREENSAVER
if|if
condition|(
name|saved_scrnsv_tmo
operator|=
name|scrnsv_timeout
condition|)
name|pcvt_set_scrnsv_tmo
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* turn it off */
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
name|async_update
argument_list|(
name|UPDATE_STOP
argument_list|)
expr_stmt|;
comment|/* turn off */
comment|/* disable text output and save screen contents */
comment|/* video board memory -> kernel memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Crtat
argument_list|,
name|vsp
operator|->
name|Memory
argument_list|,
name|vsp
operator|->
name|screen_rowsize
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|vsp
operator|->
name|Memory
expr_stmt|;
comment|/* operate in memory now */
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
comment|/* put keyboard to return ancient PC scan codes */
name|kbc_8042cmd
argument_list|(
name|CONTR_WRITE
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_USEKBDSEC
comment|/* security enabled */
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
operator|(
name|COMMAND_SYSFLG
operator||
name|COMMAND_IRQEN
operator||
name|COMMAND_PCSCAN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* security disabled */
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
operator|(
name|COMMAND_INHOVR
operator||
name|COMMAND_SYSFLG
operator||
name|COMMAND_IRQEN
operator||
name|COMMAND_PCSCAN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_USEKBDSEC */
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
comment|/* put keyboard to return ancient PC scan codes */
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_TRANSLATION
argument_list|,
name|KBD_TRANSLATION
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|fp
operator|->
name|tf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
else|#
directive|else
name|fp
operator|->
name|sf_eflags
operator||=
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
block|}
else|else
block|{
if|if
condition|(
operator|!
name|pcvt_xmode
condition|)
comment|/* verify if in X */
return|return
literal|0
return|;
name|pcvt_xmode
operator|=
name|pcvt_kbd_raw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totalfonts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|saved_fonts
index|[
name|i
index|]
condition|)
block|{
name|vga_move_charset
argument_list|(
name|i
argument_list|,
name|saved_fonts
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|saved_fonts
index|[
name|i
index|]
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|saved_fonts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|#
directive|if
name|PCVT_NETBSD
operator|>
literal|9
name|fp
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
else|#
directive|else
name|fp
operator|->
name|sf_eflags
operator|&=
operator|~
name|PSL_IOPL
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_NETBSD> 9 */
if|#
directive|if
name|PCVT_SCREENSAVER
if|if
condition|(
name|saved_scrnsv_tmo
condition|)
name|pcvt_set_scrnsv_tmo
argument_list|(
name|saved_scrnsv_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCREENSAVER */
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
name|kbc_8042cmd
argument_list|(
name|CONTR_WRITE
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_USEKBDSEC
comment|/* security enabled */
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
operator|(
name|COMMAND_SYSFLG
operator||
name|COMMAND_IRQEN
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* security disabled */
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
operator|(
name|COMMAND_INHOVR
operator||
name|COMMAND_SYSFLG
operator||
name|COMMAND_IRQEN
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_USEKBDSEC */
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_TRANSLATION
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
if|if
condition|(
name|adaptor_type
operator|==
name|MDA_ADAPTOR
condition|)
block|{
comment|/* 		     * Due to the fact that HGC registers are write-only, 		     * the Xserver can only make guesses about the state 		     * the HGC adaptor has been before turning on X mode. 		     * Thus, the display must be re-enabled now, and the 		     * cursor shape and location restored. 		     */
name|outb
argument_list|(
name|GN_DMCNTLM
argument_list|,
literal|0x28
argument_list|)
expr_stmt|;
comment|/* enable display, text mode */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORH
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|vsp
operator|->
name|Crtat
operator|+
name|vsp
operator|->
name|cur_offset
operator|)
operator|-
name|Crtat
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSORL
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
operator|(
name|vsp
operator|->
name|Crtat
operator|+
name|vsp
operator|->
name|cur_offset
operator|)
operator|-
name|Crtat
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CURSTART
argument_list|)
expr_stmt|;
comment|/* select high register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_CUREND
argument_list|)
expr_stmt|;
comment|/* select low register */
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|vsp
operator|->
name|cursor_end
argument_list|)
expr_stmt|;
block|}
comment|/* restore screen and re-enable text output */
comment|/* kernel memory -> video board memory */
name|bcopy
argument_list|(
name|vsp
operator|->
name|Memory
argument_list|,
name|Crtat
argument_list|,
name|vsp
operator|->
name|screen_rowsize
operator|*
name|vsp
operator|->
name|maxcol
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|vsp
operator|->
name|Crtat
operator|=
name|Crtat
expr_stmt|;
comment|/* operate on-screen now */
comment|/* set crtc screen memory start address */
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|vsp
operator|->
name|Crtat
operator|-
name|Crtat
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
name|CRTC_STARTADRL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
operator|(
name|vsp
operator|->
name|Crtat
operator|-
name|Crtat
operator|)
argument_list|)
expr_stmt|;
name|async_update
argument_list|(
name|UPDATE_START
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XSERVER&& !PCVT_USL_VT_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVT> 0 */
end_comment

begin_comment
comment|/*-------------------------- E O F -------------------------------------*/
end_comment

end_unit

