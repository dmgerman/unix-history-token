begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1995 Hellmuth Michaelis and Joerg Wunsch.  *  * Copyright (c) 1992, 1993 Brian Dunford-Shore and Holger Veit.  *  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  *  * This code is derived from software contributed to 386BSD by  * Holger Veit.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Hellmuth Michaelis,  *	Brian Dunford-Shore and Joerg Wunsch.  * 4. The name authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * @(#)pcvt_kbd.c, 3.20, Last Edit-Date: [Sun Apr  2 18:59:04 1995]  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *  *	pcvt_kbd.c	VT220 Driver Keyboard Interface Code  *	----------------------------------------------------  *	-hm	------------ Release 3.00 --------------  *	-hm	integrating NetBSD-current patches  *	-jw	introduced kbd_emulate_pc() if scanset> 1  *	-hm	patch from joerg for timeout in kbd_emulate_pc()  *	-hm	starting to implement alt-shift/ctrl key mappings  *	-hm	Gateway 2000 Keyboard fix from Brian Moore  *	-hm	some #if adjusting for NetBSD 0.9  *	-hm	split off pcvt_kbd.h  *	-hm	applying Joerg's patches for FreeBSD 2.0  *	-hm	patch from Martin, PCVT_NO_LED_UPDATE  *	-hm	PCVT_VT220KEYB patches from Lon Willet  *	-hm	PR #399, patch from Bill Sommerfeld: Return with PCVT_META_ESC  *	-hm	allow keyboard-less kernel boot for serial consoles and such ..  *	-hm	patch from Lon Willett for led-update and showkey()  *	-hm	patch from Lon Willett to fix mapping of Control-R scancode  *	-hm	delay patch from Martin Husemann after port-i386 ml-discussion  *	-hm	added PCVT_NONRESP_KEYB_TRY definition to doreset()  *  *---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"vt.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_if
if|#
directive|if
name|NVT
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<i386/isa/pcvt/pcvt_hdr.h>
end_include

begin_comment
comment|/* global include */
end_comment

begin_define
define|#
directive|define
name|LEDSTATE_UPDATE_PENDING
value|(1<< 3)
end_define

begin_decl_stmt
specifier|static
name|void
name|fkey1
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey2
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey3
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey4
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fkey5
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey6
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey7
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey8
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fkey9
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey10
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey11
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|fkey12
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sfkey1
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey2
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey3
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey4
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sfkey5
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey6
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey7
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey8
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sfkey9
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey10
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey11
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|sfkey12
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cfkey1
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey2
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey3
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey4
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cfkey5
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey6
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey7
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey8
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cfkey9
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey10
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey11
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|cfkey12
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|doreset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ovlinit
parameter_list|(
name|int
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|settpmrate
parameter_list|(
name|int
name|rate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setlockkeys
parameter_list|(
name|int
name|snc
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
end_ifndef

begin_function_decl
specifier|static
name|int
name|kbc_8042cmd
parameter_list|(
name|int
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|set_keyboard_param
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_I386_ISA_KBDIO_H_ */
end_comment

begin_function_decl
specifier|static
name|int
name|getokeydef
parameter_list|(
name|unsigned
name|key
parameter_list|,
name|struct
name|kbd_ovlkey
modifier|*
name|thisdef
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getckeydef
parameter_list|(
name|unsigned
name|key
parameter_list|,
name|struct
name|kbd_ovlkey
modifier|*
name|thisdef
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmkeydef
parameter_list|(
name|int
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setkeydef
parameter_list|(
name|struct
name|kbd_ovlkey
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|xlatkey2ascii
parameter_list|(
name|U_short
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ledstate
init|=
name|LEDSTATE_UPDATE_PENDING
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyboard led's */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tpmrate
init|=
name|KBD_TPD500
operator||
name|KBD_TPM100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|altkpflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|altkpval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|PCVT_SHOWKEYS
end_if

begin_decl_stmt
name|u_char
name|rawkeybuf
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/pcvt/pcvt_kbd.h>
end_include

begin_comment
comment|/* tables etc */
end_comment

begin_if
if|#
directive|if
name|PCVT_SHOWKEYS
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	keyboard debugging: put kbd communication char into some buffer  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|showkey
parameter_list|(
name|char
name|delim
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|int
name|rki
decl_stmt|;
for|for
control|(
name|rki
operator|=
literal|3
init|;
name|rki
operator|<
literal|80
condition|;
name|rki
operator|++
control|)
comment|/* shift left buffer */
name|rawkeybuf
index|[
name|rki
operator|-
literal|3
index|]
operator|=
name|rawkeybuf
index|[
name|rki
index|]
expr_stmt|;
name|rawkeybuf
index|[
literal|77
index|]
operator|=
name|delim
expr_stmt|;
comment|/* delimiter */
name|rki
operator|=
operator|(
name|val
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
expr_stmt|;
comment|/* ms nibble */
if|if
condition|(
name|rki
operator|<=
literal|9
condition|)
name|rki
operator|=
name|rki
operator|+
literal|'0'
expr_stmt|;
else|else
name|rki
operator|=
name|rki
operator|-
literal|10
operator|+
literal|'A'
expr_stmt|;
name|rawkeybuf
index|[
literal|78
index|]
operator|=
name|rki
expr_stmt|;
name|rki
operator|=
name|val
operator|&
literal|0x0f
expr_stmt|;
comment|/* ls nibble */
if|if
condition|(
name|rki
operator|<=
literal|9
condition|)
name|rki
operator|=
name|rki
operator|+
literal|'0'
expr_stmt|;
else|else
name|rki
operator|=
name|rki
operator|-
literal|10
operator|+
literal|'A'
expr_stmt|;
name|rawkeybuf
index|[
literal|79
index|]
operator|=
name|rki
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_SHOWKEYS */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	function to switch to another virtual screen  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|do_vgapage
parameter_list|(
name|int
name|page
parameter_list|)
block|{
if|if
condition|(
name|critical_scroll
condition|)
comment|/* executing critical region ? */
name|switch_page
operator|=
name|page
expr_stmt|;
comment|/* yes, auto switch later */
else|else
name|vgapage
argument_list|(
name|page
argument_list|)
expr_stmt|;
comment|/* no, switch now */
block|}
end_function

begin_comment
comment|/*  * This code from Lon Willett enclosed in #if PCVT_UPDLED_LOSES_INTR is  * abled because it crashes FreeBSD 1.1.5.1 at boot time.  * The cause is obviously that the timeout queue is not yet initialized  * timeout is called from here the first time.  * Anyway it is a pointer in the right direction so it is included for  * reference here.  */
end_comment

begin_define
define|#
directive|define
name|PCVT_UPDLED_LOSES_INTR
value|0
end_define

begin_comment
comment|/* disabled for now */
end_comment

begin_if
if|#
directive|if
name|PCVT_UPDLED_LOSES_INTR
operator|||
name|defined
argument_list|(
name|_I386_ISA_KBDIO_H_
argument_list|)
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	check for lost keyboard interrupts  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*  * The two commands to change the LEDs generate two KEYB_R_ACK responses  * from the keyboard, which aren't explicitly checked for (maybe they  * should be?).  However, when a lot of other I/O is happening, one of  * the interrupts sometimes gets lost (I'm not sure of the details of  * how and why and what hardware this happens with).  *  * This may have had something to do with spltty() previously not being  * called before the kbd_cmd() calls in update_led().  *  * This is a real problem, because normally the keyboard is only polled  * by pcrint(), and no more interrupts will be generated until the ACK  * has been read.  So the keyboard is hung.  This code polls a little  * while after changing the LEDs to make sure that this hasn't happened.  *  * XXX Quite possibly we should poll the kbd on a regular basis anyway,  * in the interest of robustness.  It may be possible that interrupts  * get lost other times as well.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lost_intr_timeout_queued
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|lost_intr_ch
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|lost_intr_ch
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|check_for_lost_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|lost_intr_timeout_queued
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
condition|)
block|{
name|int
name|opri
init|=
name|spltty
argument_list|()
decl_stmt|;
name|pcrint
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|int
name|opri
decl_stmt|;
name|lost_intr_timeout_queued
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kbdc_data_ready
argument_list|(
name|kbdc
argument_list|)
condition|)
name|pcrint
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
name|lost_intr_ch
operator|=
name|timeout
argument_list|(
name|check_for_lost_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lost_intr_timeout_queued
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_UPDLED_LOSES_INTR || defined(_I386_ISA_KBDIO_H_) */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	update keyboard led's  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|update_led
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|PCVT_NO_LED_UPDATE
comment|/* Don't update LED's unless necessary. */
name|int
name|opri
decl_stmt|,
name|new_ledstate
decl_stmt|,
name|response1
decl_stmt|,
name|response2
decl_stmt|;
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|new_ledstate
operator|=
operator|(
name|vsp
operator|->
name|scroll_lock
operator|)
operator||
operator|(
name|vsp
operator|->
name|num_lock
operator|*
literal|2
operator|)
operator||
operator|(
name|vsp
operator|->
name|caps_lock
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
name|new_ledstate
operator|!=
name|ledstate
condition|)
block|{
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|ledstate
operator|=
name|LEDSTATE_UPDATE_PENDING
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KEYB_C_LEDS
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard LED command timeout\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * For some keyboards or keyboard controllers, it is an 		 * error to issue a command without waiting long enough 		 * for an ACK for the previous command.  The keyboard 		 * gets confused, and responds with KEYB_R_RESEND, but 		 * we ignore that.  Wait for the ACK here.  The busy 		 * waiting doesn't matter much, since we lose anyway by 		 * busy waiting to send the command. 		 * 		 * XXX actually wait for any response, since we can't 		 * handle normal scancodes here. 		 * 		 * XXX all this should be interrupt driven.  Issue only 		 * one command at a time wait for a ACK before proceeding. 		 * Retry after a timeout or on receipt of a KEYB_R_RESEND. 		 * KEYB_R_RESENDs seem to be guaranteed by working 		 * keyboard controllers with broken (or disconnected) 		 * keyboards.  There is another code for keyboard 		 * reconnects.  The keyboard hardware is very simple and 		 * well designed :-). 		 */
name|response1
operator|=
name|kbd_response
argument_list|()
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|new_ledstate
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Keyboard LED data timeout\n"
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
block|}
name|response2
operator|=
name|kbd_response
argument_list|()
expr_stmt|;
if|if
condition|(
name|response1
operator|==
name|KEYB_R_ACK
operator|&&
name|response2
operator|==
name|KEYB_R_ACK
condition|)
name|ledstate
operator|=
name|new_ledstate
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Keyboard LED command not ACKed (responses %#x %#x)\n"
argument_list|,
name|response1
argument_list|,
name|response2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
block|{
name|ledstate
operator|=
name|new_ledstate
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ledstate
operator|=
name|LEDSTATE_UPDATE_PENDING
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_keyboard_param
argument_list|(
name|KBDC_SET_LEDS
argument_list|,
name|new_ledstate
argument_list|)
operator|==
literal|0
condition|)
name|ledstate
operator|=
name|new_ledstate
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_UPDLED_LOSES_INTR
if|if
condition|(
name|lost_intr_timeout_queued
condition|)
name|untimeout
argument_list|(
name|check_for_lost_intr
argument_list|,
name|NULL
argument_list|,
name|lost_intr_ch
argument_list|)
expr_stmt|;
name|lost_intr_ch
operator|=
name|timeout
argument_list|(
name|check_for_lost_intr
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lost_intr_timeout_queued
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_UPDLED_LOSES_INTR */
block|}
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* !PCVT_NO_LED_UPDATE */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	set typematic rate  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|settpmrate
parameter_list|(
name|int
name|rate
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|tpmrate
operator|=
name|rate
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KEYB_C_TYPEM
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Keyboard TYPEMATIC command timeout\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kbd_cmd
argument_list|(
name|tpmrate
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Keyboard TYPEMATIC data timeout\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|tpmrate
operator|=
name|rate
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|set_keyboard_param
argument_list|(
name|KBDC_SET_TYPEMATIC
argument_list|,
name|tpmrate
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"pcvt: failed to set keyboard TYPEMATIC.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
end_ifndef

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Pass command to keyboard controller (8042)  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|kbc_8042cmd
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|100000
expr_stmt|;
comment|/*> 100 msec */
while|while
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_INPBF
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|CONTROLLER_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Pass command to keyboard itself  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|kbd_cmd
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|100000
expr_stmt|;
comment|/*> 100 msec */
while|while
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_INPBF
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_SHOWKEYS
name|showkey
argument_list|(
literal|'>'
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	Read response from keyboard  *	NB: make sure to call spltty() before kbd_cmd(), kbd_response().  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|kbd_response
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|ch
decl_stmt|;
name|unsigned
name|timeo
decl_stmt|;
name|timeo
operator|=
literal|500000
expr_stmt|;
comment|/*> 500 msec (KEYB_R_SELFOK requires 87) */
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
operator|)
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|ch
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_SHOWKEYS
name|showkey
argument_list|(
literal|'<'
argument_list|,
name|ch
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
return|return
name|ch
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|set_keyboard_param
parameter_list|(
name|int
name|command
parameter_list|,
name|int
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* prevent the timeout routine from polling the keyboard */
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* disable the keyboard and mouse interrupt */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|c = get_controller_command_byte(kbdc);     if ((c == -1)  	|| !set_controller_command_byte(kbdc,              kbdc_get_device_mask(kbdc),             KBD_DISABLE_KBD_PORT | KBD_DISABLE_KBD_INT                 | KBD_DISABLE_AUX_PORT | KBD_DISABLE_AUX_INT)) {
comment|/* CONTROLLER ERROR */
block|kbdc_lock(kbdc, FALSE); 	splx(s); 	return 1;     }
comment|/*       * Now that the keyboard controller is told not to generate       * the keyboard and mouse interrupts, call `splx()' to allow       * the other tty interrupts. The clock interrupt may also occur,       * but the timeout routine (`scrn_timer()') will be blocked       * by the lock flag set via `kbdc_lock()'      */
block|splx(s);
endif|#
directive|endif
if|if
condition|(
name|send_kbd_command_and_data
argument_list|(
name|kbdc
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
operator|!=
name|KBD_ACK
condition|)
name|send_kbd_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_ENABLE_KBD
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* restore the interrupts */
block|if (!set_controller_command_byte(kbdc,             kbdc_get_device_mask(kbdc), 	    c& (KBD_KBD_CONTROL_BITS | KBD_AUX_CONTROL_BITS))) {
comment|/* CONTROLLER ERROR */
block|}
else|#
directive|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_I386_ISA_KBDIO_H_ */
end_comment

begin_if
if|#
directive|if
name|PCVT_SCANSET
operator|>
literal|1
end_if

begin_comment
comment|/*---------------------------------------------------------------------------*  *	switch PC scan code emulation mode  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|kbd_emulate_pc
parameter_list|(
name|int
name|do_emulation
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|int
name|cmd
decl_stmt|,
name|timeo
init|=
literal|10000
decl_stmt|;
name|cmd
operator|=
name|COMMAND_SYSFLG
operator||
name|COMMAND_IRQEN
expr_stmt|;
comment|/* common base cmd */
if|#
directive|if
operator|!
name|PCVT_USEKBDSEC
name|cmd
operator||=
name|COMMAND_INHOVR
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|do_emulation
condition|)
name|cmd
operator||=
name|COMMAND_PCSCAN
expr_stmt|;
name|kbc_8042cmd
argument_list|(
name|CONTR_WRITE
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_INPBF
condition|)
if|if
condition|(
operator|--
name|timeo
operator|==
literal|0
condition|)
break|break;
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
else|#
directive|else
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_TRANSLATION
argument_list|,
operator|(
name|do_emulation
operator|)
condition|?
name|KBD_TRANSLATION
else|:
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_SCANSET> 1 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PCVT_NONRESP_KEYB_TRY
end_ifndef

begin_define
define|#
directive|define
name|PCVT_NONRESP_KEYB_TRY
value|25
end_define

begin_comment
comment|/* no of times to try to detect	*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a nonresponding keyboard	*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------*  *	try to force keyboard into a known state ..  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|doreset
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
name|int
name|again
init|=
literal|0
decl_stmt|;
name|int
name|once
init|=
literal|0
decl_stmt|;
name|int
name|response
decl_stmt|,
name|opri
decl_stmt|;
comment|/* Enable interrupts and keyboard, etc. */
if|if
condition|(
name|kbc_8042cmd
argument_list|(
name|CONTR_WRITE
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"pcvt: doreset() - timeout controller write command\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_USEKBDSEC
comment|/* security enabled */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
define|#
directive|define
name|KBDINITCMD
value|COMMAND_SYSFLG|COMMAND_IRQEN
else|#
directive|else
comment|/* PCVT_SCANSET != 2 */
define|#
directive|define
name|KBDINITCMD
value|COMMAND_PCSCAN|COMMAND_SYSFLG|COMMAND_IRQEN
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
else|#
directive|else
comment|/* ! PCVT_USEKBDSEC */
comment|/* security disabled */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
define|#
directive|define
name|KBDINITCMD
value|COMMAND_INHOVR|COMMAND_SYSFLG|COMMAND_IRQEN
else|#
directive|else
comment|/* PCVT_SCANSET != 2 */
define|#
directive|define
name|KBDINITCMD
value|COMMAND_PCSCAN|COMMAND_INHOVR|COMMAND_SYSFLG\ 	|COMMAND_IRQEN
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
endif|#
directive|endif
comment|/* PCVT_USEKBDSEC */
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KBDINITCMD
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"pcvt: doreset() - timeout writing keyboard init command\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Discard any stale keyboard activity.  The 0.1 boot code isn't 	 * very careful and sometimes leaves a KEYB_R_RESEND.  Versions 	 * between 1992 and Oct 1996 didn't have the delay and sometimes 	 * left a KEYB_R_RESEND. 	 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
condition|)
name|kbd_response
argument_list|()
expr_stmt|;
else|else
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
operator|)
condition|)
break|break;
block|}
block|}
comment|/* Start keyboard reset */
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KEYB_C_RESET
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcvt: doreset() - timeout for keyboard reset command\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
name|KEYB_C_RESET
argument_list|)
expr_stmt|;
comment|/* force */
block|}
comment|/* Wait for the first response to reset and handle retries */
while|while
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|!=
name|KEYB_R_ACK
condition|)
block|{
if|if
condition|(
name|response
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
comment|/* print message only once ! */
name|printf
argument_list|(
literal|"pcvt: doreset() - response != ack and response< 0 [one time only msg]\n"
argument_list|)
expr_stmt|;
name|response
operator|=
name|KEYB_R_RESEND
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|response
operator|==
name|KEYB_R_RESEND
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
comment|/* print message only once ! */
name|printf
argument_list|(
literal|"pcvt: doreset() - got KEYB_R_RESEND response ... [one time only msg]\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|response
operator|==
name|KEYB_R_RESEND
condition|)
block|{
if|if
condition|(
operator|++
name|again
operator|>
name|PCVT_NONRESP_KEYB_TRY
condition|)
block|{
name|printf
argument_list|(
literal|"pcvt: doreset() - Caution - no PC keyboard detected!\n"
argument_list|)
expr_stmt|;
name|keyboard_type
operator|=
name|KB_UNKNOWN
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|kbd_cmd
argument_list|(
name|KEYB_C_RESET
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|once
operator|==
literal|0
operator|)
condition|)
block|{
name|once
operator|++
expr_stmt|;
comment|/* print message only once ! */
name|printf
argument_list|(
literal|"pcvt: doreset() - timeout for loop keyboard reset command [one time only msg]\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CONTROLLER_DATA
argument_list|,
name|KEYB_C_RESET
argument_list|)
expr_stmt|;
comment|/* force */
block|}
block|}
block|}
comment|/* Wait for the second response to reset */
while|while
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|!=
name|KEYB_R_SELFOK
condition|)
block|{
if|if
condition|(
name|response
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcvt: doreset() - response != OK and resonse< 0\n"
argument_list|)
expr_stmt|;
comment|/* 			 * If KEYB_R_SELFOK never arrives, the loop will 			 * finish here unless the keyboard babbles or 			 * STATUS_OUTPBF gets stuck. 			 */
break|break;
block|}
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
if|#
directive|if
name|PCVT_KEYBDID
name|opri
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|kbd_cmd
argument_list|(
name|KEYB_C_ID
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pcvt: doreset() - timeout for keyboard ID command\n"
argument_list|)
expr_stmt|;
name|keyboard_type
operator|=
name|KB_UNKNOWN
expr_stmt|;
block|}
else|else
block|{
name|r_entry
label|:
if|if
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|==
name|KEYB_R_MF2ID1
condition|)
block|{
if|if
condition|(
operator|(
name|response
operator|=
name|kbd_response
argument_list|()
operator|)
operator|==
name|KEYB_R_MF2ID2
condition|)
block|{
name|keyboard_type
operator|=
name|KB_MFII
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|response
operator|==
name|KEYB_R_MF2ID2HP
condition|)
block|{
name|keyboard_type
operator|=
name|KB_MFII
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\npcvt: doreset() - kbdid, response 2 = [%d]\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
name|keyboard_type
operator|=
name|KB_UNKNOWN
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|response
operator|==
name|KEYB_R_ACK
condition|)
block|{
goto|goto
name|r_entry
goto|;
block|}
elseif|else
if|if
condition|(
name|response
operator|==
operator|-
literal|1
condition|)
block|{
name|keyboard_type
operator|=
name|KB_AT
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\npcvt: doreset() - kbdid, response 1 = [%d]\n"
argument_list|,
name|response
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PCVT_KEYBDID */
name|keyboard_type
operator|=
name|KB_MFII
expr_stmt|;
comment|/* force it .. */
endif|#
directive|endif
comment|/* PCVT_KEYBDID */
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
name|int
name|c
decl_stmt|;
name|int
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|!
name|reset_keyboard
condition|)
comment|/* no, we are not ready to reset */
return|return;
if|if
condition|(
name|lost_intr_timeout_queued
condition|)
block|{
name|untimeout
argument_list|(
name|check_for_lost_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|lost_intr_ch
argument_list|)
expr_stmt|;
name|lost_intr_timeout_queued
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|kbdc
operator|==
name|NULL
condition|)
name|kbdc
operator|=
name|kbdc_open
argument_list|(
name|IO_KBD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|TRUE
argument_list|)
condition|)
comment|/* strange, somebody got there first */
return|return;
comment|/* remove any noise */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* save the current controller command byte */
name|m
operator|=
name|kbdc_get_device_mask
argument_list|(
name|kbdc
argument_list|)
operator|&
operator|~
name|KBD_KBD_CONTROL_BITS
expr_stmt|;
name|c
operator|=
name|get_controller_command_byte
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* CONTROLLER ERROR */
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|kbdc
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pcvt: unable to get the command byte.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|PCVT_USEKBDSEC
comment|/* security enabled */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
define|#
directive|define
name|KBDINITCMD
value|0
else|#
directive|else
comment|/* PCVT_SCANSET != 2 */
define|#
directive|define
name|KBDINITCMD
value|KBD_TRANSLATION
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
else|#
directive|else
comment|/* ! PCVT_USEKBDSEC */
comment|/* security disabled */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
define|#
directive|define
name|KBDINITCMD
value|KBD_OVERRIDE_KBD_LOCK
else|#
directive|else
comment|/* PCVT_SCANSET != 2 */
define|#
directive|define
name|KBDINITCMD
value|KBD_TRANSLATION | KBD_OVERRIDE_KBD_LOCK
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
endif|#
directive|endif
comment|/* PCVT_USEKBDSEC */
comment|/* disable the keyboard interrupt and the aux port and interrupt */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
operator||
name|KBD_TRANSLATION
operator||
name|KBD_OVERRIDE_KBD_LOCK
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_DISABLE_KBD_INT
operator||
name|KBDINITCMD
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR: there is very little we can do... */
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|kbdc
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pcvt: unable to set the command byte.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* reset keyboard hardware */
name|ledstate
operator|=
name|LEDSTATE_UPDATE_PENDING
expr_stmt|;
if|if
condition|(
operator|!
name|reset_kbd
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
comment|/* KEYBOARD ERROR */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
comment|/*  		 * We could disable the keyboard port and interrupt now...  		 * but, the keyboard may still exist.      		 */
name|printf
argument_list|(
literal|"pcvt: failed to reset the keyboard.\n"
argument_list|)
expr_stmt|;
comment|/* try to restore the original command byte */
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
literal|0xff
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|kbdc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|PCVT_KEYBDID
name|keyboard_type
operator|=
name|KB_UNKNOWN
expr_stmt|;
if|if
condition|(
name|send_kbd_command
argument_list|(
name|kbdc
argument_list|,
name|KBDC_SEND_DEV_ID
argument_list|)
operator|==
name|KBD_ACK
condition|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 10msec delay */
switch|switch
condition|(
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
case|case
name|KEYB_R_MF2ID1
case|:
switch|switch
condition|(
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
condition|)
block|{
case|case
name|KEYB_R_MF2ID2
case|:
case|case
name|KEYB_R_MF2ID2HP
case|:
name|keyboard_type
operator|=
name|KB_MFII
expr_stmt|;
break|break;
case|case
operator|-
literal|1
case|:
default|default:
break|break;
block|}
break|break;
case|case
operator|-
literal|1
case|:
name|keyboard_type
operator|=
name|KB_AT
expr_stmt|;
comment|/* fall through */
default|default:
comment|/* XXX: should we read the second byte? */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* XXX */
break|break;
block|}
block|}
else|else
block|{
comment|/*  		 * The send ID command failed. This error is considered 		 * benign, but may need recovery.  		 */
name|empty_both_buffers
argument_list|(
name|kbdc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|test_controller
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
name|test_kbd_port
argument_list|(
name|kbdc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PCVT_KEYBDID */
name|keyboard_type
operator|=
name|KB_MFII
expr_stmt|;
comment|/* force it .. */
endif|#
directive|endif
comment|/* PCVT_KEYBDID */
comment|/* enable the keyboard port and intr. */
if|if
condition|(
operator|!
name|set_controller_command_byte
argument_list|(
name|kbdc
argument_list|,
name|KBD_KBD_CONTROL_BITS
argument_list|,
name|KBD_ENABLE_KBD_PORT
operator||
name|KBD_ENABLE_KBD_INT
argument_list|)
condition|)
block|{
comment|/* CONTROLLER ERROR      		 * This is serious; we are left with the disabled  		 * keyboard intr.      		 */
name|printf
argument_list|(
literal|"pcvt: failed to enable the keyboard port and intr.\n"
argument_list|)
expr_stmt|;
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|kbdc
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|kbdc_set_device_mask
argument_list|(
name|kbdc
argument_list|,
name|m
operator||
name|KBD_KBD_CONTROL_BITS
argument_list|)
expr_stmt|;
name|kbdc_lock
argument_list|(
name|kbdc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
name|lost_intr_ch
operator|=
name|timeout
argument_list|(
name|check_for_lost_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lost_intr_timeout_queued
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	init keyboard code  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|kbd_code_init
parameter_list|(
name|void
parameter_list|)
block|{
name|doreset
argument_list|()
expr_stmt|;
name|ovlinit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|keyboard_is_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	init keyboard code, this initializes the keyboard subsystem  *	just "a bit" so the very very first ddb session is able to  *	get proper keystrokes - in other words, it's a hack ....  *---------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|kbd_code_init1
parameter_list|(
name|void
parameter_list|)
block|{
name|doreset
argument_list|()
expr_stmt|;
name|keyboard_is_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	init keyboard overlay table  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|ovlinit
parameter_list|(
name|int
name|force
parameter_list|)
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|force
operator|||
name|ovlinitflag
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ovlinitflag
operator|==
literal|0
operator|&&
operator|(
name|ovltbl
operator|=
operator|(
name|Ovl_tbl
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Ovl_tbl
argument_list|)
operator|*
name|OVLTBL_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pcvt_kbd: malloc of Ovl_tbl failed"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OVLTBL_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|ovltbl
index|[
name|i
index|]
operator|.
name|keynum
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|ovltbl
index|[
name|i
index|]
operator|.
name|unshift
index|[
literal|0
index|]
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|shift
index|[
literal|0
index|]
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|ctrl
index|[
literal|0
index|]
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|altgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ovltbl
index|[
name|i
index|]
operator|.
name|subu
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|subs
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|subc
operator|=
name|ovltbl
index|[
name|i
index|]
operator|.
name|suba
operator|=
name|KBD_SUBT_STR
expr_stmt|;
comment|/* just strings .. */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXKEYNUM
condition|;
name|i
operator|++
control|)
name|key2ascii
index|[
name|i
index|]
operator|.
name|type
operator|&=
name|KBD_MASK
expr_stmt|;
name|ovlinitflag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	get original key definition  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|getokeydef
parameter_list|(
name|unsigned
name|key
parameter_list|,
name|Ovl_tbl
modifier|*
name|thisdef
parameter_list|)
block|{
if|if
condition|(
name|key
operator|==
literal|0
operator|||
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
name|thisdef
operator|->
name|keynum
operator|=
name|key
expr_stmt|;
name|thisdef
operator|->
name|type
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|subtype
operator|==
name|STR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|what
operator|.
name|string
operator|)
argument_list|,
name|thisdef
operator|->
name|unshift
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subu
operator|=
name|KBD_SUBT_STR
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
literal|""
argument_list|,
name|thisdef
operator|->
name|unshift
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subu
operator|=
name|KBD_SUBT_FNC
expr_stmt|;
block|}
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|subtype
operator|==
name|STR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|what
operator|.
name|string
operator|)
argument_list|,
name|thisdef
operator|->
name|shift
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subs
operator|=
name|KBD_SUBT_STR
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
literal|""
argument_list|,
name|thisdef
operator|->
name|shift
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subs
operator|=
name|KBD_SUBT_FNC
expr_stmt|;
block|}
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|ctrl
operator|.
name|subtype
operator|==
name|STR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|ctrl
operator|.
name|what
operator|.
name|string
operator|)
argument_list|,
name|thisdef
operator|->
name|ctrl
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subc
operator|=
name|KBD_SUBT_STR
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
literal|""
argument_list|,
name|thisdef
operator|->
name|ctrl
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|subc
operator|=
name|KBD_SUBT_FNC
expr_stmt|;
block|}
comment|/* deliver at least anything for ALTGR settings ... */
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|subtype
operator|==
name|STR
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|what
operator|.
name|string
operator|)
argument_list|,
name|thisdef
operator|->
name|altgr
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|suba
operator|=
name|KBD_SUBT_STR
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
literal|""
argument_list|,
name|thisdef
operator|->
name|altgr
argument_list|,
name|CODE_SIZE
argument_list|)
expr_stmt|;
name|thisdef
operator|->
name|suba
operator|=
name|KBD_SUBT_FNC
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	get current key definition  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|getckeydef
parameter_list|(
name|unsigned
name|key
parameter_list|,
name|Ovl_tbl
modifier|*
name|thisdef
parameter_list|)
block|{
name|u_short
name|type
init|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|type
decl_stmt|;
if|if
condition|(
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|type
operator|&
name|KBD_OVERLOAD
condition|)
operator|*
name|thisdef
operator|=
name|ovltbl
index|[
name|key2ascii
index|[
name|key
index|]
operator|.
name|ovlindex
index|]
expr_stmt|;
else|else
name|getokeydef
argument_list|(
name|key
argument_list|,
name|thisdef
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	translate keynumber and returns ptr to associated ascii string  *	if key is bound to a function, executes it, and ret empty ptr  *---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|xlatkey2ascii
parameter_list|(
name|U_short
name|key
parameter_list|)
block|{
specifier|static
name|u_char
name|capchar
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
if|#
directive|if
name|PCVT_META_ESC
specifier|static
name|u_char
name|metachar
index|[
literal|3
index|]
init|=
block|{
literal|0x1b
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
else|#
directive|else
specifier|static
name|u_char
name|metachar
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
endif|#
directive|endif
specifier|static
name|Ovl_tbl
name|thisdef
decl_stmt|;
name|int
name|n
decl_stmt|;
name|void
function_decl|(
modifier|*
name|fnc
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
if|if
condition|(
name|key
operator|==
literal|0
condition|)
comment|/* ignore the NON-KEY */
return|return
literal|0
return|;
name|getckeydef
argument_list|(
name|key
operator|&
literal|0x7F
argument_list|,
operator|&
name|thisdef
argument_list|)
expr_stmt|;
comment|/* get the current ASCII value */
name|thisdef
operator|.
name|type
operator|&=
name|KBD_MASK
expr_stmt|;
if|if
condition|(
name|key
operator|&
literal|0x80
condition|)
comment|/* special handling of ALT-KEYPAD */
block|{
comment|/* is the ALT Key released? */
if|if
condition|(
name|thisdef
operator|.
name|type
operator|==
name|KBD_META
operator|||
name|thisdef
operator|.
name|type
operator|==
name|KBD_ALTGR
condition|)
block|{
if|if
condition|(
name|altkpflag
condition|)
comment|/* have we been in altkp mode? */
block|{
name|capchar
index|[
literal|0
index|]
operator|=
name|altkpval
expr_stmt|;
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|altkpval
operator|=
literal|0
expr_stmt|;
return|return
name|capchar
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|thisdef
operator|.
name|type
condition|)
comment|/* convert the keys */
block|{
case|case
name|KBD_BREAK
case|:
case|case
name|KBD_ASCII
case|:
case|case
name|KBD_FUNC
case|:
name|fnc
operator|=
name|NULL
expr_stmt|;
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|altgr_down
condition|)
block|{
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|altgr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ctrl_down
operator|&&
operator|(
name|shift_down
operator|||
name|vsp
operator|->
name|shift_lock
operator|)
condition|)
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|shift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ctrl_down
condition|)
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|ctrl
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|ctrl
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|ctrl
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|unshift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
if|if
condition|(
name|fnc
condition|)
call|(
modifier|*
name|fnc
call|)
argument_list|()
expr_stmt|;
comment|/* execute function */
if|if
condition|(
operator|(
name|more_chars
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|more_chars
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|caps_lock
operator|&&
name|more_chars
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|more_chars
index|[
literal|0
index|]
operator|<=
literal|'z'
condition|)
block|{
name|capchar
index|[
literal|0
index|]
operator|=
operator|*
name|more_chars
operator|-
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|more_chars
operator|=
name|capchar
expr_stmt|;
block|}
if|if
condition|(
name|meta_down
condition|)
block|{
if|#
directive|if
name|PCVT_META_ESC
name|metachar
index|[
literal|1
index|]
operator|=
operator|*
name|more_chars
expr_stmt|;
else|#
directive|else
name|metachar
index|[
literal|0
index|]
operator|=
operator|*
name|more_chars
operator||
literal|0x80
expr_stmt|;
endif|#
directive|endif
name|more_chars
operator|=
name|metachar
expr_stmt|;
block|}
block|}
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KBD_KP
case|:
name|fnc
operator|=
name|NULL
expr_stmt|;
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|meta_down
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|95
case|:
comment|/* / */
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033OQ"
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
literal|100
case|:
comment|/* * */
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033OR"
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
literal|105
case|:
comment|/* - */
name|altkpflag
operator|=
literal|0
expr_stmt|;
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033OS"
expr_stmt|;
return|return
operator|(
name|more_chars
operator|)
return|;
block|}
block|}
if|if
condition|(
name|meta_down
operator|||
name|altgr_down
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|keypad2num
index|[
name|key
operator|-
literal|91
index|]
operator|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|altkpflag
condition|)
block|{
comment|/* start ALT-KP mode */
name|altkpflag
operator|=
literal|1
expr_stmt|;
name|altkpval
operator|=
literal|0
expr_stmt|;
block|}
name|altkpval
operator|*=
literal|10
expr_stmt|;
name|altkpval
operator|+=
name|n
expr_stmt|;
block|}
else|else
name|altkpflag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|vsp
operator|->
name|num_lock
operator|)
condition|)
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|shift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|unshift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
if|if
condition|(
name|fnc
condition|)
call|(
modifier|*
name|fnc
call|)
argument_list|()
expr_stmt|;
comment|/* execute function */
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KBD_CURSOR
case|:
name|fnc
operator|=
name|NULL
expr_stmt|;
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vsp
operator|->
name|ckm
condition|)
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|shift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|shift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|subtype
operator|==
name|STR
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|unshift
expr_stmt|;
else|else
name|fnc
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|unshift
operator|.
name|what
operator|.
name|func
expr_stmt|;
block|}
if|if
condition|(
name|fnc
condition|)
call|(
modifier|*
name|fnc
call|)
argument_list|()
expr_stmt|;
comment|/* execute function */
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KBD_NUM
case|:
comment|/*  special kp-num handling */
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|meta_down
condition|)
block|{
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033OP"
expr_stmt|;
comment|/* PF1 */
block|}
else|else
block|{
name|vsp
operator|->
name|num_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KBD_RETURN
case|:
name|more_chars
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vsp
operator|->
name|num_lock
operator|)
condition|)
block|{
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|shift
expr_stmt|;
block|}
else|else
block|{
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
name|thisdef
operator|.
name|unshift
expr_stmt|;
block|}
if|if
condition|(
name|vsp
operator|->
name|lnm
operator|&&
operator|(
operator|*
name|more_chars
operator|==
literal|'\r'
operator|)
condition|)
block|{
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\r\n"
expr_stmt|;
comment|/* CR LF */
block|}
if|if
condition|(
name|meta_down
condition|)
block|{
if|#
directive|if
name|PCVT_META_ESC
name|metachar
index|[
literal|1
index|]
operator|=
operator|*
name|more_chars
expr_stmt|;
else|#
directive|else
name|metachar
index|[
literal|0
index|]
operator|=
operator|*
name|more_chars
operator||
literal|0x80
expr_stmt|;
endif|#
directive|endif
name|more_chars
operator|=
name|metachar
expr_stmt|;
block|}
return|return
operator|(
name|more_chars
operator|)
return|;
case|case
name|KBD_META
case|:
comment|/* these keys are	*/
case|case
name|KBD_ALTGR
case|:
comment|/*  handled directly	*/
case|case
name|KBD_SCROLL
case|:
comment|/*  by the keyboard	*/
case|case
name|KBD_CAPS
case|:
comment|/*  handler - they are	*/
case|case
name|KBD_SHFTLOCK
case|:
comment|/*  ignored here	*/
case|case
name|KBD_CTL
case|:
case|case
name|KBD_NONE
case|:
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*  *	get keystrokes from the keyboard.  *	if noblock = 0, wait until a key is pressed.  *	else return NULL if no characters present.  *---------------------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|PCVT_KBD_FIFO
end_if

begin_decl_stmt
specifier|extern
name|u_char
name|pcvt_kbd_fifo
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|pcvt_kbd_rptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|pcvt_kbd_count
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|u_char
modifier|*
name|sgetc
parameter_list|(
name|int
name|noblock
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
name|dt
decl_stmt|;
name|u_char
name|key
decl_stmt|;
name|u_short
name|type
decl_stmt|;
if|#
directive|if
name|PCVT_KBD_FIFO
operator|&&
name|PCVT_SLOW_INTERRUPT
name|int
name|s
decl_stmt|;
endif|#
directive|endif
specifier|static
name|u_char
name|kbd_lastkey
init|=
literal|0
decl_stmt|;
comment|/* last keystroke */
specifier|static
struct|struct
block|{
name|u_char
name|extended
range|:
literal|1
decl_stmt|;
comment|/* extended prefix seen */
name|u_char
name|ext1
range|:
literal|1
decl_stmt|;
comment|/* extended prefix 1 seen */
name|u_char
name|breakseen
range|:
literal|1
decl_stmt|;
comment|/* break code seen */
name|u_char
name|vshift
range|:
literal|1
decl_stmt|;
comment|/* virtual shift pending */
name|u_char
name|vcontrol
range|:
literal|1
decl_stmt|;
comment|/* virtual control pending */
name|u_char
name|sysrq
range|:
literal|1
decl_stmt|;
comment|/* sysrq pressed */
block|}
name|kbd_status
init|=
block|{
literal|0
block|}
struct|;
ifdef|#
directive|ifdef
name|XSERVER
specifier|static
name|char
name|keybuf
index|[
literal|2
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* the second 0 is a delimiter! */
endif|#
directive|endif
comment|/* XSERVER */
ifdef|#
directive|ifdef
name|_I386_ISA_KBDIO_H_
name|int
name|c
decl_stmt|;
endif|#
directive|endif
comment|/* _I386_ISA_KBDIO_H_ */
name|loop
label|:
ifdef|#
directive|ifdef
name|XSERVER
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
if|#
directive|if
name|PCVT_KBD_FIFO
comment|/* see if there is data from the keyboard available either from */
comment|/* the keyboard fifo or from the 8042 keyboard controller	*/
if|if
condition|(
name|pcvt_kbd_count
operator|||
operator|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|pcvt_kbd_count
condition|)
comment|/* source = 8042 */
block|{
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|dt
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
comment|/* get from obuf */
block|}
else|else
comment|/* source = keyboard fifo */
block|{
name|dt
operator|=
name|pcvt_kbd_fifo
index|[
name|pcvt_kbd_rptr
operator|++
index|]
expr_stmt|;
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
name|pcvt_kbd_count
operator|--
expr_stmt|;
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcvt_kbd_rptr
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
name|pcvt_kbd_rptr
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* !PCVT_KB_FIFO */
comment|/* see if there is data from the keyboard available from the 8042 */
if|if
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
condition|)
block|{
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|dt
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
comment|/* yes, get data */
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_KBD_FIFO
if|if
condition|(
name|pcvt_kbd_count
condition|)
block|{
name|dt
operator|=
name|pcvt_kbd_fifo
index|[
name|pcvt_kbd_rptr
operator|++
index|]
expr_stmt|;
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
name|pcvt_kbd_count
operator|--
expr_stmt|;
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcvt_kbd_rptr
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
name|pcvt_kbd_rptr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* PCVT_KBD_FIFO */
if|if
condition|(
operator|!
name|noblock
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
empty_stmt|;
name|dt
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|kbdc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|dt
operator|=
name|c
expr_stmt|;
block|}
block|{
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
comment|/* 		 * If x mode is active, only care for locking keys, then 		 * return the scan code instead of any key translation. 		 * Additionally, this prevents us from any attempts to 		 * execute pcvt internal functions caused by keys (such 		 * as screen flipping). 		 * XXX For now, only the default locking key definitions 		 * are recognized (i.e. if you have overloaded you "A" key 		 * as NUMLOCK, that wont effect X mode:-) 		 * Changing this would be nice, but would require modifi- 		 * cations to the X server. After having this, X will 		 * deal with the LEDs itself, so we are committed. 		 */
comment|/* 		 * Iff PCVT_USL_VT_COMPAT is defined, the behaviour has 		 * been fixed. We need not care about any keys here, since 		 * there are ioctls that deal with the lock key / LED stuff. 		 */
if|if
condition|(
name|pcvt_kbd_raw
condition|)
block|{
name|keybuf
index|[
literal|0
index|]
operator|=
name|dt
expr_stmt|;
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|210
name|add_keyboard_randomness
argument_list|(
name|dt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_FREEBSD> 210 */
if|#
directive|if
operator|!
name|PCVT_USL_VT_COMPAT
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
comment|/* key make */
switch|switch
condition|(
name|dt
condition|)
block|{
case|case
literal|0x45
case|:
comment|/* XXX on which virt screen? */
name|vsp
operator|->
name|num_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x3a
case|:
name|vsp
operator|->
name|caps_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
literal|0x46
case|:
name|vsp
operator|->
name|scroll_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* !PCVT_USL_VT_COMPAT */
if|#
directive|if
name|PCVT_EMU_MOUSE
comment|/* 			 * The (mouse systems) mouse emulator. The mouse 			 * device allocates the first device node that is 			 * not used by a virtual terminal. (E.g., you have 			 * eight vtys, /dev/ttyv0 thru /dev/ttyv7, so the 			 * mouse emulator were /dev/ttyv8.) 			 * Currently the emulator only works if the keyboard 			 * is in raw (PC scan code) mode. This is the typic- 			 * al case when running the X server. 			 * It is activated if the num locks LED is active 			 * for the current vty, and if the mouse device 			 * has been opened by at least one process. It 			 * grabs the numerical keypad events (but only 			 * the "non-extended", so the separate arrow keys 			 * continue to work), and three keys for the "mouse 			 * buttons", preferrably F1 thru F3. Any of the 			 * eight directions (N, NE, E, SE, S, SW, W, NW) 			 * is supported, and frequent key presses (less 			 * than e.g. half a second between key presses) 			 * cause the emulator to accelerate the pointer 			 * movement by 6, while single presses result in 			 * single moves, so each point can be reached. 			 */
comment|/* 			 * NB: the following code is spagghetti. 			 * Only eat it with lotta tomato ketchup and 			 * Parmesan cheese:-) 			 */
comment|/* 			 * look whether we will have to steal the keys 			 * and cook them into mouse events 			 */
if|if
condition|(
name|vsp
operator|->
name|num_lock
operator|&&
name|mouse
operator|.
name|opened
condition|)
block|{
name|int
name|button
decl_stmt|,
name|accel
decl_stmt|,
name|i
decl_stmt|;
enum|enum
name|mouse_dir
block|{
name|MOUSE_NW
block|,
name|MOUSE_N
block|,
name|MOUSE_NE
block|,
name|MOUSE_W
block|,
name|MOUSE_0
block|,
name|MOUSE_E
block|,
name|MOUSE_SW
block|,
name|MOUSE_S
block|,
name|MOUSE_SE
block|}
name|move
enum|;
name|struct
name|timeval
name|now
decl_stmt|;
name|dev_t
name|dummy
init|=
name|makedev
argument_list|(
literal|0
argument_list|,
name|mouse
operator|.
name|minor
argument_list|)
decl_stmt|;
name|struct
name|tty
modifier|*
name|mousetty
init|=
name|get_pccons
argument_list|(
name|dummy
argument_list|)
decl_stmt|;
comment|/* 				 * strings to send for each mouse event, 				 * indexed by the movement direction and 				 * the "accelerator" value (TRUE for frequent 				 * key presses); note that the first byte 				 * of each string is actually overwritten 				 * by the current button value before sending 				 * the string 				 */
specifier|static
name|u_char
name|mousestrings
index|[
literal|2
index|]
index|[
name|MOUSE_SE
operator|+
literal|1
index|]
index|[
literal|5
index|]
init|=
block|{
block|{
comment|/* first, the non-accelerated strings*/
block|{
literal|0x87
block|,
operator|-
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NW */
block|{
literal|0x87
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* N */
block|{
literal|0x87
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NE */
block|{
literal|0x87
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* W */
block|{
literal|0x87
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|0x87
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* E */
block|{
literal|0x87
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SW */
block|{
literal|0x87
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* S */
block|{
literal|0x87
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|}
comment|/* SE */
block|}
block|,
block|{
comment|/* now, 6 steps at once */
block|{
literal|0x87
block|,
operator|-
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NW */
block|{
literal|0x87
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* N */
block|{
literal|0x87
block|,
literal|4
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* NE */
block|{
literal|0x87
block|,
operator|-
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* W */
block|{
literal|0x87
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0 */
block|{
literal|0x87
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* E */
block|{
literal|0x87
block|,
operator|-
literal|4
block|,
operator|-
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SW */
block|{
literal|0x87
block|,
literal|0
block|,
operator|-
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* S */
block|{
literal|0x87
block|,
literal|4
block|,
operator|-
literal|4
block|,
literal|0
block|,
literal|0
block|}
comment|/* SE */
block|}
block|}
decl_stmt|;
if|if
condition|(
name|dt
operator|==
literal|0xe0
condition|)
block|{
comment|/* ignore extended scan codes */
name|mouse
operator|.
name|extendedseen
operator|=
literal|1
expr_stmt|;
goto|goto
name|no_mouse_event
goto|;
block|}
if|if
condition|(
name|mouse
operator|.
name|extendedseen
condition|)
block|{
name|mouse
operator|.
name|extendedseen
operator|=
literal|0
expr_stmt|;
goto|goto
name|no_mouse_event
goto|;
block|}
name|mouse
operator|.
name|extendedseen
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Note that we cannot use a switch here 				 * since we want to have the keycodes in 				 * a variable 				 */
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
name|mousedef
operator|.
name|leftbutton
condition|)
block|{
name|button
operator|=
literal|4
expr_stmt|;
goto|goto
name|do_button
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
name|mousedef
operator|.
name|middlebutton
condition|)
block|{
name|button
operator|=
literal|2
expr_stmt|;
goto|goto
name|do_button
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dt
operator|&
literal|0x7f
operator|)
operator|==
name|mousedef
operator|.
name|rightbutton
condition|)
block|{
name|button
operator|=
literal|1
expr_stmt|;
name|do_button
label|:
comment|/* 					 * i would really like to give 					 * some acustical support 					 * (pling/plong); i am not sure 					 * whether it is safe to call 					 * sysbeep from within an intr 					 * service, since it calls 					 * timeout in turn which mani- 					 * pulates the spl mask - jw 					 */
define|#
directive|define
name|PLING
value|sysbeep(PCVT_SYSBEEPF / 1500, 2)
define|#
directive|define
name|PLONG
value|sysbeep(PCVT_SYSBEEPF / 1200, 2)
if|if
condition|(
name|mousedef
operator|.
name|stickybuttons
condition|)
block|{
if|if
condition|(
name|dt
operator|&
literal|0x80
condition|)
block|{
name|mouse
operator|.
name|breakseen
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|u_char
operator|*
operator|)
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|mouse
operator|.
name|buttons
operator|==
name|button
operator|&&
operator|!
name|mouse
operator|.
name|breakseen
condition|)
block|{
comment|/* ignore repeats */
return|return
operator|(
name|u_char
operator|*
operator|)
literal|0
return|;
block|}
else|else
name|mouse
operator|.
name|breakseen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mouse
operator|.
name|buttons
operator|==
name|button
condition|)
block|{
comment|/* release it */
name|mouse
operator|.
name|buttons
operator|=
literal|0
expr_stmt|;
name|PLONG
expr_stmt|;
block|}
else|else
block|{
comment|/* 							 * eventually, release 							 * any other button, 							 * and stick this one 							 */
name|mouse
operator|.
name|buttons
operator|=
name|button
expr_stmt|;
name|PLING
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dt
operator|&
literal|0x80
condition|)
block|{
name|mouse
operator|.
name|buttons
operator|&=
operator|~
name|button
expr_stmt|;
name|PLONG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mouse
operator|.
name|buttons
operator|&
name|button
operator|)
operator|==
literal|0
condition|)
block|{
name|mouse
operator|.
name|buttons
operator||=
name|button
expr_stmt|;
name|PLING
expr_stmt|;
block|}
comment|/*else: ignore same btn press*/
block|}
name|move
operator|=
name|MOUSE_0
expr_stmt|;
name|accel
operator|=
literal|0
expr_stmt|;
block|}
undef|#
directive|undef
name|PLING
undef|#
directive|undef
name|PLONG
else|else
switch|switch
condition|(
name|dt
operator|&
literal|0x7f
condition|)
block|{
comment|/* the arrow keys - KP 1 thru KP 9 */
case|case
literal|0x47
case|:
name|move
operator|=
name|MOUSE_NW
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x48
case|:
name|move
operator|=
name|MOUSE_N
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x49
case|:
name|move
operator|=
name|MOUSE_NE
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x4b
case|:
name|move
operator|=
name|MOUSE_W
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x4c
case|:
name|move
operator|=
name|MOUSE_0
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x4d
case|:
name|move
operator|=
name|MOUSE_E
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x4f
case|:
name|move
operator|=
name|MOUSE_SW
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x50
case|:
name|move
operator|=
name|MOUSE_S
expr_stmt|;
goto|goto
name|do_move
goto|;
case|case
literal|0x51
case|:
name|move
operator|=
name|MOUSE_SE
expr_stmt|;
name|do_move
label|:
if|if
condition|(
name|dt
operator|&
literal|0x80
condition|)
comment|/* 						 * arrow key break events are 						 * of no importance for us 						 */
return|return
operator|(
name|u_char
operator|*
operator|)
literal|0
return|;
comment|/* 					 * see whether the last move did 					 * happen "recently", i.e. before 					 * less than half a second 					 */
name|gettime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|mouse
operator|.
name|lastmove
argument_list|)
expr_stmt|;
name|mouse
operator|.
name|lastmove
operator|=
name|time
expr_stmt|;
name|accel
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|now
operator|.
name|tv_usec
operator|<
name|mousedef
operator|.
name|acceltime
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* not a mouse-emulating key */
goto|goto
name|no_mouse_event
goto|;
block|}
name|mousestrings
index|[
name|accel
index|]
index|[
name|move
index|]
index|[
literal|0
index|]
operator|=
literal|0x80
operator|+
operator|(
operator|~
name|mouse
operator|.
name|buttons
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* finally, send the string */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|linesw
index|[
name|mousetty
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|mousestrings
index|[
name|accel
index|]
index|[
name|move
index|]
index|[
name|i
index|]
operator|,
name|mousetty
operator|)
expr_stmt|;
return|return
operator|(
name|u_char
operator|*
operator|)
literal|0
return|;
comment|/* not a kbd event */
block|}
name|no_mouse_event
label|:
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
return|return
operator|(
operator|(
name|u_char
operator|*
operator|)
name|keybuf
operator|)
return|;
block|}
block|}
else|#
directive|else
comment|/* !XSERVER */
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
if|#
directive|if
name|PCVT_KBD_FIFO
comment|/* see if there is data from the keyboard available either from */
comment|/* the keyboard fifo or from the 8042 keyboard controller	*/
if|if
condition|(
name|pcvt_kbd_count
operator|||
operator|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|noblock
operator|||
name|kbd_polling
condition|)
comment|/* source = 8042 */
block|{
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|dt
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* source = keyboard fifo */
block|{
name|dt
operator|=
name|pcvt_kbd_fifo
index|[
name|pcvt_kbd_rptr
operator|++
index|]
expr_stmt|;
comment|/* yes, get it ! */
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
name|pcvt_kbd_count
operator|--
expr_stmt|;
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcvt_kbd_rptr
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
name|pcvt_kbd_rptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !PCVT_KBD_FIFO */
comment|/* see if there is data from the keyboard available from the 8042 */
if|if
condition|(
name|inb
argument_list|(
name|CONTROLLER_CTRL
argument_list|)
operator|&
name|STATUS_OUTPBF
condition|)
block|{
name|PCVT_KBD_DELAY
argument_list|()
expr_stmt|;
comment|/* 7 us delay */
name|dt
operator|=
name|inb
argument_list|(
name|CONTROLLER_DATA
argument_list|)
expr_stmt|;
comment|/* yes, get data ! */
block|}
endif|#
directive|endif
comment|/* !PCVT_KBD_FIFO */
else|#
directive|else
comment|/* _I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_KBD_FIFO
if|if
condition|(
name|pcvt_kbd_count
condition|)
block|{
name|dt
operator|=
name|pcvt_kbd_fifo
index|[
name|pcvt_kbd_rptr
operator|++
index|]
expr_stmt|;
name|PCVT_DISABLE_INTR
argument_list|()
expr_stmt|;
name|pcvt_kbd_count
operator|--
expr_stmt|;
name|PCVT_ENABLE_INTR
argument_list|()
expr_stmt|;
if|if
condition|(
name|pcvt_kbd_rptr
operator|>=
name|PCVT_KBD_FIFO_SZ
condition|)
name|pcvt_kbd_rptr
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* PCVT_KBD_FIFO */
if|if
condition|(
operator|!
name|noblock
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|read_kbd_data
argument_list|(
name|kbdc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
empty_stmt|;
name|dt
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|read_kbd_data_no_wait
argument_list|(
name|kbdc
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
name|dt
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
endif|#
directive|endif
comment|/* !XSERVER */
ifndef|#
directive|ifndef
name|_I386_ISA_KBDIO_H_
else|else
block|{
if|if
condition|(
name|noblock
condition|)
return|return
name|NULL
return|;
else|else
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
comment|/* !_I386_ISA_KBDIO_H_ */
if|#
directive|if
name|PCVT_SHOWKEYS
name|showkey
argument_list|(
literal|' '
argument_list|,
name|dt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
comment|/* lets look what we got */
switch|switch
condition|(
name|dt
condition|)
block|{
case|case
name|KEYB_R_OVERRUN0
case|:
comment|/* keyboard buffer overflow */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
case|case
name|KEYB_R_SELFOK
case|:
comment|/* keyboard selftest ok */
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
case|case
name|KEYB_R_ECHO
case|:
comment|/* keyboard response to KEYB_C_ECHO */
case|case
name|KEYB_R_ACK
case|:
comment|/* acknowledge after command has rx'd*/
case|case
name|KEYB_R_SELFBAD
case|:
comment|/* keyboard selftest FAILED */
case|case
name|KEYB_R_DIAGBAD
case|:
comment|/* keyboard self diagnostic failure */
case|case
name|KEYB_R_RESEND
case|:
comment|/* keyboard wants us to resend cmnd */
case|case
name|KEYB_R_OVERRUN1
case|:
comment|/* keyboard buffer overflow */
break|break;
case|case
name|KEYB_R_EXT1
case|:
comment|/* keyboard extended scancode pfx 2 */
name|kbd_status
operator|.
name|ext1
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|KEYB_R_EXT0
case|:
comment|/* keyboard extended scancode pfx 1 */
name|kbd_status
operator|.
name|extended
operator|=
literal|1
expr_stmt|;
break|break;
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|2
case|case
name|KEYB_R_BREAKPFX
case|:
comment|/* break code prefix for set 2 and 3 */
name|kbd_status
operator|.
name|breakseen
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PCVT_SCANSET == 2 */
default|default:
goto|goto
name|regular
goto|;
comment|/* regular key */
block|}
if|if
condition|(
name|noblock
condition|)
return|return
name|NULL
return|;
else|else
goto|goto
name|loop
goto|;
comment|/* got a normal scan key */
name|regular
label|:
if|#
directive|if
name|PCVT_FREEBSD
operator|>
literal|210
name|add_keyboard_randomness
argument_list|(
name|dt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_FREEBSD> 210 */
if|#
directive|if
name|PCVT_SCANSET
operator|==
literal|1
name|kbd_status
operator|.
name|breakseen
operator|=
name|dt
operator|&
literal|0x80
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|dt
operator|&=
literal|0x7f
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SCANSET == 1 */
comment|/*   make a keycode from scan code	*/
if|if
condition|(
name|dt
operator|>=
sizeof|sizeof
name|scantokey
operator|/
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|key
operator|=
literal|0
expr_stmt|;
else|else
name|key
operator|=
name|kbd_status
operator|.
name|extended
condition|?
name|extscantokey
index|[
name|dt
index|]
else|:
name|scantokey
index|[
name|dt
index|]
expr_stmt|;
if|if
condition|(
name|kbd_status
operator|.
name|ext1
operator|&&
name|key
operator|==
literal|64
condition|)
comment|/* virtual control key */
name|key
operator|=
literal|129
expr_stmt|;
name|kbd_status
operator|.
name|extended
operator|=
name|kbd_status
operator|.
name|ext1
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|PCVT_CTRL_ALT_DEL
comment|/*   Check for cntl-alt-del	*/
if|if
condition|(
operator|(
name|key
operator|==
literal|76
operator|)
operator|&&
name|ctrl_down
operator|&&
operator|(
name|meta_down
operator|||
name|altgr_down
operator|)
condition|)
name|shutdown_nice
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_CTRL_ALT_DEL */
if|#
directive|if
operator|!
operator|(
name|PCVT_NETBSD
operator|||
name|PCVT_FREEBSD
operator|>=
literal|200
operator|)
include|#
directive|include
file|"ddb.h"
endif|#
directive|endif
comment|/* !(PCVT_NETBSD || PCVT_FREEBSD>= 200) */
if|#
directive|if
name|NDDB
operator|>
literal|0
operator|||
name|defined
argument_list|(
name|DDB
argument_list|)
comment|/*   Check for cntl-alt-esc	*/
if|if
condition|(
operator|(
name|key
operator|==
literal|110
operator|)
operator|&&
name|ctrl_down
operator|&&
operator|(
name|meta_down
operator|||
name|altgr_down
operator|)
condition|)
block|{
specifier|static
name|u_char
name|in_Debugger
decl_stmt|;
if|if
condition|(
operator|!
name|in_Debugger
condition|)
block|{
name|in_Debugger
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|PCVT_FREEBSD
comment|/* the string is actually not used... */
name|Debugger
argument_list|(
literal|"kbd"
argument_list|)
expr_stmt|;
else|#
directive|else
name|Debugger
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|in_Debugger
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|noblock
condition|)
return|return
name|NULL
return|;
else|else
goto|goto
name|loop
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* NDDB> 0 || defined(DDB) */
comment|/* look for keys with special handling */
if|if
condition|(
name|key
operator|==
literal|128
condition|)
block|{
comment|/* 		 * virtual shift; sent around PrtScr, and around the arrow 		 * keys if the NumLck LED is on 		 */
name|kbd_status
operator|.
name|vshift
operator|=
operator|!
name|kbd_status
operator|.
name|breakseen
expr_stmt|;
name|key
operator|=
literal|0
expr_stmt|;
comment|/* no key */
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|129
condition|)
block|{
comment|/* 		 * virtual control - the most ugly thingie at all 		 * the Pause key sends: 		 *<virtual control make><numlock make><virtual control 		 * break><numlock break> 		 */
if|if
condition|(
operator|!
name|kbd_status
operator|.
name|breakseen
condition|)
name|kbd_status
operator|.
name|vcontrol
operator|=
literal|1
expr_stmt|;
comment|/* else: let the numlock hook clear this */
name|key
operator|=
literal|0
expr_stmt|;
comment|/* no key */
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|90
condition|)
block|{
comment|/* NumLock, look whether this is rather a Pause */
if|if
condition|(
name|kbd_status
operator|.
name|vcontrol
condition|)
name|key
operator|=
literal|126
expr_stmt|;
comment|/* 		 * if this is the final break code of a Pause key, 		 * clear the virtual control status, too 		 */
if|if
condition|(
name|kbd_status
operator|.
name|vcontrol
operator|&&
name|kbd_status
operator|.
name|breakseen
condition|)
name|kbd_status
operator|.
name|vcontrol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|127
condition|)
block|{
comment|/* 		 * a SysRq; some keyboards are brain-dead enough to 		 * repeat the SysRq key make code by sending PrtScr 		 * make codes; other keyboards do not repeat SysRq 		 * at all. We keep track of the SysRq state here. 		 */
name|kbd_status
operator|.
name|sysrq
operator|=
operator|!
name|kbd_status
operator|.
name|breakseen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|124
condition|)
block|{
comment|/* 		 * PrtScr; look whether this is really PrtScr or rather 		 * a silly repeat of a SysRq key 		 */
if|if
condition|(
name|kbd_status
operator|.
name|sysrq
condition|)
comment|/* ignore the garbage */
name|key
operator|=
literal|0
expr_stmt|;
block|}
comment|/* in NOREPEAT MODE ignore the key if it was the same as before */
if|if
condition|(
operator|!
name|kbrepflag
operator|&&
name|key
operator|==
name|kbd_lastkey
operator|&&
operator|!
name|kbd_status
operator|.
name|breakseen
condition|)
block|{
if|if
condition|(
name|noblock
condition|)
return|return
name|NULL
return|;
else|else
goto|goto
name|loop
goto|;
block|}
name|type
operator|=
name|key2ascii
index|[
name|key
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|&
name|KBD_OVERLOAD
condition|)
name|type
operator|=
name|ovltbl
index|[
name|key2ascii
index|[
name|key
index|]
operator|.
name|ovlindex
index|]
operator|.
name|type
expr_stmt|;
name|type
operator|&=
name|KBD_MASK
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KBD_SHFTLOCK
case|:
if|if
condition|(
operator|!
name|kbd_status
operator|.
name|breakseen
operator|&&
name|key
operator|!=
name|kbd_lastkey
condition|)
block|{
name|vsp
operator|->
name|shift_lock
operator|^=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|KBD_CAPS
case|:
if|if
condition|(
operator|!
name|kbd_status
operator|.
name|breakseen
operator|&&
name|key
operator|!=
name|kbd_lastkey
condition|)
block|{
name|vsp
operator|->
name|caps_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|KBD_SCROLL
case|:
if|if
condition|(
operator|!
name|kbd_status
operator|.
name|breakseen
operator|&&
name|key
operator|!=
name|kbd_lastkey
condition|)
block|{
name|vsp
operator|->
name|scroll_lock
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vsp
operator|->
name|scroll_lock
operator|)
condition|)
block|{
comment|/* someone may be sleeping */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|vsp
operator|->
name|scroll_lock
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|KBD_SHIFT
case|:
name|shift_down
operator|=
name|kbd_status
operator|.
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|KBD_META
case|:
name|meta_down
operator|=
name|kbd_status
operator|.
name|breakseen
condition|?
literal|0
else|:
literal|0x80
expr_stmt|;
break|break;
case|case
name|KBD_ALTGR
case|:
name|altgr_down
operator|=
name|kbd_status
operator|.
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|KBD_CTL
case|:
name|ctrl_down
operator|=
name|kbd_status
operator|.
name|breakseen
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
case|case
name|KBD_NONE
case|:
default|default:
break|break;
comment|/* deliver a key */
block|}
if|if
condition|(
name|kbd_status
operator|.
name|breakseen
condition|)
block|{
name|key
operator||=
literal|0x80
expr_stmt|;
name|kbd_status
operator|.
name|breakseen
operator|=
literal|0
expr_stmt|;
name|kbd_lastkey
operator|=
literal|0
expr_stmt|;
comment|/* -hv- I know this is a bug with */
block|}
comment|/* N-Key-Rollover, but I ignore that */
else|else
comment|/* because avoidance is too complicated */
name|kbd_lastkey
operator|=
name|key
expr_stmt|;
name|cp
operator|=
name|xlatkey2ascii
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* have a key */
if|if
condition|(
name|cp
operator|==
name|NULL
operator|&&
operator|!
name|noblock
condition|)
goto|goto
name|loop
goto|;
return|return
name|cp
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	reflect status of locking keys& set led's  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|setlockkeys
parameter_list|(
name|int
name|snc
parameter_list|)
block|{
name|vsp
operator|->
name|scroll_lock
operator|=
name|snc
operator|&
literal|1
expr_stmt|;
name|vsp
operator|->
name|num_lock
operator|=
operator|(
name|snc
operator|&
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|vsp
operator|->
name|caps_lock
operator|=
operator|(
name|snc
operator|&
literal|4
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	remove a key definition  *---------------------------------------------------------------------------*/
specifier|static
name|int
name|rmkeydef
parameter_list|(
name|int
name|key
parameter_list|)
block|{
specifier|register
name|Ovl_tbl
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|key
operator|==
literal|0
operator|||
name|key
operator|>
name|MAXKEYNUM
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|key2ascii
index|[
name|key
index|]
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
block|{
name|ref
operator|=
operator|&
name|ovltbl
index|[
name|key2ascii
index|[
name|key
index|]
operator|.
name|ovlindex
index|]
expr_stmt|;
name|ref
operator|->
name|keynum
operator|=
literal|0
expr_stmt|;
name|ref
operator|->
name|type
operator|=
literal|0
expr_stmt|;
name|ref
operator|->
name|unshift
index|[
literal|0
index|]
operator|=
name|ref
operator|->
name|shift
index|[
literal|0
index|]
operator|=
name|ref
operator|->
name|ctrl
index|[
literal|0
index|]
operator|=
name|ref
operator|->
name|altgr
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|key2ascii
index|[
name|key
index|]
operator|.
name|type
operator|&=
name|KBD_MASK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	overlay a key  *---------------------------------------------------------------------------*/
specifier|static
name|int
name|setkeydef
parameter_list|(
name|Ovl_tbl
modifier|*
name|data
parameter_list|)
block|{
specifier|register
name|i
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|keynum
operator|>
name|MAXKEYNUM
operator|||
operator|(
name|data
operator|->
name|type
operator|&
name|KBD_MASK
operator|)
operator|==
name|KBD_BREAK
operator|||
operator|(
name|data
operator|->
name|type
operator|&
name|KBD_MASK
operator|)
operator|>
name|KBD_SHFTLOCK
condition|)
return|return
name|EINVAL
return|;
name|data
operator|->
name|unshift
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|shift
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|ctrl
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
name|data
operator|->
name|altgr
index|[
name|KBDMAXOVLKEYSIZE
index|]
operator|=
literal|0
expr_stmt|;
name|data
operator|->
name|subu
operator|=
name|data
operator|->
name|subs
operator|=
name|data
operator|->
name|subc
operator|=
name|data
operator|->
name|suba
operator|=
name|KBD_SUBT_STR
expr_stmt|;
comment|/* just strings .. */
name|data
operator|->
name|type
operator||=
name|KBD_OVERLOAD
expr_stmt|;
comment|/* mark overloaded */
comment|/* if key already overloaded, use that slot else find free slot */
if|if
condition|(
name|key2ascii
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|type
operator|&
name|KBD_OVERLOAD
condition|)
block|{
name|i
operator|=
name|key2ascii
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlindex
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OVLTBL_SIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ovltbl
index|[
name|i
index|]
operator|.
name|keynum
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|OVLTBL_SIZE
condition|)
return|return
name|ENOSPC
return|;
comment|/* no space, abuse of ENOSPC(!) */
block|}
name|ovltbl
index|[
name|i
index|]
operator|=
operator|*
name|data
expr_stmt|;
comment|/* copy new data string */
name|key2ascii
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|type
operator||=
name|KBD_OVERLOAD
expr_stmt|;
comment|/* mark key */
name|key2ascii
index|[
name|data
operator|->
name|keynum
index|]
operator|.
name|ovlindex
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	keyboard ioctl's entry  *---------------------------------------------------------------------------*/
name|int
name|kbdioctl
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|key
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KBDRESET
case|:
name|doreset
argument_list|()
expr_stmt|;
name|ovlinit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|settpmrate
argument_list|(
name|KBD_TPD500
operator||
name|KBD_TPM100
argument_list|)
expr_stmt|;
name|setlockkeys
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|KBDGTPMAT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tpmrate
expr_stmt|;
break|break;
case|case
name|KBDSTPMAT
case|:
name|settpmrate
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|KBDGREPSW
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|kbrepflag
expr_stmt|;
break|break;
case|case
name|KBDSREPSW
case|:
name|kbrepflag
operator|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
literal|1
expr_stmt|;
break|break;
case|case
name|KBDGLEDS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ledstate
expr_stmt|;
break|break;
case|case
name|KBDSLEDS
case|:
name|update_led
argument_list|()
expr_stmt|;
comment|/* ??? */
break|break;
case|case
name|KBDGLOCK
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
operator|(
name|vsp
operator|->
name|scroll_lock
operator|)
operator||
operator|(
name|vsp
operator|->
name|num_lock
operator|*
literal|2
operator|)
operator||
operator|(
name|vsp
operator|->
name|caps_lock
operator|*
literal|4
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|KBDSLOCK
case|:
name|setlockkeys
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|KBDGCKEY
case|:
name|key
operator|=
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
expr_stmt|;
return|return
name|getckeydef
argument_list|(
name|key
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDSCKEY
case|:
name|key
operator|=
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
expr_stmt|;
return|return
name|setkeydef
argument_list|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDGOKEY
case|:
name|key
operator|=
operator|(
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
operator|)
operator|->
name|keynum
expr_stmt|;
return|return
name|getokeydef
argument_list|(
name|key
argument_list|,
operator|(
name|Ovl_tbl
operator|*
operator|)
name|data
argument_list|)
return|;
case|case
name|KBDRMKEY
case|:
name|key
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
name|rmkeydef
argument_list|(
name|key
argument_list|)
return|;
case|case
name|KBDDEFAULT
case|:
name|ovlinit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* proceed with vga ioctls */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
if|#
directive|if
name|PCVT_EMU_MOUSE
comment|/*--------------------------------------------------------------------------*  *	mouse emulator ioctl  *--------------------------------------------------------------------------*/
name|int
name|mouse_ioctl
parameter_list|(
name|Dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|mousedefs
modifier|*
name|def
init|=
operator|(
expr|struct
name|mousedefs
operator|*
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|KBDMOUSEGET
case|:
operator|*
name|def
operator|=
name|mousedef
expr_stmt|;
break|break;
case|case
name|KBDMOUSESET
case|:
name|mousedef
operator|=
operator|*
name|def
expr_stmt|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* PCVT_EMU_MOUSE */
if|#
directive|if
name|PCVT_USL_VT_COMPAT
comment|/*---------------------------------------------------------------------------*  *	convert ISO-8859 style keycode into IBM 437  *---------------------------------------------------------------------------*/
specifier|static
specifier|inline
name|u_char
name|iso2ibm
parameter_list|(
name|u_char
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
return|return
name|c
return|;
return|return
name|iso2ibm437
index|[
name|c
operator|-
literal|0x80
index|]
return|;
block|}
comment|/*---------------------------------------------------------------------------*  *	build up a USL style keyboard map  *---------------------------------------------------------------------------*/
name|void
name|get_usl_keymap
parameter_list|(
name|keymap_t
modifier|*
name|map
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|map
argument_list|,
sizeof|sizeof
argument_list|(
name|keymap_t
argument_list|)
argument_list|)
expr_stmt|;
name|map
operator|->
name|n_keys
operator|=
literal|0x59
expr_stmt|;
comment|/* that many keys we know about */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|N_KEYNUMS
condition|;
name|i
operator|++
control|)
block|{
name|Ovl_tbl
name|kdef
decl_stmt|;
name|u_char
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|idx
init|=
name|key2scan1
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
operator|||
name|idx
operator|>=
name|map
operator|->
name|n_keys
condition|)
continue|continue;
name|getckeydef
argument_list|(
name|i
argument_list|,
operator|&
name|kdef
argument_list|)
expr_stmt|;
name|kdef
operator|.
name|type
operator|&=
name|KBD_MASK
expr_stmt|;
switch|switch
condition|(
name|kdef
operator|.
name|type
condition|)
block|{
case|case
name|KBD_ASCII
case|:
case|case
name|KBD_RETURN
case|:
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|0
index|]
operator|=
name|iso2ibm
argument_list|(
name|kdef
operator|.
name|unshift
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|1
index|]
operator|=
name|iso2ibm
argument_list|(
name|kdef
operator|.
name|shift
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|2
index|]
operator|=
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|3
index|]
operator|=
name|iso2ibm
argument_list|(
name|kdef
operator|.
name|ctrl
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|4
index|]
operator|=
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|5
index|]
operator|=
name|iso2ibm
argument_list|(
name|c
operator|=
name|kdef
operator|.
name|altgr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * XXX this is a hack 			 * since we currently do not map strings to AltGr + 			 * shift, we attempt to use the unshifted AltGr 			 * definition here and try to toggle the case 			 * this should at least work for ISO8859 letters, 			 * but also for (e.g.) russian KOI-8 style 			 */
if|if
condition|(
operator|(
name|c
operator|&
literal|0x7f
operator|)
operator|>=
literal|0x40
condition|)
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|5
index|]
operator|=
name|iso2ibm
argument_list|(
name|c
operator|^
literal|0x20
argument_list|)
expr_stmt|;
break|break;
case|case
name|KBD_FUNC
case|:
comment|/* we are only interested in F1 thru F12 here */
if|if
condition|(
name|i
operator|>=
literal|112
operator|&&
name|i
operator|<=
literal|123
condition|)
block|{
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
literal|0
index|]
operator|=
name|i
operator|-
literal|112
operator|+
literal|27
expr_stmt|;
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|spcl
operator|=
literal|0x80
expr_stmt|;
block|}
break|break;
case|case
name|KBD_SHIFT
case|:
name|c
operator|=
name|i
operator|==
literal|44
condition|?
literal|2
comment|/* lSh */
else|:
literal|3
comment|/* rSh */
expr_stmt|;
goto|goto
name|special
goto|;
case|case
name|KBD_CAPS
case|:
name|c
operator|=
literal|4
expr_stmt|;
goto|goto
name|special
goto|;
case|case
name|KBD_NUM
case|:
name|c
operator|=
literal|5
expr_stmt|;
goto|goto
name|special
goto|;
case|case
name|KBD_SCROLL
case|:
name|c
operator|=
literal|6
expr_stmt|;
goto|goto
name|special
goto|;
case|case
name|KBD_META
case|:
name|c
operator|=
literal|7
expr_stmt|;
goto|goto
name|special
goto|;
case|case
name|KBD_CTL
case|:
name|c
operator|=
literal|9
expr_stmt|;
goto|goto
name|special
goto|;
name|special
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_STATES
condition|;
name|j
operator|++
control|)
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|map
index|[
name|j
index|]
operator|=
name|c
expr_stmt|;
name|map
operator|->
name|key
index|[
name|idx
index|]
operator|.
name|spcl
operator|=
literal|0xff
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* PCVT_USL_VT_COMPAT */
comment|/*---------------------------------------------------------------------------*  *	switch keypad to numeric mode  *---------------------------------------------------------------------------*/
name|void
name|vt_keynum
parameter_list|(
name|struct
name|video_state
modifier|*
name|svsp
parameter_list|)
block|{
name|svsp
operator|->
name|num_lock
operator|=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	switch keypad to application mode  *---------------------------------------------------------------------------*/
name|void
name|vt_keyappl
parameter_list|(
name|struct
name|video_state
modifier|*
name|svsp
parameter_list|)
block|{
name|svsp
operator|->
name|num_lock
operator|=
literal|0
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|PCVT_VT220KEYB
comment|/* !PCVT_VT220KEYB, HP-like Keyboard layout */
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_columns
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[17~"
expr_stmt|;
comment|/* F6 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[26~"
expr_stmt|;
comment|/* F14 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|vt_ris
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[18~"
expr_stmt|;
comment|/* F7 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[28~"
expr_stmt|;
comment|/* HELP */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_24l
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[19~"
expr_stmt|;
comment|/* F8 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[29~"
expr_stmt|;
comment|/* DO */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|#
directive|if
name|PCVT_SHOWKEYS
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_kbddbg
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[20~"
expr_stmt|;
comment|/* F9 */
else|#
directive|else
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[20~"
expr_stmt|;
comment|/* F9 */
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[31~"
expr_stmt|;
comment|/* F17 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_bell
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[21~"
expr_stmt|;
comment|/* F10 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[32~"
expr_stmt|;
comment|/* F18 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_sevenbit
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[23~"
expr_stmt|;
comment|/* F11 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[33~"
expr_stmt|;
comment|/* F19 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_dspf
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[24~"
expr_stmt|;
comment|/* F12 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[34~"
expr_stmt|;
comment|/* F20 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
operator|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
operator|)
operator|&&
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
operator|)
condition|)
name|toggl_awm
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[25~"
expr_stmt|;
comment|/* F13 */
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
operator|||
operator|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
operator|)
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[35~"
expr_stmt|;
comment|/* F21 ??!! */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey9
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
condition|)
return|return;
if|if
condition|(
name|vsp
operator|->
name|labels_on
condition|)
comment|/* toggle label display on/off */
name|fkl_off
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|fkl_on
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|!=
name|M_PUREVT
operator|&&
name|vsp
operator|->
name|labels_on
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
condition|)
name|sw_sfkl
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|sw_ufkl
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey11
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
condition|)
name|set_emulation_mode
argument_list|(
name|vsp
argument_list|,
name|M_HPVT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
condition|)
name|set_emulation_mode
argument_list|(
name|vsp
argument_list|,
name|M_PUREVT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey12
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|current_video_screen
operator|+
literal|1
operator|>
name|totalscreens
operator|-
literal|1
condition|)
name|do_vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|do_vgapage
argument_list|(
name|current_video_screen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|0
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|0
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|9
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|9
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|1
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|1
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|11
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|11
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|2
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|2
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|12
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|12
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|3
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|3
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|13
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|13
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|4
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|4
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|14
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|14
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|6
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|6
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|15
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|15
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|7
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|7
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|16
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|16
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|8
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|8
index|]
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|17
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|17
index|]
index|]
operator|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey9
parameter_list|(
name|void
parameter_list|)
block|{ }
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey10
parameter_list|(
name|void
parameter_list|)
block|{ }
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey11
parameter_list|(
name|void
parameter_list|)
block|{ }
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey12
parameter_list|(
name|void
parameter_list|)
block|{ }
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey9
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|8
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey11
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey12
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|do_vgapage
argument_list|(
literal|11
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PCVT_VT220  -  VT220-like Keyboard layout */
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[23~"
expr_stmt|;
comment|/* F11 */
else|else
name|do_vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[24~"
expr_stmt|;
comment|/* F12 */
else|else
name|do_vgapage
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[25~"
expr_stmt|;
comment|/* F13 */
else|else
name|do_vgapage
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[26~"
expr_stmt|;
comment|/* F14 */
else|else
name|do_vgapage
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[28~"
expr_stmt|;
comment|/* Help */
else|else
block|{
if|if
condition|(
operator|(
name|current_video_screen
operator|+
literal|1
operator|)
operator|>
name|totalscreens
operator|-
literal|1
condition|)
name|do_vgapage
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|do_vgapage
argument_list|(
name|current_video_screen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[29~"
expr_stmt|;
comment|/* DO */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[17~"
expr_stmt|;
comment|/* F6 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[31~"
expr_stmt|;
comment|/* F17 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[18~"
expr_stmt|;
comment|/* F7 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[32~"
expr_stmt|;
comment|/* F18 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[19~"
expr_stmt|;
comment|/* F8 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey9
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[33~"
expr_stmt|;
comment|/* F19 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[20~"
expr_stmt|;
comment|/* F9 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[34~"
expr_stmt|;
comment|/* F20 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[21~"
expr_stmt|;
comment|/* F10 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey11
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\0x8FP"
expr_stmt|;
comment|/* PF1 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[23~"
expr_stmt|;
comment|/* F11 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|fkey12
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\0x8FQ"
expr_stmt|;
comment|/* PF2 */
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[24~"
expr_stmt|;
comment|/* F12 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|6
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|6
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[23~"
expr_stmt|;
comment|/* F11 */
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|7
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|7
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[24~"
expr_stmt|;
comment|/* F12 */
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|8
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|8
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[25~"
expr_stmt|;
comment|/* F13 */
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|9
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|9
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[26~"
expr_stmt|;
comment|/* F14 */
block|}
else|else
block|{
name|do_vgapage
argument_list|(
literal|7
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|11
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|11
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[28~"
expr_stmt|;
comment|/* Help */
block|}
else|else
block|{
if|if
condition|(
name|current_video_screen
operator|<=
literal|0
condition|)
name|do_vgapage
argument_list|(
name|totalscreens
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|do_vgapage
argument_list|(
name|current_video_screen
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|0
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|0
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[17~"
expr_stmt|;
comment|/* F6 */
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|12
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|12
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[29~"
expr_stmt|;
comment|/* DO */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|1
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|1
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[18~"
expr_stmt|;
comment|/* F7 */
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|14
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|14
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[31~"
expr_stmt|;
comment|/* F17 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|2
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|2
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[19~"
expr_stmt|;
comment|/* F8 */
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|14
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|15
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[32~"
expr_stmt|;
comment|/* F18 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey9
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|3
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|3
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[20~"
expr_stmt|;
comment|/* F9 */
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|16
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|16
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[33~"
expr_stmt|;
comment|/* F19 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|4
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|4
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[21~"
expr_stmt|;
comment|/* F10 */
block|}
elseif|else
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|17
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|17
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[34~"
expr_stmt|;
comment|/* F20 */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey11
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|6
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|6
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[23~"
expr_stmt|;
comment|/* F11 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to SHIFTED function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|sfkey12
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|meta_down
condition|)
block|{
if|if
condition|(
name|vsp
operator|->
name|ukt
operator|.
name|length
index|[
literal|7
index|]
condition|)
comment|/* entry available ? */
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
name|vsp
operator|->
name|udkbuf
index|[
name|vsp
operator|->
name|ukt
operator|.
name|first
index|[
literal|7
index|]
index|]
operator|)
expr_stmt|;
else|else
name|more_chars
operator|=
operator|(
name|u_char
operator|*
operator|)
literal|"\033[24~"
expr_stmt|;
comment|/* F12 */
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 1  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey1
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_columns
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 2  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|vt_ris
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 3  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey3
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_24l
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 4  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey4
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|PCVT_SHOWKEYS
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_kbddbg
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PCVT_SHOWKEYS */
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 5  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey5
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_bell
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 6  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_sevenbit
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 7  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey7
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_dspf
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 8  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey8
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|toggl_awm
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 9  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey9
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|labels_on
condition|)
comment|/* toggle label display on/off */
name|fkl_off
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
else|else
name|fkl_on
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 10  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey10
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|labels_on
condition|)
comment|/* toggle user/system fkey labels */
block|{
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|USR_FKL
condition|)
name|sw_sfkl
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vsp
operator|->
name|which_fkl
operator|==
name|SYS_FKL
condition|)
name|sw_ufkl
argument_list|(
name|vsp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 11  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey11
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_PUREVT
condition|)
name|set_emulation_mode
argument_list|(
name|vsp
argument_list|,
name|M_HPVT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|vsp
operator|->
name|vt_pure_mode
operator|==
name|M_HPVT
condition|)
name|set_emulation_mode
argument_list|(
name|vsp
argument_list|,
name|M_PUREVT
argument_list|)
expr_stmt|;
block|}
comment|/*---------------------------------------------------------------------------*  *	function bound to control function key 12  *---------------------------------------------------------------------------*/
specifier|static
name|void
name|cfkey12
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PCVT_VT220KEYB */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NVT> 0 */
end_comment

begin_comment
comment|/* ------------------------------- EOF -------------------------------------*/
end_comment

end_unit

