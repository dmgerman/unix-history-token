begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993 Dean Huxley<dean@fsa.ca>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Dean Huxley.  * 4. The name of Dean Huxley may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: if_eg.c,v 1.25 1997/09/02 01:18:09 bde Exp $  *  * Support for 3Com 3c505 Etherlink+ card.  */
end_comment

begin_comment
comment|/* To do:  * - multicast  * - promiscuous  */
end_comment

begin_include
include|#
directive|include
file|"eg.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_egreg.h>
end_include

begin_comment
comment|/* for debugging convenience */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EGDEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|EG_INLEN
value|10
end_define

begin_define
define|#
directive|define
name|EG_BUFLEN
value|0x0670
end_define

begin_comment
comment|/*  * Ethernet software status per interface.  */
end_comment

begin_struct
specifier|static
struct|struct
name|eg_softc
block|{
name|struct
name|arpcom
name|sc_arpcom
decl_stmt|;
comment|/* Ethernet common part */
name|int
name|eg_cmd
decl_stmt|;
comment|/* Command register R/W */
name|int
name|eg_ctl
decl_stmt|;
comment|/* Control register R/W (EG_CTL_*) */
name|int
name|eg_stat
decl_stmt|;
comment|/* Status register R/O (EG_STAT_*) */
name|int
name|eg_data
decl_stmt|;
comment|/* Data register R/W (16 bits) */
name|u_char
name|eg_rom_major
decl_stmt|;
comment|/* Cards ROM version (major number) */
name|u_char
name|eg_rom_minor
decl_stmt|;
comment|/* Cards ROM version (minor number) */
name|short
name|eg_ram
decl_stmt|;
comment|/* Amount of RAM on the card */
name|u_char
name|eg_pcb
index|[
literal|64
index|]
decl_stmt|;
comment|/* Primary Command Block buffer */
name|u_char
name|eg_incount
decl_stmt|;
comment|/* Number of buffers currently used */
name|u_char
modifier|*
name|eg_inbuf
decl_stmt|;
comment|/* Incoming packet buffer */
name|u_char
modifier|*
name|eg_outbuf
decl_stmt|;
comment|/* Outgoing packet buffer */
block|}
name|eg_softc
index|[
name|NEG
index|]
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|egprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|egattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|egdriver
init|=
block|{
name|egprobe
block|,
name|egattach
block|,
literal|"eg"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|egprintpcb
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|egprintstat
name|__P
argument_list|(
operator|(
name|int
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egoutPCB
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|,
name|int
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egreadPCBstat
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|,
name|int
name|statb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egreadPCBready
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egwritePCB
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|egreadPCB
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|eginit
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|egioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|egrecv
parameter_list|(
name|struct
name|eg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|egstart
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|egread
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|egstop
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|egwatchdog
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|egreset
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|egget
name|__P
argument_list|(
operator|(
expr|struct
name|eg_softc
operator|*
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Support stuff  */
end_comment

begin_function
specifier|static
name|void
name|egprintpcb
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|+
literal|2
condition|;
name|i
operator|++
control|)
name|dprintf
argument_list|(
operator|(
literal|"eg#: pcb[%2d] = %x\n"
operator|,
name|i
operator|,
name|sc
operator|->
name|eg_pcb
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|egprintstat
parameter_list|(
name|b
parameter_list|)
name|u_char
name|b
decl_stmt|;
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: %s %s %s %s %s %s %s\n"
operator|,
operator|(
name|b
operator|&
name|EG_STAT_HCRE
operator|)
condition|?
literal|"HCRE"
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_ACRF
operator|)
condition|?
literal|"ACRF"
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_DIR
operator|)
condition|?
literal|"DIR "
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_DONE
operator|)
condition|?
literal|"DONE"
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_ASF3
operator|)
condition|?
literal|"ASF3"
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_ASF2
operator|)
condition|?
literal|"ASF2"
else|:
literal|""
operator|,
operator|(
name|b
operator|&
name|EG_STAT_ASF1
operator|)
condition|?
literal|"ASF1"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|egoutPCB
parameter_list|(
name|sc
parameter_list|,
name|b
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
name|b
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_HCRE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|eg_cmd
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"eg#: egoutPCB failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egreadPCBstat
parameter_list|(
name|sc
parameter_list|,
name|statb
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
name|statb
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_PCB_STAT
operator|)
operator|!=
name|EG_PCB_NULL
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_PCB_STAT
operator|)
operator|==
name|statb
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egreadPCBready
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_ACRF
condition|)
return|return
literal|0
return|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"eg#: PCB read not ready\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egwritePCB
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|len
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator|&
operator|~
name|EG_PCB_STAT
operator|)
operator||
name|EG_PCB_NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|egoutPCB
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eg_pcb
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_HCRE
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator|&
operator|~
name|EG_PCB_STAT
operator|)
operator||
name|EG_PCB_DONE
argument_list|)
expr_stmt|;
name|egoutPCB
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|egreadPCBstat
argument_list|(
name|sc
argument_list|,
name|EG_PCB_ACCEPT
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egreadPCB
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|b
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator|&
operator|~
name|EG_PCB_STAT
operator|)
operator||
name|EG_PCB_NULL
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|eg_pcb
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|eg_pcb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|egreadPCBready
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|1
return|;
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|eg_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|egreadPCBready
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|1
return|;
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|eg_cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|>
literal|62
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: len %d too large\n"
operator|,
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|egreadPCBready
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|1
return|;
name|sc
operator|->
name|eg_pcb
index|[
literal|2
operator|+
name|i
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|eg_cmd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|egreadPCBready
argument_list|(
name|sc
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|egreadPCBstat
argument_list|(
name|sc
argument_list|,
name|EG_PCB_DONE
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|b
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|eg_cmd
argument_list|)
operator|)
operator|!=
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|+
literal|2
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: %d != %d\n"
operator|,
name|b
operator|,
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator|&
operator|~
name|EG_PCB_STAT
operator|)
operator||
name|EG_PCB_ACCEPT
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Real stuff  */
end_comment

begin_function
specifier|static
name|int
name|egprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|eg_softc
modifier|*
name|sc
init|=
operator|&
name|eg_softc
index|[
name|id
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|id_iobase
operator|&
operator|~
literal|0x07f0
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: Weird iobase %x\n"
operator|,
name|ia
operator|->
name|ia_iobase
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|eg_cmd
operator|=
name|id
operator|->
name|id_iobase
operator|+
name|EG_COMMAND
expr_stmt|;
name|sc
operator|->
name|eg_ctl
operator|=
name|id
operator|->
name|id_iobase
operator|+
name|EG_CONTROL
expr_stmt|;
name|sc
operator|->
name|eg_stat
operator|=
name|id
operator|->
name|id_iobase
operator|+
name|EG_STATUS
expr_stmt|;
name|sc
operator|->
name|eg_data
operator|=
name|id
operator|->
name|id_iobase
operator|+
name|EG_DATA
expr_stmt|;
comment|/* hard reset card */
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|EG_CTL_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1600
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_PCB_STAT
operator|)
operator|==
name|EG_PCB_NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_PCB_STAT
operator|)
operator|!=
name|EG_PCB_NULL
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: eg: Reset failed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_GETINFO
expr_stmt|;
comment|/* Get Adapter Info */
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|egreadPCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|!=
name|EG_RSP_GETINFO
operator|||
comment|/* Get Adapter Info Response */
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|!=
literal|0x0a
condition|)
block|{
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|eg_rom_major
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
expr_stmt|;
name|sc
operator|->
name|eg_rom_minor
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
expr_stmt|;
name|sc
operator|->
name|eg_ram
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
operator||
operator|(
name|sc
operator|->
name|eg_pcb
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|eg_softc
modifier|*
name|sc
init|=
operator|&
name|eg_softc
index|[
name|id
operator|->
name|id_unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|egstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_GETEADDR
expr_stmt|;
comment|/* Get Station address */
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: write error\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|egreadPCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: read error\n"
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check Get station address response */
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|!=
name|EG_RSP_GETEADDR
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|!=
literal|0x06
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: parse error\n"
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
argument_list|,
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eg%d: address %6D, type=3COM 3c505 (v%d.%02d, %dk)\n"
argument_list|,
name|id
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|,
name|sc
operator|->
name|eg_rom_major
argument_list|,
name|sc
operator|->
name|eg_rom_minor
argument_list|,
name|sc
operator|->
name|eg_ram
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_SETEADDR
expr_stmt|;
comment|/* Set station address */
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: write error2\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|egreadPCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: read error2\n"
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|!=
name|EG_RSP_SETEADDR
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|!=
literal|0x02
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: parse error2\n"
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Initialize ifnet structure. */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"eg"
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|egstart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|egioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
operator|(
name|if_init_f_t
operator|*
operator|)
name|eginit
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|egwatchdog
expr_stmt|;
comment|/* Now we can attach the interface. */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|eginit
parameter_list|(
name|struct
name|eg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
comment|/* soft reset the board */
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|EG_CTL_FLSH
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|EG_CTL_ATTN
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_CONFIG82586
expr_stmt|;
comment|/* Configure 82586 */
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|/* receive broadcast& multicast */
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EGDEBUG
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|dprintf
argument_list|(
operator|(
literal|"eg#: write error3\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|egreadPCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: read error\n"
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
operator|!=
literal|0
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"eg%d: configure card command failed\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eg_inbuf
operator|==
name|NULL
condition|)
name|sc
operator|->
name|eg_inbuf
operator|=
name|malloc
argument_list|(
name|EG_BUFLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_incount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|eg_outbuf
operator|==
name|NULL
condition|)
name|sc
operator|->
name|eg_outbuf
operator|=
name|malloc
argument_list|(
name|EG_BUFLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|EG_CTL_CMDE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_incount
operator|=
literal|0
expr_stmt|;
name|egrecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Interface is now `running', with no output active. */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* Attempt to start output, if any. */
name|egstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|egrecv
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
while|while
condition|(
name|sc
operator|->
name|eg_incount
operator|<
name|EG_INLEN
condition|)
block|{
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_RECVPACKET
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|0x08
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* address not used.. we send zero */
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
operator|=
name|EG_BUFLEN
operator|&
literal|0xff
expr_stmt|;
comment|/* our buffer size */
name|sc
operator|->
name|eg_pcb
index|[
literal|7
index|]
operator|=
operator|(
name|EG_BUFLEN
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
comment|/* timeout, 0 == none */
name|sc
operator|->
name|eg_pcb
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|eg_incount
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|egstart
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|eg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
comment|/* Don't transmit if interface is busy or not running */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_RUNNING
operator||
name|IFF_OACTIVE
operator|)
operator|)
operator|!=
name|IFF_RUNNING
condition|)
return|return;
name|loop
label|:
comment|/* Dequeue the next datagram. */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
return|return;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* We need to use m->m_pkthdr.len, so require the header */
if|if
condition|(
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"egstart: no header mbuf"
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_SENDPACKET
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|0x06
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* address not used, we send zero */
name|sc
operator|->
name|eg_pcb
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
operator|=
name|len
expr_stmt|;
comment|/* length of packet */
name|sc
operator|->
name|eg_pcb
index|[
literal|7
index|]
operator|=
name|len
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: egwritePCB in egstart failed\n"
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|buffer
operator|=
name|sc
operator|->
name|eg_outbuf
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
comment|/* set direction bit: host -> adapter */
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator|&
operator|~
name|EG_CTL_DIR
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|eg_outbuf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
literal|2
control|)
block|{
name|outw
argument_list|(
name|sc
operator|->
name|eg_data
argument_list|,
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_HRDY
operator|)
condition|)
empty_stmt|;
comment|/* XXX need timeout here */
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|egintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|eg_softc
modifier|*
name|sc
init|=
operator|&
name|eg_softc
index|[
name|unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|u_short
modifier|*
name|ptr
decl_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_ACRF
condition|)
block|{
name|egreadPCB
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
condition|)
block|{
case|case
name|EG_RSP_RECVPACKET
case|:
name|len
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
operator||
operator|(
name|sc
operator|->
name|eg_pcb
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
comment|/* Set direction bit : Adapter -> host */
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|)
operator||
name|EG_CTL_DIR
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|eg_inbuf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
literal|2
control|)
block|{
while|while
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|eg_stat
argument_list|)
operator|&
name|EG_STAT_HRDY
operator|)
condition|)
empty_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|inw
argument_list|(
name|sc
operator|->
name|eg_data
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|sc
operator|->
name|eg_pcb
index|[
literal|8
index|]
operator||
operator|(
name|sc
operator|->
name|eg_pcb
index|[
literal|9
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
name|egread
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|eg_inbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sc
operator|->
name|eg_incount
operator|--
expr_stmt|;
name|egrecv
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|EG_RSP_SENDPACKET
case|:
if|if
condition|(
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
operator|||
name|sc
operator|->
name|eg_pcb
index|[
literal|7
index|]
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"eg#: packet dropped\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
operator|.
name|if_collisions
operator|+=
name|sc
operator|->
name|eg_pcb
index|[
literal|8
index|]
operator|&
literal|0xf
expr_stmt|;
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|egstart
argument_list|(
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
break|break;
case|case
name|EG_RSP_GETSTATS
case|:
name|dprintf
argument_list|(
operator|(
literal|"eg#: Card Statistics\n"
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|2
index|]
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: Receive Packets %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|6
index|]
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: Transmit Packets %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: CRC errors %d\n"
operator|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|10
index|]
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: alignment errors %d\n"
operator|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|12
index|]
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: no resources errors %d\n"
operator|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|14
index|]
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: overrun errors %d\n"
operator|,
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|sc
operator|->
name|eg_pcb
index|[
literal|16
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|dprintf
argument_list|(
operator|(
literal|"eg#: egintr: Unknown response %x??\n"
operator|,
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|egprintpcb
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Pass a packet up to the higher levels.  */
end_comment

begin_function
specifier|static
name|void
name|egread
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
if|if
condition|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|||
name|len
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"eg#: invalid packet size %d; dropping\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Pull packet off interface. */
name|m
operator|=
name|egget
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* We assume the header fit entirely in one mbuf. */
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a BPF listener on this interface. 	 * If so, hand off the raw packet to BPF. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no BPF listeners.  And if we are in promiscuous 		 * mode, we have to check if this packet is really ours. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
comment|/* !mcast and !bcast */
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* We assume the header fit entirely in one mbuf. */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * convert buf into mbufs  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|egget
parameter_list|(
name|sc
parameter_list|,
name|buf
parameter_list|,
name|totlen
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
name|int
name|totlen
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|len
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
return|return
name|top
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|egioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|eg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, then 			 * stop it. 			 */
name|egstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|eginit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|eg_pcb
index|[
literal|0
index|]
operator|=
name|EG_CMD_GETSTATS
expr_stmt|;
name|sc
operator|->
name|eg_pcb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EGDEBUG
if|if
condition|(
name|egwritePCB
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|dprintf
argument_list|(
operator|(
literal|"eg#: write error\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * XXX deal with flags changes: 			 * IFF_MULTICAST, IFF_PROMISC, 			 * IFF_LINK0, IFF_LINK1, 			 */
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|egreset
parameter_list|(
name|sc
parameter_list|)
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"eg#: egreset()\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|egstop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|eginit
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|egwatchdog
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|eg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: device timeout\n"
argument_list|,
literal|"eg#"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|egreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|egstop
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|eg_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|outb
argument_list|(
name|sc
operator|->
name|eg_ctl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

