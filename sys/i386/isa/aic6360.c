begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 Charles Hannum.  * Copyright (c) 1994 Jarle Greipsland  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jarle Greipsland  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id: aic6360.c,v 1.35 1997/10/26 21:08:39 nate Exp $  *  * Acknowledgements: Many of the algorithms used in this driver are  * inspired by the work of Julian Elischer (julian@tfs.com) and  * Charles Hannum (mycroft@duality.gnu.ai.mit.edu).  Thanks a million!  *  * Converted from NetBSD to FreeBSD by Jim Babb  */
end_comment

begin_comment
comment|/* TODO list:  * 1) Get the DMA stuff working.  * 2) Get the iov/uio stuff working. Is this a good thing ???  * 3) Get the synch stuff working.  * 4) Rewrite it to use malloc for the acb structs instead of static alloc.?  */
end_comment

begin_comment
comment|/*  * PC-9801-100/AHA-1030P support by URATA S.  */
end_comment

begin_comment
comment|/*  * A few customizable items:  */
end_comment

begin_comment
comment|/* The SCSI ID of the host adapter/computer */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AIC_SCSI_HOSTID
end_ifndef

begin_define
define|#
directive|define
name|AIC_SCSI_HOSTID
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Use doubleword transfers to/from SCSI chip.  Note: This requires  * motherboard support.  Basicly, some motherboard chipsets are able to  * split a 32 bit I/O operation into two 16 bit I/O operations,  * transparently to the processor.  This speeds up some things, notably long  * data transfers.  */
end_comment

begin_define
define|#
directive|define
name|AIC_USE_DWORDS
value|0
end_define

begin_comment
comment|/* Allow disconnects?  Was mainly used in an early phase of the driver when  * the message system was very flaky.  Should go away soon.  */
end_comment

begin_define
define|#
directive|define
name|AIC_ALLOW_DISCONNECT
value|1
end_define

begin_comment
comment|/* Synchronous data transfers? (does not work yet!) XXX */
end_comment

begin_define
define|#
directive|define
name|AIC_USE_SYNCHRONOUS
value|0
end_define

begin_comment
comment|/* Enable/disable (1/0) */
end_comment

begin_define
define|#
directive|define
name|AIC_SYNC_PERIOD
value|200
end_define

begin_define
define|#
directive|define
name|AIC_SYNC_REQ_ACK_OFS
value|8
end_define

begin_comment
comment|/* Max attempts made to transmit a message */
end_comment

begin_define
define|#
directive|define
name|AIC_MSG_MAX_ATTEMPT
value|3
end_define

begin_comment
comment|/* Not used now XXX */
end_comment

begin_comment
comment|/* Use DMA (else we do programmed I/O using string instructions) (not yet!)*/
end_comment

begin_define
define|#
directive|define
name|AIC_USE_EISA_DMA
value|0
end_define

begin_define
define|#
directive|define
name|AIC_USE_ISA_DMA
value|0
end_define

begin_comment
comment|/* How to behave on the (E)ISA bus when/if DMAing (on<<4) + off in us */
end_comment

begin_define
define|#
directive|define
name|EISA_BRST_TIM
value|((15<<4) + 1)
end_define

begin_comment
comment|/* 15us on, 1us off */
end_comment

begin_comment
comment|/* Some spin loop parameters (essentially how long to wait some places)  * The problem(?) is that sometimes we expect either to be able to transmit a  * byte or to get a new one from the SCSI bus pretty soon.  In order to avoid  * returning from the interrupt just to get yanked back for the next byte we  * may spin in the interrupt routine waiting for this byte to come.  How long?  * This is really (SCSI) device and processor dependent.  Tuneable, I guess.  */
end_comment

begin_define
define|#
directive|define
name|AIC_MSGI_SPIN
value|1
end_define

begin_comment
comment|/* Will spinwait upto ?ms for a new msg byte */
end_comment

begin_define
define|#
directive|define
name|AIC_MSGO_SPIN
value|1
end_define

begin_comment
comment|/* Include debug functions?  At the end of this file there are a bunch of  * functions that will print out various information regarding queued SCSI  * commands, driver state and chip contents.  You can call them from the  * kernel debugger.  If you set AIC_DEBUG to 0 they are not included (the  * kernel uses less memory) but you lose the debugging facilities.  */
end_comment

begin_define
define|#
directive|define
name|AIC_DEBUG
value|0
end_define

begin_comment
comment|/* End of customizable parameters */
end_comment

begin_if
if|#
directive|if
name|AIC_USE_EISA_DMA
operator|||
name|AIC_USE_ISA_DMA
end_if

begin_error
error|#
directive|error
literal|"I said not yet! Start paying attention... grumble"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"aic.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|"ioconf.h"
end_include

begin_comment
comment|/* Definitions, most of them has turned out to be unneccesary, but here they  * are anyway.  */
end_comment

begin_comment
comment|/*  * Generic SCSI messages. For now we reject most of them.  */
end_comment

begin_comment
comment|/* Messages (1 byte) */
end_comment

begin_comment
comment|/* I/T M(andatory) or (O)ptional */
end_comment

begin_define
define|#
directive|define
name|MSG_CMDCOMPLETE
value|0x00
end_define

begin_comment
comment|/* M/M */
end_comment

begin_define
define|#
directive|define
name|MSG_EXTENDED
value|0x01
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_SAVEDATAPOINTER
value|0x02
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_RESTOREPOINTERS
value|0x03
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_DISCONNECT
value|0x04
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_INITIATOR_DET_ERR
value|0x05
end_define

begin_comment
comment|/* M/M */
end_comment

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_comment
comment|/* O/M */
end_comment

begin_define
define|#
directive|define
name|MSG_MESSAGE_REJECT
value|0x07
end_define

begin_comment
comment|/* M/M */
end_comment

begin_define
define|#
directive|define
name|MSG_NOOP
value|0x08
end_define

begin_comment
comment|/* M/M */
end_comment

begin_define
define|#
directive|define
name|MSG_PARITY_ERR
value|0x09
end_define

begin_comment
comment|/* M/M */
end_comment

begin_define
define|#
directive|define
name|MSG_LINK_CMD_COMPLETE
value|0x0a
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_LINK_CMD_COMPLETEF
value|0x0b
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_BUS_DEV_RESET
value|0x0c
end_define

begin_comment
comment|/* O/M */
end_comment

begin_define
define|#
directive|define
name|MSG_ABORT_TAG
value|0x0d
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_CLEAR_QUEUE
value|0x0e
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_INIT_RECOVERY
value|0x0f
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_REL_RECOVERY
value|0x10
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_TERM_IO_PROC
value|0x11
end_define

begin_comment
comment|/* O/O */
end_comment

begin_comment
comment|/* Messages (2 byte) */
end_comment

begin_define
define|#
directive|define
name|MSG_SIMPLE_Q_TAG
value|0x20
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_HEAD_OF_Q_TAG
value|0x21
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_ORDERED_Q_TAG
value|0x22
end_define

begin_comment
comment|/* O/O */
end_comment

begin_define
define|#
directive|define
name|MSG_IGN_WIDE_RESIDUE
value|0x23
end_define

begin_comment
comment|/* O/O */
end_comment

begin_comment
comment|/* Identify message */
end_comment

begin_define
define|#
directive|define
name|MSG_IDENTIFY
parameter_list|(
name|lun
parameter_list|)
value|((AIC_ALLOW_DISCONNECT ? 0xc0 : 0x80)|((lun)& 0x7))
end_define

begin_define
define|#
directive|define
name|MSG_ISIDENT
parameter_list|(
name|m
parameter_list|)
value|((m)& 0x80)
end_define

begin_comment
comment|/* Extended messages (opcode) */
end_comment

begin_define
define|#
directive|define
name|MSG_EXT_SDTR
value|0x01
end_define

begin_comment
comment|/* SCSI Status codes */
end_comment

begin_define
define|#
directive|define
name|ST_GOOD
value|0x00
end_define

begin_define
define|#
directive|define
name|ST_CHKCOND
value|0x02
end_define

begin_define
define|#
directive|define
name|ST_CONDMET
value|0x04
end_define

begin_define
define|#
directive|define
name|ST_BUSY
value|0x08
end_define

begin_define
define|#
directive|define
name|ST_INTERMED
value|0x10
end_define

begin_define
define|#
directive|define
name|ST_INTERMED_CONDMET
value|0x14
end_define

begin_define
define|#
directive|define
name|ST_RESERVATION_CONFLICT
value|0x18
end_define

begin_define
define|#
directive|define
name|ST_CMD_TERM
value|0x22
end_define

begin_define
define|#
directive|define
name|ST_QUEUE_FULL
value|0x28
end_define

begin_define
define|#
directive|define
name|ST_MASK
value|0x3e
end_define

begin_comment
comment|/* bit 0,6,7 is reserved */
end_comment

begin_comment
comment|/* AIC6360 definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<i386/isa/aic_98.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SCSISEQ
value|(iobase + 0x00)
end_define

begin_comment
comment|/* SCSI sequence control */
end_comment

begin_define
define|#
directive|define
name|SXFRCTL0
value|(iobase + 0x01)
end_define

begin_comment
comment|/* SCSI transfer control 0 */
end_comment

begin_define
define|#
directive|define
name|SXFRCTL1
value|(iobase + 0x02)
end_define

begin_comment
comment|/* SCSI transfer control 1 */
end_comment

begin_define
define|#
directive|define
name|SCSISIGI
value|(iobase + 0x03)
end_define

begin_comment
comment|/* SCSI signal in */
end_comment

begin_define
define|#
directive|define
name|SCSISIGO
value|(iobase + 0x03)
end_define

begin_comment
comment|/* SCSI signal out */
end_comment

begin_define
define|#
directive|define
name|SCSIRATE
value|(iobase + 0x04)
end_define

begin_comment
comment|/* SCSI rate control */
end_comment

begin_define
define|#
directive|define
name|SCSIID
value|(iobase + 0x05)
end_define

begin_comment
comment|/* SCSI ID */
end_comment

begin_define
define|#
directive|define
name|SELID
value|(iobase + 0x05)
end_define

begin_comment
comment|/* Selection/Reselection ID */
end_comment

begin_define
define|#
directive|define
name|SCSIDAT
value|(iobase + 0x06)
end_define

begin_comment
comment|/* SCSI Latched Data */
end_comment

begin_define
define|#
directive|define
name|SCSIBUS
value|(iobase + 0x07)
end_define

begin_comment
comment|/* SCSI Data Bus*/
end_comment

begin_define
define|#
directive|define
name|STCNT0
value|(iobase + 0x08)
end_define

begin_comment
comment|/* SCSI transfer count */
end_comment

begin_define
define|#
directive|define
name|STCNT1
value|(iobase + 0x09)
end_define

begin_define
define|#
directive|define
name|STCNT2
value|(iobase + 0x0a)
end_define

begin_define
define|#
directive|define
name|CLRSINT0
value|(iobase + 0x0b)
end_define

begin_comment
comment|/* Clear SCSI interrupts 0 */
end_comment

begin_define
define|#
directive|define
name|SSTAT0
value|(iobase + 0x0b)
end_define

begin_comment
comment|/* SCSI interrupt status 0 */
end_comment

begin_define
define|#
directive|define
name|CLRSINT1
value|(iobase + 0x0c)
end_define

begin_comment
comment|/* Clear SCSI interrupts 1 */
end_comment

begin_define
define|#
directive|define
name|SSTAT1
value|(iobase + 0x0c)
end_define

begin_comment
comment|/* SCSI status 1 */
end_comment

begin_define
define|#
directive|define
name|SSTAT2
value|(iobase + 0x0d)
end_define

begin_comment
comment|/* SCSI status 2 */
end_comment

begin_define
define|#
directive|define
name|SCSITEST
value|(iobase + 0x0e)
end_define

begin_comment
comment|/* SCSI test control */
end_comment

begin_define
define|#
directive|define
name|SSTAT3
value|(iobase + 0x0e)
end_define

begin_comment
comment|/* SCSI status 3 */
end_comment

begin_define
define|#
directive|define
name|CLRSERR
value|(iobase + 0x0f)
end_define

begin_comment
comment|/* Clear SCSI errors */
end_comment

begin_define
define|#
directive|define
name|SSTAT4
value|(iobase + 0x0f)
end_define

begin_comment
comment|/* SCSI status 4 */
end_comment

begin_define
define|#
directive|define
name|SIMODE0
value|(iobase + 0x10)
end_define

begin_comment
comment|/* SCSI interrupt mode 0 */
end_comment

begin_define
define|#
directive|define
name|SIMODE1
value|(iobase + 0x11)
end_define

begin_comment
comment|/* SCSI interrupt mode 1 */
end_comment

begin_define
define|#
directive|define
name|DMACNTRL0
value|(iobase + 0x12)
end_define

begin_comment
comment|/* DMA control 0 */
end_comment

begin_define
define|#
directive|define
name|DMACNTRL1
value|(iobase + 0x13)
end_define

begin_comment
comment|/* DMA control 1 */
end_comment

begin_define
define|#
directive|define
name|DMASTAT
value|(iobase + 0x14)
end_define

begin_comment
comment|/* DMA status */
end_comment

begin_define
define|#
directive|define
name|FIFOSTAT
value|(iobase + 0x15)
end_define

begin_comment
comment|/* FIFO status */
end_comment

begin_define
define|#
directive|define
name|DMADATA
value|(iobase + 0x16)
end_define

begin_comment
comment|/* DMA data */
end_comment

begin_define
define|#
directive|define
name|DMADATAL
value|(iobase + 0x16)
end_define

begin_comment
comment|/* DMA data low byte */
end_comment

begin_define
define|#
directive|define
name|DMADATAH
value|(iobase + 0x17)
end_define

begin_comment
comment|/* DMA data high byte */
end_comment

begin_define
define|#
directive|define
name|BRSTCNTRL
value|(iobase + 0x18)
end_define

begin_comment
comment|/* Burst Control */
end_comment

begin_define
define|#
directive|define
name|DMADATALONG
value|(iobase + 0x18)
end_define

begin_define
define|#
directive|define
name|PORTA
value|(iobase + 0x1a)
end_define

begin_comment
comment|/* Port A */
end_comment

begin_define
define|#
directive|define
name|PORTB
value|(iobase + 0x1b)
end_define

begin_comment
comment|/* Port B */
end_comment

begin_define
define|#
directive|define
name|REV
value|(iobase + 0x1c)
end_define

begin_comment
comment|/* Revision (001 for 6360) */
end_comment

begin_define
define|#
directive|define
name|STACK
value|(iobase + 0x1d)
end_define

begin_comment
comment|/* Stack */
end_comment

begin_define
define|#
directive|define
name|TEST
value|(iobase + 0x1e)
end_define

begin_comment
comment|/* Test register */
end_comment

begin_define
define|#
directive|define
name|ID
value|(iobase + 0x1f)
end_define

begin_comment
comment|/* ID register */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IDSTRING
value|"(C)1991ADAPTECAIC6360           "
end_define

begin_comment
comment|/* What all the bits do */
end_comment

begin_comment
comment|/* SCSISEQ */
end_comment

begin_define
define|#
directive|define
name|TEMODEO
value|0x80
end_define

begin_define
define|#
directive|define
name|ENSELO
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSELI
value|0x20
end_define

begin_define
define|#
directive|define
name|ENRESELI
value|0x10
end_define

begin_define
define|#
directive|define
name|ENAUTOATNO
value|0x08
end_define

begin_define
define|#
directive|define
name|ENAUTOATNI
value|0x04
end_define

begin_define
define|#
directive|define
name|ENAUTOATNP
value|0x02
end_define

begin_define
define|#
directive|define
name|SCSIRSTO
value|0x01
end_define

begin_comment
comment|/* SXFRCTL0 */
end_comment

begin_define
define|#
directive|define
name|SCSIEN
value|0x80
end_define

begin_define
define|#
directive|define
name|DMAEN
value|0x40
end_define

begin_define
define|#
directive|define
name|CHEN
value|0x20
end_define

begin_define
define|#
directive|define
name|CLRSTCNT
value|0x10
end_define

begin_define
define|#
directive|define
name|SPIOEN
value|0x08
end_define

begin_define
define|#
directive|define
name|CLRCH
value|0x02
end_define

begin_comment
comment|/* SXFRCTL1 */
end_comment

begin_define
define|#
directive|define
name|BITBUCKET
value|0x80
end_define

begin_define
define|#
directive|define
name|SWRAPEN
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSPCHK
value|0x20
end_define

begin_define
define|#
directive|define
name|STIMESEL1
value|0x10
end_define

begin_define
define|#
directive|define
name|STIMESEL0
value|0x08
end_define

begin_define
define|#
directive|define
name|STIMO_256ms
value|0x00
end_define

begin_define
define|#
directive|define
name|STIMO_128ms
value|0x08
end_define

begin_define
define|#
directive|define
name|STIMO_64ms
value|0x10
end_define

begin_define
define|#
directive|define
name|STIMO_32ms
value|0x18
end_define

begin_define
define|#
directive|define
name|ENSTIMER
value|0x04
end_define

begin_define
define|#
directive|define
name|BYTEALIGN
value|0x02
end_define

begin_comment
comment|/* SCSISIGI */
end_comment

begin_define
define|#
directive|define
name|CDI
value|0x80
end_define

begin_define
define|#
directive|define
name|IOI
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGI
value|0x20
end_define

begin_define
define|#
directive|define
name|ATNI
value|0x10
end_define

begin_define
define|#
directive|define
name|SELI
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYI
value|0x04
end_define

begin_define
define|#
directive|define
name|REQI
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKI
value|0x01
end_define

begin_comment
comment|/* Important! The 3 most significant bits of this register, in initiator mode,  * represents the "expected" SCSI bus phase and can be used to trigger phase  * mismatch and phase change interrupts.  But more important:  If there is a  * phase mismatch the chip will not transfer any data!  This is actually a nice  * feature as it gives us a bit more control over what is happening when we are  * bursting data (in) through the FIFOs and the phase suddenly changes from  * DATA IN to STATUS or MESSAGE IN.  The transfer will stop and wait for the  * proper phase to be set in this register instead of dumping the bits into the  * FIFOs.  */
end_comment

begin_comment
comment|/* SCSISIGO */
end_comment

begin_define
define|#
directive|define
name|CDO
value|0x80
end_define

begin_define
define|#
directive|define
name|CDEXP
value|(CDO)
end_define

begin_define
define|#
directive|define
name|IOO
value|0x40
end_define

begin_define
define|#
directive|define
name|IOEXP
value|(IOO)
end_define

begin_define
define|#
directive|define
name|MSGO
value|0x20
end_define

begin_define
define|#
directive|define
name|MSGEXP
value|(MSGO)
end_define

begin_define
define|#
directive|define
name|ATNO
value|0x10
end_define

begin_define
define|#
directive|define
name|SELO
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYO
value|0x04
end_define

begin_define
define|#
directive|define
name|REQO
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKO
value|0x01
end_define

begin_comment
comment|/* Information transfer phases */
end_comment

begin_define
define|#
directive|define
name|PH_DOUT
value|(0)
end_define

begin_define
define|#
directive|define
name|PH_DIN
value|(IOI)
end_define

begin_define
define|#
directive|define
name|PH_CMD
value|(CDI)
end_define

begin_define
define|#
directive|define
name|PH_STAT
value|(CDI|IOI)
end_define

begin_define
define|#
directive|define
name|PH_MSGO
value|(MSGI|CDI)
end_define

begin_define
define|#
directive|define
name|PH_MSGI
value|(MSGI|CDI|IOI)
end_define

begin_define
define|#
directive|define
name|PH_MASK
value|0xe0
end_define

begin_comment
comment|/* Some pseudo phases for getphase()*/
end_comment

begin_define
define|#
directive|define
name|PH_BUSFREE
value|0x100
end_define

begin_comment
comment|/* (Re)Selection no longer valid */
end_comment

begin_define
define|#
directive|define
name|PH_INVALID
value|0x101
end_define

begin_comment
comment|/* (Re)Selection valid, but no REQ yet */
end_comment

begin_define
define|#
directive|define
name|PH_PSBIT
value|0x100
end_define

begin_comment
comment|/* "pseudo" bit */
end_comment

begin_comment
comment|/* SCSIRATE */
end_comment

begin_define
define|#
directive|define
name|SXFR2
value|0x40
end_define

begin_define
define|#
directive|define
name|SXFR1
value|0x20
end_define

begin_define
define|#
directive|define
name|SXFR0
value|0x10
end_define

begin_define
define|#
directive|define
name|SOFS3
value|0x08
end_define

begin_define
define|#
directive|define
name|SOFS2
value|0x04
end_define

begin_define
define|#
directive|define
name|SOFS1
value|0x02
end_define

begin_define
define|#
directive|define
name|SOFS0
value|0x01
end_define

begin_comment
comment|/* SCSI ID */
end_comment

begin_define
define|#
directive|define
name|OID2
value|0x40
end_define

begin_define
define|#
directive|define
name|OID1
value|0x20
end_define

begin_define
define|#
directive|define
name|OID0
value|0x10
end_define

begin_define
define|#
directive|define
name|OID_S
value|4
end_define

begin_comment
comment|/* shift value */
end_comment

begin_define
define|#
directive|define
name|TID2
value|0x04
end_define

begin_define
define|#
directive|define
name|TID1
value|0x02
end_define

begin_define
define|#
directive|define
name|TID0
value|0x01
end_define

begin_define
define|#
directive|define
name|SCSI_ID_MASK
value|0x7
end_define

begin_comment
comment|/* SCSI selection/reselection ID (both target *and* initiator) */
end_comment

begin_define
define|#
directive|define
name|SELID7
value|0x80
end_define

begin_define
define|#
directive|define
name|SELID6
value|0x40
end_define

begin_define
define|#
directive|define
name|SELID5
value|0x20
end_define

begin_define
define|#
directive|define
name|SELID4
value|0x10
end_define

begin_define
define|#
directive|define
name|SELID3
value|0x08
end_define

begin_define
define|#
directive|define
name|SELID2
value|0x04
end_define

begin_define
define|#
directive|define
name|SELID1
value|0x02
end_define

begin_define
define|#
directive|define
name|SELID0
value|0x01
end_define

begin_comment
comment|/* CLRSINT0                      Clears what? (interrupt and/or status bit) */
end_comment

begin_define
define|#
directive|define
name|SETSDONE
value|0x80
end_define

begin_define
define|#
directive|define
name|CLRSELDO
value|0x40
end_define

begin_comment
comment|/* I */
end_comment

begin_define
define|#
directive|define
name|CLRSELDI
value|0x20
end_define

begin_comment
comment|/* I+ */
end_comment

begin_define
define|#
directive|define
name|CLRSELINGO
value|0x10
end_define

begin_comment
comment|/* I */
end_comment

begin_define
define|#
directive|define
name|CLRSWRAP
value|0x08
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRSDONE
value|0x04
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRSPIORDY
value|0x02
end_define

begin_comment
comment|/* I */
end_comment

begin_define
define|#
directive|define
name|CLRDMADONE
value|0x01
end_define

begin_comment
comment|/* I */
end_comment

begin_comment
comment|/* SSTAT0                          Howto clear */
end_comment

begin_define
define|#
directive|define
name|TARGET
value|0x80
end_define

begin_define
define|#
directive|define
name|SELDO
value|0x40
end_define

begin_comment
comment|/* Selfclearing */
end_comment

begin_define
define|#
directive|define
name|SELDI
value|0x20
end_define

begin_comment
comment|/* Selfclearing when CLRSELDI is set */
end_comment

begin_define
define|#
directive|define
name|SELINGO
value|0x10
end_define

begin_comment
comment|/* Selfclearing */
end_comment

begin_define
define|#
directive|define
name|SWRAP
value|0x08
end_define

begin_comment
comment|/* CLRSWAP */
end_comment

begin_define
define|#
directive|define
name|SDONE
value|0x04
end_define

begin_comment
comment|/* Not used in initiator mode */
end_comment

begin_define
define|#
directive|define
name|SPIORDY
value|0x02
end_define

begin_comment
comment|/* Selfclearing (op on SCSIDAT) */
end_comment

begin_define
define|#
directive|define
name|DMADONE
value|0x01
end_define

begin_comment
comment|/* Selfclearing (all FIFOs empty& T/C */
end_comment

begin_comment
comment|/* CLRSINT1                      Clears what? */
end_comment

begin_define
define|#
directive|define
name|CLRSELTIMO
value|0x80
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRATNO
value|0x40
end_define

begin_define
define|#
directive|define
name|CLRSCSIRSTI
value|0x20
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRBUSFREE
value|0x08
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRSCSIPERR
value|0x04
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRPHASECHG
value|0x02
end_define

begin_comment
comment|/* I+S */
end_comment

begin_define
define|#
directive|define
name|CLRREQINIT
value|0x01
end_define

begin_comment
comment|/* I+S */
end_comment

begin_comment
comment|/* SSTAT1                       How to clear?  When set?*/
end_comment

begin_define
define|#
directive|define
name|SELTO
value|0x80
end_define

begin_comment
comment|/* C		select out timeout */
end_comment

begin_define
define|#
directive|define
name|ATNTARG
value|0x40
end_define

begin_comment
comment|/* Not used in initiator mode */
end_comment

begin_define
define|#
directive|define
name|SCSIRSTI
value|0x20
end_define

begin_comment
comment|/* C		RST asserted */
end_comment

begin_define
define|#
directive|define
name|PHASEMIS
value|0x10
end_define

begin_comment
comment|/* Selfclearing */
end_comment

begin_define
define|#
directive|define
name|BUSFREE
value|0x08
end_define

begin_comment
comment|/* C		bus free condition */
end_comment

begin_define
define|#
directive|define
name|SCSIPERR
value|0x04
end_define

begin_comment
comment|/* C		parity error on inbound data */
end_comment

begin_define
define|#
directive|define
name|PHASECHG
value|0x02
end_define

begin_comment
comment|/* C	     phase in SCSISIGI doesn't match */
end_comment

begin_define
define|#
directive|define
name|REQINIT
value|0x01
end_define

begin_comment
comment|/* C or ACK	asserting edge of REQ */
end_comment

begin_comment
comment|/* SSTAT2 */
end_comment

begin_define
define|#
directive|define
name|SOFFSET
value|0x20
end_define

begin_define
define|#
directive|define
name|SEMPTY
value|0x10
end_define

begin_define
define|#
directive|define
name|SFULL
value|0x08
end_define

begin_define
define|#
directive|define
name|SFCNT2
value|0x04
end_define

begin_define
define|#
directive|define
name|SFCNT1
value|0x02
end_define

begin_define
define|#
directive|define
name|SFCNT0
value|0x01
end_define

begin_comment
comment|/* SCSITEST */
end_comment

begin_define
define|#
directive|define
name|SCTESTU
value|0x08
end_define

begin_define
define|#
directive|define
name|SCTESTD
value|0x04
end_define

begin_define
define|#
directive|define
name|STCTEST
value|0x01
end_define

begin_comment
comment|/* SSTAT3 */
end_comment

begin_define
define|#
directive|define
name|SCSICNT3
value|0x80
end_define

begin_define
define|#
directive|define
name|SCSICNT2
value|0x40
end_define

begin_define
define|#
directive|define
name|SCSICNT1
value|0x20
end_define

begin_define
define|#
directive|define
name|SCSICNT0
value|0x10
end_define

begin_define
define|#
directive|define
name|OFFCNT3
value|0x08
end_define

begin_define
define|#
directive|define
name|OFFCNT2
value|0x04
end_define

begin_define
define|#
directive|define
name|OFFCNT1
value|0x02
end_define

begin_define
define|#
directive|define
name|OFFCNT0
value|0x01
end_define

begin_comment
comment|/* CLRSERR */
end_comment

begin_define
define|#
directive|define
name|CLRSYNCERR
value|0x04
end_define

begin_define
define|#
directive|define
name|CLRFWERR
value|0x02
end_define

begin_define
define|#
directive|define
name|CLRFRERR
value|0x01
end_define

begin_comment
comment|/* SSTAT4 */
end_comment

begin_define
define|#
directive|define
name|SYNCERR
value|0x04
end_define

begin_define
define|#
directive|define
name|FWERR
value|0x02
end_define

begin_define
define|#
directive|define
name|FRERR
value|0x01
end_define

begin_comment
comment|/* SIMODE0 */
end_comment

begin_define
define|#
directive|define
name|ENSELDO
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSELDI
value|0x20
end_define

begin_define
define|#
directive|define
name|ENSELINGO
value|0x10
end_define

begin_define
define|#
directive|define
name|ENSWRAP
value|0x08
end_define

begin_define
define|#
directive|define
name|ENSDONE
value|0x04
end_define

begin_define
define|#
directive|define
name|ENSPIORDY
value|0x02
end_define

begin_define
define|#
directive|define
name|ENDMADONE
value|0x01
end_define

begin_comment
comment|/* SIMODE1 */
end_comment

begin_define
define|#
directive|define
name|ENSELTIMO
value|0x80
end_define

begin_define
define|#
directive|define
name|ENATNTARG
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSCSIRST
value|0x20
end_define

begin_define
define|#
directive|define
name|ENPHASEMIS
value|0x10
end_define

begin_define
define|#
directive|define
name|ENBUSFREE
value|0x08
end_define

begin_define
define|#
directive|define
name|ENSCSIPERR
value|0x04
end_define

begin_define
define|#
directive|define
name|ENPHASECHG
value|0x02
end_define

begin_define
define|#
directive|define
name|ENREQINIT
value|0x01
end_define

begin_comment
comment|/* DMACNTRL0 */
end_comment

begin_define
define|#
directive|define
name|ENDMA
value|0x80
end_define

begin_define
define|#
directive|define
name|B8MODE
value|0x40
end_define

begin_define
define|#
directive|define
name|DMA
value|0x20
end_define

begin_define
define|#
directive|define
name|DWORDPIO
value|0x10
end_define

begin_define
define|#
directive|define
name|WRITE
value|0x08
end_define

begin_define
define|#
directive|define
name|INTEN
value|0x04
end_define

begin_define
define|#
directive|define
name|RSTFIFO
value|0x02
end_define

begin_define
define|#
directive|define
name|SWINT
value|0x01
end_define

begin_comment
comment|/* DMACNTRL1 */
end_comment

begin_define
define|#
directive|define
name|PWRDWN
value|0x80
end_define

begin_define
define|#
directive|define
name|ENSTK32
value|0x40
end_define

begin_define
define|#
directive|define
name|STK4
value|0x10
end_define

begin_define
define|#
directive|define
name|STK3
value|0x08
end_define

begin_define
define|#
directive|define
name|STK2
value|0x04
end_define

begin_define
define|#
directive|define
name|STK1
value|0x02
end_define

begin_define
define|#
directive|define
name|STK0
value|0x01
end_define

begin_comment
comment|/* DMASTAT */
end_comment

begin_define
define|#
directive|define
name|ATDONE
value|0x80
end_define

begin_define
define|#
directive|define
name|WORDRDY
value|0x40
end_define

begin_define
define|#
directive|define
name|INTSTAT
value|0x20
end_define

begin_define
define|#
directive|define
name|DFIFOFULL
value|0x10
end_define

begin_define
define|#
directive|define
name|DFIFOEMP
value|0x08
end_define

begin_define
define|#
directive|define
name|DFIFOHF
value|0x04
end_define

begin_define
define|#
directive|define
name|DWORDRDY
value|0x02
end_define

begin_comment
comment|/* BRSTCNTRL */
end_comment

begin_define
define|#
directive|define
name|BON3
value|0x80
end_define

begin_define
define|#
directive|define
name|BON2
value|0x40
end_define

begin_define
define|#
directive|define
name|BON1
value|0x20
end_define

begin_define
define|#
directive|define
name|BON0
value|0x10
end_define

begin_define
define|#
directive|define
name|BOFF3
value|0x08
end_define

begin_define
define|#
directive|define
name|BOFF2
value|0x04
end_define

begin_define
define|#
directive|define
name|BOFF1
value|0x02
end_define

begin_define
define|#
directive|define
name|BOFF0
value|0x01
end_define

begin_comment
comment|/* TEST */
end_comment

begin_define
define|#
directive|define
name|BOFFTMR
value|0x40
end_define

begin_define
define|#
directive|define
name|BONTMR
value|0x20
end_define

begin_define
define|#
directive|define
name|STCNTH
value|0x10
end_define

begin_define
define|#
directive|define
name|STCNTM
value|0x08
end_define

begin_define
define|#
directive|define
name|STCNTL
value|0x04
end_define

begin_define
define|#
directive|define
name|SCSIBLK
value|0x02
end_define

begin_define
define|#
directive|define
name|DMABLK
value|0x01
end_define

begin_define
define|#
directive|define
name|orreg
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
value|outb((reg), inb(reg)| (val))
end_define

begin_define
define|#
directive|define
name|andreg
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
value|outb((reg), inb(reg)& (val))
end_define

begin_define
define|#
directive|define
name|nandreg
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
value|outb((reg), inb(reg)&~(val))
end_define

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_define
define|#
directive|define
name|fatal_if_no_DDB
parameter_list|()
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|fatal_if_no_DDB
parameter_list|()
value|panic("panic for historical reasons")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|u_long
name|physaddr
typedef|;
end_typedef

begin_struct
struct|struct
name|aic_dma_seg
block|{
name|physaddr
name|addr
decl_stmt|;
name|long
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DELAYCOUNT
value|16
end_define

begin_define
define|#
directive|define
name|FUDGE
parameter_list|(
name|X
parameter_list|)
value|((X)>>1)
end_define

begin_comment
comment|/* get 1 ms spincount */
end_comment

begin_define
define|#
directive|define
name|MINIFUDGE
parameter_list|(
name|X
parameter_list|)
value|((X)>>4)
end_define

begin_comment
comment|/* get (approx) 125us spincount */
end_comment

begin_define
define|#
directive|define
name|AIC_NSEG
value|16
end_define

begin_define
define|#
directive|define
name|NUM_CONCURRENT
value|7
end_define

begin_comment
comment|/* Only one per target for now */
end_comment

begin_comment
comment|/*  * ACB. Holds additional information for each SCSI command Comments: We  * need a separate scsi command block because we may need to overwrite it  * with a request sense command.  Basicly, we refrain from fiddling with  * the scsi_xfer struct (except do the expected updating of return values).  * We'll generally update: xs->{flags,resid,error,sense,status} and  * occasionally xs->retries.  */
end_comment

begin_struct
struct|struct
name|acb
block|{
name|TAILQ_ENTRY
argument_list|(
argument|acb
argument_list|)
name|chain
expr_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* SCSI xfer ctrl block from above */
name|int
name|flags
decl_stmt|;
comment|/* Status */
define|#
directive|define
name|ACB_FREE
value|0x00
define|#
directive|define
name|ACB_ACTIVE
value|0x01
define|#
directive|define
name|ACB_DONE
value|0x04
define|#
directive|define
name|ACB_CHKSENSE
value|0x08
comment|/*	struct aic_dma_seg dma[AIC_NSEG]; */
comment|/* Physical addresses+len */
name|struct
name|scsi_generic
name|cmd
decl_stmt|;
comment|/* SCSI command block */
name|int
name|clen
decl_stmt|;
name|char
modifier|*
name|daddr
decl_stmt|;
comment|/* Saved data pointer */
name|int
name|dleft
decl_stmt|;
comment|/* Residue */
name|int
name|stat
decl_stmt|;
comment|/* SCSI status byte */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Some info about each (possible) target on the SCSI bus.  This should  * probably have been a "per target+lunit" structure, but we'll leave it at  * this for now.  Is there a way to reliably hook it up to sc->fordriver??  */
end_comment

begin_struct
struct|struct
name|aic_tinfo
block|{
name|int
name|cmds
decl_stmt|;
comment|/* #commands processed */
name|int
name|dconns
decl_stmt|;
comment|/* #disconnects */
name|int
name|touts
decl_stmt|;
comment|/* #timeouts */
name|int
name|perrs
decl_stmt|;
comment|/* #parity errors */
name|int
name|senses
decl_stmt|;
comment|/* #request sense commands sent */
name|ushort
name|lubusy
decl_stmt|;
comment|/* What local units/subr. are busy? */
name|u_char
name|flags
decl_stmt|;
define|#
directive|define
name|NEED_TO_RESET
value|0x01
comment|/* Should send a BUS_DEV_RESET */
define|#
directive|define
name|DO_NEGOTIATE
value|0x02
comment|/* (Re)Negotiate synchronous options */
define|#
directive|define
name|TARGET_BUSY
value|0x04
comment|/* Target is busy, i.e. cmd in progress */
name|u_char
name|persgst
decl_stmt|;
comment|/* Period suggestion */
name|u_char
name|offsgst
decl_stmt|;
comment|/* Offset suggestion */
name|u_char
name|syncdata
decl_stmt|;
comment|/* True negotiated synch parameters */
block|}
struct|;
end_struct

begin_comment
comment|/* Register a linenumber (for debugging) */
end_comment

begin_if
if|#
directive|if
name|AIC_DEBUG
end_if

begin_define
define|#
directive|define
name|LOGLINE
parameter_list|(
name|p
parameter_list|)
define|\
value|do {					\ 		p->history[p->hp] = __LINE__;	\ 		p->hp = ++p->hp % AIC_HSIZE;	\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LOGLINE
parameter_list|(
name|p
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
name|aic_data
block|{
comment|/* One of these per adapter */
name|u_short
name|iobase
decl_stmt|;
comment|/* Base I/O port */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* prototype for subdevs */
name|int
name|aic_int
decl_stmt|;
comment|/* IRQ on the EISA bus */
name|int
name|aic_dma
decl_stmt|;
comment|/* DRQ on the EISA bus */
comment|/* Lists of command blocks */
name|TAILQ_HEAD
argument_list|(
argument|acb_list
argument_list|,
argument|acb
argument_list|)
name|free_list
operator|,
name|ready_list
operator|,
name|nexus_list
expr_stmt|;
name|struct
name|acb
modifier|*
name|nexus
decl_stmt|;
comment|/* current command */
comment|/* Command blocks and target info */
name|struct
name|acb
name|acb
index|[
name|NUM_CONCURRENT
index|]
decl_stmt|;
name|struct
name|aic_tinfo
name|tinfo
index|[
literal|8
index|]
decl_stmt|;
comment|/* Data about the current nexus (updated for every cmd switch) */
name|u_char
modifier|*
name|dp
decl_stmt|;
comment|/* Current data pointer */
name|int
name|dleft
decl_stmt|;
comment|/* Data left to transfer */
comment|/* Adapter state */
name|short
name|phase
decl_stmt|;
comment|/* Copy of what bus phase we are in */
name|short
name|prevphase
decl_stmt|;
comment|/* Copy of what bus phase we were in */
name|short
name|state
decl_stmt|;
comment|/* State applicable to the adapter */
define|#
directive|define
name|AIC_IDLE
value|0x01
define|#
directive|define
name|AIC_TMP_UNAVAIL
value|0x02
comment|/* Don't accept SCSI commands */
define|#
directive|define
name|AIC_SELECTING
value|0x03
comment|/* SCSI command is arbiting  */
define|#
directive|define
name|AIC_RESELECTED
value|0x04
comment|/* Has been reselected */
define|#
directive|define
name|AIC_HASNEXUS
value|0x05
comment|/* Actively using the SCSI bus */
define|#
directive|define
name|AIC_CLEANING
value|0x06
name|short
name|flags
decl_stmt|;
define|#
directive|define
name|AIC_DROP_MSGI
value|0x01
comment|/* Discard all msgs (parity err detected) */
define|#
directive|define
name|AIC_DOINGDMA
value|0x02
comment|/* The FIFO data path is active! */
define|#
directive|define
name|AIC_BUSFREE_OK
value|0x04
comment|/* Bus free phase is OK. */
define|#
directive|define
name|AIC_SYNCHNEGO
value|0x08
comment|/* Synch negotiation in progress. */
define|#
directive|define
name|AIC_BLOCKED
value|0x10
comment|/* Don't schedule new scsi bus operations */
comment|/* Debugging stuff */
define|#
directive|define
name|AIC_HSIZE
value|8
name|short
name|history
index|[
name|AIC_HSIZE
index|]
decl_stmt|;
comment|/* Store line numbers here. */
name|short
name|hp
decl_stmt|;
name|u_char
name|progress
decl_stmt|;
comment|/* Set if interrupt has achieved progress */
comment|/* Message stuff */
name|u_char
name|msgpriq
decl_stmt|;
comment|/* One or more messages to send (encoded) */
name|u_char
name|msgout
decl_stmt|;
comment|/* What message is on its way out? */
define|#
directive|define
name|SEND_DEV_RESET
value|0x01
define|#
directive|define
name|SEND_PARITY_ERROR
value|0x02
define|#
directive|define
name|SEND_ABORT
value|0x04
define|#
directive|define
name|SEND_REJECT
value|0x08
define|#
directive|define
name|SEND_INIT_DET_ERR
value|0x10
define|#
directive|define
name|SEND_IDENTIFY
value|0x20
define|#
directive|define
name|SEND_SDTR
value|0x40
define|#
directive|define
name|AIC_MAX_MSG_LEN
value|8
name|u_char
name|omess
index|[
name|AIC_MAX_MSG_LEN
index|]
decl_stmt|;
comment|/* Scratch area for messages */
name|u_char
operator|*
expr|omp
expr_stmt|;
comment|/* Message pointer (for multibyte messages) */
name|u_char
name|omlen
decl_stmt|;
name|u_char
name|imess
index|[
name|AIC_MAX_MSG_LEN
operator|+
literal|1
index|]
decl_stmt|;
name|u_char
modifier|*
name|imp
decl_stmt|;
comment|/* Message pointer (for multibyte messages) */
name|u_char
name|imlen
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|int
modifier|*
name|aicport
decl_stmt|;
comment|/* I/O port information */
endif|#
directive|endif
block|}
modifier|*
name|aicdata
index|[
name|NAIC
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|AIC_SHOWACBS
value|0x01
end_define

begin_define
define|#
directive|define
name|AIC_SHOWINTS
value|0x02
end_define

begin_define
define|#
directive|define
name|AIC_SHOWCMDS
value|0x04
end_define

begin_define
define|#
directive|define
name|AIC_SHOWMISC
value|0x08
end_define

begin_define
define|#
directive|define
name|AIC_SHOWTRAC
value|0x10
end_define

begin_define
define|#
directive|define
name|AIC_SHOWSTART
value|0x20
end_define

begin_decl_stmt
specifier|static
name|int
name|aic_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AIC_SHOWSTART|AIC_SHOWMISC|AIC_SHOWTRAC; */
end_comment

begin_if
if|#
directive|if
name|AIC_DEBUG
end_if

begin_define
define|#
directive|define
name|AIC_ACBS
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWACBS) printf str;} while (0)
end_define

begin_define
define|#
directive|define
name|AIC_MISC
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWMISC) printf str;} while (0)
end_define

begin_define
define|#
directive|define
name|AIC_INTS
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWINTS) printf str;} while (0)
end_define

begin_define
define|#
directive|define
name|AIC_TRACE
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWTRAC) printf str;} while (0)
end_define

begin_define
define|#
directive|define
name|AIC_CMDS
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWCMDS) printf str;} while (0)
end_define

begin_define
define|#
directive|define
name|AIC_START
parameter_list|(
name|str
parameter_list|)
value|do {if (aic_debug& AIC_SHOWSTART) printf str;}while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AIC_ACBS
parameter_list|(
name|str
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AIC_MISC
parameter_list|(
name|str
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AIC_INTS
parameter_list|(
name|str
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AIC_TRACE
parameter_list|(
name|str
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AIC_CMDS
parameter_list|(
name|str
parameter_list|)
end_define

begin_define
define|#
directive|define
name|AIC_START
parameter_list|(
name|str
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|aicprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aicattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_minphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|aic_adapter_info
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_init
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aic_find
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_done
name|__P
argument_list|(
operator|(
expr|struct
name|acb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_dataout
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_datain
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|aic_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aic_poll
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|,
expr|struct
name|acb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|aic_add_timeout
name|__P
argument_list|(
operator|(
expr|struct
name|acb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|aic_remove_timeout
name|__P
argument_list|(
operator|(
expr|struct
name|acb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic6360_reset
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|aicphase
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_msgin
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_msgout
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
name|aic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|aic_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_sched
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aic_scsi_reset
name|__P
argument_list|(
operator|(
expr|struct
name|aic_data
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|AIC_DEBUG
end_if

begin_decl_stmt
name|void
name|aic_print_active_acb
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|aic_dump6360
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|aic_dump_driver
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_DETACH
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|aicdetach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Linkup to the rest of the kernel */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|aicdriver
init|=
block|{
name|aicprobe
block|,
name|aicattach
block|,
literal|"aic"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aicunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|aic_switch
init|=
block|{
name|aic_scsi_cmd
block|,
name|aic_minphys
block|,
literal|0
block|,
literal|0
block|,
name|aic_adapter_info
block|,
literal|"aic"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|aic_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"aic"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* PCCARD suport */
end_comment

begin_include
include|#
directive|include
file|"card.h"
end_include

begin_if
if|#
directive|if
name|NCARD
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/driver.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_function_decl
specifier|static
name|int
name|aicinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* init device */
end_comment

begin_function_decl
name|void
name|aicunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Disable driver */
end_comment

begin_function_decl
specifier|static
name|int
name|aic_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Interrupt handler */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pccard_device
name|aic_info
init|=
block|{
literal|"aic"
block|,
name|aicinit
block|,
name|aicunload
block|,
name|aic_card_intr
block|,
literal|0
block|,
comment|/* Attributes - presently unused */
operator|&
name|bio_imask
comment|/* Interrupt mask for device */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pccarddrv_set
argument_list|,
name|aic_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialize the device - called from Slot manager.  */
end_comment

begin_function
name|int
name|aicinit
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
specifier|static
name|int
name|already_aicinit
index|[
name|NAIC
index|]
decl_stmt|;
comment|/* validate unit number */
if|if
condition|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
operator|>=
name|NAIC
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* Make sure it isn't already initialised */
if|if
condition|(
name|already_aicinit
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|aicattach
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Probe the device. If a value is returned, the 	 * device was found at the location. 	 */
if|if
condition|(
name|aicprobe
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|aicattach
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|already_aicinit
index|[
name|devi
operator|->
name|isahd
operator|.
name|id_unit
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * aicunload - unload the driver and clear the table.  * XXX TODO:  * This is called usually when the card is ejected, but  * can be caused by the modunload of a controller driver.  * The idea is reset the driver's view of the device  * and ensure that any driver entry points such as  * read and write do not hang.  */
end_comment

begin_function
name|void
name|aicunload
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|printf
argument_list|(
literal|"aic%d: unload\n"
argument_list|,
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|aicstop(devi->isahd.id_unit);
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCSI_DETACH
name|aicdetach
argument_list|(
operator|&
name|devi
operator|->
name|isahd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * card_intr - Shared interrupt called from front end of PC-Card handler.  */
end_comment

begin_function
specifier|static
name|int
name|aic_card_intr
parameter_list|(
name|struct
name|pccard_devinfo
modifier|*
name|devi
parameter_list|)
block|{
name|aicintr
argument_list|(
name|devi
operator|->
name|isahd
operator|.
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCARD> 0 */
end_comment

begin_comment
comment|/*  * INITIALIZATION ROUTINES (probe, attach ++)  */
end_comment

begin_comment
comment|/*  * aicprobe: probe for AIC6360 SCSI-controller  * returns non-zero value if a controller is found.  */
end_comment

begin_function
specifier|static
name|int
name|aicprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
if|#
directive|if
name|NCARD
operator|>
literal|0
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|int
name|aic_reg_drv
index|[
name|NAIC
index|]
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|aicunit
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|unit
operator|>=
name|NAIC
condition|)
block|{
name|printf
argument_list|(
literal|"aic%d: unit number too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
if|#
directive|if
name|NCARD
operator|>
literal|0
if|if
condition|(
operator|!
name|aic_reg_drv
index|[
name|unit
index|]
condition|)
name|aic_reg_drv
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|aicdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"aic%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aic_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aic
condition|)
block|{
name|printf
argument_list|(
literal|"aic%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|aic
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aic_data
argument_list|)
argument_list|)
expr_stmt|;
name|aicdata
index|[
name|unit
index|]
operator|=
name|aic
expr_stmt|;
name|aic
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|AIC_TYPE98
argument_list|(
name|dev
operator|->
name|id_flags
argument_list|)
operator|==
name|AIC98_100
condition|)
block|{
comment|/* PC-9801-100 */
name|aic
operator|->
name|aicport
operator|=
name|aicport_100
expr_stmt|;
block|}
else|else
block|{
comment|/* generic card */
name|aic
operator|->
name|aicport
operator|=
name|aicport_generic
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|aic_find
argument_list|(
name|aic
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|aicdata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|aic
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aicunit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|AIC_TYPE98
argument_list|(
name|dev
operator|->
name|id_flags
argument_list|)
operator|==
name|AIC98_100
condition|)
return|return
literal|0x40
return|;
endif|#
directive|endif
return|return
literal|0x20
return|;
block|}
end_function

begin_comment
comment|/* Do the real search-for-device.  * Prerequisite: aic->iobase should be set to the proper value  */
end_comment

begin_function
specifier|static
name|int
name|aic_find
parameter_list|(
name|aic
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|char
name|chip_id
index|[
sizeof|sizeof
argument_list|(
name|IDSTRING
argument_list|)
index|]
decl_stmt|;
comment|/* For chips that support it */
name|int
name|i
decl_stmt|;
comment|/* Remove aic6360 from possible powerdown mode */
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Thanks to mark@aggregate.com for the new method for detecting 	 * whether the chip is present or not.  Bonus: may also work for 	 * the AIC-6260!  	 */
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic: probing for aic-chip at port 0x%x\n"
operator|,
operator|(
name|int
operator|)
name|iobase
operator|)
argument_list|)
expr_stmt|;
comment|/*  	 * Linux also init's the stack to 1-16 and then clears it,      	 *  6260's don't appear to have an ID reg - mpg  	 */
comment|/* Push the sequence 0,1,..,15 on the stack */
define|#
directive|define
name|STSIZE
value|16
name|outb
argument_list|(
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset stack pointer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STSIZE
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|STACK
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* See if we can pull out the same sequence */
name|outb
argument_list|(
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|STSIZE
operator|&&
name|inb
argument_list|(
name|STACK
argument_list|)
operator|==
name|i
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|!=
name|STSIZE
condition|)
block|{
name|AIC_START
argument_list|(
operator|(
literal|"STACK futzed at %d.\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
comment|/* See if we can pull the id string out of the ID register, 	 * now only used for informational purposes. 	 */
name|bzero
argument_list|(
name|chip_id
argument_list|,
sizeof|sizeof
argument_list|(
name|chip_id
argument_list|)
argument_list|)
expr_stmt|;
name|insb
argument_list|(
name|ID
argument_list|,
name|chip_id
argument_list|,
sizeof|sizeof
argument_list|(
name|IDSTRING
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|AIC_START
argument_list|(
operator|(
literal|"AIC found at 0x%x "
operator|,
operator|(
name|int
operator|)
name|aic
operator|->
name|iobase
operator|)
argument_list|)
expr_stmt|;
name|AIC_START
argument_list|(
operator|(
literal|"ID: %s "
operator|,
name|chip_id
operator|)
argument_list|)
expr_stmt|;
name|AIC_START
argument_list|(
operator|(
literal|"chip revision %d\n"
operator|,
operator|(
name|int
operator|)
name|inb
argument_list|(
name|REV
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_DETACH
end_ifdef

begin_function
specifier|static
name|void
name|aicdetach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
init|=
name|aicdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|scbus
operator|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|scsi_extend_get
argument_list|(
name|aicdata
index|[
name|unit
index|]
operator|->
name|sc_link
operator|.
name|scsibus
argument_list|)
expr_stmt|;
name|scsi_detachdev
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_DETACH */
end_comment

begin_comment
comment|/*  * Attach the AIC6360, fill out some high and low level data structures  */
end_comment

begin_function
specifier|static
name|int
name|aicattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
init|=
name|aicdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aicattach\n"
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|aic_scsi_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Init chip and driver */
comment|/* 	 * Fill in the prototype scsi_link 	 */
name|aic
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|aic
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|AIC_SCSI_HOSTID
expr_stmt|;
name|aic
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|aic
expr_stmt|;
name|aic
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|aic_switch
expr_stmt|;
name|aic
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|aic_dev
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|aic
operator|->
name|sc_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize AIC6360 chip itself  * The following conditions should hold:  * aicprobe should have succeeded, i.e. the iobase address in aic_data must  * be valid.  */
end_comment

begin_function
specifier|static
name|void
name|aic6360_reset
parameter_list|(
name|aic
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|outb
argument_list|(
name|SCSITEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Doc. recommends to clear these two */
name|outb
argument_list|(
name|TEST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* registers before operations commence */
comment|/* Reset SCSI-FIFO and abort any transfers */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRCH
operator||
name|CLRSTCNT
argument_list|)
expr_stmt|;
comment|/* Reset DMA-FIFO */
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|RSTFIFO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable all selection features */
name|outb
argument_list|(
name|SXFRCTL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Disable some interrupts */
name|outb
argument_list|(
name|CLRSINT0
argument_list|,
literal|0x7f
argument_list|)
expr_stmt|;
comment|/* Clear a slew of interrupts */
name|outb
argument_list|(
name|SIMODE1
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Disable some more interrupts */
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
literal|0xef
argument_list|)
expr_stmt|;
comment|/* Clear another slew of interrupts */
name|outb
argument_list|(
name|SCSIRATE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable synchronous transfers */
name|outb
argument_list|(
name|CLRSERR
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
comment|/* Haven't seen ant errors (yet) */
name|outb
argument_list|(
name|SCSIID
argument_list|,
name|AIC_SCSI_HOSTID
operator|<<
name|OID_S
argument_list|)
expr_stmt|;
comment|/* Set our SCSI-ID */
name|outb
argument_list|(
name|BRSTCNTRL
argument_list|,
name|EISA_BRST_TIM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pull the SCSI RST line for 500 us */
end_comment

begin_function
specifier|static
name|void
name|aic_scsi_reset
parameter_list|(
name|aic
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize aic SCSI driver, also (conditonally) reset the SCSI bus.  * The reinitialization is still buggy (e.g. on SCSI resets).  */
end_comment

begin_function
specifier|static
name|void
name|aic_init
parameter_list|(
name|aic
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Reset the SCSI-bus itself */
name|aic_scsi_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic6360_reset
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Clean up our own hardware */
comment|/*XXX*/
comment|/* If not the first time (probably a reset condition), 	 * we should clean queues with active commands 	 */
if|if
condition|(
name|aic
operator|->
name|state
operator|==
literal|0
condition|)
block|{
comment|/* First time through */
name|TAILQ_INIT
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aic
operator|->
name|nexus_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|aic
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
literal|0
expr_stmt|;
name|acb
operator|=
name|aic
operator|->
name|acb
expr_stmt|;
name|bzero
argument_list|(
name|acb
argument_list|,
sizeof|sizeof
argument_list|(
name|aic
operator|->
name|acb
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
sizeof|sizeof
argument_list|(
name|aic
operator|->
name|acb
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|acb
argument_list|)
condition|;
name|r
operator|++
control|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aic
operator|->
name|free_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|acb
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|aic
operator|->
name|tinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|aic
operator|->
name|tinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aic
operator|->
name|state
operator|=
name|AIC_CLEANING
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|nexus
operator|!=
name|NULL
condition|)
block|{
name|aic
operator|->
name|nexus
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|aic
operator|->
name|nexus
argument_list|,
name|aic
operator|->
name|nexus
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|aic
operator|->
name|nexus
argument_list|)
expr_stmt|;
block|}
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|acb
operator|=
name|aic
operator|->
name|nexus_list
operator|.
name|tqh_first
condition|)
block|{
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|aic
operator|->
name|nexus
argument_list|,
name|aic
operator|->
name|nexus
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
block|}
name|aic
operator|->
name|phase
operator|=
name|aic
operator|->
name|prevphase
operator|=
name|PH_INVALID
expr_stmt|;
name|aic
operator|->
name|hp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|7
condition|;
name|r
operator|++
control|)
block|{
name|struct
name|aic_tinfo
modifier|*
name|tp
init|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|r
index|]
decl_stmt|;
name|tp
operator|->
name|flags
operator|=
name|AIC_USE_SYNCHRONOUS
condition|?
name|DO_NEGOTIATE
else|:
literal|0
expr_stmt|;
name|tp
operator|->
name|flags
operator||=
name|NEED_TO_RESET
expr_stmt|;
name|tp
operator|->
name|persgst
operator|=
name|AIC_SYNC_PERIOD
expr_stmt|;
name|tp
operator|->
name|offsgst
operator|=
name|AIC_SYNC_REQ_ACK_OFS
expr_stmt|;
name|tp
operator|->
name|syncdata
operator|=
literal|0
expr_stmt|;
block|}
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * DRIVER FUNCTIONS CALLABLE FROM HIGHER LEVEL DRIVERS  */
end_comment

begin_comment
comment|/*  * Expected sequence:  * 1) Command inserted into ready list  * 2) Command selected for execution  * 3) Command won arbitration and has selected target device  * 4) Send message out (identify message, eventually also sync.negotiations)  * 5) Send command  * 5a) Receive disconnect message, disconnect.  * 5b) Reselected by target  * 5c) Receive identify message from target.  * 6) Send or receive data  * 7) Receive status  * 8) Receive message (command complete etc.)  * 9) If status == SCSI_CHECK construct a synthetic request sense SCSI cmd.  *    Repeat 2-8 (no disconnects please...)  */
end_comment

begin_comment
comment|/*  * Start a SCSI-command  * This function is called by the higher level SCSI-driver to queue/run  * SCSI-commands.  */
end_comment

begin_function
specifier|static
name|int32_t
name|aic_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
name|int
name|s
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|aic
operator|=
operator|(
expr|struct
name|aic_data
operator|*
operator|)
name|sc
operator|->
name|adapter_softc
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"aic_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"[0x%x, %d]->%d "
operator|,
operator|(
name|int
operator|)
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|,
name|xs
operator|->
name|cmdlen
operator|,
name|sc
operator|->
name|target
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
comment|/* Get a aic command block */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
comment|/* Critical region */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|acb
operator|=
name|aic
operator|->
name|free_list
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|acb
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|free_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acb
operator|=
name|aic
operator|->
name|free_list
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|acb
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|free_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acb
operator|==
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"TRY_AGAIN_LATER"
operator|)
argument_list|)
expr_stmt|;
return|return
name|TRY_AGAIN_LATER
return|;
block|}
comment|/* Initialize acb */
name|acb
operator|->
name|flags
operator|=
name|ACB_ACTIVE
expr_stmt|;
name|acb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
operator|&
name|acb
operator|->
name|cmd
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|acb
operator|->
name|clen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|acb
operator|->
name|daddr
operator|=
name|xs
operator|->
name|data
expr_stmt|;
name|acb
operator|->
name|dleft
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|acb
operator|->
name|stat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|xs
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_IDLE
condition|)
name|aic_sched
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
comment|/* Almost done. Wait outside */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"SUCCESSFULLY_QUEUED"
operator|)
argument_list|)
expr_stmt|;
return|return
name|SUCCESSFULLY_QUEUED
return|;
block|}
comment|/* Not allowed to use interrupts, use polling instead */
return|return
name|aic_poll
argument_list|(
name|aic
argument_list|,
name|acb
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust transfer size in buffer structure  */
end_comment

begin_function
specifier|static
name|void
name|aic_minphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_minphys\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
name|AIC_NSEG
operator|<<
name|PAGE_SHIFT
operator|)
condition|)
name|bp
operator|->
name|b_bcount
operator|=
operator|(
name|AIC_NSEG
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|aic_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_adapter_info\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
comment|/* One outstanding command per target */
block|}
end_function

begin_comment
comment|/*  * Used when interrupt driven I/O isn't allowed, e.g. during boot.  */
end_comment

begin_function
specifier|static
name|int
name|aic_poll
parameter_list|(
name|aic
parameter_list|,
name|acb
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|acb
operator|->
name|xs
decl_stmt|;
name|int
name|count
init|=
name|xs
operator|->
name|timeout
operator|*
literal|10
decl_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_poll\n"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
condition|)
name|aicintr
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
break|break;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|AIC_MISC
argument_list|(
operator|(
literal|"aic_poll: timeout"
operator|)
argument_list|)
expr_stmt|;
name|aic_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|acb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|error
condition|)
return|return
name|HAD_ERROR
return|;
return|return
name|COMPLETE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* LOW LEVEL SCSI UTILITIES */
end_comment

begin_comment
comment|/* Determine the SCSI bus phase, return either a real SCSI bus phase or some  * pseudo phase we use to detect certain exceptions.  This one is a bit tricky.  * The bits we peek at:  * CDI, MSGI and DI is the 3 SCSI signals determining the bus phase.  * These should be qualified by REQI high and ACKI low.  * Also peek at SSTAT0[SELDO|SELDI] to detect a passing BUSFREE condition.  * No longer detect SCSI RESET or PERR here.  They are tested for separately  * in the interrupt handler.  * Note: If an exception occur at some critical time during the phase  * determination we'll most likely return something wildly erronous....  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_short
name|aicphase
parameter_list|(
name|aic
parameter_list|)
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
specifier|register
name|u_char
name|sstat0
decl_stmt|,
name|sstat1
decl_stmt|,
name|scsisig
decl_stmt|;
name|sstat1
operator|=
name|inb
argument_list|(
name|SSTAT1
argument_list|)
expr_stmt|;
comment|/* Look for REQINIT (REQ asserted) */
name|scsisig
operator|=
name|inb
argument_list|(
name|SCSISIGI
argument_list|)
expr_stmt|;
comment|/* Get the SCSI bus signals */
name|sstat0
operator|=
name|inb
argument_list|(
name|SSTAT0
argument_list|)
expr_stmt|;
comment|/* Get the selection valid status bits */
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|SSTAT0
argument_list|)
operator|&
operator|(
name|SELDO
operator||
name|SELDI
operator|)
operator|)
condition|)
comment|/* Selection became invalid? */
return|return
name|PH_BUSFREE
return|;
comment|/* Selection is still valid */
if|if
condition|(
operator|!
operator|(
name|sstat1
operator|&
name|REQINIT
operator|)
condition|)
comment|/* REQ not asserted ? */
return|return
name|PH_INVALID
return|;
comment|/* REQ is asserted, (and ACK is not) */
return|return
name|scsisig
operator|&
name|PH_MASK
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Schedule a scsi operation.  This has now been pulled out of the interrupt  * handler so that we may call it from aic_scsi_cmd and aic_done.  This may  * save us an unecessary interrupt just to get things going.  Should only be  * called when state == AIC_IDLE and at bio pl.  */
end_comment

begin_function
specifier|static
name|void
name|aic_sched
parameter_list|(
name|aic
parameter_list|)
specifier|register
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|int
name|t
decl_stmt|;
name|u_char
name|simode0
decl_stmt|,
name|simode1
decl_stmt|,
name|scsiseq
decl_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_sched\n"
operator|)
argument_list|)
expr_stmt|;
name|simode0
operator|=
name|ENSELDI
expr_stmt|;
name|simode1
operator|=
name|ENSCSIRST
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
expr_stmt|;
name|scsiseq
operator|=
name|ENRESELI
expr_stmt|;
comment|/* 	 * Find first acb in rdy queue that is for a target/lunit 	 * combinations that is not busy. 	 */
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRSELTIMO
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|aic
operator|->
name|ready_list
operator|.
name|tqh_first
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|chain
operator|.
name|tqe_next
control|)
block|{
name|sc
operator|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
name|t
operator|=
name|sc
operator|->
name|target
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aic
operator|->
name|tinfo
index|[
name|t
index|]
operator|.
name|lubusy
operator|&
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|acb
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_SELECTING
expr_stmt|;
comment|/* 			 * Start selection process. Always enable 			 * reselections.  Note: we don't have a nexus yet, so 			 * cannot set aic->state = AIC_HASNEXUS. 			 */
name|simode0
operator|=
name|ENSELDI
operator||
name|ENSELDO
expr_stmt|;
name|simode1
operator|=
name|ENSCSIRST
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
operator||
name|ENSELTIMO
expr_stmt|;
name|scsiseq
operator|=
name|ENRESELI
operator||
name|ENSELO
operator||
name|ENAUTOATNO
expr_stmt|;
name|outb
argument_list|(
name|SCSIID
argument_list|,
name|AIC_SCSI_HOSTID
operator|<<
name|OID_S
operator||
name|t
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL1
argument_list|,
name|STIMO_256ms
operator||
name|ENSTIMER
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT0
argument_list|,
name|CLRSELDO
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|AIC_DEBUG
else|else
name|AIC_MISC
argument_list|(
operator|(
literal|"%d:%d busy\n"
operator|,
name|t
operator|,
name|sc
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|AIC_MISC
argument_list|(
operator|(
literal|"%sselecting\n"
operator|,
name|scsiseq
operator|&
name|ENSELO
condition|?
literal|""
else|:
literal|"re"
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE0
argument_list|,
name|simode0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|simode1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
name|scsiseq
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * POST PROCESSING OF SCSI_CMD (usually current)  */
end_comment

begin_function
specifier|static
name|void
name|aic_done
parameter_list|(
name|acb
parameter_list|)
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|acb
operator|->
name|xs
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
init|=
operator|(
expr|struct
name|aic_data
operator|*
operator|)
name|sc
operator|->
name|adapter_softc
decl_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_done "
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now, if we've come here with no error code, i.e. we've kept the 	 * initial XS_NOERROR, and the status code signals that we should 	 * check sense, we'll need to set up a request sense cmd block and 	 * push the command back into the ready queue *before* any other 	 * commands for this target/lunit, else we lose the sense info. 	 * We don't support chk sense conditions for the request sense cmd. 	 */
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|&&
operator|!
operator|(
name|acb
operator|->
name|flags
operator|&
name|ACB_CHKSENSE
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|acb
operator|->
name|stat
operator|&
name|ST_MASK
operator|)
operator|==
name|SCSI_CHECK
condition|)
block|{
name|struct
name|scsi_sense
modifier|*
name|ss
init|=
operator|(
name|void
operator|*
operator|)
operator|&
name|acb
operator|->
name|cmd
decl_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"requesting sense "
operator|)
argument_list|)
expr_stmt|;
comment|/* First, save the return values */
name|xs
operator|->
name|resid
operator|=
name|acb
operator|->
name|dleft
expr_stmt|;
name|xs
operator|->
name|status
operator|=
name|acb
operator|->
name|stat
expr_stmt|;
comment|/* Next, setup a request sense command block */
name|bzero
argument_list|(
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|ss
operator|->
name|byte2
operator|=
name|sc
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|ss
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|acb
operator|->
name|clen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ss
argument_list|)
expr_stmt|;
name|acb
operator|->
name|daddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xs
operator|->
name|sense
expr_stmt|;
name|acb
operator|->
name|dleft
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|acb
operator|->
name|flags
operator|=
name|ACB_ACTIVE
operator||
name|ACB_CHKSENSE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|senses
operator|++
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|nexus
operator|==
name|acb
condition|)
block|{
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic_sched
argument_list|(
name|aic
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|&&
operator|(
name|acb
operator|->
name|flags
operator|&
name|ACB_CHKSENSE
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|resid
operator|=
name|acb
operator|->
name|dleft
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
if|#
directive|if
name|AIC_DEBUG
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"err=0x%02x "
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
condition|)
name|printf
argument_list|(
literal|"sense=%2x\n"
argument_list|,
name|xs
operator|->
name|sense
operator|.
name|error_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|xs
operator|->
name|resid
operator|||
name|xs
operator|->
name|error
operator|>
name|XS_SENSE
operator|)
operator|&&
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|resid
condition|)
name|printf
argument_list|(
literal|"aic_done: resid=%d\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
condition|)
name|printf
argument_list|(
literal|"aic_done: error=%d\n"
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Remove the ACB from whatever queue it's on.  We have to do a bit of 	 * a hack to figure out which queue it's on.  Note that it is *not* 	 * necessary to cdr down the ready queue, but we must cdr down the 	 * nexus queue and see if it's there, so we can mark the unit as no 	 * longer busy.  This code is sickening, but it works. 	 */
if|if
condition|(
name|acb
operator|==
name|aic
operator|->
name|nexus
condition|)
block|{
if|#
directive|if
name|NAPM
operator|>
literal|0
operator|&&
name|NCARD
operator|>
literal|0
comment|/* SlimSCSI dies without this when it resumes from suspend */
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
expr_stmt|;
name|aic_sched
argument_list|(
name|aic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aic
operator|->
name|ready_list
operator|.
name|tqh_last
operator|==
operator|&
name|acb
operator|->
name|chain
operator|.
name|tqe_next
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|acb
modifier|*
name|acb2
decl_stmt|;
for|for
control|(
name|acb2
operator|=
name|aic
operator|->
name|nexus_list
operator|.
name|tqh_first
init|;
name|acb2
condition|;
name|acb2
operator|=
name|acb2
operator|->
name|chain
operator|.
name|tqe_next
control|)
if|if
condition|(
name|acb2
operator|==
name|acb
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|nexus_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|lubusy
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
expr_stmt|;
comment|/* XXXX Should we call aic_sched() here? */
break|break;
block|}
if|if
condition|(
name|acb2
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|acb
operator|->
name|chain
operator|.
name|tqe_next
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"aic%d: can't find matching acb\n"
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Put it on the free list. */
name|acb
operator|->
name|flags
operator|=
name|ACB_FREE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aic
operator|->
name|free_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|cmds
operator|++
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * INTERRUPT/PROTOCOL ENGINE  */
end_comment

begin_comment
comment|/* The message system:  * This is a revamped message system that now should easier accomodate new  * messages, if necessary.  * Currently we accept these messages:  * IDENTIFY (when reselecting)  * COMMAND COMPLETE # (expect bus free after messages marked #)  * NOOP  * MESSAGE REJECT  * SYNCHRONOUS DATA TRANSFER REQUEST  * SAVE DATA POINTER  * RESTORE POINTERS  * DISCONNECT #  *  * We may send these messages in prioritized order:  * BUS DEVICE RESET #		if SCSI_RESET& xs->flags (or in weird sits.)  * MESSAGE PARITY ERROR		par. err. during MSGI  * MESSAGE REJECT		If we get a message we don't know how to handle  * ABORT #			send on errors  * INITIATOR DETECTED ERROR	also on errors (SCSI2) (during info xfer)  * IDENTIFY			At the start of each transfer  * SYNCHRONOUS DATA TRANSFER REQUEST	if appropriate  * NOOP				if nothing else fits the bill ...  */
end_comment

begin_define
define|#
directive|define
name|aic_sched_msgout
parameter_list|(
name|m
parameter_list|)
define|\
value|do {				\ 		orreg(SCSISIGO, ATNO);	\ 		aic->msgpriq |= (m);	\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|IS1BYTEMSG
parameter_list|(
name|m
parameter_list|)
value|(((m) != 1&& (m)< 0x20) || (m)>= 0x80)
end_define

begin_define
define|#
directive|define
name|IS2BYTEMSG
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0xf0) == 0x20)
end_define

begin_define
define|#
directive|define
name|ISEXTMSG
parameter_list|(
name|m
parameter_list|)
value|((m) == 1)
end_define

begin_comment
comment|/* Precondition:  * The SCSI bus is already in the MSGI phase and there is a message byte  * on the bus, along with an asserted REQ signal.  */
end_comment

begin_function
specifier|static
name|void
name|aic_msgin
parameter_list|(
name|aic
parameter_list|)
specifier|register
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|int
name|spincount
decl_stmt|,
name|extlen
decl_stmt|;
name|u_char
name|sstat1
decl_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aic_msgin "
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_MSGI
argument_list|)
expr_stmt|;
comment|/* Prepare for a new message.  A message should (according to the SCSI 	 * standard) be transmitted in one single message_in phase. 	 * If we have been in some other phase, then this is a new message. 	 */
if|if
condition|(
name|aic
operator|->
name|prevphase
operator|!=
name|PH_MSGI
condition|)
block|{
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_DROP_MSGI
expr_stmt|;
name|aic
operator|->
name|imlen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Read a whole message but the last byte.  If we shall reject the 	 * message, we shall have to do it, by asserting ATNO, during the 	 * message transfer phase itself. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|sstat1
operator|=
name|inb
argument_list|(
name|SSTAT1
argument_list|)
expr_stmt|;
comment|/* If parity errors just dump everything on the floor, also 		 * a parity error automatically sets ATNO 		 */
if|if
condition|(
name|sstat1
operator|&
name|SCSIPERR
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|SEND_PARITY_ERROR
argument_list|)
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_DROP_MSGI
expr_stmt|;
block|}
comment|/* 		 * If we're going to reject the message, don't bother storing 		 * the incoming bytes.  But still, we need to ACK them. 		 */
if|if
condition|(
operator|!
operator|(
name|aic
operator|->
name|flags
operator|&
name|AIC_DROP_MSGI
operator|)
condition|)
block|{
comment|/* Get next message byte */
name|aic
operator|->
name|imess
index|[
name|aic
operator|->
name|imlen
index|]
operator|=
name|inb
argument_list|(
name|SCSIDAT
argument_list|)
expr_stmt|;
comment|/* 			 * This testing is suboptimal, but most messages will 			 * be of the one byte variety, so it should not effect 			 * performance significantly. 			 */
if|if
condition|(
name|IS1BYTEMSG
argument_list|(
name|aic
operator|->
name|imess
index|[
literal|0
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|IS2BYTEMSG
argument_list|(
name|aic
operator|->
name|imess
index|[
literal|0
index|]
argument_list|)
operator|&&
name|aic
operator|->
name|imlen
operator|==
literal|1
condition|)
break|break;
if|if
condition|(
name|ISEXTMSG
argument_list|(
name|aic
operator|->
name|imess
index|[
literal|0
index|]
argument_list|)
operator|&&
name|aic
operator|->
name|imlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|aic
operator|->
name|imlen
operator|==
name|AIC_MAX_MSG_LEN
condition|)
block|{
name|aic
operator|->
name|flags
operator||=
name|AIC_DROP_MSGI
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
block|}
name|extlen
operator|=
name|aic
operator|->
name|imess
index|[
literal|1
index|]
condition|?
name|aic
operator|->
name|imess
index|[
literal|1
index|]
else|:
literal|256
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|imlen
operator|==
name|extlen
operator|+
literal|2
condition|)
break|break;
comment|/* Got it all */
block|}
block|}
comment|/* If we reach this spot we're either: 		 * a) in the middle of a multi-byte message or 		 * b) we're dropping bytes 		 */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|SCSIDAT
argument_list|)
expr_stmt|;
comment|/* Really read it (ACK it, that is) */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|aic
operator|->
name|imlen
operator|++
expr_stmt|;
comment|/* 		 * We expect the bytes in a multibyte message to arrive 		 * relatively close in time, a few microseconds apart. 		 * Therefore we will spinwait for some small amount of time 		 * waiting for the next byte. 		 */
name|spincount
operator|=
name|DELAYCOUNT
operator|*
name|AIC_MSGI_SPIN
expr_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
while|while
condition|(
name|spincount
operator|--
operator|&&
operator|!
operator|(
operator|(
name|sstat1
operator|=
name|inb
argument_list|(
name|SSTAT1
argument_list|)
operator|)
operator|&
name|REQINIT
operator|)
condition|)
empty_stmt|;
if|if
condition|(
name|spincount
operator|==
operator|-
literal|1
operator|||
name|sstat1
operator|&
operator|(
name|PHASEMIS
operator||
name|BUSFREE
operator|)
condition|)
return|return;
block|}
comment|/* Now we should have a complete message (1 byte, 2 byte and moderately 	 * long extended messages).  We only handle extended messages which 	 * total length is shorter than AIC_MAX_MSG_LEN.  Longer messages will 	 * be amputated.  (Return XS_BOBBITT ?) 	 */
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_HASNEXUS
condition|)
block|{
name|struct
name|acb
modifier|*
name|acb
init|=
name|aic
operator|->
name|nexus
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
init|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
decl_stmt|;
name|int
name|offs
decl_stmt|,
name|per
decl_stmt|,
name|rate
decl_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|aic
operator|->
name|imess
index|[
literal|0
index|]
condition|)
block|{
case|case
name|MSG_CMDCOMPLETE
case|:
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic: CMDCOMPLETE but no command?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aic
operator|->
name|dleft
operator|<
literal|0
condition|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc
init|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
decl_stmt|;
name|printf
argument_list|(
literal|"aic: %d extra bytes from %d:%d\n"
argument_list|,
operator|-
name|aic
operator|->
name|dleft
argument_list|,
name|sc
operator|->
name|target
argument_list|,
name|sc
operator|->
name|lun
argument_list|)
expr_stmt|;
name|acb
operator|->
name|dleft
operator|=
literal|0
expr_stmt|;
block|}
name|acb
operator|->
name|xs
operator|->
name|resid
operator|=
name|acb
operator|->
name|dleft
operator|=
name|aic
operator|->
name|dleft
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
name|acb
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_MESSAGE_REJECT
case|:
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"aic: our msg rejected by target\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_SYNCHNEGO
condition|)
block|{
name|ti
operator|->
name|syncdata
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|persgst
operator|=
name|ti
operator|->
name|offsgst
operator|=
literal|0
expr_stmt|;
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_SYNCHNEGO
expr_stmt|;
name|ti
operator|->
name|flags
operator|&=
operator|~
name|DO_NEGOTIATE
expr_stmt|;
block|}
comment|/* Not all targets understand INITIATOR_DETECTED_ERR */
if|if
condition|(
name|aic
operator|->
name|msgout
operator|==
name|SEND_INIT_DET_ERR
condition|)
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_NOOP
case|:
comment|/* Will do! Immediately, sir!*/
break|break;
comment|/* Hah, that was easy! */
case|case
name|MSG_DISCONNECT
case|:
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic: nothing to DISCONNECT\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ti
operator|->
name|dconns
operator|++
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aic
operator|->
name|nexus_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|acb
operator|=
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
break|break;
case|case
name|MSG_SAVEDATAPOINTER
case|:
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic: no DATAPOINTERs to save\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|acb
operator|->
name|dleft
operator|=
name|aic
operator|->
name|dleft
expr_stmt|;
name|acb
operator|->
name|daddr
operator|=
name|aic
operator|->
name|dp
expr_stmt|;
break|break;
case|case
name|MSG_RESTOREPOINTERS
case|:
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic: no DATAPOINTERs to restore\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|aic
operator|->
name|dp
operator|=
name|acb
operator|->
name|daddr
expr_stmt|;
name|aic
operator|->
name|dleft
operator|=
name|acb
operator|->
name|dleft
expr_stmt|;
break|break;
case|case
name|MSG_EXTENDED
case|:
switch|switch
condition|(
name|aic
operator|->
name|imess
index|[
literal|2
index|]
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
name|per
operator|=
name|aic
operator|->
name|imess
index|[
literal|3
index|]
operator|*
literal|4
expr_stmt|;
name|rate
operator|=
operator|(
name|per
operator|+
literal|49
operator|-
literal|100
operator|)
operator|/
literal|50
expr_stmt|;
name|offs
operator|=
name|aic
operator|->
name|imess
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|offs
operator|==
literal|0
condition|)
name|ti
operator|->
name|syncdata
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|rate
operator|>
literal|7
condition|)
block|{
comment|/* Too slow for aic6360. Do asynch 					 * instead.  Renegotiate the deal. 					 */
name|ti
operator|->
name|persgst
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|offsgst
operator|=
literal|0
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rate
operator|=
name|rate
operator|<<
literal|4
operator||
name|offs
expr_stmt|;
name|ti
operator|->
name|syncdata
operator|=
name|rate
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Extended messages we don't handle */
name|aic_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|aic_sched_msgout
argument_list|(
name|SEND_REJECT
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_RESELECTED
condition|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
name|u_char
name|selid
decl_stmt|,
name|lunit
decl_stmt|;
comment|/* 		 * Which target is reselecting us? (The ID bit really) 		 */
name|selid
operator|=
name|inb
argument_list|(
name|SELID
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|AIC_SCSI_HOSTID
operator|)
expr_stmt|;
if|if
condition|(
name|MSG_ISIDENT
argument_list|(
name|aic
operator|->
name|imess
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* Identify? */
name|AIC_MISC
argument_list|(
operator|(
literal|"searching "
operator|)
argument_list|)
expr_stmt|;
comment|/* Search wait queue for disconnected cmd 			 * The list should be short, so I haven't bothered with 			 * any more sophisticated structures than a simple 			 * singly linked list. 			 */
name|lunit
operator|=
name|aic
operator|->
name|imess
index|[
literal|0
index|]
operator|&
literal|0x07
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|aic
operator|->
name|nexus_list
operator|.
name|tqh_first
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|chain
operator|.
name|tqe_next
control|)
block|{
name|sc
operator|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lun
operator|==
name|lunit
operator|&&
name|selid
operator|==
operator|(
literal|1
operator|<<
name|sc
operator|->
name|target
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|aic
operator|->
name|nexus_list
argument_list|,
name|acb
argument_list|,
name|chain
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|acb
condition|)
block|{
comment|/* Invalid reselection! */
name|aic_sched_msgout
argument_list|(
name|SEND_ABORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"aic: invalid reselect (idbit=0x%2x)\n"
argument_list|,
name|selid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Reestablish nexus */
comment|/* Setup driver data structures and 				 * do an implicit RESTORE POINTERS 				 */
name|aic
operator|->
name|nexus
operator|=
name|acb
expr_stmt|;
name|aic
operator|->
name|dp
operator|=
name|acb
operator|->
name|daddr
expr_stmt|;
name|aic
operator|->
name|dleft
operator|=
name|acb
operator|->
name|dleft
expr_stmt|;
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|lubusy
operator||=
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
argument_list|,
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
operator|.
name|syncdata
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"... found acb"
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_HASNEXUS
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"aic: bogus reselect (no IDENTIFY) %0x2x\n"
argument_list|,
name|selid
argument_list|)
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Neither AIC_HASNEXUS nor AIC_RESELECTED! */
name|printf
argument_list|(
literal|"aic: unexpected message in; will send DEV_RESET\n"
argument_list|)
expr_stmt|;
name|aic_sched_msgout
argument_list|(
name|SEND_DEV_RESET
argument_list|)
expr_stmt|;
block|}
comment|/* Must not forget to ACK the last message byte ... */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|SCSIDAT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The message out (and in) stuff is a bit complicated:  * If the target requests another message (sequence) without  * having changed phase in between it really asks for a  * retransmit, probably due to parity error(s).  * The following messages can be sent:  * IDENTIFY	   @ These 3 stems from scsi command activity  * BUS_DEV_RESET   @  * IDENTIFY + SDTR @  * MESSAGE_REJECT if MSGI doesn't make sense  * MESSAGE_PARITY_ERROR if MSGI spots a parity error  * NOOP if asked for a message and there's nothing to send  */
end_comment

begin_function
specifier|static
name|void
name|aic_msgout
parameter_list|(
name|aic
parameter_list|)
specifier|register
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
comment|/* First determine what to send. If we haven't seen a 	 * phasechange this is a retransmission request. 	 */
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_MSGO
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|prevphase
operator|!=
name|PH_MSGO
condition|)
block|{
comment|/* NOT a retransmit */
comment|/* Pick up highest priority message */
name|aic
operator|->
name|msgout
operator|=
name|aic
operator|->
name|msgpriq
operator|&
operator|-
name|aic
operator|->
name|msgpriq
expr_stmt|;
comment|/* What message? */
name|aic
operator|->
name|omlen
operator|=
literal|1
expr_stmt|;
comment|/* "Default" message len */
switch|switch
condition|(
name|aic
operator|->
name|msgout
condition|)
block|{
case|case
name|SEND_SDTR
case|:
comment|/* Also implies an IDENTIFY message */
name|acb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
index|]
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|1
index|]
operator|=
name|MSG_EXTENDED
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|3
index|]
operator|=
name|MSG_EXT_SDTR
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|4
index|]
operator|=
name|ti
operator|->
name|persgst
operator|>>
literal|2
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|5
index|]
operator|=
name|ti
operator|->
name|offsgst
expr_stmt|;
name|aic
operator|->
name|omlen
operator|=
literal|6
expr_stmt|;
comment|/* Fallthrough! */
case|case
name|SEND_IDENTIFY
case|:
if|if
condition|(
name|aic
operator|->
name|state
operator|!=
name|AIC_HASNEXUS
condition|)
block|{
name|printf
argument_list|(
literal|"aic at line %d: no nexus"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
name|acb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_IDENTIFY
argument_list|(
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_DEV_RESET
case|:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_BUS_DEV_RESET
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
break|break;
case|case
name|SEND_PARITY_ERROR
case|:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_PARITY_ERR
expr_stmt|;
break|break;
case|case
name|SEND_ABORT
case|:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_ABORT
expr_stmt|;
name|aic
operator|->
name|flags
operator||=
name|AIC_BUSFREE_OK
expr_stmt|;
break|break;
case|case
name|SEND_INIT_DET_ERR
case|:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|SEND_REJECT
case|:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_MESSAGE_REJECT
expr_stmt|;
break|break;
default|default:
name|aic
operator|->
name|omess
index|[
literal|0
index|]
operator|=
name|MSG_NOOP
expr_stmt|;
break|break;
block|}
name|aic
operator|->
expr|omp
operator|=
name|aic
operator|->
name|omess
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aic
operator|->
expr|omp
operator|==
operator|&
name|aic
operator|->
name|omess
index|[
name|aic
operator|->
name|omlen
index|]
condition|)
block|{
comment|/* Have sent the message at least once, this is a retransmit. 		 */
name|AIC_MISC
argument_list|(
operator|(
literal|"retransmitting "
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|omlen
operator|>
literal|1
condition|)
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_MSGO
operator||
name|ATNO
argument_list|)
expr_stmt|;
block|}
comment|/* else, we're in the middle of a multi-byte message */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
operator||
name|RSTFIFO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
do|do
block|{
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
do|do
block|{
name|aic
operator|->
name|phase
operator|=
name|aicphase
argument_list|(
name|aic
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|aic
operator|->
name|phase
operator|==
name|PH_INVALID
condition|)
do|;
if|if
condition|(
name|aic
operator|->
name|phase
operator|!=
name|PH_MSGO
condition|)
comment|/* Target left MSGO, possibly to reject our 			 * message 			 */
break|break;
comment|/* Clear ATN before last byte */
if|if
condition|(
name|aic
operator|->
expr|omp
operator|==
operator|&
name|aic
operator|->
name|omess
index|[
name|aic
operator|->
name|omlen
operator|-
literal|1
index|]
condition|)
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRATNO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIDAT
argument_list|,
operator|*
name|aic
operator|->
expr|omp
operator|++
argument_list|)
expr_stmt|;
comment|/* Send MSG */
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|SCSISIGI
argument_list|)
operator|&
name|ACKO
condition|)
empty_stmt|;
block|}
do|while
condition|(
name|aic
operator|->
expr|omp
operator|!=
operator|&
name|aic
operator|->
name|omess
index|[
name|aic
operator|->
name|omlen
index|]
condition|)
do|;
name|aic
operator|->
name|progress
operator|=
name|aic
operator|->
expr|omp
operator|!=
name|aic
operator|->
name|omess
expr_stmt|;
comment|/* We get here in two ways: 	 * a) phase != MSGO.  Target is probably going to reject our message 	 * b) aic->omp ==&aic->omess[aic->omlen], i.e. the message has been 	 *    transmitted correctly and accepted by the target. 	 */
if|if
condition|(
name|aic
operator|->
name|phase
operator|==
name|PH_MSGO
condition|)
block|{
comment|/* Message accepted by target! */
name|aic
operator|->
name|msgpriq
operator|&=
operator|~
name|aic
operator|->
name|msgout
expr_stmt|;
name|aic
operator|->
name|msgout
operator|=
literal|0
expr_stmt|;
block|}
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
comment|/* Disable SPIO */
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup interrupts before leaving */
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Enabled ints: SCSIPERR, SCSIRSTI (unexpected) 	 * 		 REQINIT (expected) BUSFREE (possibly expected) 	 */
block|}
end_function

begin_comment
comment|/* aic_dataout: perform a data transfer using the FIFO datapath in the aic6360  * Precondition: The SCSI bus should be in the DOUT phase, with REQ asserted  * and ACK deasserted (i.e. waiting for a data byte)  * This new revision has been optimized (I tried) to make the common case fast,  * and the rarer cases (as a result) somewhat more comlex  */
end_comment

begin_function
specifier|static
name|void
name|aic_dataout
parameter_list|(
name|aic
parameter_list|)
specifier|register
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
specifier|register
name|u_char
name|dmastat
decl_stmt|;
name|int
name|amount
decl_stmt|,
name|olddleft
init|=
name|aic
operator|->
name|dleft
decl_stmt|;
define|#
directive|define
name|DOUTAMOUNT
value|128
comment|/* Full FIFO */
comment|/* Enable DATA OUT transfers */
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_DOUT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRPHASECHG
argument_list|)
expr_stmt|;
comment|/* Clear FIFOs and counters */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRSTCNT
operator||
name|CLRCH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|WRITE
operator||
name|INTEN
operator||
name|RSTFIFO
argument_list|)
expr_stmt|;
comment|/* Enable FIFOs */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|DWORDPIO
operator||
name|WRITE
operator||
name|INTEN
argument_list|)
expr_stmt|;
comment|/* Setup to detect: 	 * PHASEMIS& PHASECHG: target has left the DOUT phase 	 * SCSIRST: something just pulled the RST line. 	 * BUSFREE: target has unexpectedly left the DOUT phase 	 */
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENPHASEMIS
operator||
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENPHASECHG
argument_list|)
expr_stmt|;
comment|/* I have tried to make the main loop as tight as possible.  This 	 * means that some of the code following the loop is a bit more 	 * complex than otherwise. 	 */
while|while
condition|(
name|aic
operator|->
name|dleft
condition|)
block|{
name|int
name|xfer
decl_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dmastat
operator|=
name|inb
argument_list|(
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
name|DFIFOEMP
condition|)
break|break;
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
goto|goto
name|phasechange
goto|;
block|}
name|xfer
operator|=
name|min
argument_list|(
name|DOUTAMOUNT
argument_list|,
name|aic
operator|->
name|dleft
argument_list|)
expr_stmt|;
if|#
directive|if
name|AIC_USE_DWORDS
if|if
condition|(
name|xfer
operator|>=
literal|12
condition|)
block|{
name|outsl
argument_list|(
name|DMADATALONG
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
operator|/
literal|4
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
operator|&
operator|~
literal|3
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
operator|&
operator|~
literal|3
expr_stmt|;
name|xfer
operator|&=
literal|3
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|xfer
operator|>=
literal|8
condition|)
block|{
name|outsw
argument_list|(
name|DMADATA
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
operator|/
literal|2
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
operator|&
operator|~
literal|1
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
operator|&
operator|~
literal|1
expr_stmt|;
name|xfer
operator|&=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
condition|)
block|{
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|B8MODE
operator||
name|INTEN
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|DMADATA
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|DWORDPIO
operator||
name|INTEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See the bytes off chip */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dmastat
operator|=
name|inb
argument_list|(
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmastat
operator|&
name|DFIFOEMP
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|SSTAT2
argument_list|)
operator|&
name|SEMPTY
operator|)
condition|)
break|break;
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
goto|goto
name|phasechange
goto|;
block|}
name|phasechange
label|:
comment|/* We now have the data off chip.  */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
name|INTSTAT
condition|)
block|{
comment|/* Some sort of phasechange */
specifier|register
name|u_char
name|sstat2
decl_stmt|;
comment|/* Stop transfers, do some accounting */
name|amount
operator|=
name|inb
argument_list|(
name|FIFOSTAT
argument_list|)
expr_stmt|;
name|sstat2
operator|=
name|inb
argument_list|(
name|SSTAT2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sstat2
operator|&
literal|7
operator|)
operator|==
literal|0
condition|)
name|amount
operator|+=
name|sstat2
operator|&
name|SFULL
condition|?
literal|8
else|:
literal|0
expr_stmt|;
else|else
name|amount
operator|+=
name|sstat2
operator|&
literal|7
expr_stmt|;
name|aic
operator|->
name|dleft
operator|+=
name|amount
expr_stmt|;
name|aic
operator|->
name|dp
operator|-=
name|amount
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"+%d "
operator|,
name|amount
operator|)
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|RSTFIFO
operator||
name|INTEN
argument_list|)
expr_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
name|SXFRCTL0
argument_list|)
operator|&
name|SCSIEN
condition|)
empty_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Enabled ints: BUSFREE, SCSIPERR, SCSIRSTI (unexpected) 	 * 		 REQINIT (expected) 	 */
name|aic
operator|->
name|progress
operator|=
name|olddleft
operator|!=
name|aic
operator|->
name|dleft
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* aic_datain: perform data transfers using the FIFO datapath in the aic6360  * Precondition: The SCSI bus should be in the DIN phase, with REQ asserted  * and ACK deasserted (i.e. at least one byte is ready).  * For now, uses a pretty dumb algorithm, hangs around until all data has been  * transferred.  This, is OK for fast targets, but not so smart for slow  * targets which don't disconnect or for huge transfers.  */
end_comment

begin_function
specifier|static
name|void
name|aic_datain
parameter_list|(
name|aic
parameter_list|)
specifier|register
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
block|{
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
specifier|register
name|u_char
name|dmastat
decl_stmt|;
name|int
name|olddleft
init|=
name|aic
operator|->
name|dleft
decl_stmt|;
define|#
directive|define
name|DINAMOUNT
value|128
comment|/* Default amount of data to transfer */
comment|/* Enable DATA IN transfers */
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_DIN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRPHASECHG
argument_list|)
expr_stmt|;
comment|/* Clear FIFOs and counters */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRSTCNT
operator||
name|CLRCH
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
operator||
name|RSTFIFO
argument_list|)
expr_stmt|;
comment|/* Enable FIFOs */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|DWORDPIO
operator||
name|INTEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
operator||
name|ENPHASECHG
argument_list|)
expr_stmt|;
comment|/* We leave this loop if one or more of the following is true: 	 * a) phase != PH_DIN&& FIFOs are empty 	 * b) SCSIRSTI is set (a reset has occurred) or busfree is detected. 	 */
while|while
condition|(
name|aic
operator|->
name|dleft
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|xfer
decl_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Wait for fifo half full or phase mismatch */
for|for
control|(
init|;
condition|;
control|)
block|{
name|dmastat
operator|=
name|inb
argument_list|(
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
operator|(
name|DFIFOFULL
operator||
name|INTSTAT
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|dmastat
operator|&
name|DFIFOFULL
condition|)
name|xfer
operator|=
name|DINAMOUNT
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|SSTAT2
argument_list|)
operator|&
name|SEMPTY
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|xfer
operator|=
name|inb
argument_list|(
name|FIFOSTAT
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
name|xfer
operator|=
name|min
argument_list|(
name|xfer
argument_list|,
name|aic
operator|->
name|dleft
argument_list|)
expr_stmt|;
if|#
directive|if
name|AIC_USE_DWORDS
if|if
condition|(
name|xfer
operator|>=
literal|12
condition|)
block|{
name|insl
argument_list|(
name|DMADATALONG
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
operator|/
literal|4
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
operator|&
operator|~
literal|3
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
operator|&
operator|~
literal|3
expr_stmt|;
name|xfer
operator|&=
literal|3
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|xfer
operator|>=
literal|8
condition|)
block|{
name|insw
argument_list|(
name|DMADATA
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
operator|/
literal|2
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
operator|&
operator|~
literal|1
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
operator|&
operator|~
literal|1
expr_stmt|;
name|xfer
operator|&=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|xfer
condition|)
block|{
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|B8MODE
operator||
name|INTEN
argument_list|)
expr_stmt|;
name|insb
argument_list|(
name|DMADATA
argument_list|,
name|aic
operator|->
name|dp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|aic
operator|->
name|dleft
operator|-=
name|xfer
expr_stmt|;
name|aic
operator|->
name|dp
operator|+=
name|xfer
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|DWORDPIO
operator||
name|INTEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
block|}
if|#
directive|if
literal|0
block|if (aic->dleft) 		printf("residual of %d\n", aic->dleft);
endif|#
directive|endif
name|aic
operator|->
name|progress
operator|=
name|olddleft
operator|!=
name|aic
operator|->
name|dleft
expr_stmt|;
comment|/* Some SCSI-devices are rude enough to transfer more data than what 	 * was requested, e.g. 2048 bytes from a CD-ROM instead of the 	 * requested 512.  Test for progress, i.e. real transfers.  If no real 	 * transfers have been performed (acb->dleft is probably already zero) 	 * and the FIFO is not empty, waste some bytes.... 	 */
if|if
condition|(
operator|!
name|aic
operator|->
name|progress
condition|)
block|{
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dmastat
operator|=
name|inb
argument_list|(
name|DMASTAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmastat
operator|&
name|DFIFOEMP
condition|)
break|break;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|DMADATA
argument_list|)
expr_stmt|;
comment|/* Throw it away */
name|extra
operator|++
expr_stmt|;
block|}
name|AIC_MISC
argument_list|(
operator|(
literal|"aic: %d extra bytes from %d:%d\n"
operator|,
name|extra
operator|,
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|,
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|)
argument_list|)
expr_stmt|;
name|aic
operator|->
name|progress
operator|=
name|extra
expr_stmt|;
block|}
comment|/* Stop the FIFO data path */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|RSTFIFO
operator||
name|INTEN
argument_list|)
expr_stmt|;
comment|/* Come back when REQ is set again */
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the workhorse routine of the driver.  * Deficiencies (for now):  * 1) always uses programmed I/O  * 2) doesn't support synchronous transfers properly (yet)  */
end_comment

begin_function
name|void
name|aicintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|aic_data
modifier|*
name|aic
init|=
name|aicdata
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
specifier|register
name|struct
name|scsi_link
modifier|*
name|sc
decl_stmt|;
specifier|register
name|u_short
name|iobase
init|=
name|aic
operator|->
name|iobase
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|u_char
name|sstat0
decl_stmt|,
name|sstat1
decl_stmt|,
name|sstat2
decl_stmt|,
name|sxfrctl0
decl_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Clear INTEN.  This is important if we're running with edge 	 * triggered interrupts as we don't guarantee that all interrupts will 	 * be served during one single invocation of this routine, i.e. we may 	 * need another edge. 	 */
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AIC_TRACE
argument_list|(
operator|(
literal|"aicintr\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * 1st check for abnormal conditions, such as reset or parity errors 	 */
name|sstat1
operator|=
name|inb
argument_list|(
name|SSTAT1
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"s1:0x%02x "
operator|,
name|sstat1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstat1
operator|&
operator|(
name|SCSIRSTI
operator||
name|SCSIPERR
operator|)
condition|)
block|{
if|if
condition|(
name|sstat1
operator|&
name|SCSIRSTI
condition|)
block|{
name|printf
argument_list|(
literal|"aic: reset in -- reinitializing....\n"
argument_list|)
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Restart everything */
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"aic: SCSI bus parity error\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|prevphase
operator|==
name|PH_MSGI
condition|)
name|aic_sched_msgout
argument_list|(
name|SEND_PARITY_ERROR
argument_list|)
expr_stmt|;
else|else
name|aic_sched_msgout
argument_list|(
name|SEND_INIT_DET_ERR
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we're not already busy doing something test for the following 	 * conditions: 	 * 1) We have been reselected by something 	 * 2) We have selected something successfully 	 * 3) Our selection process has timed out 	 * 4) This is really a bus free interrupt just to get a new command 	 *    going? 	 * 5) Spurious interrupt? 	 */
name|sstat0
operator|=
name|inb
argument_list|(
name|SSTAT0
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"s0:0x%02x "
operator|,
name|sstat0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|state
operator|!=
name|AIC_HASNEXUS
condition|)
block|{
comment|/* No nexus yet */
if|if
condition|(
name|sstat0
operator|&
name|SELDI
condition|)
block|{
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* We have been reselected. Things to do: 			 * a) If we're trying to select something ourselves 			 *    back off the current command. 			 * b) "Wait" for a message in phase (IDENTIFY) 			 * c) Call aic_msgin() to get the identify message and 			 *    retrieve the disconnected command from the wait 			 *    queue. 			 */
name|AIC_MISC
argument_list|(
operator|(
literal|"reselect "
operator|)
argument_list|)
expr_stmt|;
comment|/* If we're trying to select a target ourselves, 			 * push our command back into the rdy list. 			 */
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_SELECTING
condition|)
block|{
name|AIC_MISC
argument_list|(
operator|(
literal|"backoff selector "
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|aic
operator|->
name|ready_list
argument_list|,
name|aic
operator|->
name|nexus
argument_list|,
name|chain
argument_list|)
expr_stmt|;
name|aic
operator|->
name|nexus
operator|=
name|NULL
expr_stmt|;
block|}
name|aic
operator|->
name|state
operator|=
name|AIC_RESELECTED
expr_stmt|;
comment|/* Clear interrupts, disable future selection stuff 			 * including select interrupts and timeouts 			 */
name|outb
argument_list|(
name|CLRSINT0
argument_list|,
name|CLRSELDI
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup chip so we may detect spurious busfree 			 * conditions later. 			 */
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Now, we're expecting an IDENTIFY message. */
name|aic
operator|->
name|phase
operator|=
name|aicphase
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|phase
operator|&
name|PH_PSBIT
condition|)
block|{
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
comment|/* Come back when REQ is set */
block|}
if|if
condition|(
name|aic
operator|->
name|phase
operator|==
name|PH_MSGI
condition|)
name|aic_msgin
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* Handle identify message */
else|else
block|{
comment|/* Things are seriously fucked up. 				 * Pull the brakes, i.e. RST 				 */
name|printf
argument_list|(
literal|"aic at line %d: target didn't identify\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|aic
operator|->
name|state
operator|!=
name|AIC_HASNEXUS
condition|)
block|{
comment|/* IDENTIFY fail?! */
name|printf
argument_list|(
literal|"aic at line %d: identify failed\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Fallthrough to HASNEXUS part of aicintr */
block|}
block|}
elseif|else
if|if
condition|(
name|sstat0
operator|&
name|SELDO
condition|)
block|{
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
comment|/* We have selected a target. Things to do: 			 * a) Determine what message(s) to send. 			 * b) Verify that we're still selecting the target. 			 * c) Mark device as busy. 			 */
name|acb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|printf
argument_list|(
literal|"aic at line %d: missing acb"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
name|sc
operator|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
expr_stmt|;
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|sc
operator|->
name|target
index|]
expr_stmt|;
if|if
condition|(
name|acb
operator|->
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
condition|)
name|aic
operator|->
name|msgpriq
operator|=
name|SEND_DEV_RESET
expr_stmt|;
elseif|else
if|if
condition|(
name|ti
operator|->
name|flags
operator|&
name|DO_NEGOTIATE
condition|)
name|aic
operator|->
name|msgpriq
operator|=
name|SEND_IDENTIFY
operator||
name|SEND_SDTR
expr_stmt|;
else|else
name|aic
operator|->
name|msgpriq
operator|=
name|SEND_IDENTIFY
expr_stmt|;
comment|/* Setup chip to enable later testing for busfree 			 * conditions 			 */
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Stop selection stuff */
name|nandreg
argument_list|(
name|SIMODE0
argument_list|,
name|ENSELDO
argument_list|)
expr_stmt|;
comment|/* No more selectout ints */
name|sstat0
operator|=
name|inb
argument_list|(
name|SSTAT0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sstat0
operator|&
name|SELDO
condition|)
block|{
comment|/* Still selected!? */
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENSCSIPERR
operator||
name|ENBUSFREE
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_HASNEXUS
expr_stmt|;
name|aic
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_INVALID
expr_stmt|;
name|aic
operator|->
name|dp
operator|=
name|acb
operator|->
name|daddr
expr_stmt|;
name|aic
operator|->
name|dleft
operator|=
name|acb
operator|->
name|dleft
expr_stmt|;
name|ti
operator|->
name|lubusy
operator||=
operator|(
literal|1
operator|<<
name|sc
operator|->
name|lun
operator|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"select ok "
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Has seen busfree since selection, i.e. 				 * a "spurious" selection. Shouldn't happen. 				 */
name|printf
argument_list|(
literal|"aic: unexpected busfree\n"
argument_list|)
expr_stmt|;
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
name|acb
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sstat1
operator|&
name|SELTO
condition|)
block|{
comment|/* Selection timed out. What to do: 			 * Disable selections out and fail the command with 			 * code XS_TIMEOUT. 			 */
name|acb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
if|if
condition|(
operator|!
name|acb
condition|)
block|{
name|printf
argument_list|(
literal|"aic at line %d: missing acb"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
name|outb
argument_list|(
name|SCSISEQ
argument_list|,
name|ENRESELI
operator||
name|ENAUTOATNP
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRSELTIMO
argument_list|)
expr_stmt|;
name|aic
operator|->
name|state
operator|=
name|AIC_IDLE
expr_stmt|;
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
name|acb
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Assume a bus free interrupt.  What to do: 			 * Start selecting. 			 */
if|if
condition|(
name|aic
operator|->
name|state
operator|==
name|AIC_IDLE
condition|)
name|aic_sched
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|#
directive|if
name|AIC_DEBUG
else|else
name|AIC_MISC
argument_list|(
operator|(
literal|"Extra aic6360 interrupt."
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Driver is now in state AIC_HASNEXUS, i.e. we have a current command 	 * working the SCSI bus. 	 */
name|acb
operator|=
name|aic
operator|->
name|nexus
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|state
operator|!=
name|AIC_HASNEXUS
operator|||
name|acb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"aic: no nexus!!\n"
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
comment|/* What sort of transfer does the bus signal? */
name|aic
operator|->
name|phase
operator|=
name|aicphase
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|aic
operator|->
name|phase
operator|&
name|PH_PSBIT
operator|)
condition|)
comment|/* not a pseudo phase */
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|aic
operator|->
name|phase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
argument_list|,
name|CLRPHASECHG
argument_list|)
expr_stmt|;
comment|/* These interrupts are enabled by default: 	 * SCSIRSTI, SCSIPERR, BUSFREE, REQINIT 	 */
switch|switch
condition|(
name|aic
operator|->
name|phase
condition|)
block|{
case|case
name|PH_MSGO
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"PH_MSGO "
argument_list|)
expr_stmt|;
name|aic_msgout
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_MSGO
expr_stmt|;
comment|/* Setup interrupts before leaving */
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Enabled ints: SCSIPERR, SCSIRSTI (unexpected) 		 * 		 REQINIT (expected) BUSFREE (possibly expected) 		 */
break|break;
case|case
name|PH_CMD
case|:
comment|/* CMD phase& REQ asserted */
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"PH_CMD 0x%02x (%d) "
argument_list|,
name|acb
operator|->
name|cmd
operator|.
name|opcode
argument_list|,
name|acb
operator|->
name|clen
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_CMD
argument_list|)
expr_stmt|;
comment|/* Use FIFO for CMDs. Assumes that no cmd> 128 bytes. OK? */
comment|/* Clear hostFIFO and enable EISA-hostFIFO transfers */
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|WRITE
operator||
name|RSTFIFO
operator||
name|INTEN
argument_list|)
expr_stmt|;
comment|/* 3(4) */
comment|/* Clear scsiFIFO and enable SCSI-interface& hostFIFO-scsiFIFO transfers */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|CLRCH
operator||
name|CLRSTCNT
argument_list|)
expr_stmt|;
comment|/* 4 */
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|SCSIEN
operator||
name|DMAEN
operator||
name|CHEN
argument_list|)
expr_stmt|;
comment|/* 5 */
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|ENDMA
operator||
name|WRITE
operator||
name|INTEN
argument_list|)
expr_stmt|;
comment|/* 3+6 */
comment|/* What (polled) interrupts to enable */
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENPHASEMIS
operator||
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
comment|/* DFIFOEMP is set, FIFO (128 byte) is always big enough */
name|outsw
argument_list|(
name|DMADATA
argument_list|,
operator|(
name|short
operator|*
operator|)
operator|&
name|acb
operator|->
name|cmd
argument_list|,
name|acb
operator|->
name|clen
operator|>>
literal|1
argument_list|)
expr_stmt|;
comment|/* Wait for SCSI FIFO to drain */
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
do|do
block|{
name|sstat2
operator|=
name|inb
argument_list|(
name|SSTAT2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
operator|(
name|sstat2
operator|&
name|SEMPTY
operator|)
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|SSTAT2
argument_list|)
operator|&
name|SEMPTY
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"aic at line %d: SCSI-FIFO didn't drain\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
name|acb
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
return|return;
block|}
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
comment|/* Clear SCSIEN& DMAEN */
name|outb
argument_list|(
name|SIMODE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
do|do
block|{
name|sxfrctl0
operator|=
name|inb
argument_list|(
name|SXFRCTL0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|sxfrctl0
operator|&
name|SCSIEN
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|DMASTAT
argument_list|)
operator|&
name|INTSTAT
operator|)
condition|)
do|;
if|if
condition|(
name|sxfrctl0
operator|&
name|SCSIEN
condition|)
block|{
name|printf
argument_list|(
literal|"aic at line %d: scsi xfer never finished\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|aic_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|acb
argument_list|,
name|acb
operator|->
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|aic_init
argument_list|(
name|aic
argument_list|)
expr_stmt|;
return|return;
block|}
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
comment|/* Enabled ints: BUSFREE, SCSIPERR, SCSIRSTI (unexpected) 		 * 		 REQINIT (expected) 		 */
name|aic
operator|->
name|prevphase
operator|=
name|PH_CMD
expr_stmt|;
break|break;
case|case
name|PH_DOUT
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|AIC_MISC
argument_list|(
operator|(
literal|"PH_DOUT [%d] "
operator|,
name|aic
operator|->
name|dleft
operator|)
argument_list|)
expr_stmt|;
name|aic_dataout
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_DOUT
expr_stmt|;
break|break;
case|case
name|PH_MSGI
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"PH_MSGI "
argument_list|)
expr_stmt|;
name|aic_msgin
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_MSGI
expr_stmt|;
break|break;
case|case
name|PH_DIN
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"PH_DIN "
argument_list|)
expr_stmt|;
name|aic_datain
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_DIN
expr_stmt|;
break|break;
case|case
name|PH_STAT
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"PH_STAT "
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISIGO
argument_list|,
name|PH_STAT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|RSTFIFO
operator||
name|INTEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENPHASEMIS
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
name|acb
operator|->
name|stat
operator|=
name|inb
argument_list|(
name|SCSIDAT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL0
argument_list|,
name|CHEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic_debug
operator|&
name|AIC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"0x%02x "
argument_list|,
name|acb
operator|->
name|stat
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
argument_list|,
name|ENSCSIRST
operator||
name|ENBUSFREE
operator||
name|ENSCSIPERR
operator||
name|ENREQINIT
argument_list|)
expr_stmt|;
name|aic
operator|->
name|prevphase
operator|=
name|PH_STAT
expr_stmt|;
break|break;
case|case
name|PH_INVALID
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
break|break;
case|case
name|PH_BUSFREE
case|:
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|flags
operator|&
name|AIC_BUSFREE_OK
condition|)
block|{
comment|/*It's fun the 1st time.. */
name|aic
operator|->
name|flags
operator|&=
operator|~
name|AIC_BUSFREE_OK
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"aic at line %d: unexpected busfree phase\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"aic at line %d: bogus bus phase\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aic6360"
argument_list|)
expr_stmt|;
name|fatal_if_no_DDB
argument_list|()
expr_stmt|;
break|break;
block|}
name|LOGLINE
argument_list|(
name|aic
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|DMACNTRL0
argument_list|,
name|INTEN
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|aic_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|struct
name|acb
modifier|*
name|acb
init|=
operator|(
expr|struct
name|acb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
decl_stmt|;
name|unit
operator|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|aic
operator|=
name|aicdata
index|[
name|unit
index|]
expr_stmt|;
name|sc_print_addr
argument_list|(
name|acb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|acb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
name|printf
argument_list|(
literal|"timed out\n"
argument_list|)
expr_stmt|;
name|aic_done
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|AIC_DEBUG
end_if

begin_comment
comment|/*  * The following functions are mostly used for debugging purposes, either  * directly called from the driver or from the kernel debugger.  */
end_comment

begin_function
name|void
name|aic_show_scsi_cmd
parameter_list|(
name|acb
parameter_list|)
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|acb
operator|->
name|cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc
init|=
name|acb
operator|->
name|xs
operator|->
name|sc_link
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc_print_addr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|acb
operator|->
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acb
operator|->
name|clen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"RESET\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aic_print_acb
parameter_list|(
name|acb
parameter_list|)
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"acb@%x xs=%x flags=%x"
argument_list|,
name|acb
argument_list|,
name|acb
operator|->
name|xs
argument_list|,
name|acb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" daddr=%x dleft=%d stat=%x\n"
argument_list|,
operator|(
name|long
operator|)
name|acb
operator|->
name|daddr
argument_list|,
name|acb
operator|->
name|dleft
argument_list|,
name|acb
operator|->
name|stat
argument_list|)
expr_stmt|;
name|aic_show_scsi_cmd
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aic_print_active_acb
parameter_list|()
block|{
name|struct
name|acb
modifier|*
name|acb
decl_stmt|;
name|struct
name|aic_data
modifier|*
name|aic
init|=
name|aicdata
index|[
literal|0
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"ready list:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|aic
operator|->
name|ready_list
operator|.
name|tqh_first
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|chain
operator|.
name|tqe_next
control|)
name|aic_print_acb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nexus:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aic
operator|->
name|nexus
condition|)
name|aic_print_acb
argument_list|(
name|aic
operator|->
name|nexus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"nexus list:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|acb
operator|=
name|aic
operator|->
name|nexus_list
operator|.
name|tqh_first
init|;
name|acb
condition|;
name|acb
operator|=
name|acb
operator|->
name|chain
operator|.
name|tqe_next
control|)
name|aic_print_acb
argument_list|(
name|acb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aic_dump6360
parameter_list|()
block|{
name|u_short
name|iobase
init|=
literal|0x340
decl_stmt|;
name|printf
argument_list|(
literal|"aic6360: SCSISEQ=%x SXFRCTL0=%x SXFRCTL1=%x SCSISIGI=%x\n"
argument_list|,
name|inb
argument_list|(
name|SCSISEQ
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SXFRCTL0
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SXFRCTL1
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         SSTAT0=%x SSTAT1=%x SSTAT2=%x SSTAT3=%x SSTAT4=%x\n"
argument_list|,
name|inb
argument_list|(
name|SSTAT0
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SSTAT1
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SSTAT2
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SSTAT3
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SSTAT4
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         SIMODE0=%x SIMODE1=%x DMACNTRL0=%x DMACNTRL1=%x DMASTAT=%x\n"
argument_list|,
name|inb
argument_list|(
name|SIMODE0
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SIMODE1
argument_list|)
argument_list|,
name|inb
argument_list|(
name|DMACNTRL0
argument_list|)
argument_list|,
name|inb
argument_list|(
name|DMACNTRL1
argument_list|)
argument_list|,
name|inb
argument_list|(
name|DMASTAT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         FIFOSTAT=%d SCSIBUS=0x%x\n"
argument_list|,
name|inb
argument_list|(
name|FIFOSTAT
argument_list|)
argument_list|,
name|inb
argument_list|(
name|SCSIBUS
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|aic_dump_driver
parameter_list|()
block|{
name|struct
name|aic_data
modifier|*
name|aic
init|=
name|aicdata
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|aic_tinfo
modifier|*
name|ti
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"nexus=%x phase=%x prevphase=%x\n"
argument_list|,
name|aic
operator|->
name|nexus
argument_list|,
name|aic
operator|->
name|phase
argument_list|,
name|aic
operator|->
name|prevphase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"state=%x msgin=%x msgpriq=%x msgout=%x imlen=%d omlen=%d\n"
argument_list|,
name|aic
operator|->
name|state
argument_list|,
name|aic
operator|->
name|imess
index|[
literal|0
index|]
argument_list|,
name|aic
operator|->
name|msgpriq
argument_list|,
name|aic
operator|->
name|msgout
argument_list|,
name|aic
operator|->
name|imlen
argument_list|,
name|aic
operator|->
name|omlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"history:"
argument_list|)
expr_stmt|;
name|i
operator|=
name|aic
operator|->
name|hp
expr_stmt|;
do|do
block|{
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|aic
operator|->
name|history
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|AIC_HSIZE
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|aic
operator|->
name|hp
condition|)
do|;
name|printf
argument_list|(
literal|"*\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|ti
operator|=
operator|&
name|aic
operator|->
name|tinfo
index|[
name|i
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"tinfo%d: %d cmds %d disconnects %d timeouts"
argument_list|,
name|i
argument_list|,
name|ti
operator|->
name|cmds
argument_list|,
name|ti
operator|->
name|dconns
argument_list|,
name|ti
operator|->
name|touts
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %d senses flags=%x\n"
argument_list|,
name|ti
operator|->
name|senses
argument_list|,
name|ti
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

