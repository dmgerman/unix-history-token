begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * (Mostly) Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *      $Id: aha1542.c,v 1.67 1997/03/23 04:39:26 bde Exp $  */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_comment
comment|/* don't laugh.. look for main() */
end_comment

begin_include
include|#
directive|include
file|"aha.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*KERNEL */
end_comment

begin_define
define|#
directive|define
name|NAHA
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_include
include|#
directive|include
file|"ioconf.h"
end_include

begin_comment
comment|/************************** board definitions *******************************/
end_comment

begin_comment
comment|/*  * I/O Port Interface  */
end_comment

begin_define
define|#
directive|define
name|AHA_BASE
value|aha->aha_base
end_define

begin_define
define|#
directive|define
name|AHA_CTRL_STAT_PORT
value|(AHA_BASE + 0x0)
end_define

begin_comment
comment|/* control& status */
end_comment

begin_define
define|#
directive|define
name|AHA_CMD_DATA_PORT
value|(AHA_BASE + 0x1)
end_define

begin_comment
comment|/* cmds and datas */
end_comment

begin_define
define|#
directive|define
name|AHA_INTR_PORT
value|(AHA_BASE + 0x2)
end_define

begin_comment
comment|/* Intr. stat */
end_comment

begin_comment
comment|/*  * AHA_CTRL_STAT bits (write)  */
end_comment

begin_define
define|#
directive|define
name|AHA_HRST
value|0x80
end_define

begin_comment
comment|/* Hardware reset */
end_comment

begin_define
define|#
directive|define
name|AHA_SRST
value|0x40
end_define

begin_comment
comment|/* Software reset */
end_comment

begin_define
define|#
directive|define
name|AHA_IRST
value|0x20
end_define

begin_comment
comment|/* Interrupt reset */
end_comment

begin_define
define|#
directive|define
name|AHA_SCRST
value|0x10
end_define

begin_comment
comment|/* SCSI bus reset */
end_comment

begin_comment
comment|/*  * AHA_CTRL_STAT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|AHA_STST
value|0x80
end_define

begin_comment
comment|/* Self test in Progress */
end_comment

begin_define
define|#
directive|define
name|AHA_DIAGF
value|0x40
end_define

begin_comment
comment|/* Diagnostic Failure */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT
value|0x20
end_define

begin_comment
comment|/* Mbx Init required */
end_comment

begin_define
define|#
directive|define
name|AHA_IDLE
value|0x10
end_define

begin_comment
comment|/* Host Adapter Idle */
end_comment

begin_define
define|#
directive|define
name|AHA_CDF
value|0x08
end_define

begin_comment
comment|/* cmd/data out port full */
end_comment

begin_define
define|#
directive|define
name|AHA_DF
value|0x04
end_define

begin_comment
comment|/* Data in port full */
end_comment

begin_define
define|#
directive|define
name|AHA_INVDCMD
value|0x01
end_define

begin_comment
comment|/* Invalid command */
end_comment

begin_comment
comment|/*  * AHA_CMD_DATA bits (write)  */
end_comment

begin_define
define|#
directive|define
name|AHA_NOP
value|0x00
end_define

begin_comment
comment|/* No operation */
end_comment

begin_define
define|#
directive|define
name|AHA_MBX_INIT
value|0x01
end_define

begin_comment
comment|/* Mbx initialization */
end_comment

begin_define
define|#
directive|define
name|AHA_START_SCSI
value|0x02
end_define

begin_comment
comment|/* start scsi command */
end_comment

begin_define
define|#
directive|define
name|AHA_START_BIOS
value|0x03
end_define

begin_comment
comment|/* start bios command */
end_comment

begin_define
define|#
directive|define
name|AHA_INQUIRE
value|0x04
end_define

begin_comment
comment|/* Adapter Inquiry */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_INTR_EN
value|0x05
end_define

begin_comment
comment|/* Enable MBO available interrupt */
end_comment

begin_define
define|#
directive|define
name|AHA_SEL_TIMEOUT_SET
value|0x06
end_define

begin_comment
comment|/* set selection time-out */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_ON_TIME_SET
value|0x07
end_define

begin_comment
comment|/* set bus-on time */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_OFF_TIME_SET
value|0x08
end_define

begin_comment
comment|/* set bus-off time */
end_comment

begin_define
define|#
directive|define
name|AHA_SPEED_SET
value|0x09
end_define

begin_comment
comment|/* set transfer speed */
end_comment

begin_define
define|#
directive|define
name|AHA_DEV_GET
value|0x0a
end_define

begin_comment
comment|/* return installed devices */
end_comment

begin_define
define|#
directive|define
name|AHA_CONF_GET
value|0x0b
end_define

begin_comment
comment|/* return configuration data */
end_comment

begin_define
define|#
directive|define
name|AHA_TARGET_EN
value|0x0c
end_define

begin_comment
comment|/* enable target mode */
end_comment

begin_define
define|#
directive|define
name|AHA_SETUP_GET
value|0x0d
end_define

begin_comment
comment|/* return setup data */
end_comment

begin_define
define|#
directive|define
name|AHA_WRITE_CH2
value|0x1a
end_define

begin_comment
comment|/* write channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_READ_CH2
value|0x1b
end_define

begin_comment
comment|/* read channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_WRITE_FIFO
value|0x1c
end_define

begin_comment
comment|/* write fifo buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_READ_FIFO
value|0x1d
end_define

begin_comment
comment|/* read fifo buffer */
end_comment

begin_define
define|#
directive|define
name|AHA_ECHO
value|0x1e
end_define

begin_comment
comment|/* Echo command data */
end_comment

begin_define
define|#
directive|define
name|AHA_EXT_BIOS
value|0x28
end_define

begin_comment
comment|/* return extended bios info */
end_comment

begin_define
define|#
directive|define
name|AHA_MBX_ENABLE
value|0x29
end_define

begin_comment
comment|/* enable mail box interface */
end_comment

begin_struct
struct|struct
name|aha_cmd_buf
block|{
name|u_char
name|byte
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * AHA_INTR_PORT bits (read)  */
end_comment

begin_define
define|#
directive|define
name|AHA_ANY_INTR
value|0x80
end_define

begin_comment
comment|/* Any interrupt */
end_comment

begin_define
define|#
directive|define
name|AHA_SCRD
value|0x08
end_define

begin_comment
comment|/* SCSI reset detected */
end_comment

begin_define
define|#
directive|define
name|AHA_HACC
value|0x04
end_define

begin_comment
comment|/* Command complete */
end_comment

begin_define
define|#
directive|define
name|AHA_MBOA
value|0x02
end_define

begin_comment
comment|/* MBX out empty */
end_comment

begin_define
define|#
directive|define
name|AHA_MBIF
value|0x01
end_define

begin_comment
comment|/* MBX in full */
end_comment

begin_comment
comment|/*  * Mail box defs  */
end_comment

begin_define
define|#
directive|define
name|AHA_MBX_SIZE
value|16
end_define

begin_comment
comment|/* mail box size */
end_comment

begin_struct
struct|struct
name|aha_mbx
block|{
struct|struct
name|aha_mbx_out
block|{
name|unsigned
name|char
name|cmd
decl_stmt|;
name|unsigned
name|char
name|ccb_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|mbo
index|[
name|AHA_MBX_SIZE
index|]
struct|;
struct|struct
name|aha_mbx_in
block|{
name|unsigned
name|char
name|stat
decl_stmt|;
name|unsigned
name|char
name|ccb_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|mbi
index|[
name|AHA_MBX_SIZE
index|]
struct|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * mbo.cmd values  */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_FREE
value|0x0
end_define

begin_comment
comment|/* MBO entry is free */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_START
value|0x1
end_define

begin_comment
comment|/* MBO activate entry */
end_comment

begin_define
define|#
directive|define
name|AHA_MBO_ABORT
value|0x2
end_define

begin_comment
comment|/* MBO abort entry */
end_comment

begin_comment
comment|/*  * mbi.stat values  */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_FREE
value|0x0
end_define

begin_comment
comment|/* MBI entry is free */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_OK
value|0x1
end_define

begin_comment
comment|/* completed without error */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_ABORT
value|0x2
end_define

begin_comment
comment|/* aborted ccb */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_UNKNOWN
value|0x3
end_define

begin_comment
comment|/* Tried to abort invalid CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_ERROR
value|0x4
end_define

begin_comment
comment|/* Completed with error */
end_comment

begin_define
define|#
directive|define
name|AHA_MBI_TGT_NO_CCB
value|0x10
end_define

begin_comment
comment|/* Target received, no CCB ready */
end_comment

begin_comment
comment|/* FOR OLD VERSIONS OF THE !%$@ this may have to be 16 (yuk) */
end_comment

begin_define
define|#
directive|define
name|AHA_NSEG
value|17
end_define

begin_comment
comment|/* Number of scatter gather segments<= 16 */
end_comment

begin_comment
comment|/* allow 64 K i/o (min) */
end_comment

begin_struct
struct|struct
name|aha_ccb
block|{
name|unsigned
name|char
name|opcode
decl_stmt|;
name|unsigned
name|char
name|lun
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|data_in
range|:
literal|1
decl_stmt|;
comment|/* must be 0 */
name|unsigned
name|char
name|data_out
range|:
literal|1
decl_stmt|;
comment|/* must be 0 */
name|unsigned
name|char
name|target
range|:
literal|3
decl_stmt|;
name|unsigned
name|char
name|scsi_cmd_length
decl_stmt|;
name|unsigned
name|char
name|req_sense_length
decl_stmt|;
name|unsigned
name|char
name|data_length
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|data_addr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|link_addr
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|link_id
decl_stmt|;
name|unsigned
name|char
name|host_stat
decl_stmt|;
name|unsigned
name|char
name|target_stat
decl_stmt|;
name|unsigned
name|char
name|reserved
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|scsi_generic
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_sense_data
name|scsi_sense
decl_stmt|;
struct|struct
name|aha_scat_gath
block|{
name|unsigned
name|char
name|seg_len
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|seg_addr
index|[
literal|3
index|]
decl_stmt|;
block|}
name|scat_gath
index|[
name|AHA_NSEG
index|]
struct|;
name|struct
name|aha_ccb
modifier|*
name|next
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xfer
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|struct
name|aha_mbx_out
modifier|*
name|mbx
decl_stmt|;
comment|/* pointer to mail box */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|CCB_FREE
value|0
define|#
directive|define
name|CCB_ACTIVE
value|1
define|#
directive|define
name|CCB_ABORTED
value|2
block|}
struct|;
end_struct

begin_comment
comment|/*  * opcode fields  */
end_comment

begin_define
define|#
directive|define
name|AHA_INITIATOR_CCB
value|0x00
end_define

begin_comment
comment|/* SCSI Initiator CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_TARGET_CCB
value|0x01
end_define

begin_comment
comment|/* SCSI Target CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT_SCAT_GATH_CCB
value|0x02
end_define

begin_comment
comment|/* SCSI Initiator with scatter gather */
end_comment

begin_define
define|#
directive|define
name|AHA_RESET_CCB
value|0x81
end_define

begin_comment
comment|/* SCSI Bus reset */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT_RESID_CCB
value|0x03
end_define

begin_comment
comment|/* SCSI Initiator CCB */
end_comment

begin_define
define|#
directive|define
name|AHA_INIT_SG_RESID_CCB
value|0x04
end_define

begin_comment
comment|/* SCSI initiator with scatter gather */
end_comment

begin_comment
comment|/*  * aha_ccb.host_stat values  */
end_comment

begin_define
define|#
directive|define
name|AHA_OK
value|0x00
end_define

begin_comment
comment|/* cmd ok */
end_comment

begin_define
define|#
directive|define
name|AHA_LINK_OK
value|0x0a
end_define

begin_comment
comment|/* Link cmd ok */
end_comment

begin_define
define|#
directive|define
name|AHA_LINK_IT
value|0x0b
end_define

begin_comment
comment|/* Link cmd ok + int */
end_comment

begin_define
define|#
directive|define
name|AHA_SEL_TIMEOUT
value|0x11
end_define

begin_comment
comment|/* Selection time out */
end_comment

begin_define
define|#
directive|define
name|AHA_OVER_UNDER
value|0x12
end_define

begin_comment
comment|/* Data over/under run */
end_comment

begin_define
define|#
directive|define
name|AHA_BUS_FREE
value|0x13
end_define

begin_comment
comment|/* Bus dropped at unexpected time */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_BUS
value|0x14
end_define

begin_comment
comment|/* Invalid bus phase/sequence */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_MBO
value|0x15
end_define

begin_comment
comment|/* Incorrect MBO cmd */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_CCB
value|0x16
end_define

begin_comment
comment|/* Incorrect ccb opcode */
end_comment

begin_define
define|#
directive|define
name|AHA_BAD_LINK
value|0x17
end_define

begin_comment
comment|/* Not same values of LUN for links */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_TARGET
value|0x18
end_define

begin_comment
comment|/* Invalid target direction */
end_comment

begin_define
define|#
directive|define
name|AHA_CCB_DUP
value|0x19
end_define

begin_comment
comment|/* Duplicate CCB received */
end_comment

begin_define
define|#
directive|define
name|AHA_INV_CCB
value|0x1a
end_define

begin_comment
comment|/* Invalid CCB or segment list */
end_comment

begin_define
define|#
directive|define
name|AHA_ABORTED
value|42
end_define

begin_struct
struct|struct
name|aha_setup
block|{
name|u_char
name|sync_neg
range|:
literal|1
decl_stmt|;
name|u_char
name|parity
range|:
literal|1
decl_stmt|;
name|u_char
label|:
literal|6
expr_stmt|;
name|u_char
name|speed
decl_stmt|;
name|u_char
name|bus_on
decl_stmt|;
name|u_char
name|bus_off
decl_stmt|;
name|u_char
name|num_mbx
decl_stmt|;
name|u_char
name|mbx
index|[
literal|3
index|]
decl_stmt|;
struct|struct
block|{
name|u_char
name|offset
range|:
literal|4
decl_stmt|;
name|u_char
name|period
range|:
literal|3
decl_stmt|;
name|u_char
name|valid
range|:
literal|1
decl_stmt|;
block|}
name|sync
index|[
literal|8
index|]
struct|;
name|u_char
name|disc_sts
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aha_config
block|{
name|u_char
name|chan
decl_stmt|;
name|u_char
name|intr
decl_stmt|;
name|u_char
name|scsi_dev
range|:
literal|3
decl_stmt|;
name|u_char
label|:
literal|5
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aha_inquire
block|{
name|u_char
name|boardid
decl_stmt|;
comment|/* type of board */
comment|/* 0x20 (' ') = BusLogic 545, but it gets 					   the command wrong, only returns 					   one byte */
comment|/* 0x31 ('1') = AHA-1540 */
comment|/* 0x41 ('A') = AHA-1540A/1542A/1542B */
comment|/* 0x42 ('B') = AHA-1640 */
comment|/* 0x43 ('C') = AHA-1542C */
comment|/* 0x44 ('D') = AHA-1542CF */
comment|/* 0x45 ('E') = AHA-1542CF, BIOS v2.01 */
comment|/* 0x46 ('F') = AHA-1542CP, "Plug'nPlay" */
name|u_char
name|spec_opts
decl_stmt|;
comment|/* special options ID */
comment|/* 0x41 = Board is standard model */
name|u_char
name|revision_1
decl_stmt|;
comment|/* firmware revision [0-9A-Z] */
name|u_char
name|revision_2
decl_stmt|;
comment|/* firmware revision [0-9A-Z] */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|aha_extbios
block|{
name|u_char
name|flags
decl_stmt|;
comment|/* Bit 3 == 1 extended bios enabled */
name|u_char
name|mailboxlock
decl_stmt|;
comment|/* mail box lock code to unlock it */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INT9
value|0x01
end_define

begin_define
define|#
directive|define
name|INT10
value|0x02
end_define

begin_define
define|#
directive|define
name|INT11
value|0x04
end_define

begin_define
define|#
directive|define
name|INT12
value|0x08
end_define

begin_define
define|#
directive|define
name|INT14
value|0x20
end_define

begin_define
define|#
directive|define
name|INT15
value|0x40
end_define

begin_define
define|#
directive|define
name|CHAN0
value|0x01
end_define

begin_define
define|#
directive|define
name|CHAN5
value|0x20
end_define

begin_define
define|#
directive|define
name|CHAN6
value|0x40
end_define

begin_define
define|#
directive|define
name|CHAN7
value|0x80
end_define

begin_comment
comment|/*********************************** end of board definitions***************/
end_comment

begin_define
define|#
directive|define
name|PHYSTOKV
parameter_list|(
name|x
parameter_list|)
value|(((long int)(x)) ^ aha->kv_phys_xor)
end_define

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|AHA_DMA_PAGES
value|AHA_NSEG
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AHADEBUG
end_ifdef

begin_decl_stmt
name|int
name|aha_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*AHADEBUG */
end_comment

begin_struct
specifier|static
struct|struct
name|aha_data
block|{
name|int
name|aha_base
decl_stmt|;
comment|/* base port for each board */
comment|/* 	 * xor this with a physaddr to get a kv addr and visa versa 	 * for items in THIS STRUCT only. 	 * Used to get the CCD's physical and kv addresses from each 	 * other. 	 */
name|long
name|int
name|kv_phys_xor
decl_stmt|;
name|struct
name|aha_mbx
name|aha_mbx
decl_stmt|;
comment|/* all the mailboxes */
name|struct
name|aha_ccb
modifier|*
name|aha_ccb_free
decl_stmt|;
comment|/* the next free ccb */
name|struct
name|aha_ccb
name|aha_ccb
index|[
name|AHA_MBX_SIZE
index|]
decl_stmt|;
comment|/* all the CCBs      */
name|int
name|unit
decl_stmt|;
comment|/* unit number */
name|int
name|aha_int
decl_stmt|;
comment|/* irq level        */
name|int
name|aha_dma
decl_stmt|;
comment|/* DMA req channel  */
name|int
name|aha_scsi_dev
decl_stmt|;
comment|/* scsi bus address  */
name|int
name|flags
decl_stmt|;
comment|/* We use different op codes for different revs of the board 	 * if we think residual codes will work. 	 */
name|short
name|init_opcode
decl_stmt|;
comment|/* Command to use for initiator */
name|short
name|sg_opcode
decl_stmt|;
comment|/* Command to use for scatter/gather */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
comment|/* prototype for subdevs */
block|}
modifier|*
name|ahadata
index|[
name|NAHA
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int32_t
name|aha_adapter_info
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahaattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|TUNE_1542
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|aha_bus_speed_check
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
name|int
name|speed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aha_set_bus_speed
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|aha_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
name|int
name|icnt
operator|,
name|int
name|ocnt
operator|,
name|int
name|wait
operator|,
name|u_char
operator|*
name|retval
operator|,
name|u_char
name|opcode
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aha_done
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
expr|struct
name|aha_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aha_escape
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|,
expr|struct
name|aha_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|aha_free_ccb
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
expr|struct
name|aha_ccb
operator|*
name|ccb
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|aha_ccb
modifier|*
name|aha_get_ccb
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aha_init
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahaminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|aha_poll
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|,
expr|struct
name|aha_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahaprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|aha_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|aha_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|board_rev
name|__P
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
name|aha
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|physcontig
name|__P
argument_list|(
operator|(
name|int
name|kv
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_host_stat
name|__P
argument_list|(
operator|(
name|int
name|host_stat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|aha_switch
init|=
block|{
name|aha_scsi_cmd
block|,
name|ahaminphys
block|,
literal|0
block|,
literal|0
block|,
name|aha_adapter_info
block|,
literal|"aha"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for out link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|aha_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"aha"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|ahadriver
init|=
block|{
name|ahaprobe
block|,
name|ahaattach
block|,
literal|"aha"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ahaunit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|aha_abortmbx
parameter_list|(
name|mbx
parameter_list|)
define|\
value|(mbx)->cmd = AHA_MBO_ABORT; \ 	outb(AHA_CMD_DATA_PORT, AHA_START_SCSI);
end_define

begin_define
define|#
directive|define
name|aha_startmbx
parameter_list|(
name|mbx
parameter_list|)
define|\
value|(mbx)->cmd = AHA_MBO_START; \ 	outb(AHA_CMD_DATA_PORT, AHA_START_SCSI);
end_define

begin_define
define|#
directive|define
name|AHA_RESET_TIMEOUT
value|2000
end_define

begin_comment
comment|/* time to wait for reset (mSec) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_function
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"size of aha_data is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aha_data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size of aha_ccb is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aha_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"size of aha_mbx is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aha_mbx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*KERNEL */
end_comment

begin_comment
comment|/*  * aha_cmd(struct aha_data *aha,icnt, ocnt,wait, retval, opcode, ...)  * Activate Adapter command  *    icnt:   number of args (outbound bytes written after opcode)  *    ocnt:   number of expected returned bytes  *    wait:   number of seconds to wait for response  *    retval: buffer where to place returned bytes  *    opcode: opcode AHA_NOP, AHA_MBX_INIT, AHA_START_SCSI, etc  *    ...   : parameters to the command specified by opcode  *  * Performs an adapter command through the ports. Not to be confused  * with a scsi command, which is read in via the dma.  One of the adapter  * commands tells it to read in a scsi command but that one is done  * separately.  This is only called during set-up.  *  */
end_comment

begin_decl_stmt
specifier|static
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|aha_cmd
argument_list|(
expr|struct
name|aha_data
operator|*
name|aha
argument_list|,
name|int
name|icnt
argument_list|,
name|int
name|ocnt
argument_list|,
name|int
name|wait
argument_list|,
name|u_char
operator|*
name|retval
argument_list|,
name|u_char
name|opcode
argument_list|,
operator|...
argument_list|)
else|#
directive|else
name|aha_cmd
argument_list|(
name|aha
argument_list|,
name|icnt
argument_list|,
name|ocnt
argument_list|,
name|wait
argument_list|,
name|retval
argument_list|,
name|opcode
argument_list|,
name|va_alist
argument_list|)
decl|struct
name|aha_data
modifier|*
name|aha
decl_stmt|,
name|int
name|icnt
decl_stmt|,
name|int
name|ocnt
decl_stmt|,
name|int
name|wait
decl_stmt|,
name|u_char
modifier|*
name|retval
decl_stmt|,
name|u_char
name|opcode
decl_stmt|,
name|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|u_char
name|oc
decl_stmt|;
name|u_char
name|data
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|sts
decl_stmt|;
comment|/* 	 * multiply the wait argument by a big constant 	 * zero defaults to 1 sec.. 	 * all wait loops are in 50uSec cycles 	 */
if|if
condition|(
name|wait
condition|)
name|wait
operator|*=
literal|20000
expr_stmt|;
else|else
name|wait
operator|=
literal|20000
expr_stmt|;
comment|/* 	 * Wait for the adapter to go idle, unless it's one of 	 * the commands which don't need this 	 */
if|if
condition|(
name|opcode
operator|!=
name|AHA_MBX_INIT
operator|&&
name|opcode
operator|!=
name|AHA_START_SCSI
condition|)
block|{
name|i
operator|=
literal|20000
expr_stmt|;
comment|/*do this for upto about a second */
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_IDLE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: aha_cmd, host not idle(0x%x)\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Now that it is idle, if we expect output, preflush the 	 * queue feeding to us. 	 */
if|if
condition|(
name|ocnt
condition|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
operator|)
operator|&
name|AHA_DF
condition|)
name|inb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Output the command and the number of arguments given 	 * for each byte, first check the port is empty. 	 */
name|va_start
argument_list|(
name|ap
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
for|for
control|(
name|data
operator|=
name|opcode
init|;
name|icnt
operator|>=
literal|0
condition|;
name|icnt
operator|--
operator|,
name|data
operator|=
operator|(
name|u_char
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|AHA_CDF
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: aha_cmd, cmd/data port full\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_SRST
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we expect input, loop that many times, each time, 	 * looking for the data register to have valid data 	 */
while|while
condition|(
name|ocnt
operator|--
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_DF
condition|)
break|break;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: aha_cmd, cmd/data port empty %d\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|ocnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|oc
operator|=
name|inb
argument_list|(
name|AHA_CMD_DATA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
operator|*
name|retval
operator|++
operator|=
name|oc
expr_stmt|;
block|}
comment|/* 	 * Wait for the board to report a finised instruction 	 */
name|i
operator|=
literal|20000
expr_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|AHA_HACC
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: aha_cmd, host not finished(0x%x)\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_IRST
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given  * and if so, set it up ready for further work  * as an argument, takes the isa_device structure from  * autoconf.c  */
end_comment

begin_function
specifier|static
name|int
name|ahaprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|ahaunit
decl_stmt|;
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
comment|/* 	 * find unit and check we have that many defined 	 */
if|if
condition|(
name|unit
operator|>=
name|NAHA
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: unit number too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * a quick safety check so we can be sleazy later 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|aha_data
argument_list|)
operator|>
name|PAGESIZ
condition|)
block|{
name|printf
argument_list|(
literal|"aha struct> pagesize\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|ahadata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aha
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|aha_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aha
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|aha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|aha_data
argument_list|)
argument_list|)
expr_stmt|;
name|ahadata
index|[
name|unit
index|]
operator|=
name|aha
expr_stmt|;
name|aha
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|aha
operator|->
name|aha_base
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * Try initialise a unit at this location 	 * sets up dma and bus speed, loads aha->aha_int 	 */
if|if
condition|(
name|aha_init
argument_list|(
name|aha
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahadata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|aha
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Calculate the xor product of the aha struct's 	 * physical and virtual address. This allows us 	 * to change addresses within the structure 	 * from physical to virtual easily, as long as 	 * the structure is less than 1 page in size. 	 * This is used to recognise CCBs which are in 	 * this struct and which are refered to by the 	 * hardware using physical addresses. 	 * (assumes malloc returns a chunk that doesn't 	 * span pages) 	 * eventually use the hash table in aha1742.c 	 */
name|aha
operator|->
name|kv_phys_xor
operator|=
operator|(
name|long
name|int
operator|)
name|aha
operator|^
operator|(
name|KVTOPHYS
argument_list|(
name|aha
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * If it's there, put in it's interrupt vectors 	 */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|aha
operator|->
name|aha_int
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
name|aha
operator|->
name|aha_dma
expr_stmt|;
name|ahaunit
operator|++
expr_stmt|;
return|return
literal|0x4
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
specifier|static
name|int
name|ahaattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|aha_data
modifier|*
name|aha
init|=
name|ahadata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|aha
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|aha
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|aha
operator|->
name|aha_scsi_dev
expr_stmt|;
name|aha
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|aha
expr_stmt|;
name|aha
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|aha_switch
expr_stmt|;
name|aha
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|aha_dev
expr_stmt|;
name|aha
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|aha
operator|->
name|flags
expr_stmt|;
empty_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|aha
operator|->
name|sc_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about the adapter and its  * capabilities.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|aha_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|void
name|ahaintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|unsigned
name|char
name|stat
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|struct
name|aha_data
modifier|*
name|aha
init|=
name|ahadata
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"ahaintr "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
comment|/* 	 * First acknowledge the interrupt, Then if it's not telling about 	 * a completed operation just return. 	 */
name|stat
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_IRST
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|AHA_MBIF
operator|)
condition|)
return|return;
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"mbxin "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
comment|/* 	 * If it IS then process the completed operation 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHA_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|aha_mbx_in
modifier|*
name|mbi
init|=
name|aha
operator|->
name|aha_mbx
operator|.
name|mbi
operator|+
name|i
decl_stmt|;
if|if
condition|(
name|mbi
operator|->
name|stat
operator|!=
name|AHA_MBI_FREE
condition|)
block|{
name|struct
name|aha_ccb
modifier|*
name|ccb
init|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|PHYSTOKV
argument_list|(
name|scsi_3btou
argument_list|(
name|mbi
operator|->
name|ccb_addr
argument_list|)
argument_list|)
decl_stmt|;
name|stat
operator|=
name|mbi
operator|->
name|stat
expr_stmt|;
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|AHA_MBI_OK
case|:
break|break;
case|case
name|AHA_MBI_ABORT
case|:
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
name|ccb
operator|->
name|host_stat
operator|=
name|AHA_ABORTED
expr_stmt|;
break|break;
case|case
name|AHA_MBI_TGT_NO_CCB
case|:
comment|/* We enabled target mode and received a SEND 				 * or RECEIVE command from the initiator, but 				 * we don't have any CCB registered to handle the command. 				 * At this point it would be nice to wakeup a 				 * process sleeping on this event via an ioctl, 				 * returning whether it is a SEND or RECEIVE and the 				 * required length. 				 * However, I want to look at the CAM documentation before 				 * I start extending the API at all. 				 */
ifdef|#
directive|ifdef
name|NOISE_WHEN_TGT_NO_CDB
name|printf
argument_list|(
literal|"Target received, but no CCB ready.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Initiator& lun: %02x\n"
argument_list|,
name|mbi
operator|->
name|ccb_addr
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Max data length:     %06x\n"
argument_list|,
operator|(
name|mbi
operator|->
name|ccb_addr
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|mbi
operator|->
name|ccb_addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
literal|255
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"target-no-ccb"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
name|ccb
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AHA_MBI_UNKNOWN
case|:
name|ccb
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"unknown ccb for abort "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
comment|/* may have missed it */
comment|/* no such ccb known for abort */
case|case
name|AHA_MBI_ERROR
case|:
comment|/* XXX ccb is still set up? Driver fails without it? */
break|break;
default|default:
name|panic
argument_list|(
literal|"Impossible mbxi status"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
operator|&&
name|ccb
operator|&&
name|stat
operator|!=
name|AHA_MBI_OK
condition|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
operator|(
name|ccb
operator|->
name|scsi_cmd
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"op=%x %x %x %x %x %x\n"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|,
name|cp
index|[
literal|4
index|]
argument_list|,
name|cp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stat %x for mbi[%d]\n"
argument_list|,
name|mbi
operator|->
name|stat
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr = 0x%x\n"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*AHADEBUG */
if|if
condition|(
name|ccb
condition|)
block|{
name|untimeout
argument_list|(
name|aha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|aha_done
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
name|mbi
operator|->
name|stat
operator|=
name|AHA_MBI_FREE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * A ccb (and hence a mbx-out) is put onto the  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|aha_free_ccb
parameter_list|(
name|aha
parameter_list|,
name|ccb
parameter_list|,
name|flags
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|next
operator|=
name|aha
operator|->
name|aha_ccb_free
expr_stmt|;
name|aha
operator|->
name|aha_ccb_free
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
comment|/* 	 * If there were none, wake anybody waiting for 	 * one to come free, starting with queued entries 	 */
if|if
condition|(
operator|!
name|ccb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|aha
operator|->
name|aha_ccb_free
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free ccb (and hence mbox-out entry)  */
end_comment

begin_function
specifier|static
name|struct
name|aha_ccb
modifier|*
name|aha_get_ccb
parameter_list|(
name|aha
parameter_list|,
name|flags
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|rc
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one 	 * to come free 	 */
while|while
condition|(
operator|(
operator|!
operator|(
name|rc
operator|=
name|aha
operator|->
name|aha_ccb_free
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|aha
operator|->
name|aha_ccb_free
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahaccb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
condition|)
block|{
name|aha
operator|->
name|aha_ccb_free
operator|=
name|aha
operator|->
name|aha_ccb_free
operator|->
name|next
expr_stmt|;
name|rc
operator|->
name|flags
operator|=
name|CCB_ACTIVE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_host_stat
parameter_list|(
name|int
name|host_stat
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
struct|struct
block|{
name|int
name|host_stat
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
block|}
name|tab
index|[]
init|=
block|{
block|{
name|AHA_OK
block|,
literal|"Cmd ok"
block|}
block|,
block|{
name|AHA_LINK_OK
block|,
literal|"Link cmd ok"
block|}
block|,
block|{
name|AHA_LINK_IT
block|,
literal|"Link cmd ok + int"
block|}
block|,
block|{
name|AHA_SEL_TIMEOUT
block|,
literal|"Selection time out"
block|}
block|,
block|{
name|AHA_OVER_UNDER
block|,
literal|"Data over/under run"
block|}
block|,
block|{
name|AHA_BUS_FREE
block|,
literal|"Bus dropped at unexpected time"
block|}
block|,
block|{
name|AHA_INV_BUS
block|,
literal|"Invalid bus phase/sequence"
block|}
block|,
block|{
name|AHA_BAD_MBO
block|,
literal|"Incorrect MBO cmd"
block|}
block|,
block|{
name|AHA_BAD_CCB
block|,
literal|"Incorrect ccb opcode"
block|}
block|,
block|{
name|AHA_BAD_LINK
block|,
literal|"Not same values of LUN for links"
block|}
block|,
block|{
name|AHA_INV_TARGET
block|,
literal|"Invalid target direction"
block|}
block|,
block|{
name|AHA_CCB_DUP
block|,
literal|"Duplicate CCB received"
block|}
block|,
block|{
name|AHA_INV_CCB
block|,
literal|"Invalid CCB or segment list"
block|}
block|,
block|{
name|AHA_ABORTED
block|,
literal|"Software abort"
block|}
block|, 	}
struct|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tab
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tab
index|[
name|i
index|]
operator|.
name|host_stat
operator|==
name|host_stat
condition|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tab
index|[
name|i
index|]
operator|.
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"Unknown host_stat %02x\n"
argument_list|,
name|host_stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have a ccb which has been processed by the  * adaptor, now we look to see how the operation  * went. Wake up the owner if waiting  */
end_comment

begin_function
specifier|static
name|void
name|aha_done
parameter_list|(
name|aha
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ccb
operator|->
name|xfer
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"aha_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, put the results of the operation 	 * into the xfer and call whoever started it 	 */
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: exiting but not in use!\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"aha1542 exiting but not in use"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|xs
operator|->
name|status
operator|=
name|ccb
operator|->
name|target_stat
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ccb
operator|->
name|host_stat
operator|!=
name|AHA_OK
operator|)
operator|||
operator|(
name|ccb
operator|->
name|target_stat
operator|!=
name|SCSI_OK
operator|)
operator|)
operator|&&
operator|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * We have an error, that we cannot ignore. 		 */
name|s1
operator|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|ccb
operator|->
name|scsi_cmd
operator|)
operator|)
operator|+
name|ccb
operator|->
name|scsi_cmd_length
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"host err 0x%x\n"
operator|,
name|ccb
operator|->
name|host_stat
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
case|case
name|AHA_ABORTED
case|:
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
case|case
name|AHA_SEL_TIMEOUT
case|:
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
break|break;
case|case
name|AHA_OVER_UNDER
case|:
comment|/* Over run / under run */
switch|switch
condition|(
name|ccb
operator|->
name|opcode
condition|)
block|{
case|case
name|AHA_TARGET_CCB
case|:
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
operator|-
name|scsi_3btoi
argument_list|(
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|resid
operator|<=
literal|0
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_LENGTH
expr_stmt|;
break|break;
case|case
name|AHA_INIT_RESID_CCB
case|:
case|case
name|AHA_INIT_SG_RESID_CCB
case|:
name|xs
operator|->
name|resid
operator|=
name|scsi_3btoi
argument_list|(
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|resid
operator|<=
literal|0
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_LENGTH
expr_stmt|;
break|break;
default|default:
name|xs
operator|->
name|error
operator|=
name|XS_LENGTH
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|printf
argument_list|(
literal|"aha%d: "
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|put_host_stat
argument_list|(
name|ccb
operator|->
name|host_stat
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"target err 0x%x\n"
operator|,
name|ccb
operator|->
name|target_stat
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ccb
operator|->
name|target_stat
condition|)
block|{
case|case
literal|0x02
case|:
comment|/* structure copy!!!!! */
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"aha%d:target_stat%x\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|target_stat
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Macro to determine that a rev is potentially a new valid one  * so that the driver doesn't keep breaking on new revs as it  * did for the CF and CP.  */
end_comment

begin_define
define|#
directive|define
name|PROBABLY_NEW_BOARD
parameter_list|(
name|REV
parameter_list|)
value|(REV> 0x43&& REV< 0x56)
end_define

begin_function
specifier|static
name|char
modifier|*
name|board_rev
parameter_list|(
name|struct
name|aha_data
modifier|*
name|aha
parameter_list|,
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0x20
case|:
return|return
literal|"Buslogic 545?"
return|;
case|case
literal|0x31
case|:
return|return
literal|"AHA-1540"
return|;
case|case
literal|0x41
case|:
return|return
literal|"AHA-154x[AB]"
return|;
case|case
literal|0x42
case|:
return|return
literal|"AHA-1640"
return|;
case|case
literal|0x43
case|:
return|return
literal|"AHA-1542C"
return|;
case|case
literal|0x44
case|:
return|return
literal|"AHA-1542CF"
return|;
case|case
literal|0x45
case|:
return|return
literal|"AHA-1542CF BIOS v2.01"
return|;
case|case
literal|0x46
case|:
return|return
literal|"AHA-1542CP"
return|;
default|default:
if|if
condition|(
name|PROBABLY_NEW_BOARD
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: Assuming type %02x is a new board.\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|"New Adaptec rev?"
return|;
block|}
name|printf
argument_list|(
literal|"aha%d: type %02x is an unknown board.\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
literal|"Unknown board"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
specifier|static
name|int
name|aha_init
parameter_list|(
name|aha
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
block|{
name|char
modifier|*
name|desc
decl_stmt|;
name|unsigned
name|char
name|ad
index|[
literal|3
index|]
decl_stmt|;
specifier|volatile
name|int
name|i
decl_stmt|,
name|sts
decl_stmt|;
name|struct
name|aha_config
name|conf
decl_stmt|;
name|struct
name|aha_inquire
name|inquire
decl_stmt|;
name|struct
name|aha_extbios
name|extbios
decl_stmt|;
comment|/* Assume that residual codes don't work.  If they 	 * do we enable that after we figure out what kind of 	 * board it is. 	 */
name|aha
operator|->
name|init_opcode
operator|=
name|AHA_INITIATOR_CCB
expr_stmt|;
name|aha
operator|->
name|sg_opcode
operator|=
name|AHA_INIT_SCAT_GATH_CCB
expr_stmt|;
comment|/* 	 * reset board, If it doesn't respond, assume 	 * that it's not there.. good for the probe 	 */
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_HRST
operator||
name|AHA_SRST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AHA_RESET_TIMEOUT
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|==
operator|(
name|AHA_IDLE
operator||
name|AHA_INIT
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* calibrated in msec */
block|}
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"aha_init: AHA_RESET_TIMEOUT went to %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHADEBUG */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"aha_init: No answer from board\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Assume we have a board at this stage, do an adapter inquire 	 * to find out what type of controller it is.  If the AHA_INQUIRE 	 * command fails, blatter about it, nuke the boardid so the 1542C 	 * stuff gets skipped over, and reset the board again. 	 */
if|if
condition|(
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inquire
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|inquire
argument_list|,
name|AHA_INQUIRE
argument_list|)
condition|)
block|{
comment|/* 		 * Blah.. not a real adaptec board!!! 		 * Seems that the Buslogic 545S and the DTC3290 both get 		 * this wrong. 		 */
name|printf
argument_list|(
literal|"aha%d: not a REAL adaptec board, may cause warnings\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|inquire
operator|.
name|boardid
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|,
name|AHA_HRST
operator||
name|AHA_SRST
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|AHA_RESET_TIMEOUT
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|AHA_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|==
operator|(
name|AHA_IDLE
operator||
name|AHA_INIT
operator|)
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* calibrated in msec */
block|}
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"aha_init2: AHA_RESET_TIMEOUT went to %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHADEBUG */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHADEBUG
if|if
condition|(
name|aha_debug
condition|)
name|printf
argument_list|(
literal|"aha_init2: No answer from board\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHADEBUG */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"aha%d: inquire %x, %x, %x, %x\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|inquire
operator|.
name|boardid
argument_list|,
name|inquire
operator|.
name|spec_opts
argument_list|,
name|inquire
operator|.
name|revision_1
argument_list|,
name|inquire
operator|.
name|revision_2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHADEBUG */
name|aha
operator|->
name|flags
operator|=
name|SDEV_BOUNCE
expr_stmt|;
define|#
directive|define
name|PRVERBOSE
parameter_list|(
name|x
parameter_list|)
value|if (bootverbose) printf x
comment|/* 	 * If we are a new type of 1542 board (anything newer than a 1542C) 	 * then disable the extended bios so that the 	 * mailbox interface is unlocked. 	 * This is also true for the 1542B Version 3.20. First Adaptec 	 * board that supports>1Gb drives. 	 * No need to check the extended bios flags as some of the 	 * extensions that cause us problems are not flagged in that byte. 	 */
name|desc
operator|=
name|board_rev
argument_list|(
name|aha
argument_list|,
name|inquire
operator|.
name|boardid
argument_list|)
expr_stmt|;
name|PRVERBOSE
argument_list|(
operator|(
literal|"aha%d: Rev %02x (%s) V%c.%c"
operator|,
name|aha
operator|->
name|unit
operator|,
name|inquire
operator|.
name|boardid
operator|,
name|desc
operator|,
name|inquire
operator|.
name|revision_1
operator|,
name|inquire
operator|.
name|revision_2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PROBABLY_NEW_BOARD
argument_list|(
name|inquire
operator|.
name|boardid
argument_list|)
operator|||
operator|(
name|inquire
operator|.
name|boardid
operator|==
literal|0x41
operator|&&
name|inquire
operator|.
name|revision_1
operator|==
literal|0x31
operator|&&
name|inquire
operator|.
name|revision_2
operator|==
literal|0x34
operator|)
condition|)
block|{
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|extbios
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|extbios
argument_list|,
name|AHA_EXT_BIOS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHADEBUG
name|printf
argument_list|(
literal|"aha%d: extended bios flags %x\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|extbios
operator|.
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHADEBUG */
name|PRVERBOSE
argument_list|(
operator|(
literal|", enabling mailbox"
operator|)
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_MBX_ENABLE
argument_list|,
literal|0
argument_list|,
name|extbios
operator|.
name|mailboxlock
argument_list|)
expr_stmt|;
block|}
comment|/* Which boards support residuals?  Some early 1542A's apparently 	 * don't.  The 1542B with V0.5 of the software does, so I've 	 * arbitrarily set that as the earliest rev. 	 */
if|if
condition|(
name|PROBABLY_NEW_BOARD
argument_list|(
name|inquire
operator|.
name|boardid
argument_list|)
operator|||
operator|(
name|inquire
operator|.
name|boardid
operator|==
literal|0x41
operator|&&
operator|(
name|inquire
operator|.
name|revision_1
operator|>
literal|'0'
operator|||
name|inquire
operator|.
name|revision_2
operator|>=
literal|'5'
operator|)
operator|)
condition|)
block|{
name|PRVERBOSE
argument_list|(
operator|(
literal|", enabling residuals"
operator|)
argument_list|)
expr_stmt|;
name|aha
operator|->
name|init_opcode
operator|=
name|AHA_INIT_RESID_CCB
expr_stmt|;
name|aha
operator|->
name|sg_opcode
operator|=
name|AHA_INIT_SG_RESID_CCB
expr_stmt|;
block|}
comment|/* Which boards support target operations?  The 1542C completely 	 * locks up the SCSI bus if you enable them.  I'm only sure 	 * about the B, which was sold in the OEM market as a target 	 * board. 	 */
if|if
condition|(
name|inquire
operator|.
name|boardid
operator|==
literal|0x41
condition|)
block|{
name|PRVERBOSE
argument_list|(
operator|(
literal|", target ops"
operator|)
argument_list|)
expr_stmt|;
name|aha
operator|->
name|flags
operator||=
name|SDEV_TARGET_OPS
expr_stmt|;
block|}
name|PRVERBOSE
argument_list|(
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * setup dma channel from jumpers and save int 	 * level 	 */
name|PRVERBOSE
argument_list|(
operator|(
literal|"aha%d: reading board settings, "
operator|,
name|aha
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inquire
operator|.
name|boardid
operator|==
literal|0x20
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* for Bustek 545 */
block|}
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|conf
argument_list|,
name|AHA_CONF_GET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|chan
condition|)
block|{
case|case
name|CHAN0
case|:
name|outb
argument_list|(
literal|0x0b
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x0a
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|aha
operator|->
name|aha_dma
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CHAN5
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|aha
operator|->
name|aha_dma
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|CHAN6
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|aha
operator|->
name|aha_dma
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CHAN7
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|aha
operator|->
name|aha_dma
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"aha%d: illegal dma jumper setting\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|PRVERBOSE
argument_list|(
operator|(
literal|"dma=%d "
operator|,
name|aha
operator|->
name|aha_dma
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|intr
condition|)
block|{
case|case
name|INT9
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|INT10
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|INT11
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|INT14
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|INT15
case|:
name|aha
operator|->
name|aha_int
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"aha%d: illegal int jumper setting\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|PRVERBOSE
argument_list|(
operator|(
literal|"int=%d "
operator|,
name|aha
operator|->
name|aha_int
operator|)
argument_list|)
expr_stmt|;
comment|/* who are we on the scsi bus? */
name|aha
operator|->
name|aha_scsi_dev
operator|=
name|conf
operator|.
name|scsi_dev
expr_stmt|;
name|PRVERBOSE
argument_list|(
operator|(
literal|"id=%d "
operator|,
name|aha
operator|->
name|aha_scsi_dev
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Change the bus on/off times to not clash with other dma users. 	 */
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_BUS_ON_TIME_SET
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_BUS_OFF_TIME_SET
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TUNE_1542
comment|/* 	 * Initialize memory transfer speed 	 * Not compiled in by default because it breaks some machines 	 */
if|if
condition|(
operator|!
operator|(
name|aha_set_bus_speed
argument_list|(
name|aha
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
else|#
directive|else
name|PRVERBOSE
argument_list|(
operator|(
literal|" (bus speed defaulted)\n"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*TUNE_1542*/
comment|/* 	 * Initialize mail box 	 */
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|&
name|aha
operator|->
name|aha_mbx
argument_list|)
argument_list|,
name|ad
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_MBX_INIT
argument_list|,
name|AHA_MBX_SIZE
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * link the ccb's with the mbox-out entries and 	 * into a free-list 	 * this is a kludge but it works 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHA_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|aha
operator|->
name|aha_ccb
index|[
name|i
index|]
operator|.
name|next
operator|=
name|aha
operator|->
name|aha_ccb_free
expr_stmt|;
name|aha
operator|->
name|aha_ccb_free
operator|=
operator|&
name|aha
operator|->
name|aha_ccb
index|[
name|i
index|]
expr_stmt|;
name|aha
operator|->
name|aha_ccb_free
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
name|aha
operator|->
name|aha_ccb_free
operator|->
name|mbx
operator|=
operator|&
name|aha
operator|->
name|aha_mbx
operator|.
name|mbo
index|[
name|i
index|]
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|aha
operator|->
name|aha_ccb_free
argument_list|)
argument_list|,
name|aha
operator|->
name|aha_mbx
operator|.
name|mbo
index|[
name|i
index|]
operator|.
name|ccb_addr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that we are going and return (to probe) 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/*      aha seems to explode with 17 segs (64k may require 17 segs) */
comment|/*      on old boards so use a max of 16 segs if you have problems here */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHA_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|aha_escape
parameter_list|(
name|xs
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|xs
operator|->
name|cmd
condition|)
block|{
switch|switch
condition|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
condition|)
block|{
case|case
name|SCSI_OP_RESET
case|:
name|ccb
operator|->
name|opcode
operator|=
name|AHA_RESET_CCB
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCSI_OP_TARGET
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|aha_cmd
argument_list|(
operator|(
expr|struct
name|aha_data
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_TARGET_EN
argument_list|,
operator|(
name|int
operator|)
name|xs
operator|->
name|cmd
operator|->
name|bytes
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|ret
operator|=
name|COMPLETE
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|ESCAPE_NOT_SUPPORTED
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ccb
operator|->
name|opcode
operator|=
name|AHA_RESET_CCB
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_define
define|#
directive|define
name|physdb
parameter_list|(
name|ARG
parameter_list|)
value|(void)(ARG)
end_define

begin_comment
comment|/* physcontig: Scan forward from a KV and return length to the  * end of physically contiguous addresses.  This belongs in  * i386/.../something_or_other.c  * XXX: Find the right thing in the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|physcontig
parameter_list|(
name|int
name|kv
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|len_was
init|=
name|len
decl_stmt|;
name|u_long
name|kvl
init|=
operator|(
name|u_long
operator|)
name|kv
decl_stmt|;
name|int
name|phys_len
decl_stmt|;
name|u_long
name|phys
decl_stmt|,
name|prev_phys
decl_stmt|;
name|prev_phys
operator|=
name|KVTOPHYS
argument_list|(
name|kvl
argument_list|)
expr_stmt|;
comment|/* We go at least to the end of this page: 	 */
name|phys_len
operator|=
name|PAGESIZ
operator|-
operator|(
name|prev_phys
operator|&
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|len
operator|-=
name|phys_len
expr_stmt|;
name|kvl
operator|+=
name|phys_len
expr_stmt|;
name|prev_phys
operator|&=
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|phys
operator|=
name|KVTOPHYS
argument_list|(
name|kvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|phys
operator|!=
name|prev_phys
operator|+
name|PAGESIZ
condition|)
block|{
name|physdb
argument_list|(
operator|(
literal|"phys %08x != prev_phys %08x + PAGESIZ\n"
operator|,
name|phys
operator|,
name|prev_phys
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|prev_phys
operator|=
name|phys
expr_stmt|;
name|kvl
operator|+=
name|PAGESIZ
expr_stmt|;
name|len
operator|-=
name|PAGESIZ
expr_stmt|;
block|}
name|phys_len
operator|=
operator|(
name|len
operator|<
literal|0
operator|)
condition|?
name|len_was
else|:
operator|(
name|len_was
operator|-
name|len
operator|)
expr_stmt|;
name|physdb
argument_list|(
operator|(
literal|"physcontig(%08x, %d) = %d\n"
operator|,
name|kv
operator|,
name|len_was
operator|,
name|phys_len
operator|)
argument_list|)
expr_stmt|;
return|return
name|phys_len
return|;
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address. Also needs the unit, target  * and lu  */
end_comment

begin_function
specifier|static
name|int32_t
name|aha_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|aha_scat_gath
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|int
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|s
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_data
operator|*
operator|)
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"aha_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * get a ccb (mbox-out) to use. If the transfer 	 * is from a buf (possibly from interrupt time) 	 * then we can't allow it to sleep 	 */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ccb
operator|=
name|aha_get_ccb
argument_list|(
name|aha
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
if|if
condition|(
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|!=
name|AHA_MBO_FREE
condition|)
name|printf
argument_list|(
literal|"aha%d: MBO %02x and not %02x (free)\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|ccb
operator|->
name|mbx
operator|->
name|cmd
argument_list|,
name|AHA_MBO_FREE
argument_list|)
expr_stmt|;
comment|/* 	 * Put all the arguments for the xfer in the ccb 	 */
name|ccb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|ccb
operator|->
name|opcode
operator|=
name|AHA_RESET_CCB
expr_stmt|;
block|}
else|else
block|{
comment|/* can't use S/G if zero length */
name|ccb
operator|->
name|opcode
operator|=
operator|(
name|xs
operator|->
name|datalen
condition|?
name|aha
operator|->
name|sg_opcode
else|:
name|aha
operator|->
name|init_opcode
operator|)
expr_stmt|;
block|}
name|ccb
operator|->
name|target
operator|=
name|sc_link
operator|->
name|target
expr_stmt|;
name|ccb
operator|->
name|data_out
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|data_in
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|lun
operator|=
name|sc_link
operator|->
name|lun
expr_stmt|;
name|ccb
operator|->
name|scsi_cmd_length
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
comment|/* Some devices (e.g, Microtek ScanMaker II) 	 * fall on the ground if you ask for anything but 	 * an exact number of sense bytes (wiping out the 	 * sense data) 	 * XXX: This was lost at some point in scsi_ioctl.c. 	 */
name|ccb
operator|->
name|req_sense_length
operator|=
operator|(
name|xs
operator|->
name|req_sense_length
operator|)
condition|?
name|xs
operator|->
name|req_sense_length
else|:
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|scsi_sense
argument_list|)
expr_stmt|;
comment|/* XXX: I propose we move the reset handling into the escape 	 * handling. 	 */
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|flags
operator||=
name|SCSI_ESCAPE
expr_stmt|;
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|=
name|SCSI_OP_RESET
expr_stmt|;
block|}
comment|/* Set up the CCB.  For an escape function, the escape hook may 	 * set it up for us. 	 */
if|if
condition|(
name|flags
operator|&
name|SCSI_ESCAPE
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|aha_escape
argument_list|(
name|xs
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|SCSI_TARGET
condition|)
block|{
name|ccb
operator|->
name|opcode
operator|=
name|AHA_TARGET_CCB
expr_stmt|;
comment|/* These must be set up for target mode: 		 */
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_IN
condition|)
name|ccb
operator|->
name|data_in
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_OUT
condition|)
name|ccb
operator|->
name|data_out
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ccb
operator|->
name|opcode
operator|=
operator|(
name|xs
operator|->
name|datalen
condition|?
comment|/* can't use S/G if zero length */
name|AHA_INIT_SCAT_GATH_CCB
else|:
name|AHA_INITIATOR_CCB
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ccb
operator|->
name|opcode
condition|)
block|{
case|case
name|AHA_TARGET_CCB
case|:
if|if
condition|(
name|xs
operator|->
name|data
condition|)
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|(
name|int
operator|)
name|xs
operator|->
name|data
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
else|else
name|scsi_uto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
comment|/* For non scatter-gather I/O (and Target mode doesn't do 		 * scatter-gather) we need to truncate the transfer 		 * at the first non consecutive physical address. 		 */
name|scsi_uto3b
argument_list|(
name|physcontig
argument_list|(
operator|(
name|int
operator|)
name|xs
operator|->
name|data
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
break|break;
comment|/* This should be folded in with TARGET_CCB once 		 * physcontig is debugged. 		 */
case|case
name|AHA_INITIATOR_CCB
case|:
case|case
name|AHA_INIT_RESID_CCB
case|:
if|if
condition|(
name|xs
operator|->
name|data
condition|)
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
operator|(
name|int
operator|)
name|xs
operator|->
name|data
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
else|else
name|scsi_uto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|xs
operator|->
name|datalen
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHA_RESET_CCB
case|:
name|scsi_uto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHA_INIT_SCAT_GATH_CCB
case|:
case|case
name|AHA_INIT_SG_RESID_CCB
case|:
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|ccb
operator|->
name|scat_gath
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_addr
argument_list|)
expr_stmt|;
name|sg
operator|=
name|ccb
operator|->
name|scat_gath
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TFS_ONLY
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHA_NSEG
operator|)
condition|)
block|{
name|scsi_uto3b
argument_list|(
name|iovp
operator|->
name|iov_base
argument_list|,
name|sg
operator|->
name|seg_addr
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|iovp
operator|->
name|iov_len
argument_list|,
name|sg
operator|->
name|seg_len
argument_list|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"UIO(0x%x@0x%x)"
operator|,
name|iovp
operator|->
name|iov_len
operator|,
name|iovp
operator|->
name|iov_base
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/*TFS_ONLY */
block|{
comment|/* 			 * Set up the scatter gather block 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%ld @%p:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHA_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|scsi_uto3b
argument_list|(
name|thisphys
argument_list|,
name|sg
operator|->
name|seg_addr
argument_list|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%x"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 					 * This page is contiguous (physically) 					 * with the the last, just extend the 					 * length 					 */
comment|/* check it fits on the ISA bus */
if|if
condition|(
name|thisphys
operator|>
literal|0xFFFFFF
condition|)
block|{
name|printf
argument_list|(
literal|"aha%d: DMA beyond"
literal|" end Of ISA: 0x%x\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|thisphys
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
comment|/** how far to the end of the page ***/
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/**** get more ready for the next page ****/
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * next page isn't contiguous, finish the seg 				 */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|bytes_this_seg
argument_list|,
name|sg
operator|->
name|seg_len
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
name|scsi_uto3b
argument_list|(
name|seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|aha_scat_gath
argument_list|)
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"aha%d: aha_scsi_cmd, more than %d DMA segs\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|,
name|AHA_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"aha_scsi_cmd%d: Illegal CCB opcode.\n"
argument_list|,
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|aha_free_ccb
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|HAD_ERROR
return|;
block|}
name|scsi_uto3b
argument_list|(
literal|0
argument_list|,
name|ccb
operator|->
name|link_addr
argument_list|)
expr_stmt|;
comment|/* 	 * Put the scsi command in the ccb and start it 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_ESCAPE
operator|)
condition|)
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
operator|&
name|ccb
operator|->
name|scsi_cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmd_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* stop instant timeouts */
name|timeout
argument_list|(
name|aha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|aha_startmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
comment|/* 		 * Usually return SUCCESSFULLY QUEUED 		 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
name|aha_startmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd sent, waiting\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't use interrupts, poll on completion 	 */
return|return
operator|(
name|aha_poll
argument_list|(
name|aha
argument_list|,
name|xs
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
comment|/* only during boot */
block|}
end_function

begin_comment
comment|/*  * Poll a particular unit, looking for a particular xs  */
end_comment

begin_function
specifier|static
name|int
name|aha_poll
parameter_list|(
name|aha
parameter_list|,
name|xs
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|aha_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|int
name|count
init|=
name|xs
operator|->
name|timeout
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
comment|/*timeouts are in msec, so we loop in 1000uSec cycles */
while|while
condition|(
name|count
condition|)
block|{
comment|/* 		 * If we had interrupts enabled, would we 		 * have got an interrupt? 		 */
name|stat
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|AHA_ANY_INTR
condition|)
block|{
name|ahaintr
argument_list|(
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* only happens in boot so ok */
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We timed out, so call the timeout handler 		 * manually, accout  for the fact that the 		 * clock is not running yet by taking out the 		 * clock queue entry it makes 		 */
name|aha_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * because we are polling, 		 * take out the timeout entry aha_timeout made 		 */
name|untimeout
argument_list|(
name|aha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
name|count
operator|=
literal|2000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
comment|/* 			 * Once again, wait for the int bit 			 */
name|stat
operator|=
name|inb
argument_list|(
name|AHA_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|AHA_ANY_INTR
condition|)
block|{
name|ahaintr
argument_list|(
name|aha
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* only happens in boot so ok */
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We timed out again.. this is bad 			 * Notice that this time there is no 			 * clock queue entry to remove 			 */
name|aha_timeout
argument_list|(
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xs
operator|->
name|error
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TUNE_1542
end_ifdef

begin_comment
comment|/*  * Try all the speeds from slowest to fastest.. if it finds a  * speed that fails, back off one notch from the last working  * speed (unless there is no other notch).  * Returns the nSEC value of the time used  * or 0 if it could get a working speed (or the NEXT speed  * failed)  */
end_comment

begin_struct
specifier|static
struct|struct
name|bus_speed
block|{
name|char
name|arg
decl_stmt|;
name|int
name|nsecs
decl_stmt|;
block|}
name|aha_bus_speeds
index|[]
init|=
block|{
block|{
literal|0x88
block|,
literal|100
block|}
block|,
block|{
literal|0x99
block|,
literal|150
block|}
block|,
block|{
literal|0xaa
block|,
literal|200
block|}
block|,
block|{
literal|0xbb
block|,
literal|250
block|}
block|,
block|{
literal|0xcc
block|,
literal|300
block|}
block|,
block|{
literal|0xdd
block|,
literal|350
block|}
block|,
block|{
literal|0xee
block|,
literal|400
block|}
block|,
block|{
literal|0xff
block|,
literal|450
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|aha_set_bus_speed
parameter_list|(
name|aha
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
block|{
name|int
name|speed
decl_stmt|;
name|int
name|lastworking
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|retval2
decl_stmt|;
name|lastworking
operator|=
operator|-
literal|1
expr_stmt|;
name|speed
operator|=
literal|7
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|retval
operator|=
name|aha_bus_speed_check
argument_list|(
name|aha
argument_list|,
name|speed
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
name|lastworking
operator|=
name|speed
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|retval
operator|==
literal|0
operator|)
operator|||
operator|(
name|speed
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|lastworking
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"No working bus speed for aha154X\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"%d nSEC ok, using "
argument_list|,
name|aha_bus_speeds
index|[
name|lastworking
index|]
operator|.
name|nsecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastworking
operator|==
literal|7
condition|)
block|{
comment|/* is slowest already */
name|printf
argument_list|(
literal|"marginal "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lastworking
operator|++
expr_stmt|;
block|}
name|retval2
operator|=
name|aha_bus_speed_check
argument_list|(
name|aha
argument_list|,
name|lastworking
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval2
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test retry failed.. aborting.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|printf
argument_list|(
literal|"%d nSEC\n"
argument_list|,
name|retval2
argument_list|)
expr_stmt|;
return|return
name|retval2
return|;
block|}
name|speed
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the DMA speed to the Nth speed and try an xfer. If it  * fails return 0, if it succeeds return the nSec value selected  * If there is no such speed return HAD_ERROR.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|aha_test_string
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz!@"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|aha_scratch_buf
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|aha_bus_speed_check
parameter_list|(
name|aha
parameter_list|,
name|speed
parameter_list|)
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|int
name|speed
decl_stmt|;
block|{
name|int
name|numspeeds
init|=
sizeof|sizeof
argument_list|(
name|aha_bus_speeds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bus_speed
argument_list|)
decl_stmt|;
name|int
name|loopcount
decl_stmt|;
name|u_char
name|ad
index|[
literal|3
index|]
decl_stmt|;
comment|/* 	 * Check we have such an entry 	 */
if|if
condition|(
name|speed
operator|>=
name|numspeeds
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
comment|/* illegal speed */
comment|/* 	 * Set the dma-speed 	 */
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_SPEED_SET
argument_list|,
name|aha_bus_speeds
index|[
name|speed
index|]
operator|.
name|arg
argument_list|)
expr_stmt|;
comment|/* 	 * put the test data into the buffer and calculate 	 * it's address. Read it onto the board 	 */
name|scsi_uto3b
argument_list|(
name|KVTOPHYS
argument_list|(
name|aha_scratch_buf
argument_list|)
argument_list|,
name|ad
argument_list|)
expr_stmt|;
for|for
control|(
name|loopcount
operator|=
literal|2000
init|;
name|loopcount
condition|;
name|loopcount
operator|--
control|)
block|{
name|strcpy
argument_list|(
name|aha_scratch_buf
argument_list|,
name|aha_test_string
argument_list|)
expr_stmt|;
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_WRITE_FIFO
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 	* clear the buffer then copy the contents back from the 	 	* board. 	 	*/
name|bzero
argument_list|(
name|aha_scratch_buf
argument_list|,
literal|54
argument_list|)
expr_stmt|;
comment|/* 54 bytes transfered by test */
name|aha_cmd
argument_list|(
name|aha
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|AHA_READ_FIFO
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 	* Compare the original data and the final data and 	 	* return the correct value depending upon the result 	 	*/
if|if
condition|(
name|strcmp
argument_list|(
name|aha_test_string
argument_list|,
name|aha_scratch_buf
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* failed test */
block|}
comment|/* copy succeded assume speed ok */
return|return
operator|(
name|aha_bus_speeds
index|[
name|speed
index|]
operator|.
name|nsecs
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*TUNE_1542*/
end_comment

begin_function
specifier|static
name|void
name|aha_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|aha_ccb
modifier|*
name|ccb
init|=
operator|(
expr|struct
name|aha_ccb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|struct
name|aha_data
modifier|*
name|aha
decl_stmt|;
name|aha
operator|=
operator|(
expr|struct
name|aha_data
operator|*
operator|)
name|ccb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|sc_print_addr
argument_list|(
name|ccb
operator|->
name|xfer
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timed out "
argument_list|)
expr_stmt|;
comment|/* 	 * If The ccb's mbx is not free, then 	 * the board has gone south 	 */
if|if
condition|(
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|!=
name|AHA_MBO_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"\nadapter not taking commands.. frozen?!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"aha1542 frozen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * If it has been through before, then 	 * a previous abort has failed, don't 	 * try abort again 	 */
if|if
condition|(
name|ccb
operator|->
name|flags
operator|==
name|CCB_ABORTED
condition|)
block|{
comment|/* abort timed out */
name|printf
argument_list|(
literal|" AGAIN\n"
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ccb
operator|->
name|host_stat
operator|=
name|AHA_ABORTED
expr_stmt|;
name|aha_done
argument_list|(
name|aha
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|aha_abortmbx
argument_list|(
name|ccb
operator|->
name|mbx
argument_list|)
expr_stmt|;
comment|/* 4 secs for the abort */
name|timeout
argument_list|(
name|aha_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|4
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_ABORTED
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

end_unit

