begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1993, 1994, 1995  *	Rodney W. Grimes, Milwaukie, Oregon  97222.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer as  *    the first lines of this file unmodified.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Rodney W. Grimes.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY RODNEY W. GRIMES ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL RODNEY W. GRIMES BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"ix.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_comment
comment|/*ZZZ no work done on this, this is just here to remind me*/
end_comment

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_comment
comment|/*ZZZ no work done on this, this is just here to remind me*/
end_comment

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|all_es_snpa
index|[]
decl_stmt|,
name|all_is_snpa
index|[]
decl_stmt|,
name|all_l1is_snpa
index|[]
decl_stmt|,
name|all_l2is_snpa
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

begin_comment
comment|/*ZZZ no work done on this, this is just here to remind me*/
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NBPFILTER> 0 */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_ixreg.h>
end_include

begin_decl_stmt
name|ix_softc_t
name|ix_softc
index|[
name|NIX
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUGNONE
value|0x0000
end_define

begin_define
define|#
directive|define
name|DEBUGPROBE
value|0x0001
end_define

begin_define
define|#
directive|define
name|DEBUGATTACH
value|(DEBUGPROBE<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINIT
value|(DEBUGATTACH<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINIT_RFA
value|(DEBUGINIT<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINIT_TFA
value|(DEBUGINIT_RFA<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINTR
value|(DEBUGINIT_TFA<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINTR_FR
value|(DEBUGINTR<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGINTR_CX
value|(DEBUGINTR_FR<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGSTART
value|(DEBUGINTR_CX<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGSTOP
value|(DEBUGSTART<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGRESET
value|(DEBUGSTOP<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGDONE
value|(DEBUGRESET<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGIOCTL
value|(DEBUGDONE<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGACK
value|(DEBUGIOCTL<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGCA
value|(DEBUGACK<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGCB_WAIT
value|(DEBUGCA<< 1)
end_define

begin_define
define|#
directive|define
name|DEBUGALL
value|0xFFFFFFFF
end_define

begin_comment
comment|/* #define IXDEBUG	(DEBUGPROBE | DEBUGINIT | DEBUGSTOP | DEBUGCB_WAIT) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IXDEBUG
end_ifdef

begin_decl_stmt
name|int
name|ixdebug
init|=
name|IXDEBUG
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEBUGBEGIN
parameter_list|(
name|flag
parameter_list|)
define|\
value|{\ 	if (ixdebug& flag)\ 		{
end_define

begin_define
define|#
directive|define
name|DEBUGEND
define|\
value|}\ 	}
end_define

begin_define
define|#
directive|define
name|DEBUGDO
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IXDEBUG */
end_comment

begin_define
define|#
directive|define
name|DEBUGBEGIN
parameter_list|(
name|flag
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DEBUGEND
end_define

begin_define
define|#
directive|define
name|DEBUGDO
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXDEBUG */
end_comment

begin_comment
comment|/*  * Enable the exteneded ixcounters by using #define IXCOUNTERS, note that  * this requires a modification to the ifnet structure to add the counters  * in.  Some day a standard extended ifnet structure will be done so that  * additional statistics can be gathered for any board that supports these  * counters.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IXCOUNTERS
end_ifdef

begin_define
define|#
directive|define
name|IXCOUNTER
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IXCOUNTERS */
end_comment

begin_define
define|#
directive|define
name|IXCOUNTER
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IXCOUNTERS */
end_comment

begin_comment
comment|/*  * Function Prototypes  */
end_comment

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixinterrupt_enable
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixinterrupt_disable
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixchannel_attention
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|ixacknowledge
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ix_cb_wait
parameter_list|(
name|cb_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ix_scb_wait
parameter_list|(
name|scb_t
modifier|*
parameter_list|,
name|u_short
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixinit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixinit_rfa
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixinit_tfa
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|inthand2_t
name|ixintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixintr_cx
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixintr_cx_free
parameter_list|(
name|int
parameter_list|,
name|cb_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixintr_fr
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixintr_fr_copy
parameter_list|(
name|int
parameter_list|,
name|rfd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|ixintr_fr_free
parameter_list|(
name|int
parameter_list|,
name|rfd_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixstart
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixstop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixdone
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixreset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixwatchdog
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_short
name|ixeeprom_read
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixeeprom_outbits
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ixeeprom_inbits
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ixeeprom_clock
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* RRR */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|ixdriver
init|=
block|{
name|ixprobe
block|,
name|ixattach
block|,
literal|"ix"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_ix_template
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"ix"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"net"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
comment|/* state */
literal|""
block|,
comment|/* description */
name|DC_CLS_NETIF
comment|/* class */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|ix_registerdev
parameter_list|(
name|struct
name|isa_device
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|)
block|{
name|struct
name|kern_devconf
modifier|*
name|kdc
init|=
operator|&
name|ix_softc
index|[
name|id
operator|->
name|id_unit
index|]
operator|.
name|kdc
decl_stmt|;
name|char
modifier|*
name|longdescr
decl_stmt|;
operator|*
name|kdc
operator|=
name|kdc_ix_template
expr_stmt|;
name|kdc
operator|->
name|kdc_unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|kdc
operator|->
name|kdc_parentdata
operator|=
name|id
expr_stmt|;
name|kdc
operator|->
name|kdc_description
operator|=
name|descr
expr_stmt|;
name|dev_attach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable the interrupt signal on the board so that it may interrupt  * the host.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixinterrupt_enable
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|sel_irq
argument_list|,
name|sc
operator|->
name|irq_encoded
operator||
name|IRQ_ENABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Disable the interrupt signal on the board so that it will not interrupt  * the host.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixinterrupt_disable
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|sel_irq
argument_list|,
name|sc
operator|->
name|irq_encoded
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a channel attention to the 82586 chip  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ixchannel_attention
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGCA
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ca"
argument|);
argument_list|)
name|DEBUGEND
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ca_ctrl
argument_list|,
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|u_short
name|ixacknowledge
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|SCB_ADDR
operator|)
decl_stmt|;
name|u_short
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGACK
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ack:"
argument|);
argument_list|)
name|DEBUGEND
name|status
init|=
name|scb
operator|->
name|status
decl_stmt|;
name|scb
operator|->
name|command
operator|=
name|status
operator|&
name|SCB_ACK_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SCB_ACK_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|scb
operator|->
name|command
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
comment|/*ZZZ timeout*/
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|".TO=%x:"
argument_list|,
name|scb
operator|->
name|command
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nshutting down\n"
argument_list|)
expr_stmt|;
name|ixinterrupt_disable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|IXF_NONE
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGACK
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|".ok:"
argument|);
argument_list|)
name|DEBUGEND
block|}
block|}
else|else
block|{
comment|/* nothing to acknowledge */
name|DEBUGBEGIN
argument_list|(
argument|DEBUGACK
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"NONE:"
argument|);
argument_list|)
name|DEBUGEND
block|}
name|DEBUGBEGIN
argument_list|(
argument|DEBUGACK
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"%x "
argument|, status);
argument_list|)
name|DEBUGEND
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ix_cb_wait
parameter_list|(
name|cb_t
modifier|*
name|cb
parameter_list|,
name|char
modifier|*
name|message
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_COMPLETE
condition|)
break|break;
comment|/* Wait for done */
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s timeout cb->status = %x\n"
argument_list|,
name|message
argument_list|,
name|cb
operator|->
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGCB_WAIT
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"%s cb ok count = %d\n"
argument|, message, i);
argument_list|)
name|DEBUGEND
name|status
init|=
literal|0
decl_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ix_scb_wait
parameter_list|(
name|scb_t
modifier|*
name|scb
parameter_list|,
name|u_short
name|expect
parameter_list|,
name|char
modifier|*
name|message
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1000000
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|scb
operator|->
name|status
operator|==
name|expect
condition|)
break|break;
comment|/* Wait for done */
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s timeout scb->status = %x\n"
argument_list|,
name|message
argument_list|,
name|scb
operator|->
name|status
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"%s scb ok count = %d\n"
argument|, message, i);
argument_list|)
name|DEBUGEND
name|status
init|=
literal|0
decl_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|char
name|tempid
decl_stmt|,
name|idstate
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|u_short
name|boardid
decl_stmt|,
name|checksum
decl_stmt|,
name|connector
decl_stmt|,
name|eaddrtemp
decl_stmt|,
name|irq
decl_stmt|;
comment|/* ZZZ irq_translate should really be unsigned, but until 	 * isa_device.h and all uses are fixed we have to live with it */
name|short
name|irq_translate
index|[]
init|=
block|{
literal|0
block|,
name|IRQ9
block|,
name|IRQ3
block|,
name|IRQ4
block|,
name|IRQ5
block|,
name|IRQ10
block|,
name|IRQ11
block|,
literal|0
block|}
decl_stmt|;
name|char
name|irq_encode
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|5
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"ixprobe:"
argument|);
argument_list|)
name|DEBUGEND
comment|/* 	 * Since Intel gives us such a nice way to ID this board lets 	 * see if we really have one at this I/O address 	 */
name|idstate
init|=
name|inb
argument_list|(
name|dvp
operator|->
name|id_iobase
operator|+
name|autoid
argument_list|)
operator|&
literal|0x03
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|boardid
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|tempid
operator|=
name|inb
argument_list|(
name|dvp
operator|->
name|id_iobase
operator|+
name|autoid
argument_list|)
expr_stmt|;
name|boardid
operator||=
operator|(
operator|(
name|tempid
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
operator|)
operator|<<
operator|(
operator|(
name|tempid
operator|&
literal|0x03
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|tempid
operator|&
literal|0x03
operator|)
operator|!=
operator|(
operator|++
name|idstate
operator|&
literal|0x03
operator|)
condition|)
block|{
comment|/* out of sequence, destroy boardid and bail out */
name|boardid
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"boardid = %x\n"
argument|, boardid);
argument_list|)
name|DEBUGEND
if|if
condition|(
name|boardid
operator|!=
name|BOARDID
condition|)
block|{
goto|goto
name|ixprobe_exit
goto|;
block|}
comment|/* 	 * We now know that we have a board, so save the I/O base 	 * address in the softc and use the softc from here on out 	 */
name|sc
operator|->
name|iobase
operator|=
name|dvp
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * Reset the Bart ASIC by pulsing the reset bit and waiting 	 * the required 240 uSecounds.  Also place the 82856 in the reset 	 * mode so that we can access the EEPROM 	 */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|GA_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ee_ctrl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|240
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|I586_RESET
argument_list|)
expr_stmt|;
comment|/* 	 * Checksum the EEPROM, should be equal to BOARDID 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|checksum
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|+=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"checksum = %x\n"
argument|, checksum);
argument_list|)
name|DEBUGEND
if|if
condition|(
name|checksum
operator|!=
name|BOARDID
condition|)
block|{
goto|goto
name|ixprobe_exit
goto|;
block|}
comment|/* 	 * Do the I/O channel ready test 	 */
block|{
name|u_char
name|lock_bit
decl_stmt|;
name|lock_bit
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_lock_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_bit
operator|&
name|EEPROM_LOCKED
condition|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"lockbit set, no doing io channel ready test\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
else|else
block|{
name|u_char
name|bart_config
decl_stmt|,
name|junk
decl_stmt|;
name|bart_config
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
expr_stmt|;
name|bart_config
operator||=
name|BART_IOCHRDY_LATE
operator||
name|BART_IO_TEST_EN
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
name|junk
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
literal|0x4000
argument_list|)
expr_stmt|;
comment|/*XXX read junk */
name|bart_config
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|,
name|bart_config
operator|&
operator|~
operator|(
name|BART_IO_TEST_EN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bart_config
operator|&
name|BART_IO_RESULT
condition|)
block|{
name|printf
argument_list|(
literal|"iochannel ready test failed!!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"iochannel ready test passed\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
block|}
block|}
comment|/* 	 * Size and test the memory on the board.  The size of the memory 	 * can be one of 16k, 32k, 48k or 64k.  It can be located in the 	 * address range 0xC0000 to 0xEFFFF on 16k boundaries.  Although 	 * the board can be configured for 0xEC0000 to 0xEEFFFF, 	 * or 0xFC0000 to 0xFFFFFF these ranges are not supported by 386bsd. 	 * 	 * If the size does not match the passed in memory allocation size 	 * issue a warning, but continue with the minimum of the two sizes. 	 */
block|{
name|u_short
name|memory_page
decl_stmt|;
name|u_short
name|memory_adjust
decl_stmt|;
name|u_short
name|memory_decode
decl_stmt|;
name|u_short
name|memory_edecode
decl_stmt|;
switch|switch
condition|(
name|dvp
operator|->
name|id_msize
condition|)
block|{
case|case
literal|65536
case|:
case|case
literal|32768
case|:
comment|/* XXX Only support 32k and 64k right now */
block|{
break|break;
block|}
case|case
literal|16384
case|:
case|case
literal|49512
case|:
default|default:
block|{
name|printf
argument_list|(
literal|"ixprobe mapped memory size out of range\n"
argument_list|)
expr_stmt|;
goto|goto
name|ixprobe_exit
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|<
literal|0xC0000
operator|)
operator|||
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|+
name|dvp
operator|->
name|id_msize
operator|>
literal|0xF0000
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ixprobe mapped memory address out of range\n"
argument_list|)
expr_stmt|;
goto|goto
name|ixprobe_exit
goto|;
block|}
name|memory_page
operator|=
operator|(
name|kvtop
argument_list|(
name|dvp
operator|->
name|id_maddr
argument_list|)
operator|&
literal|0x3C000
operator|)
operator|>>
literal|14
expr_stmt|;
name|memory_adjust
operator|=
name|MEMCTRL_FMCS16
operator||
operator|(
name|memory_page
operator|&
literal|0x3
operator|)
operator|<<
literal|2
expr_stmt|;
name|memory_decode
operator|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|dvp
operator|->
name|id_msize
operator|/
literal|16384
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|memory_page
expr_stmt|;
name|memory_edecode
operator|=
operator|(
operator|(
operator|~
name|memory_decode
operator|>>
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|memory_decode
operator|>>
literal|8
operator|)
expr_stmt|;
comment|/* ZZZ This should be checked against eeprom location 6, low byte */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|memdec
argument_list|,
name|memory_decode
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* ZZZ This should be checked against eeprom location 1, low byte */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|memctrl
argument_list|,
name|memory_adjust
argument_list|)
expr_stmt|;
comment|/* ZZZ Now if I could find this one I would have it made */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|mempc
argument_list|,
operator|(
operator|~
name|memory_decode
operator|&
literal|0xFF
operator|)
argument_list|)
expr_stmt|;
comment|/* ZZZ I think this is location 6, high byte */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|memectrl
argument_list|,
name|memory_edecode
argument_list|)
expr_stmt|;
comment|/*XXX disable Exxx */
name|sc
operator|->
name|maddr
operator|=
name|dvp
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|msize
operator|=
name|dvp
operator|->
name|id_msize
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"Physical address = %lx\n"
argument|, kvtop(sc->maddr));
argument_list|)
name|DEBUGEND
block|}
comment|/* 	 * first prime the stupid bart DRAM controller so that it 	 * works, then zero out all or memory. 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|maddr
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|maddr
argument_list|,
name|sc
operator|->
name|msize
argument_list|)
expr_stmt|;
comment|/* 	 * Get the type of connector used, either AUI, BNC or TPE. 	 */
name|connector
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_config1
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|&
name|CONNECT_BNCTPE
condition|)
block|{
name|connector
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_config2
argument_list|)
expr_stmt|;
if|if
condition|(
name|connector
operator|&
name|CONNECT_TPE
condition|)
block|{
name|sc
operator|->
name|connector
operator|=
name|TPE
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"Using TPE connector\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
else|else
block|{
name|sc
operator|->
name|connector
operator|=
name|BNC
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"Using BNC connector\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
block|}
else|else
block|{
name|sc
operator|->
name|connector
operator|=
name|AUI
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"Using AUI connector\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
comment|/* 	 * Get the encoded interrupt number from the EEPROM, check it 	 * against the passed in IRQ.  Issue a warning if they do not 	 * match.  Always use the passed in IRQ, not the one in the EEPROM. 	 */
name|irq
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_config1
argument_list|)
expr_stmt|;
name|irq
operator|=
operator|(
name|irq
operator|&
name|IRQ
operator|)
operator|>>
name|IRQ_SHIFT
expr_stmt|;
name|irq
operator|=
name|irq_translate
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_irq
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|irq
operator|!=
name|dvp
operator|->
name|id_irq
condition|)
block|{
name|printf
argument_list|(
literal|"ix%d: WARNING: board is configured for IRQ %d, using %d\n"
argument_list|,
name|unit
argument_list|,
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
argument_list|,
name|ffs
argument_list|(
name|dvp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|irq
operator|=
name|dvp
operator|->
name|id_irq
expr_stmt|;
block|}
block|}
else|else
block|{
name|dvp
operator|->
name|id_irq
operator|=
name|irq
expr_stmt|;
block|}
name|sc
operator|->
name|irq_encoded
operator|=
name|irq_encode
index|[
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irq_encoded
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ix%d: invalid irq (%d)\n"
argument_list|,
name|ffs
argument_list|(
name|irq
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|ixprobe_exit
goto|;
block|}
comment|/* 	 * Get the slot width, either 8 bit or 16 bit. 	 */
if|if
condition|(
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
operator|&
name|SLOT_WIDTH
condition|)
block|{
name|sc
operator|->
name|width
operator|=
name|WIDTH_16
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"Using 16-bit slot\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
else|else
block|{
name|sc
operator|->
name|width
operator|=
name|WIDTH_8
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"Using 8-bit slot\n"
argument|);
argument_list|)
name|DEBUGEND
block|}
comment|/* 	 * Get the hardware ethernet address from the EEPROM and 	 * save it in the softc for use by the 586 setup code. 	 */
name|eaddrtemp
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_enetaddr_high
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|1
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|0
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
name|eaddrtemp
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_enetaddr_mid
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|3
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|2
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
name|eaddrtemp
operator|=
name|ixeeprom_read
argument_list|(
name|unit
argument_list|,
name|eeprom_enetaddr_low
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|5
index|]
operator|=
name|eaddrtemp
operator|&
literal|0xFF
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
literal|4
index|]
operator|=
name|eaddrtemp
operator|>>
literal|8
expr_stmt|;
name|sc
operator|->
name|flags
operator|=
name|IXF_NONE
expr_stmt|;
comment|/* make sure the flag word is NONE */
name|status
operator|=
name|IX_IO_PORTS
expr_stmt|;
ifndef|#
directive|ifndef
name|DEV_LKM
name|ix_registerdev
argument_list|(
name|dvp
argument_list|,
literal|"Ethernet adapter: Intel EtherExpress16"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not DEV_LKM */
name|ixprobe_exit
label|:
name|DEBUGBEGIN
argument_list|(
argument|DEBUGPROBE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"ixprobe exited\n"
argument|);
argument_list|)
name|DEBUGEND
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ixattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dvp
operator|->
name|id_unit
decl_stmt|;
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGATTACH
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixattach:"
argument|);
argument_list|)
name|DEBUGEND
comment|/* 	 * Fill in the interface parameters for if_attach 	 * Note:  We could save some code here by first using a 	 *        bzero(ifp, sizeof(ifp)); and then not doing all 	 *        the = 0;'s 	 *        Infact we should bzero this just to make sure 	 *        that something does not get missed. 	 */
name|bzero
argument_list|(
name|ifp
argument_list|,
sizeof|sizeof
argument_list|(
name|ifp
argument_list|)
argument_list|)
decl_stmt|;
name|ifp
operator|->
name|if_name
operator|=
name|ixdriver
operator|.
name|name
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_NOTRAILERS
operator||
name|IFF_BROADCAST
expr_stmt|;
comment|/* 	 * This is commented out to save memory and cpu time 	 * ifp->if_timer = 0; 	 * ifp->if_metric = 0; 	 * ifp->if_addrlist = 0; 	 * ifp->if_snd.ifq_head = 0; 	 * ifp->if_snd.ifq_tail = 0; 	 * ifp->if_snd.ifq_len = 0; 	 * ifp->if_snd.ifq_maxlen = 0; 	 * ifp->if_snd.ifq_drops = 0; 	 * end of commented out block 	 */
name|ifp
operator|->
name|if_init
operator|=
name|ixinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ixstart
expr_stmt|;
name|ifp
operator|->
name|if_done
operator|=
name|ixdone
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ixioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|ixreset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|ixwatchdog
expr_stmt|;
comment|/* 	 * This is commented out to save memory and cpu time 	 * ifp->if_ipackets = 0; 	 * ifp->if_ierrors = 0; 	 * ifp->if_opackets = 0; 	 * ifp->if_oerrors = 0; 	 * ifp->if_collisions = 0; 	 * ifp->if_next = 0; 	 * end of commented out block 	 */
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
name|ETHER_ADDRESS_LENGTH
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ETHER_HEADER_LENGTH
expr_stmt|;
comment|/* 	 * This is commented out to save memory and cpu time 	 * ifp->if_index = 0; 	 * ifp->if_lastchange.tv_sec = 0; 	 * ifp->if_lastchange.tv_usec = 0; 	 * ifp->if_ibytes = 0; 	 * ifp->if_obytes = 0; 	 * ifp->if_imcasts = 0; 	 * ifp->if_omcasts = 0; 	 * ifp->if_iqdrops = 0; 	 * ifp->if_noproto = 0; 	 * ifp->if_baudrate = 0;          * ifp->if_pcount = 0; 	 * end of commented out block 	 */
ifdef|#
directive|ifdef
name|IXCOUNTERS
comment|/* 	  * ZZZ more counters added, but bzero gets them 	  */
endif|#
directive|endif
comment|/* IXCOUNTERS */
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|kdc
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
comment|/* Search down the ifa address list looking for the AF_LINK type entry */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
block|{
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
block|}
comment|/* If we find an AF_LINK type entry, we well fill in the hardware addr */
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fill in the link level address for this interface */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDRESS_LENGTH
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDRESS_LENGTH
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ix%d: address %s\n"
argument_list|,
name|unit
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixinit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|scp_t
modifier|*
name|scp
init|=
operator|(
name|scp_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|SCP_ADDR
operator|)
decl_stmt|;
name|iscp_t
modifier|*
name|iscp
init|=
operator|(
name|iscp_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|ISCP_ADDR
operator|)
decl_stmt|;
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|SCB_ADDR
operator|)
decl_stmt|;
name|cb_t
modifier|*
name|cb
decl_stmt|;
name|tbd_t
modifier|*
name|tbd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_char
name|bart_config
decl_stmt|;
comment|/* bart config byte */
name|int
name|status
init|=
literal|0
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixinit:"
argument|);
argument_list|)
name|DEBUGEND
name|sc
operator|->
name|kdc
operator|.
name|kdc_state
init|=
name|DC_BUSY
decl_stmt|;
comment|/* Put bart into loopback until we are done intializing to 	 * make sure that packets don't hit the wire */
name|bart_config
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
expr_stmt|;
name|bart_config
operator||=
name|BART_LOOPBACK
expr_stmt|;
name|bart_config
operator||=
name|BART_MCS16_TEST
expr_stmt|;
comment|/* inb does not get this bit! */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
name|bart_config
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
expr_stmt|;
name|scp
operator|->
name|unused1
operator|=
literal|0
expr_stmt|;
comment|/* Intel says to put zeros in it */
name|scp
operator|->
name|sysbus
operator|=
name|sc
operator|->
name|width
expr_stmt|;
comment|/* ZZZ need to fix for 596 */
name|scp
operator|->
name|unused2
operator|=
literal|0
expr_stmt|;
comment|/* Intel says to put zeros in it */
name|scp
operator|->
name|unused3
operator|=
literal|0
expr_stmt|;
comment|/* Intel says to put zeros in it */
name|scp
operator|->
name|iscp
operator|=
name|ISCP_ADDR
expr_stmt|;
name|iscp
operator|->
name|busy
operator|=
name|ISCP_BUSY
expr_stmt|;
name|iscp
operator|->
name|scb_offset
operator|=
name|SCB_ADDR
expr_stmt|;
name|iscp
operator|->
name|scb_base
operator|=
name|TFA_START
expr_stmt|;
name|scb
operator|->
name|status
operator|=
name|SCB_STAT_NULL
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_RESET
expr_stmt|;
name|scb
operator|->
name|cbl_offset
operator|=
name|TFA_START
expr_stmt|;
name|scb
operator|->
name|rfa_offset
operator|=
name|RFA_START
expr_stmt|;
name|scb
operator|->
name|crc_errors
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|aln_errors
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|rsc_errors
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|ovr_errors
operator|=
literal|0
expr_stmt|;
name|ixinit_tfa
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|ixinit_rfa
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cb
operator|=
name|sc
operator|->
name|cb_head
expr_stmt|;
name|tbd
operator|=
name|sc
operator|->
name|tbd_head
expr_stmt|;
comment|/* 	 * remove the reset signal and start the 586 up, the 586 well read          * the SCP, ISCP and the reset CB.  This should put it into a 	 * known state: RESET! 	 */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|EENORMAL
argument_list|)
expr_stmt|;
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|100000
init|;
name|iscp
operator|->
name|busy
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
comment|/* Wait for done */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"iscp->busy time out\n"
argument_list|)
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf (
literal|"iscp->busy did not timeout = %d\n"
argument|, i);
argument_list|)
name|DEBUGEND
block|}
name|status
operator||=
name|ix_scb_wait
argument_list|(
name|scb
argument_list|,
call|(
name|u_short
call|)
argument_list|(
name|SCB_STAT_CX
operator||
name|SCB_STAT_CNA
argument_list|)
argument_list|,
literal|"Reset"
argument_list|)
expr_stmt|;
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* XXX this belongs some place else, run diagnostics on the 586 */
block|{
name|cb_diagnose_t
modifier|*
name|cb_diag
init|=
operator|(
name|cb_diagnose_t
operator|*
operator|)
operator|(
name|cb
operator|)
decl_stmt|;
name|cb_diag
operator|->
name|common
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|cb_diag
operator|->
name|common
operator|.
name|command
operator|=
name|CB_CMD_EL
operator||
name|CB_CMD_DIAGNOSE
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_CUC_START
expr_stmt|;
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_cb_wait
argument_list|(
operator|(
name|cb_t
operator|*
operator|)
name|cb_diag
argument_list|,
literal|"Diagnose"
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_scb_wait
argument_list|(
name|scb
argument_list|,
operator|(
name|u_short
operator|)
name|SCB_STAT_CNA
argument_list|,
literal|"Diagnose"
argument_list|)
expr_stmt|;
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* XXX end this belongs some place else, run diagnostics on the 586 */
comment|/* XXX this belongs some place else, run configure on the 586 */
block|{
name|cb_configure_t
modifier|*
name|cb_conf
init|=
operator|(
name|cb_configure_t
operator|*
operator|)
operator|(
name|cb
operator|)
decl_stmt|;
name|cb_conf
operator|->
name|common
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|cb_conf
operator|->
name|common
operator|.
name|command
operator|=
name|CB_CMD_EL
operator||
name|CB_CMD_CONF
expr_stmt|;
name|cb_conf
operator|->
name|byte
index|[
literal|0
index|]
operator|=
literal|12
expr_stmt|;
comment|/* 12 byte configure block */
name|cb_conf
operator|->
name|byte
index|[
literal|1
index|]
operator|=
literal|8
expr_stmt|;
comment|/* fifo limit at 8 bytes */
name|cb_conf
operator|->
name|byte
index|[
literal|2
index|]
operator|=
literal|0x40
expr_stmt|;
comment|/* don't save bad frames, 					   srdy/ardy is srdy */
name|cb_conf
operator|->
name|byte
index|[
literal|3
index|]
operator|=
literal|0x2E
expr_stmt|;
comment|/* address length is 6 bytes, 					   address and length are in tb, 					   preamble length is 8 bytes, 					   internal loopback off, 					   external loopback off */
name|cb_conf
operator|->
name|byte
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* linear priority is 0, 					   ACR (Exponential priorty) is 0, 					   exponential backoff is 802.3 */
name|cb_conf
operator|->
name|byte
index|[
literal|5
index|]
operator|=
literal|96
expr_stmt|;
comment|/* interframe spacing in TxC clocks */
name|cb_conf
operator|->
name|byte
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
comment|/* lower 8 bits of slot time */
name|cb_conf
operator|->
name|byte
index|[
literal|7
index|]
operator|=
literal|0xf2
expr_stmt|;
comment|/* upper slot time (512 bits), 					   15 transmision retries */
name|cb_conf
operator|->
name|byte
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
comment|/* promiscuous mode off, 					   broadcast enabled, 					   nrz encodeing, 					   cease transmission if ^CRS, 					   insert crc, 					   end of carrier mode bit stuffing, 					   no padding */
name|cb_conf
operator|->
name|byte
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
comment|/* carrier sense filter = 0 bits, 					   carrier sense source external, 					   collision detect filter = 0 bits, 					   collision detect source external */
name|cb_conf
operator|->
name|byte
index|[
literal|10
index|]
operator|=
literal|60
expr_stmt|;
comment|/* minimum number of bytes is a frame */
name|cb_conf
operator|->
name|byte
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
comment|/* unused */
name|scb
operator|->
name|command
operator|=
name|SCB_CUC_START
expr_stmt|;
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_cb_wait
argument_list|(
operator|(
name|cb_t
operator|*
operator|)
name|cb_conf
argument_list|,
literal|"Configure"
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_scb_wait
argument_list|(
name|scb
argument_list|,
operator|(
name|u_short
operator|)
name|SCB_STAT_CNA
argument_list|,
literal|"Configure"
argument_list|)
expr_stmt|;
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* XXX end this belongs some place else, run configure on the 586 */
comment|/* XXX this belongs some place else, run ias on the 586 */
block|{
name|cb_ias_t
modifier|*
name|cb_ias
init|=
operator|(
name|cb_ias_t
operator|*
operator|)
operator|(
name|cb
operator|)
decl_stmt|;
name|cb_ias
operator|->
name|common
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|cb_ias
operator|->
name|common
operator|.
name|command
operator|=
name|CB_CMD_EL
operator||
name|CB_CMD_IAS
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|cb_ias
operator|->
name|source
argument_list|,
name|ETHER_ADDRESS_LENGTH
argument_list|)
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_CUC_START
expr_stmt|;
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_cb_wait
argument_list|(
operator|(
name|cb_t
operator|*
operator|)
name|cb_ias
argument_list|,
literal|"IAS"
argument_list|)
expr_stmt|;
name|status
operator||=
name|ix_scb_wait
argument_list|(
name|scb
argument_list|,
operator|(
name|u_short
operator|)
name|SCB_STAT_CNA
argument_list|,
literal|"IAS"
argument_list|)
expr_stmt|;
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/* XXX end this belongs some place else, run ias on the 586 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* Take bart out of loopback as we are done intializing */
name|bart_config
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|)
expr_stmt|;
name|bart_config
operator|&=
operator|~
name|BART_LOOPBACK
expr_stmt|;
name|bart_config
operator||=
name|BART_MCS16_TEST
expr_stmt|;
comment|/* inb does not get this bit! */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|config
argument_list|,
name|bart_config
argument_list|)
expr_stmt|;
comment|/* The above code screwed with the tfa, reinit it! */
name|ixinit_tfa
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_RUC_START
expr_stmt|;
comment|/* start up the receive unit */
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|flags
operator||=
name|IXF_INITED
expr_stmt|;
comment|/* we have been initialized */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|ixinterrupt_enable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Let err fly!!! */
block|}
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixinit exited\n"
argument|);
argument_list|)
name|DEBUGEND
return|return;
block|}
end_function

begin_comment
comment|/*  * ixinit_rfa(int unit)  *  *	This routine initializes the Receive Frame Area for the 82586  *  * input	the unit number to build the RFA for  * access	the softc for memory address  * output	an initialized RFA, ready for packet receiption  *		the following queue pointers in the softc structure are  *		also initialize  *		sc->rfd_head		sc->rfd_tail  *		sc->rbd_head		sc->rbd_tail  * defines	RFA_START	the starting offset of the RFA  *		RFA_SIZE	size of the RFA area  *		RB_SIZE		size of the receive buffer, this must  *				be even and should be greater than the  *				minumum packet size and less than the  *				maximum packet size  */
end_comment

begin_function
name|void
name|ixinit_rfa
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|rfd_t
modifier|*
name|rfd
decl_stmt|;
name|rbd_t
modifier|*
name|rbd
decl_stmt|;
name|caddr_t
name|rb
decl_stmt|;
name|int
name|i
decl_stmt|,
name|complete_frame_size
decl_stmt|,
name|how_many_frames
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT_RFA
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"\nix%d: ixinit_rfa\n"
argument|, unit);
argument_list|)
name|DEBUGEND
name|complete_frame_size
init|=
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|+
name|RB_SIZE
decl_stmt|;
name|how_many_frames
operator|=
name|RFA_SIZE
operator|/
name|complete_frame_size
expr_stmt|;
comment|/* build the list of rfd's, rbd's and rb's */
name|rfd
operator|=
operator|(
name|rfd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|)
expr_stmt|;
name|rbd
operator|=
operator|(
name|rbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|+
operator|(
name|how_many_frames
operator|*
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|rb
operator|=
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|+
operator|(
name|how_many_frames
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|rfd_head
operator|=
name|rfd
expr_stmt|;
name|sc
operator|->
name|rbd_head
operator|=
name|rbd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|how_many_frames
condition|;
name|i
operator|++
operator|,
name|rfd
operator|++
operator|,
name|rbd
operator|++
operator|,
name|rb
operator|+=
name|RB_SIZE
control|)
block|{
name|rfd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|rfd
operator|->
name|command
operator|=
literal|0
expr_stmt|;
name|rfd
operator|->
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|rfd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
expr_stmt|;
name|rfd
operator|->
name|rbd_offset
operator|=
name|INTEL586NULL
expr_stmt|;
comment|/* ZZZ could bzero this, but just leave a note for now */
comment|/* ZZZ bzero(rfd->destination); */
comment|/* ZZZ bzero(rfd->source); */
name|rfd
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|rbd
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|rbd
operator|->
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|rbd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|buffer
operator|=
name|KVTOBOARD
argument_list|(
name|rb
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|size
operator|=
name|RB_SIZE
expr_stmt|;
comment|/* 		 * handle the boundary conditions here.  for the zeroth 		 * rfd we must set the rbd_offset to point at the zeroth 		 * rbd.  for the last rfd and rbd we need to close the 		 * list into a ring and set the end of list bits. 		 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|rfd
operator|->
name|rbd_offset
operator|=
name|KVTOBOARD
argument_list|(
name|rbd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|how_many_frames
operator|-
literal|1
condition|)
block|{
name|rfd
operator|->
name|command
operator|=
name|RFD_CMD_EL
operator||
name|RFD_CMD_SUSP
expr_stmt|;
name|rfd
operator|->
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|sc
operator|->
name|rfd_head
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|sc
operator|->
name|rbd_head
argument_list|)
expr_stmt|;
name|rbd
operator|->
name|size
operator|=
name|RBD_SIZE_EL
operator||
name|RB_SIZE
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|rfd_tail
operator|=
operator|(
operator|--
name|rfd
operator|)
expr_stmt|;
name|sc
operator|->
name|rbd_tail
operator|=
operator|(
operator|--
name|rbd
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXDEBUG
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT_RFA
argument_list|)
name|rfd
operator|=
operator|(
name|rfd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|)
expr_stmt|;
name|rbd
operator|=
operator|(
name|rbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|+
operator|(
name|how_many_frames
operator|*
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|rb
operator|=
name|sc
operator|->
name|maddr
operator|+
name|RFA_START
operator|+
operator|(
name|how_many_frames
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|rfd_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rbd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  complete_frame_size = %d\n"
argument_list|,
name|complete_frame_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  how_many_frames = %d\n"
argument_list|,
name|how_many_frames
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rfd_head = %lx\t\trfd_tail = %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|rfd_head
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|rfd_tail
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  rbd_head = %lx\t\trbd_tail = %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|rbd_head
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|rbd_tail
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|how_many_frames
condition|;
name|i
operator|++
operator|,
name|rfd
operator|++
operator|,
name|rbd
operator|++
operator|,
name|rb
operator|+=
name|RB_SIZE
control|)
block|{
name|printf
argument_list|(
literal|"  %d:\trfd = %lx\t\trbd = %lx\t\trb = %lx\n"
argument_list|,
name|i
argument_list|,
name|kvtop
argument_list|(
name|rfd
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|rbd
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trfd->command = %x\n"
argument_list|,
name|rfd
operator|->
name|command
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trfd->next = %x\trfd->rbd_offset = %x\n"
argument_list|,
name|rfd
operator|->
name|next
argument_list|,
name|rfd
operator|->
name|rbd_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trbd->next = %x\trbd->size = %x"
argument_list|,
name|rbd
operator|->
name|next
argument_list|,
name|rbd
operator|->
name|size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trbd->buffer = %lx\n\n"
argument_list|,
name|rbd
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|DEBUGEND
endif|#
directive|endif
comment|/* IXDEBUG */
comment|/* 	 * ZZZ need to add sanity check to see if last rb runs into 	 * the stuff after it in memory, this should not be possible 	 * but if someone screws up with the defines it can happen 	 */
name|DEBUGBEGIN
argument_list|(
name|DEBUGINIT_RFA
argument_list|)
name|DEBUGDO
argument_list|(
name|printf
argument_list|(
literal|"  next rb would be at %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|rb
argument_list|)
argument_list|)
argument_list|;)
name|DEBUGDO
argument_list|(
name|printf
argument_list|(
literal|"ix%d: ixinit_rfa exit\n"
argument_list|,
name|unit
argument_list|)
argument_list|;)
name|DEBUGEND
block|}
end_function

begin_comment
comment|/*  * ixinit_tfa(int unit)  *  *	This routine initializes the Transmit Frame Area for the 82586  *  * input	the unit number to build the TFA for  * access	the softc for memory address  * output	an initialized TFA, ready for packet transmission  *		the following queue pointers in the softc structure are  *		also initialize  *		sc->cb_head		sc->cb_tail  *		sc->tbd_head		sc->tbd_tail  * defines	TB_COUNT	home many transmit buffers to create  *		TB_SIZE		size of the tranmit buffer, this must  *				be even and should be greater than the  *				minumum packet size and less than the  *				maximum packet size  *		TFA_START	the starting offset of the TFA  */
end_comment

begin_function
name|void
name|ixinit_tfa
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|cb_transmit_t
modifier|*
name|cb
decl_stmt|;
name|tbd_t
modifier|*
name|tbd
decl_stmt|;
name|caddr_t
name|tb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT_TFA
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"\nix%d: ixinit_tfa\n"
argument|, unit);
argument_list|)
name|DEBUGEND
comment|/* build the list of cb's, tbd's and tb's */
name|cb
init|=
operator|(
name|cb_transmit_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|)
decl_stmt|;
name|tbd
operator|=
operator|(
name|tbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|+
operator|(
name|TB_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|cb_transmit_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|tb
operator|=
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|+
operator|(
name|TB_COUNT
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|cb_transmit_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|sc
operator|->
name|cb_head
operator|=
operator|(
name|cb_t
operator|*
operator|)
name|cb
expr_stmt|;
name|sc
operator|->
name|tbd_head
operator|=
name|tbd
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TB_COUNT
condition|;
name|i
operator|++
operator|,
name|cb
operator|++
operator|,
name|tbd
operator|++
operator|,
name|tb
operator|+=
name|TB_SIZE
control|)
block|{
name|cb
operator|->
name|common
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|common
operator|.
name|command
operator|=
name|CB_CMD_NOP
expr_stmt|;
name|cb
operator|->
name|common
operator|.
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|cb
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|cb_transmit_t
argument_list|)
expr_stmt|;
name|cb
operator|->
name|tbd_offset
operator|=
name|KVTOBOARD
argument_list|(
name|tbd
argument_list|)
expr_stmt|;
comment|/* ZZZ could bzero this, but just leave a note for now */
comment|/* ZZZ bzero(cb->destination); */
name|cb
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|tbd
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|tbd
operator|->
name|act_count
operator|=
name|TBD_STAT_EOF
expr_stmt|;
name|tbd
operator|->
name|next
operator|=
name|KVTOBOARD
argument_list|(
name|tbd
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
expr_stmt|;
name|tbd
operator|->
name|buffer
operator|=
name|KVTOBOARD
argument_list|(
name|tb
argument_list|)
expr_stmt|;
comment|/* 		 * handle the boundary conditions here. 		 */
if|if
condition|(
name|i
operator|==
name|TB_COUNT
operator|-
literal|1
condition|)
block|{
name|cb
operator|->
name|common
operator|.
name|command
operator|=
name|CB_CMD_EL
operator||
name|CB_CMD_NOP
expr_stmt|;
name|cb
operator|->
name|common
operator|.
name|next
operator|=
name|INTEL586NULL
expr_stmt|;
comment|/*RRR KVTOBOARD(sc->cb_head);*/
name|tbd
operator|->
name|next
operator|=
name|INTEL586NULL
expr_stmt|;
comment|/*RRR KVTOBOARD(sc->tbd_head);*/
block|}
block|}
name|sc
operator|->
name|cb_tail
operator|=
operator|(
name|cb_t
operator|*
operator|)
operator|(
operator|--
name|cb
operator|)
expr_stmt|;
name|sc
operator|->
name|tbd_tail
operator|=
operator|(
operator|--
name|tbd
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IXDEBUG
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINIT_TFA
argument_list|)
name|cb
operator|=
operator|(
name|cb_transmit_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|)
expr_stmt|;
name|tbd
operator|=
operator|(
name|tbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|+
operator|(
name|TB_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|cb_transmit_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|tb
operator|=
name|sc
operator|->
name|maddr
operator|+
name|TFA_START
operator|+
operator|(
name|TB_COUNT
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|cb_transmit_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|tbd_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"  TB_COUNT = %d\n"
argument_list|,
name|TB_COUNT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  cb_head = %lx\t\tcb_tail = %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|cb_head
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|cb_tail
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  tbd_head = %lx\t\ttbd_tail = %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|tbd_head
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|sc
operator|->
name|tbd_tail
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TB_COUNT
condition|;
name|i
operator|++
operator|,
name|cb
operator|++
operator|,
name|tbd
operator|++
operator|,
name|tb
operator|+=
name|TB_SIZE
control|)
block|{
name|printf
argument_list|(
literal|"  %d:\tcb = %lx\t\ttbd = %lx\t\ttb = %lx\n"
argument_list|,
name|i
argument_list|,
name|kvtop
argument_list|(
name|cb
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|tbd
argument_list|)
argument_list|,
name|kvtop
argument_list|(
name|tb
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcb->common.command = %x\n"
argument_list|,
name|cb
operator|->
name|common
operator|.
name|command
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tcb->common.next = %x\tcb->tbd_offset = %x\n"
argument_list|,
name|cb
operator|->
name|common
operator|.
name|next
argument_list|,
name|cb
operator|->
name|tbd_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttbd->act_count = %x"
argument_list|,
name|tbd
operator|->
name|act_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttbd->next = %x"
argument_list|,
name|tbd
operator|->
name|next
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttbd->buffer = %lx\n\n"
argument_list|,
name|tbd
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
name|DEBUGEND
endif|#
directive|endif
comment|/* IXDEBUG */
comment|/* 	 * ZZZ need to add sanity check to see if last tb runs into 	 * the stuff after it in memory, this should not be possible 	 * but if someone screws up with the defines it can happen 	 */
name|DEBUGBEGIN
argument_list|(
name|DEBUGINIT_TFA
argument_list|)
name|DEBUGDO
argument_list|(
name|printf
argument_list|(
literal|"  next tb would be at %lx\n"
argument_list|,
name|kvtop
argument_list|(
name|tb
argument_list|)
argument_list|)
argument_list|;)
name|DEBUGDO
argument_list|(
name|printf
argument_list|(
literal|"ix%d: ixinit_tfa exit\n"
argument_list|,
name|unit
argument_list|)
argument_list|;)
name|DEBUGEND
block|}
end_function

begin_function
name|void
name|ixintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|SCB_ADDR
operator|)
decl_stmt|;
name|int
name|check_queue
decl_stmt|;
comment|/* flag to tell us to check the queue */
name|u_short
name|status
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixintr: "
argument|);
argument_list|)
name|DEBUGEND
if|if
condition|(
operator|(
name|sc
operator|->
name|flags
operator|&
name|IXF_INITED
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n ixintr without being inited!!\n"
argument_list|)
expr_stmt|;
comment|/* ZZZ */
name|ixinterrupt_disable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|ixintr_exit
goto|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  ixintr when device not running!!\n"
argument_list|)
expr_stmt|;
comment|/* ZZZ */
name|ixinterrupt_disable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
goto|goto
name|ixintr_exit
goto|;
block|}
comment|/* The sequence, disable ints, status=ack must be done 	 * as quick as possible to avoid missing things */
name|ixinterrupt_disable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|status
operator|=
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|check_queue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|status
operator|&
name|SCB_STAT_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|status
operator|&
name|SCB_STAT_FR
condition|)
block|{
name|ixintr_fr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|SCB_STAT_CX
condition|)
block|{
name|ixintr_cx
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|check_queue
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|SCB_STAT_CNA
condition|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"cna:"
argument|);
argument_list|)
name|DEBUGEND
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|SCB_STAT_RNR
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|SCB_RUS_MASK
operator|)
operator|==
name|SCB_RUS_NRSC
operator|)
condition|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR
argument_list|)
name|printf
argument_list|(
literal|"RNR:"
argument_list|)
expr_stmt|;
comment|/* ZZZ this means trouble */
name|DEBUGEND
name|IXCOUNTER
argument_list|(
name|ifp
operator|->
name|if_rnr
operator|++
argument_list|;
block|)
name|ixinit_rfa
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|scb
operator|->
name|status
operator|=
name|SCB_STAT_NULL
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_RUC_START
expr_stmt|;
name|scb
operator|->
name|rfa_offset
operator|=
name|RFA_START
expr_stmt|;
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|->
name|status
operator|&
name|SCB_STAT_MASK
condition|)
block|{
name|status
operator|=
name|ixacknowledge
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|ixinterrupt_enable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|check_queue
operator|&&
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
literal|0
condition|)
block|{
name|ixstart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* we have stuff on the queue */
block|}
end_if

begin_label
name|ixintr_exit
label|:
end_label

begin_macro
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR
argument_list|)
end_macro

begin_macro
name|DEBUGDO
argument_list|(
argument|printf(
literal|" ixintr exited\n"
argument|);
argument_list|)
end_macro

begin_expr_stmt
name|DEBUGEND
end_expr_stmt

begin_function
unit|}  static
specifier|inline
name|void
name|ixintr_cx
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|cb_t
modifier|*
name|cb
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR_CX
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"cx:"
argument|);
argument_list|)
name|DEBUGEND
name|cb
init|=
name|sc
operator|->
name|cb_head
decl_stmt|;
do|do
block|{
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_BUSY
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_busy++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.busy"
argument_list|)
expr_stmt|;
comment|/* This should never occur */
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_COMPLETE
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_complete++;
argument_list|)
switch|switch
condition|(
name|cb
operator|->
name|command
operator|&
name|CB_CMD_MASK
condition|)
block|{
case|case
name|CB_CMD_NOP
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_IAS
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_CONF
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_MCAS
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_TRANSMIT
case|:
block|{
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_OK
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|IXCOUNTER
argument_list|(
argument|ifp->if_ok++;
argument_list|)
block|}
else|else
block|{
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_ABORT
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_abort++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.abort"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_LATECOLL
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_latecoll++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.latecoll"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_NOCS
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_nocs++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.nocs"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_NOCTS
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_nocts++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.nocts"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_DMAUNDER
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_dmaunder++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.dmaunder"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_DEFER
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_defer++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.defer"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_HEARTBEAT
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_heartbeat++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.heartbeat"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|status
operator|&
name|CB_EXCESSCOLL
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_excesscoll++;
argument_list|)
name|printf
argument_list|(
literal|"ix.cx.excesscoll"
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
name|ifp
operator|->
name|if_collisions
operator|+=
name|cb
operator|->
name|status
operator|&
name|CB_COLLISIONS
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
comment|/* clear watchdog timeout */
break|break;
block|}
case|case
name|CB_CMD_TDR
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_DUMP
case|:
block|{
break|break;
block|}
case|case
name|CB_CMD_DIAGNOSE
case|:
block|{
break|break;
block|}
default|default:
block|{
break|break;
block|}
block|}
name|ixintr_cx_free
argument_list|(
name|unit
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{ 		}
if|if
condition|(
name|cb
operator|->
name|next
operator|==
name|INTEL586NULL
condition|)
block|{
break|break;
block|}
else|else
block|{
name|cb
operator|=
operator|(
name|cb_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
name|cb
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
comment|/* 	 * clear the IFF_OACTIVE flag because the CU should now be 	 * idle, this only holds true as long as the last CB is the 	 * only one with the CB_CMD_INT bit set.  If the start routine 	 * violates this rule this code well have to change. 	 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixintr_cx_free
parameter_list|(
name|int
name|unit
parameter_list|,
name|cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR_CX
argument_list|)
name|DEBUGDO
argument_list|(
argument|ix_softc_t	*sc =&ix_softc[unit];
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"cb=%x:cb->status=%x:"
argument|, KVTOBOARD(cb), cb->status);
argument_list|)
name|DEBUGEND
comment|/*1*/
name|cb
operator|->
name|command
init|=
name|CB_CMD_EL
operator||
name|CB_CMD_NOP
decl_stmt|;
comment|/*2*/
name|cb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixintr_fr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR_FR
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"fr:"
argument|);
argument_list|)
name|DEBUGEND
comment|/* find each frame in the rfa and copy it up, then free it */
while|while
condition|(
operator|(
name|sc
operator|->
name|rfd_head
operator|->
name|status
operator|&
operator|(
name|RFD_COMPLETE
operator||
name|RFD_BUSY
operator|)
operator|)
operator|==
name|RFD_COMPLETE
condition|)
block|{
name|ixintr_fr_copy
argument_list|(
name|unit
argument_list|,
name|sc
operator|->
name|rfd_head
argument_list|)
expr_stmt|;
name|ixintr_fr_free
argument_list|(
name|unit
argument_list|,
name|sc
operator|->
name|rfd_head
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixintr_fr_copy
parameter_list|(
name|int
name|unit
parameter_list|,
name|rfd_t
modifier|*
name|rfd
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|rbd_t
modifier|*
name|rbd
decl_stmt|;
name|caddr_t
name|rb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|length
decl_stmt|,
name|bytesleft
decl_stmt|;
name|rbd
operator|=
operator|(
name|rbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|rfd
operator|->
name|rbd_offset
operator|)
expr_stmt|;
name|rb
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|maddr
operator|+
name|rbd
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGINTR_FR
argument_list|)
name|DEBUGDO
argument_list|(
argument|int	i;
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"rfd=%x:"
argument|, KVTOBOARD(rfd));
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"rfd->status=%x:"
argument|, rfd->status);
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"rbd->act_count=%x:"
argument|, rbd->act_count);
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"data="
argument|);
argument_list|)
name|DEBUGDO
argument_list|(
argument|for (i =
literal|0
argument|; i<
literal|16
argument|; i ++) printf (
literal|"%02x"
argument|, rb[i]&
literal|0xFF
argument|);
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|":"
argument|);
argument_list|)
name|DEBUGEND
comment|/* trickery here, eh points right at memory on 	 * the board.  eh is only used by ether_input, 	 * it is not passed to the upper layer */
name|eh
init|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|rb
decl_stmt|;
comment|/* here we go, lets build an mbuf chain up to hold all this */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MGETHDR:"
argument_list|)
expr_stmt|;
comment|/* ZZZ need to add drop counters */
return|return;
block|}
name|m0
operator|=
name|m
expr_stmt|;
name|length
operator|=
name|rbd
operator|->
name|act_count
operator|&
name|RBD_STAT_SIZE
expr_stmt|;
name|bytesleft
operator|=
name|length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|rb
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|bytesleft
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
while|while
condition|(
name|bytesleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bytesleft
operator|>
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|MCLBYTES
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"MCLGET:"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* ZZZ need to add drop counters */
return|return;
block|}
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|bytesleft
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rb
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|rb
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|bytesleft
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|bytesleft
operator|>
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"MGET"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* ZZZ need to add drop counters */
return|return;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
block|}
name|ether_input
argument_list|(
name|ifp
argument_list|,
name|eh
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ixintr_fr_free
parameter_list|(
name|int
name|unit
parameter_list|,
name|rfd_t
modifier|*
name|rfd
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|rbd_t
modifier|*
name|rbd
decl_stmt|;
name|rbd
operator|=
operator|(
name|rbd_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|maddr
operator|+
name|rfd
operator|->
name|rbd_offset
operator|)
expr_stmt|;
comment|/* XXX this still needs work, does not handle chained rbd's */
comment|/*1*/
name|rbd
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
comment|/*2*/
name|rbd
operator|->
name|size
operator|=
name|RBD_SIZE_EL
operator||
name|RB_SIZE
expr_stmt|;
comment|/*3*/
name|sc
operator|->
name|rbd_tail
operator|->
name|size
operator|=
name|RB_SIZE
expr_stmt|;
comment|/*4*/
name|sc
operator|->
name|rbd_tail
operator|=
name|rbd
expr_stmt|;
comment|/* Free the rfd buy putting it back on the rfd queue */
comment|/*1*/
name|rfd
operator|->
name|command
operator|=
name|RFD_CMD_EL
operator||
name|RFD_CMD_SUSP
expr_stmt|;
comment|/*2*/
name|rfd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/*3*/
name|rfd
operator|->
name|rbd_offset
operator|=
name|INTEL586NULL
expr_stmt|;
comment|/*4*/
name|sc
operator|->
name|rfd_head
operator|=
operator|(
name|rfd_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
name|rfd
operator|->
name|next
argument_list|)
expr_stmt|;
comment|/*5*/
name|sc
operator|->
name|rfd_tail
operator|->
name|command
operator|&=
operator|~
operator|(
name|RFD_CMD_EL
operator||
name|RFD_CMD_SUSP
operator|)
expr_stmt|;
comment|/*6*/
name|sc
operator|->
name|rfd_tail
operator|=
name|rfd
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Psuedo code:  * 	Do consistency check:  *	  IFF_UP should be set.  *	  IFF_RUNNING should be set.  *	  IFF_OACTIVE should be clear.  *	  ifp->snd.ifq_head should point to an MBUF  *	  I82586 CU should be in the idle state.  *	  All cb's should have CUC = NOP.  *	The real work:  *	  while there are packets to send& free cb's do:  *		build a cb, tbd, and tb  *		copy the MBUF chain to a tb  *	  setup the scb for a start CU  *	  start the CU  *	  set IFF_OACTIVE  *	  set ifp->if_timer for watchdog timeout  *	Exit:  */
end_comment

begin_function
name|void
name|ixstart
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|scb_t
modifier|*
name|scb
init|=
operator|(
name|scb_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
name|SCB_ADDR
argument_list|)
decl_stmt|;
name|cb_t
modifier|*
name|cb
init|=
name|sc
operator|->
name|cb_head
decl_stmt|;
name|tbd_t
modifier|*
name|tbd
decl_stmt|;
name|caddr_t
name|tb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_temp
decl_stmt|;
name|u_short
name|length
decl_stmt|;
name|IXCOUNTER
argument_list|(
argument|int		queued;
argument_list|)
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTART
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixstart:"
argument|);
argument_list|)
name|DEBUGEND
comment|/* check that if is up and running */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
block|{
goto|goto
name|ixstart_exit
goto|;
block|}
comment|/* check to see that we are not already active */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
name|IFF_OACTIVE
condition|)
block|{
goto|goto
name|ixstart_exit
goto|;
block|}
comment|/* check that there are packets to send */
if|if
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|==
literal|0
condition|)
block|{
goto|goto
name|ixstart_exit
goto|;
block|}
comment|/* check that the command unit is idle */
if|if
condition|(
operator|(
name|scb
operator|->
name|status
operator|&
name|SCB_CUS_MASK
operator|)
operator|!=
name|SCB_CUS_IDLE
condition|)
block|{
goto|goto
name|ixstart_exit
goto|;
block|}
comment|/* check that all cb's on the list are free */
ifdef|#
directive|ifdef
name|THISDONTDONOTHING
name|cb
operator|=
name|sc
operator|->
name|cb_head
expr_stmt|;
name|IXCOUNTER
argument_list|(
argument|ifp->if_could_queue =
literal|0
argument|;
argument_list|)
do|do
block|{
comment|/* XXX this does nothing right now! */
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTART
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"chk_cb=%x:"
argument|, KVTOBOARD(cb));
argument_list|)
name|DEBUGEND
name|IXCOUNTER
argument_list|(
name|ifp
operator|->
name|if_could_queue
operator|++
argument_list|;)
decl|if
argument_list|(
name|cb
operator|->
name|next
operator|==
name|INTEL586NULL
argument_list|)
block|{
break|break;
block|}
else|else
block|{
name|cb
operator|=
operator|(
name|cb_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
name|cb
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
endif|#
directive|endif
comment|/* THISDONTDONOTHING */
comment|/* build as many cb's as we can */
name|IXCOUNTER
argument_list|(
argument|queued =
literal|0
argument|;
argument_list|)
name|cb
operator|=
name|sc
operator|->
name|cb_head
expr_stmt|;
do|do
block|{
name|cb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|command
operator|=
name|CB_CMD_TRANSMIT
expr_stmt|;
name|tbd
operator|=
operator|(
name|tbd_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
operator|(
operator|(
name|cb_transmit_t
operator|*
operator|)
name|cb
operator|)
operator|->
name|tbd_offset
argument_list|)
expr_stmt|;
name|tb
operator|=
operator|(
name|caddr_t
operator|)
name|BOARDTOKV
argument_list|(
name|tbd
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTART
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"cb=%x:"
argument|, KVTOBOARD(cb));
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"tbd=%x:"
argument|, KVTOBOARD(tbd));
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"tb=%x:"
argument|, KVTOBOARD(tb));
argument_list|)
name|DEBUGEND
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
decl_stmt|;
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_temp
operator|=
name|m
init|;
name|m_temp
operator|!=
literal|0
condition|;
name|m_temp
operator|=
name|m_temp
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m_temp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|tb
argument_list|,
name|m_temp
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|tb
operator|+=
name|m_temp
operator|->
name|m_len
expr_stmt|;
name|length
operator|+=
name|m_temp
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|<
name|ETHER_MIN_LENGTH
condition|)
name|length
operator|=
name|ETHER_MIN_LENGTH
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|length
operator|>
name|ETHER_MAX_LENGTH
condition|)
block|{
comment|/* XXX  			 * This should never ever happen, if it does 			 * we probable screwed up all sorts of board data 			 * in the above bcopy's and should probably shut 			 * down, but for now just issue a warning that 			 * something is real wrong 			 */
name|printf
argument_list|(
literal|"ix%d: ixstart: Packet length=%d> MTU=%d\n"
argument_list|,
name|unit
argument_list|,
name|length
argument_list|,
name|ETHER_MAX_LENGTH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DIAGNOSTIC */
name|tbd
operator|->
name|act_count
operator|=
name|TBD_STAT_EOF
operator||
name|length
expr_stmt|;
name|IXCOUNTER
argument_list|(
argument|queued++;
argument_list|)
comment|/* check to see if we have used the last cb */
if|if
condition|(
name|cb
operator|->
name|next
operator|==
name|INTEL586NULL
condition|)
block|{
name|IXCOUNTER
argument_list|(
argument|ifp->if_filled_queue++;
argument_list|)
break|break;
block|}
else|else
block|{
name|cb
operator|=
operator|(
name|cb_t
operator|*
operator|)
name|BOARDTOKV
argument_list|(
name|cb
operator|->
name|next
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_head
operator|!=
literal|0
condition|)
do|;
name|IXCOUNTER
argument_list|(
argument|ifp->if_high_queue = max(ifp->if_high_queue, queued);
argument_list|)
comment|/* set the end of list and interrupt bits in the last cb */
name|cb
operator|->
name|command
operator||=
operator|(
name|CB_CMD_EL
operator||
name|CB_CMD_INT
operator|)
expr_stmt|;
comment|/* build the scb */
name|scb
operator|->
name|status
operator|=
name|SCB_STAT_NULL
expr_stmt|;
name|scb
operator|->
name|command
operator|=
name|SCB_CUC_START
expr_stmt|;
name|scb
operator|->
name|cbl_offset
operator|=
name|KVTOBOARD
argument_list|(
name|sc
operator|->
name|cb_head
argument_list|)
expr_stmt|;
comment|/* This should not be needed */
comment|/* start the cu */
name|ixchannel_attention
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* mark the interface as having output active */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* 	 * set the watchdog timer so that if the board fails to interrupt 	 * we will go clean up 	 */
name|ifp
operator|->
name|if_timer
operator|=
literal|2
expr_stmt|;
name|ixstart_exit
label|:
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTART
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixstart exited\n"
argument|);
argument_list|)
name|DEBUGEND
return|return;
block|}
end_function

begin_function
name|int
name|ixstop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTOP
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixstop:"
argument|);
argument_list|)
name|DEBUGEND
comment|/* XXX Need to find out what spl we are at, and maybe add splx */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|ixinterrupt_disable
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* force the 82586 reset pin high */
name|outb
argument_list|(
name|sc
operator|->
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|I586_RESET
argument_list|)
expr_stmt|;
name|sc
operator|->
name|kdc
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGSTOP
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixstop exiting\n"
argument|);
argument_list|)
name|DEBUGEND
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * I can't find any calls to if_done, it may be deprecated, but I left  * it here until I find out.  rwgrimes 1993/01/15  */
end_comment

begin_function
name|int
name|ixdone
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGDONE
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixdone:"
argument|);
argument_list|)
name|DEBUGEND
name|DEBUGBEGIN
argument_list|(
name|DEBUGDONE
argument_list|)
name|DEBUGDO
argument_list|(
name|printf
argument_list|(
literal|"ixdone exited\n"
argument_list|)
argument_list|;)
name|DEBUGEND
decl|return
argument_list|(
literal|0
argument_list|)
decl_stmt|;
block|}
end_function

begin_function
name|int
name|ixioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|unit
init|=
name|ifp
operator|->
name|if_unit
decl_stmt|;
name|int
name|status
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGIOCTL
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixioctl:"
argument|);
argument_list|)
name|DEBUGEND
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|ixstop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|ixinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
comment|/*ZZZ*/
name|printf
argument_list|(
literal|"Address family NS not supported by ixioctl\n"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* NS */
default|default:
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGIOCTL
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"Unknow Address Family in ixioctl\n"
argument|);
argument_list|)
name|DEBUGEND
name|status
init|=
name|EINVAL
decl_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
block|{
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|ixstop
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ixinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
block|{
name|DEBUGBEGIN
argument_list|(
argument|DEBUGIOCTL
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"Unknown cmd in ixioctl\n"
argument|);
argument_list|)
name|DEBUGEND
name|status
init|=
name|EINVAL
decl_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGIOCTL
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixioctl exit\n"
argument|);
argument_list|)
name|DEBUGEND
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixreset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGRESET
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixreset:"
argument|);
argument_list|)
name|DEBUGEND
name|ixstop
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|ixinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DEBUGBEGIN
argument_list|(
argument|DEBUGRESET
argument_list|)
name|DEBUGDO
argument_list|(
argument|printf(
literal|"ixreset exit\n"
argument|);
argument_list|)
name|DEBUGEND
argument_list|(
argument|void
argument_list|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * The ixwatchdog routine gets called if the transmitter failed to interrupt  * within ifp->if_timer XXXseconds.  The interrupt service routine must reset  * ifp->if_timer to 0 after an transmitter interrupt occurs to stop the  * watchdog from happening.  */
end_comment

begin_function
name|void
name|ixwatchdog
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|ix_softc_t
modifier|*
name|sc
init|=
operator|&
name|ix_softc
index|[
name|unit
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ix%d: device timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|ixreset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|u_short
name|ixeeprom_read
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|location
parameter_list|)
block|{
name|int
name|eeprom_control
decl_stmt|,
name|data
decl_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
name|eeprom_control
operator|&=
literal|0xB2
expr_stmt|;
comment|/* XXX fix 0xB2 */
name|eeprom_control
operator||=
name|EECS
expr_stmt|;
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|eeprom_control
argument_list|)
expr_stmt|;
name|ixeeprom_outbits
argument_list|(
name|unit
argument_list|,
name|eeprom_read_op
argument_list|,
name|eeprom_opsize1
argument_list|)
expr_stmt|;
name|ixeeprom_outbits
argument_list|(
name|unit
argument_list|,
name|location
argument_list|,
name|eeprom_addr_size
argument_list|)
expr_stmt|;
name|data
operator|=
name|ixeeprom_inbits
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
name|eeprom_control
operator|&=
operator|~
operator|(
name|GA_RESET
operator||
name|EEDI
operator||
name|EECS
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|eeprom_control
argument_list|)
expr_stmt|;
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixeeprom_outbits
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|data
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|eeprom_control
decl_stmt|,
name|i
decl_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
name|eeprom_control
operator|&=
operator|~
name|GA_RESET
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|eeprom_control
operator|&=
operator|~
name|EEDI
expr_stmt|;
if|if
condition|(
name|data
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
name|eeprom_control
operator||=
name|EEDI
expr_stmt|;
block|}
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|eeprom_control
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* eeprom data must be setup for 0.4 uSec */
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|eeprom_control
operator|&=
operator|~
name|EEDI
expr_stmt|;
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|eeprom_control
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* eeprom data must be held for 0.4 uSec */
block|}
end_function

begin_function
name|int
name|ixeeprom_inbits
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|eeprom_control
decl_stmt|,
name|data
decl_stmt|,
name|i
decl_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
name|eeprom_control
operator|&=
operator|~
name|GA_RESET
expr_stmt|;
for|for
control|(
name|data
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|data
operator|<<
literal|1
expr_stmt|;
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
if|if
condition|(
name|eeprom_control
operator|&
name|EEDO
condition|)
block|{
name|data
operator||=
literal|1
expr_stmt|;
block|}
name|ixeeprom_clock
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ixeeprom_clock
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|eeprom_control
decl_stmt|;
name|eeprom_control
operator|=
name|inb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|)
expr_stmt|;
name|eeprom_control
operator|&=
operator|~
operator|(
name|GA_RESET
operator||
name|EESK
operator|)
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
name|eeprom_control
operator|=
name|eeprom_control
operator||
name|EESK
expr_stmt|;
block|}
name|outb
argument_list|(
name|ix_softc
index|[
name|unit
index|]
operator|.
name|iobase
operator|+
name|ee_ctrl
argument_list|,
name|eeprom_control
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|9
argument_list|)
expr_stmt|;
comment|/* EESK must be stable for 8.38 uSec */
block|}
end_function

end_unit

