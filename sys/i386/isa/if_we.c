begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Tim L. Tucker.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)if_we.c	7.3 (Berkeley) 5/21/91  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         2       00112  * --------------------         -----   ----------------------  *  * 09 Sep 92	Mike Durkin		Fix Danpex EW-2016& other 8013 clones  *					enable with "options WECOMPAT"  * 19 Sep 92	Michael Galassi		Fixed multiboard routing  * 20 Sep 92	Barry Lustig		WD8013 16 bit mode -- enable  *						with "options WD8013".  * 14 Mar 93	Marc Frajola		BPF packet filter support  * 14 Mar 93	David Greenman		Input and other routines re-written  * 14 Mar 93	Rodney W. Grimes	Added link level address to we_attach  */
end_comment

begin_comment
comment|/*  * Modification history  *  * 8/28/89 - Initial version(if_wd.c), Tim L Tucker  *  * 92.09.19 - Changes to allow multiple we interfaces in one box.  *          Allowed interupt handler to look at unit other than 0  *            Bdry was static, made it into an array w/ one entry per  *          interface.  nerd@percival.rain.com (Michael Galassi)  *  * BPF Packet Filter Support added by Marc Frajola, 12/30/92  * Input& other routines re-written by David Greenman, 1/2/93  * BPF trailer support added by David Greenman, 1/7/93  * we_attach enhanced with link level address by Rodney W. Grimes, 1/30/93  *  * $Log:	if_we.c,v $  * Revision 1.2  93/02/18  17:21:57  davidg  * Bugs in mbuf cluster allocation fixed  * Problem with nfs wanting mbufs aligned on longword boundries fixed  *   */
end_comment

begin_include
include|#
directive|include
file|"we.h"
end_include

begin_if
if|#
directive|if
name|NWE
operator|>
literal|0
end_if

begin_comment
comment|/*  * Western Digital 8003 ethernet/starlan adapter  *  * Supports the following interface cards:  * WD8003E, WD8003EBT, WD8003S, WD8003SBT, WD8013EBT  *  * The Western Digital card is one of many AT/MCA ethernet interfaces  * based on the National DS8390 Network Interface chip set.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/if_types.h"
end_include

begin_include
include|#
directive|include
file|"net/if_dl.h"
end_include

begin_include
include|#
directive|include
file|"net/netisr.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_include
include|#
directive|include
file|"netinet/if_ether.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|"netns/ns.h"
end_include

begin_include
include|#
directive|include
file|"netns/ns_if.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"net/bpf.h"
end_include

begin_include
include|#
directive|include
file|"net/bpfdesc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/if_wereg.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/include/pio.h"
end_include

begin_function_decl
specifier|static
specifier|inline
name|char
modifier|*
name|we_ring_copy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * This constant should really be 60 because the we adds 4 bytes of crc.  * However when set to 60 our packets are ignored by deunas , 3coms are  * okay ??????????????????????????????????????????  */
end_comment

begin_define
define|#
directive|define
name|ETHER_MIN_LEN
value|64
end_define

begin_define
define|#
directive|define
name|ETHER_ADDR_LEN
value|6
end_define

begin_define
define|#
directive|define
name|ETHER_HDR_SIZE
value|14
end_define

begin_comment
comment|/*  * Ethernet software status per interface.  *  * Each interface is referenced by a network interface structure,  * qe_if, which the routing code uses to locate the interface.  * This structure contains the output queue for the interface, its address, ...  */
end_comment

begin_struct
struct|struct
name|we_softc
block|{
name|struct
name|arpcom
name|we_ac
decl_stmt|;
comment|/* Ethernet common part 	*/
define|#
directive|define
name|we_if
value|we_ac.ac_if
comment|/* network-visible interface 	*/
define|#
directive|define
name|we_addr
value|we_ac.ac_enaddr
comment|/* hardware Ethernet address 	*/
name|u_char
name|we_flags
decl_stmt|;
comment|/* software state		*/
define|#
directive|define
name|WDF_RUNNING
value|0x01
define|#
directive|define
name|WDF_TXBUSY
value|0x02
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
define|#
directive|define
name|WDF_ATTACHED
value|0x80
endif|#
directive|endif
name|u_char
name|we_type
decl_stmt|;
comment|/* interface type code		*/
name|u_short
name|we_vector
decl_stmt|;
comment|/* interrupt vector 		*/
name|short
name|we_io_ctl_addr
decl_stmt|;
comment|/* i/o bus address, control	*/
name|short
name|we_io_nic_addr
decl_stmt|;
comment|/* i/o bus address, DS8390	*/
name|caddr_t
name|we_vmem_addr
decl_stmt|;
comment|/* card RAM virtual memory base */
name|u_long
name|we_vmem_size
decl_stmt|;
comment|/* card RAM bytes		*/
name|caddr_t
name|we_vmem_ring
decl_stmt|;
comment|/* receive ring RAM vaddress	*/
name|caddr_t
name|we_vmem_end
decl_stmt|;
comment|/* receive ring RAM end	*/
name|caddr_t
name|we_bpf
decl_stmt|;
comment|/* Magic Cookie for BPF */
block|}
name|we_softc
index|[
name|NWE
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|weprobe
argument_list|()
decl_stmt|,
name|weattach
argument_list|()
decl_stmt|,
name|weintr
argument_list|()
decl_stmt|,
name|westart
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|weinit
argument_list|()
decl_stmt|,
name|ether_output
argument_list|()
decl_stmt|,
name|weioctl
argument_list|()
decl_stmt|,
name|wereset
argument_list|()
decl_stmt|,
name|wewatchdog
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|wedriver
init|=
block|{
name|weprobe
block|,
name|weattach
block|,
literal|"we"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|wemask
index|[]
init|=
block|{
name|IRQ9
block|,
name|IRQ3
block|,
name|IRQ5
block|,
name|IRQ7
block|,
name|IRQ10
block|,
name|IRQ11
block|,
name|IRQ15
block|,
name|IRQ4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Probe the WD8003 to see if its there  */
end_comment

begin_macro
name|weprobe
argument_list|(
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
name|union
name|we_mem_sel
name|wem
decl_stmt|;
name|u_char
name|sum
decl_stmt|;
ifdef|#
directive|ifdef
name|WD8013
comment|/* 20 Sep 92*/
name|union
name|we_laar
name|laar
decl_stmt|;
name|laar
operator|.
name|laar_byte
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* WD8013*/
name|wem
operator|.
name|ms_byte
operator|=
literal|0
expr_stmt|;
comment|/* 20 Sep 92*/
comment|/* reset card to force it into a known state. */
name|outb
argument_list|(
name|is
operator|->
name|id_iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|is
operator|->
name|id_iobase
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* wait in the case this card is reading it's EEROM */
name|DELAY
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WD8013
comment|/* 20 Sep 92*/
comment|/* allow the NIC to access the shared RAM 16 bits at a time */
name|laar
operator|.
name|addr_l19
operator|=
literal|1
expr_stmt|;
name|laar
operator|.
name|lan_16_en
operator|=
literal|1
expr_stmt|;
name|laar
operator|.
name|mem_16_en
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
literal|5
argument_list|,
name|laar
operator|.
name|laar_byte
argument_list|)
expr_stmt|;
comment|/* Write a 0xc1 */
endif|#
directive|endif
comment|/* WD8013*/
comment|/* 	 * Here we check the card ROM, if the checksum passes, and the 	 * type code and ethernet address check out, then we know we have 	 * a wd8003 card. 	 * 	 * Autoconfiguration: No warning message is printed on error. 	 */
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|WD_CHECKSUM
condition|)
block|{
comment|/* 09 Sep 92*/
ifdef|#
directive|ifdef
name|WECOMPAT
name|printf
argument_list|(
literal|"we: probe: checksum failed... installing anyway\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"we: Danpex EW-2016 or other 8013 clone card?\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !WECOMPAT*/
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* !WECOMPAT*/
block|}
name|sc
operator|->
name|we_type
operator|=
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
name|WD_ROM_OFFSET
operator|+
literal|6
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|nope
if|if
condition|(
operator|(
name|sc
operator|->
name|we_type
operator|&
name|WD_REVMASK
operator|)
operator|!=
literal|2
comment|/* WD8003E or WD8003S */
operator|&&
operator|(
name|sc
operator|->
name|we_type
operator|&
name|WD_REVMASK
operator|)
operator|!=
literal|4
comment|/* WD8003EBT */
operator|&&
operator|(
name|sc
operator|->
name|we_type
operator|&
name|WD_REVMASK
operator|)
operator|!=
literal|6
condition|)
comment|/* WD8003ELB? */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/*printf("type %x ", sc->we_type);*/
if|if
condition|(
name|sc
operator|->
name|we_type
operator|&
name|WD_SOFTCONFIG
condition|)
block|{
name|int
name|iv
init|=
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
literal|1
argument_list|)
operator|&
literal|4
operator||
operator|(
operator|(
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
literal|4
argument_list|)
operator|&
literal|0x60
operator|)
operator|>>
literal|5
operator|)
decl_stmt|;
comment|/*printf("iv %d ", iv);*/
if|if
condition|(
name|wemask
index|[
name|iv
index|]
operator|!=
name|is
operator|->
name|id_irq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|outb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
literal|4
argument_list|,
name|inb
argument_list|(
name|is
operator|->
name|id_iobase
operator|+
literal|4
argument_list|)
operator||
literal|0x80
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Setup card RAM area and i/o addresses 	 * Kernel Virtual to segment C0000-DFFFF????? 	 */
name|sc
operator|->
name|we_io_ctl_addr
operator|=
name|is
operator|->
name|id_iobase
expr_stmt|;
name|sc
operator|->
name|we_io_nic_addr
operator|=
name|sc
operator|->
name|we_io_ctl_addr
operator|+
name|WD_NIC_OFFSET
expr_stmt|;
name|sc
operator|->
name|we_vector
operator|=
name|is
operator|->
name|id_irq
expr_stmt|;
name|sc
operator|->
name|we_vmem_addr
operator|=
operator|(
name|caddr_t
operator|)
name|is
operator|->
name|id_maddr
expr_stmt|;
name|sc
operator|->
name|we_vmem_size
operator|=
name|is
operator|->
name|id_msize
expr_stmt|;
name|sc
operator|->
name|we_vmem_ring
operator|=
name|sc
operator|->
name|we_vmem_addr
operator|+
operator|(
name|WD_PAGE_SIZE
operator|*
name|WD_TXBUF_SIZE
operator|)
expr_stmt|;
name|sc
operator|->
name|we_vmem_end
operator|=
name|sc
operator|->
name|we_vmem_addr
operator|+
name|is
operator|->
name|id_msize
expr_stmt|;
comment|/* 	 * Save board ROM station address 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_ctl_addr
operator|+
name|WD_ROM_OFFSET
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Mapin interface memory, setup memory select register 	 */
name|wem
operator|.
name|ms_addr
operator|=
name|kvtop
argument_list|(
name|sc
operator|->
name|we_vmem_addr
argument_list|)
operator|>>
literal|13
expr_stmt|;
name|wem
operator|.
name|ms_enable
operator|=
literal|1
expr_stmt|;
name|wem
operator|.
name|ms_reset
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_ctl_addr
argument_list|,
name|wem
operator|.
name|ms_byte
argument_list|)
expr_stmt|;
comment|/* 	 * clear interface memory, then sum to make sure its valid 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|we_vmem_size
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|we_vmem_addr
index|[
name|i
index|]
operator|=
literal|0x0
expr_stmt|;
for|for
control|(
name|sum
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|we_vmem_size
condition|;
operator|++
name|i
control|)
name|sum
operator|+=
name|sc
operator|->
name|we_vmem_addr
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
literal|0x0
condition|)
block|{
name|printf
argument_list|(
literal|"we%d: wd8003 dual port RAM address error\n"
argument_list|,
name|is
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|WD_IO_PORTS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Interface exists: make available by filling in network interface  * record.  System will initialize the interface when it is ready  * to accept packets.  */
end_comment

begin_macro
name|weattach
argument_list|(
argument|is
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|is
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|is
operator|->
name|id_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|we_if
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize ifnet structure 	 */
name|ifp
operator|->
name|if_unit
operator|=
name|is
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"we"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|weinit
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|westart
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|weioctl
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|wereset
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|wewatchdog
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Search down the ifa address list looking for the AF_LINK type entry */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
block|{
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
block|}
comment|/* If we find an AF_LINK type entry, we well fill in the hardware addr */
if|if
condition|(
operator|(
name|ifa
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fill in the link level address for this interface */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|we_addr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_ATTACHED
expr_stmt|;
comment|/* Make sure BPF attach flag clear */
endif|#
directive|endif
comment|/* 	 * Banner... 	 */
name|printf
argument_list|(
literal|" %saddr %s"
argument_list|,
operator|(
name|sc
operator|->
name|we_type
operator|&
name|WD_ETHERNET
operator|)
condition|?
literal|"enet"
else|:
literal|"slan"
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|we_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Reset of interface.  */
end_comment

begin_macro
name|wereset
argument_list|(
argument|unit
argument_list|,
argument|uban
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|uban
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|unit
operator|>=
name|NWE
condition|)
return|return;
name|printf
argument_list|(
literal|"we%d: reset\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*	we_softc[unit].we_flags&= ~WDF_RUNNING; */
name|weinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Take interface offline.  */
end_comment

begin_macro
name|westop
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Shutdown DS8390 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|wewatchdog
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|weintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*log(LOG_WARNING,"we%d: soft reset\n", unit); 	westop(unit); 	weinit(unit);*/
block|}
end_block

begin_expr_stmt
specifier|static
name|Bdry
index|[
name|NWE
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 19 Sep 92*/
end_comment

begin_comment
comment|/*  * Initialization of interface (really just DS8390).   */
end_comment

begin_macro
name|weinit
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|we_if
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
operator|(
name|sc
operator|->
name|we_flags
operator|&
name|WDF_ATTACHED
operator|)
operator|==
literal|0
condition|)
block|{
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|we_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|we_flags
operator||=
name|WDF_ATTACHED
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* address not known */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
comment|/* already running */
comment|/*if (ifp->if_flags& IFF_RUNNING) return; */
comment|/* 	 * Initialize DS8390 in order given in NSC NIC manual. 	 * this is stock code...please see the National manual for details. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|Bdry
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 19 Sep 92*/
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WD8013
comment|/* 20 Sep 92*/
comment|/* enable 16 bit access if 8013 card */
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_DCR
argument_list|,
name|WD_D_CONFIG16
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !WD8013*/
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_DCR
argument_list|,
name|WD_D_CONFIG
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !WD8013*/
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_MON
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TCR
argument_list|,
name|WD_T_CONFIG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TPSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_PSTART
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_PSTOP
argument_list|,
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
name|WD_I_CONFIG
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_PAR0
operator|+
name|i
argument_list|,
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
operator|++
name|i
control|)
comment|/* == broadcast addr */
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|,
name|WD_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_stp
operator|=
literal|0
expr_stmt|;
name|wecmd
operator|.
name|cs_sta
operator|=
literal|1
expr_stmt|;
name|wecmd
operator|.
name|cs_rd
operator|=
literal|0x4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|we_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_PRO
operator||
name|WD_R_SEP
operator||
name|WD_R_AR
operator||
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
comment|/* 	 * Take the interface out of reset, program the vector,  	 * enable interrupts, and tell the world we are up. 	 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|westart
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Start output on interface.  */
end_comment

begin_macro
name|westart
argument_list|(
argument|ifp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|caddr_t
name|buffer
decl_stmt|;
name|int
name|len
decl_stmt|,
name|s
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
comment|/* 	 * The DS8390 has only one transmit buffer, if it is busy we 	 * must wait until the transmit interrupt completes. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|we_flags
operator|&
name|WDF_TXBUSY
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|we_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|we_flags
operator||=
name|WDF_TXBUSY
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|we_bpf
condition|)
block|{
name|u_short
name|etype
decl_stmt|;
name|int
name|off
decl_stmt|,
name|datasize
decl_stmt|,
name|resid
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
struct|struct
name|trailer_header
block|{
name|u_short
name|ether_type
decl_stmt|;
name|u_short
name|ether_residual
decl_stmt|;
block|}
name|trailer_header
struct|;
name|char
name|ether_packet
index|[
name|ETHERMTU
operator|+
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|ep
operator|=
name|ether_packet
expr_stmt|;
comment|/* 		 * We handle trailers below: 		 * Copy ether header first, then residual data, 		 * then data. Put all this in a temporary buffer 		 * 'ether_packet' and send off to bpf. Since the 		 * system has generated this packet, we assume 		 * that all of the offsets in the packet are 		 * correct; if they're not, the system will almost 		 * certainly crash in m_copydata. 		 * We make no assumptions about how the data is 		 * arranged in the mbuf chain (i.e. how much 		 * data is in each mbuf, if mbuf clusters are 		 * used, etc.), which is why we use m_copydata 		 * to get the ether header rather than assume 		 * that this is located in the first mbuf. 		 */
comment|/* copy ether header */
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|ep
expr_stmt|;
name|ep
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|datasize
operator|=
operator|(
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|<<
literal|9
operator|)
expr_stmt|;
name|off
operator|=
name|datasize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* copy trailer_header into a data structure */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
operator|&
name|trailer_header
operator|.
name|ether_type
argument_list|)
expr_stmt|;
comment|/* copy residual data */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
name|resid
operator|=
name|ntohs
argument_list|(
name|trailer_header
operator|.
name|ether_residual
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|resid
expr_stmt|;
comment|/* copy data */
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|datasize
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|datasize
expr_stmt|;
comment|/* restore original ether packet type */
name|eh
operator|->
name|ether_type
operator|=
name|trailer_header
operator|.
name|ether_type
expr_stmt|;
name|bpf_tap
argument_list|(
name|sc
operator|->
name|we_bpf
argument_list|,
name|ether_packet
argument_list|,
name|ep
operator|-
name|ether_packet
argument_list|)
expr_stmt|;
block|}
else|else
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|we_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Copy the mbuf chain into the transmit buffer 	 */
name|buffer
operator|=
name|sc
operator|->
name|we_vmem_addr
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|buffer
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* 	 * Init transmit length registers, and set transmit start flag. 	 */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|len
operator|=
name|MAX
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR1
argument_list|,
name|len
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_txp
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|sc
operator|->
name|we_if
operator|.
name|if_timer
operator|=
literal|3
expr_stmt|;
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface interrupt processor  */
end_comment

begin_macro
name|weintr
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|union
name|we_interrupt
name|weisr
decl_stmt|;
comment|/* disable onboard interrupts, then get interrupt status */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|weisr
operator|.
name|is_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|)
expr_stmt|;
name|loop
label|:
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|,
name|weisr
operator|.
name|is_byte
argument_list|)
expr_stmt|;
comment|/* transmit error */
if|if
condition|(
name|weisr
operator|.
name|is_txe
condition|)
block|{
comment|/* need to read these registers to clear status */
name|sc
operator|->
name|we_if
operator|.
name|if_collisions
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_oerrors
expr_stmt|;
block|}
comment|/* receiver error */
if|if
condition|(
name|weisr
operator|.
name|is_rxe
condition|)
block|{
comment|/* need to read these registers to clear status */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
literal|0xF
argument_list|)
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_ierrors
expr_stmt|;
block|}
comment|/* normal transmit complete */
if|if
condition|(
name|weisr
operator|.
name|is_ptx
operator|||
name|weisr
operator|.
name|is_txe
condition|)
name|wetint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* normal receive notification */
if|if
condition|(
name|weisr
operator|.
name|is_prx
operator|||
name|weisr
operator|.
name|is_rxe
condition|)
name|werint
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* try to start transmit */
name|westart
argument_list|(
operator|&
name|sc
operator|->
name|we_if
argument_list|)
expr_stmt|;
comment|/* re-enable onboard interrupts */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_IMR
argument_list|,
literal|0xff
comment|/*WD_I_CONFIG*/
argument_list|)
expr_stmt|;
name|weisr
operator|.
name|is_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_ISR
argument_list|)
expr_stmt|;
if|if
condition|(
name|weisr
operator|.
name|is_byte
condition|)
goto|goto
name|loop
goto|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface transmit interrupt.  */
end_comment

begin_macro
name|wetint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * Do some statistics (assume page zero of NIC mapped in) 	 */
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_TXBUSY
expr_stmt|;
name|sc
operator|->
name|we_if
operator|.
name|if_timer
operator|=
literal|0
expr_stmt|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_opackets
expr_stmt|;
name|sc
operator|->
name|we_if
operator|.
name|if_collisions
operator|+=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_TBCR0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Ethernet interface receiver interrupt.  */
end_comment

begin_macro
name|werint
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|bnry
decl_stmt|,
name|curr
decl_stmt|;
name|long
name|len
decl_stmt|;
name|union
name|we_command
name|wecmd
decl_stmt|;
name|struct
name|we_ring
modifier|*
name|wer
decl_stmt|;
comment|/* 	 * Traverse the receive ring looking for packets to pass back. 	 * The search is complete when we find a descriptor not in use. 	 */
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|bnry
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
if|if
condition|(
name|Bdry
index|[
name|unit
index|]
condition|)
comment|/* 19 Sep 92*/
name|bnry
operator|=
name|Bdry
index|[
name|unit
index|]
expr_stmt|;
while|while
condition|(
name|bnry
operator|!=
name|curr
condition|)
block|{
comment|/* get pointer to this buffer header structure */
name|wer
operator|=
operator|(
expr|struct
name|we_ring
operator|*
operator|)
operator|(
name|sc
operator|->
name|we_vmem_addr
operator|+
operator|(
name|bnry
operator|<<
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* count includes CRC */
name|len
operator|=
name|wer
operator|->
name|we_count
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|30
operator|&&
name|len
operator|<=
name|ETHERMTU
operator|+
literal|100
condition|)
name|weread
argument_list|(
name|sc
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|wer
operator|+
literal|1
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"we%d: reject - bad length %d"
argument_list|,
name|unit
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outofbufs
label|:
name|wecmd
operator|.
name|cs_byte
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|)
expr_stmt|;
name|wecmd
operator|.
name|cs_ps
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
comment|/* advance on chip Boundry register */
if|if
condition|(
operator|(
name|caddr_t
operator|)
name|wer
operator|+
name|WD_PAGE_SIZE
operator|-
literal|1
operator|>
name|sc
operator|->
name|we_vmem_end
condition|)
block|{
name|bnry
operator|=
name|WD_TXBUF_SIZE
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
literal|30
operator|&&
name|len
operator|<=
name|ETHERMTU
operator|+
literal|100
condition|)
name|bnry
operator|=
name|wer
operator|->
name|we_next_packet
expr_stmt|;
else|else
name|bnry
operator|=
name|curr
expr_stmt|;
comment|/* watch out for NIC overflow, reset Boundry if invalid */
if|if
condition|(
operator|(
name|bnry
operator|-
literal|1
operator|)
operator|<
name|WD_TXBUF_SIZE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
operator|(
name|sc
operator|->
name|we_vmem_size
operator|/
name|WD_PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bnry
operator|=
name|WD_TXBUF_SIZE
expr_stmt|;
block|}
else|else
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_BNRY
argument_list|,
name|bnry
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* refresh our copy of CURR */
name|wecmd
operator|.
name|cs_ps
operator|=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_COMMAND
argument_list|,
name|wecmd
operator|.
name|cs_byte
argument_list|)
expr_stmt|;
name|curr
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P1_CURR
argument_list|)
expr_stmt|;
block|}
name|Bdry
index|[
name|unit
index|]
operator|=
name|bnry
expr_stmt|;
comment|/* 19 Sep 92*/
block|}
end_block

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_expr_stmt
name|weioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|ns_addr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 * The manual says we cant change the address  				 * while the receiver is armed, 				 * so reset everything 				 */
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|ns_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ns_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* does ne_setaddr() */
break|break;
block|}
endif|#
directive|endif
default|default:
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|westop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|weinit
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|we_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_PRO
operator||
name|WD_R_SEP
operator||
name|WD_R_AR
operator||
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|outb
argument_list|(
name|sc
operator|->
name|we_io_nic_addr
operator|+
name|WD_P0_RCR
argument_list|,
name|WD_R_CONFIG
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notdef
case|case
name|SIOCGHWADDR
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * set ethernet address for unit  */
end_comment

begin_macro
name|wesetaddr
argument_list|(
argument|physaddr
argument_list|,
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|physaddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|we_softc
modifier|*
name|sc
init|=
operator|&
name|we_softc
index|[
name|unit
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Rewrite ethernet address, and then force restart of NIC 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|we_addr
index|[
name|i
index|]
operator|=
name|physaddr
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|we_flags
operator|&=
operator|~
name|WDF_RUNNING
expr_stmt|;
name|weinit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|ringoffset
parameter_list|(
name|sc
parameter_list|,
name|eh
parameter_list|,
name|off
parameter_list|,
name|type
parameter_list|)
define|\
value|((type)( ((caddr_t)(eh)+(off)>= (sc)->we_vmem_end) ? \ 		(((caddr_t)(eh)+(off))) - (sc)->we_vmem_end \ 		+ (sc)->we_vmem_ring: \ 		((caddr_t)(eh)+(off)) ))
end_define

begin_comment
comment|/*  * Pass a packet to the higher levels.  * We deal with the trailer protocol here.  */
end_comment

begin_expr_stmt
name|weread
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
specifier|register
expr|struct
name|we_softc
operator|*
name|sc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|caddr_t
name|we_ring_copy
parameter_list|()
function_decl|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
name|we_ring_to_mbuf
argument_list|()
decl_stmt|;
name|int
name|off
decl_stmt|,
name|resid
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
struct|struct
name|trailer_header
block|{
name|u_short
name|trail_type
decl_stmt|;
name|u_short
name|trail_residual
decl_stmt|;
block|}
name|trailer_header
struct|;
operator|++
name|sc
operator|->
name|we_if
operator|.
name|if_ipackets
expr_stmt|;
comment|/* Allocate a header mbuf */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|we_if
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|m
expr_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
define|#
directive|define
name|EROUND
value|((sizeof(struct ether_header) + 3)& ~3)
define|#
directive|define
name|EOFF
value|(EROUND - sizeof(struct ether_header))
comment|/* 	 * The following assumes there is room for 	 * the ether header in the header mbuf 	 */
name|head
operator|->
name|m_data
operator|+=
name|EOFF
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|head
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|head
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with trailer protocol: 	 * If trailer protocol, calculate the datasize as 'off', 	 * which is also the offset to the trailer header. 	 * Set resid to the amount of packet data following the 	 * trailer header. 	 * Finally, copy residual data into mbuf chain. 	 */
if|if
condition|(
name|etype
operator|>=
name|ETHERTYPE_TRAIL
operator|&&
name|etype
operator|<
name|ETHERTYPE_TRAIL
operator|+
name|ETHERTYPE_NTRAILER
condition|)
block|{
name|off
operator|=
operator|(
name|etype
operator|-
name|ETHERTYPE_TRAIL
operator|)
operator|<<
literal|9
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
operator|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
name|eh
operator|->
name|ether_type
operator|=
operator|*
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
argument_list|,
name|u_short
operator|*
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ntohs
argument_list|(
operator|*
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
operator|+
literal|2
argument_list|,
name|u_short
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|+
name|resid
operator|)
operator|>
name|len
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
name|resid
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|trailer_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* insanity */
name|m
operator|=
name|we_ring_to_mbuf
argument_list|(
name|sc
argument_list|,
name|ringoffset
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|off
operator|+
literal|4
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|head
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|len
operator|=
name|off
expr_stmt|;
name|head
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
literal|4
expr_stmt|;
comment|/* subtract trailer header */
block|}
comment|/* 	 * Pull packet off interface. Or if this was a trailer packet, 	 * the data portion is appended. 	 */
name|m
operator|=
name|we_ring_to_mbuf
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to bpf.  	 */
if|if
condition|(
name|sc
operator|->
name|we_bpf
condition|)
block|{
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|we_bpf
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that the interface cannot be in promiscuous mode if 	 * there are no bpf listeners.  And if we are in promiscuous 	 * mode, we have to check if this packet is really ours. 	 * 	 * XXX This test does not support multicasts. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|we_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|we_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Fix up data start offset in mbuf to point past ether header 	 */
name|m_adj
argument_list|(
name|head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * silly ether_input routine needs 'type' in host byte order 	 */
name|eh
operator|->
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|we_if
argument_list|,
name|eh
argument_list|,
name|head
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
if|if
condition|(
name|head
condition|)
name|m_freem
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/*  * Supporting routines  */
end_comment

begin_comment
comment|/*  * Copy data from receive buffer to end of mbuf chain  * allocate additional mbufs as needed. return pointer  * to last mbuf in chain.  * sc = we info  * src = pointer in we ring buffer  * dst = pointer to last mbuf in mbuf chain to copy to  * amount = amount of data to copy  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|we_ring_to_mbuf
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|total_len
parameter_list|)
name|struct
name|we_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dst
decl_stmt|;
name|int
name|total_len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|total_len
operator|>
literal|0
condition|)
block|{
specifier|register
name|int
name|amount
init|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|amount
operator|==
literal|0
condition|)
block|{
comment|/* no more data in this mbuf, alloc another */
comment|/* 			 * if there is enough data for an mbuf cluster, attempt 			 * to allocate one of those, otherwise, a regular mbuf 			 * will do. 			 */
name|dst
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|total_len
operator|>=
name|MINCLSIZE
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|dst
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|amount
operator|=
name|min
argument_list|(
name|total_len
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|src
operator|=
name|we_ring_copy
argument_list|(
name|sc
argument_list|,
name|src
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|amount
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|amount
expr_stmt|;
name|total_len
operator|-=
name|amount
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|we_ring_copy
parameter_list|(
name|sc
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|amount
parameter_list|)
name|struct
name|we_softc
modifier|*
name|sc
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|int
name|amount
decl_stmt|;
block|{
name|int
name|tmp_amount
decl_stmt|;
comment|/* does copy wrap to lower addr in ring buffer? */
if|if
condition|(
name|src
operator|+
name|amount
operator|>
name|sc
operator|->
name|we_vmem_end
condition|)
block|{
name|tmp_amount
operator|=
name|sc
operator|->
name|we_vmem_end
operator|-
name|src
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|tmp_amount
argument_list|)
expr_stmt|;
comment|/* copy amount up to end */
name|amount
operator|-=
name|tmp_amount
expr_stmt|;
name|src
operator|=
name|sc
operator|->
name|we_vmem_ring
expr_stmt|;
name|dst
operator|+=
name|tmp_amount
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|amount
argument_list|)
expr_stmt|;
return|return
operator|(
name|src
operator|+
name|amount
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

