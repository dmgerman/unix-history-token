begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Kazutaka YOKOTA (yokota@zodiac.mech.utsunomiya-u.ac.jp)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote   *    products derived from this software without specific prior written   *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id$  */
end_comment

begin_include
include|#
directive|include
file|"sc.h"
end_include

begin_include
include|#
directive|include
file|"opt_syscons.h"
end_include

begin_if
if|#
directive|if
name|NSC
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/console.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/videoio.h>
end_include

begin_comment
comment|/* this should really be in `rtc.h' */
end_comment

begin_define
define|#
directive|define
name|RTC_EQUIPMENT
value|0x14
end_define

begin_comment
comment|/* video adapter state buffer */
end_comment

begin_struct
struct|struct
name|adp_state
block|{
name|int
name|sig
decl_stmt|;
define|#
directive|define
name|V_STATE_SIG
value|0x736f6962
name|u_char
name|regs
index|[
name|V_MODE_PARAM_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|adp_state
name|adp_state_t
typedef|;
end_typedef

begin_comment
comment|/* video adapter information */
end_comment

begin_define
define|#
directive|define
name|DCC_MONO
value|0
end_define

begin_define
define|#
directive|define
name|DCC_CGA40
value|1
end_define

begin_define
define|#
directive|define
name|DCC_CGA80
value|2
end_define

begin_define
define|#
directive|define
name|DCC_EGAMONO
value|3
end_define

begin_define
define|#
directive|define
name|DCC_EGA40
value|4
end_define

begin_define
define|#
directive|define
name|DCC_EGA80
value|5
end_define

begin_comment
comment|/*   * NOTE: `va_window' should have a virtual address, but is initialized  * with a physical address in the following table, as verify_adapter()  * will perform address conversion at run-time.  */
end_comment

begin_decl_stmt
specifier|static
name|video_adapter_t
name|adapter_init_value
index|[]
init|=
block|{
block|{
literal|0
block|,
name|KD_MONO
block|,
literal|0
block|,
name|MONO_BASE
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|KD_CGA
block|,
name|V_ADP_COLOR
block|,
name|COLOR_BASE
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|KD_CGA
block|,
name|V_ADP_COLOR
block|,
name|COLOR_BASE
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|KD_EGA
block|,
literal|0
block|,
name|MONO_BASE
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|KD_EGA
block|,
name|V_ADP_COLOR
block|,
name|COLOR_BASE
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
name|KD_EGA
block|,
name|V_ADP_COLOR
block|,
name|COLOR_BASE
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|video_adapter_t
name|adapter
index|[
name|V_MAX_ADAPTERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adapters
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VGA function entries */
end_comment

begin_decl_stmt
specifier|static
name|vi_init_t
name|vid_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_adapter_t
name|vid_adapter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_get_info_t
name|vid_get_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_query_mode_t
name|vid_query_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_mode_t
name|vid_set_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_font_t
name|vid_save_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_font_t
name|vid_load_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_show_font_t
name|vid_show_font
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_palette_t
name|vid_save_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_palette_t
name|vid_load_palette
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_border_t
name|vid_set_border
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_save_state_t
name|vid_save_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_load_state_t
name|vid_load_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_win_org_t
name|vid_set_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_read_hw_cursor_t
name|vid_read_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_set_hw_cursor_t
name|vid_set_hw_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vi_diag_t
name|vid_diag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vidsw
name|biosvidsw
init|=
block|{
name|vid_init
block|,
name|vid_adapter
block|,
name|vid_get_info
block|,
name|vid_query_mode
block|,
name|vid_set_mode
block|,
name|vid_save_font
block|,
name|vid_load_font
block|,
name|vid_show_font
block|,
name|vid_save_palette
block|,
name|vid_load_palette
block|,
name|vid_set_border
block|,
name|vid_save_state
block|,
name|vid_load_state
block|,
name|vid_set_origin
block|,
name|vid_read_hw_cursor
block|,
name|vid_set_hw_cursor
block|,
name|vid_diag
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VGA BIOS standard video modes */
end_comment

begin_define
define|#
directive|define
name|EOT
value|(-1)
end_define

begin_define
define|#
directive|define
name|NA
value|(-2)
end_define

begin_decl_stmt
specifier|static
name|video_info_t
name|bios_vmode
index|[]
init|=
block|{
comment|/* CGA */
block|{
name|M_B40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_B80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* EGA */
block|{
name|M_ENH_B40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_ENH_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_ENH_B80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_ENH_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* VGA */
block|{
name|M_VGA_C40x25
block|,
name|V_INFO_COLOR
block|,
literal|40
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_M80x25
block|,
literal|0
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
literal|1
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_C80x25
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* MDA */
block|{
name|M_EGAMONO80x25
block|,
literal|0
block|,
literal|80
block|,
literal|25
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|1
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* EGA */
block|{
name|M_ENH_B80x43
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|43
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_ENH_C80x43
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|43
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* VGA */
block|{
name|M_VGA_M80x30
block|,
literal|0
block|,
literal|80
block|,
literal|30
block|,
literal|8
block|,
literal|16
block|,
literal|2
block|,
literal|1
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_C80x30
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|30
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_M80x50
block|,
literal|0
block|,
literal|80
block|,
literal|50
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_C80x50
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|50
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_M80x60
block|,
literal|0
block|,
literal|80
block|,
literal|60
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb0000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_VGA_C80x60
block|,
name|V_INFO_COLOR
block|,
literal|80
block|,
literal|60
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* CGA */
block|{
name|M_BG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_CG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
block|{
name|M_BG640
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|,
literal|0xb8000
block|,
literal|32
block|,
literal|32
block|,
literal|0
block|,
literal|32
block|}
block|,
comment|/* EGA */
block|{
name|M_CG320_D
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_CG640_E
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_EGAMONOAPA
block|,
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_ENHMONOAPA2
block|,
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_CG640x350
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|2
block|,
literal|2
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_ENH_CG640
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|350
block|,
literal|8
block|,
literal|14
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
comment|/* VGA */
block|{
name|M_BG640x480
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|480
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_CG640x480
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|640
block|,
literal|480
block|,
literal|8
block|,
literal|16
block|,
literal|4
block|,
literal|4
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_VGA_CG320
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|200
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|M_VGA_MODEX
block|,
name|V_INFO_COLOR
operator||
name|V_INFO_GRAPHICS
block|,
literal|320
block|,
literal|240
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|1
block|,
literal|0xa0000
block|,
literal|64
block|,
literal|64
block|,
literal|0
block|,
literal|64
block|}
block|,
block|{
name|EOT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_done
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|video_mode_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* EGA/VGA */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|video_mode_ptr2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CGA/MDA */
end_comment

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|mode_map
index|[
name|V_MODE_MAP_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|adp_state_t
name|adpstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|adp_state_t
name|adpstate2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rows_offset
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local macros and functions */
end_comment

begin_define
define|#
directive|define
name|BIOS_SADDRTOLADDR
parameter_list|(
name|p
parameter_list|)
value|((((p)& 0xffff0000)>> 12) + ((p)& 0x0000ffff))
end_define

begin_function_decl
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clear_mode_map
parameter_list|(
name|int
name|ad
parameter_list|,
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|color
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_mode_num
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|map_bios_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|bios_mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|get_mode_param
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fill_adapter_param
parameter_list|(
name|int
name|code
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|verify_adapter
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|COMP_IDENTICAL
value|0
end_define

begin_define
define|#
directive|define
name|COMP_SIMILAR
value|1
end_define

begin_define
define|#
directive|define
name|COMP_DIFFERENT
value|2
end_define

begin_function_decl
specifier|static
name|int
name|comp_adpregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PARAM_BUFSIZE
value|6
end_define

begin_function_decl
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|adapter_name
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_adp_info
parameter_list|(
name|int
name|ad
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_mode_info
parameter_list|(
name|int
name|ad
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|level
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_buffer
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|generic_bcopy
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISMAPPED
parameter_list|(
name|pa
parameter_list|,
name|width
parameter_list|)
define|\
value|(((pa)<= (u_long)0x1000 - (width)) 		\ 	 || ((pa)>= ISA_HOLE_START&& (pa)<= 0x100000 - (width)))
end_define

begin_define
define|#
directive|define
name|prologue
parameter_list|(
name|ad
parameter_list|,
name|flag
parameter_list|,
name|err
parameter_list|)
define|\
value|if (!init_done					\ 	    || ((ad)< 0) || ((ad)>= adapters)		\ 	    || !(adapter[(ad)].va_flags& (flag)))	\ 	    return (err)
end_define

begin_comment
comment|/* construct the mode parameter map */
end_comment

begin_function
specifier|static
name|void
name|map_mode_table
parameter_list|(
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|u_char
modifier|*
name|table
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|table
operator|+
name|i
operator|*
name|V_MODE_PARAM_SIZE
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|V_MODE_MAP_SIZE
condition|;
operator|++
name|i
control|)
name|map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_mode_map
parameter_list|(
name|int
name|ad
parameter_list|,
name|u_char
modifier|*
name|map
index|[]
parameter_list|,
name|int
name|max
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/*      * NOTE: we don't touch `bios_vmode[]' because it is shared      * by all adapters.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|vid_get_info
argument_list|(
name|ad
argument_list|,
name|i
argument_list|,
operator|&
name|info
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
operator|!=
name|color
condition|)
name|map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* the non-standard video mode is based on a standard mode... */
end_comment

begin_function
specifier|static
name|int
name|map_mode_num
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|from
decl_stmt|;
name|int
name|to
decl_stmt|;
block|}
name|mode_map
index|[]
init|=
block|{
block|{
name|M_ENH_B80x43
block|,
name|M_ENH_B80x25
block|}
block|,
block|{
name|M_ENH_C80x43
block|,
name|M_ENH_C80x25
block|}
block|,
block|{
name|M_VGA_M80x30
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x30
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x50
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x50
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_M80x60
block|,
name|M_VGA_M80x25
block|}
block|,
block|{
name|M_VGA_C80x60
block|,
name|M_VGA_C80x25
block|}
block|,
block|{
name|M_VGA_MODEX
block|,
name|M_VGA_CG320
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mode_map
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|mode_map
index|[
name|i
index|]
operator|.
name|from
operator|==
name|mode
condition|)
return|return
name|mode_map
index|[
name|i
index|]
operator|.
name|to
return|;
block|}
return|return
name|mode
return|;
block|}
end_function

begin_comment
comment|/* turn the BIOS video number into our video mode number */
end_comment

begin_function
specifier|static
name|int
name|map_bios_mode_num
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|color
parameter_list|,
name|int
name|bios_mode
parameter_list|)
block|{
specifier|static
name|int
name|cga_modes
index|[
literal|7
index|]
init|=
block|{
name|M_B40x25
block|,
name|M_C40x25
block|,
comment|/* 0, 1 */
name|M_B80x25
block|,
name|M_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,     }
decl_stmt|;
specifier|static
name|int
name|ega_modes
index|[
literal|17
index|]
init|=
block|{
name|M_ENH_B40x25
block|,
name|M_ENH_C40x25
block|,
comment|/* 0, 1 */
name|M_ENH_B80x25
block|,
name|M_ENH_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,
name|M_EGAMONO80x25
block|,
comment|/* 7 */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
name|M_CG320_D
block|,
name|M_CG640_E
block|,
name|M_ENHMONOAPA2
block|,
comment|/* XXX: video momery> 64K */
name|M_ENH_CG640
block|,
comment|/* XXX: video momery> 64K */
block|}
decl_stmt|;
specifier|static
name|int
name|vga_modes
index|[
literal|20
index|]
init|=
block|{
name|M_VGA_C40x25
block|,
name|M_VGA_C40x25
block|,
comment|/* 0, 1 */
name|M_VGA_C80x25
block|,
name|M_VGA_C80x25
block|,
comment|/* 2, 3 */
name|M_BG320
block|,
name|M_CG320
block|,
name|M_BG640
block|,
name|M_VGA_M80x25
block|,
comment|/* 7 */
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
name|M_CG320_D
block|,
name|M_CG640_E
block|,
name|M_ENHMONOAPA2
block|,
name|M_ENH_CG640
block|,
name|M_BG640x480
block|,
name|M_CG640x480
block|,
name|M_VGA_CG320
block|,     }
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|KD_VGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|vga_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|vga_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|vga_modes
index|[
name|bios_mode
index|]
return|;
elseif|else
if|if
condition|(
name|color
condition|)
return|return
name|M_VGA_C80x25
return|;
else|else
return|return
name|M_VGA_M80x25
return|;
break|break;
case|case
name|KD_EGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|ega_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ega_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|ega_modes
index|[
name|bios_mode
index|]
return|;
elseif|else
if|if
condition|(
name|color
condition|)
return|return
name|M_ENH_C80x25
return|;
else|else
return|return
name|M_EGAMONO80x25
return|;
break|break;
case|case
name|KD_CGA
case|:
if|if
condition|(
name|bios_mode
operator|<
sizeof|sizeof
argument_list|(
name|cga_modes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cga_modes
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|cga_modes
index|[
name|bios_mode
index|]
return|;
else|else
return|return
name|M_C80x25
return|;
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
return|return
name|M_EGAMONO80x25
return|;
comment|/* XXX: this name is confusing */
default|default:
break|break;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* look up a parameter table entry */
end_comment

begin_function
specifier|static
name|u_char
modifier|*
name|get_mode_param
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>=
name|V_MODE_MAP_SIZE
condition|)
name|mode
operator|=
name|map_mode_num
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|<
name|V_MODE_MAP_SIZE
condition|)
return|return
name|mode_map
index|[
name|mode
index|]
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_adapter_param
parameter_list|(
name|int
name|code
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|primary
decl_stmt|;
name|int
name|secondary
decl_stmt|;
block|}
name|dcc
index|[]
init|=
block|{
block|{
name|DCC_MONO
block|,
name|DCC_EGA40
comment|/* CGA monitor */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
comment|/* CGA monitor */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
comment|/* CGA emulation */
block|}
block|,
block|{
name|DCC_MONO
block|,
name|DCC_EGA80
block|}
block|,
block|{
name|DCC_CGA40
block|,
name|DCC_EGAMONO
block|}
block|,
block|{
name|DCC_CGA80
block|,
name|DCC_EGAMONO
block|}
block|,
block|{
name|DCC_EGA40
comment|/* CGA monitor */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
comment|/* CGA monitor */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
comment|/* CGA emulation */
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGA80
block|,
name|DCC_MONO
block|}
block|,
block|{
name|DCC_EGAMONO
block|,
name|DCC_CGA40
block|}
block|,
block|{
name|DCC_EGAMONO
block|,
name|DCC_CGA40
block|}
block|,     }
struct|;
if|if
condition|(
operator|(
name|code
operator|<
literal|0
operator|)
operator|||
operator|(
name|code
operator|>=
sizeof|sizeof
argument_list|(
name|dcc
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dcc
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|adp
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
name|adp
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
block|}
else|else
block|{
name|adp
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|dcc
index|[
name|code
index|]
operator|.
name|primary
index|]
expr_stmt|;
name|adp
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|dcc
index|[
name|code
index|]
operator|.
name|secondary
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|verify_adapter
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|)
block|{
name|u_short
specifier|volatile
modifier|*
name|buf
decl_stmt|;
name|u_short
name|v
decl_stmt|;
name|u_int32_t
name|p
decl_stmt|;
name|buf
operator|=
operator|(
name|u_short
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|adp
operator|->
name|va_window
argument_list|)
expr_stmt|;
name|v
operator|=
operator|*
name|buf
expr_stmt|;
operator|*
name|buf
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|0xA55A
condition|)
return|return
literal|1
return|;
operator|*
name|buf
operator|=
name|v
expr_stmt|;
switch|switch
condition|(
name|adp
operator|->
name|va_type
condition|)
block|{
case|case
name|KD_EGA
case|:
name|outb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
argument_list|)
operator|==
literal|7
condition|)
block|{
name|adp
operator|->
name|va_type
operator|=
name|KD_VGA
expr_stmt|;
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_STATESAVE
operator||
name|V_ADP_PALETTE
expr_stmt|;
block|}
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_STATELOAD
operator||
name|V_ADP_FONT
operator||
name|V_ADP_BORDER
expr_stmt|;
comment|/* the color adapter may be in the 40x25 mode... XXX */
comment|/* get the BIOS video mode pointer */
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x4a8
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
condition|)
block|{
name|p
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|BIOS_SADDRTOLADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISMAPPED
argument_list|(
name|p
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
condition|)
name|video_mode_ptr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KD_CGA
case|:
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_COLOR
operator||
name|V_ADP_BORDER
expr_stmt|;
comment|/* may be in the 40x25 mode... XXX */
break|break;
case|case
name|KD_MONO
case|:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* compare two parameter table entries */
end_comment

begin_function
specifier|static
name|int
name|comp_adpregs
parameter_list|(
name|u_char
modifier|*
name|buf1
parameter_list|,
name|u_char
modifier|*
name|buf2
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|u_char
name|mask
decl_stmt|;
block|}
name|params
index|[
name|V_MODE_PARAM_SIZE
index|]
init|=
block|{
literal|0xff
block|,
literal|0x00
block|,
literal|0xff
block|,
comment|/* COLS, ROWS, POINTS */
literal|0x00
block|,
literal|0x00
block|,
comment|/* page length */
literal|0xfe
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* sequencer registers */
literal|0xf3
block|,
comment|/* misc register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
comment|/* CRTC */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x7f
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xef
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* attribute controller registers */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xf0
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
comment|/* GDC register */
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,      }
struct|;
name|int
name|identical
init|=
name|TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|buf1
operator|==
name|NULL
operator|)
operator|||
operator|(
name|buf2
operator|==
name|NULL
operator|)
condition|)
return|return
name|COMP_DIFFERENT
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|params
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|params
index|[
literal|0
index|]
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|==
literal|0
condition|)
comment|/* don't care */
continue|continue;
if|if
condition|(
operator|(
name|buf1
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
operator|!=
operator|(
name|buf2
index|[
name|i
index|]
operator|&
name|params
index|[
name|i
index|]
operator|.
name|mask
operator|)
condition|)
return|return
name|COMP_DIFFERENT
return|;
if|if
condition|(
name|buf1
index|[
name|i
index|]
operator|!=
name|buf2
index|[
name|i
index|]
condition|)
name|identical
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
operator|(
name|identical
operator|)
condition|?
name|COMP_IDENTICAL
else|:
name|COMP_SIMILAR
return|;
block|}
end_function

begin_comment
comment|/* exported functions */
end_comment

begin_comment
comment|/* all adapters */
end_comment

begin_function
specifier|static
name|int
name|vid_init
parameter_list|(
name|void
parameter_list|)
block|{
name|video_adapter_t
modifier|*
name|adp
decl_stmt|;
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* do this test only once */
if|if
condition|(
name|init_done
condition|)
return|return
name|adapters
return|;
name|init_done
operator|=
name|TRUE
expr_stmt|;
comment|/*       * Locate display adapters.       * The AT architecture supports upto two adapters. `syscons' allows      * the following combinations of adapters:       *     1) MDA + CGA      *     2) MDA + EGA/VGA color       *     3) CGA + EGA/VGA mono      * Note that `syscons' doesn't bother with MCGA as it is only      * avaiable for low end PS/2 models which has 80286 or earlier CPUs,      * thus, they are not running FreeBSD!      * When there are two adapaters in the system, one becomes `primary'      * and the other `secondary'. The EGA adapter has a set of DIP       * switches on board for this information and the EGA BIOS copies       * it in the BIOS data area BIOSDATA_VIDEOSWITCH (40:88).       * The VGA BIOS has more sophisticated mechanism and has this       * information in BIOSDATA_DCCINDEX (40:8a), but it also maintains       * compatibility with the EGA BIOS by updating BIOSDATA_VIDEOSWITCH.      */
comment|/* check rtc and BIOS date area */
comment|/*       * XXX: don't use BIOSDATA_EQUIPMENT, it is not a dead copy      * of RTC_EQUIPMENT. The bit 4 and 5 of the ETC_EQUIPMENT are      * zeros for EGA and VGA. However, the EGA/VGA BIOS will set       * these bits in BIOSDATA_EQUIPMENT according to the monitor      * type detected.      */
switch|switch
condition|(
operator|(
name|rtcin
argument_list|(
name|RTC_EQUIPMENT
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|3
condition|)
block|{
comment|/* bit 4 and 5 */
case|case
literal|0
case|:
comment|/* EGA/VGA */
name|fill_adapter_param
argument_list|(
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x488
argument_list|)
operator|&
literal|0x0f
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* CGA 40x25 */
comment|/* FIXME: switch to the 80x25 mode? XXX */
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA40
index|]
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* CGA 80x25 */
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* MDA */
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_MONO
index|]
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|=
name|adapter_init_value
index|[
name|DCC_CGA80
index|]
expr_stmt|;
break|break;
block|}
name|adapters
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|verify_adapter
argument_list|(
operator|&
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|adapters
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_mode
operator|=
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_mode
operator|=
name|map_bios_mode_num
argument_list|(
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
argument_list|,
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|verify_adapter
argument_list|(
operator|&
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|adapters
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_bios_mode
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x449
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_mode
operator|=
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_mode
operator|=
name|map_bios_mode_num
argument_list|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
argument_list|,
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
argument_list|,
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_bios_mode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|=
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|adapters
operator|==
literal|0
condition|)
return|return
name|adapters
return|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_index
operator|=
name|V_ADP_PRIMARY
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_index
operator|=
name|V_ADP_SECONDARY
expr_stmt|;
if|#
directive|if
literal|0
comment|/*      * We cannot have two video adapter of the same type; there must be      * only one of color or mono adapter, or one each of them.      */
block|if (adapters> 1) { 	if (!((adapter[0].va_flags ^ adapter[1].va_flags)& V_ADP_COLOR))
comment|/* we have two mono or color adapters!! */
block|return (adapters = 0);     }
endif|#
directive|endif
comment|/*      * Ensure a zero start address.  This is mainly to recover after      * switching from pcvt using userconfig().  The registers are w/o      * for old hardware so it's too hard to relocate the active screen      * memory.      * This must be done before vid_save_state() for VGA.      */
name|outb
argument_list|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|13
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* the video mode parameter table in EGA/VGA BIOS */
comment|/* NOTE: there can be only one EGA/VGA, wheather color or mono,      * recognized by the video BIOS.      */
if|if
condition|(
operator|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
operator|==
name|KD_EGA
operator|)
operator|||
operator|(
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
operator|)
condition|)
block|{
name|adp
operator|=
operator|&
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|==
name|KD_EGA
operator|)
operator|||
operator|(
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
operator|)
condition|)
block|{
name|adp
operator|=
operator|&
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
expr_stmt|;
block|}
else|else
block|{
name|adp
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|vid_save_state
argument_list|(
name|adp
operator|-
name|adapter
argument_list|,
operator|&
name|adpstate
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
block|{
name|mode_map
index|[
name|map_mode_num
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* discard the table if we are not familiar with it... */
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|mp
argument_list|,
name|adpstate2
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|comp_adpregs
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|,
name|mp
argument_list|)
condition|)
block|{
case|case
name|COMP_IDENTICAL
case|:
comment|/* 		     * OK, this parameter table looks reasonably familiar 		     * to us... 		     */
comment|/*  		     * This is a kludge for Toshiba DynaBook SS433  		     * whose BIOS video mode table entry has the actual #  		     * of rows at the offset 1; BIOSes from other  		     * manufacturers store the # of rows - 1 there. XXX 		     */
name|rows_offset
operator|=
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|mp
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|COMP_SIMILAR
case|:
comment|/* 		     * Not exactly the same, but similar enough to be 		     * trusted. However, use the saved register values 		     * for the initial mode and other modes which are 		     * based on the initial mode. 		     */
name|mode_map
index|[
name|map_mode_num
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|+
literal|1
operator|-
name|mp
index|[
literal|1
index|]
expr_stmt|;
name|adpstate
operator|.
name|regs
index|[
literal|1
index|]
operator|-=
name|rows_offset
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|COMP_DIFFERENT
case|:
default|default:
comment|/* 		     * Don't use the paramter table in BIOS. It doesn't 		     * look familiar to us. Video mode switching is allowed 		     * only if the new mode is the same as or based on 		     * the initial mode.  		     */
name|video_mode_ptr
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
name|mode_map
index|[
name|map_mode_num
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
index|]
operator|=
name|adpstate
operator|.
name|regs
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_MODECHANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_EGA
condition|)
block|{
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
block|{
name|adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_FONT
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|map_mode_table
argument_list|(
name|mode_map
argument_list|,
name|video_mode_ptr
argument_list|,
name|M_ENH_C80x25
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX how can one validate the EGA table... */
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
name|adp
operator|->
name|va_flags
operator||=
name|V_ADP_MODECHANGE
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		     * This is serious. We will not be able to switch video 		     * modes at all... 		     */
name|adp
operator|->
name|va_flags
operator|&=
operator|~
name|V_ADP_FONT
expr_stmt|;
name|video_mode_ptr
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|mode_map
argument_list|,
sizeof|sizeof
argument_list|(
name|mode_map
argument_list|)
argument_list|)
expr_stmt|;
name|rows_offset
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* remove conflicting modes if we have more than one adapter */
if|if
condition|(
name|adapters
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|adapters
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|adapter
index|[
name|i
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
continue|continue;
name|clear_mode_map
argument_list|(
name|i
argument_list|,
name|mode_map
argument_list|,
name|M_VGA_CG320
operator|+
literal|1
argument_list|,
operator|(
name|adapter
index|[
name|i
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|V_INFO_COLOR
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* buffer address */
name|vid_get_info
argument_list|(
name|V_ADP_PRIMARY
argument_list|,
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_window
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_window
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_window_size
operator|=
name|info
operator|.
name|vi_window_size
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_window_gran
operator|=
name|info
operator|.
name|vi_window_gran
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_buffer
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_buffer
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_PRIMARY
index|]
operator|.
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
if|if
condition|(
name|adapters
operator|>
literal|1
condition|)
block|{
name|vid_get_info
argument_list|(
name|V_ADP_SECONDARY
argument_list|,
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_window
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_window
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_window_size
operator|=
name|info
operator|.
name|vi_window_size
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_window_gran
operator|=
name|info
operator|.
name|vi_window_gran
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_buffer
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_buffer
argument_list|)
expr_stmt|;
name|adapter
index|[
name|V_ADP_SECONDARY
index|]
operator|.
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
block|}
comment|/*      * XXX: we should verify the following values for the primary adapter...      * crtc I/O port address: *(u_int16_t *)BIOS_PADDRTOVADDR(0x463);      * color/mono display: (*(u_int8_t *)BIOS_PADDRTOVADDR(0x487)& 0x02)       *                     ? 0 : V_ADP_COLOR;      * columns: *(u_int8_t *)BIOS_PADDRTOVADDR(0x44a);      * rows: *(u_int8_t *)BIOS_PADDRTOVADDR(0x484);      * font size: *(u_int8_t *)BIOS_PADDRTOVADDR(0x485);      * buffer size: *(u_int16_t *)BIOS_PADDRTOVADDR(0x44c);      */
return|return
name|adapters
return|;
block|}
end_function

begin_comment
comment|/* all adapters */
end_comment

begin_function
specifier|static
name|video_adapter_t
modifier|*
name|vid_adapter
parameter_list|(
name|int
name|ad
parameter_list|)
block|{
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|ad
operator|<
literal|0
operator|)
operator|||
operator|(
name|ad
operator|>=
name|adapters
operator|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|adapter
index|[
name|ad
index|]
return|;
block|}
end_function

begin_comment
comment|/* all adapters */
end_comment

begin_function
specifier|static
name|int
name|vid_get_info
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|mode
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ad
operator|<
literal|0
operator|)
operator|||
operator|(
name|ad
operator|>=
name|adapters
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_MODECHANGE
condition|)
block|{
comment|/* 	 * If the parameter table entry for this mode is not found,  	 * the mode is not supported... 	 */
if|if
condition|(
name|get_mode_param
argument_list|(
name|mode
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/*  	 * Even if we don't support video mode switching on this adapter, 	 * the information on the initial (thus current) video mode  	 * should be made available. 	 */
if|if
condition|(
name|mode
operator|!=
name|adapter
index|[
name|ad
index|]
operator|.
name|va_initial_mode
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|==
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
condition|)
block|{
operator|*
name|info
operator|=
name|bios_vmode
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* all adapters */
end_comment

begin_function
specifier|static
name|int
name|vid_query_mode
parameter_list|(
name|int
name|ad
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|)
block|{
name|video_info_t
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|ad
operator|<
literal|0
operator|)
operator|||
operator|(
name|ad
operator|>=
name|adapters
operator|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_width
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_width
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_width
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_height
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_height
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_height
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cwidth
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_cwidth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_cheight
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_cheight
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_depth
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_depth
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_depth
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|info
operator|->
name|vi_planes
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_planes
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_planes
operator|)
condition|)
continue|continue;
comment|/* XXX: should check pixel format, memory model */
if|if
condition|(
operator|(
name|info
operator|->
name|vi_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|info
operator|->
name|vi_flags
operator|!=
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_flags
operator|)
condition|)
continue|continue;
comment|/* verify if this mode is supported on this adapter */
if|if
condition|(
name|vid_get_info
argument_list|(
name|ad
argument_list|,
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
argument_list|,
operator|&
name|buf
argument_list|)
condition|)
continue|continue;
return|return
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_set_mode
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|adp_state_t
name|params
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_MODECHANGE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vid_get_info
argument_list|(
name|ad
argument_list|,
name|mode
argument_list|,
operator|&
name|info
argument_list|)
condition|)
return|return
literal|1
return|;
name|params
operator|.
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
name|bcopy
argument_list|(
name|get_mode_param
argument_list|(
name|mode
argument_list|)
argument_list|,
name|params
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|params
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|M_VGA_C80x60
case|:
case|case
name|M_VGA_M80x60
case|:
name|params
operator|.
name|regs
index|[
literal|2
index|]
operator|=
literal|0x08
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|0x47
expr_stmt|;
goto|goto
name|special_480l
goto|;
case|case
name|M_VGA_C80x30
case|:
case|case
name|M_VGA_M80x30
case|:
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|0x4f
expr_stmt|;
name|special_480l
label|:
name|params
operator|.
name|regs
index|[
literal|9
index|]
operator||=
literal|0xc0
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|16
index|]
operator|=
literal|0x08
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|17
index|]
operator|=
literal|0x3e
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|26
index|]
operator|=
literal|0xea
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|28
index|]
operator|=
literal|0xdf
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|31
index|]
operator|=
literal|0xe7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|32
index|]
operator|=
literal|0x04
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_ENH_C80x43
case|:
case|case
name|M_ENH_B80x43
case|:
name|params
operator|.
name|regs
index|[
literal|28
index|]
operator|=
literal|87
expr_stmt|;
goto|goto
name|special_80x50
goto|;
case|case
name|M_VGA_C80x50
case|:
case|case
name|M_VGA_M80x50
case|:
name|special_80x50
label|:
name|params
operator|.
name|regs
index|[
literal|2
index|]
operator|=
literal|8
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|19
index|]
operator|=
literal|7
expr_stmt|;
goto|goto
name|setup_mode
goto|;
case|case
name|M_VGA_C40x25
case|:
case|case
name|M_VGA_C80x25
case|:
case|case
name|M_VGA_M80x25
case|:
case|case
name|M_B40x25
case|:
case|case
name|M_C40x25
case|:
case|case
name|M_B80x25
case|:
case|case
name|M_C80x25
case|:
case|case
name|M_ENH_B40x25
case|:
case|case
name|M_ENH_C40x25
case|:
case|case
name|M_ENH_B80x25
case|:
case|case
name|M_ENH_C80x25
case|:
case|case
name|M_EGAMONO80x25
case|:
name|setup_mode
label|:
name|vid_load_state
argument_list|(
name|ad
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_VGA_MODEX
case|:
comment|/* "unchain" the VGA mode */
name|params
operator|.
name|regs
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator|&=
literal|0xf7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|5
operator|-
literal|1
operator|+
literal|0x04
index|]
operator||=
literal|0x04
expr_stmt|;
comment|/* turn off doubleword mode */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x14
index|]
operator|&=
literal|0xbf
expr_stmt|;
comment|/* turn off word adressing */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x17
index|]
operator||=
literal|0x40
expr_stmt|;
comment|/* set logical screen width */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x13
index|]
operator|=
literal|80
expr_stmt|;
comment|/* set 240 lines */
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0x2c
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x06
index|]
operator|=
literal|0x0d
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x07
index|]
operator|=
literal|0x3e
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x10
index|]
operator|=
literal|0xea
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x11
index|]
operator|=
literal|0xac
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x12
index|]
operator|=
literal|0xdf
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x15
index|]
operator|=
literal|0xe7
expr_stmt|;
name|params
operator|.
name|regs
index|[
literal|10
operator|+
literal|0x16
index|]
operator|=
literal|0x06
expr_stmt|;
comment|/* set vertical sync polarity to reflect aspect ratio */
name|params
operator|.
name|regs
index|[
literal|9
index|]
operator|=
literal|0xe3
expr_stmt|;
goto|goto
name|setup_grmode
goto|;
case|case
name|M_BG320
case|:
case|case
name|M_CG320
case|:
case|case
name|M_BG640
case|:
case|case
name|M_CG320_D
case|:
case|case
name|M_CG640_E
case|:
case|case
name|M_CG640x350
case|:
case|case
name|M_ENH_CG640
case|:
case|case
name|M_BG640x480
case|:
case|case
name|M_CG640x480
case|:
case|case
name|M_VGA_CG320
case|:
name|setup_grmode
label|:
name|vid_load_state
argument_list|(
name|ad
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
literal|1
return|;
block|}
name|adapter
index|[
name|ad
index|]
operator|.
name|va_mode
operator|=
name|mode
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_flags
operator|&=
operator|~
name|V_ADP_COLOR
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_flags
operator||=
operator|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_COLOR
operator|)
condition|?
name|V_ADP_COLOR
else|:
literal|0
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|=
operator|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_COLOR
operator|)
condition|?
name|COLOR_BASE
else|:
name|MONO_BASE
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_window
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_window
argument_list|)
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_window_size
operator|=
name|info
operator|.
name|vi_window_size
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_window_gran
operator|=
name|info
operator|.
name|vi_window_gran
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_buffer_size
operator|==
literal|0
condition|)
block|{
name|adapter
index|[
name|ad
index|]
operator|.
name|va_buffer
operator|=
literal|0
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_buffer_size
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|adapter
index|[
name|ad
index|]
operator|.
name|va_buffer
operator|=
name|BIOS_PADDRTOVADDR
argument_list|(
name|info
operator|.
name|vi_buffer
argument_list|)
expr_stmt|;
name|adapter
index|[
name|ad
index|]
operator|.
name|va_buffer_size
operator|=
name|info
operator|.
name|vi_buffer_size
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_font_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* save register values */
if|if
condition|(
name|adp
operator|->
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (adp->va_type == KD_EGA) */
block|{
comment|/*  	 * EGA cannot be read; copy parameters from the mode parameter  	 * table.  	 */
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adp
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|mp
index|[
literal|5
operator|+
literal|0x02
operator|-
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|mp
index|[
literal|5
operator|+
literal|0x04
operator|-
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x04
index|]
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x05
index|]
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|mp
index|[
literal|55
operator|+
literal|0x06
index|]
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|mp
index|[
literal|35
operator|+
literal|0x10
index|]
expr_stmt|;
block|}
comment|/* setup vga for loading fonts */
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
literal|5
index|]
operator|&
operator|~
literal|0x01
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0402
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0704
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0300
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0204
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0406
argument_list|)
expr_stmt|;
comment|/* addr = a0000, 64kb */
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_normal_mode
parameter_list|(
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* setup vga for normal operation mode again */
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x10
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adp
operator|->
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|#
directive|if
name|SLOW_VGA
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x04
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x05
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_crtc_addr
operator|==
name|MONO_BASE
condition|)
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|GDCIDX
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0002
operator||
operator|(
name|buf
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SC_BAD_FLICKER
name|outw
argument_list|(
name|TSIDX
argument_list|,
literal|0x0300
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0004
operator||
operator|(
name|buf
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0005
operator||
operator|(
name|buf
index|[
literal|3
index|]
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adp
operator|->
name|va_crtc_addr
operator|==
name|MONO_BASE
condition|)
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x08
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
else|else
name|outw
argument_list|(
name|GDCIDX
argument_list|,
literal|0x0006
operator||
operator|(
operator|(
operator|(
name|buf
index|[
literal|4
index|]
operator|&
literal|0x03
operator|)
operator||
literal|0x0c
operator|)
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_save_font
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|val
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|segment
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
block|{
comment|/* FONT_8 */
name|fontsize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|32
condition|)
block|{
name|fontsize
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
block|{
comment|/* FONT_16 */
name|fontsize
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* FONT_14 */
name|fontsize
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|segment
operator|=
name|VIDEOMEM
operator|+
literal|0x4000
operator|*
name|page
expr_stmt|;
if|if
condition|(
name|page
operator|>
literal|3
condition|)
name|segment
operator|-=
literal|0xe000
expr_stmt|;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
comment|/* what about EGA? XXX */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|set_font_mode
argument_list|(
operator|&
name|adapter
index|[
name|ad
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|==
literal|32
condition|)
block|{
name|generic_bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|segment
operator|+
name|ch
operator|*
literal|32
argument_list|)
argument_list|,
name|data
argument_list|,
name|fontsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|ch
init|;
name|count
operator|>
literal|0
condition|;
operator|++
name|c
operator|,
operator|--
name|count
control|)
block|{
name|generic_bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|segment
operator|+
name|c
operator|*
literal|32
argument_list|)
argument_list|,
name|data
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
name|data
operator|+=
name|fontsize
expr_stmt|;
block|}
block|}
name|set_normal_mode
argument_list|(
operator|&
name|adapter
index|[
name|ad
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* enable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_load_font
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|page
parameter_list|,
name|int
name|fontsize
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|u_char
name|buf
index|[
name|PARAM_BUFSIZE
index|]
decl_stmt|;
name|u_char
name|val
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|segment
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|s
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|<
literal|14
condition|)
block|{
comment|/* FONT_8 */
name|fontsize
operator|=
literal|8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|32
condition|)
block|{
name|fontsize
operator|=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fontsize
operator|>=
literal|16
condition|)
block|{
comment|/* FONT_16 */
name|fontsize
operator|=
literal|16
expr_stmt|;
block|}
else|else
block|{
comment|/* FONT_14 */
name|fontsize
operator|=
literal|14
expr_stmt|;
block|}
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|segment
operator|=
name|VIDEOMEM
operator|+
literal|0x4000
operator|*
name|page
expr_stmt|;
if|if
condition|(
name|page
operator|>
literal|3
condition|)
name|segment
operator|-=
literal|0xe000
expr_stmt|;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
comment|/* what about EGA? XXX */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|val
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
comment|/* disable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator||
literal|0x20
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|set_font_mode
argument_list|(
operator|&
name|adapter
index|[
name|ad
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fontsize
operator|==
literal|32
condition|)
block|{
name|generic_bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|void
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|segment
operator|+
name|ch
operator|*
literal|32
argument_list|)
argument_list|,
name|fontsize
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|ch
init|;
name|count
operator|>
literal|0
condition|;
operator|++
name|c
operator|,
operator|--
name|count
control|)
block|{
name|generic_bcopy
argument_list|(
name|data
argument_list|,
operator|(
name|void
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|segment
operator|+
name|c
operator|*
literal|32
argument_list|)
argument_list|,
name|fontsize
argument_list|)
expr_stmt|;
name|data
operator|+=
name|fontsize
expr_stmt|;
block|}
block|}
name|set_normal_mode
argument_list|(
operator|&
name|adapter
index|[
name|ad
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|val
operator|&
literal|0xdf
argument_list|)
expr_stmt|;
comment|/* enable screen */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_show_font
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|page
parameter_list|)
block|{
specifier|static
name|u_char
name|cg
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x0f
block|,
literal|0x30
block|,
literal|0x35
block|,
literal|0x3a
block|,
literal|0x3f
block|}
decl_stmt|;
name|int
name|s
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_FONT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
operator|<
literal|0
operator|||
name|page
operator|>=
literal|8
condition|)
return|return
literal|1
return|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|cg
index|[
name|page
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_save_palette
parameter_list|(
name|int
name|ad
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_PALETTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*       * We store 8 bit values in the palette buffer, while the standard      * VGA has 6 bit DAC .      */
name|outb
argument_list|(
name|PALRADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
name|palette
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|PALDATA
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|inb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_load_palette
parameter_list|(
name|int
name|ad
parameter_list|,
name|u_char
modifier|*
name|palette
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_PALETTE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|PIXMASK
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* no pixelmask */
name|outb
argument_list|(
name|PALWADR
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
operator|*
literal|3
condition|;
operator|++
name|i
control|)
name|outb
argument_list|(
name|PALDATA
argument_list|,
name|palette
index|[
name|i
index|]
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|inb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip/flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* CGA/EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_set_border
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|color
parameter_list|)
block|{
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_BORDER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
condition|)
block|{
case|case
name|KD_EGA
case|:
case|case
name|KD_VGA
case|:
name|inb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x31
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|color
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|KD_CGA
case|:
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|5
argument_list|,
name|color
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
comment|/* color select register */
break|break;
case|case
name|KD_MONO
case|:
case|case
name|KD_HERCULES
case|:
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_save_state
parameter_list|(
name|int
name|ad
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* return the required buffer size */
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_STATESAVE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|adp_state_t
argument_list|)
return|;
block|}
else|else
block|{
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_STATESAVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|adp_state_t
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|=
name|V_STATE_SIG
expr_stmt|;
name|buf
operator|=
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
expr_stmt|;
name|crtc_addr
operator|=
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|5
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|TSREG
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
literal|9
index|]
operator|=
name|inb
argument_list|(
name|MISC
operator|+
literal|10
argument_list|)
expr_stmt|;
comment|/* dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|10
init|;
name|i
operator|<
literal|25
condition|;
name|i
operator|++
control|)
block|{
comment|/* crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|35
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
comment|/* attribute ctrl */
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|ATC
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|55
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
comment|/* graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
index|[
name|j
operator|++
index|]
operator|=
name|inb
argument_list|(
name|GDCREG
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|vid_get_info
argument_list|(
name|ad
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_mode
argument_list|,
operator|&
name|info
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|info
operator|.
name|vi_width
operator|/
name|info
operator|.
name|vi_cwidth
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
name|info
operator|.
name|vi_height
operator|/
name|info
operator|.
name|vi_cheight
operator|-
literal|1
expr_stmt|;
comment|/* ROWS */
block|}
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|info
operator|.
name|vi_width
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
name|info
operator|.
name|vi_height
operator|-
literal|1
expr_stmt|;
comment|/* ROWS */
block|}
name|buf
index|[
literal|2
index|]
operator|=
name|info
operator|.
name|vi_cheight
expr_stmt|;
comment|/* POINTS */
block|}
else|else
block|{
comment|/* XXX: shouldn't be happening... */
name|printf
argument_list|(
literal|"video#%d: failed to obtain mode info. (vid_save_state())\n"
argument_list|,
name|ad
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|buf
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
expr_stmt|;
comment|/* COLS */
name|buf
index|[
literal|1
index|]
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
expr_stmt|;
comment|/* ROWS */
name|buf
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
expr_stmt|;
comment|/* POINTS */
name|buf
index|[
literal|3
index|]
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44c
argument_list|)
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44d
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* EGA/VGA */
end_comment

begin_function
specifier|static
name|int
name|vid_load_state
parameter_list|(
name|int
name|ad
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|crtc_addr
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|prologue
argument_list|(
name|ad
argument_list|,
name|V_ADP_STATELOAD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|sig
operator|!=
name|V_STATE_SIG
condition|)
return|return
literal|1
return|;
name|buf
operator|=
operator|(
operator|(
name|adp_state_t
operator|*
operator|)
name|p
operator|)
operator|->
name|regs
expr_stmt|;
name|crtc_addr
operator|=
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* stop sequencer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
block|{
comment|/* program sequencer */
name|outb
argument_list|(
name|TSIDX
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
name|buf
index|[
name|i
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|MISC
argument_list|,
name|buf
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
comment|/* set dot-clock */
name|outb
argument_list|(
name|TSIDX
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|TSREG
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
comment|/* start sequencer */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
literal|0x11
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|)
operator|&
literal|0x7F
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|25
condition|;
operator|++
name|i
control|)
block|{
comment|/* program crtc */
name|outb
argument_list|(
name|crtc_addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|crtc_addr
operator|+
literal|1
argument_list|,
name|buf
index|[
name|i
operator|+
literal|10
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
operator|++
name|i
control|)
block|{
comment|/* program attribute ctrl */
name|outb
argument_list|(
name|ATC
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ATC
argument_list|,
name|buf
index|[
name|i
operator|+
literal|35
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
operator|++
name|i
control|)
block|{
comment|/* program graph data ctrl */
name|outb
argument_list|(
name|GDCIDX
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|GDCREG
argument_list|,
name|buf
index|[
name|i
operator|+
literal|55
index|]
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
name|crtc_addr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* reset flip-flop */
name|outb
argument_list|(
name|ATC
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* enable palette */
if|if
condition|(
name|ad
operator|==
name|V_ADP_PRIMARY
condition|)
block|{
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
comment|/* COLS */
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
operator|=
name|buf
index|[
literal|1
index|]
operator|+
name|rows_offset
operator|-
literal|1
expr_stmt|;
comment|/* ROWS */
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
operator|=
name|buf
index|[
literal|2
index|]
expr_stmt|;
comment|/* POINTS */
if|#
directive|if
literal|0
block|*(u_int8_t *)BIOS_PADDRTOVADDR(0x44c) = buf[3]; 	*(u_int8_t *)BIOS_PADDRTOVADDR(0x44d) = buf[4];
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* all */
end_comment

begin_function
specifier|static
name|int
name|vid_set_origin
parameter_list|(
name|int
name|ad
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
comment|/*       * The standard video modes do not require window mapping;       * always return error.      */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* all */
end_comment

begin_function
specifier|static
name|int
name|vid_read_hw_cursor
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
modifier|*
name|col
parameter_list|,
name|int
modifier|*
name|row
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_int16_t
name|off
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ad
operator|<
literal|0
operator|)
operator|||
operator|(
name|ad
operator|>=
name|adapters
operator|)
condition|)
return|return
literal|1
return|;
call|(
modifier|*
name|biosvidsw
operator|.
name|get_info
call|)
argument_list|(
name|ad
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
literal|1
return|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|off
operator|=
name|inb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|off
operator|=
operator|(
name|off
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|row
operator|=
name|off
operator|/
name|info
operator|.
name|vi_width
expr_stmt|;
operator|*
name|col
operator|=
name|off
operator|%
name|info
operator|.
name|vi_width
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* all */
end_comment

begin_function
specifier|static
name|int
name|vid_set_hw_cursor
parameter_list|(
name|int
name|ad
parameter_list|,
name|int
name|col
parameter_list|,
name|int
name|row
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_int16_t
name|off
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|ad
operator|<
literal|0
operator|)
operator|||
operator|(
name|ad
operator|>=
name|adapters
operator|)
condition|)
return|return
literal|1
return|;
call|(
modifier|*
name|biosvidsw
operator|.
name|get_info
call|)
argument_list|(
name|ad
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|col
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|row
operator|==
operator|-
literal|1
operator|)
condition|)
name|off
operator|=
literal|0xffff
expr_stmt|;
else|else
name|off
operator|=
name|row
operator|*
name|info
operator|.
name|vi_width
operator|+
name|col
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|off
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_crtc_addr
operator|+
literal|1
argument_list|,
name|off
operator|&
literal|0x00ff
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|adapter_name
parameter_list|(
name|int
name|type
parameter_list|)
block|{
specifier|static
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|names
index|[]
init|=
block|{
block|{
name|KD_MONO
block|,
literal|"MDA"
block|}
block|,
block|{
name|KD_HERCULES
block|,
literal|"Hercules"
block|}
block|,
block|{
name|KD_CGA
block|,
literal|"CGA"
block|}
block|,
block|{
name|KD_EGA
block|,
literal|"EGA"
block|}
block|,
block|{
name|KD_VGA
block|,
literal|"VGA"
block|}
block|,
block|{
name|KD_PC98
block|,
literal|"PC-98xx"
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|"Unknown"
block|}
block|,     }
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|names
index|[
name|i
index|]
operator|.
name|type
operator|!=
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
condition|)
break|break;
return|return
name|names
index|[
name|i
index|]
operator|.
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_adp_info
parameter_list|(
name|int
name|ad
parameter_list|,
name|video_adapter_t
modifier|*
name|adp
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"video#%d: adapter type:%s (%d), flags:0x%x, CRTC:0x%x\n"
argument_list|,
name|ad
argument_list|,
name|adapter_name
argument_list|(
name|adp
operator|->
name|va_type
argument_list|)
argument_list|,
name|adp
operator|->
name|va_type
argument_list|,
name|adp
operator|->
name|va_flags
argument_list|,
name|adp
operator|->
name|va_crtc_addr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"video#%d: init mode:%d, bios mode:%d, current mode:%d\n"
argument_list|,
name|ad
argument_list|,
name|adp
operator|->
name|va_initial_mode
argument_list|,
name|adp
operator|->
name|va_initial_bios_mode
argument_list|,
name|adp
operator|->
name|va_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"video#%d: window:0x%x size:%dk gran:%dk, buf:0x%x size:%dk\n"
argument_list|,
name|ad
argument_list|,
name|adp
operator|->
name|va_window
argument_list|,
name|adp
operator|->
name|va_window_size
argument_list|,
name|adp
operator|->
name|va_window_gran
argument_list|,
name|adp
operator|->
name|va_buffer
argument_list|,
name|adp
operator|->
name|va_buffer_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_mode_info
parameter_list|(
name|int
name|ad
parameter_list|,
name|video_info_t
modifier|*
name|info
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"video#%d: mode:%d, flags:0x%x "
argument_list|,
name|ad
argument_list|,
name|info
operator|->
name|vi_mode
argument_list|,
name|info
operator|->
name|vi_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|vi_flags
operator|&
name|V_INFO_GRAPHICS
condition|)
name|printf
argument_list|(
literal|"G %dx%dx%d, %d plane(s), font:%dx%d, "
argument_list|,
name|info
operator|->
name|vi_width
argument_list|,
name|info
operator|->
name|vi_height
argument_list|,
name|info
operator|->
name|vi_depth
argument_list|,
name|info
operator|->
name|vi_planes
argument_list|,
name|info
operator|->
name|vi_cwidth
argument_list|,
name|info
operator|->
name|vi_cheight
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"T %dx%d, font:%dx%d, "
argument_list|,
name|info
operator|->
name|vi_width
argument_list|,
name|info
operator|->
name|vi_height
argument_list|,
name|info
operator|->
name|vi_cwidth
argument_list|,
name|info
operator|->
name|vi_cheight
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"win:0x%x\n"
argument_list|,
name|info
operator|->
name|vi_window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_buffer
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|++
name|i
operator|%
literal|16
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vid_diag
parameter_list|(
name|int
name|level
parameter_list|)
block|{
name|video_info_t
name|info
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|;
name|int
name|ad
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|level
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"video: RTC equip. code:0x%02x, DCC code:0x%02x\n"
argument_list|,
name|rtcin
argument_list|(
name|RTC_EQUIPMENT
argument_list|)
argument_list|,
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x488
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"video: CRTC:0x%x, video option:0x%02x, "
argument_list|,
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x463
argument_list|)
argument_list|,
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x487
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rows:%d, cols:%d, font height:%d\n"
argument_list|,
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x44a
argument_list|)
argument_list|,
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x484
argument_list|)
operator|+
literal|1
argument_list|,
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
literal|0x485
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"video: param table EGA/VGA:%p, CGA/MDA:%p\n"
argument_list|,
name|video_mode_ptr
argument_list|,
name|video_mode_ptr2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"video: rows_offset:%d\n"
argument_list|,
name|rows_offset
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ad
operator|=
literal|0
init|;
name|ad
operator|<
name|adapters
condition|;
operator|++
name|ad
control|)
block|{
name|dump_adp_info
argument_list|(
name|ad
argument_list|,
operator|&
name|adapter
index|[
name|ad
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_flags
operator|&
name|V_ADP_MODECHANGE
operator|)
condition|)
block|{
name|vid_get_info
argument_list|(
name|ad
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_initial_mode
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|dump_mode_info
argument_list|(
name|ad
argument_list|,
operator|&
name|info
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|!=
name|EOT
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
operator|==
name|NA
condition|)
continue|continue;
if|if
condition|(
name|get_mode_param
argument_list|(
name|bios_vmode
index|[
name|i
index|]
operator|.
name|vi_mode
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|dump_mode_info
argument_list|(
name|ad
argument_list|,
operator|&
name|bios_vmode
index|[
name|i
index|]
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|!=
name|KD_EGA
operator|)
operator|&&
operator|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|!=
name|KD_VGA
operator|)
condition|)
continue|continue;
if|if
condition|(
name|video_mode_ptr
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"video#%d: WARNING: video mode switching is not fully supported on this adapter\n"
argument_list|,
name|ad
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|<=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_type
operator|==
name|KD_VGA
condition|)
block|{
name|printf
argument_list|(
literal|"VGA parameters upon power-up\n"
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"VGA parameters in BIOS for mode %d\n"
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_initial_mode
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|adpstate2
operator|.
name|regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|get_mode_param
argument_list|(
name|adapter
index|[
name|ad
index|]
operator|.
name|va_initial_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
comment|/* this shouldn't be happening */
continue|continue;
name|printf
argument_list|(
literal|"EGA/VGA parameters to be used for mode %d\n"
argument_list|,
name|adapter
index|[
name|ad
index|]
operator|.
name|va_initial_mode
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|(
name|mp
argument_list|,
name|V_MODE_PARAM_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSC> 0 */
end_comment

end_unit

