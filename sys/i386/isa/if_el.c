begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1994, Matthew E. Kimmel.  Permission is hereby granted  * to use, copy, modify and distribute this software provided that both  * the copyright notice and this permission notice appear in all copies  * of the software, derivative works or modified versions, and any  * portions thereof.  *  * Questions, comments, bug reports and fixes to kimmel@cs.umass.edu.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* Except of course for the portions of code lifted from other FreeBSD  * drivers (mainly elread, elget and el_ioctl)  */
end_comment

begin_comment
comment|/* 3COM Etherlink 3C501 device driver for FreeBSD */
end_comment

begin_comment
comment|/* Yeah, I know these cards suck, but you can also get them for free  * really easily...  */
end_comment

begin_comment
comment|/* Bugs/possible improvements:  *	- Does not currently support DMA  *	- Does not currently support multicasts  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_elreg.h>
end_include

begin_comment
comment|/* For debugging convenience */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EL_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* el_softc: per line info and status */
end_comment

begin_struct
struct|struct
name|el_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
name|bus_space_handle_t
name|el_bhandle
decl_stmt|;
name|bus_space_tag_t
name|el_btag
decl_stmt|;
name|void
modifier|*
name|el_intrhand
decl_stmt|;
name|struct
name|resource
modifier|*
name|el_irq
decl_stmt|;
name|struct
name|resource
modifier|*
name|el_res
decl_stmt|;
name|struct
name|mtx
name|el_mtx
decl_stmt|;
name|char
name|el_pktbuf
index|[
name|EL_BUFSIZ
index|]
decl_stmt|;
comment|/* Frame buffer */
block|}
struct|;
end_struct

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|el_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_detach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_probe
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_reset
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_shutdown
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_stop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_xmit
parameter_list|(
name|struct
name|el_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|elread
parameter_list|(
name|struct
name|el_softc
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|elget
parameter_list|(
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|el_hardreset
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|el_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|el_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|el_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|el_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|el_shutdown
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|el_driver
init|=
block|{
literal|"el"
block|,
name|el_methods
block|,
expr|sizeof
operator|(
expr|struct
name|el_softc
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|el_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|if_el
argument_list|,
name|isa
argument_list|,
name|el_driver
argument_list|,
name|el_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CSR_WRITE_1
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_1(sc->el_btag, sc->el_bhandle, reg, val)
end_define

begin_define
define|#
directive|define
name|CSR_READ_1
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_space_read_1(sc->el_btag, sc->el_bhandle, reg)
end_define

begin_define
define|#
directive|define
name|EL_LOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_lock(&(_sc)->el_mtx)
end_define

begin_define
define|#
directive|define
name|EL_UNLOCK
parameter_list|(
name|_sc
parameter_list|)
value|mtx_unlock(&(_sc)->el_mtx)
end_define

begin_comment
comment|/* Probe routine.  See if the card is there and at the right place. */
end_comment

begin_function
specifier|static
name|int
name|el_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|base
decl_stmt|;
comment|/* Just for convenience */
name|u_char
name|station_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rid
decl_stmt|;
comment|/* Grab some info for our structure */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|isa_get_logicalid
argument_list|(
name|dev
argument_list|)
condition|)
comment|/* skip PnP probes */
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|base
operator|=
name|bus_get_resource_start
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* First check the base */
if|if
condition|(
operator|(
name|base
operator|<
literal|0x280
operator|)
operator|||
operator|(
name|base
operator|>
literal|0x3f0
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioaddr must be between 0x280 and 0x3f0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Temporarily map the resources. */
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|el_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|EL_IOSIZ
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|el_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|->
name|el_btag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
name|sc
operator|->
name|el_bhandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|el_mtx
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Now attempt to grab the station address from the PROM 	 * and see if it contains the 3com vendor code. 	 */
name|dprintf
argument_list|(
operator|(
literal|"Probing 3c501 at 0x%x...\n"
operator|,
name|base
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the board */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"Reading station address...\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Now read the address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|station_addr
index|[
name|i
index|]
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_EAW
argument_list|)
expr_stmt|;
block|}
comment|/* Now release resources */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|el_mtx
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"Address is %6D\n"
operator|,
name|station_addr
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
comment|/* If the vendor code is ok, return a 1.  We'll assume that 	 * whoever configured this system is right about the IRQ. 	 */
if|if
condition|(
operator|(
name|station_addr
index|[
literal|0
index|]
operator|!=
literal|0x02
operator|)
operator|||
operator|(
name|station_addr
index|[
literal|1
index|]
operator|!=
literal|0x60
operator|)
operator|||
operator|(
name|station_addr
index|[
literal|2
index|]
operator|!=
literal|0x8c
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"Bad vendor code.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"Vendor code ok.\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the station address into the arpcom structure */
name|bcopy
argument_list|(
name|station_addr
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"3Com 3c501 Ethernet"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a hardware reset of the 3c501.  Do not call until after el_probe()! */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|el_hardreset
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
specifier|register
name|struct
name|el_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* First reset the board */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then give it back its ethernet address.  Thanks to the mach 	 * source code for this undocumented goodie... 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ETHER_ADDR_LEN
condition|;
name|j
operator|++
control|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|j
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach the interface to the kernel data structures.  By the time  * this is called, we know that the card exists at the given I/O address.  * We still assume that the IRQ given is correct.  */
end_comment

begin_function
specifier|static
name|int
name|el_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rid
decl_stmt|,
name|error
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"Attaching el%d...\n"
operator|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Get things pointing to the right places. */
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|el_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
name|EL_IOSIZ
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|el_res
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|el_irq
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
literal|0
argument_list|,
operator|~
literal|0
argument_list|,
literal|1
argument_list|,
name|RF_SHAREABLE
operator||
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|el_irq
operator|==
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|el_irq
argument_list|,
name|INTR_TYPE_NET
argument_list|,
name|elintr
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|el_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|el_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Now reset the board */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize ifnet structure */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
empty_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"el"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|el_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|el_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|el_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|el_init
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
comment|/* Now we can attach the interface */
name|dprintf
argument_list|(
operator|(
literal|"Attaching interface...\n"
operator|)
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
comment|/* Print out some information for the user */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"3c501 address %6D\n"
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"el_attach() finished.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|el_detach
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|el_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|,
name|ETHER_BPF_SUPPORTED
argument_list|)
expr_stmt|;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|el_irq
argument_list|,
name|sc
operator|->
name|el_intrhand
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|el_irq
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|el_res
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|el_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|el_shutdown
parameter_list|(
name|dev
parameter_list|)
name|device_t
name|dev
decl_stmt|;
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|el_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine resets the interface. */
end_comment

begin_function
specifier|static
name|void
name|el_reset
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|el_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"elreset()\n"
operator|)
argument_list|)
expr_stmt|;
name|el_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|el_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|el_stop
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|el_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize interface.  */
end_comment

begin_function
specifier|static
name|void
name|el_init
parameter_list|(
name|xsc
parameter_list|)
name|void
modifier|*
name|xsc
decl_stmt|;
block|{
name|struct
name|el_softc
modifier|*
name|sc
init|=
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* Set up pointers */
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
comment|/* If address not known, do nothing. */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_addrhead
argument_list|)
condition|)
comment|/* XXX unlikely */
return|return;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* First, reset the board. */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Configure rx */
name|dprintf
argument_list|(
operator|(
literal|"Configuring rx...\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure TX */
name|dprintf
argument_list|(
operator|(
literal|"Configuring tx...\n"
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_TXC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start reception */
name|dprintf
argument_list|(
operator|(
literal|"Starting reception...\n"
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
comment|/* Set flags appropriately */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* And start output. */
name|el_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start output on interface.  Get datagrams from the queue and output  * them, giving the receiver a chance between datagrams.  Call only  * from splimp or interrupt level!  */
end_comment

begin_function
specifier|static
name|void
name|el_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|retries
decl_stmt|,
name|done
decl_stmt|;
comment|/* Get things pointing in the right directions */
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"el_start()...\n"
operator|)
argument_list|)
expr_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Don't do anything if output is active */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* The main loop.  They warned me against endless loops, but 	 * would I listen?  NOOO.... 	 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Dequeue the next datagram */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* If there's nothing to send, return. */
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable the receiver */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the datagram to the buffer. */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|sc
operator|->
name|el_pktbuf
operator|+
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* Give the packet to the bpf, if any */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Transfer datagram to board */
name|dprintf
argument_list|(
operator|(
literal|"el: xfr pkt length=%d...\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|EL_BUFSIZ
operator|-
name|len
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBL
argument_list|,
operator|(
name|i
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBH
argument_list|,
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|bus_space_write_multi_1
argument_list|(
name|sc
operator|->
name|el_btag
argument_list|,
name|sc
operator|->
name|el_bhandle
argument_list|,
name|EL_BUF
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Now transmit the datagram */
name|retries
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|el_xmit
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* Something went wrong */
name|done
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Check out status */
name|i
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_TXS
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"tx status=0x%x\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
name|EL_TXS_READY
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"el: err txs=%x\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|EL_TXS_COLL
operator||
name|EL_TXS_COLL16
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|i
operator|&
name|EL_TXC_DCOLL16
operator|)
operator|)
operator|&&
name|retries
operator|<
literal|15
condition|)
block|{
name|retries
operator|++
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
operator|==
operator|-
literal|1
condition|)
comment|/* Packet not transmitted */
continue|continue;
comment|/* Now give the card a chance to receive. 		 * Gotta love 3c501s... 		 */
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Interrupt here */
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function actually attempts to transmit a datagram downloaded  * to the board.  Call at splimp or interrupt, after downloading data!  * Returns 0 on success, non-0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|el_xmit
parameter_list|(
name|struct
name|el_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|gpl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gpl
operator|=
name|EL_BUFSIZ
operator|-
name|len
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"el: xmit..."
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBL
argument_list|,
operator|(
name|gpl
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBH
argument_list|,
operator|(
operator|(
name|gpl
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_TXFRX
argument_list|)
expr_stmt|;
name|i
operator|=
literal|20000
expr_stmt|;
while|while
condition|(
operator|(
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
operator|&
name|EL_AS_TXBUSY
operator|)
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"tx not ready\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"%d cycles.\n"
operator|,
operator|(
literal|20000
operator|-
name|i
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass a packet up to the higher levels. */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|elread
parameter_list|(
name|struct
name|el_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 	 * Put packet into an mbuf chain 	 */
name|m
operator|=
name|elget
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* controller interrupt */
end_comment

begin_function
specifier|static
name|void
name|elintr
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
specifier|register
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|stat
decl_stmt|,
name|rxstat
decl_stmt|,
name|len
decl_stmt|,
name|done
decl_stmt|;
comment|/* Get things pointing properly */
name|sc
operator|=
name|xsc
expr_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"elintr: "
operator|)
argument_list|)
expr_stmt|;
comment|/* Check board status */
name|stat
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|EL_AS_RXBUSY
condition|)
block|{
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|rxstat
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|EL_RXS_STALE
condition|)
block|{
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there's an overflow, reinit the board. */
if|if
condition|(
operator|!
operator|(
name|rxstat
operator|&
name|EL_RXS_NOFLOW
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"overflow.\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Put board back into receive mode */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Incoming packet */
name|len
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RBL
argument_list|)
expr_stmt|;
name|len
operator||=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RBH
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"receive len=%d rxstat=%x "
operator|,
name|len
operator|,
name|rxstat
operator|)
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
comment|/* If packet too short or too long, restore rx mode and return 		 */
if|if
condition|(
operator|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|>
name|ETHER_MAX_LEN
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AMULTI
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Copy the data into our buffer */
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_GPBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_space_read_multi_1
argument_list|(
name|sc
operator|->
name|el_btag
argument_list|,
name|sc
operator|->
name|el_bhandle
argument_list|,
name|EL_BUF
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
name|EL_AC_RX
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"%6D-->"
operator|,
name|sc
operator|->
name|el_pktbuf
operator|+
literal|6
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"%6D\n"
operator|,
name|sc
operator|->
name|el_pktbuf
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
comment|/* Pass data up to upper levels */
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|elread
argument_list|(
name|sc
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|el_pktbuf
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Is there another packet? */
name|stat
operator|=
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_AS
argument_list|)
expr_stmt|;
comment|/* If so, do it all again (i.e. don't set done to 1) */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|EL_AS_RXBUSY
operator|)
condition|)
name|dprintf
argument_list|(
operator|(
literal|"<rescan> "
operator|)
argument_list|)
expr_stmt|;
else|else
name|done
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|CSR_READ_1
argument_list|(
name|sc
argument_list|,
name|EL_RXC
argument_list|)
expr_stmt|;
name|CSR_WRITE_1
argument_list|(
name|sc
argument_list|,
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Pull read data off a interface.  * Len is length of data, with local net header stripped.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|elget
parameter_list|(
name|buf
parameter_list|,
name|totlen
parameter_list|,
name|ifp
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|register
name|caddr_t
name|cp
decl_stmt|;
name|char
modifier|*
name|epkt
decl_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|epkt
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/*                          * Place initial small packet/header at end of mbuf.                          */
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|epkt
condition|)
name|cp
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|el_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|EL_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCGIFADDR
case|:
case|case
name|SIOCSIFMTU
case|:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If interface is marked down and it is running, then stop it 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|el_stop
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If interface is marked up and it is stopped, then start it 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|el_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|EL_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Device timeout routine */
end_comment

begin_function
specifier|static
name|void
name|el_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"el%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|el_reset
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

