begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Copyright (c) 1994, Matthew E. Kimmel.  Permission is hereby granted  * to use, copy, modify and distribute this software provided that both  * the copyright notice and this permission notice appear in all copies  * of the software, derivative works or modified versions, and any  * portions thereof.  *  * Questions, comments, bug reports and fixes to kimmel@cs.umass.edu.  *  * $Id: if_el.c,v 1.25 1996/08/06 21:14:04 phk Exp $  */
end_comment

begin_comment
comment|/* Except of course for the portions of code lifted from other FreeBSD  * drivers (mainly elread, elget and el_ioctl)  */
end_comment

begin_comment
comment|/* 3COM Etherlink 3C501 device driver for FreeBSD */
end_comment

begin_comment
comment|/* Yeah, I know these cards suck, but you can also get them for free  * really easily...  */
end_comment

begin_comment
comment|/* Bugs/possible improvements:  *	- Does not currently support DMA  *	- Does not currently support multicasts  */
end_comment

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/if_elreg.h>
end_include

begin_comment
comment|/* For debugging convenience */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EL_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
value|printf x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|dprintf
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* el_softc: per line info and status */
end_comment

begin_struct
specifier|static
struct|struct
name|el_softc
block|{
name|struct
name|arpcom
name|arpcom
decl_stmt|;
comment|/* Ethernet common */
name|u_short
name|el_base
decl_stmt|;
comment|/* Base I/O addr */
name|char
name|el_pktbuf
index|[
name|EL_BUFSIZ
index|]
decl_stmt|;
comment|/* Frame buffer */
block|}
name|el_softc
index|[
name|NEL
index|]
struct|;
end_struct

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|el_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_init
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_reset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|el_stop
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|el_xmit
parameter_list|(
name|struct
name|el_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|elread
parameter_list|(
name|struct
name|el_softc
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|elget
parameter_list|(
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|el_hardreset
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* isa_driver structure for autoconf */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|eldriver
init|=
block|{
name|el_probe
block|,
name|el_attach
block|,
literal|"el"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Probe routine.  See if the card is there and at the right place. */
end_comment

begin_function
specifier|static
name|int
name|el_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idev
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|base
decl_stmt|;
comment|/* Just for convenience */
name|u_char
name|station_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Grab some info for our structure */
name|sc
operator|=
operator|&
name|el_softc
index|[
name|idev
operator|->
name|id_unit
index|]
expr_stmt|;
name|sc
operator|->
name|el_base
operator|=
name|idev
operator|->
name|id_iobase
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
comment|/* First check the base */
if|if
condition|(
operator|(
name|base
operator|<
literal|0x280
operator|)
operator|||
operator|(
name|base
operator|>
literal|0x3f0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"el%d: ioaddr must be between 0x280 and 0x3f0\n"
argument_list|,
name|idev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now attempt to grab the station address from the PROM 	 * and see if it contains the 3com vendor code. 	 */
name|dprintf
argument_list|(
operator|(
literal|"Probing 3c501 at 0x%x...\n"
operator|,
name|base
operator|)
argument_list|)
expr_stmt|;
comment|/* Reset the board */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"Reading station address...\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Now read the address */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|base
operator|+
name|EL_GPBL
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|station_addr
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_EAW
argument_list|)
expr_stmt|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"Address is %6D\n"
operator|,
name|station_addr
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
comment|/* If the vendor code is ok, return a 1.  We'll assume that 	 * whoever configured this system is right about the IRQ. 	 */
if|if
condition|(
operator|(
name|station_addr
index|[
literal|0
index|]
operator|!=
literal|0x02
operator|)
operator|||
operator|(
name|station_addr
index|[
literal|1
index|]
operator|!=
literal|0x60
operator|)
operator|||
operator|(
name|station_addr
index|[
literal|2
index|]
operator|!=
literal|0x8c
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"Bad vendor code.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|dprintf
argument_list|(
operator|(
literal|"Vendor code ok.\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the station address into the arpcom structure */
name|bcopy
argument_list|(
name|station_addr
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Attach the interface to the kernel data structures.  By the time  * this is called, we know that the card exists at the given I/O address.  * We still assume that the IRQ given is correct.  */
end_comment

begin_function
specifier|static
name|int
name|el_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idev
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|u_short
name|base
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"Attaching el%d...\n"
operator|,
name|idev
operator|->
name|id_unit
operator|)
argument_list|)
expr_stmt|;
comment|/* Get things pointing to the right places. */
name|sc
operator|=
operator|&
name|el_softc
index|[
name|idev
operator|->
name|id_unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
comment|/* Now reset the board */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|idev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
comment|/* Initialize ifnet structure */
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_unit
operator|=
name|idev
operator|->
name|id_unit
expr_stmt|;
name|ifp
operator|->
name|if_name
operator|=
literal|"el"
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|el_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|el_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|el_watchdog
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator|)
expr_stmt|;
comment|/* Now we can attach the interface */
name|dprintf
argument_list|(
operator|(
literal|"Attaching interface...\n"
operator|)
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Put the station address in the ifa address list's AF_LINK 	 * entry, if any. 	 */
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
expr_stmt|;
while|while
condition|(
operator|(
name|ifa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|)
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_addr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/* Print out some information for the user */
name|printf
argument_list|(
literal|"el%d: 3c501 address %6D\n"
argument_list|,
name|idev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* Finally, attach to bpf filter if it is present. */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|dprintf
argument_list|(
operator|(
literal|"Attaching to BPF...\n"
operator|)
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dprintf
argument_list|(
operator|(
literal|"el_attach() finished.\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine resets the interface. */
end_comment

begin_function
specifier|static
name|void
name|el_reset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"elreset()\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|el_stop
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|el_init
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|el_stop
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|&
name|el_softc
index|[
name|unit
index|]
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|el_base
operator|+
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Do a hardware reset of the 3c501.  Do not call until after el_probe()! */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|el_hardreset
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|base
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|sc
operator|=
operator|&
name|el_softc
index|[
name|unit
index|]
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
comment|/* First reset the board */
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Then give it back its ethernet address.  Thanks to the mach 	 * source code for this undocumented goodie... 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ETHER_ADDR_LEN
condition|;
name|j
operator|++
control|)
name|outb
argument_list|(
name|base
operator|+
name|j
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize interface.  */
end_comment

begin_function
specifier|static
name|void
name|el_init
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|u_short
name|base
decl_stmt|;
comment|/* Set up pointers */
name|sc
operator|=
operator|&
name|el_softc
index|[
name|unit
index|]
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
comment|/* If address not known, do nothing. */
if|if
condition|(
name|ifp
operator|->
name|if_addrlist
operator|==
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
literal|0
condition|)
return|return;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* First, reset the board. */
name|dprintf
argument_list|(
operator|(
literal|"Resetting board...\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Configure rx */
name|dprintf
argument_list|(
operator|(
literal|"Configuring rx...\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure TX */
name|dprintf
argument_list|(
operator|(
literal|"Configuring tx...\n"
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_TXC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Start reception */
name|dprintf
argument_list|(
operator|(
literal|"Starting reception...\n"
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
comment|/* Set flags appropriately */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
comment|/* And start output. */
name|el_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start output on interface.  Get datagrams from the queue and output  * them, giving the receiver a chance between datagrams.  Call only  * from splimp or interrupt level!  */
end_comment

begin_function
specifier|static
name|void
name|el_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
name|u_short
name|base
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|retries
decl_stmt|,
name|done
decl_stmt|;
comment|/* Get things pointing in the right directions */
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"el_start()...\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Don't do anything if output is active */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_OACTIVE
condition|)
return|return;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
comment|/* The main loop.  They warned me against endless loops, but 	 * would I listen?  NOOO.... 	 */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Dequeue the next datagram */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/* If there's nothing to send, return. */
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Disable the receiver */
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy the datagram to the buffer. */
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|sc
operator|->
name|el_pktbuf
operator|+
name|len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|len
operator|=
name|max
argument_list|(
name|len
argument_list|,
name|ETHER_MIN_LEN
argument_list|)
expr_stmt|;
comment|/* Give the packet to the bpf, if any */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
name|bpf_tap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Transfer datagram to board */
name|dprintf
argument_list|(
operator|(
literal|"el: xfr pkt length=%d...\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|EL_BUFSIZ
operator|-
name|len
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_GPBL
argument_list|,
operator|(
name|i
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_GPBH
argument_list|,
operator|(
operator|(
name|i
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|base
operator|+
name|EL_BUF
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Now transmit the datagram */
name|retries
operator|=
literal|0
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|el_xmit
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
condition|)
block|{
comment|/* Something went wrong */
name|done
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Check out status */
name|i
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_TXS
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"tx status=0x%x\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
name|EL_TXS_READY
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"el: err txs=%x\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|&
operator|(
name|EL_TXS_COLL
operator||
name|EL_TXS_COLL16
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|i
operator|&
name|EL_TXC_DCOLL16
operator|)
operator|)
operator|&&
name|retries
operator|<
literal|15
condition|)
block|{
name|retries
operator|++
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|done
operator|==
operator|-
literal|1
condition|)
comment|/* Packet not transmitted */
continue|continue;
comment|/* Now give the card a chance to receive. 		 * Gotta love 3c501s... 		 */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_AS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Interrupt here */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function actually attempts to transmit a datagram downloaded  * to the board.  Call at splimp or interrupt, after downloading data!  * Returns 0 on success, non-0 on failure  */
end_comment

begin_function
specifier|static
name|int
name|el_xmit
parameter_list|(
name|struct
name|el_softc
modifier|*
name|sc
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|gpl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|gpl
operator|=
name|EL_BUFSIZ
operator|-
name|len
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"el: xmit..."
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|sc
operator|->
name|el_base
operator|)
operator|+
name|EL_GPBL
argument_list|,
operator|(
name|gpl
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|sc
operator|->
name|el_base
operator|)
operator|+
name|EL_GPBH
argument_list|,
operator|(
operator|(
name|gpl
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|sc
operator|->
name|el_base
operator|)
operator|+
name|EL_AC
argument_list|,
name|EL_AC_TXFRX
argument_list|)
expr_stmt|;
name|i
operator|=
literal|20000
expr_stmt|;
while|while
condition|(
operator|(
name|inb
argument_list|(
operator|(
name|sc
operator|->
name|el_base
operator|)
operator|+
name|EL_AS
argument_list|)
operator|&
name|EL_AS_TXBUSY
operator|)
operator|&&
operator|(
name|i
operator|>
literal|0
operator|)
condition|)
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"tx not ready\n"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dprintf
argument_list|(
operator|(
literal|"%d cycles.\n"
operator|,
operator|(
literal|20000
operator|-
name|i
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* controller interrupt */
end_comment

begin_function
name|void
name|elintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
specifier|register
name|struct
name|el_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|base
expr_stmt|;
name|int
name|stat
decl_stmt|,
name|rxstat
decl_stmt|,
name|len
decl_stmt|,
name|done
decl_stmt|;
comment|/* Get things pointing properly */
name|sc
operator|=
operator|&
name|el_softc
index|[
name|unit
index|]
expr_stmt|;
name|base
operator|=
name|sc
operator|->
name|el_base
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"elintr: "
operator|)
argument_list|)
expr_stmt|;
comment|/* Check board status */
name|stat
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_AS
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|EL_AS_RXBUSY
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
name|rxstat
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_RXS
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxstat
operator|&
name|EL_RXS_STALE
condition|)
block|{
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there's an overflow, reinit the board. */
if|if
condition|(
operator|!
operator|(
name|rxstat
operator|&
name|EL_RXS_NOFLOW
operator|)
condition|)
block|{
name|dprintf
argument_list|(
operator|(
literal|"overflow.\n"
operator|)
argument_list|)
expr_stmt|;
name|el_hardreset
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* Put board back into receive mode */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_AS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Incoming packet */
name|len
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_RBL
argument_list|)
expr_stmt|;
name|len
operator||=
name|inb
argument_list|(
name|base
operator|+
name|EL_RBH
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"receive len=%d rxstat=%x "
operator|,
name|len
operator|,
name|rxstat
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_HOST
argument_list|)
expr_stmt|;
comment|/* If packet too short or too long, restore rx mode and return 		 */
if|if
condition|(
operator|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
operator|||
operator|(
name|len
operator|>
name|ETHER_MAX_LEN
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_PROMISC
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|,
operator|(
name|EL_RXC_ABROAD
operator||
name|EL_RXC_AGF
operator||
name|EL_RXC_DSHORT
operator||
name|EL_RXC_DDRIB
operator||
name|EL_RXC_DOFLOW
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_AS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Copy the data into our buffer */
name|outb
argument_list|(
name|base
operator|+
name|EL_GPBL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_GPBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|insb
argument_list|(
name|base
operator|+
name|EL_BUF
argument_list|,
name|sc
operator|->
name|el_pktbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_RBC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
name|EL_AC_RX
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"%6D-->"
operator|,
name|sc
operator|->
name|el_pktbuf
operator|+
literal|6
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
operator|(
literal|"%6D\n"
operator|,
name|sc
operator|->
name|el_pktbuf
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
comment|/* Pass data up to upper levels */
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|elread
argument_list|(
name|sc
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|el_pktbuf
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Is there another packet? */
name|stat
operator|=
name|inb
argument_list|(
name|base
operator|+
name|EL_AS
argument_list|)
expr_stmt|;
comment|/* If so, do it all again (i.e. don't set done to 1) */
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|EL_AS_RXBUSY
operator|)
condition|)
name|dprintf
argument_list|(
operator|(
literal|"<rescan> "
operator|)
argument_list|)
expr_stmt|;
else|else
name|done
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|inb
argument_list|(
name|base
operator|+
name|EL_RXC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|base
operator|+
name|EL_AC
argument_list|,
operator|(
name|EL_AC_IRQE
operator||
name|EL_AC_RX
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Pass a packet up to the higher levels. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|elread
parameter_list|(
name|struct
name|el_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|register
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|buf
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* 	 * Check if there's a bpf filter listening on this interface. 	 * If so, hand off the raw packet to bpf. 	 */
if|if
condition|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_bpf
condition|)
block|{
name|bpf_tap
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|buf
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the interface cannot be in promiscuous mode if 		 * there are no bpf listeners.  And if el are in promiscuous 		 * mode, el have to check if this packet is really ours. 		 * 		 * This test does not support multicasts. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|etherbroadcastaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Pull packet off interface. 	 */
name|m
operator|=
name|elget
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
argument_list|,
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pull read data off a interface.  * Len is length of data, with local net header stripped.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|elget
parameter_list|(
name|buf
parameter_list|,
name|totlen
parameter_list|,
name|off0
parameter_list|,
name|ifp
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|int
name|totlen
decl_stmt|,
name|off0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|off
init|=
name|off0
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|caddr_t
name|cp
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|epkt
decl_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|epkt
operator|=
name|cp
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|off
condition|)
block|{
name|cp
operator|+=
name|off
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|totlen
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|MHLEN
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
while|while
condition|(
name|totlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|top
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MLEN
expr_stmt|;
block|}
name|len
operator|=
name|min
argument_list|(
name|totlen
argument_list|,
name|epkt
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|m
operator|->
name|m_len
operator|=
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|MCLBYTES
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
block|{
comment|/*                          * Place initial small packet/header at end of mbuf.                          */
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|top
operator|==
literal|0
operator|&&
name|len
operator|+
name|max_linkhdr
operator|<=
name|m
operator|->
name|m_len
condition|)
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
else|else
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|cp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|totlen
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|epkt
condition|)
name|cp
operator|=
name|buf
expr_stmt|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request. This code needs some work - it looks  *	pretty ugly.  */
end_comment

begin_function
specifier|static
name|int
name|el_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|el_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|el_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
comment|/* 		 * XXX - This code is probably wrong 		 */
case|case
name|AF_IPX
case|:
block|{
specifier|register
name|struct
name|ipx_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SIPX
argument_list|(
name|ifa
argument_list|)
operator|->
name|sipx_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ipx_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
comment|/*  				 *  				 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Set new address 			 */
name|el_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
comment|/* 		 * XXX - This code is probably wrong 		 */
case|case
name|AF_NS
case|:
block|{
specifier|register
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
else|else
block|{
comment|/* 				 * 				 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Set new address 			 */
name|el_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|el_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|arpcom
operator|.
name|ac_enaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * If interface is marked down and it is running, then stop it 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
condition|)
block|{
name|el_stop
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If interface is marked up and it is stopped, then start it 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|)
condition|)
name|el_init
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ETHERMTU
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Device timeout routine */
end_comment

begin_function
specifier|static
name|void
name|el_watchdog
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"el%d: device timeout\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|el_reset
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

