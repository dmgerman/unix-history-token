begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, 1997, 1998, 1999  *    Mark Dawson and David James. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *    $Id: ida.c,v 1.1.2.1 1999/05/25 19:47:41 julian Exp $  *  */
end_comment

begin_comment
comment|/*  * Compaq SMART disk array controller driver for FreeBSD.  * Supports the Compaq SMART-2 and SMART-3 families of disk  * array controllers.  *  */
end_comment

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_comment
comment|/*#include<sys/dkbad.h>*/
end_comment

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_decl_stmt
specifier|extern
name|u_long
name|bootdev
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IDA_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_comment
comment|/* IDA wdc vector stealing (cuckoo) control */
end_comment

begin_define
define|#
directive|define
name|IDA_CUCKOO_NEVER
value|0
end_define

begin_comment
comment|/* never steal wdc vectors */
end_comment

begin_define
define|#
directive|define
name|IDA_CUCKOO_ROOTWD
value|1
end_define

begin_comment
comment|/* steal iff rootdev is wd device */
end_comment

begin_define
define|#
directive|define
name|IDA_CUCKOO_ROOTNOTIDA
value|2
end_define

begin_comment
comment|/* steal if rootdev not ida device */
end_comment

begin_define
define|#
directive|define
name|IDA_CUCKOO_ALWAYS
value|3
end_define

begin_comment
comment|/* always steal wdc vectors */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IDA_CUCKOO_MODE
end_ifndef

begin_define
define|#
directive|define
name|IDA_CUCKOO_MODE
value|IDA_CUCKOO_ALWAYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IDA PCI controller */
end_comment

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_COMPAQ_SMART2P
value|0xae100e11ul
end_define

begin_define
define|#
directive|define
name|PCI_CONTROLLER
parameter_list|(
name|ctlp
parameter_list|)
value|(ctlp->ident == PCI_DEVICE_ID_COMPAQ_SMART2P)
end_define

begin_typedef
typedef|typedef
struct|struct
name|ida_pci_reg
block|{
name|u_long
name|unknown
decl_stmt|;
name|u_long
name|initiate_fifo
decl_stmt|;
define|#
directive|define
name|IDA_PCI_BUSY
value|1
name|u_long
name|complete_fifo
decl_stmt|;
name|u_long
name|interrupt
decl_stmt|;
define|#
directive|define
name|IDA_PCI_ENABLE_INTS
value|1
define|#
directive|define
name|IDA_PCI_DISABLE_INTS
value|0
name|u_long
name|status
decl_stmt|;
define|#
directive|define
name|IDA_PCI_PENDING
value|1
define|#
directive|define
name|IDA_PCI_READY
value|2
block|}
name|ida_pci_reg_t
typedef|;
end_typedef

begin_comment
comment|/* IDA controller register definitions */
end_comment

begin_define
define|#
directive|define
name|R_ID0
value|0xc80
end_define

begin_comment
comment|/* id byte 0 */
end_comment

begin_define
define|#
directive|define
name|R_ID1
value|0xc81
end_define

begin_comment
comment|/* id byte 1 */
end_comment

begin_define
define|#
directive|define
name|R_ID2
value|0xc82
end_define

begin_comment
comment|/* id byte 2 */
end_comment

begin_define
define|#
directive|define
name|R_ID3
value|0xc83
end_define

begin_comment
comment|/* id byte 3 */
end_comment

begin_define
define|#
directive|define
name|R_CONF
value|0xc88
end_define

begin_comment
comment|/* global configuration */
end_comment

begin_define
define|#
directive|define
name|R_SYSINT
value|0xc89
end_define

begin_comment
comment|/* system interrupt enable/ctrl */
end_comment

begin_define
define|#
directive|define
name|R_SEM0
value|0xc8a
end_define

begin_comment
comment|/* semaphore port 0 */
end_comment

begin_define
define|#
directive|define
name|R_SEM1
value|0xc8b
end_define

begin_comment
comment|/* semaphore port 1 */
end_comment

begin_define
define|#
directive|define
name|R_LBELL_E
value|0xc8c
end_define

begin_comment
comment|/* local doorbell enable */
end_comment

begin_define
define|#
directive|define
name|R_LBELL_I
value|0xc8d
end_define

begin_comment
comment|/* local doorbell int/status */
end_comment

begin_define
define|#
directive|define
name|R_EBELL_E
value|0xc8e
end_define

begin_comment
comment|/* EISA doorbell enable */
end_comment

begin_define
define|#
directive|define
name|R_EBELL_I
value|0xc8f
end_define

begin_comment
comment|/* EISA doorbell int/status */
end_comment

begin_define
define|#
directive|define
name|R_SUB_ADDR
value|0xc90
end_define

begin_comment
comment|/* submit address */
end_comment

begin_define
define|#
directive|define
name|R_SUB_LEN
value|0xc94
end_define

begin_comment
comment|/* submit cmdlist size */
end_comment

begin_define
define|#
directive|define
name|R_COM_ADDR
value|0xc98
end_define

begin_comment
comment|/* completion address */
end_comment

begin_define
define|#
directive|define
name|R_COM_OFF
value|0xc9c
end_define

begin_comment
comment|/* completion request offset */
end_comment

begin_define
define|#
directive|define
name|R_COM_STAT
value|0xc9e
end_define

begin_comment
comment|/* completion cmdlist status */
end_comment

begin_define
define|#
directive|define
name|R_INTDEF
value|0xcc0
end_define

begin_comment
comment|/* interrupt definition */
end_comment

begin_comment
comment|/*  * BMIC doorbell status codes  */
end_comment

begin_define
define|#
directive|define
name|BMIC_DATA_READY
value|0x01
end_define

begin_comment
comment|/* data ready bit */
end_comment

begin_define
define|#
directive|define
name|BMIC_CHAN_CLEAR
value|0x02
end_define

begin_comment
comment|/* channel clear bit */
end_comment

begin_comment
comment|/* IDA controller command list return status values */
end_comment

begin_define
define|#
directive|define
name|IDA_COMPL_OK
value|0x01
end_define

begin_comment
comment|/* command list completed ok */
end_comment

begin_define
define|#
directive|define
name|IDA_NON_FATAL
value|0x02
end_define

begin_comment
comment|/* non-fatal error */
end_comment

begin_define
define|#
directive|define
name|IDA_FATAL
value|0x04
end_define

begin_comment
comment|/* fatal error */
end_comment

begin_define
define|#
directive|define
name|IDA_ABORTED
value|0x08
end_define

begin_comment
comment|/* command list aborted */
end_comment

begin_define
define|#
directive|define
name|IDA_INVAL_REQ
value|0x10
end_define

begin_comment
comment|/* bad request block */
end_comment

begin_define
define|#
directive|define
name|IDA_INVAL_LIST
value|0x20
end_define

begin_comment
comment|/* bad command list */
end_comment

begin_define
define|#
directive|define
name|IDA_AARGH_LIST
value|0x40
end_define

begin_comment
comment|/* totally disastrous command list */
end_comment

begin_comment
comment|/* IDA controller command codes */
end_comment

begin_define
define|#
directive|define
name|IDA_GET_DRV_INFO
value|0x10
end_define

begin_define
define|#
directive|define
name|IDA_GET_CTL_INFO
value|0x11
end_define

begin_define
define|#
directive|define
name|IDA_READ_DATA
value|0x20
end_define

begin_define
define|#
directive|define
name|IDA_WRITE_DATA
value|0x30
end_define

begin_define
define|#
directive|define
name|IDA_FLUSH_CACHE
value|0xc2
end_define

begin_comment
comment|/* Interrupt definition codes */
end_comment

begin_define
define|#
directive|define
name|IDA_IRQ_MASK
value|0xfc
end_define

begin_define
define|#
directive|define
name|IDA_IRQ_10
value|0x20
end_define

begin_define
define|#
directive|define
name|IDA_IRQ_11
value|0x10
end_define

begin_define
define|#
directive|define
name|IDA_IRQ_14
value|0x40
end_define

begin_define
define|#
directive|define
name|IDA_IRQ_15
value|0x80
end_define

begin_comment
comment|/* IDA controller hardware command structure definitions */
end_comment

begin_typedef
typedef|typedef
name|u_long
name|physaddr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|ida_hdr
block|{
name|u_long
name|drive
range|:
literal|8
decl_stmt|;
comment|/* logical drive */
name|u_long
name|priority
range|:
literal|8
decl_stmt|;
comment|/* block priority */
name|u_long
name|flags
range|:
literal|16
decl_stmt|;
comment|/* control flags */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ida_req
block|{
name|u_long
name|next
range|:
literal|16
decl_stmt|;
comment|/* offset of next request */
name|u_long
name|command
range|:
literal|8
decl_stmt|;
comment|/* command */
name|u_long
name|error
range|:
literal|8
decl_stmt|;
comment|/* return error code */
name|u_long
name|blkno
decl_stmt|;
comment|/* block number */
name|u_short
name|bcount
decl_stmt|;
comment|/* block count */
name|u_short
name|sgcount
decl_stmt|;
comment|/* number of scatter gather entries */
comment|/* a struct ida_req is followed physically by an array of struct ida_sgb */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ida_sgb
block|{
name|u_long
name|len
decl_stmt|;
comment|/* length of scatter gather segmmentk */
name|physaddr_t
name|addr
decl_stmt|;
comment|/* physical address of block */
block|}
struct|;
end_struct

begin_comment
comment|/* first some handy definitions as FreeBSD gcc doesn't do #pragma pack() */
end_comment

begin_define
define|#
directive|define
name|pack_char
parameter_list|(
name|name
parameter_list|)
value|u_char name[1]
end_define

begin_define
define|#
directive|define
name|pack_short
parameter_list|(
name|name
parameter_list|)
value|u_char name[2]
end_define

begin_define
define|#
directive|define
name|pack_int
parameter_list|(
name|name
parameter_list|)
value|u_char name[4]
end_define

begin_define
define|#
directive|define
name|pack_long
parameter_list|(
name|name
parameter_list|)
value|u_char name[4]
end_define

begin_comment
comment|/* ugly, but not inefficient, as it gets evaluated at compile time by gcc */
end_comment

begin_define
define|#
directive|define
name|u_unpack
parameter_list|(
name|member
parameter_list|)
value|( \ 			  (sizeof(member) == 1) ? *(u_char *)(member) \ 			  : (sizeof(member) == 2) ? *(u_short *)(member) \ 			  : *(u_int *)(member) \ 			   )
end_define

begin_define
define|#
directive|define
name|s_unpack
parameter_list|(
name|member
parameter_list|)
value|( \ 			  (sizeof(member) == 1) ? *(char *)(member) \ 			  : (sizeof(member) == 2) ? *(short *)(member) \ 			  : *(int *)(member) \ 			   )
end_define

begin_comment
comment|/* IDA controller hardware returned data structure definitions */
end_comment

begin_struct
struct|struct
name|ida_ctl_info
block|{
name|pack_char
argument_list|(
name|num_drvs
argument_list|)
expr_stmt|;
name|pack_long
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|pack_long
argument_list|(
name|firm_rev
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ida_drv_info
block|{
name|pack_short
argument_list|(
name|secsize
argument_list|)
expr_stmt|;
name|pack_long
argument_list|(
name|secperunit
argument_list|)
expr_stmt|;
name|pack_short
argument_list|(
name|ncylinders
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|ntracks
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|signature
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|psectors
argument_list|)
expr_stmt|;
name|pack_short
argument_list|(
name|wprecomp
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|max_acc
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|pack_short
argument_list|(
name|pcylinders
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|ptracks
argument_list|)
expr_stmt|;
name|pack_short
argument_list|(
name|landing_zone
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|nsectors
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|checksum
argument_list|)
expr_stmt|;
name|pack_char
argument_list|(
name|mirror
argument_list|)
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* IDA driver queue command block */
end_comment

begin_define
define|#
directive|define
name|IDA_MAX_SGLEN
value|32
end_define

begin_comment
comment|/* maximum entries in scatter gather list */
end_comment

begin_define
define|#
directive|define
name|IDA_MAX_DRVS_CTLR
value|8
end_define

begin_comment
comment|/* maximum logical drives per controller */
end_comment

begin_define
define|#
directive|define
name|IDA_DEF_PRIORITY
value|16
end_define

begin_comment
comment|/* default priority for command list */
end_comment

begin_define
define|#
directive|define
name|IDA_SCSI_TARGET_ID
value|7
end_define

begin_define
define|#
directive|define
name|IDA_QCB_MAX
value|256
end_define

begin_struct
struct|struct
name|ida_qcb
block|{
comment|/* first some hardware specific fields ... */
name|struct
name|ida_hdr
name|hdr
decl_stmt|;
name|struct
name|ida_req
name|req
decl_stmt|;
name|struct
name|ida_sgb
name|sglist
index|[
name|IDA_MAX_SGLEN
index|]
decl_stmt|;
comment|/* and then some driver queue managment stuff */
name|u_int
name|flags
decl_stmt|;
comment|/* qcb type */
define|#
directive|define
name|QCB_FREE
value|0
comment|/* ready for a new command */
define|#
directive|define
name|QCB_ACTIVE
value|1
comment|/* waiting to be sent to the controller */
define|#
directive|define
name|QCB_SENT
value|2
comment|/* waiting for interrupt from the controller */
define|#
directive|define
name|QCB_IMMED
value|4
comment|/* immediate (non-queued) command */
define|#
directive|define
name|QCB_IMMED_FAIL
value|8
name|struct
name|ida_qcb
modifier|*
name|next
decl_stmt|;
comment|/* next ida command block of this type */
name|struct
name|ida_qcb
modifier|*
name|last
decl_stmt|;
comment|/* last ida command block of this type */
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
comment|/* buf associated with this qcb */
name|physaddr_t
name|paddr
decl_stmt|;
comment|/* physical address of this struct */
name|struct
name|ida_qcb
modifier|*
name|nexthash
decl_stmt|;
comment|/* next ida command block with same hash value */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ida_qcb
name|qcb_t
typedef|;
end_typedef

begin_comment
comment|/* IDA driver controller and drive information blocks */
end_comment

begin_define
define|#
directive|define
name|QCB_HASH_SIZE
value|257
end_define

begin_comment
comment|/* some suitable prime number */
end_comment

begin_define
define|#
directive|define
name|QCB_HASH
parameter_list|(
name|h
parameter_list|)
value|((h) % QCB_HASH_SIZE)
end_define

begin_struct
struct|struct
name|ida_drv
block|{
name|u_int
name|flags
decl_stmt|;
define|#
directive|define
name|ID_INIT
value|0x0001
define|#
directive|define
name|ID_WRITEPROT
value|0x0002
define|#
directive|define
name|ID_DEV_OPEN
value|0x0004
name|u_int
name|ctl_unit
decl_stmt|;
comment|/* which controller is this drive on */
name|u_int
name|drv_unit
decl_stmt|;
comment|/* number of this virtual disk */
name|struct
name|ida_drv_info
name|drv_info
decl_stmt|;
comment|/* data from the controller */
name|struct
name|diskslices
modifier|*
name|slices
decl_stmt|;
comment|/* new slice code */
name|struct
name|devstat
name|dk_stats
decl_stmt|;
comment|/* devstat entry */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ida_ctl
block|{
name|u_int
name|ident
decl_stmt|;
comment|/* controller identifier */
name|u_int
name|flags
decl_stmt|;
name|u_int
name|iobase
decl_stmt|;
name|u_short
name|inside
decl_stmt|;
comment|/* number of qcbs in the controller */
name|u_short
name|max_inside
decl_stmt|;
comment|/* maximum number simulaneously active */
name|u_short
name|num_qcbs
decl_stmt|;
comment|/* number of qcbs allocated */
name|u_char
name|num_drvs
decl_stmt|;
name|u_char
name|irq
decl_stmt|;
name|u_char
name|com_status
decl_stmt|;
comment|/* status of last completed command list */
name|physaddr_t
name|com_addr
decl_stmt|;
comment|/* address of last completed command list */
name|u_short
name|com_offset
decl_stmt|;
comment|/* offset of last completed command list */
name|qcb_t
modifier|*
name|freelist
decl_stmt|;
comment|/* linked list of free qcbs */
name|qcb_t
modifier|*
name|send_next
decl_stmt|;
comment|/* doubly-linked list of unsent qcbs */
name|qcb_t
modifier|*
name|send_last
decl_stmt|;
comment|/* because we must treat all jobs equally */
name|qcb_t
modifier|*
name|hashlist
index|[
name|QCB_HASH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|ida_ctl
modifier|*
name|idadata
index|[
name|NIDA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Useful IDA controller IO macro definitions */
end_comment

begin_define
define|#
directive|define
name|IDA_DISABLE_INTERRUPT
parameter_list|(
name|iobase
parameter_list|)
value|outb(iobase + R_SYSINT, 0)
end_define

begin_define
define|#
directive|define
name|IDA_ENABLE_INTERRUPT
parameter_list|(
name|ctlp
parameter_list|)
value|outb(ctlp->iobase + R_SYSINT, 1)
end_define

begin_define
define|#
directive|define
name|IDA_SET_READY
parameter_list|(
name|ctlp
parameter_list|)
value|outb(ctlp->iobase + R_EBELL_E, 1)
end_define

begin_define
define|#
directive|define
name|IDA_DATA_READY
parameter_list|(
name|ctlp
parameter_list|)
value|((inb(ctlp->iobase + R_EBELL_I)& 1))
end_define

begin_define
define|#
directive|define
name|IDA_CHAN_CLEAR
parameter_list|(
name|ctlp
parameter_list|)
value|((inb(ctlp->iobase + R_EBELL_I)& 2))
end_define

begin_comment
comment|/* enable/disable interrupts on a change of channel clear status (?) */
end_comment

begin_define
define|#
directive|define
name|IDA_ENABLE_CHAN
parameter_list|(
name|ctlp
parameter_list|)
define|\
value|outb(ctlp->iobase + R_EBELL_E, inb(ctlp->iobase + R_EBELL_E) | 2)
end_define

begin_define
define|#
directive|define
name|IDA_DISABLE_CHAN
parameter_list|(
name|ctlp
parameter_list|)
define|\
value|outb(ctlp->iobase + R_EBELL_E, inb(ctlp->iobase + R_EBELL_E)& ~0x2)
end_define

begin_comment
comment|/* acknowledge the completion of a command */
end_comment

begin_define
define|#
directive|define
name|IDA_ACK_CMD_COM
parameter_list|(
name|ctlp
parameter_list|)
define|\
value|(outb(ctlp->iobase + R_EBELL_I, 1), outb(ctlp->iobase + R_LBELL_I, 2))
end_define

begin_comment
comment|/* set submission details for a command list */
end_comment

begin_define
define|#
directive|define
name|IDA_SET_SUB_ADDR
parameter_list|(
name|ctlp
parameter_list|,
name|addr
parameter_list|)
value|outl(ctlp->iobase + R_SUB_ADDR, addr)
end_define

begin_define
define|#
directive|define
name|IDA_SET_SUB_LEN
parameter_list|(
name|ctlp
parameter_list|,
name|size
parameter_list|)
value|outw(ctlp->iobase + R_SUB_LEN, size)
end_define

begin_comment
comment|/* get completion details for a command list */
end_comment

begin_define
define|#
directive|define
name|IDA_GET_COM_ADDR
parameter_list|(
name|ctlp
parameter_list|)
value|inl(ctlp->iobase + R_COM_ADDR)
end_define

begin_define
define|#
directive|define
name|IDA_GET_COM_OFFSET
parameter_list|(
name|ctlp
parameter_list|)
value|inw(ctlp->iobase + R_COM_OFF)
end_define

begin_define
define|#
directive|define
name|IDA_GET_COM_STATUS
parameter_list|(
name|ctlp
parameter_list|)
value|inb(ctlp->iobase + R_COM_STAT)
end_define

begin_define
define|#
directive|define
name|IDA_READ_EBELL_I
parameter_list|(
name|ctlp
parameter_list|)
value|inb(ctlp->iobase + R_EBELL_I)
end_define

begin_define
define|#
directive|define
name|IDA_READ_EBELL_E
parameter_list|(
name|ctlp
parameter_list|)
value|inb(ctlp->iobase + R_EBELL_E)
end_define

begin_define
define|#
directive|define
name|IDA_READ_LBELL_I
parameter_list|(
name|ctlp
parameter_list|)
value|inb(ctlp->iobase + R_LBELL_I)
end_define

begin_define
define|#
directive|define
name|IDA_SET_EBELL_I
parameter_list|(
name|ctlp
parameter_list|,
name|n
parameter_list|)
value|outb(ctlp->iobase + R_EBELL_I, n)
end_define

begin_define
define|#
directive|define
name|IDA_SET_LBELL_I
parameter_list|(
name|ctlp
parameter_list|,
name|n
parameter_list|)
value|outb(ctlp->iobase + R_LBELL_I, n)
end_define

begin_define
define|#
directive|define
name|JOB_SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|JOB_FAILURE
value|1
end_define

begin_define
define|#
directive|define
name|JOB_ABORTED
value|2
end_define

begin_comment
comment|/* debugging aids */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IDADEBUG
end_ifdef

begin_define
define|#
directive|define
name|IDA_MAXQCBS
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|IDA_SHOWQCBS
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|IDA_SHOWSUBS
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|IDA_SHOWINTS
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|IDA_SHOWCMDS
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|IDA_SHOWMISC
value|(1<<5)
end_define

begin_function_decl
name|void
name|ida_print_qcb
parameter_list|(
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ida_print_active_qcb
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ida_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ida_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ida_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ida_soft_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ida_soft_errors
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ida_soft_errors
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* EISA probe and board identification definitions */
end_comment

begin_define
define|#
directive|define
name|MAX_EISA_SLOT
value|16
end_define

begin_define
define|#
directive|define
name|IDA_EISA_PROD_ID
value|0x40
end_define

begin_union
union|union
name|eisa_id
block|{
name|u_int
name|value
decl_stmt|;
struct|struct
block|{
name|u_int
name|rev
range|:
literal|8
decl_stmt|;
name|u_int
name|prod
range|:
literal|8
decl_stmt|;
name|u_int
name|mfr2
range|:
literal|5
decl_stmt|;
name|u_int
name|mfr1
range|:
literal|5
decl_stmt|;
name|u_int
name|mfr0
range|:
literal|5
decl_stmt|;
block|}
name|split
struct|;
block|}
union|;
end_union

begin_comment
comment|/* test the manufacturer ID within an EISA board ID */
end_comment

begin_define
define|#
directive|define
name|EISA_MFR_EQ
parameter_list|(
name|ident
parameter_list|,
name|mfr
parameter_list|)
value|( \ 				 (ident).split.mfr0 + '@' == (mfr)[0]&& \ 				 (ident).split.mfr1 + '@' == (mfr)[1]&& \ 				 (ident).split.mfr2 + '@' == (mfr)[2] \ 				  )
end_define

begin_comment
comment|/* generates a list of EISA board ID values, suitable for a printf */
end_comment

begin_define
define|#
directive|define
name|EISA_ID_LIST
parameter_list|(
name|ident
parameter_list|)
define|\
value|(ident).split.mfr0 + '@', \   (ident).split.mfr1 + '@', \   (ident).split.mfr2 + '@', \   (ident).split.prod, \   (ident).split.rev
end_define

begin_function_decl
specifier|extern
name|void
name|DELAY
parameter_list|(
name|int
name|millisecs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* FreeBSD IDA driver forward function definitions */
end_comment

begin_decl_stmt
specifier|static
name|d_open_t
name|idopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|idread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|idwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|idclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|idstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|idioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_dump_t
name|iddump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|idsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pci_inthand_t
name|idaintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ida_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ida_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ida_eisa_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ida_eisa_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ida_poll
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|wait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|idaminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ida_start
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ida_get_ctl_info
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ida_attach_drives
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ida_done
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ida_queue_buf
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ida_newqueue
parameter_list|(
name|int
name|cntlr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|qcb_t
modifier|*
name|ida_dequeue
parameter_list|(
name|int
name|cntlr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ida_enqueue
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ida_submit
parameter_list|(
name|int
name|unit
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ida_submit_wait
parameter_list|(
name|int
name|unit
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|qcb_t
modifier|*
name|ida_get_qcb
parameter_list|(
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ida_free_qcb
parameter_list|(
name|int
name|unit
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|qcb_t
modifier|*
name|ida_qcb_phys_kv
parameter_list|(
name|struct
name|ida_ctl
modifier|*
name|ida
parameter_list|,
name|physaddr_t
name|ida_qcb_phys
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|id_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|idadriver
init|=
block|{
name|ida_eisa_probe
block|,
name|ida_eisa_attach
block|,
literal|"ida"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ida_pci_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|ida_pci_driver
init|=
block|{
literal|"ida"
block|,
name|ida_pci_probe
block|,
name|ida_pci_attach
block|,
operator|&
name|ida_pci_count
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|ida_pci_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* definitions for stealing wd driver's vectors */
end_comment

begin_define
define|#
directive|define
name|ID_BDMAJ
value|29
end_define

begin_define
define|#
directive|define
name|ID_CDMAJ
value|109
end_define

begin_define
define|#
directive|define
name|WD_BDMAJ
value|0
end_define

begin_define
define|#
directive|define
name|WD_CDMAJ
value|3
end_define

begin_decl_stmt
name|struct
name|isa_driver
name|wdcdriver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stub_probe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stub_attach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|isa_driver
name|nodriver
init|=
block|{
name|stub_probe
block|,
name|stub_attach
block|,
literal|"stub"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* steal the wdc driver's vectors if we have booted off a wd device */
end_comment

begin_function
specifier|static
name|void
name|ida_cuckoo_wdc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cuckoo
init|=
name|IDA_CUCKOO_MODE
decl_stmt|;
name|int
name|steal
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
name|int
name|major
init|=
name|B_TYPE
argument_list|(
name|bootdev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cuckoo
operator|==
name|IDA_CUCKOO_NEVER
condition|)
block|{
name|mode
operator|=
literal|"never"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cuckoo
operator|==
name|IDA_CUCKOO_ROOTWD
condition|)
block|{
name|mode
operator|=
literal|"rootwd"
expr_stmt|;
name|steal
operator|=
operator|(
name|major
operator|==
name|WD_BDMAJ
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cuckoo
operator|==
name|IDA_CUCKOO_ROOTNOTIDA
condition|)
block|{
name|mode
operator|=
literal|"notida"
expr_stmt|;
comment|/* check for magic value of 3 rather than ID_BDMAJ as boot code      * pretends we are a wt device (not normally bootable)      */
name|steal
operator|=
operator|(
name|major
operator|!=
literal|3
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
literal|"always"
expr_stmt|;
name|steal
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ida: wdc vector stealing %s (mode = %s, boot major = %d)\n"
argument_list|,
operator|(
name|steal
condition|?
literal|"on"
else|:
literal|"off"
operator|)
argument_list|,
name|mode
argument_list|,
name|major
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|steal
condition|)
return|return;
comment|/* OK - we have a controller, so steal wd driver's vectors */
name|wdcdriver
operator|=
name|nodriver
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_open
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_open
operator|=
name|idopen
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_close
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_close
operator|=
name|idclose
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_read
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_read
operator|=
name|idread
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_write
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_write
operator|=
name|idwrite
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_strategy
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_strategy
operator|=
name|idstrategy
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_ioctl
operator|=
name|cdevsw
index|[
name|WD_CDMAJ
index|]
operator|->
name|d_ioctl
operator|=
name|idioctl
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_dump
operator|=
name|iddump
expr_stmt|;
name|bdevsw
index|[
name|WD_BDMAJ
index|]
operator|->
name|d_psize
operator|=
name|idsize
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ida_ctl
modifier|*
name|idadata
index|[
name|NIDA
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* controller structures */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ida_drv
modifier|*
name|id_drive
index|[
name|NID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of drives */
end_comment

begin_decl_stmt
specifier|static
name|int
name|id_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of drives found */
end_comment

begin_comment
comment|/* general purpose data buffer for 'special' IDA driver commands */
end_comment

begin_union
union|union
name|ida_buf
block|{
name|char
name|pad
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|ida_ctl_info
name|ctl
decl_stmt|;
name|struct
name|ida_drv_info
name|drv
decl_stmt|;
block|}
name|ida_buf
union|;
end_union

begin_function
specifier|static
name|int
name|stub_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stub_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ida_pci_probe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PCI_DEVICE_ID_COMPAQ_SMART2P
case|:
return|return
literal|"Compaq SMART-2/P array controller"
return|;
break|break;
default|default:
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|ida_pci_reg_t
modifier|*
name|reg
decl_stmt|;
name|struct
name|ida_ctl
modifier|*
name|ctlp
decl_stmt|;
name|u_long
name|id
decl_stmt|;
name|vm_offset_t
name|paddr
decl_stmt|,
name|vaddr
decl_stmt|;
name|id
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|PCI_DEVICE_ID_COMPAQ_SMART2P
case|:
break|break;
default|default:
break|break;
block|}
if|if
condition|(
operator|!
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
literal|0x14
argument_list|,
operator|&
name|vaddr
argument_list|,
operator|&
name|paddr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ida: map failed.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* allocate and initialise a storage area for this controller */
if|if
condition|(
name|idadata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: controller structure already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|ctlp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ida_ctl
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: unable to allocate controller structure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
name|idadata
index|[
name|unit
index|]
operator|=
name|ctlp
expr_stmt|;
name|bzero
argument_list|(
name|ctlp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ida_ctl
argument_list|)
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|ident
operator|=
name|id
expr_stmt|;
name|ctlp
operator|->
name|iobase
operator|=
name|vaddr
expr_stmt|;
comment|/* Install the interrupt handler. */
if|if
condition|(
operator|!
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|idaintr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|unit
argument_list|,
operator|&
name|bio_imask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: failed to assign an interrupt handler\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ctlp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|idadata
index|[
name|unit
index|]
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ida_get_ctl_info
argument_list|(
name|unit
argument_list|)
operator|&&
name|ida_attach_drives
argument_list|(
name|unit
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
name|reg
operator|=
operator|(
name|ida_pci_reg_t
operator|*
operator|)
name|vaddr
expr_stmt|;
name|reg
operator|->
name|interrupt
operator|=
name|IDA_PCI_ENABLE_INTS
expr_stmt|;
name|ida_cuckoo_wdc
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ida_eisa_probe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
specifier|static
name|u_int
name|ida_used
init|=
literal|0
decl_stmt|;
name|u_int
name|slot
decl_stmt|;
name|u_int
name|port
decl_stmt|;
name|u_char
name|intdef
decl_stmt|;
name|u_char
name|irq
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|union
name|eisa_id
name|ident
decl_stmt|;
name|struct
name|ida_ctl
modifier|*
name|ctlp
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_iobase
condition|)
block|{
comment|/* check out the configured iobase if given one */
name|slot
operator|=
name|dev
operator|->
name|id_iobase
operator|/
literal|0x1000
expr_stmt|;
if|if
condition|(
name|slot
operator|==
literal|0
operator|||
name|slot
operator|>
name|MAX_EISA_SLOT
condition|)
block|{
name|printf
argument_list|(
literal|"ida: port address (0x%x) out of range\n"
argument_list|,
name|dev
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* otherwise, search from the beginning for an unused slot to check out */
name|slot
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|ida_used
operator|&
operator|(
literal|1
operator|<<
name|slot
operator|)
condition|)
block|{
if|if
condition|(
name|slot
operator|++
operator|==
name|MAX_EISA_SLOT
condition|)
return|return
literal|0
return|;
block|}
name|ida_used
operator||=
operator|(
literal|1
operator|<<
name|slot
operator|)
expr_stmt|;
name|port
operator|=
name|slot
operator|*
literal|0x1000
expr_stmt|;
comment|/* read the EISA identification bytes */
name|ident
operator|.
name|value
operator|=
name|inb
argument_list|(
name|port
operator|+
name|R_ID0
argument_list|)
expr_stmt|;
name|ident
operator|.
name|value
operator|<<=
literal|8
expr_stmt|;
name|ident
operator|.
name|value
operator||=
name|inb
argument_list|(
name|port
operator|+
name|R_ID1
argument_list|)
expr_stmt|;
name|ident
operator|.
name|value
operator|<<=
literal|8
expr_stmt|;
name|ident
operator|.
name|value
operator||=
name|inb
argument_list|(
name|port
operator|+
name|R_ID2
argument_list|)
expr_stmt|;
name|ident
operator|.
name|value
operator|<<=
literal|8
expr_stmt|;
name|ident
operator|.
name|value
operator||=
name|inb
argument_list|(
name|port
operator|+
name|R_ID3
argument_list|)
expr_stmt|;
comment|/* check that the card is the right type ? */
if|if
condition|(
name|EISA_MFR_EQ
argument_list|(
name|ident
argument_list|,
literal|"CPQ"
argument_list|)
operator|&&
name|ident
operator|.
name|split
operator|.
name|prod
operator|==
name|IDA_EISA_PROD_ID
condition|)
block|{
break|break;
block|}
comment|/* if we were config'ed with an iobase, then don't probe any more slots */
if|if
condition|(
name|dev
operator|->
name|id_iobase
condition|)
return|return
literal|0
return|;
block|}
comment|/* disable interrupts and find out what interrupt this controller uses */
name|IDA_DISABLE_INTERRUPT
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|intdef
operator|=
name|inb
argument_list|(
name|port
operator|+
name|R_INTDEF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intdef
operator|&
name|IDA_IRQ_MASK
condition|)
block|{
case|case
name|IDA_IRQ_10
case|:
name|irq
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|IDA_IRQ_11
case|:
name|irq
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|IDA_IRQ_14
case|:
name|irq
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|IDA_IRQ_15
case|:
name|irq
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ida: slot %d bogus interrupt setting (0x%02x)\n"
argument_list|,
name|slot
argument_list|,
name|intdef
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|irq
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* allocate and initialise a storage area for this controller */
if|if
condition|(
name|idadata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: controller structure already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|ctlp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ida_ctl
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: unable to allocate controller structure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|idadata
index|[
name|unit
index|]
operator|=
name|ctlp
expr_stmt|;
name|bzero
argument_list|(
name|ctlp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ida_ctl
argument_list|)
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|iobase
operator|=
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
name|ctlp
operator|->
name|ident
operator|=
name|ident
operator|.
name|value
expr_stmt|;
name|ctlp
operator|->
name|irq
operator|=
name|irq
expr_stmt|;
if|if
condition|(
name|ida_get_ctl_info
argument_list|(
name|unit
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* return range of io ports used */
return|return
literal|0x1000
return|;
block|}
end_function

begin_function
name|int
name|ida_get_ctl_info
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ctlp
init|=
name|idadata
index|[
name|unit
index|]
decl_stmt|;
name|qcb_t
name|qcb
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
init|=
operator|&
name|qcb
decl_stmt|;
name|ida_newqueue
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* controller capacity statistics */
name|ctlp
operator|->
name|inside
operator|=
literal|0
expr_stmt|;
name|ctlp
operator|->
name|max_inside
operator|=
literal|0
expr_stmt|;
comment|/* ask the controller to tell us about itself with an IDA_GET_CTL_INFO */
name|bzero
argument_list|(
name|qcbp
argument_list|,
sizeof|sizeof
argument_list|(
name|qcb_t
argument_list|)
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|paddr
operator|=
name|vtophys
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
literal|0x00
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x24
expr_stmt|;
block|}
else|else
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
name|IDA_DEF_PRIORITY
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x12
expr_stmt|;
block|}
name|qcbp
operator|->
name|req
operator|.
name|command
operator|=
name|IDA_GET_CTL_INFO
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|bcount
operator|=
literal|1
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|sgcount
operator|=
literal|1
expr_stmt|;
name|qcbp
operator|->
name|sglist
index|[
literal|0
index|]
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ida_buf
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|sglist
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|ida_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ida_submit_wait
argument_list|(
name|unit
argument_list|,
name|qcbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ida_qcb
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: idasubmit failed on IDA_GET_CTL_INFO\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|PCI_CONTROLLER
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctlp
operator|->
name|com_status
operator|!=
name|IDA_COMPL_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: bad status 0x%02x from IDA_GET_CTL_INFO\n"
argument_list|,
name|unit
argument_list|,
name|ctlp
operator|->
name|com_status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* got the information at last, print it and note the number of drives */
name|printf
argument_list|(
literal|"ida%d: drvs=%d firm_rev=%c%c%c%c\n"
argument_list|,
name|unit
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|ctl
operator|.
name|num_drvs
argument_list|)
argument_list|,
name|ida_buf
operator|.
name|ctl
operator|.
name|firm_rev
index|[
literal|0
index|]
argument_list|,
name|ida_buf
operator|.
name|ctl
operator|.
name|firm_rev
index|[
literal|1
index|]
argument_list|,
name|ida_buf
operator|.
name|ctl
operator|.
name|firm_rev
index|[
literal|2
index|]
argument_list|,
name|ida_buf
operator|.
name|ctl
operator|.
name|firm_rev
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|num_drvs
operator|=
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|ctl
operator|.
name|num_drvs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ida_attach_drives
parameter_list|(
name|int
name|cntlr
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ctlp
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|qcb_t
name|qcb
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
init|=
operator|&
name|qcb
decl_stmt|;
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
name|int
name|drive
decl_stmt|;
name|int
name|unit
decl_stmt|;
comment|/* prepare to interrogate the drives */
name|bzero
argument_list|(
name|qcbp
argument_list|,
sizeof|sizeof
argument_list|(
name|qcb_t
argument_list|)
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|command
operator|=
name|IDA_GET_DRV_INFO
expr_stmt|;
name|qcbp
operator|->
name|paddr
operator|=
name|vtophys
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
literal|0x00
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x24
expr_stmt|;
block|}
else|else
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
name|IDA_DEF_PRIORITY
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x12
expr_stmt|;
block|}
name|qcbp
operator|->
name|req
operator|.
name|bcount
operator|=
literal|1
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|sgcount
operator|=
literal|1
expr_stmt|;
name|qcbp
operator|->
name|sglist
index|[
literal|0
index|]
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ida_buf
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|sglist
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|ida_buf
argument_list|)
expr_stmt|;
for|for
control|(
name|drive
operator|=
literal|0
init|;
name|drive
operator|<
name|ctlp
operator|->
name|num_drvs
condition|;
name|drive
operator|++
control|)
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|drive
operator|=
name|drive
expr_stmt|;
if|if
condition|(
name|ida_submit_wait
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ida_qcb
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: ida_submit_wait failed on IDA_GET_DRV_INFO\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|PCI_CONTROLLER
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctlp
operator|->
name|com_status
operator|!=
name|IDA_COMPL_OK
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: bad status 0x%02x from IDA_GET_DRV_INFO\n"
argument_list|,
name|cntlr
argument_list|,
name|ctlp
operator|->
name|com_status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
name|drv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ida_drv
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: unable to allocate drive structure\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|drv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ida_drv
argument_list|)
argument_list|)
expr_stmt|;
name|drv
operator|->
name|ctl_unit
operator|=
name|cntlr
expr_stmt|;
name|drv
operator|->
name|drv_unit
operator|=
name|drive
expr_stmt|;
name|drv
operator|->
name|drv_info
operator|=
name|ida_buf
operator|.
name|drv
expr_stmt|;
name|drv
operator|->
name|flags
operator||=
name|ID_INIT
expr_stmt|;
name|unit
operator|=
name|id_unit
expr_stmt|;
name|id_unit
operator|++
expr_stmt|;
comment|/* XXX unsure if this is the right way to do things */
name|id_drive
index|[
name|unit
index|]
operator|=
name|drv
expr_stmt|;
name|printf
argument_list|(
literal|"ida%d: unit %d (id%d):<%s>\n"
argument_list|,
name|cntlr
argument_list|,
name|drive
argument_list|,
name|unit
argument_list|,
literal|"Compaq Logical Drive"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"id%d: %luMB (%lu total sec), "
argument_list|,
name|unit
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secperunit
argument_list|)
operator|/
literal|2048
argument_list|)
operator|*
operator|(
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secsize
argument_list|)
operator|/
literal|512
operator|)
argument_list|,
operator|(
name|u_long
operator|)
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secperunit
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lu cyl, %lu head, %lu sec, bytes/sec %lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|ncylinders
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|ntracks
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|nsectors
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secsize
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Export the drive to the devstat interface.      */
name|devstat_add_entry
argument_list|(
operator|&
name|drv
operator|->
name|dk_stats
argument_list|,
literal|"id"
argument_list|,
name|unit
argument_list|,
operator|(
name|u_int32_t
operator|)
name|drv
operator|->
name|drv_info
operator|.
name|secsize
argument_list|,
name|DEVSTAT_NO_ORDERED_TAGS
argument_list|,
name|DEVSTAT_TYPE_DIRECT
operator||
name|DEVSTAT_TYPE_IF_OTHER
argument_list|,
name|DEVSTAT_PRIORITY_DA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: drive %d secsize=%d secperunit=%d ncylinders=%d ntracks=%d\n"
argument_list|,
name|unit
argument_list|,
name|drive
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|secsize
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|secperunit
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|ncylinders
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|ntracks
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         signature=0x%02x psectors=%d wprecomp=%d max_acc=%d control=0x%02x\n"
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|signature
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|psectors
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|wprecomp
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|max_acc
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|control
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"         pcylinders=%d ptracks=%d landing_zone=%d nsectors=%d checksum=0x%02x\n"
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|pcylinders
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|ptracks
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|landing_zone
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|nsectors
argument_list|)
argument_list|,
name|u_unpack
argument_list|(
name|ida_buf
operator|.
name|drv
operator|.
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attach all the sub-devices we can find. */
end_comment

begin_function
name|int
name|ida_eisa_attach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|cntlr
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|ida_ctl
modifier|*
name|ctlp
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
if|if
condition|(
name|ida_attach_drives
argument_list|(
name|cntlr
argument_list|)
condition|)
block|{
name|IDA_ENABLE_INTERRUPT
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
name|IDA_SET_READY
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
name|ida_cuckoo_wdc
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a drive.  */
end_comment

begin_function
name|int
name|idopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
name|int
name|part
init|=
name|dkpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NID
operator|||
name|part
operator|>=
name|MAXPARTITIONS
condition|)
comment|/* bounds check */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|drv
operator|=
name|id_drive
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|drv
operator|||
operator|!
operator|(
name|drv
operator|->
name|flags
operator|&
name|ID_INIT
operator|)
condition|)
comment|/* drive not initialised */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|drv
operator|->
name|flags
operator||=
name|ID_DEV_OPEN
expr_stmt|;
comment|/* knock up a label for the whole disk. */
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secsize
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secsize
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_nsectors
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|nsectors
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_ntracks
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|ntracks
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_ncylinders
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|ncylinders
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secpercyl
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|ntracks
argument_list|)
operator|*
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|nsectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|label
operator|.
name|d_secpercyl
operator|==
literal|0
condition|)
name|label
operator|.
name|d_secpercyl
operator|=
literal|100
expr_stmt|;
comment|/* prevent accidental division by zero */
name|label
operator|.
name|d_secperunit
operator|=
name|u_unpack
argument_list|(
name|drv
operator|->
name|drv_info
operator|.
name|secperunit
argument_list|)
expr_stmt|;
comment|/* Initialize slice tables. */
if|if
condition|(
operator|(
name|err
operator|=
name|dsopen
argument_list|(
literal|"id"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
literal|0
argument_list|,
operator|&
name|drv
operator|->
name|slices
argument_list|,
operator|&
name|label
argument_list|,
name|idstrategy
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|id_cdevsw
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|drv
operator|->
name|slices
argument_list|)
condition|)
block|{
name|drv
operator|->
name|flags
operator|&=
operator|~
name|ID_DEV_OPEN
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|idclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
name|int
name|part
init|=
name|dkpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NID
operator|||
name|part
operator|>=
name|MAXPARTITIONS
condition|)
comment|/* bounds check */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|drv
operator|=
name|id_drive
index|[
name|unit
index|]
expr_stmt|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|drv
operator|->
name|slices
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|drv
operator|->
name|slices
argument_list|)
condition|)
block|{
name|drv
operator|->
name|flags
operator|&=
operator|~
name|ID_DEV_OPEN
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|idioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
name|int
name|part
init|=
name|dkpart
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|unit
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NID
operator|||
name|part
operator|>=
name|MAXPARTITIONS
operator|||
operator|!
operator|(
name|drv
operator|=
name|id_drive
index|[
name|unit
index|]
operator|)
operator|||
operator|!
operator|(
name|drv
operator|->
name|flags
operator|&
name|ID_INIT
operator|)
condition|)
comment|/* sanity check */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|err
operator|=
name|dsioctl
argument_list|(
literal|"id"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
operator|&
name|drv
operator|->
name|slices
argument_list|,
name|idstrategy
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|dkpart
argument_list|(
name|dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|idstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|1
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|idwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
return|return
operator|(
name|physio
argument_list|(
name|idstrategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
name|minphys
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read/write routine for a buffer.  Finds the proper unit, range checks  * arguments, and schedules the transfer.  Does not wait for the transfer  * to complete.  Multi-page transfers are supported.  All I/O requests must  * be a multiple of a sector in length.  */
end_comment

begin_function
name|void
name|idstrategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|unit
init|=
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
decl_stmt|;
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
name|int
name|opri
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NID
condition|)
block|{
name|printf
argument_list|(
literal|"ida: unit out of range\n"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|drv
operator|=
name|id_drive
index|[
name|unit
index|]
operator|)
operator|||
operator|!
operator|(
name|drv
operator|->
name|flags
operator|&
name|ID_INIT
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"id%d: drive not initialised\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"id%d: negative block requested\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|DEV_BSIZE
operator|!=
literal|0
condition|)
block|{
comment|/* bounds check */
name|printf
argument_list|(
literal|"id%d: count (%lu) not a multiple of a block\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|idaminphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* adjust the transfer size */
comment|/* "soft" write protect check */
if|if
condition|(
operator|(
name|drv
operator|->
name|flags
operator|&
name|ID_WRITEPROT
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* If it's a null transfer, return immediately */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|drv
operator|->
name|slices
argument_list|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ida_queue_buf
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
operator|&
name|drv
operator|->
name|dk_stats
argument_list|)
expr_stmt|;
name|ida_start
argument_list|(
name|drv
operator|->
name|ctl_unit
argument_list|)
expr_stmt|;
comment|/* hit the appropriate controller */
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/* correctly set the buf to indicate a completed xfer */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
block|}
end_function

begin_function
name|void
name|idaminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/* assumes each page requires an sgb entry */
name|int
name|max
init|=
operator|(
name|IDA_MAX_SGLEN
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|max
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
name|max
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a free qcb.  * If there are none, see if we can allocate a new one.  * If so, put it in the hash table too,  * otherwise either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|qcb_t
modifier|*
name|ida_get_qcb
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
decl_stmt|;
name|int
name|hashnum
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* if the freelist is empty - create a qcb until limit is reached */
while|while
condition|(
operator|!
operator|(
name|qcbp
operator|=
name|ida
operator|->
name|freelist
operator|)
condition|)
block|{
if|if
condition|(
name|ida
operator|->
name|num_qcbs
operator|<
name|IDA_QCB_MAX
condition|)
block|{
name|qcbp
operator|=
operator|(
name|qcb_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|qcb_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|qcbp
condition|)
block|{
name|bzero
argument_list|(
name|qcbp
argument_list|,
sizeof|sizeof
argument_list|(
name|qcb_t
argument_list|)
argument_list|)
expr_stmt|;
name|ida
operator|->
name|num_qcbs
operator|++
expr_stmt|;
name|qcbp
operator|->
name|flags
operator|=
name|QCB_ACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida_get_qcb%d: qcb %d created\n"
argument_list|,
name|unit
argument_list|,
name|ida
operator|->
name|num_qcbs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Put in the phystokv hash table. */
comment|/* Never gets taken out. */
name|qcbp
operator|->
name|paddr
operator|=
name|vtophys
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
name|hashnum
operator|=
name|QCB_HASH
argument_list|(
name|qcbp
operator|->
name|paddr
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|nexthash
operator|=
name|ida
operator|->
name|hashlist
index|[
name|hashnum
index|]
expr_stmt|;
name|ida
operator|->
name|hashlist
index|[
name|hashnum
index|]
operator|=
name|qcbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ida%d: Can't malloc QCB\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
comment|/* reached maximum allocation of qcbs - sleep until one is freed */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ida
operator|->
name|freelist
argument_list|,
name|PRIBIO
argument_list|,
literal|"idaqcb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qcbp
condition|)
block|{
comment|/* qet the qcb from from the (non-empty) free list */
name|ida
operator|->
name|freelist
operator|=
name|qcbp
operator|->
name|next
expr_stmt|;
name|qcbp
operator|->
name|flags
operator|=
name|QCB_ACTIVE
expr_stmt|;
block|}
name|gottit
label|:
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida_get_qcb%d: returns 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|qcbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a qcb to the free list */
end_comment

begin_function
specifier|static
name|void
name|ida_free_qcb
parameter_list|(
name|int
name|unit
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida_free_qcb%d: freeing 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|qcbp
operator|->
name|next
operator|=
name|ida
operator|->
name|freelist
expr_stmt|;
name|ida
operator|->
name|freelist
operator|=
name|qcbp
expr_stmt|;
name|qcbp
operator|->
name|flags
operator|=
name|QCB_FREE
expr_stmt|;
comment|/* if the free list was empty, wakeup anyone sleeping */
if|if
condition|(
operator|!
name|qcbp
operator|->
name|next
condition|)
block|{
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida_free_qcb%d: about to wakeup 0x%x queue\n"
argument_list|,
name|unit
argument_list|,
operator|&
name|ida
operator|->
name|freelist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ida
operator|->
name|freelist
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the ida_qcb having a given physical address */
end_comment

begin_function
name|qcb_t
modifier|*
name|ida_qcb_phys_kv
parameter_list|(
name|ida
parameter_list|,
name|ida_qcb_phys
parameter_list|)
name|struct
name|ida_ctl
modifier|*
name|ida
decl_stmt|;
name|physaddr_t
name|ida_qcb_phys
decl_stmt|;
block|{
name|int
name|hash
init|=
name|QCB_HASH
argument_list|(
name|ida_qcb_phys
argument_list|)
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
init|=
name|ida
operator|->
name|hashlist
index|[
name|hash
index|]
decl_stmt|;
while|while
condition|(
name|qcbp
condition|)
block|{
if|if
condition|(
name|qcbp
operator|->
name|paddr
operator|==
name|ida_qcb_phys
condition|)
break|break;
name|qcbp
operator|=
name|qcbp
operator|->
name|nexthash
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida?: ida_qcb_phys_kv(0x%x) = 0x%x\n"
argument_list|,
name|ida_qcb_phys
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|qcbp
return|;
block|}
end_function

begin_function
name|void
name|ida_queue_buf
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|ida_drv
modifier|*
name|drv
init|=
name|id_drive
index|[
name|unit
index|]
decl_stmt|;
name|int
name|cntlr
init|=
name|drv
operator|->
name|ctl_unit
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
init|=
name|ida_get_qcb
argument_list|(
name|cntlr
argument_list|)
decl_stmt|;
comment|/* may cause us to wait */
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|unsigned
name|int
name|datalen
init|=
name|bp
operator|->
name|b_bcount
decl_stmt|;
name|int
name|thiskv
init|=
operator|(
name|int
operator|)
name|bp
operator|->
name|b_data
decl_stmt|;
name|physaddr_t
name|thisphys
init|=
name|vtophys
argument_list|(
name|thiskv
argument_list|)
decl_stmt|;
name|int
name|nsgb
init|=
literal|0
decl_stmt|;
comment|/* number of scatter/gather blocks used */
name|struct
name|ida_sgb
modifier|*
name|sg
init|=
operator|&
operator|(
name|qcbp
operator|->
name|sglist
index|[
literal|0
index|]
operator|)
decl_stmt|;
comment|/* fill in the qcb command header */
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
literal|0x00
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x24
expr_stmt|;
block|}
else|else
block|{
name|qcbp
operator|->
name|hdr
operator|.
name|priority
operator|=
name|IDA_DEF_PRIORITY
expr_stmt|;
name|qcbp
operator|->
name|hdr
operator|.
name|flags
operator|=
literal|0x10
expr_stmt|;
block|}
name|qcbp
operator|->
name|hdr
operator|.
name|drive
operator|=
name|drv
operator|->
name|drv_unit
expr_stmt|;
comment|/* logical drive number */
name|qcbp
operator|->
name|buf
operator|=
name|bp
expr_stmt|;
comment|/* the buf this command came from */
comment|/* set up the scatter-gather list in the qcb */
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|nsgb
operator|<
name|IDA_MAX_SGLEN
operator|)
condition|)
block|{
name|int
name|bytes_this_seg
init|=
literal|0
decl_stmt|;
name|physaddr_t
name|nextphys
decl_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
name|int
name|bytes_this_page
decl_stmt|;
comment|/* This page is contiguous (physically) with the the last, */
comment|/* just extend the length */
comment|/* how far to the end of the page ... */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/* ... or to the end of the data */
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|vtophys
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* next page isn't contiguous, finish the seg */
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|nsgb
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* still data => command block too small */
name|printf
argument_list|(
literal|"ida_queue_buf%d: more than %d scatter/gather blocks needed\n"
argument_list|,
name|cntlr
argument_list|,
name|IDA_MAX_SGLEN
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fill-in the I/O request block */
name|qcbp
operator|->
name|req
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|next
operator|=
literal|0
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|blkno
operator|=
name|bp
operator|->
name|b_pblkno
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|bcount
operator|=
name|bp
operator|->
name|b_bcount
operator|>>
literal|9
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|sgcount
operator|=
name|nsgb
expr_stmt|;
name|qcbp
operator|->
name|req
operator|.
name|command
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|?
name|IDA_READ_DATA
else|:
name|IDA_WRITE_DATA
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
block|{
name|printf
argument_list|(
literal|"ida_rw%d: queuing:\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
name|ida_print_qcb
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* queue for submission to the controller */
name|ida_enqueue
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ida_start
parameter_list|(
name|int
name|cntlr
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|opri
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|ida
operator|->
name|send_next
condition|)
block|{
comment|/* check there is a job in the queue */
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|ida_pci_reg_t
modifier|*
name|reg
init|=
operator|(
name|ida_pci_reg_t
operator|*
operator|)
name|ida
operator|->
name|iobase
decl_stmt|;
name|u_int
name|fifo
init|=
name|reg
operator|->
name|initiate_fifo
decl_stmt|;
if|if
condition|(
name|fifo
operator|==
literal|1
condition|)
block|{
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
comment|/* not sent - must try again later */
block|}
comment|/* submit upto 16 jobs at once into the initiate fifo */
while|while
condition|(
name|count
operator|<
literal|16
operator|&&
operator|(
name|fifo
operator|=
name|reg
operator|->
name|initiate_fifo
operator|)
operator|!=
literal|1
operator|&&
operator|(
name|qcbp
operator|=
name|ida_dequeue
argument_list|(
name|cntlr
argument_list|)
operator|)
condition|)
block|{
name|reg
operator|->
name|initiate_fifo
operator|=
name|qcbp
operator|->
name|paddr
expr_stmt|;
name|qcbp
operator|->
name|flags
operator|=
name|QCB_SENT
expr_stmt|;
name|ida
operator|->
name|inside
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IDA_CHAN_CLEAR
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|IDA_ENABLE_CHAN
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
block|}
name|qcbp
operator|=
name|ida_dequeue
argument_list|(
name|cntlr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
name|printf
argument_list|(
literal|"ida%d: ida_start: sending 0x%x\n"
argument_list|,
name|cntlr
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IDA_SET_EBELL_I
argument_list|(
name|ida
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDA_SET_SUB_ADDR
argument_list|(
name|ida
argument_list|,
name|qcbp
operator|->
name|paddr
argument_list|)
expr_stmt|;
comment|/* physical address of this qcb */
name|IDA_SET_SUB_LEN
argument_list|(
name|ida
argument_list|,
sizeof|sizeof
argument_list|(
name|qcb_t
argument_list|)
argument_list|)
expr_stmt|;
name|IDA_SET_LBELL_I
argument_list|(
name|ida
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qcbp
operator|->
name|flags
operator|=
name|QCB_SENT
expr_stmt|;
name|ida
operator|->
name|inside
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ida
operator|->
name|inside
operator|>
name|ida
operator|->
name|max_inside
condition|)
block|{
name|ida
operator|->
name|max_inside
operator|=
name|ida
operator|->
name|inside
expr_stmt|;
comment|/* new maximum */
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_MAXQCBS
condition|)
name|printf
argument_list|(
literal|"ida%d: qcbs %d/%d\n"
argument_list|,
name|cntlr
argument_list|,
name|ida
operator|->
name|inside
argument_list|,
name|ida
operator|->
name|num_qcbs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
operator|(
name|ida_debug
operator|&
name|IDA_SHOWSUBS
operator|)
operator|&&
name|count
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"ida%d: %d jobs submitted (queue %s).\n"
argument_list|,
name|cntlr
argument_list|,
name|count
argument_list|,
name|ida
operator|->
name|send_next
condition|?
literal|"not emptied"
else|:
literal|"emptied"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ida_newqueue
parameter_list|(
name|int
name|cntlr
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|ida
operator|->
name|send_next
operator|=
literal|0
expr_stmt|;
name|ida
operator|->
name|send_last
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|qcb_t
modifier|*
name|ida_dequeue
parameter_list|(
name|int
name|cntlr
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
init|=
name|ida
operator|->
name|send_next
decl_stmt|;
comment|/* who is next? */
if|if
condition|(
name|qcbp
condition|)
block|{
comment|/* queue is not empty */
name|qcb_t
modifier|*
name|nextp
init|=
name|qcbp
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|nextp
condition|)
block|{
comment|/* more than one element in the queue */
name|nextp
operator|->
name|last
operator|=
literal|0
expr_stmt|;
comment|/* we are the first */
name|ida
operator|->
name|send_next
operator|=
name|nextp
expr_stmt|;
comment|/* hence first to go */
block|}
else|else
block|{
comment|/* exactly one element in the queue */
name|ida
operator|->
name|send_last
operator|=
name|ida
operator|->
name|send_next
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|qcbp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ida_enqueue
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|qcb_t
modifier|*
name|lastp
init|=
name|ida
operator|->
name|send_last
decl_stmt|;
comment|/* who is last? */
name|int
name|opri
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|lastp
condition|)
block|{
comment|/* if the queue is not empty */
name|lastp
operator|->
name|next
operator|=
name|qcbp
expr_stmt|;
comment|/* then we go after the last */
block|}
else|else
block|{
comment|/* if the queue was empty */
name|ida
operator|->
name|send_next
operator|=
name|qcbp
expr_stmt|;
comment|/* then we go next */
block|}
name|qcbp
operator|->
name|last
operator|=
name|lastp
expr_stmt|;
comment|/* we follow the last */
name|qcbp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* and nothing follows us */
name|ida
operator|->
name|send_last
operator|=
name|qcbp
expr_stmt|;
comment|/* we go last */
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|idaintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|cntlr
init|=
operator|(
name|int
operator|)
name|arg
decl_stmt|;
name|qcb_t
modifier|*
name|qcbp
decl_stmt|;
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|physaddr_t
name|paddr
decl_stmt|,
name|paddr1
decl_stmt|;
comment|/* physical address of the qcb */
name|int
name|offset
decl_stmt|;
comment|/* qcb offset */
name|u_char
name|cstat
decl_stmt|;
comment|/* job status */
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ida
argument_list|)
condition|)
block|{
comment|/*pci:*/
name|ida_pci_reg_t
modifier|*
name|reg
init|=
operator|(
name|ida_pci_reg_t
operator|*
operator|)
name|ida
operator|->
name|iobase
decl_stmt|;
name|int
name|status
init|=
name|reg
operator|->
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWINTS
condition|)
name|printf
argument_list|(
literal|"ida%d: idaintr: status=%x (before complete)\n"
argument_list|,
name|cntlr
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|status
operator|&
name|IDA_PCI_PENDING
condition|)
block|{
name|paddr1
operator|=
name|reg
operator|->
name|complete_fifo
expr_stmt|;
name|paddr
operator|=
name|paddr1
operator|&
operator|~
literal|3
expr_stmt|;
name|qcbp
operator|=
name|ida_qcb_phys_kv
argument_list|(
name|ida
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: idaintr: qcb(%x) completed\n"
argument_list|,
name|cntlr
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
name|ida_print_qcb
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|qcbp
condition|)
block|{
if|if
condition|(
name|qcbp
operator|->
name|req
operator|.
name|error
operator|&
literal|3
condition|)
name|ida_soft_errors
operator|++
expr_stmt|;
name|ida_done
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|,
operator|(
name|qcbp
operator|->
name|req
operator|.
name|error
operator|>>
literal|2
operator|)
condition|?
name|JOB_FAILURE
else|:
name|JOB_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ida%d: idaintr: completion (%x) ignored\n"
argument_list|,
name|cntlr
argument_list|,
name|paddr1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|reg
operator|->
name|status
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWINTS
condition|)
name|printf
argument_list|(
literal|"ida%d: idaintr: status=%x (before initiate)\n"
argument_list|,
name|cntlr
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|IDA_PCI_READY
condition|)
block|{
name|ida_start
argument_list|(
name|cntlr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|IDA_READ_EBELL_I
argument_list|(
name|ida
argument_list|)
operator|&
name|IDA_READ_EBELL_E
argument_list|(
name|ida
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWINTS
condition|)
name|printf
argument_list|(
literal|"ida%d: idaintr: status = 0x%x\n"
argument_list|,
name|cntlr
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|status
operator|&
operator|(
name|BMIC_DATA_READY
operator||
name|BMIC_CHAN_CLEAR
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|status
operator|&
name|BMIC_DATA_READY
condition|)
block|{
comment|/* data ready */
name|int
name|job_status
decl_stmt|;
if|if
condition|(
name|IDA_READ_LBELL_I
argument_list|(
name|ida
argument_list|)
operator|&
name|JOB_ABORTED
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: idaintr: status:%x local channel should be busy! "
argument_list|,
name|cntlr
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
name|paddr
operator|=
name|IDA_GET_COM_ADDR
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|offset
operator|=
name|IDA_GET_COM_OFFSET
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|cstat
operator|=
name|IDA_GET_COM_STATUS
argument_list|(
name|ida
argument_list|)
expr_stmt|;
comment|/* acknowledge interrupt */
name|IDA_ACK_CMD_COM
argument_list|(
name|ida
argument_list|)
expr_stmt|;
comment|/* determine which job completed */
name|qcbp
operator|=
name|ida_qcb_phys_kv
argument_list|(
name|ida
argument_list|,
name|paddr
argument_list|)
expr_stmt|;
comment|/* analyse the job status code */
if|if
condition|(
name|cstat
operator|&
name|IDA_COMPL_OK
condition|)
block|{
name|job_status
operator|=
name|JOB_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ida%d: idaintr: return code %x="
argument_list|,
name|cntlr
argument_list|,
name|cstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_NON_FATAL
condition|)
name|printf
argument_list|(
literal|"recoverable error! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_FATAL
condition|)
name|printf
argument_list|(
literal|"fatal error! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_ABORTED
condition|)
name|printf
argument_list|(
literal|"aborted! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_INVAL_REQ
condition|)
name|printf
argument_list|(
literal|"invalid request block! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_INVAL_LIST
condition|)
name|printf
argument_list|(
literal|"cmd list error! "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cstat
operator|&
name|IDA_AARGH_LIST
condition|)
name|printf
argument_list|(
literal|"really bad cmd list! "
argument_list|)
expr_stmt|;
name|job_status
operator|=
name|JOB_FAILURE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWQCBS
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: idaintr: qcb(%x) returned.\n"
argument_list|,
name|cntlr
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
name|ida_print_qcb
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ida_done
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|,
name|job_status
argument_list|)
expr_stmt|;
comment|/* retire the job */
name|ida_start
argument_list|(
name|cntlr
argument_list|)
expr_stmt|;
comment|/* send the controller another job */
block|}
if|if
condition|(
name|status
operator|&
name|BMIC_CHAN_CLEAR
condition|)
block|{
comment|/* channel not clear */
name|IDA_DISABLE_CHAN
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|ida_start
argument_list|(
name|cntlr
argument_list|)
expr_stmt|;
comment|/* send the controller another job */
block|}
block|}
comment|/*eisa*/
block|}
block|}
end_function

begin_function
name|int
name|ida_poll
parameter_list|(
name|cntlr
parameter_list|,
name|wait
parameter_list|)
name|int
name|cntlr
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* delay in milliseconds */
block|{
name|struct
name|ida_ctl
modifier|*
name|ctlp
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: error: ida_poll called on a PCI controller\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
while|while
condition|(
name|wait
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|IDA_DATA_READY
argument_list|(
name|ctlp
argument_list|)
condition|)
block|{
name|ctlp
operator|->
name|com_addr
operator|=
name|IDA_GET_COM_ADDR
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|com_offset
operator|=
name|IDA_GET_COM_OFFSET
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
name|ctlp
operator|->
name|com_status
operator|=
name|IDA_GET_COM_STATUS
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
name|IDA_ACK_CMD_COM
argument_list|(
name|ctlp
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
name|printf
argument_list|(
literal|"ida_poll: addr=0x%08x off=0x%04x cmdstatus=0x%02x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|ctlp
operator|->
name|com_addr
argument_list|,
name|ctlp
operator|->
name|com_offset
argument_list|,
name|ctlp
operator|->
name|com_status
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"ida%d: board not responding\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
block|}
end_function

begin_function
name|int
name|ida_submit
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|ida_pci_reg_t
modifier|*
name|reg
init|=
operator|(
name|ida_pci_reg_t
operator|*
operator|)
name|ida
operator|->
name|iobase
decl_stmt|;
name|u_int
name|fifo
init|=
name|reg
operator|->
name|initiate_fifo
decl_stmt|;
if|if
condition|(
name|fifo
operator|==
literal|1
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWSUBS
condition|)
name|printf
argument_list|(
literal|"ida%d: ida_submit(%x): fifo=1 not submitting\n"
argument_list|,
name|cntlr
argument_list|,
name|qcbp
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not sent - must try again later */
block|}
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWSUBS
condition|)
name|printf
argument_list|(
literal|"ida%d: ida_submit(%x): fifo=%d submitting\n"
argument_list|,
name|cntlr
argument_list|,
name|qcbp
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reg
operator|->
name|initiate_fifo
operator|=
name|qcbp
operator|->
name|paddr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IDA_CHAN_CLEAR
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|IDA_ENABLE_CHAN
argument_list|(
name|ida
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not sent - must try again later */
block|}
name|IDA_SET_EBELL_I
argument_list|(
name|ida
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|IDA_SET_SUB_ADDR
argument_list|(
name|ida
argument_list|,
name|qcbp
operator|->
name|paddr
argument_list|)
expr_stmt|;
comment|/* physical address of this qcb */
name|IDA_SET_SUB_LEN
argument_list|(
name|ida
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|IDA_SET_LBELL_I
argument_list|(
name|ida
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* sent */
block|}
end_function

begin_function
specifier|static
name|void
name|ida_empty_pci_complete_fifo
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|ida_pci_reg_t
modifier|*
name|reg
parameter_list|)
block|{
name|u_long
name|paddr
decl_stmt|;
if|if
condition|(
name|paddr
operator|=
name|reg
operator|->
name|complete_fifo
condition|)
block|{
name|int
name|count
init|=
literal|200
decl_stmt|;
while|while
condition|(
name|paddr
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: command completion discarded (0x%x).\n"
argument_list|,
name|cntlr
argument_list|,
operator|(
name|u_int
operator|)
name|paddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|=
name|reg
operator|->
name|complete_fifo
condition|)
block|{
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|u_long
name|ida_complete_pci_command
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|ida_pci_reg_t
modifier|*
name|reg
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
name|u_long
name|paddr
decl_stmt|;
while|while
condition|(
name|count
operator|<
literal|1000000
condition|)
block|{
if|if
condition|(
name|reg
operator|->
name|status
operator|&
name|IDA_PCI_PENDING
condition|)
block|{
if|if
condition|(
operator|(
name|paddr
operator|=
name|reg
operator|->
name|complete_fifo
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"ida%d: ida_complete_pci_command: zero address returned.\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
else|else
return|return
name|paddr
return|;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ida_submit_wait
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
if|if
condition|(
name|PCI_CONTROLLER
argument_list|(
name|ida
argument_list|)
condition|)
block|{
name|ida_pci_reg_t
modifier|*
name|reg
init|=
operator|(
name|ida_pci_reg_t
operator|*
operator|)
name|ida
operator|->
name|iobase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
init|=
literal|1000000
decl_stmt|;
name|u_long
name|paddr
decl_stmt|;
name|ida_empty_pci_complete_fifo
argument_list|(
name|cntlr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|reg
operator|->
name|interrupt
operator|=
name|IDA_PCI_DISABLE_INTS
expr_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
operator|&&
operator|(
name|i
operator|=
name|reg
operator|->
name|initiate_fifo
operator|)
operator|>
literal|16
condition|)
block|{
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: ida_pci_submit_wait: fifo failed to clear - controller has failed.\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|reg
operator|->
name|initiate_fifo
operator|=
name|qcbp
operator|->
name|paddr
expr_stmt|;
name|paddr
operator|=
name|ida_complete_pci_command
argument_list|(
name|cntlr
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: ida_pci_submit_wait timeout.  No command list returned.\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|paddr
operator|!=
name|qcbp
operator|->
name|paddr
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: ida_pci_submit_wait error. Invalid command list returned.\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|qcbp
operator|->
name|req
operator|.
name|error
operator|!=
literal|0xfe
operator|&&
name|qcbp
operator|->
name|req
operator|.
name|error
operator|==
literal|0x40
condition|)
block|{
name|printf
argument_list|(
literal|"ida%d: ida_pci_submit_wait: Job error.\n"
argument_list|,
name|cntlr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ida_submit
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|,
name|size
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ida_poll
argument_list|(
name|cntlr
argument_list|,
literal|10
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* sent */
block|}
end_function

begin_function
name|void
name|ida_done
parameter_list|(
name|int
name|cntlr
parameter_list|,
name|qcb_t
modifier|*
name|qcbp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|qcbp
operator|->
name|buf
decl_stmt|;
if|if
condition|(
name|idadata
index|[
name|cntlr
index|]
operator|>
literal|0
condition|)
name|idadata
index|[
name|cntlr
index|]
operator|->
name|inside
operator|--
expr_stmt|;
comment|/* one less job inside the controller */
if|if
condition|(
name|state
operator|!=
name|JOB_SUCCESS
condition|)
block|{
ifdef|#
directive|ifdef
name|IDADEBUG
if|if
condition|(
name|ida_debug
operator|&
name|IDA_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"ida%d: ida_done: job failed 0x%x\n"
argument_list|,
name|cntlr
argument_list|,
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* we had a problem */
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ida_drv
modifier|*
name|drv
init|=
name|id_drive
index|[
name|dkunit
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
decl_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
comment|/* Update device stats */
name|devstat_end_transaction
argument_list|(
operator|&
name|drv
operator|->
name|dk_stats
argument_list|,
name|bp
operator|->
name|b_bcount
operator|-
name|bp
operator|->
name|b_resid
argument_list|,
name|DEVSTAT_TAG_NONE
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|DEVSTAT_READ
else|:
name|DEVSTAT_WRITE
argument_list|)
expr_stmt|;
block|}
name|ida_free_qcb
argument_list|(
name|cntlr
argument_list|,
name|qcbp
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|idsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|int
name|unit
init|=
name|dkunit
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ida_drv
modifier|*
name|drv
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NID
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|drv
operator|=
name|id_drive
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|drv
operator|||
operator|!
operator|(
name|drv
operator|->
name|flags
operator|&
name|ID_INIT
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|drv
operator|->
name|slices
argument_list|,
name|idopen
argument_list|,
name|idclose
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dump all of physical memory into the partition specified, starting  * at offset 'dumplo' into the partition.  */
end_comment

begin_function
name|int
name|iddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
comment|/* dump core after a system crash */
return|return
literal|0
return|;
comment|/* XXX */
block|}
end_function

begin_expr_stmt
specifier|static
name|id_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|id_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|id_devsw_installed
condition|)
block|{
name|cdevsw_add_generic
argument_list|(
name|ID_BDMAJ
argument_list|,
name|ID_CDMAJ
argument_list|,
operator|&
name|id_cdevsw
argument_list|)
expr_stmt|;
name|id_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|iddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+ID_CDMAJ
argument_list|,
argument|id_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|IDADEBUG
end_ifdef

begin_function
name|void
name|ida_print_qcb
parameter_list|(
name|qcb_t
modifier|*
name|qcbp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"qcb(%x): drive=%x priority=%x flags=%x sgcount=%d\n"
argument_list|,
name|qcbp
argument_list|,
name|qcbp
operator|->
name|hdr
operator|.
name|drive
argument_list|,
name|qcbp
operator|->
name|hdr
operator|.
name|priority
argument_list|,
name|qcbp
operator|->
name|hdr
operator|.
name|flags
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|sgcount
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"qcb(%x): next=%x command=%x error=%x blkno=%x bcount=%x\n"
argument_list|,
name|qcbp
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|next
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|command
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|error
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|blkno
argument_list|,
name|qcbp
operator|->
name|req
operator|.
name|bcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qcbp
operator|->
name|req
operator|.
name|sgcount
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"qcb(%x): %x len=%x addr=%x\n"
argument_list|,
name|qcbp
argument_list|,
name|i
argument_list|,
name|qcbp
operator|->
name|sglist
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|qcbp
operator|->
name|sglist
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ida_print_active_qcb
parameter_list|(
name|int
name|cntlr
parameter_list|)
block|{
name|struct
name|ida_ctl
modifier|*
name|ida
init|=
name|idadata
index|[
name|cntlr
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|QCB_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|qcb_t
modifier|*
name|qcbp
init|=
name|ida
operator|->
name|hashlist
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|qcbp
condition|)
block|{
if|if
condition|(
name|qcbp
operator|->
name|flags
operator|!=
name|QCB_FREE
condition|)
block|{
name|ida_print_qcb
argument_list|(
name|qcbp
argument_list|)
expr_stmt|;
block|}
name|qcbp
operator|=
name|qcbp
operator|->
name|nexthash
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*IDADEBUG */
end_comment

end_unit

