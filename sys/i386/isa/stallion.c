begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  * stallion.c  -- stallion multiport serial driver.  *  * Copyright (c) 1995-1996 Greg Ungerer (gerg@stallion.oz.au).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Greg Ungerer.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: stallion.c,v 1.24 1999/01/12 00:36:36 eivind Exp $  */
end_comment

begin_comment
comment|/*****************************************************************************/
end_comment

begin_define
define|#
directive|define
name|TTYDEFCHARS
value|1
end_define

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/ic/scd1400.h>
end_include

begin_include
include|#
directive|include
file|<machine/comstats.h>
end_include

begin_include
include|#
directive|include
file|"pci.h"
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define the version level of the kernel - so we can compile in the  *	appropriate bits of code. By default this will compile for a 2.1  *	level kernel.  */
end_comment

begin_define
define|#
directive|define
name|VFREEBSD
value|220
end_define

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|STATIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define different board types. At the moment I have only declared  *	those boards that this driver supports. But I will use the standard  *	"assigned" board numbers. In the future this driver will support  *	some of the other Stallion boards. Currently supported boards are  *	abbreviated as EIO = EasyIO and ECH = EasyConnection 8/32.  */
end_comment

begin_define
define|#
directive|define
name|BRD_EASYIO
value|20
end_define

begin_define
define|#
directive|define
name|BRD_ECH
value|21
end_define

begin_define
define|#
directive|define
name|BRD_ECHMC
value|22
end_define

begin_define
define|#
directive|define
name|BRD_ECHPCI
value|26
end_define

begin_comment
comment|/*  *	When using the BSD "config" stuff there is no easy way to specifiy  *	a secondary IO address region. So it is hard wired here. Also the  *	shared interrupt information is hard wired here...  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|stl_ioshared
init|=
literal|0x280
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|stl_irqshared
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define important driver limitations.  */
end_comment

begin_define
define|#
directive|define
name|STL_MAXBRDS
value|8
end_define

begin_define
define|#
directive|define
name|STL_MAXPANELS
value|4
end_define

begin_define
define|#
directive|define
name|STL_PORTSPERPANEL
value|16
end_define

begin_define
define|#
directive|define
name|STL_PORTSPERBRD
value|64
end_define

begin_comment
comment|/*  *	Define the important minor number break down bits. These have been  *	chosen to be "compatable" with the standard sio driver minor numbers.  *	Extra high bits are used to distinguish between boards.  */
end_comment

begin_define
define|#
directive|define
name|STL_CALLOUTDEV
value|0x80
end_define

begin_define
define|#
directive|define
name|STL_CTRLLOCK
value|0x40
end_define

begin_define
define|#
directive|define
name|STL_CTRLINIT
value|0x20
end_define

begin_define
define|#
directive|define
name|STL_CTRLDEV
value|(STL_CTRLLOCK | STL_CTRLINIT)
end_define

begin_define
define|#
directive|define
name|STL_MEMDEV
value|0x07000000
end_define

begin_define
define|#
directive|define
name|STL_DEFSPEED
value|TTYDEF_SPEED
end_define

begin_define
define|#
directive|define
name|STL_DEFCFLAG
value|(CS8 | CREAD | HUPCL)
end_define

begin_comment
comment|/*  *	I haven't really decided (or measured) what buffer sizes give  *	a good balance between performance and memory usage. These seem  *	to work pretty well...  */
end_comment

begin_define
define|#
directive|define
name|STL_RXBUFSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|STL_TXBUFSIZE
value|2048
end_define

begin_define
define|#
directive|define
name|STL_TXBUFLOW
value|(STL_TXBUFSIZE / 4)
end_define

begin_define
define|#
directive|define
name|STL_RXBUFHIGH
value|(3 * STL_RXBUFSIZE / 4)
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define our local driver identity first. Set up stuff to deal with  *	all the local structures required by a serial tty driver.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|stl_drvname
index|[]
init|=
literal|"stl"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|stl_longdrvname
index|[]
init|=
literal|"Stallion Multiport Serial Driver"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|stl_drvversion
index|[]
init|=
literal|"1.0.0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stl_brdprobed
index|[
name|STL_MAXBRDS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stl_nrbrds
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stl_doingtimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|__file__
index|[]
init|=
comment|/*__FILE__*/
literal|"stallion.c"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Define global stats structures. Not used often, and can be  *	re-used for each stats call.  */
end_comment

begin_decl_stmt
specifier|static
name|combrd_t
name|stl_brdstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|comstats_t
name|stl_comstats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define a set of structures to hold all the board/panel/port info  *	for our ports. These will be dynamically allocated as required.  */
end_comment

begin_comment
comment|/*  *	Define a ring queue structure for each port. This will hold the  *	TX data waiting to be output. Characters are fed into this buffer  *	from the line discipline (or even direct from user space!) and  *	then fed into the UARTs during interrupts. Will use a clasic ring  *	queue here for this. The good thing about this type of ring queue  *	is that the head and tail pointers can be updated without interrupt  *	protection - since "write" code only needs to change the head, and  *	interrupt code only needs to change the tail.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|endbuf
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
block|}
name|stlrq_t
typedef|;
end_typedef

begin_comment
comment|/*  *	Port, panel and board structures to hold status info about each.  *	The board structure contains pointers to structures for each panel  *	connected to it, and in turn each panel structure contains pointers  *	for each port structure for each port on that panel. Note that  *	the port structure also contains the board and panel number that it  *	is associated with, this makes it (fairly) easy to get back to the  *	board/panel info for a port. Also note that the tty struct is at  *	the top of the structure, this is important, since the code uses  *	this fact to get the port struct pointer from the tty struct  *	pointer!  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|tty
name|tty
decl_stmt|;
name|int
name|portnr
decl_stmt|;
name|int
name|panelnr
decl_stmt|;
name|int
name|brdnr
decl_stmt|;
name|int
name|ioaddr
decl_stmt|;
name|int
name|uartaddr
decl_stmt|;
name|int
name|pagenr
decl_stmt|;
name|int
name|callout
decl_stmt|;
name|int
name|brklen
decl_stmt|;
name|int
name|dtrwait
decl_stmt|;
name|int
name|dotimestamp
decl_stmt|;
name|int
name|waitopens
decl_stmt|;
name|int
name|hotchar
decl_stmt|;
name|unsigned
name|int
name|state
decl_stmt|;
name|unsigned
name|int
name|hwid
decl_stmt|;
name|unsigned
name|int
name|sigs
decl_stmt|;
name|unsigned
name|int
name|rxignoremsk
decl_stmt|;
name|unsigned
name|int
name|rxmarkmsk
decl_stmt|;
name|unsigned
name|long
name|clk
decl_stmt|;
name|struct
name|termios
name|initintios
decl_stmt|;
name|struct
name|termios
name|initouttios
decl_stmt|;
name|struct
name|termios
name|lockintios
decl_stmt|;
name|struct
name|termios
name|lockouttios
decl_stmt|;
name|struct
name|timeval
name|timestamp
decl_stmt|;
name|comstats_t
name|stats
decl_stmt|;
name|stlrq_t
name|tx
decl_stmt|;
name|stlrq_t
name|rx
decl_stmt|;
name|stlrq_t
name|rxstatus
decl_stmt|;
block|}
name|stlport_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|panelnr
decl_stmt|;
name|int
name|brdnr
decl_stmt|;
name|int
name|pagenr
decl_stmt|;
name|int
name|nrports
decl_stmt|;
name|int
name|iobase
decl_stmt|;
name|unsigned
name|int
name|hwid
decl_stmt|;
name|unsigned
name|int
name|ackmask
decl_stmt|;
name|stlport_t
modifier|*
name|ports
index|[
name|STL_PORTSPERPANEL
index|]
decl_stmt|;
block|}
name|stlpanel_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|brdnr
decl_stmt|;
name|int
name|brdtype
decl_stmt|;
name|int
name|unitid
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|nrpanels
decl_stmt|;
name|int
name|nrports
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|irqtype
decl_stmt|;
name|unsigned
name|int
name|ioaddr1
decl_stmt|;
name|unsigned
name|int
name|ioaddr2
decl_stmt|;
name|unsigned
name|int
name|iostatus
decl_stmt|;
name|unsigned
name|int
name|ioctrl
decl_stmt|;
name|unsigned
name|int
name|ioctrlval
decl_stmt|;
name|unsigned
name|int
name|hwid
decl_stmt|;
name|unsigned
name|long
name|clk
decl_stmt|;
name|stlpanel_t
modifier|*
name|panels
index|[
name|STL_MAXPANELS
index|]
decl_stmt|;
name|stlport_t
modifier|*
name|ports
index|[
name|STL_PORTSPERBRD
index|]
decl_stmt|;
block|}
name|stlbrd_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|stlbrd_t
modifier|*
name|stl_brds
index|[
name|STL_MAXBRDS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Per board state flags. Used with the state field of the board struct.  *	Not really much here yet!  */
end_comment

begin_define
define|#
directive|define
name|BRD_FOUND
value|0x1
end_define

begin_comment
comment|/*  *	Define the port structure state flags. These set of flags are  *	modified at interrupt time - so setting and reseting them needs  *	to be atomic.  */
end_comment

begin_define
define|#
directive|define
name|ASY_TXLOW
value|0x1
end_define

begin_define
define|#
directive|define
name|ASY_RXDATA
value|0x2
end_define

begin_define
define|#
directive|define
name|ASY_DCDCHANGE
value|0x4
end_define

begin_define
define|#
directive|define
name|ASY_DTRWAIT
value|0x8
end_define

begin_define
define|#
directive|define
name|ASY_RTSFLOW
value|0x10
end_define

begin_define
define|#
directive|define
name|ASY_RTSFLOWMODE
value|0x20
end_define

begin_define
define|#
directive|define
name|ASY_CTSFLOWMODE
value|0x40
end_define

begin_define
define|#
directive|define
name|ASY_ACTIVE
value|(ASY_TXLOW | ASY_RXDATA | ASY_DCDCHANGE)
end_define

begin_comment
comment|/*  *	Define an array of board names as printable strings. Handy for  *	referencing boards when printing trace and stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|stl_brdnames
index|[]
init|=
block|{
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"EasyIO"
block|,
literal|"EC8/32-AT"
block|,
literal|"EC8/32-MC"
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
operator|(
name|char
operator|*
operator|)
name|NULL
block|,
literal|"EC8/32-PCI"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Hardware ID bits for the EasyIO and ECH boards. These defines apply  *	to the directly accessable io ports of these boards (not the cd1400  *	uarts - they are in scd1400.h).  */
end_comment

begin_define
define|#
directive|define
name|EIO_8PORTRS
value|0x04
end_define

begin_define
define|#
directive|define
name|EIO_4PORTRS
value|0x05
end_define

begin_define
define|#
directive|define
name|EIO_8PORTDI
value|0x00
end_define

begin_define
define|#
directive|define
name|EIO_8PORTM
value|0x06
end_define

begin_define
define|#
directive|define
name|EIO_IDBITMASK
value|0x07
end_define

begin_define
define|#
directive|define
name|EIO_INTRPEND
value|0x08
end_define

begin_define
define|#
directive|define
name|EIO_INTEDGE
value|0x00
end_define

begin_define
define|#
directive|define
name|EIO_INTLEVEL
value|0x08
end_define

begin_define
define|#
directive|define
name|ECH_ID
value|0xa0
end_define

begin_define
define|#
directive|define
name|ECH_IDBITMASK
value|0xe0
end_define

begin_define
define|#
directive|define
name|ECH_BRDENABLE
value|0x08
end_define

begin_define
define|#
directive|define
name|ECH_BRDDISABLE
value|0x00
end_define

begin_define
define|#
directive|define
name|ECH_INTENABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|ECH_INTDISABLE
value|0x00
end_define

begin_define
define|#
directive|define
name|ECH_INTLEVEL
value|0x02
end_define

begin_define
define|#
directive|define
name|ECH_INTEDGE
value|0x00
end_define

begin_define
define|#
directive|define
name|ECH_INTRPEND
value|0x01
end_define

begin_define
define|#
directive|define
name|ECH_BRDRESET
value|0x01
end_define

begin_define
define|#
directive|define
name|ECHMC_INTENABLE
value|0x01
end_define

begin_define
define|#
directive|define
name|ECHMC_BRDRESET
value|0x02
end_define

begin_define
define|#
directive|define
name|ECH_PNLSTATUS
value|2
end_define

begin_define
define|#
directive|define
name|ECH_PNL16PORT
value|0x20
end_define

begin_define
define|#
directive|define
name|ECH_PNLIDMASK
value|0x07
end_define

begin_define
define|#
directive|define
name|ECH_PNLINTRPEND
value|0x80
end_define

begin_define
define|#
directive|define
name|ECH_ADDR2MASK
value|0x1e0
end_define

begin_define
define|#
directive|define
name|EIO_CLK
value|25000000
end_define

begin_define
define|#
directive|define
name|EIO_CLK8M
value|20000000
end_define

begin_define
define|#
directive|define
name|ECH_CLK
value|EIO_CLK
end_define

begin_comment
comment|/*  *	Define the offsets within the register bank for all io registers.  *	These io address offsets are common to both the EIO and ECH.  */
end_comment

begin_define
define|#
directive|define
name|EREG_ADDR
value|0
end_define

begin_define
define|#
directive|define
name|EREG_DATA
value|4
end_define

begin_define
define|#
directive|define
name|EREG_RXACK
value|5
end_define

begin_define
define|#
directive|define
name|EREG_TXACK
value|6
end_define

begin_define
define|#
directive|define
name|EREG_MDACK
value|7
end_define

begin_define
define|#
directive|define
name|EREG_BANKSIZE
value|8
end_define

begin_comment
comment|/*  *	Define the PCI vendor and device id for ECH8/32-PCI.  */
end_comment

begin_define
define|#
directive|define
name|STL_PCIDEVID
value|0xd001100b
end_define

begin_comment
comment|/*  *	Define the vector mapping bits for the programmable interrupt board  *	hardware. These bits encode the interrupt for the board to use - it  *	is software selectable (except the EIO-8M).  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|stl_vecmap
index|[]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x04
block|,
literal|0x06
block|,
literal|0x05
block|,
literal|0xff
block|,
literal|0x07
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x00
block|,
literal|0x02
block|,
literal|0x01
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0x03
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	Set up enable and disable macros for the ECH boards. They require  *	the secondary io address space to be activated and deactivated.  *	This way all ECH boards can share their secondary io region.  *	If this is an ECH-PCI board then also need to set the page pointer  *	to point to the correct page.  */
end_comment

begin_define
define|#
directive|define
name|BRDENABLE
parameter_list|(
name|brdnr
parameter_list|,
name|pagenr
parameter_list|)
define|\
value|if (stl_brds[(brdnr)]->brdtype == BRD_ECH)			\ 		outb(stl_brds[(brdnr)]->ioctrl,				\ 			(stl_brds[(brdnr)]->ioctrlval | ECH_BRDENABLE));\ 	else if (stl_brds[(brdnr)]->brdtype == BRD_ECHPCI)		\ 		outb(stl_brds[(brdnr)]->ioctrl, (pagenr));
end_define

begin_define
define|#
directive|define
name|BRDDISABLE
parameter_list|(
name|brdnr
parameter_list|)
define|\
value|if (stl_brds[(brdnr)]->brdtype == BRD_ECH)			\ 		outb(stl_brds[(brdnr)]->ioctrl,				\ 			(stl_brds[(brdnr)]->ioctrlval | ECH_BRDDISABLE));
end_define

begin_comment
comment|/*  *	Define the cd1400 baud rate clocks. These are used when calculating  *	what clock and divisor to use for the required baud rate. Also  *	define the maximum baud rate allowed, and the default base baud.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stl_cd1400clkdivs
index|[]
init|=
block|{
name|CD1400_CLK0
block|,
name|CD1400_CLK1
block|,
name|CD1400_CLK2
block|,
name|CD1400_CLK3
block|,
name|CD1400_CLK4
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STL_MAXBAUD
value|230400
end_define

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Define macros to extract a brd and port number from a minor number.  *	This uses the extended minor number range in the upper 2 bytes of  *	the device number. This gives us plenty of minor numbers to play  *	with...  */
end_comment

begin_define
define|#
directive|define
name|MKDEV2BRD
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0x00700000)>> 20)
end_define

begin_define
define|#
directive|define
name|MKDEV2PORT
parameter_list|(
name|m
parameter_list|)
value|(((m)& 0x1f) | (((m)& 0x00010000)>> 11))
end_define

begin_comment
comment|/*  *	Define some handy local macros...  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<= (b)) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Declare all those functions in this driver!  First up is the set of  *	externally visible functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|stlprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stlattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|STATIC
name|d_open_t
name|stlopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_close_t
name|stlclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_read_t
name|stlread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_write_t
name|stlwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_ioctl_t
name|stlioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|d_stop_t
name|stlstop
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_decl_stmt
name|STATIC
name|d_devtotty_t
name|stldevtotty
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_function_decl
name|struct
name|tty
modifier|*
name|stldevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Internal function prototypes.  */
end_comment

begin_function_decl
specifier|static
name|stlport_t
modifier|*
name|stl_dev2port
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_findfreeunit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_rawopen
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_rawclose
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_ttyoptim
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_dotimeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_rxprocess
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_dtrwakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_brdinit
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_initeio
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_initech
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_initports
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|,
name|stlpanel_t
modifier|*
name|panelp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ointhand2_t
name|stlintr
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|stl_txisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|stl_rxisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|stl_mdmisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_setreg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_getreg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_updatereg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_getsignals
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_setsignals
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|dtr
parameter_list|,
name|int
name|rts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_flowcontrol
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|hw
parameter_list|,
name|int
name|sw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_ccrwait
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_enablerxtx
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_startrxtx
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_disableintrs
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_sendbreak
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|long
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stl_flush
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_memioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_getbrdstats
parameter_list|(
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_getportstats
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stl_clrportstats
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|stlport_t
modifier|*
name|stl_getport
parameter_list|(
name|int
name|brdnr
parameter_list|,
name|int
name|panelnr
parameter_list|,
name|int
name|portnr
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|stlpciprobe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stlpciattach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stlpciintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Declare the driver isa structure.  */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|stldriver
init|=
block|{
name|stlprobe
block|,
name|stlattach
block|,
literal|"stl"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*  *	Declare the driver pci structure.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|stl_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_device
name|stlpcidriver
init|=
block|{
literal|"stl"
block|,
name|stlpciprobe
block|,
name|stlpciattach
block|,
operator|&
name|stl_count
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DATA_SET
argument_list|(
name|pcidevice_set
argument_list|,
name|stlpcidriver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_comment
comment|/*  *	FreeBSD-2.2+ kernel linkage.  */
end_comment

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|72
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|stl_cdevsw
init|=
block|{
name|stlopen
block|,
name|stlclose
block|,
name|stlread
block|,
name|stlwrite
block|,
name|stlioctl
block|,
name|stlstop
block|,
name|noreset
block|,
name|stldevtotty
block|,
name|ttpoll
block|,
name|nommap
block|,
name|NULL
block|,
literal|"stl"
block|,
name|NULL
block|,
operator|-
literal|1
block|,
name|nodump
block|,
name|nopsize
block|,
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|stl_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|stl_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|stl_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|stl_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|stl_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|sidev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|stl_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Probe for some type of EasyIO or EasyConnection 8/32 board at  *	the supplied address. All we do is check if we can find the  *	board ID for the board... (Note, PCI boards not checked here,  *	they are done in the stlpciprobe() routine).  */
end_comment

begin_function
specifier|static
name|int
name|stlprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|unsigned
name|int
name|status
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlprobe(idp=%x): unit=%d iobase=%x\n"
argument_list|,
operator|(
name|int
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|idp
operator|->
name|id_unit
operator|>
name|STL_MAXBRDS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|status
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ECH_IDBITMASK
operator|)
operator|==
name|ECH_ID
condition|)
block|{
name|stl_brdprobed
index|[
name|idp
operator|->
name|id_unit
index|]
operator|=
name|BRD_ECH
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|status
operator|=
name|inb
argument_list|(
name|idp
operator|->
name|id_iobase
operator|+
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|EIO_IDBITMASK
condition|)
block|{
case|case
name|EIO_8PORTRS
case|:
case|case
name|EIO_8PORTM
case|:
case|case
name|EIO_8PORTDI
case|:
case|case
name|EIO_4PORTRS
case|:
name|stl_brdprobed
index|[
name|idp
operator|->
name|id_unit
index|]
operator|=
name|BRD_EASYIO
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Find an available internal board number (unit number). The problem  *	is that the same unit numbers can be assigned to different boards  *	detected during the ISA and PCI initialization phases.  */
end_comment

begin_function
specifier|static
name|int
name|stl_findfreeunit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|STL_MAXBRDS
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|stl_brds
index|[
name|i
index|]
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
break|break;
return|return
operator|(
operator|(
name|i
operator|>=
name|STL_MAXBRDS
operator|)
condition|?
operator|-
literal|1
else|:
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Allocate resources for and initialize the specified board.  */
end_comment

begin_function
specifier|static
name|int
name|stlattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|idp
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlattach(idp=%p): unit=%d iobase=%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|idp
argument_list|,
name|idp
operator|->
name|id_unit
argument_list|,
name|idp
operator|->
name|id_iobase
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|idp
operator|->
name|id_ointr
operator|=
name|stlintr
expr_stmt|;
name|brdp
operator|=
operator|(
name|stlbrd_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate memory (size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
name|brdp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|brdnr
operator|=
name|stl_findfreeunit
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: too many boards found, max=%d\n"
argument_list|,
name|STL_MAXBRDS
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|brdp
operator|->
name|brdnr
operator|>=
name|stl_nrbrds
condition|)
name|stl_nrbrds
operator|=
name|brdp
operator|->
name|brdnr
operator|+
literal|1
expr_stmt|;
name|brdp
operator|->
name|unitid
operator|=
name|idp
operator|->
name|id_unit
expr_stmt|;
name|brdp
operator|->
name|brdtype
operator|=
name|stl_brdprobed
index|[
name|idp
operator|->
name|id_unit
index|]
expr_stmt|;
name|brdp
operator|->
name|ioaddr1
operator|=
name|idp
operator|->
name|id_iobase
expr_stmt|;
name|brdp
operator|->
name|ioaddr2
operator|=
name|stl_ioshared
expr_stmt|;
name|brdp
operator|->
name|irq
operator|=
name|ffs
argument_list|(
name|idp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
name|brdp
operator|->
name|irqtype
operator|=
name|stl_irqshared
expr_stmt|;
name|stl_brdinit
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*  *	Probe specifically for the PCI boards. We need to be a little  *	carefull here, since it looks sort like a Nat Semi IDE chip...  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|stlpciprobe
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|pcidi_t
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|class
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlpciprobe(tag=%x,type=%x)\n"
argument_list|,
operator|(
name|int
operator|)
operator|&
name|tag
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STL_PCIDEVID
case|:
break|break;
default|default:
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
name|class
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_CLASS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|class
operator|&
name|PCI_CLASS_MASK
operator|)
operator|==
name|PCI_CLASS_MASS_STORAGE
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
literal|"Stallion EasyConnection 8/32-PCI"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Allocate resources for and initialize the specified PCI board.  */
end_comment

begin_function
name|void
name|stlpciattach
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlpciattach(tag=%x,unit=%x)\n"
argument_list|,
operator|(
name|int
operator|)
operator|&
name|tag
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdp
operator|=
operator|(
name|stlbrd_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate memory (size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|brdp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlbrd_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|<
literal|0
operator|)
operator|||
operator|(
name|unit
operator|>
name|STL_MAXBRDS
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: bad PCI board unit number=%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  *	Allocate us a new driver unique unit number.  */
if|if
condition|(
operator|(
name|brdp
operator|->
name|brdnr
operator|=
name|stl_findfreeunit
argument_list|()
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: too many boards found, max=%d\n"
argument_list|,
name|STL_MAXBRDS
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|brdp
operator|->
name|brdnr
operator|>=
name|stl_nrbrds
condition|)
name|stl_nrbrds
operator|=
name|brdp
operator|->
name|brdnr
operator|+
literal|1
expr_stmt|;
name|brdp
operator|->
name|unitid
operator|=
literal|0
expr_stmt|;
name|brdp
operator|->
name|brdtype
operator|=
name|BRD_ECHPCI
expr_stmt|;
name|brdp
operator|->
name|ioaddr1
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x14
argument_list|)
operator|)
operator|&
literal|0xfffc
expr_stmt|;
name|brdp
operator|->
name|ioaddr2
operator|=
operator|(
operator|(
name|unsigned
name|int
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x10
argument_list|)
operator|)
operator|&
literal|0xfffc
expr_stmt|;
name|brdp
operator|->
name|irq
operator|=
operator|(
operator|(
name|int
operator|)
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
literal|0x3c
argument_list|)
operator|)
operator|&
literal|0xff
expr_stmt|;
name|brdp
operator|->
name|irqtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_map_int
argument_list|(
name|tag
argument_list|,
name|stlpciintr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|tty_imask
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to map interrupt irq=%d for unit=%d\n"
argument_list|,
name|brdp
operator|->
name|irq
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
literal|0
block|printf("%s(%d): ECH-PCI iobase=%x iopage=%x irq=%d\n", __file__,			 __LINE__, brdp->ioaddr2, brdp->ioaddr1, brdp->irq);
endif|#
directive|endif
name|stl_brdinit
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stlopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|callout
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlopen(dev=%x,flag=%x,mode=%x,p=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|dev
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
operator|(
name|int
operator|)
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Firstly check if the supplied device number is a valid device.  */
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|portp
operator|=
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|callout
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
operator|&
name|STL_CALLOUTDEV
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|stlopen_restart
label|:
comment|/*  *	Wait here for the DTR drop timeout period to expire.  */
while|while
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_DTRWAIT
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|dtrwait
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stldtr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stlopen_end
goto|;
block|}
comment|/*  *	We have a valid device, so now we check if it is already open.  *	If not then initialize the port hardware and set up the tty  *	struct as required.  */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_oproc
operator|=
name|stl_start
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|stl_param
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|=
name|callout
condition|?
name|portp
operator|->
name|initouttios
else|:
name|portp
operator|->
name|initintios
expr_stmt|;
name|stl_rawopen
argument_list|(
name|portp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|portp
operator|->
name|sigs
operator|&
name|TIOCM_CD
operator|)
operator|||
name|callout
condition|)
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|callout
condition|)
block|{
if|if
condition|(
name|portp
operator|->
name|callout
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stlopen_end
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|portp
operator|->
name|callout
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stlopen_end
goto|;
block|}
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|portp
operator|->
name|callout
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stlcall"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stlopen_end
goto|;
goto|goto
name|stlopen_restart
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|)
operator|&&
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|stlopen_end
goto|;
block|}
block|}
comment|/*  *	If this port is not the callout device and we do not have carrier  *	then we need to sleep, waiting for it to be asserted.  */
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
name|callout
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flag
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|portp
operator|->
name|waitopens
operator|++
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|,
operator|(
name|TTIPRI
operator||
name|PCATCH
operator|)
argument_list|,
literal|"stldcd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|portp
operator|->
name|waitopens
operator|--
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|stlopen_end
goto|;
goto|goto
name|stlopen_restart
goto|;
block|}
comment|/*  *	Open the line discipline.  */
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
expr_stmt|;
name|stl_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|&&
name|callout
condition|)
name|portp
operator|->
name|callout
operator|=
literal|1
expr_stmt|;
comment|/*  *	If for any reason we get to here and the port is not actually  *	open then close of the physical hardware - no point leaving it  *	active when the open failed...  */
name|stlopen_end
label|:
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|portp
operator|->
name|waitopens
operator|==
literal|0
operator|)
condition|)
name|stl_rawclose
argument_list|(
name|portp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stlclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlclose(dev=%lx,flag=%x,mode=%x,p=%p)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|,
name|flag
argument_list|,
name|mode
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|portp
operator|=
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
name|tp
operator|,
name|flag
operator|)
expr_stmt|;
name|stl_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|stl_rawclose
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|ttyclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stlread
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlread(dev=%lx,uiop=%p,flag=%x)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uiop
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|portp
operator|=
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|portp
operator|->
name|tty
operator|.
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
operator|&
name|portp
operator|->
name|tty
operator|,
name|uiop
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|VFREEBSD
operator|>=
literal|220
end_if

begin_function
name|STATIC
name|void
name|stlstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlstop(tp=%x,rw=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stl_flush
argument_list|(
operator|(
name|stlport_t
operator|*
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|STATIC
name|int
name|stlstop
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlstop(tp=%x,rw=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stl_flush
argument_list|(
operator|(
name|stlport_t
operator|*
operator|)
name|tp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|struct
name|tty
modifier|*
name|stldevtotty
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stldevtotty(dev=%x)\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
expr|struct
name|tty
operator|*
operator|)
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stlwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uiop
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlwrite(dev=%lx,uiop=%p,flag=%x)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uiop
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|portp
operator|=
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|portp
operator|->
name|tty
operator|.
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
operator|&
name|portp
operator|->
name|tty
operator|,
name|uiop
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
name|STATIC
name|int
name|stlioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|termios
modifier|*
name|newtios
decl_stmt|,
modifier|*
name|localtios
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlioctl(dev=%lx,cmd=%lx,data=%p,flag=%x,p=%p)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|,
name|cmd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
name|flag
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dev
operator|=
name|minor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|&
name|STL_MEMDEV
condition|)
return|return
operator|(
name|stl_memioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|p
argument_list|)
operator|)
return|;
name|portp
operator|=
name|stl_dev2port
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/*  *	First up handle ioctls on the control devices.  */
if|if
condition|(
name|dev
operator|&
name|STL_CTRLDEV
condition|)
block|{
if|if
condition|(
operator|(
name|dev
operator|&
name|STL_CTRLDEV
operator|)
operator|==
name|STL_CTRLINIT
condition|)
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|initouttios
else|:
operator|&
name|portp
operator|->
name|initintios
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dev
operator|&
name|STL_CTRLDEV
operator|)
operator|==
name|STL_CTRLLOCK
condition|)
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|lockouttios
else|:
operator|&
name|portp
operator|->
name|lockintios
expr_stmt|;
else|else
return|return
operator|(
name|ENODEV
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSETA
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|*
name|localtios
operator|=
operator|*
operator|(
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|TIOCGETA
case|:
operator|*
operator|(
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|)
operator|=
operator|*
name|localtios
expr_stmt|;
break|break;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|TTYDISC
expr_stmt|;
break|break;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  *	Deal with 4.3 compatability issues if we have too...  */
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
if|if
condition|(
literal|1
condition|)
block|{
name|struct
name|termios
name|tios
decl_stmt|;
name|unsigned
name|long
name|oldcmd
decl_stmt|;
name|tios
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
name|oldcmd
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|cmd
argument_list|,
name|data
argument_list|,
operator|&
name|tios
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|!=
name|oldcmd
condition|)
name|data
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|tios
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  *	Carry out some pre-cmd processing work first...  *	Hmmm, not so sure we want this, disable for now...  */
if|if
condition|(
operator|(
name|cmd
operator|==
name|TIOCSETA
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAW
operator|)
operator|||
operator|(
name|cmd
operator|==
name|TIOCSETAF
operator|)
condition|)
block|{
name|newtios
operator|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
name|localtios
operator|=
operator|(
name|dev
operator|&
name|STL_CALLOUTDEV
operator|)
condition|?
operator|&
name|portp
operator|->
name|lockouttios
else|:
operator|&
name|portp
operator|->
name|lockintios
expr_stmt|;
name|newtios
operator|->
name|c_iflag
operator|=
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|localtios
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_iflag
operator|&
operator|~
name|localtios
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_oflag
operator|=
operator|(
name|tp
operator|->
name|t_oflag
operator|&
name|localtios
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_oflag
operator|&
operator|~
name|localtios
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_cflag
operator|=
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|localtios
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_cflag
operator|&
operator|~
name|localtios
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|newtios
operator|->
name|c_lflag
operator|=
operator|(
name|tp
operator|->
name|t_lflag
operator|&
name|localtios
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|newtios
operator|->
name|c_lflag
operator|&
operator|~
name|localtios
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|NCCS
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|localtios
operator|->
name|c_cc
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_cc
index|[
name|i
index|]
operator|=
name|tp
operator|->
name|t_cc
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|localtios
operator|->
name|c_ispeed
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
name|localtios
operator|->
name|c_ospeed
operator|!=
literal|0
condition|)
name|newtios
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
block|}
comment|/*  *	Call the line discipline and the common command processing to  *	process this command (if they can).  */
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|,
name|p
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|stl_ttyoptim
argument_list|(
name|portp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/*  *	Process local commands here. These are all commands that only we  *	can take care of (they all rely on actually doing something special  *	to the actual hardware).  */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCSBRK
case|:
name|stl_sendbreak
argument_list|(
name|portp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCBRK
case|:
name|stl_sendbreak
argument_list|(
name|portp
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCSDTR
case|:
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCCDTR
case|:
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMSET
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIS
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMBIC
case|:
name|i
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_DTR
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
argument_list|,
operator|(
operator|(
name|i
operator|&
name|TIOCM_RTS
operator|)
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TIOCMGET
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
operator|(
name|stl_getsignals
argument_list|(
name|portp
argument_list|)
operator||
name|TIOCM_LE
operator|)
expr_stmt|;
break|break;
case|case
name|TIOCMSDTRWAIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|portp
operator|->
name|dtrwait
operator|=
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|*
name|hz
operator|/
literal|100
expr_stmt|;
break|break;
case|case
name|TIOCMGDTRWAIT
case|:
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|=
name|portp
operator|->
name|dtrwait
operator|*
literal|100
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|TIOCTIMESTAMP
case|:
name|portp
operator|->
name|dotimestamp
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|data
operator|)
operator|=
name|portp
operator|->
name|timestamp
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Convert the specified minor device number into a port struct  *	pointer. Return NULL if the device number is not a valid port.  */
end_comment

begin_function
name|STATIC
name|stlport_t
modifier|*
name|stl_dev2port
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|brdp
operator|=
name|stl_brds
index|[
name|MKDEV2BRD
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|brdp
operator|->
name|ports
index|[
name|MKDEV2PORT
argument_list|(
name|dev
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Initialize the port hardware. This involves enabling the transmitter  *	and receiver, setting the port configuration, and setting the initial  *	signal state.  */
end_comment

begin_function
specifier|static
name|int
name|stl_rawopen
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_rawopen(portp=%p): brdnr=%d panelnr=%d portnr=%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|portp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|panelnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stl_param
argument_list|(
operator|&
name|portp
operator|->
name|tty
argument_list|,
operator|&
name|portp
operator|->
name|tty
operator|.
name|t_termios
argument_list|)
expr_stmt|;
name|portp
operator|->
name|sigs
operator|=
name|stl_getsignals
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stl_enablerxtx
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stl_startrxtx
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Shutdown the hardware of a port. Disable its transmitter and  *	receiver, and maybe drop signals if appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|stl_rawclose
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_rawclose(portp=%p): brdnr=%d panelnr=%d portnr=%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|portp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|panelnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|stl_disableintrs
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|stl_enablerxtx
argument_list|(
name|portp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stl_flush
argument_list|(
name|portp
argument_list|,
operator|(
name|FWRITE
operator||
name|FREAD
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_cflag
operator|&
name|HUPCL
condition|)
block|{
name|stl_setsignals
argument_list|(
name|portp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|dtrwait
operator|!=
literal|0
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ASY_DTRWAIT
expr_stmt|;
name|timeout
argument_list|(
name|stl_dtrwakeup
argument_list|,
name|portp
argument_list|,
name|portp
operator|->
name|dtrwait
argument_list|)
expr_stmt|;
block|}
block|}
name|portp
operator|->
name|callout
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|brklen
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
operator|(
name|ASY_ACTIVE
operator||
name|ASY_RTSFLOW
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|callout
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|TSA_CARR_ON
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Clear the DTR waiting flag, and wake up any sleepers waiting for  *	DTR wait period to finish.  */
end_comment

begin_function
specifier|static
name|void
name|stl_dtrwakeup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|portp
operator|=
operator|(
name|stlport_t
operator|*
operator|)
name|arg
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ASY_DTRWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|portp
operator|->
name|dtrwait
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Start (or continue) the transfer of TX data on this port. If the  *	port is not currently busy then load up the interrupt ring queue  *	buffer and kick of the transmitter. If the port is running low on  *	TX data then refill the ring queue. This routine is also used to  *	activate input flow control!  */
end_comment

begin_function
specifier|static
name|void
name|stl_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|stlen
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|int
name|count
decl_stmt|,
name|x
decl_stmt|;
name|portp
operator|=
operator|(
name|stlport_t
operator|*
operator|)
name|tp
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_start(tp=%x): brdnr=%d portnr=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/*  *	Check if the ports input has been blocked, and take appropriate action.  *	Not very often do we really need to do anything, so make it quick.  */
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
condition|)
block|{
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
operator|)
operator|==
literal|0
condition|)
name|stl_flowcontrol
argument_list|(
name|portp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
condition|)
name|stl_flowcontrol
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|VFREEBSD
operator|==
literal|205
comment|/*  *	Check if the output cooked clist buffers are near empty, wake up  *	the line discipline to fill it up.  */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_wsel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_TTSTOP
operator|)
condition|)
block|{
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  *	Copy data from the clists into the interrupt ring queue. This will  *	require at most 2 copys... What we do is calculate how many chars  *	can fit into the ring queue, and how many can fit in 1 copy. If after  *	the first copy there is still more room then do the second copy.   *	The beauty of this type of ring queue is that we do not need to  *	spl protect our-selves, since we only ever update the head pointer,  *	and the interrupt routine only ever updates the tail pointer.  */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
name|head
operator|=
name|portp
operator|->
name|tx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|len
operator|=
name|STL_TXBUFSIZE
operator|-
operator|(
name|head
operator|-
name|tail
operator|)
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|portp
operator|->
name|tx
operator|.
name|endbuf
operator|-
name|head
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|stlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|count
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|head
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|head
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|portp
operator|->
name|tx
operator|.
name|endbuf
condition|)
block|{
name|head
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|stlen
operator|=
name|q_to_b
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|head
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|head
operator|+=
name|stlen
expr_stmt|;
name|count
operator|+=
name|stlen
expr_stmt|;
block|}
block|}
name|portp
operator|->
name|tx
operator|.
name|head
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
name|stl_startrxtx
argument_list|(
name|portp
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*  *		If we sent something, make sure we are called again.  */
name|tp
operator|->
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
block|}
if|#
directive|if
name|VFREEBSD
operator|!=
literal|205
comment|/*  *	Do any writer wakeups.  */
name|ttwwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stl_flush
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|int
name|len
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_flush(portp=%x,flag=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
block|{
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
name|stl_ccrwait
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CCR
argument_list|,
name|CCR_TXFLUSHFIFO
argument_list|)
expr_stmt|;
name|stl_ccrwait
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|portp
operator|->
name|tx
operator|.
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|head
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
block|}
comment|/*  *	The only thing to watch out for when flushing the read side is  *	the RX status buffer. The interrupt code relys on the status  *	bytes as being zeroed all the time (it does not bother setting  *	a good char status to 0, it expects that it already will be).  *	We also need to un-flow the RX channel if flow control was  *	active.  */
if|if
condition|(
name|flag
operator|&
name|FREAD
condition|)
block|{
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|tail
condition|)
block|{
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|len
operator|=
name|head
operator|-
name|tail
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|portp
operator|->
name|rx
operator|.
name|endbuf
operator|-
name|tail
expr_stmt|;
name|bzero
argument_list|(
name|portp
operator|->
name|rxstatus
operator|.
name|buf
argument_list|,
operator|(
name|head
operator|-
name|portp
operator|->
name|rx
operator|.
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|tail
operator|+
name|STL_RXBUFSIZE
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|tail
operator|=
name|head
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
operator|)
operator|&&
operator|(
operator|(
name|portp
operator|->
name|tty
operator|.
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
name|stl_flowcontrol
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	These functions get/set/update the registers of the cd1400 UARTs.  *	Access to the cd1400 registers is via an address/data io port pair.  *	(Maybe should make this inline...)  */
end_comment

begin_function
specifier|static
name|int
name|stl_getreg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|)
block|{
name|outb
argument_list|(
name|portp
operator|->
name|ioaddr
argument_list|,
operator|(
name|regnr
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|inb
argument_list|(
name|portp
operator|->
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stl_setreg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|outb
argument_list|(
name|portp
operator|->
name|ioaddr
argument_list|,
operator|(
name|regnr
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|portp
operator|->
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|stl_updatereg
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|regnr
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|outb
argument_list|(
name|portp
operator|->
name|ioaddr
argument_list|,
operator|(
name|regnr
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|portp
operator|->
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
operator|!=
name|value
condition|)
block|{
name|outb
argument_list|(
operator|(
name|portp
operator|->
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Wait for the command register to be ready. We will poll this, since  *	it won't usually take too long to be ready, and it is only really  *	used for non-critical actions.  */
end_comment

begin_function
specifier|static
name|void
name|stl_ccrwait
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|CCR_MAXWAIT
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|CCR
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
name|printf
argument_list|(
literal|"STALLION: cd1400 device not responding, brd=%d panel=%d"
literal|"port=%d\n"
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|panelnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Transmit interrupt handler. This has gotta be fast!  Handling TX  *	chars is pretty simple, stuff as many as possible from the TX buffer  *	into the cd1400 FIFO. Must also handle TX breaks here, since they  *	are embedded as commands in the data stream. Oh no, had to use a goto!  *	This could be optimized more, will do when I get time...  *	In practice it is possible that interrupts are enabled but that the  *	port has been hung up. Need to handle not having any TX buffer here,  *	this is done by using the side effect that head and tail will also  *	be NULL if the buffer has been freed.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|stl_txisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|stlen
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|unsigned
name|char
name|ioack
decl_stmt|,
name|srer
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_txisr(panelp=%x,ioaddr=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|panelp
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioack
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_TXACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ioack
operator|&
name|panelp
operator|->
name|ackmask
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|ioack
operator|&
name|ACK_TYPMASK
operator|)
operator|!=
name|ACK_TYPTX
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: bad TX interrupt ack value=%x\n"
argument_list|,
name|ioack
argument_list|)
expr_stmt|;
return|return;
block|}
name|portp
operator|=
name|panelp
operator|->
name|ports
index|[
operator|(
name|ioack
operator|>>
literal|3
operator|)
index|]
expr_stmt|;
comment|/*  *	Unfortunately we need to handle breaks in the data stream, since  *	this is the only way to generate them on the cd1400. Do it now if  *	a break is to be sent. Some special cases here: brklen is -1 then  *	start sending an un-timed break, if brklen is -2 then stop sending  *	an un-timed break, if brklen is -3 then we have just sent an  *	un-timed break and do not want any data to go out, if brklen is -4  *	then a break has just completed so clean up the port settings.  */
if|if
condition|(
name|portp
operator|->
name|brklen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|portp
operator|->
name|brklen
operator|>=
operator|-
literal|1
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|TDR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_CMD
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_STARTBREAK
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|brklen
operator|>
literal|0
condition|)
block|{
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_CMD
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_DELAY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|portp
operator|->
name|brklen
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_CMD
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_STOPBREAK
argument_list|)
expr_stmt|;
name|portp
operator|->
name|brklen
operator|=
operator|-
literal|4
expr_stmt|;
block|}
else|else
block|{
name|portp
operator|->
name|brklen
operator|=
operator|-
literal|3
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|portp
operator|->
name|brklen
operator|==
operator|-
literal|2
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|TDR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_CMD
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|ETC_STOPBREAK
argument_list|)
expr_stmt|;
name|portp
operator|->
name|brklen
operator|=
operator|-
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|portp
operator|->
name|brklen
operator|==
operator|-
literal|3
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|SRER
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|srer
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
name|srer
operator|&=
operator|~
operator|(
name|SRER_TXDATA
operator||
name|SRER_TXEMPTY
operator|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|srer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|COR2
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
operator|(
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
operator|&
operator|~
name|COR2_ETC
operator|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|brklen
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|stl_txalldone
goto|;
block|}
name|head
operator|=
name|portp
operator|->
name|tx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|tail
expr_stmt|;
name|len
operator|=
operator|(
name|head
operator|>=
name|tail
operator|)
condition|?
operator|(
name|head
operator|-
name|tail
operator|)
else|:
operator|(
name|STL_TXBUFSIZE
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|len
operator|<
name|STL_TXBUFLOW
operator|)
operator|&&
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_TXLOW
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ASY_TXLOW
expr_stmt|;
name|stl_dotimeout
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|SRER
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|srer
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|srer
operator|&
name|SRER_TXDATA
condition|)
block|{
name|srer
operator|=
operator|(
name|srer
operator|&
operator|~
name|SRER_TXDATA
operator|)
operator||
name|SRER_TXEMPTY
expr_stmt|;
block|}
else|else
block|{
name|srer
operator|&=
operator|~
operator|(
name|SRER_TXDATA
operator||
name|SRER_TXEMPTY
operator|)
expr_stmt|;
name|portp
operator|->
name|tty
operator|.
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
block|}
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|srer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|CD1400_TXFIFOSIZE
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|txtotal
operator|+=
name|len
expr_stmt|;
name|stlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
operator|(
name|portp
operator|->
name|tx
operator|.
name|endbuf
operator|-
name|tail
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|TDR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|tail
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|len
operator|-=
name|stlen
expr_stmt|;
name|tail
operator|+=
name|stlen
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|portp
operator|->
name|tx
operator|.
name|endbuf
condition|)
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|outsb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|tail
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tail
operator|+=
name|len
expr_stmt|;
block|}
name|portp
operator|->
name|tx
operator|.
name|tail
operator|=
name|tail
expr_stmt|;
block|}
name|stl_txalldone
label|:
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|EOSRR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Receive character interrupt handler. Determine if we have good chars  *	or bad chars and then process appropriately. Good chars are easy  *	just shove the lot into the RX buffer and set all status bytes to 0.  *	If a bad RX char then process as required. This routine needs to be  *	fast!  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|stl_rxisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|ioack
decl_stmt|,
name|len
decl_stmt|,
name|buflen
decl_stmt|,
name|stlen
decl_stmt|;
name|unsigned
name|char
name|status
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
specifier|static
name|char
name|unwanted
index|[
name|CD1400_RXFIFOSIZE
index|]
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_rxisr(panelp=%x,ioaddr=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|panelp
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioack
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_RXACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ioack
operator|&
name|panelp
operator|->
name|ackmask
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: bad RX interrupt ack value=%x\n"
argument_list|,
name|ioack
argument_list|)
expr_stmt|;
return|return;
block|}
name|portp
operator|=
name|panelp
operator|->
name|ports
index|[
operator|(
name|ioack
operator|>>
literal|3
operator|)
index|]
expr_stmt|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
comment|/*  *	First up, caluclate how much room there is in the RX ring queue.  *	We also want to keep track of the longest possible copy length,  *	this has to allow for the wrapping of the ring queue.  */
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|buflen
operator|=
name|STL_RXBUFSIZE
operator|-
operator|(
name|head
operator|-
name|tail
operator|)
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|portp
operator|->
name|rx
operator|.
name|endbuf
operator|-
name|head
expr_stmt|;
block|}
else|else
block|{
name|buflen
operator|=
name|tail
operator|-
name|head
operator|-
literal|1
expr_stmt|;
name|stlen
operator|=
name|buflen
expr_stmt|;
block|}
comment|/*  *	Check if the input buffer is near full. If so then we should take  *	some flow control action... It is very easy to do hardware and  *	software flow control from here since we have the port selected on  *	the UART.  */
if|if
condition|(
name|buflen
operator|<=
operator|(
name|STL_RXBUFSIZE
operator|-
name|STL_RXBUFHIGH
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOWMODE
operator|)
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ASY_RTSFLOW
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|,
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|)
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxrtsoff
operator|++
expr_stmt|;
block|}
block|}
comment|/*  *	OK we are set, process good data... If the RX ring queue is full  *	just chuck the chars - don't leave them in the UART.  */
if|if
condition|(
operator|(
name|ioack
operator|&
name|ACK_TYPMASK
operator|)
operator|==
name|ACK_TYPRXGOOD
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|RDCR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|==
literal|0
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|RDSR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|insb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
operator|&
name|unwanted
index|[
literal|0
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxlost
operator|+=
name|len
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxtotal
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxtotal
operator|+=
name|len
expr_stmt|;
name|stlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|RDSR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|insb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|head
argument_list|,
name|stlen
argument_list|)
expr_stmt|;
name|head
operator|+=
name|stlen
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|portp
operator|->
name|rx
operator|.
name|endbuf
condition|)
block|{
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
name|len
operator|-=
name|stlen
expr_stmt|;
name|insb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|head
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|head
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ioack
operator|&
name|ACK_TYPMASK
operator|)
operator|==
name|ACK_TYPRXBAD
condition|)
block|{
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|RDSR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
name|ch
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_BREAK
condition|)
name|portp
operator|->
name|stats
operator|.
name|rxbreaks
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_FRAMING
condition|)
name|portp
operator|->
name|stats
operator|.
name|rxframing
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_PARITY
condition|)
name|portp
operator|->
name|stats
operator|.
name|rxparity
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_OVERRUN
condition|)
name|portp
operator|->
name|stats
operator|.
name|rxoverrun
operator|++
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_SCHARMASK
condition|)
block|{
if|if
condition|(
operator|(
name|status
operator|&
name|ST_SCHARMASK
operator|)
operator|==
name|ST_SCHAR1
condition|)
name|portp
operator|->
name|stats
operator|.
name|txxon
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ST_SCHARMASK
operator|)
operator|==
name|ST_SCHAR2
condition|)
name|portp
operator|->
name|stats
operator|.
name|txxoff
operator|++
expr_stmt|;
goto|goto
name|stl_rxalldone
goto|;
block|}
if|if
condition|(
operator|(
name|portp
operator|->
name|rxignoremsk
operator|&
name|status
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
operator|)
operator|&&
operator|(
operator|(
name|status
operator|&
name|ST_FRAMING
operator|)
operator|||
operator|(
operator|(
name|status
operator|&
name|ST_PARITY
operator|)
operator|&&
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|INPCK
operator|)
operator|)
operator|)
condition|)
name|ch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|portp
operator|->
name|rxmarkmsk
operator|&
name|status
operator|)
operator|==
literal|0
condition|)
name|status
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|head
operator|+
name|STL_RXBUFSIZE
operator|)
operator|=
name|status
expr_stmt|;
operator|*
name|head
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|portp
operator|->
name|rx
operator|.
name|endbuf
condition|)
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"STALLION: bad RX interrupt ack value=%x\n"
argument_list|,
name|ioack
argument_list|)
expr_stmt|;
return|return;
block|}
name|portp
operator|->
name|rx
operator|.
name|head
operator|=
name|head
expr_stmt|;
name|portp
operator|->
name|state
operator||=
name|ASY_RXDATA
expr_stmt|;
name|stl_dotimeout
argument_list|()
expr_stmt|;
name|stl_rxalldone
label|:
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|EOSRR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Modem interrupt handler. The is called when the modem signal line  *	(DCD) has changed state. Leave most of the work to the off-level  *	processing routine.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|stl_mdmisr
parameter_list|(
name|stlpanel_t
modifier|*
name|panelp
parameter_list|,
name|int
name|ioaddr
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|unsigned
name|int
name|ioack
decl_stmt|;
name|unsigned
name|char
name|misr
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_mdmisr(panelp=%x,ioaddr=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|panelp
argument_list|,
name|ioaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ioack
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_MDACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ioack
operator|&
name|panelp
operator|->
name|ackmask
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
name|ioack
operator|&
name|ACK_TYPMASK
operator|)
operator|!=
name|ACK_TYPMDM
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: bad MODEM interrupt ack value=%x\n"
argument_list|,
name|ioack
argument_list|)
expr_stmt|;
return|return;
block|}
name|portp
operator|=
name|panelp
operator|->
name|ports
index|[
operator|(
name|ioack
operator|>>
literal|3
operator|)
index|]
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|MISR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|misr
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|misr
operator|&
name|MISR_DCD
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ASY_DCDCHANGE
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|modem
operator|++
expr_stmt|;
name|stl_dotimeout
argument_list|()
expr_stmt|;
block|}
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|EOSRR
operator|+
name|portp
operator|->
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Interrupt handler for EIO and ECH boards. This code ain't all that  *	pretty, but the idea is to make it as fast as possible. This code is  *	well suited to be assemblerized :-)  We don't use the general purpose  *	register access functions here, for speed we will go strait to the  *	io register.  */
end_comment

begin_function
specifier|static
name|void
name|stlintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
name|unsigned
name|char
name|svrtype
decl_stmt|;
name|int
name|i
decl_stmt|,
name|panelnr
decl_stmt|,
name|iobase
decl_stmt|;
name|int
name|cnt
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stlintr(unit=%d)\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cnt
operator|=
literal|0
expr_stmt|;
name|panelp
operator|=
operator|(
name|stlpanel_t
operator|*
operator|)
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|stl_nrbrds
operator|)
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|brdp
operator|=
name|stl_brds
index|[
name|i
index|]
operator|)
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|brdp
operator|->
name|state
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*  *		The following section of code handles the subtle differences  *		between board types. It is sort of similar, but different  *		enough to handle each separately.  */
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_EASYIO
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
operator|&
name|EIO_INTRPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
literal|0
index|]
expr_stmt|;
name|iobase
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
name|outb
argument_list|(
name|iobase
argument_list|,
name|SVRR
argument_list|)
expr_stmt|;
name|svrtype
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdp
operator|->
name|nrports
operator|>
literal|4
condition|)
block|{
name|outb
argument_list|(
name|iobase
argument_list|,
operator|(
name|SVRR
operator|+
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|svrtype
operator||=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECH
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
operator|&
name|ECH_INTRPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|brdp
operator|->
name|ioctrlval
operator||
name|ECH_BRDENABLE
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|panelnr
operator|=
literal|0
init|;
operator|(
name|panelnr
operator|<
name|brdp
operator|->
name|nrpanels
operator|)
condition|;
name|panelnr
operator|++
control|)
block|{
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
expr_stmt|;
name|iobase
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
if|if
condition|(
name|panelp
operator|->
name|nrports
operator|>
literal|8
condition|)
block|{
name|iobase
operator|+=
literal|0x8
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|panelnr
operator|>=
name|brdp
operator|->
name|nrpanels
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|iobase
argument_list|,
name|SVRR
argument_list|)
expr_stmt|;
name|svrtype
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
argument_list|,
operator|(
name|SVRR
operator|+
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|svrtype
operator||=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHPCI
condition|)
block|{
name|iobase
operator|=
name|brdp
operator|->
name|ioaddr2
expr_stmt|;
for|for
control|(
name|panelnr
operator|=
literal|0
init|;
operator|(
name|panelnr
operator|<
name|brdp
operator|->
name|nrpanels
operator|)
condition|;
name|panelnr
operator|++
control|)
block|{
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
name|panelp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
if|if
condition|(
name|panelp
operator|->
name|nrports
operator|>
literal|8
condition|)
block|{
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|panelp
operator|->
name|pagenr
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|panelnr
operator|>=
name|brdp
operator|->
name|nrpanels
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|iobase
argument_list|,
name|SVRR
argument_list|)
expr_stmt|;
name|svrtype
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
argument_list|,
operator|(
name|SVRR
operator|+
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|svrtype
operator||=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHMC
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
operator|&
name|ECH_INTRPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|panelnr
operator|=
literal|0
init|;
operator|(
name|panelnr
operator|<
name|brdp
operator|->
name|nrpanels
operator|)
condition|;
name|panelnr
operator|++
control|)
block|{
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
expr_stmt|;
name|iobase
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
if|if
condition|(
name|panelp
operator|->
name|nrports
operator|>
literal|8
condition|)
block|{
name|iobase
operator|+=
literal|0x8
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|iobase
operator|+
name|ECH_PNLSTATUS
argument_list|)
operator|&
name|ECH_PNLINTRPEND
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|panelnr
operator|>=
name|brdp
operator|->
name|nrpanels
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|iobase
argument_list|,
name|SVRR
argument_list|)
expr_stmt|;
name|svrtype
operator|=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|iobase
argument_list|,
operator|(
name|SVRR
operator|+
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|svrtype
operator||=
name|inb
argument_list|(
name|iobase
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"STALLION: unknown board type=%x\n"
argument_list|,
name|brdp
operator|->
name|brdtype
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/*  *		We have determined what type of service is required for a  *		port. From here on in the service of a port is the same no  *		matter what the board type...  */
if|if
condition|(
name|svrtype
operator|&
name|SVRR_RX
condition|)
name|stl_rxisr
argument_list|(
name|panelp
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|svrtype
operator|&
name|SVRR_TX
condition|)
name|stl_txisr
argument_list|(
name|panelp
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|svrtype
operator|&
name|SVRR_MDM
condition|)
name|stl_mdmisr
argument_list|(
name|panelp
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECH
condition|)
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|brdp
operator|->
name|ioctrlval
operator||
name|ECH_BRDDISABLE
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_function
specifier|static
name|void
name|stlpciintr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|stlintr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	If we haven't scheduled a timeout then do it, some port needs high  *	level processing.  */
end_comment

begin_function
specifier|static
name|void
name|stl_dotimeout
parameter_list|()
block|{
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_dotimeout()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stl_doingtimeout
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|stl_poll
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stl_doingtimeout
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Service "software" level processing. Too slow or painfull to be done  *	at real hardware interrupt time. This way we might also be able to  *	do some service on other waiting ports as well...  */
end_comment

begin_function
specifier|static
name|void
name|stl_poll
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|brdnr
decl_stmt|,
name|portnr
decl_stmt|,
name|rearm
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_poll()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stl_doingtimeout
operator|=
literal|0
expr_stmt|;
name|rearm
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
name|brdnr
operator|=
literal|0
init|;
operator|(
name|brdnr
operator|<
name|stl_nrbrds
operator|)
condition|;
name|brdnr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|brdp
operator|=
name|stl_brds
index|[
name|brdnr
index|]
operator|)
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
for|for
control|(
name|portnr
operator|=
literal|0
init|;
operator|(
name|portnr
operator|<
name|brdp
operator|->
name|nrports
operator|)
condition|;
name|portnr
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|portp
operator|=
name|brdp
operator|->
name|ports
index|[
name|portnr
index|]
operator|)
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_ACTIVE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_RXDATA
condition|)
name|stl_rxprocess
argument_list|(
name|portp
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_DCDCHANGE
condition|)
block|{
name|portp
operator|->
name|state
operator|&=
operator|~
name|ASY_DCDCHANGE
expr_stmt|;
name|portp
operator|->
name|sigs
operator|=
name|stl_getsignals
argument_list|(
name|portp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_modem
operator|)
operator|(
name|tp
operator|,
operator|(
name|portp
operator|->
name|sigs
operator|&
name|TIOCM_CD
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_TXLOW
condition|)
block|{
name|portp
operator|->
name|state
operator|&=
operator|~
name|ASY_TXLOW
expr_stmt|;
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
name|tp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_ACTIVE
condition|)
name|rearm
operator|++
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|rearm
condition|)
name|stl_dotimeout
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Process the RX data that has been buffered up in the RX ring queue.  */
end_comment

begin_function
specifier|static
name|void
name|stl_rxprocess
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|,
name|stlen
decl_stmt|,
name|lostlen
decl_stmt|;
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|char
name|status
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_rxprocess(portp=%x): brdnr=%d portnr=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
name|ASY_RXDATA
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|stl_flush
argument_list|(
name|portp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  *	Calculate the amount of data in the RX ring queue. Also calculate  *	the largest single copy size...  */
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|tail
expr_stmt|;
if|if
condition|(
name|head
operator|>=
name|tail
condition|)
block|{
name|len
operator|=
name|head
operator|-
name|tail
expr_stmt|;
name|stlen
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|STL_RXBUFSIZE
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
expr_stmt|;
name|stlen
operator|=
name|portp
operator|->
name|rx
operator|.
name|endbuf
operator|-
name|tail
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CAN_BYPASS_L_RINT
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|+
name|len
operator|)
operator|>=
name|TTYHOG
operator|)
operator|&&
operator|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOWMODE
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXOFF
operator|)
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ch
operator|=
name|TTYHOG
operator|-
name|tp
operator|->
name|t_rawq
operator|.
name|c_cc
operator|-
literal|1
expr_stmt|;
name|len
operator|=
operator|(
name|ch
operator|>
literal|0
operator|)
condition|?
name|ch
else|:
literal|0
expr_stmt|;
name|stlen
operator|=
name|MIN
argument_list|(
name|stlen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ttyblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|lostlen
operator|=
name|b_to_q
argument_list|(
name|tail
argument_list|,
name|stlen
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|tail
operator|+=
name|stlen
expr_stmt|;
name|len
operator|-=
name|stlen
expr_stmt|;
if|if
condition|(
name|tail
operator|>=
name|portp
operator|->
name|rx
operator|.
name|endbuf
condition|)
block|{
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
name|lostlen
operator|+=
name|b_to_q
argument_list|(
name|tail
argument_list|,
name|len
argument_list|,
operator|&
name|tp
operator|->
name|t_rawq
argument_list|)
expr_stmt|;
name|tail
operator|+=
name|len
expr_stmt|;
block|}
name|portp
operator|->
name|stats
operator|.
name|rxlost
operator|+=
name|lostlen
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|tail
operator|=
name|tail
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|!=
name|head
condition|)
block|{
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|=
operator|*
operator|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|+
name|STL_RXBUFSIZE
operator|)
condition|)
block|{
operator|*
operator|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|+
name|STL_RXBUFSIZE
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_BREAK
condition|)
name|ch
operator||=
name|TTY_BI
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_FRAMING
condition|)
name|ch
operator||=
name|TTY_FE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_PARITY
condition|)
name|ch
operator||=
name|TTY_PE
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ST_OVERRUN
condition|)
name|ch
operator||=
name|TTY_OE
expr_stmt|;
block|}
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|ch
operator|,
name|tp
operator|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|==
name|head
condition|)
break|break;
if|if
condition|(
operator|++
operator|(
name|portp
operator|->
name|rx
operator|.
name|tail
operator|)
operator|>=
name|portp
operator|->
name|rx
operator|.
name|endbuf
condition|)
name|portp
operator|->
name|rx
operator|.
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|head
operator|!=
name|portp
operator|->
name|rx
operator|.
name|tail
condition|)
name|portp
operator|->
name|state
operator||=
name|ASY_RXDATA
expr_stmt|;
comment|/*  *	If we where flow controled then maybe the buffer is low enough that  *	we can re-activate it.  */
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TBLOCK
operator|)
operator|==
literal|0
operator|)
condition|)
name|stl_flowcontrol
argument_list|(
name|portp
argument_list|,
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Set up the cd1400 registers for a port based on the termios port  *	settings.  */
end_comment

begin_function
specifier|static
name|int
name|stl_param
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|unsigned
name|int
name|clkdiv
decl_stmt|;
name|unsigned
name|char
name|cor1
decl_stmt|,
name|cor2
decl_stmt|,
name|cor3
decl_stmt|;
name|unsigned
name|char
name|cor4
decl_stmt|,
name|cor5
decl_stmt|,
name|ccr
decl_stmt|;
name|unsigned
name|char
name|srer
decl_stmt|,
name|sreron
decl_stmt|,
name|sreroff
decl_stmt|;
name|unsigned
name|char
name|mcor1
decl_stmt|,
name|mcor2
decl_stmt|,
name|rtpr
decl_stmt|;
name|unsigned
name|char
name|clk
decl_stmt|,
name|div
decl_stmt|;
name|int
name|x
decl_stmt|;
name|portp
operator|=
operator|(
name|stlport_t
operator|*
operator|)
name|tp
expr_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_param(tp=%x,tiosp=%x): brdnr=%d portnr=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|tp
argument_list|,
operator|(
name|int
operator|)
name|tiosp
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|portnr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cor1
operator|=
literal|0
expr_stmt|;
name|cor2
operator|=
literal|0
expr_stmt|;
name|cor3
operator|=
literal|0
expr_stmt|;
name|cor4
operator|=
literal|0
expr_stmt|;
name|cor5
operator|=
literal|0
expr_stmt|;
name|ccr
operator|=
literal|0
expr_stmt|;
name|rtpr
operator|=
literal|0
expr_stmt|;
name|clk
operator|=
literal|0
expr_stmt|;
name|div
operator|=
literal|0
expr_stmt|;
name|mcor1
operator|=
literal|0
expr_stmt|;
name|mcor2
operator|=
literal|0
expr_stmt|;
name|sreron
operator|=
literal|0
expr_stmt|;
name|sreroff
operator|=
literal|0
expr_stmt|;
comment|/*  *	Set up the RX char ignore mask with those RX error types we  *	can ignore. We could have used some special modes of the cd1400  *	UART to help, but it is better this way because we can keep stats  *	on the number of each type of RX exception event.  */
name|portp
operator|->
name|rxignoremsk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNPAR
condition|)
name|portp
operator|->
name|rxignoremsk
operator||=
operator|(
name|ST_PARITY
operator||
name|ST_FRAMING
operator||
name|ST_OVERRUN
operator|)
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNBRK
condition|)
name|portp
operator|->
name|rxignoremsk
operator||=
name|ST_BREAK
expr_stmt|;
name|portp
operator|->
name|rxmarkmsk
operator|=
name|ST_OVERRUN
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|INPCK
operator||
name|PARMRK
operator|)
condition|)
name|portp
operator|->
name|rxmarkmsk
operator||=
operator|(
name|ST_PARITY
operator||
name|ST_FRAMING
operator|)
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|BRKINT
condition|)
name|portp
operator|->
name|rxmarkmsk
operator||=
name|ST_BREAK
expr_stmt|;
comment|/*  *	Go through the char size, parity and stop bits and set all the  *	option registers appropriately.  */
switch|switch
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CSIZE
condition|)
block|{
case|case
name|CS5
case|:
name|cor1
operator||=
name|COR1_CHL5
expr_stmt|;
break|break;
case|case
name|CS6
case|:
name|cor1
operator||=
name|COR1_CHL6
expr_stmt|;
break|break;
case|case
name|CS7
case|:
name|cor1
operator||=
name|COR1_CHL7
expr_stmt|;
break|break;
default|default:
name|cor1
operator||=
name|COR1_CHL8
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CSTOPB
condition|)
name|cor1
operator||=
name|COR1_STOP2
expr_stmt|;
else|else
name|cor1
operator||=
name|COR1_STOP1
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|PARODD
condition|)
name|cor1
operator||=
operator|(
name|COR1_PARENB
operator||
name|COR1_PARODD
operator|)
expr_stmt|;
else|else
name|cor1
operator||=
operator|(
name|COR1_PARENB
operator||
name|COR1_PAREVEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cor1
operator||=
name|COR1_PARNONE
expr_stmt|;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|ISTRIP
condition|)
name|cor5
operator||=
name|COR5_ISTRIP
expr_stmt|;
comment|/*  *	Set the RX FIFO threshold at 6 chars. This gives a bit of breathing  *	space for hardware flow control and the like. This should be set to  *	VMIN. Also here we will set the RX data timeout to 10ms - this should  *	really be based on VTIME...  */
name|cor3
operator||=
name|FIFO_RXTHRESHOLD
expr_stmt|;
name|rtpr
operator|=
literal|2
expr_stmt|;
comment|/*  *	Calculate the baud rate timers. For now we will just assume that  *	the input and output baud are the same. Could have used a baud  *	table here, but this way we can generate virtually any baud rate  *	we like!  */
if|if
condition|(
name|tiosp
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|tiosp
operator|->
name|c_ispeed
operator|=
name|tiosp
operator|->
name|c_ospeed
expr_stmt|;
if|if
condition|(
operator|(
name|tiosp
operator|->
name|c_ospeed
operator|<
literal|0
operator|)
operator|||
operator|(
name|tiosp
operator|->
name|c_ospeed
operator|>
name|STL_MAXBAUD
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|tiosp
operator|->
name|c_ospeed
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|clk
operator|=
literal|0
init|;
operator|(
name|clk
operator|<
name|CD1400_NUMCLKS
operator|)
condition|;
name|clk
operator|++
control|)
block|{
name|clkdiv
operator|=
operator|(
operator|(
name|portp
operator|->
name|clk
operator|/
name|stl_cd1400clkdivs
index|[
name|clk
index|]
operator|)
operator|/
name|tiosp
operator|->
name|c_ospeed
operator|)
expr_stmt|;
if|if
condition|(
name|clkdiv
operator|<
literal|0x100
condition|)
break|break;
block|}
name|div
operator|=
operator|(
name|unsigned
name|char
operator|)
name|clkdiv
expr_stmt|;
block|}
comment|/*  *	Check what form of modem signaling is required and set it up.  */
if|if
condition|(
operator|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
condition|)
block|{
name|mcor1
operator||=
name|MCOR1_DCD
expr_stmt|;
name|mcor2
operator||=
name|MCOR2_DCD
expr_stmt|;
name|sreron
operator||=
name|SRER_MODEM
expr_stmt|;
block|}
comment|/*  *	Setup cd1400 enhanced modes if we can. In particular we want to  *	handle as much of the flow control as possbile automatically. As  *	well as saving a few CPU cycles it will also greatly improve flow  *	control reliablilty.  */
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IXON
condition|)
block|{
name|cor2
operator||=
name|COR2_TXIBE
expr_stmt|;
name|cor3
operator||=
name|COR3_SCD12
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IXANY
condition|)
name|cor2
operator||=
name|COR2_IXM
expr_stmt|;
block|}
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CCTS_OFLOW
condition|)
name|cor2
operator||=
name|COR2_CTSAE
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CRTS_IFLOW
condition|)
name|mcor1
operator||=
name|FIFO_RTSTHRESHOLD
expr_stmt|;
comment|/*  *	All cd1400 register values calculated so go through and set them  *	all up.  */
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"SETPORT: portnr=%d panelnr=%d brdnr=%d\n"
argument_list|,
name|portp
operator|->
name|portnr
argument_list|,
name|portp
operator|->
name|panelnr
argument_list|,
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    cor1=%x cor2=%x cor3=%x cor4=%x cor5=%x\n"
argument_list|,
name|cor1
argument_list|,
name|cor2
argument_list|,
name|cor3
argument_list|,
name|cor4
argument_list|,
name|cor5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    mcor1=%x mcor2=%x rtpr=%x sreron=%x sreroff=%x\n"
argument_list|,
name|mcor1
argument_list|,
name|mcor2
argument_list|,
name|rtpr
argument_list|,
name|sreron
argument_list|,
name|sreroff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    tcor=%x tbpr=%x rcor=%x rbpr=%x\n"
argument_list|,
name|clk
argument_list|,
name|div
argument_list|,
name|clk
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    schr1=%x schr2=%x schr3=%x schr4=%x\n"
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|srer
operator|=
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|stl_updatereg
argument_list|(
name|portp
argument_list|,
name|COR1
argument_list|,
name|cor1
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|stl_updatereg
argument_list|(
name|portp
argument_list|,
name|COR2
argument_list|,
name|cor2
argument_list|)
expr_stmt|;
name|ccr
operator|+=
name|stl_updatereg
argument_list|(
name|portp
argument_list|,
name|COR3
argument_list|,
name|cor3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccr
condition|)
block|{
name|stl_ccrwait
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CCR
argument_list|,
name|CCR_CORCHANGE
argument_list|)
expr_stmt|;
block|}
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|COR4
argument_list|,
name|cor4
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|COR5
argument_list|,
name|cor5
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|,
name|mcor1
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MCOR2
argument_list|,
name|mcor2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tiosp
operator|->
name|c_ospeed
operator|==
literal|0
condition|)
block|{
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR1
argument_list|,
name|MSVR1_DTR
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|TCOR
argument_list|,
name|clk
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|TBPR
argument_list|,
name|div
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|RCOR
argument_list|,
name|clk
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|RBPR
argument_list|,
name|div
argument_list|)
expr_stmt|;
block|}
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SCHR1
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SCHR2
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SCHR3
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTART
index|]
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SCHR4
argument_list|,
name|tiosp
operator|->
name|c_cc
index|[
name|VSTOP
index|]
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|RTPR
argument_list|,
name|rtpr
argument_list|)
expr_stmt|;
name|mcor1
operator|=
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MSVR1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcor1
operator|&
name|MSVR1_DCD
condition|)
name|portp
operator|->
name|sigs
operator||=
name|TIOCM_CD
expr_stmt|;
else|else
name|portp
operator|->
name|sigs
operator|&=
operator|~
name|TIOCM_CD
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|,
operator|(
operator|(
name|srer
operator|&
operator|~
name|sreroff
operator|)
operator||
name|sreron
operator|)
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|portp
operator|->
name|state
operator|&=
operator|~
operator|(
name|ASY_RTSFLOWMODE
operator||
name|ASY_CTSFLOWMODE
operator|)
expr_stmt|;
name|portp
operator|->
name|state
operator||=
operator|(
operator|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CRTS_IFLOW
operator|)
condition|?
name|ASY_RTSFLOWMODE
else|:
literal|0
operator|)
expr_stmt|;
name|portp
operator|->
name|state
operator||=
operator|(
operator|(
name|tiosp
operator|->
name|c_cflag
operator|&
name|CCTS_OFLOW
operator|)
condition|?
name|ASY_CTSFLOWMODE
else|:
literal|0
operator|)
expr_stmt|;
name|stl_ttyoptim
argument_list|(
name|portp
argument_list|,
name|tiosp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Action the flow control as required. The hw and sw args inform the  *	routine what flow control methods it should try.  */
end_comment

begin_function
specifier|static
name|void
name|stl_flowcontrol
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|hw
parameter_list|,
name|int
name|sw
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|int
name|len
decl_stmt|,
name|hwflow
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_flowcontrol(portp=%x,hw=%d,sw=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|hw
argument_list|,
name|sw
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hwflow
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOWMODE
condition|)
block|{
if|if
condition|(
name|hw
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
operator|)
operator|==
literal|0
condition|)
name|hwflow
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hw
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|portp
operator|->
name|state
operator|&
name|ASY_RTSFLOW
condition|)
block|{
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|tail
expr_stmt|;
name|len
operator|=
operator|(
name|head
operator|>=
name|tail
operator|)
condition|?
operator|(
name|head
operator|-
name|tail
operator|)
else|:
operator|(
name|STL_RXBUFSIZE
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|STL_RXBUFHIGH
condition|)
name|hwflow
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/*  *	We have worked out what to do, if anything. So now apply it to the  *	UART port.  */
if|if
condition|(
name|hwflow
operator|>=
literal|0
condition|)
block|{
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hwflow
operator|==
literal|0
condition|)
block|{
name|portp
operator|->
name|state
operator||=
name|ASY_RTSFLOW
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|,
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|)
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxrtsoff
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hwflow
operator|>
literal|0
condition|)
block|{
name|portp
operator|->
name|state
operator|&=
operator|~
name|ASY_RTSFLOW
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR2
argument_list|,
name|MSVR2_RTS
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|,
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MCOR1
argument_list|)
operator||
name|FIFO_RTSTHRESHOLD
operator|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxrtson
operator|++
expr_stmt|;
block|}
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Set the state of the DTR and RTS signals.  */
end_comment

begin_function
specifier|static
name|void
name|stl_setsignals
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|dtr
parameter_list|,
name|int
name|rts
parameter_list|)
block|{
name|unsigned
name|char
name|msvr1
decl_stmt|,
name|msvr2
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_setsignals(portp=%x,dtr=%d,rts=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|dtr
argument_list|,
name|rts
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msvr1
operator|=
literal|0
expr_stmt|;
name|msvr2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dtr
operator|>
literal|0
condition|)
name|msvr1
operator|=
name|MSVR1_DTR
expr_stmt|;
if|if
condition|(
name|rts
operator|>
literal|0
condition|)
name|msvr2
operator|=
name|MSVR2_RTS
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rts
operator|>=
literal|0
condition|)
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR2
argument_list|,
name|msvr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtr
operator|>=
literal|0
condition|)
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|MSVR1
argument_list|,
name|msvr1
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Get the state of the signals.  */
end_comment

begin_function
specifier|static
name|int
name|stl_getsignals
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
name|unsigned
name|char
name|msvr1
decl_stmt|,
name|msvr2
decl_stmt|;
name|int
name|sigs
decl_stmt|,
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_getsignals(portp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|msvr1
operator|=
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MSVR1
argument_list|)
expr_stmt|;
name|msvr2
operator|=
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|MSVR2
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sigs
operator|=
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr1
operator|&
name|MSVR1_DCD
operator|)
condition|?
name|TIOCM_CD
else|:
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr1
operator|&
name|MSVR1_CTS
operator|)
condition|?
name|TIOCM_CTS
else|:
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr1
operator|&
name|MSVR1_RI
operator|)
condition|?
name|TIOCM_RI
else|:
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr1
operator|&
name|MSVR1_DSR
operator|)
condition|?
name|TIOCM_DSR
else|:
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr1
operator|&
name|MSVR1_DTR
operator|)
condition|?
name|TIOCM_DTR
else|:
literal|0
expr_stmt|;
name|sigs
operator||=
operator|(
name|msvr2
operator|&
name|MSVR2_RTS
operator|)
condition|?
name|TIOCM_RTS
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|sigs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Enable or disable the Transmitter and/or Receiver.  */
end_comment

begin_function
specifier|static
name|void
name|stl_enablerxtx
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|tx
parameter_list|)
block|{
name|unsigned
name|char
name|ccr
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_enablerxtx(portp=%x,rx=%d,tx=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|rx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tx
operator|==
literal|0
condition|)
name|ccr
operator||=
name|CCR_TXDISABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|tx
operator|>
literal|0
condition|)
name|ccr
operator||=
name|CCR_TXENABLE
expr_stmt|;
if|if
condition|(
name|rx
operator|==
literal|0
condition|)
name|ccr
operator||=
name|CCR_RXDISABLE
expr_stmt|;
elseif|else
if|if
condition|(
name|rx
operator|>
literal|0
condition|)
name|ccr
operator||=
name|CCR_RXENABLE
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x03
operator|)
argument_list|)
expr_stmt|;
name|stl_ccrwait
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CCR
argument_list|,
name|ccr
argument_list|)
expr_stmt|;
name|stl_ccrwait
argument_list|(
name|portp
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Start or stop the Transmitter and/or Receiver.  */
end_comment

begin_function
specifier|static
name|void
name|stl_startrxtx
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|int
name|rx
parameter_list|,
name|int
name|tx
parameter_list|)
block|{
name|unsigned
name|char
name|sreron
decl_stmt|,
name|sreroff
decl_stmt|;
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_startrxtx(portp=%x,rx=%d,tx=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
name|rx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sreron
operator|=
literal|0
expr_stmt|;
name|sreroff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tx
operator|==
literal|0
condition|)
name|sreroff
operator||=
operator|(
name|SRER_TXDATA
operator||
name|SRER_TXEMPTY
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tx
operator|==
literal|1
condition|)
name|sreron
operator||=
name|SRER_TXDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|tx
operator|>=
literal|2
condition|)
name|sreron
operator||=
name|SRER_TXEMPTY
expr_stmt|;
if|if
condition|(
name|rx
operator|==
literal|0
condition|)
name|sreroff
operator||=
name|SRER_RXDATA
expr_stmt|;
elseif|else
if|if
condition|(
name|rx
operator|>
literal|0
condition|)
name|sreron
operator||=
name|SRER_RXDATA
expr_stmt|;
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|,
operator|(
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|)
operator|&
operator|~
name|sreroff
operator|)
operator||
name|sreron
operator|)
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|>
literal|0
condition|)
name|portp
operator|->
name|tty
operator|.
name|t_state
operator||=
name|TS_BUSY
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Disable all interrupts from this port.  */
end_comment

begin_function
specifier|static
name|void
name|stl_disableintrs
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_disableintrs(portp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|stl_sendbreak
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|long
name|len
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_sendbreak(portp=%x,len=%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|portp
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|BRDENABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|,
name|portp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|portp
operator|->
name|portnr
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|COR2
argument_list|,
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|COR2
argument_list|)
operator||
name|COR2_ETC
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|,
operator|(
operator|(
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|SRER
argument_list|)
operator|&
operator|~
name|SRER_TXDATA
operator|)
operator||
name|SRER_TXEMPTY
operator|)
argument_list|)
expr_stmt|;
name|BRDDISABLE
argument_list|(
name|portp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|len
operator|/
literal|5
expr_stmt|;
name|portp
operator|->
name|brklen
operator|=
operator|(
name|len
operator|>
literal|255
operator|)
condition|?
literal|255
else|:
name|len
expr_stmt|;
block|}
else|else
block|{
name|portp
operator|->
name|brklen
operator|=
name|len
expr_stmt|;
block|}
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|txbreaks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Enable l_rint processing bypass mode if tty modes allow it.  */
end_comment

begin_function
specifier|static
name|void
name|stl_ttyoptim
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|struct
name|termios
modifier|*
name|tiosp
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|portp
operator|->
name|tty
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|ICRNL
operator||
name|IGNCR
operator||
name|IMAXBEL
operator||
name|INLCR
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|BRKINT
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|IGNBRK
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
name|PARMRK
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|tiosp
operator|->
name|c_iflag
operator|&
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|==
operator|(
name|IGNPAR
operator||
name|IGNBRK
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|(
name|tiosp
operator|->
name|c_lflag
operator|&
operator|(
name|ECHO
operator||
name|ICANON
operator||
name|IEXTEN
operator||
name|ISIG
operator||
name|PENDIN
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_rint
operator|==
name|ttyinput
operator|)
condition|)
name|tp
operator|->
name|t_state
operator||=
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
else|else
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_CAN_BYPASS_L_RINT
expr_stmt|;
name|portp
operator|->
name|hotchar
operator|=
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_hotchar
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try and find and initialize all the ports on a panel. We don't care  *	what sort of board these ports are on - since the port io registers  *	are almost identical when dealing with ports.  */
end_comment

begin_function
specifier|static
name|int
name|stl_initports
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|,
name|stlpanel_t
modifier|*
name|panelp
parameter_list|)
block|{
name|stlport_t
modifier|*
name|portp
decl_stmt|;
name|unsigned
name|int
name|chipmask
decl_stmt|;
name|unsigned
name|int
name|gfrcr
decl_stmt|;
name|int
name|nrchips
decl_stmt|,
name|uartaddr
decl_stmt|,
name|ioaddr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_initports(panelp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|panelp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|BRDENABLE
argument_list|(
name|panelp
operator|->
name|brdnr
argument_list|,
name|panelp
operator|->
name|pagenr
argument_list|)
expr_stmt|;
comment|/*  *	Check that each chip is present and started up OK.  */
name|chipmask
operator|=
literal|0
expr_stmt|;
name|nrchips
operator|=
name|panelp
operator|->
name|nrports
operator|/
name|CD1400_PORTS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|nrchips
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHPCI
condition|)
block|{
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|panelp
operator|->
name|pagenr
operator|+
operator|(
name|i
operator|>>
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ioaddr
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
block|}
else|else
block|{
name|ioaddr
operator|=
name|panelp
operator|->
name|iobase
operator|+
operator|(
name|EREG_BANKSIZE
operator|*
operator|(
name|i
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
block|}
name|uartaddr
operator|=
operator|(
name|i
operator|&
literal|0x01
operator|)
condition|?
literal|0x080
else|:
literal|0
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|GFRCR
operator|+
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|CCR
operator|+
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|CCR_RESETFULL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|CCR_RESETFULL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|GFRCR
operator|+
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|CCR_MAXWAIT
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|gfrcr
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|EREG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gfrcr
operator|>
literal|0x40
operator|)
operator|&&
operator|(
name|gfrcr
operator|<
literal|0x60
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|>=
name|CCR_MAXWAIT
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: cd1400 not responding, brd=%d "
literal|"panel=%d chip=%d\n"
argument_list|,
name|panelp
operator|->
name|brdnr
argument_list|,
name|panelp
operator|->
name|panelnr
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|chipmask
operator||=
operator|(
literal|0x1
operator|<<
name|i
operator|)
expr_stmt|;
name|outb
argument_list|(
name|ioaddr
argument_list|,
operator|(
name|PPR
operator|+
name|uartaddr
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
operator|(
name|ioaddr
operator|+
name|EREG_DATA
operator|)
argument_list|,
name|PPR_SCALAR
argument_list|)
expr_stmt|;
block|}
comment|/*  *	All cd1400's are initialized (if found!). Now go through and setup  *	each ports data structures. Also init the LIVR register of cd1400  *	for each port.  */
name|ioaddr
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|panelp
operator|->
name|nrports
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHPCI
condition|)
block|{
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|panelp
operator|->
name|pagenr
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ioaddr
operator|=
name|panelp
operator|->
name|iobase
expr_stmt|;
block|}
else|else
block|{
name|ioaddr
operator|=
name|panelp
operator|->
name|iobase
operator|+
operator|(
name|EREG_BANKSIZE
operator|*
operator|(
name|i
operator|>>
literal|3
operator|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chipmask
operator|&
operator|(
literal|0x1
operator|<<
operator|(
name|i
operator|/
literal|4
operator|)
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|portp
operator|=
operator|(
name|stlport_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlport_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate port memory "
literal|"(size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlport_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|portp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlport_t
argument_list|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|portnr
operator|=
name|i
expr_stmt|;
name|portp
operator|->
name|brdnr
operator|=
name|panelp
operator|->
name|brdnr
expr_stmt|;
name|portp
operator|->
name|panelnr
operator|=
name|panelp
operator|->
name|panelnr
expr_stmt|;
name|portp
operator|->
name|clk
operator|=
name|brdp
operator|->
name|clk
expr_stmt|;
name|portp
operator|->
name|ioaddr
operator|=
name|ioaddr
expr_stmt|;
name|portp
operator|->
name|uartaddr
operator|=
operator|(
name|i
operator|&
literal|0x4
operator|)
operator|<<
literal|5
expr_stmt|;
name|portp
operator|->
name|pagenr
operator|=
name|panelp
operator|->
name|pagenr
operator|+
operator|(
name|i
operator|>>
literal|3
operator|)
expr_stmt|;
name|portp
operator|->
name|hwid
operator|=
name|stl_getreg
argument_list|(
name|portp
argument_list|,
name|GFRCR
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|CAR
argument_list|,
operator|(
name|i
operator|&
literal|0x3
operator|)
argument_list|)
expr_stmt|;
name|stl_setreg
argument_list|(
name|portp
argument_list|,
name|LIVR
argument_list|,
operator|(
name|i
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|panelp
operator|->
name|ports
index|[
name|i
index|]
operator|=
name|portp
expr_stmt|;
name|j
operator|=
name|STL_TXBUFSIZE
operator|+
operator|(
literal|2
operator|*
name|STL_RXBUFSIZE
operator|)
expr_stmt|;
name|portp
operator|->
name|tx
operator|.
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|j
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|->
name|tx
operator|.
name|buf
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate buffer memory "
literal|"(size=%d)\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
break|break;
block|}
name|portp
operator|->
name|tx
operator|.
name|endbuf
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
operator|+
name|STL_TXBUFSIZE
expr_stmt|;
name|portp
operator|->
name|tx
operator|.
name|head
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
expr_stmt|;
name|portp
operator|->
name|tx
operator|.
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|buf
operator|=
name|portp
operator|->
name|tx
operator|.
name|buf
operator|+
name|STL_TXBUFSIZE
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|endbuf
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
operator|+
name|STL_RXBUFSIZE
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
name|portp
operator|->
name|rx
operator|.
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
expr_stmt|;
name|portp
operator|->
name|rxstatus
operator|.
name|buf
operator|=
name|portp
operator|->
name|rx
operator|.
name|buf
operator|+
name|STL_RXBUFSIZE
expr_stmt|;
name|portp
operator|->
name|rxstatus
operator|.
name|endbuf
operator|=
name|portp
operator|->
name|rxstatus
operator|.
name|buf
operator|+
name|STL_RXBUFSIZE
expr_stmt|;
name|portp
operator|->
name|rxstatus
operator|.
name|head
operator|=
name|portp
operator|->
name|rxstatus
operator|.
name|buf
expr_stmt|;
name|portp
operator|->
name|rxstatus
operator|.
name|tail
operator|=
name|portp
operator|->
name|rxstatus
operator|.
name|buf
expr_stmt|;
name|bzero
argument_list|(
name|portp
operator|->
name|rxstatus
operator|.
name|head
argument_list|,
name|STL_RXBUFSIZE
argument_list|)
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_ispeed
operator|=
name|STL_DEFSPEED
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_ospeed
operator|=
name|STL_DEFSPEED
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_cflag
operator|=
name|STL_DEFCFLAG
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_iflag
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_oflag
operator|=
literal|0
expr_stmt|;
name|portp
operator|->
name|initintios
operator|.
name|c_lflag
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ttydefchars
index|[
literal|0
index|]
argument_list|,
operator|&
name|portp
operator|->
name|initintios
operator|.
name|c_cc
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|portp
operator|->
name|initintios
operator|.
name|c_cc
argument_list|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|initouttios
operator|=
name|portp
operator|->
name|initintios
expr_stmt|;
name|portp
operator|->
name|dtrwait
operator|=
literal|3
operator|*
name|hz
expr_stmt|;
block|}
name|BRDDISABLE
argument_list|(
name|panelp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try to find and initialize an EasyIO board.  */
end_comment

begin_function
specifier|static
name|int
name|stl_initeio
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
name|unsigned
name|int
name|status
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_initeio(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdp
operator|->
name|ioctrl
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|1
expr_stmt|;
name|brdp
operator|->
name|iostatus
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|2
expr_stmt|;
name|brdp
operator|->
name|clk
operator|=
name|EIO_CLK
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|&
name|EIO_IDBITMASK
condition|)
block|{
case|case
name|EIO_8PORTM
case|:
name|brdp
operator|->
name|clk
operator|=
name|EIO_CLK8M
expr_stmt|;
comment|/* fall thru */
case|case
name|EIO_8PORTRS
case|:
case|case
name|EIO_8PORTDI
case|:
name|brdp
operator|->
name|nrports
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|EIO_4PORTRS
case|:
name|brdp
operator|->
name|nrports
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/*  *	Check that the supplied IRQ is good and then use it to setup the  *	programmable interrupt bits on EIO board. Also set the edge/level  *	triggered interrupt bit.  */
if|if
condition|(
operator|(
name|brdp
operator|->
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdp
operator|->
name|irq
operator|>
literal|15
operator|)
operator|||
operator|(
name|stl_vecmap
index|[
name|brdp
operator|->
name|irq
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: invalid irq=%d for brd=%d\n"
argument_list|,
name|brdp
operator|->
name|irq
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|stl_vecmap
index|[
name|brdp
operator|->
name|irq
index|]
operator||
operator|(
operator|(
name|brdp
operator|->
name|irqtype
operator|)
condition|?
name|EIO_INTLEVEL
else|:
name|EIO_INTEDGE
operator|)
operator|)
argument_list|)
expr_stmt|;
name|panelp
operator|=
operator|(
name|stlpanel_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|panelp
operator|==
operator|(
name|stlpanel_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate memory (size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|panelp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|)
expr_stmt|;
name|panelp
operator|->
name|brdnr
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|panelp
operator|->
name|panelnr
operator|=
literal|0
expr_stmt|;
name|panelp
operator|->
name|nrports
operator|=
name|brdp
operator|->
name|nrports
expr_stmt|;
name|panelp
operator|->
name|iobase
operator|=
name|brdp
operator|->
name|ioaddr1
expr_stmt|;
name|panelp
operator|->
name|hwid
operator|=
name|status
expr_stmt|;
name|brdp
operator|->
name|panels
index|[
literal|0
index|]
operator|=
name|panelp
expr_stmt|;
name|brdp
operator|->
name|nrpanels
operator|=
literal|1
expr_stmt|;
name|brdp
operator|->
name|hwid
operator|=
name|status
expr_stmt|;
name|brdp
operator|->
name|state
operator||=
name|BRD_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Try to find an ECH board and initialize it. This code is capable of  *	dealing with all types of ECH board.  */
end_comment

begin_function
specifier|static
name|int
name|stl_initech
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
name|unsigned
name|int
name|status
decl_stmt|,
name|nxtid
decl_stmt|;
name|int
name|panelnr
decl_stmt|,
name|ioaddr
decl_stmt|,
name|i
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_initech(brdp=%x)\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  *	Set up the initial board register contents for boards. This varys a  *	bit between the different board types. So we need to handle each  *	separately. Also do a check that the supplied IRQ is good.  */
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECH
condition|)
block|{
name|brdp
operator|->
name|ioctrl
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|1
expr_stmt|;
name|brdp
operator|->
name|iostatus
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|1
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ECH_IDBITMASK
operator|)
operator|!=
name|ECH_ID
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|brdp
operator|->
name|hwid
operator|=
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdp
operator|->
name|irq
operator|>
literal|15
operator|)
operator|||
operator|(
name|stl_vecmap
index|[
name|brdp
operator|->
name|irq
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: invalid irq=%d for brd=%d\n"
argument_list|,
name|brdp
operator|->
name|irq
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|status
operator|=
operator|(
operator|(
name|brdp
operator|->
name|ioaddr2
operator|&
name|ECH_ADDR2MASK
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|status
operator||=
operator|(
name|stl_vecmap
index|[
name|brdp
operator|->
name|irq
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|ioaddr1
argument_list|,
operator|(
name|status
operator||
name|ECH_BRDRESET
operator|)
argument_list|)
expr_stmt|;
name|brdp
operator|->
name|ioctrlval
operator|=
name|ECH_INTENABLE
operator||
operator|(
operator|(
name|brdp
operator|->
name|irqtype
operator|)
condition|?
name|ECH_INTLEVEL
else|:
name|ECH_INTEDGE
operator|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|brdp
operator|->
name|ioctrlval
operator||
name|ECH_BRDENABLE
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|ioaddr1
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHMC
condition|)
block|{
name|brdp
operator|->
name|ioctrl
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|0x20
expr_stmt|;
name|brdp
operator|->
name|iostatus
operator|=
name|brdp
operator|->
name|ioctrl
expr_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|brdp
operator|->
name|iostatus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ECH_IDBITMASK
operator|)
operator|!=
name|ECH_ID
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|brdp
operator|->
name|hwid
operator|=
name|status
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|irq
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdp
operator|->
name|irq
operator|>
literal|15
operator|)
operator|||
operator|(
name|stl_vecmap
index|[
name|brdp
operator|->
name|irq
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|0xff
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: invalid irq=%d for brd=%d\n"
argument_list|,
name|brdp
operator|->
name|irq
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
name|ECHMC_BRDRESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
name|ECHMC_INTENABLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHPCI
condition|)
block|{
name|brdp
operator|->
name|ioctrl
operator|=
name|brdp
operator|->
name|ioaddr1
operator|+
literal|2
expr_stmt|;
block|}
name|brdp
operator|->
name|clk
operator|=
name|ECH_CLK
expr_stmt|;
comment|/*  *	Scan through the secondary io address space looking for panels.  *	As we find'em allocate and initialize panel structures for each.  */
name|ioaddr
operator|=
name|brdp
operator|->
name|ioaddr2
expr_stmt|;
name|panelnr
operator|=
literal|0
expr_stmt|;
name|nxtid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|STL_MAXPANELS
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECHPCI
condition|)
block|{
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
name|nxtid
argument_list|)
expr_stmt|;
name|ioaddr
operator|=
name|brdp
operator|->
name|ioaddr2
expr_stmt|;
block|}
name|status
operator|=
name|inb
argument_list|(
name|ioaddr
operator|+
name|ECH_PNLSTATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|ECH_PNLIDMASK
operator|)
operator|!=
name|nxtid
condition|)
break|break;
name|panelp
operator|=
operator|(
name|stlpanel_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|,
name|M_TTYS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|panelp
operator|==
operator|(
name|stlpanel_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"STALLION: failed to allocate memory"
literal|"(size=%d)\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|panelp
argument_list|,
sizeof|sizeof
argument_list|(
name|stlpanel_t
argument_list|)
argument_list|)
expr_stmt|;
name|panelp
operator|->
name|brdnr
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|panelp
operator|->
name|panelnr
operator|=
name|panelnr
expr_stmt|;
name|panelp
operator|->
name|iobase
operator|=
name|ioaddr
expr_stmt|;
name|panelp
operator|->
name|pagenr
operator|=
name|nxtid
expr_stmt|;
name|panelp
operator|->
name|hwid
operator|=
name|status
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|ECH_PNL16PORT
condition|)
block|{
if|if
condition|(
operator|(
name|brdp
operator|->
name|nrports
operator|+
literal|16
operator|)
operator|>
literal|32
condition|)
break|break;
name|panelp
operator|->
name|nrports
operator|=
literal|16
expr_stmt|;
name|panelp
operator|->
name|ackmask
operator|=
literal|0x80
expr_stmt|;
name|brdp
operator|->
name|nrports
operator|+=
literal|16
expr_stmt|;
name|ioaddr
operator|+=
operator|(
name|EREG_BANKSIZE
operator|*
literal|2
operator|)
expr_stmt|;
name|nxtid
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|panelp
operator|->
name|nrports
operator|=
literal|8
expr_stmt|;
name|panelp
operator|->
name|ackmask
operator|=
literal|0xc0
expr_stmt|;
name|brdp
operator|->
name|nrports
operator|+=
literal|8
expr_stmt|;
name|ioaddr
operator|+=
name|EREG_BANKSIZE
expr_stmt|;
name|nxtid
operator|++
expr_stmt|;
block|}
name|brdp
operator|->
name|panels
index|[
name|panelnr
operator|++
index|]
operator|=
name|panelp
expr_stmt|;
name|brdp
operator|->
name|nrpanels
operator|++
expr_stmt|;
if|if
condition|(
name|ioaddr
operator|>=
operator|(
name|brdp
operator|->
name|ioaddr2
operator|+
literal|0x20
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|brdp
operator|->
name|brdtype
operator|==
name|BRD_ECH
condition|)
name|outb
argument_list|(
name|brdp
operator|->
name|ioctrl
argument_list|,
operator|(
name|brdp
operator|->
name|ioctrlval
operator||
name|ECH_BRDDISABLE
operator|)
argument_list|)
expr_stmt|;
name|brdp
operator|->
name|state
operator||=
name|BRD_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Initialize and configure the specified board. This firstly probes  *	for the board, if it is found then the board is initialized and  *	then all its ports are initialized as well.  */
end_comment

begin_function
specifier|static
name|int
name|stl_brdinit
parameter_list|(
name|stlbrd_t
modifier|*
name|brdp
parameter_list|)
block|{
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_brdinit(brdp=%x): unit=%d type=%d io1=%x io2=%x irq=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|brdp
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|brdtype
argument_list|,
name|brdp
operator|->
name|ioaddr1
argument_list|,
name|brdp
operator|->
name|ioaddr2
argument_list|,
name|brdp
operator|->
name|irq
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|brdp
operator|->
name|brdtype
condition|)
block|{
case|case
name|BRD_EASYIO
case|:
name|stl_initeio
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BRD_ECH
case|:
case|case
name|BRD_ECHMC
case|:
case|case
name|BRD_ECHPCI
case|:
name|stl_initech
argument_list|(
name|brdp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"STALLION: unit=%d is unknown board type=%d\n"
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|brdtype
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
name|stl_brds
index|[
name|brdp
operator|->
name|brdnr
index|]
operator|=
name|brdp
expr_stmt|;
if|if
condition|(
operator|(
name|brdp
operator|->
name|state
operator|&
name|BRD_FOUND
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("STALLION: %s board not found, unit=%d io=%x irq=%d\n", 			stl_brdnames[brdp->brdtype], brdp->brdnr, 			brdp->ioaddr1, brdp->irq);
endif|#
directive|endif
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|STL_MAXPANELS
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|panelp
operator|!=
operator|(
name|stlpanel_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|stl_initports
argument_list|(
name|brdp
argument_list|,
name|panelp
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|j
operator|<
name|panelp
operator|->
name|nrports
operator|)
condition|;
name|j
operator|++
control|)
name|brdp
operator|->
name|ports
index|[
name|k
operator|++
index|]
operator|=
name|panelp
operator|->
name|ports
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"stl%d: %s (driver version %s) unit=%d nrpanels=%d nrports=%d\n"
argument_list|,
name|brdp
operator|->
name|unitid
argument_list|,
name|stl_brdnames
index|[
name|brdp
operator|->
name|brdtype
index|]
argument_list|,
name|stl_drvversion
argument_list|,
name|brdp
operator|->
name|brdnr
argument_list|,
name|brdp
operator|->
name|nrpanels
argument_list|,
name|brdp
operator|->
name|nrports
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Return the board stats structure to user app.  */
end_comment

begin_function
specifier|static
name|int
name|stl_getbrdstats
parameter_list|(
name|caddr_t
name|data
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|stl_brdstats
operator|=
operator|*
operator|(
operator|(
name|combrd_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|stl_brdstats
operator|.
name|brd
operator|>=
name|STL_MAXBRDS
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
name|brdp
operator|=
name|stl_brds
index|[
name|stl_brdstats
operator|.
name|brd
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|stl_brdstats
argument_list|,
sizeof|sizeof
argument_list|(
name|combrd_t
argument_list|)
argument_list|)
expr_stmt|;
name|stl_brdstats
operator|.
name|brd
operator|=
name|brdp
operator|->
name|brdnr
expr_stmt|;
name|stl_brdstats
operator|.
name|type
operator|=
name|brdp
operator|->
name|brdtype
expr_stmt|;
name|stl_brdstats
operator|.
name|hwid
operator|=
name|brdp
operator|->
name|hwid
expr_stmt|;
name|stl_brdstats
operator|.
name|state
operator|=
name|brdp
operator|->
name|state
expr_stmt|;
name|stl_brdstats
operator|.
name|ioaddr
operator|=
name|brdp
operator|->
name|ioaddr1
expr_stmt|;
name|stl_brdstats
operator|.
name|ioaddr2
operator|=
name|brdp
operator|->
name|ioaddr2
expr_stmt|;
name|stl_brdstats
operator|.
name|irq
operator|=
name|brdp
operator|->
name|irq
expr_stmt|;
name|stl_brdstats
operator|.
name|nrpanels
operator|=
name|brdp
operator|->
name|nrpanels
expr_stmt|;
name|stl_brdstats
operator|.
name|nrports
operator|=
name|brdp
operator|->
name|nrports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|brdp
operator|->
name|nrpanels
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|i
index|]
expr_stmt|;
name|stl_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|panel
operator|=
name|i
expr_stmt|;
name|stl_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|hwid
operator|=
name|panelp
operator|->
name|hwid
expr_stmt|;
name|stl_brdstats
operator|.
name|panels
index|[
name|i
index|]
operator|.
name|nrports
operator|=
name|panelp
operator|->
name|nrports
expr_stmt|;
block|}
operator|*
operator|(
operator|(
name|combrd_t
operator|*
operator|)
name|data
operator|)
operator|=
name|stl_brdstats
expr_stmt|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Resolve the referenced port number into a port struct pointer.  */
end_comment

begin_function
specifier|static
name|stlport_t
modifier|*
name|stl_getport
parameter_list|(
name|int
name|brdnr
parameter_list|,
name|int
name|panelnr
parameter_list|,
name|int
name|portnr
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|stlpanel_t
modifier|*
name|panelp
decl_stmt|;
if|if
condition|(
operator|(
name|brdnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|brdnr
operator|>=
name|STL_MAXBRDS
operator|)
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
name|brdp
operator|=
name|stl_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|panelnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|panelnr
operator|>=
name|brdp
operator|->
name|nrpanels
operator|)
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
name|panelp
operator|=
name|brdp
operator|->
name|panels
index|[
name|panelnr
index|]
expr_stmt|;
if|if
condition|(
name|panelp
operator|==
operator|(
name|stlpanel_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|portnr
operator|<
literal|0
operator|)
operator|||
operator|(
name|portnr
operator|>=
name|panelp
operator|->
name|nrports
operator|)
condition|)
return|return
operator|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
operator|)
return|;
return|return
operator|(
name|panelp
operator|->
name|ports
index|[
name|portnr
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Return the port stats structure to user app. A NULL port struct  *	pointer passed in means that we need to find out from the app  *	what port to get stats for (used through board control device).  */
end_comment

begin_function
specifier|static
name|int
name|stl_getportstats
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|stl_comstats
operator|=
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|portp
operator|=
name|stl_getport
argument_list|(
name|stl_comstats
operator|.
name|brd
argument_list|,
name|stl_comstats
operator|.
name|panel
argument_list|,
name|stl_comstats
operator|.
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
block|}
name|portp
operator|->
name|stats
operator|.
name|state
operator|=
name|portp
operator|->
name|state
expr_stmt|;
comment|/*portp->stats.flags = portp->flags;*/
name|portp
operator|->
name|stats
operator|.
name|hwid
operator|=
name|portp
operator|->
name|hwid
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|ttystate
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_state
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|cflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_cflag
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|iflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_iflag
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|oflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_oflag
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|lflags
operator|=
name|portp
operator|->
name|tty
operator|.
name|t_lflag
expr_stmt|;
name|head
operator|=
name|portp
operator|->
name|tx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|tx
operator|.
name|tail
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|txbuffered
operator|=
operator|(
operator|(
name|head
operator|>=
name|tail
operator|)
condition|?
operator|(
name|head
operator|-
name|tail
operator|)
else|:
operator|(
name|STL_TXBUFSIZE
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
operator|)
operator|)
expr_stmt|;
name|head
operator|=
name|portp
operator|->
name|rx
operator|.
name|head
expr_stmt|;
name|tail
operator|=
name|portp
operator|->
name|rx
operator|.
name|tail
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|rxbuffered
operator|=
operator|(
name|head
operator|>=
name|tail
operator|)
condition|?
operator|(
name|head
operator|-
name|tail
operator|)
else|:
operator|(
name|STL_RXBUFSIZE
operator|-
operator|(
name|tail
operator|-
name|head
operator|)
operator|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|signals
operator|=
operator|(
name|unsigned
name|long
operator|)
name|stl_getsignals
argument_list|(
name|portp
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
operator|=
name|portp
operator|->
name|stats
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	Clear the port stats structure. We also return it zeroed out...  */
end_comment

begin_function
specifier|static
name|int
name|stl_clrportstats
parameter_list|(
name|stlport_t
modifier|*
name|portp
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|stl_comstats
operator|=
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|portp
operator|=
name|stl_getport
argument_list|(
name|stl_comstats
operator|.
name|brd
argument_list|,
name|stl_comstats
operator|.
name|panel
argument_list|,
name|stl_comstats
operator|.
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|portp
operator|==
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|portp
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|comstats_t
argument_list|)
argument_list|)
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|brd
operator|=
name|portp
operator|->
name|brdnr
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|panel
operator|=
name|portp
operator|->
name|panelnr
expr_stmt|;
name|portp
operator|->
name|stats
operator|.
name|port
operator|=
name|portp
operator|->
name|portnr
expr_stmt|;
operator|*
operator|(
operator|(
name|comstats_t
operator|*
operator|)
name|data
operator|)
operator|=
name|stl_comstats
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

begin_comment
comment|/*  *	The "staliomem" device is used for stats collection in this driver.  */
end_comment

begin_function
specifier|static
name|int
name|stl_memioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|unsigned
name|long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|stlbrd_t
modifier|*
name|brdp
decl_stmt|;
name|int
name|brdnr
decl_stmt|,
name|rc
decl_stmt|;
if|#
directive|if
name|DEBUG
name|printf
argument_list|(
literal|"stl_memioctl(dev=%lx,cmd=%lx,data=%p,flag=%x)\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|dev
argument_list|,
name|cmd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|brdnr
operator|=
name|dev
operator|&
literal|0x7
expr_stmt|;
name|brdp
operator|=
name|stl_brds
index|[
name|brdnr
index|]
expr_stmt|;
if|if
condition|(
name|brdp
operator|==
operator|(
name|stlbrd_t
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|brdp
operator|->
name|state
operator|==
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|rc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|COM_GETPORTSTATS
case|:
name|rc
operator|=
name|stl_getportstats
argument_list|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|COM_CLRPORTSTATS
case|:
name|rc
operator|=
name|stl_clrportstats
argument_list|(
operator|(
name|stlport_t
operator|*
operator|)
name|NULL
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|COM_GETBRDSTATS
case|:
name|rc
operator|=
name|stl_getbrdstats
argument_list|(
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|rc
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*****************************************************************************/
end_comment

end_unit

