begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-1996 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer   *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* XXX we use functions that might not exist. */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|COMPAT_43
end_ifndef

begin_error
error|#
directive|error
literal|"Unable to compile Linux-emulator due to missing COMPAT_43 option!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux_proto.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|linux_fixup
name|__P
argument_list|(
operator|(
name|long
operator|*
operator|*
name|stack_base
operator|,
expr|struct
name|image_params
operator|*
name|iparams
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_linux_fixup
name|__P
argument_list|(
operator|(
name|long
operator|*
operator|*
name|stack_base
operator|,
expr|struct
name|image_params
operator|*
name|iparams
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|linux_prepsyscall
name|__P
argument_list|(
operator|(
expr|struct
name|trapframe
operator|*
name|tf
operator|,
name|int
operator|*
name|args
operator|,
name|u_int
operator|*
name|code
operator|,
name|caddr_t
operator|*
name|params
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|linux_sendsig
name|__P
argument_list|(
operator|(
name|sig_t
name|catcher
operator|,
name|int
name|sig
operator|,
name|sigset_t
operator|*
name|mask
operator|,
name|u_long
name|code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Linux syscalls return negative errno's, we do positive and map them  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bsd_to_linux_errno
index|[
name|ELAST
operator|+
literal|1
index|]
init|=
block|{
operator|-
literal|0
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|3
block|,
operator|-
literal|4
block|,
operator|-
literal|5
block|,
operator|-
literal|6
block|,
operator|-
literal|7
block|,
operator|-
literal|8
block|,
operator|-
literal|9
block|,
operator|-
literal|10
block|,
operator|-
literal|35
block|,
operator|-
literal|12
block|,
operator|-
literal|13
block|,
operator|-
literal|14
block|,
operator|-
literal|15
block|,
operator|-
literal|16
block|,
operator|-
literal|17
block|,
operator|-
literal|18
block|,
operator|-
literal|19
block|,
operator|-
literal|20
block|,
operator|-
literal|21
block|,
operator|-
literal|22
block|,
operator|-
literal|23
block|,
operator|-
literal|24
block|,
operator|-
literal|25
block|,
operator|-
literal|26
block|,
operator|-
literal|27
block|,
operator|-
literal|28
block|,
operator|-
literal|29
block|,
operator|-
literal|30
block|,
operator|-
literal|31
block|,
operator|-
literal|32
block|,
operator|-
literal|33
block|,
operator|-
literal|34
block|,
operator|-
literal|11
block|,
operator|-
literal|115
block|,
operator|-
literal|114
block|,
operator|-
literal|88
block|,
operator|-
literal|89
block|,
operator|-
literal|90
block|,
operator|-
literal|91
block|,
operator|-
literal|92
block|,
operator|-
literal|93
block|,
operator|-
literal|94
block|,
operator|-
literal|95
block|,
operator|-
literal|96
block|,
operator|-
literal|97
block|,
operator|-
literal|98
block|,
operator|-
literal|99
block|,
operator|-
literal|100
block|,
operator|-
literal|101
block|,
operator|-
literal|102
block|,
operator|-
literal|103
block|,
operator|-
literal|104
block|,
operator|-
literal|105
block|,
operator|-
literal|106
block|,
operator|-
literal|107
block|,
operator|-
literal|108
block|,
operator|-
literal|109
block|,
operator|-
literal|110
block|,
operator|-
literal|111
block|,
operator|-
literal|40
block|,
operator|-
literal|36
block|,
operator|-
literal|112
block|,
operator|-
literal|113
block|,
operator|-
literal|39
block|,
operator|-
literal|11
block|,
operator|-
literal|87
block|,
operator|-
literal|122
block|,
operator|-
literal|116
block|,
operator|-
literal|66
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|37
block|,
operator|-
literal|38
block|,
operator|-
literal|9
block|,
operator|-
literal|6
block|,
operator|-
literal|6
block|,
operator|-
literal|43
block|,
operator|-
literal|42
block|,
operator|-
literal|75
block|,
operator|-
literal|6
block|,
operator|-
literal|84
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsd_to_linux_signal
index|[
name|LINUX_SIGTBLSZ
index|]
init|=
block|{
name|LINUX_SIGHUP
block|,
name|LINUX_SIGINT
block|,
name|LINUX_SIGQUIT
block|,
name|LINUX_SIGILL
block|,
name|LINUX_SIGTRAP
block|,
name|LINUX_SIGABRT
block|,
literal|0
block|,
name|LINUX_SIGFPE
block|,
name|LINUX_SIGKILL
block|,
name|LINUX_SIGBUS
block|,
name|LINUX_SIGSEGV
block|,
literal|0
block|,
name|LINUX_SIGPIPE
block|,
name|LINUX_SIGALRM
block|,
name|LINUX_SIGTERM
block|,
name|LINUX_SIGURG
block|,
name|LINUX_SIGSTOP
block|,
name|LINUX_SIGTSTP
block|,
name|LINUX_SIGCONT
block|,
name|LINUX_SIGCHLD
block|,
name|LINUX_SIGTTIN
block|,
name|LINUX_SIGTTOU
block|,
name|LINUX_SIGIO
block|,
name|LINUX_SIGXCPU
block|,
name|LINUX_SIGXFSZ
block|,
name|LINUX_SIGVTALRM
block|,
name|LINUX_SIGPROF
block|,
name|LINUX_SIGWINCH
block|,
literal|0
block|,
name|LINUX_SIGUSR1
block|,
name|LINUX_SIGUSR2
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|linux_to_bsd_signal
index|[
name|LINUX_SIGTBLSZ
index|]
init|=
block|{
name|SIGHUP
block|,
name|SIGINT
block|,
name|SIGQUIT
block|,
name|SIGILL
block|,
name|SIGTRAP
block|,
name|SIGABRT
block|,
name|SIGBUS
block|,
name|SIGFPE
block|,
name|SIGKILL
block|,
name|SIGUSR1
block|,
name|SIGSEGV
block|,
name|SIGUSR2
block|,
name|SIGPIPE
block|,
name|SIGALRM
block|,
name|SIGTERM
block|,
name|SIGBUS
block|,
name|SIGCHLD
block|,
name|SIGCONT
block|,
name|SIGSTOP
block|,
name|SIGTSTP
block|,
name|SIGTTIN
block|,
name|SIGTTOU
block|,
name|SIGURG
block|,
name|SIGXCPU
block|,
name|SIGXFSZ
block|,
name|SIGVTALRM
block|,
name|SIGPROF
block|,
name|SIGWINCH
block|,
name|SIGIO
block|,
name|SIGURG
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If FreeBSD& Linux have a difference of opinion about what a trap  * means, deal with it here.  */
end_comment

begin_function
specifier|static
name|int
name|translate_traps
parameter_list|(
name|int
name|signal
parameter_list|,
name|int
name|trap_code
parameter_list|)
block|{
if|if
condition|(
name|signal
operator|!=
name|SIGBUS
condition|)
return|return
name|signal
return|;
switch|switch
condition|(
name|trap_code
condition|)
block|{
case|case
name|T_PROTFLT
case|:
case|case
name|T_TSSFLT
case|:
case|case
name|T_DOUBLEFLT
case|:
case|case
name|T_PAGEFLT
case|:
return|return
name|SIGSEGV
return|;
default|default:
return|return
name|signal
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|linux_fixup
parameter_list|(
name|long
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|long
modifier|*
name|argv
decl_stmt|,
modifier|*
name|envp
decl_stmt|;
name|argv
operator|=
operator|*
name|stack_base
expr_stmt|;
name|envp
operator|=
operator|*
name|stack_base
operator|+
operator|(
name|imgp
operator|->
name|argc
operator|+
literal|1
operator|)
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|stack_base
operator|=
operator|(
name|intptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|envp
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|stack_base
operator|=
operator|(
name|intptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|argv
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|stack_base
operator|=
name|imgp
operator|->
name|argc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_linux_fixup
parameter_list|(
name|long
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf32_Auxargs
modifier|*
name|args
init|=
operator|(
name|Elf32_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
decl_stmt|;
name|long
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
operator|*
name|stack_base
operator|+
operator|(
name|imgp
operator|->
name|argc
operator|+
name|imgp
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|trace
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
block|}
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_UID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_cred
operator|->
name|p_ruid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EUID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_cred
operator|->
name|p_svuid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_GID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_cred
operator|->
name|p_rgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EGID
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_cred
operator|->
name|p_svgid
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|stack_base
operator|=
operator|(
name|long
operator|)
name|imgp
operator|->
name|argc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|_ucodesel
decl_stmt|,
name|_udatasel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine, followed by kcall  * to sigreturn routine below.  After sigreturn  * resets the signal mask, the stack, and the  * frame pointer, it returns to the user  * specified pc, psl.  */
end_comment

begin_function
specifier|static
name|void
name|linux_sendsig
parameter_list|(
name|sig_t
name|catcher
parameter_list|,
name|int
name|sig
parameter_list|,
name|sigset_t
modifier|*
name|mask
parameter_list|,
name|u_long
name|code
parameter_list|)
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|struct
name|linux_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
init|=
name|p
operator|->
name|p_sigacts
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|regs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|oonstack
operator|=
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator|&
name|SS_ONSTACK
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): linux_sendsig(%p, %d, %p, %lu)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|catcher
argument_list|,
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mask
argument_list|,
name|code
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|linux_sigframe
operator|*
operator|)
operator|(
name|p
operator|->
name|p_sigstk
operator|.
name|ss_sp
operator|+
name|p
operator|->
name|p_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|linux_sigframe
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
operator|(
expr|struct
name|linux_sigframe
operator|*
operator|)
name|regs
operator|->
name|tf_esp
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * grow() will return FALSE if the fp will not fit inside the stack 	 *	and the stack can not be grown. useracc will return FALSE 	 *	if access is denied. 	 */
if|if
condition|(
operator|(
name|grow_stack
argument_list|(
name|p
argument_list|,
operator|(
name|int
operator|)
name|fp
argument_list|)
operator|==
name|FALSE
operator|)
operator|||
operator|!
name|useracc
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linux_sigframe
argument_list|)
argument_list|,
name|VM_PROT_WRITE
argument_list|)
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|SIGACTION
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
operator|=
name|SIG_DFL
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigignore
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigcatch
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Build the argument list for the signal handler. 	 */
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
condition|)
if|if
condition|(
name|sig
operator|<=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigsize
condition|)
name|sig
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_sigtbl
index|[
name|_SIG_IDX
argument_list|(
name|sig
argument_list|)
index|]
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|catcher
expr_stmt|;
name|frame
operator|.
name|sf_sig
operator|=
name|sig
expr_stmt|;
comment|/* 	 * Build the signal context to be used by sigreturn. 	 */
name|frame
operator|.
name|sf_sc
operator|.
name|sc_mask
operator|=
name|mask
operator|->
name|__bits
index|[
literal|0
index|]
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_gs
operator|=
name|rgs
argument_list|()
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_fs
operator|=
name|regs
operator|->
name|tf_fs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_es
operator|=
name|regs
operator|->
name|tf_es
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ds
operator|=
name|regs
operator|->
name|tf_ds
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edi
operator|=
name|regs
operator|->
name|tf_edi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esi
operator|=
name|regs
operator|->
name|tf_esi
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebp
operator|=
name|regs
operator|->
name|tf_ebp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ebx
operator|=
name|regs
operator|->
name|tf_ebx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_edx
operator|=
name|regs
operator|->
name|tf_edx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ecx
operator|=
name|regs
operator|->
name|tf_ecx
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eax
operator|=
name|regs
operator|->
name|tf_eax
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eip
operator|=
name|regs
operator|->
name|tf_eip
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_cs
operator|=
name|regs
operator|->
name|tf_cs
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_eflags
operator|=
name|regs
operator|->
name|tf_eflags
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_esp_at_signal
operator|=
name|regs
operator|->
name|tf_esp
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_ss
operator|=
name|regs
operator|->
name|tf_ss
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_err
operator|=
name|regs
operator|->
name|tf_err
expr_stmt|;
name|frame
operator|.
name|sf_sc
operator|.
name|sc_trapno
operator|=
name|code
expr_stmt|;
comment|/* XXX ???? */
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|sigexit
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * Build context to run handler in. 	 */
name|regs
operator|->
name|tf_esp
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|regs
operator|->
name|tf_eip
operator|=
name|PS_STRINGS
operator|-
operator|*
operator|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
expr_stmt|;
name|regs
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_VM
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|_ucodesel
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|regs
operator|->
name|tf_fs
operator|=
name|_udatasel
expr_stmt|;
name|load_gs
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * System call to cleanup state after a signal  * has been taken.  Reset signal mask and  * stack state from context left by sendsig (above).  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|linux_sigreturn
parameter_list|(
name|p
parameter_list|,
name|args
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_sigreturn_args
modifier|*
name|args
decl_stmt|;
block|{
name|struct
name|linux_sigcontext
modifier|*
name|scp
decl_stmt|,
name|context
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|regs
decl_stmt|;
name|int
name|eflags
decl_stmt|;
name|regs
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): linux_sigreturn(%p)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|scp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * The trampoline code hands us the context. 	 * It is unsafe to keep track of it ourselves, in the event that a 	 * program jumps out of a signal handler. 	 */
name|scp
operator|=
name|SCARG
argument_list|(
name|args
argument_list|,
name|scp
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|scp
argument_list|,
operator|&
name|context
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|scp
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Check for security violations. 	 */
define|#
directive|define
name|EFLAGS_SECURE
parameter_list|(
name|ef
parameter_list|,
name|oef
parameter_list|)
value|((((ef) ^ (oef))& ~PSL_USERCHANGE) == 0)
name|eflags
operator|=
name|context
operator|.
name|sc_eflags
expr_stmt|;
comment|/* 	 * XXX do allow users to change the privileged flag PSL_RF.  The 	 * cpu sets PSL_RF in tf_eflags for faults.  Debuggers should 	 * sometimes set it there too.  tf_eflags is kept in the signal 	 * context during signal handling and there is no other place 	 * to remember it, so the PSL_RF bit may be corrupted by the 	 * signal handler without us knowing.  Corruption of the PSL_RF 	 * bit at worst causes one more or one less debugger trap, so 	 * allowing it is fairly harmless. 	 */
if|if
condition|(
operator|!
name|EFLAGS_SECURE
argument_list|(
name|eflags
operator|&
operator|~
name|PSL_RF
argument_list|,
name|regs
operator|->
name|tf_eflags
operator|&
operator|~
name|PSL_RF
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Don't allow users to load a valid privileged %cs.  Let the 	 * hardware check for invalid selectors, excess privilege in 	 * other selectors, invalid %eip's and invalid %esp's. 	 */
define|#
directive|define
name|CS_SECURE
parameter_list|(
name|cs
parameter_list|)
value|(ISPL(cs) == SEL_UPL)
if|if
condition|(
operator|!
name|CS_SECURE
argument_list|(
name|context
operator|.
name|sc_cs
argument_list|)
condition|)
block|{
name|trapsignal
argument_list|(
name|p
argument_list|,
name|SIGBUS
argument_list|,
name|T_PROTFLT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator|&=
operator|~
name|SS_ONSTACK
expr_stmt|;
name|SIGSETOLD
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|,
name|context
operator|.
name|sc_mask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal context. 	 */
comment|/* %gs was restored by the trampoline. */
name|regs
operator|->
name|tf_fs
operator|=
name|context
operator|.
name|sc_fs
expr_stmt|;
name|regs
operator|->
name|tf_es
operator|=
name|context
operator|.
name|sc_es
expr_stmt|;
name|regs
operator|->
name|tf_ds
operator|=
name|context
operator|.
name|sc_ds
expr_stmt|;
name|regs
operator|->
name|tf_edi
operator|=
name|context
operator|.
name|sc_edi
expr_stmt|;
name|regs
operator|->
name|tf_esi
operator|=
name|context
operator|.
name|sc_esi
expr_stmt|;
name|regs
operator|->
name|tf_ebp
operator|=
name|context
operator|.
name|sc_ebp
expr_stmt|;
name|regs
operator|->
name|tf_ebx
operator|=
name|context
operator|.
name|sc_ebx
expr_stmt|;
name|regs
operator|->
name|tf_edx
operator|=
name|context
operator|.
name|sc_edx
expr_stmt|;
name|regs
operator|->
name|tf_ecx
operator|=
name|context
operator|.
name|sc_ecx
expr_stmt|;
name|regs
operator|->
name|tf_eax
operator|=
name|context
operator|.
name|sc_eax
expr_stmt|;
name|regs
operator|->
name|tf_eip
operator|=
name|context
operator|.
name|sc_eip
expr_stmt|;
name|regs
operator|->
name|tf_cs
operator|=
name|context
operator|.
name|sc_cs
expr_stmt|;
name|regs
operator|->
name|tf_eflags
operator|=
name|eflags
expr_stmt|;
name|regs
operator|->
name|tf_esp
operator|=
name|context
operator|.
name|sc_esp_at_signal
expr_stmt|;
name|regs
operator|->
name|tf_ss
operator|=
name|context
operator|.
name|sc_ss
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_prepsyscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
modifier|*
name|args
parameter_list|,
name|u_int
modifier|*
name|code
parameter_list|,
name|caddr_t
modifier|*
name|params
parameter_list|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|tf
operator|->
name|tf_ebx
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|tf
operator|->
name|tf_ecx
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|tf
operator|->
name|tf_edx
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
name|tf
operator|->
name|tf_esi
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
name|tf
operator|->
name|tf_edi
expr_stmt|;
operator|*
name|params
operator|=
name|NULL
expr_stmt|;
comment|/* no copyin */
block|}
end_function

begin_decl_stmt
name|struct
name|sysentvec
name|linux_sysvec
init|=
block|{
name|LINUX_SYS_MAXSYSCALL
block|,
name|linux_sysent
block|,
literal|0xff
block|,
name|LINUX_SIGTBLSZ
block|,
name|bsd_to_linux_signal
block|,
name|ELAST
operator|+
literal|1
block|,
name|bsd_to_linux_errno
block|,
name|translate_traps
block|,
name|linux_fixup
block|,
name|linux_sendsig
block|,
name|linux_sigcode
block|,
operator|&
name|linux_szsigcode
block|,
name|linux_prepsyscall
block|,
literal|"Linux a.out"
block|,
name|aout_coredump
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sysentvec
name|elf_linux_sysvec
init|=
block|{
name|LINUX_SYS_MAXSYSCALL
block|,
name|linux_sysent
block|,
literal|0xff
block|,
name|LINUX_SIGTBLSZ
block|,
name|bsd_to_linux_signal
block|,
name|ELAST
operator|+
literal|1
block|,
name|bsd_to_linux_errno
block|,
name|translate_traps
block|,
name|elf_linux_fixup
block|,
name|linux_sendsig
block|,
name|linux_sigcode
block|,
operator|&
name|linux_szsigcode
block|,
name|linux_prepsyscall
block|,
literal|"Linux ELF"
block|,
name|elf_coredump
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_brand
init|=
block|{
literal|"Linux"
block|,
literal|"/compat/linux"
block|,
literal|"/lib/ld-linux.so.1"
block|,
operator|&
name|elf_linux_sysvec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|linux_glibc2brand
init|=
block|{
literal|"Linux"
block|,
literal|"/compat/linux"
block|,
literal|"/lib/ld-linux.so.2"
block|,
operator|&
name|elf_linux_sysvec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Elf32_Brandinfo
modifier|*
name|linux_brandlist
index|[]
init|=
block|{
operator|&
name|linux_brand
block|,
operator|&
name|linux_glibc2brand
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux_elf_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|Elf32_Brandinfo
modifier|*
modifier|*
name|brandinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf_insert_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"cannot insert Linux elf brand handler\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux-ELF exec handler installed\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf_brand_inuse
argument_list|(
operator|*
name|brandinfo
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|brandinfo
operator|=
operator|&
name|linux_brandlist
index|[
literal|0
index|]
init|;
operator|*
name|brandinfo
operator|!=
name|NULL
condition|;
operator|++
name|brandinfo
control|)
if|if
condition|(
name|elf_remove_brand_entry
argument_list|(
operator|*
name|brandinfo
argument_list|)
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"Could not deinstall ELF interpreter entry\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Linux-elf exec handler removed\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|linux_elf_mod
init|=
block|{
literal|"linuxelf"
block|,
name|linux_elf_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|linuxelf
argument_list|,
name|linux_elf_mod
argument_list|,
name|SI_SUB_EXEC
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

