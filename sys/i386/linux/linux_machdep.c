begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer   *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/sysarch.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_ipc.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_struct
struct|struct
name|linux_descriptor
block|{
name|unsigned
name|int
name|entry_number
decl_stmt|;
name|unsigned
name|long
name|base_addr
decl_stmt|;
name|unsigned
name|int
name|limit
decl_stmt|;
name|unsigned
name|int
name|seg_32bit
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|contents
range|:
literal|2
decl_stmt|;
name|unsigned
name|int
name|read_exec_only
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|limit_in_pages
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|seg_not_present
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|useable
range|:
literal|1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linux_select_argv
block|{
name|int
name|nfds
decl_stmt|;
name|fd_set
modifier|*
name|readfds
decl_stmt|;
name|fd_set
modifier|*
name|writefds
decl_stmt|;
name|fd_set
modifier|*
name|exceptfds
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_execve
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_execve_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|execve_args
name|bsd
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|args
operator|->
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%d): execve(%s)\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|args
operator|->
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd
operator|.
name|fname
operator|=
name|args
operator|->
name|path
expr_stmt|;
name|bsd
operator|.
name|argv
operator|=
name|args
operator|->
name|argp
expr_stmt|;
name|bsd
operator|.
name|envv
operator|=
name|args
operator|->
name|envp
expr_stmt|;
return|return
operator|(
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_ipc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_ipc_args
modifier|*
name|args
parameter_list|)
block|{
switch|switch
condition|(
name|args
operator|->
name|what
condition|)
block|{
case|case
name|LINUX_SEMOP
case|:
return|return
operator|(
name|linux_semop
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SEMGET
case|:
return|return
operator|(
name|linux_semget
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SEMCTL
case|:
return|return
operator|(
name|linux_semctl
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_MSGSND
case|:
return|return
operator|(
name|linux_msgsnd
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_MSGRCV
case|:
return|return
operator|(
name|linux_msgrcv
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_MSGGET
case|:
return|return
operator|(
name|linux_msgget
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_MSGCTL
case|:
return|return
operator|(
name|linux_msgctl
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SHMAT
case|:
return|return
operator|(
name|linux_shmat
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SHMDT
case|:
return|return
operator|(
name|linux_shmdt
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SHMGET
case|:
return|return
operator|(
name|linux_shmget
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
case|case
name|LINUX_SHMCTL
case|:
return|return
operator|(
name|linux_shmctl
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
block|}
name|uprintf
argument_list|(
literal|"LINUX: 'ipc' typ=%d not implemented\n"
argument_list|,
name|args
operator|->
name|what
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_select
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_select_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_select_argv
name|linux_args
decl_stmt|;
name|struct
name|linux_newselect_args
name|newsel
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|SELECT_DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): select(%x)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|args
operator|->
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|ptr
argument_list|,
operator|&
name|linux_args
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newsel
operator|.
name|nfds
operator|=
name|linux_args
operator|.
name|nfds
expr_stmt|;
name|newsel
operator|.
name|readfds
operator|=
name|linux_args
operator|.
name|readfds
expr_stmt|;
name|newsel
operator|.
name|writefds
operator|=
name|linux_args
operator|.
name|writefds
expr_stmt|;
name|newsel
operator|.
name|exceptfds
operator|=
name|linux_args
operator|.
name|exceptfds
expr_stmt|;
name|newsel
operator|.
name|timeout
operator|=
name|linux_args
operator|.
name|timeout
expr_stmt|;
return|return
operator|(
name|linux_newselect
argument_list|(
name|p
argument_list|,
operator|&
name|newsel
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_fork
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_fork_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): fork()\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|fork
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|fork_args
operator|*
operator|)
name|args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|==
literal|1
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_vfork
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_vfork_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): vfork()\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|vfork
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|vfork_args
operator|*
operator|)
name|args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Are we the child? */
if|if
condition|(
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|==
literal|1
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CLONE_VM
value|0x100
end_define

begin_define
define|#
directive|define
name|CLONE_FS
value|0x200
end_define

begin_define
define|#
directive|define
name|CLONE_FILES
value|0x400
end_define

begin_define
define|#
directive|define
name|CLONE_SIGHAND
value|0x800
end_define

begin_define
define|#
directive|define
name|CLONE_PID
value|0x1000
end_define

begin_function
name|int
name|linux_clone
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_clone_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ff
init|=
name|RFPROC
decl_stmt|;
name|struct
name|proc
modifier|*
name|p2
decl_stmt|;
name|int
name|exit_signal
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|struct
name|rfork_args
name|rf_args
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|CLONE_PID
condition|)
name|printf
argument_list|(
literal|"linux_clone(%ld): CLONE_PID not yet supported\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"linux_clone(%ld): invoked with flags %x and stack %x\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|args
operator|->
name|flags
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|args
operator|->
name|stack
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|args
operator|->
name|stack
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|exit_signal
operator|=
name|args
operator|->
name|flags
operator|&
literal|0x000000ff
expr_stmt|;
if|if
condition|(
name|exit_signal
operator|>=
name|LINUX_NSIG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|exit_signal
operator|<=
name|LINUX_SIGTBLSZ
condition|)
name|exit_signal
operator|=
name|linux_to_bsd_signal
index|[
name|_SIG_IDX
argument_list|(
name|exit_signal
argument_list|)
index|]
expr_stmt|;
comment|/* RFTHREAD probably not necessary here, but it shouldn't hurt */
name|ff
operator||=
name|RFTHREAD
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|CLONE_VM
condition|)
name|ff
operator||=
name|RFMEM
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|CLONE_SIGHAND
condition|)
name|ff
operator||=
name|RFSIGSHARE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|args
operator|->
name|flags
operator|&
name|CLONE_FILES
operator|)
condition|)
name|ff
operator||=
name|RFFDG
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|rf_args
operator|.
name|flags
operator|=
name|ff
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rfork
argument_list|(
name|p
argument_list|,
operator|&
name|rf_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p2
operator|=
name|pfind
argument_list|(
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
literal|0
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|p2
operator|->
name|p_sigparent
operator|=
name|exit_signal
expr_stmt|;
name|p2
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_esp
operator|=
operator|(
name|unsigned
name|int
operator|)
name|args
operator|->
name|stack
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"linux_clone(%ld): successful rfork to %ld\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|p2
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX move */
end_comment

begin_struct
struct|struct
name|linux_mmap_argv
block|{
name|linux_caddr_t
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|prot
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STACK_SIZE
value|(2 * 1024 * 1024)
end_define

begin_define
define|#
directive|define
name|GUARD_SIZE
value|(4 * PAGE_SIZE)
end_define

begin_function
name|int
name|linux_mmap
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_mmap_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|mmap_args
comment|/* { 		caddr_t addr; 		size_t len; 		int prot; 		int flags; 		int fd; 		long pad; 		off_t pos; 	} */
name|bsd_args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|linux_mmap_argv
name|linux_args
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|ptr
argument_list|,
operator|&
name|linux_args
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): mmap(%p, %d, %d, 0x%08x, %d, %d)"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|linux_args
operator|.
name|addr
argument_list|,
name|linux_args
operator|.
name|len
argument_list|,
name|linux_args
operator|.
name|prot
argument_list|,
name|linux_args
operator|.
name|flags
argument_list|,
name|linux_args
operator|.
name|fd
argument_list|,
name|linux_args
operator|.
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd_args
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_SHARED
condition|)
name|bsd_args
operator|.
name|flags
operator||=
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_PRIVATE
condition|)
name|bsd_args
operator|.
name|flags
operator||=
name|MAP_PRIVATE
expr_stmt|;
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_FIXED
condition|)
name|bsd_args
operator|.
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_ANON
condition|)
name|bsd_args
operator|.
name|flags
operator||=
name|MAP_ANON
expr_stmt|;
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_GROWSDOWN
condition|)
block|{
name|bsd_args
operator|.
name|flags
operator||=
name|MAP_STACK
expr_stmt|;
comment|/* The linux MAP_GROWSDOWN option does not limit auto 		 * growth of the region.  Linux mmap with this option 		 * takes as addr the inital BOS, and as len, the initial 		 * region size.  It can then grow down from addr without 		 * limit.  However, linux threads has an implicit internal 		 * limit to stack size of STACK_SIZE.  Its just not 		 * enforced explicitly in linux.  But, here we impose 		 * a limit of (STACK_SIZE - GUARD_SIZE) on the stack 		 * region, since we can do this with our mmap. 		 * 		 * Our mmap with MAP_STACK takes addr as the maximum 		 * downsize limit on BOS, and as len the max size of 		 * the region.  It them maps the top SGROWSIZ bytes, 		 * and autgrows the region down, up to the limit 		 * in addr. 		 * 		 * If we don't use the MAP_STACK option, the effect 		 * of this code is to allocate a stack region of a 		 * fixed size of (STACK_SIZE - GUARD_SIZE). 		 */
comment|/* This gives us TOS */
name|bsd_args
operator|.
name|addr
operator|=
name|linux_args
operator|.
name|addr
operator|+
name|linux_args
operator|.
name|len
expr_stmt|;
comment|/* This gives us our maximum stack size */
if|if
condition|(
name|linux_args
operator|.
name|len
operator|>
name|STACK_SIZE
operator|-
name|GUARD_SIZE
condition|)
name|bsd_args
operator|.
name|len
operator|=
name|linux_args
operator|.
name|len
expr_stmt|;
else|else
name|bsd_args
operator|.
name|len
operator|=
name|STACK_SIZE
operator|-
name|GUARD_SIZE
expr_stmt|;
comment|/* This gives us a new BOS.  If we're using VM_STACK, then 		 * mmap will just map the top SGROWSIZ bytes, and let 		 * the stack grow down to the limit at BOS.  If we're 		 * not using VM_STACK we map the full stack, since we 		 * don't have a way to autogrow it. 		 */
name|bsd_args
operator|.
name|addr
operator|-=
name|bsd_args
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
name|bsd_args
operator|.
name|addr
operator|=
name|linux_args
operator|.
name|addr
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
name|linux_args
operator|.
name|len
expr_stmt|;
block|}
name|bsd_args
operator|.
name|prot
operator|=
name|linux_args
operator|.
name|prot
operator||
name|PROT_READ
expr_stmt|;
comment|/* always required */
if|if
condition|(
name|linux_args
operator|.
name|flags
operator|&
name|LINUX_MAP_ANON
condition|)
name|bsd_args
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|bsd_args
operator|.
name|fd
operator|=
name|linux_args
operator|.
name|fd
expr_stmt|;
name|bsd_args
operator|.
name|pos
operator|=
name|linux_args
operator|.
name|pos
expr_stmt|;
name|bsd_args
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"-> (%p, %d, %d, 0x%08x, %d, %d)\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bsd_args
operator|.
name|addr
argument_list|,
name|bsd_args
operator|.
name|len
argument_list|,
name|bsd_args
operator|.
name|prot
argument_list|,
name|bsd_args
operator|.
name|flags
argument_list|,
name|bsd_args
operator|.
name|fd
argument_list|,
operator|(
name|int
operator|)
name|bsd_args
operator|.
name|pos
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|mmap
argument_list|(
name|p
argument_list|,
operator|&
name|bsd_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_pipe
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_pipe_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|reg_edx
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): pipe(*)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|reg_edx
operator|=
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
expr_stmt|;
name|error
operator|=
name|pipe
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|reg_edx
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|p
operator|->
name|p_retval
argument_list|,
name|args
operator|->
name|pipefds
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|reg_edx
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|p
operator|->
name|p_retval
index|[
literal|1
index|]
operator|=
name|reg_edx
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_ioperm
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_ioperm_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sysarch_args
name|sa
decl_stmt|;
name|struct
name|i386_ioperm_args
modifier|*
name|iia
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|iia
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i386_ioperm_args
argument_list|)
argument_list|)
expr_stmt|;
name|iia
operator|->
name|start
operator|=
name|args
operator|->
name|start
expr_stmt|;
name|iia
operator|->
name|length
operator|=
name|args
operator|->
name|length
expr_stmt|;
name|iia
operator|->
name|enable
operator|=
name|args
operator|->
name|enable
expr_stmt|;
name|sa
operator|.
name|op
operator|=
name|I386_SET_IOPERM
expr_stmt|;
name|sa
operator|.
name|parms
operator|=
operator|(
name|char
operator|*
operator|)
name|iia
expr_stmt|;
return|return
operator|(
name|sysarch
argument_list|(
name|p
argument_list|,
operator|&
name|sa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_iopl
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_iopl_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|level
operator|<
literal|0
operator|||
name|args
operator|->
name|level
operator|>
literal|3
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|securelevel
operator|>
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator|=
operator|(
name|p
operator|->
name|p_md
operator|.
name|md_regs
operator|->
name|tf_eflags
operator|&
operator|~
name|PSL_IOPL
operator|)
operator||
operator|(
name|args
operator|->
name|level
operator|*
operator|(
name|PSL_IOPL
operator|/
literal|3
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_modify_ldt
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_modify_ldt_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|struct
name|sysarch_args
name|args
decl_stmt|;
name|struct
name|i386_ldt_args
modifier|*
name|ldt
decl_stmt|;
name|struct
name|linux_descriptor
name|ld
decl_stmt|;
name|union
name|descriptor
modifier|*
name|desc
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|ptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|uap
operator|->
name|func
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* read_ldt */
name|ldt
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldt
argument_list|)
argument_list|)
expr_stmt|;
name|ldt
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|ldt
operator|->
name|descs
operator|=
name|uap
operator|->
name|ptr
expr_stmt|;
name|ldt
operator|->
name|num
operator|=
name|uap
operator|->
name|bytecount
operator|/
sizeof|sizeof
argument_list|(
expr|union
name|descriptor
argument_list|)
expr_stmt|;
name|args
operator|.
name|op
operator|=
name|I386_GET_LDT
expr_stmt|;
name|args
operator|.
name|parms
operator|=
operator|(
name|char
operator|*
operator|)
name|ldt
expr_stmt|;
name|error
operator|=
name|sysarch
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|*=
sizeof|sizeof
argument_list|(
expr|union
name|descriptor
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
comment|/* write_ldt */
case|case
literal|0x11
case|:
comment|/* write_ldt */
if|if
condition|(
name|uap
operator|->
name|bytecount
operator|!=
sizeof|sizeof
argument_list|(
name|ld
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|ptr
argument_list|,
operator|&
name|ld
argument_list|,
sizeof|sizeof
argument_list|(
name|ld
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ldt
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ldt
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|ldt
operator|->
name|start
operator|=
name|ld
operator|.
name|entry_number
expr_stmt|;
name|ldt
operator|->
name|descs
operator|=
name|desc
expr_stmt|;
name|ldt
operator|->
name|num
operator|=
literal|1
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_lolimit
operator|=
operator|(
name|ld
operator|.
name|limit
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_hilimit
operator|=
operator|(
name|ld
operator|.
name|limit
operator|&
literal|0x000f0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_lobase
operator|=
operator|(
name|ld
operator|.
name|base_addr
operator|&
literal|0x00ffffff
operator|)
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_hibase
operator|=
operator|(
name|ld
operator|.
name|base_addr
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_type
operator|=
name|SDT_MEMRO
operator||
operator|(
operator|(
name|ld
operator|.
name|read_exec_only
operator|^
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|ld
operator|.
name|contents
operator|<<
literal|2
operator|)
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_dpl
operator|=
literal|3
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_p
operator|=
operator|(
name|ld
operator|.
name|seg_not_present
operator|^
literal|1
operator|)
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_xx
operator|=
literal|0
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_def32
operator|=
name|ld
operator|.
name|seg_32bit
expr_stmt|;
name|desc
operator|->
name|sd
operator|.
name|sd_gran
operator|=
name|ld
operator|.
name|limit_in_pages
expr_stmt|;
name|args
operator|.
name|op
operator|=
name|I386_SET_LDT
expr_stmt|;
name|args
operator|.
name|parms
operator|=
operator|(
name|char
operator|*
operator|)
name|ldt
expr_stmt|;
name|error
operator|=
name|sysarch
argument_list|(
name|p
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
block|{
name|printf
argument_list|(
literal|"linux: modify_ldt needs kernel option USER_LDT\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sigaction
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_sigaction_args
modifier|*
name|args
parameter_list|)
block|{
name|linux_osigaction_t
name|osa
decl_stmt|;
name|linux_sigaction_t
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): sigaction(%d, %p, %p)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|args
operator|->
name|sig
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|nsa
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|osa
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|nsa
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|nsa
argument_list|,
operator|&
name|osa
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_osigaction_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|act
operator|.
name|lsa_handler
operator|=
name|osa
operator|.
name|lsa_handler
expr_stmt|;
name|act
operator|.
name|lsa_flags
operator|=
name|osa
operator|.
name|lsa_flags
expr_stmt|;
name|act
operator|.
name|lsa_restorer
operator|=
name|osa
operator|.
name|lsa_restorer
expr_stmt|;
name|LINUX_SIGEMPTYSET
argument_list|(
name|act
operator|.
name|lsa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|lsa_mask
operator|.
name|__bits
index|[
literal|0
index|]
operator|=
name|osa
operator|.
name|lsa_mask
expr_stmt|;
block|}
name|error
operator|=
name|linux_do_sigaction
argument_list|(
name|p
argument_list|,
name|args
operator|->
name|sig
argument_list|,
name|args
operator|->
name|nsa
condition|?
operator|&
name|act
else|:
name|NULL
argument_list|,
name|args
operator|->
name|osa
condition|?
operator|&
name|oact
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|osa
operator|!=
name|NULL
operator|&&
operator|!
name|error
condition|)
block|{
name|osa
operator|.
name|lsa_handler
operator|=
name|oact
operator|.
name|lsa_handler
expr_stmt|;
name|osa
operator|.
name|lsa_flags
operator|=
name|oact
operator|.
name|lsa_flags
expr_stmt|;
name|osa
operator|.
name|lsa_restorer
operator|=
name|oact
operator|.
name|lsa_restorer
expr_stmt|;
name|osa
operator|.
name|lsa_mask
operator|=
name|oact
operator|.
name|lsa_mask
operator|.
name|__bits
index|[
literal|0
index|]
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|osa
argument_list|,
name|args
operator|->
name|osa
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_osigaction_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Linux has two extra args, restart and oldmask.  We dont use these,  * but it seems that "restart" is actually a context pointer that  * enables the signal to happen with a different register set.  */
end_comment

begin_function
name|int
name|linux_sigsuspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_sigsuspend_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sigsuspend_args
name|bsd
decl_stmt|;
name|sigset_t
modifier|*
name|sigmask
decl_stmt|;
name|linux_sigset_t
name|mask
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): sigsuspend(%08lx)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|LINUX_SIGEMPTYSET
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|mask
operator|.
name|__bits
index|[
literal|0
index|]
operator|=
name|args
operator|->
name|mask
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|mask
argument_list|,
name|sigmask
argument_list|)
expr_stmt|;
name|bsd
operator|.
name|sigmask
operator|=
name|sigmask
expr_stmt|;
return|return
operator|(
name|sigsuspend
argument_list|(
name|p
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_rt_sigsuspend
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_rt_sigsuspend_args
modifier|*
name|uap
decl_stmt|;
block|{
name|linux_sigset_t
name|lmask
decl_stmt|;
name|sigset_t
modifier|*
name|bmask
decl_stmt|;
name|struct
name|sigsuspend_args
name|bsd
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): rt_sigsuspend(%p, %d)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|newset
argument_list|,
name|uap
operator|->
name|sigsetsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|sigsetsize
operator|!=
sizeof|sizeof
argument_list|(
name|linux_sigset_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|newset
argument_list|,
operator|&
name|lmask
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|lmask
argument_list|,
name|bmask
argument_list|)
expr_stmt|;
name|bsd
operator|.
name|sigmask
operator|=
name|bmask
expr_stmt|;
return|return
operator|(
name|sigsuspend
argument_list|(
name|p
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_pause
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|linux_pause_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sigsuspend_args
name|bsd
decl_stmt|;
name|sigset_t
modifier|*
name|sigmask
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%d): pause()\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sigmask
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sigmask
operator|=
name|p
operator|->
name|p_sigmask
expr_stmt|;
name|bsd
operator|.
name|sigmask
operator|=
name|sigmask
expr_stmt|;
return|return
operator|(
name|sigsuspend
argument_list|(
name|p
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sigaltstack
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_sigaltstack_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|sigaltstack_args
name|bsd
decl_stmt|;
name|stack_t
modifier|*
name|ss
decl_stmt|,
modifier|*
name|oss
decl_stmt|;
name|linux_stack_t
name|lss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"Linux-emul(%ld): sigaltstack(%p, %p)\n"
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|uap
operator|->
name|uss
argument_list|,
name|uap
operator|->
name|uoss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uss
argument_list|,
operator|&
name|lss
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_stack_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ss
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|stack_t
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_sp
operator|=
name|lss
operator|.
name|ss_sp
expr_stmt|;
name|ss
operator|->
name|ss_size
operator|=
name|lss
operator|.
name|ss_size
expr_stmt|;
name|ss
operator|->
name|ss_flags
operator|=
name|lss
operator|.
name|ss_flags
expr_stmt|;
name|oss
operator|=
operator|(
name|uap
operator|->
name|uoss
operator|!=
name|NULL
operator|)
condition|?
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
name|stack_t
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
name|bsd
operator|.
name|ss
operator|=
name|ss
expr_stmt|;
name|bsd
operator|.
name|oss
operator|=
name|oss
expr_stmt|;
name|error
operator|=
name|sigaltstack
argument_list|(
name|p
argument_list|,
operator|&
name|bsd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|oss
operator|!=
name|NULL
condition|)
block|{
name|lss
operator|.
name|ss_sp
operator|=
name|oss
operator|->
name|ss_sp
expr_stmt|;
name|lss
operator|.
name|ss_size
operator|=
name|oss
operator|->
name|ss_size
expr_stmt|;
name|lss
operator|.
name|ss_flags
operator|=
name|oss
operator|->
name|ss_flags
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lss
argument_list|,
name|uap
operator|->
name|uoss
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_stack_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

