begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * commenced: Sun Sep 27 18:14:01 PDT 1992  *  *      $Id: aha1742.c,v 1.14 1994/01/11 07:24:32 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_comment
comment|/* don't laugh, it compiles as a program too.. look */
end_comment

begin_include
include|#
directive|include
file|<ahb.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<i386/include/pio.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_comment
comment|/*
comment|*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NetBSD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
name|int
name|Debugger
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DDB */
end_comment

begin_define
define|#
directive|define
name|Debugger
parameter_list|()
value|panic("should call debugger here (adaptec.c)")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"ddb.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* netbsd */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* KERNEL */
end_comment

begin_define
define|#
directive|define
name|NAHB
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* kernel */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NetBSD
end_ifndef

begin_typedef
typedef|typedef
name|timeout_func_t
name|timeout_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|unsigned
name|long
name|int
name|physaddr
typedef|;
end_typedef

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|AHB_ECB_MAX
value|32
end_define

begin_comment
comment|/* store up to 32ECBs at any one time     */
end_comment

begin_comment
comment|/* in aha1742 H/W ( Not MAX ? )         */
end_comment

begin_define
define|#
directive|define
name|ECB_HASH_SIZE
value|32
end_define

begin_comment
comment|/* when we have a physical addr. for      */
end_comment

begin_comment
comment|/* a ecb and need to find the ecb in    */
end_comment

begin_comment
comment|/* space, look it up in the hash table  */
end_comment

begin_define
define|#
directive|define
name|ECB_HASH_SHIFT
value|9
end_define

begin_comment
comment|/* only hash on multiples of 512  */
end_comment

begin_define
define|#
directive|define
name|ECB_HASH
parameter_list|(
name|x
parameter_list|)
value|((((long int)(x))>>ECB_HASH_SHIFT) % ECB_HASH_SIZE)
end_define

begin_define
define|#
directive|define
name|AHB_NSEG
value|33
end_define

begin_comment
comment|/* number of dma segments supported       */
end_comment

begin_comment
comment|/*  * AHA1740 standard EISA Host ID regs  (Offset from slot base)  */
end_comment

begin_define
define|#
directive|define
name|HID0
value|0xC80
end_define

begin_comment
comment|/* 0,1: msb of ID2, 3-7: ID1      */
end_comment

begin_define
define|#
directive|define
name|HID1
value|0xC81
end_define

begin_comment
comment|/* 0-4: ID3, 4-7: LSB ID2         */
end_comment

begin_define
define|#
directive|define
name|HID2
value|0xC82
end_define

begin_comment
comment|/* product, 0=174[20] 1 = 1744    */
end_comment

begin_define
define|#
directive|define
name|HID3
value|0xC83
end_define

begin_comment
comment|/* firmware revision              */
end_comment

begin_define
define|#
directive|define
name|CHAR1
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|(((B1>>2)& 0x1F) | '@')
end_define

begin_define
define|#
directive|define
name|CHAR2
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|(((B1<<3)& 0x18) | ((B2>>5)& 0x7)|'@')
end_define

begin_define
define|#
directive|define
name|CHAR3
parameter_list|(
name|B1
parameter_list|,
name|B2
parameter_list|)
value|((B2& 0x1F) | '@')
end_define

begin_comment
comment|/* AHA1740 EISA board control registers (Offset from slot base) */
end_comment

begin_define
define|#
directive|define
name|EBCTRL
value|0xC84
end_define

begin_define
define|#
directive|define
name|CDEN
value|0x01
end_define

begin_comment
comment|/*  * AHA1740 EISA board mode registers (Offset from slot base)  */
end_comment

begin_define
define|#
directive|define
name|PORTADDR
value|0xCC0
end_define

begin_define
define|#
directive|define
name|PORTADDR_ENHANCED
value|0x80
end_define

begin_define
define|#
directive|define
name|BIOSADDR
value|0xCC1
end_define

begin_define
define|#
directive|define
name|INTDEF
value|0xCC2
end_define

begin_define
define|#
directive|define
name|SCSIDEF
value|0xCC3
end_define

begin_define
define|#
directive|define
name|BUSDEF
value|0xCC4
end_define

begin_define
define|#
directive|define
name|RESV0
value|0xCC5
end_define

begin_define
define|#
directive|define
name|RESV1
value|0xCC6
end_define

begin_define
define|#
directive|define
name|RESV2
value|0xCC7
end_define

begin_comment
comment|/**** bit definitions for INTDEF ****/
end_comment

begin_define
define|#
directive|define
name|INT9
value|0x00
end_define

begin_define
define|#
directive|define
name|INT10
value|0x01
end_define

begin_define
define|#
directive|define
name|INT11
value|0x02
end_define

begin_define
define|#
directive|define
name|INT12
value|0x03
end_define

begin_define
define|#
directive|define
name|INT14
value|0x05
end_define

begin_define
define|#
directive|define
name|INT15
value|0x06
end_define

begin_define
define|#
directive|define
name|INTHIGH
value|0x08
end_define

begin_comment
comment|/* int high=ACTIVE (else edge) */
end_comment

begin_define
define|#
directive|define
name|INTEN
value|0x10
end_define

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x0F
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_define
define|#
directive|define
name|RSTPWR
value|0x10
end_define

begin_comment
comment|/* reset scsi bus on power up or reset */
end_comment

begin_comment
comment|/**** bit definitions for BUSDEF ****/
end_comment

begin_define
define|#
directive|define
name|B0uS
value|0x00
end_define

begin_comment
comment|/* give up bus immediatly */
end_comment

begin_define
define|#
directive|define
name|B4uS
value|0x01
end_define

begin_comment
comment|/* delay 4uSec. */
end_comment

begin_define
define|#
directive|define
name|B8uS
value|0x02
end_define

begin_comment
comment|/*  * AHA1740 ENHANCED mode mailbox control regs (Offset from slot base)  */
end_comment

begin_define
define|#
directive|define
name|MBOXOUT0
value|0xCD0
end_define

begin_define
define|#
directive|define
name|MBOXOUT1
value|0xCD1
end_define

begin_define
define|#
directive|define
name|MBOXOUT2
value|0xCD2
end_define

begin_define
define|#
directive|define
name|MBOXOUT3
value|0xCD3
end_define

begin_define
define|#
directive|define
name|ATTN
value|0xCD4
end_define

begin_define
define|#
directive|define
name|G2CNTRL
value|0xCD5
end_define

begin_define
define|#
directive|define
name|G2INTST
value|0xCD6
end_define

begin_define
define|#
directive|define
name|G2STAT
value|0xCD7
end_define

begin_define
define|#
directive|define
name|MBOXIN0
value|0xCD8
end_define

begin_define
define|#
directive|define
name|MBOXIN1
value|0xCD9
end_define

begin_define
define|#
directive|define
name|MBOXIN2
value|0xCDA
end_define

begin_define
define|#
directive|define
name|MBOXIN3
value|0xCDB
end_define

begin_define
define|#
directive|define
name|G2STAT2
value|0xCDC
end_define

begin_comment
comment|/*  * Bit definitions for the 5 control/status registers  */
end_comment

begin_define
define|#
directive|define
name|ATTN_TARGET
value|0x0F
end_define

begin_define
define|#
directive|define
name|ATTN_OPCODE
value|0xF0
end_define

begin_define
define|#
directive|define
name|OP_IMMED
value|0x10
end_define

begin_define
define|#
directive|define
name|AHB_TARG_RESET
value|0x80
end_define

begin_define
define|#
directive|define
name|OP_START_ECB
value|0x40
end_define

begin_define
define|#
directive|define
name|OP_ABORT_ECB
value|0x50
end_define

begin_define
define|#
directive|define
name|G2CNTRL_SET_HOST_READY
value|0x20
end_define

begin_define
define|#
directive|define
name|G2CNTRL_CLEAR_EISA_INT
value|0x40
end_define

begin_define
define|#
directive|define
name|G2CNTRL_HARD_RESET
value|0x80
end_define

begin_define
define|#
directive|define
name|G2INTST_TARGET
value|0x0F
end_define

begin_define
define|#
directive|define
name|G2INTST_INT_STAT
value|0xF0
end_define

begin_define
define|#
directive|define
name|AHB_ECB_OK
value|0x10
end_define

begin_define
define|#
directive|define
name|AHB_ECB_RECOVERED
value|0x50
end_define

begin_define
define|#
directive|define
name|AHB_HW_ERR
value|0x70
end_define

begin_define
define|#
directive|define
name|AHB_IMMED_OK
value|0xA0
end_define

begin_define
define|#
directive|define
name|AHB_ECB_ERR
value|0xC0
end_define

begin_define
define|#
directive|define
name|AHB_ASN
value|0xD0
end_define

begin_comment
comment|/* for target mode */
end_comment

begin_define
define|#
directive|define
name|AHB_IMMED_ERR
value|0xE0
end_define

begin_define
define|#
directive|define
name|G2STAT_BUSY
value|0x01
end_define

begin_define
define|#
directive|define
name|G2STAT_INT_PEND
value|0x02
end_define

begin_define
define|#
directive|define
name|G2STAT_MBOX_EMPTY
value|0x04
end_define

begin_define
define|#
directive|define
name|G2STAT2_HOST_READY
value|0x01
end_define

begin_struct
struct|struct
name|ahb_dma_seg
block|{
name|physaddr
name|addr
decl_stmt|;
name|long
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ahb_ecb_status
block|{
name|u_short
name|status
decl_stmt|;
define|#
directive|define
name|ST_DON
value|0x0001
define|#
directive|define
name|ST_DU
value|0x0002
define|#
directive|define
name|ST_QF
value|0x0008
define|#
directive|define
name|ST_SC
value|0x0010
define|#
directive|define
name|ST_DO
value|0x0020
define|#
directive|define
name|ST_CH
value|0x0040
define|#
directive|define
name|ST_INT
value|0x0080
define|#
directive|define
name|ST_ASA
value|0x0100
define|#
directive|define
name|ST_SNS
value|0x0200
define|#
directive|define
name|ST_INI
value|0x0800
define|#
directive|define
name|ST_ME
value|0x1000
define|#
directive|define
name|ST_ECA
value|0x4000
name|u_char
name|ha_status
decl_stmt|;
define|#
directive|define
name|HS_OK
value|0x00
define|#
directive|define
name|HS_CMD_ABORTED_HOST
value|0x04
define|#
directive|define
name|HS_CMD_ABORTED_ADAPTER
value|0x05
define|#
directive|define
name|HS_TIMED_OUT
value|0x11
define|#
directive|define
name|HS_HARDWARE_ERR
value|0x20
define|#
directive|define
name|HS_SCSI_RESET_ADAPTER
value|0x22
define|#
directive|define
name|HS_SCSI_RESET_INCOMING
value|0x23
name|u_char
name|targ_status
decl_stmt|;
define|#
directive|define
name|TS_OK
value|0x00
define|#
directive|define
name|TS_CHECK_CONDITION
value|0x02
define|#
directive|define
name|TS_BUSY
value|0x08
name|u_long
name|resid_count
decl_stmt|;
name|u_long
name|resid_addr
decl_stmt|;
name|u_short
name|addit_status
decl_stmt|;
name|u_char
name|sense_len
decl_stmt|;
name|u_char
name|unused
index|[
literal|9
index|]
decl_stmt|;
name|u_char
name|cdb
index|[
literal|6
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ecb
block|{
name|u_char
name|opcode
decl_stmt|;
define|#
directive|define
name|ECB_SCSI_OP
value|0x01
name|u_char
label|:
literal|4
expr_stmt|;
name|u_char
name|options
range|:
literal|3
decl_stmt|;
name|u_char
label|:
literal|1
expr_stmt|;
name|short
name|opt1
decl_stmt|;
define|#
directive|define
name|ECB_CNE
value|0x0001
define|#
directive|define
name|ECB_DI
value|0x0080
define|#
directive|define
name|ECB_SES
value|0x0400
define|#
directive|define
name|ECB_S_G
value|0x1000
define|#
directive|define
name|ECB_DSB
value|0x4000
define|#
directive|define
name|ECB_ARS
value|0x8000
name|short
name|opt2
decl_stmt|;
define|#
directive|define
name|ECB_LUN
value|0x0007
define|#
directive|define
name|ECB_TAG
value|0x0008
define|#
directive|define
name|ECB_TT
value|0x0030
define|#
directive|define
name|ECB_ND
value|0x0040
define|#
directive|define
name|ECB_DAT
value|0x0100
define|#
directive|define
name|ECB_DIR
value|0x0200
define|#
directive|define
name|ECB_ST
value|0x0400
define|#
directive|define
name|ECB_CHK
value|0x0800
define|#
directive|define
name|ECB_REC
value|0x4000
define|#
directive|define
name|ECB_NRB
value|0x8000
name|u_short
name|unused1
decl_stmt|;
name|physaddr
name|data
decl_stmt|;
name|u_long
name|datalen
decl_stmt|;
name|physaddr
name|status
decl_stmt|;
name|physaddr
name|chain
decl_stmt|;
name|short
name|unused2
decl_stmt|;
name|short
name|unused3
decl_stmt|;
name|physaddr
name|sense
decl_stmt|;
name|u_char
name|senselen
decl_stmt|;
name|u_char
name|cdblen
decl_stmt|;
name|short
name|cksum
decl_stmt|;
name|u_char
name|cdb
index|[
literal|12
index|]
decl_stmt|;
comment|/*-----------------end of hardware supported fields----------------*/
name|struct
name|ecb
modifier|*
name|next
decl_stmt|;
comment|/* in free list */
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
comment|/* the scsi_xfer for this cmd */
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|ECB_FREE
value|0
define|#
directive|define
name|ECB_ACTIVE
value|1
define|#
directive|define
name|ECB_ABORTED
value|2
define|#
directive|define
name|ECB_IMMED
value|4
define|#
directive|define
name|ECB_IMMED_FAIL
value|8
name|struct
name|ahb_dma_seg
name|ahb_dma
index|[
name|AHB_NSEG
index|]
decl_stmt|;
name|struct
name|ahb_ecb_status
name|ecb_status
decl_stmt|;
name|struct
name|scsi_sense_data
name|ecb_sense
decl_stmt|;
name|struct
name|ecb
modifier|*
name|nexthash
decl_stmt|;
name|physaddr
name|hashkey
decl_stmt|;
comment|/* physaddr of this struct */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ahb_data
block|{
name|int
name|flags
decl_stmt|;
define|#
directive|define
name|AHB_INIT
value|0x01;
name|int
name|baseport
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecbhash
index|[
name|ECB_HASH_SIZE
index|]
decl_stmt|;
name|struct
name|ecb
modifier|*
name|free_ecb
decl_stmt|;
name|int
name|our_id
decl_stmt|;
comment|/* our scsi id */
name|int
name|vect
decl_stmt|;
name|struct
name|ecb
modifier|*
name|immed_ecb
decl_stmt|;
comment|/* an outstanding immediete command */
name|struct
name|scsi_link
name|sc_link
decl_stmt|;
name|int
name|numecbs
decl_stmt|;
block|}
modifier|*
name|ahbdata
index|[
name|NAHB
index|]
struct|;
end_struct

begin_function_decl
name|int
name|ahbprobe
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ahbprobe1
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ahb_attach
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ahb_init
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ahbintr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int32
name|ahb_scsi_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ahb_timeout
parameter_list|(
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ahb_done
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ecb
modifier|*
name|cheat
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahb_free_ecb
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ahbminphys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ecb
modifier|*
name|ahb_ecb_phys_kv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|u_int32
name|ahb_adapter_info
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_SLOTS
value|8
end_define

begin_comment
comment|/* XXX should this be 16?? Need EISA spec */
end_comment

begin_expr_stmt
specifier|static
name|ahb_slot
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* slot last board was found in */
end_comment

begin_expr_stmt
specifier|static
name|ahb_unit
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ahb_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AHB_SHOWECBS
value|0x01
end_define

begin_define
define|#
directive|define
name|AHB_SHOWINTS
value|0x02
end_define

begin_define
define|#
directive|define
name|AHB_SHOWCMDS
value|0x04
end_define

begin_define
define|#
directive|define
name|AHB_SHOWMISC
value|0x08
end_define

begin_define
define|#
directive|define
name|FAIL
value|1
end_define

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_decl_stmt
name|struct
name|isa_driver
name|ahbdriver
init|=
block|{
name|ahbprobe
block|,
name|ahb_attach
block|,
literal|"ahb"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|scsi_adapter
name|ahb_switch
init|=
block|{
name|ahb_scsi_cmd
block|,
name|ahbminphys
block|,
literal|0
block|,
literal|0
block|,
name|ahb_adapter_info
block|,
literal|"ahb"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
name|struct
name|scsi_device
name|ahb_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"ahb"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|KERNEL
end_ifndef

begin_function
name|main
parameter_list|()
block|{
name|printf
argument_list|(
literal|"ahb_data size is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahb_data
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ecb size is %d\n"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*KERNEL */
end_comment

begin_comment
comment|/*  * Function to send a command out through a mailbox  */
end_comment

begin_function
name|void
name|ahb_send_mbox
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|target
parameter_list|,
name|struct
name|ecb
modifier|*
name|ecb
parameter_list|)
block|{
name|int
name|port
init|=
name|ahbdata
index|[
name|unit
index|]
operator|->
name|baseport
decl_stmt|;
name|int
name|wait
init|=
literal|300
decl_stmt|;
comment|/* 3ms should be enough */
name|int
name|stport
init|=
name|port
operator|+
name|G2STAT
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
operator|(
name|G2STAT_BUSY
operator||
name|G2STAT_MBOX_EMPTY
operator|)
operator|)
operator|==
operator|(
name|G2STAT_MBOX_EMPTY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aha1742"
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|port
operator|+
name|MBOXOUT0
argument_list|,
name|KVTOPHYS
argument_list|(
name|ecb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* don't know this will work */
name|outb
argument_list|(
name|port
operator|+
name|ATTN
argument_list|,
name|opcode
operator||
name|target
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when in poll mode  */
end_comment

begin_function
name|int
name|ahb_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
comment|/* in msec  */
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahb
operator|->
name|baseport
decl_stmt|;
name|int
name|stport
init|=
name|port
operator|+
name|G2STAT
decl_stmt|;
name|retry
label|:
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|G2STAT_INT_PEND
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|cheat
operator|!=
name|ahb_ecb_phys_kv
argument_list|(
name|ahb
argument_list|,
name|inl
argument_list|(
name|port
operator|+
name|MBOXIN0
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"discarding %x "
argument_list|,
name|inl
argument_list|(
name|port
operator|+
name|MBOXIN0
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
name|G2CNTRL_CLEAR_EISA_INT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50000
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
comment|/* don't know this will work */
name|ahbintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function to  send an immediate type command to the adapter  */
end_comment

begin_function
name|void
name|ahb_send_immed
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|target
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
name|int
name|port
init|=
name|ahbdata
index|[
name|unit
index|]
operator|->
name|baseport
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|int
name|stport
init|=
name|port
operator|+
name|G2STAT
decl_stmt|;
name|int
name|wait
init|=
literal|100
decl_stmt|;
comment|/* 1 ms enough? */
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
operator|(
name|G2STAT_BUSY
operator||
name|G2STAT_MBOX_EMPTY
operator|)
operator|)
operator|==
operator|(
name|G2STAT_MBOX_EMPTY
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"aha1742"
argument_list|)
expr_stmt|;
block|}
name|outl
argument_list|(
name|port
operator|+
name|MBOXOUT0
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* don't know this will work */
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
name|G2CNTRL_SET_HOST_READY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|ATTN
argument_list|,
name|OP_IMMED
operator||
name|target
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the slots looking for a board we recognise  * If we find one, note it's address (slot) and call  * the actual probe routine to check it out.  */
end_comment

begin_function
name|int
name|ahbprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|port
decl_stmt|;
name|u_char
name|byte1
decl_stmt|,
name|byte2
decl_stmt|,
name|byte3
decl_stmt|;
name|ahb_slot
operator|++
expr_stmt|;
while|while
condition|(
name|ahb_slot
operator|<=
name|MAX_SLOTS
condition|)
block|{
name|port
operator|=
literal|0x1000
operator|*
name|ahb_slot
expr_stmt|;
name|byte1
operator|=
name|inb
argument_list|(
name|port
operator|+
name|HID0
argument_list|)
expr_stmt|;
name|byte2
operator|=
name|inb
argument_list|(
name|port
operator|+
name|HID1
argument_list|)
expr_stmt|;
name|byte3
operator|=
name|inb
argument_list|(
name|port
operator|+
name|HID2
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte1
operator|==
literal|0xff
condition|)
block|{
name|ahb_slot
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|CHAR1
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
operator|==
literal|'A'
operator|)
operator|&&
operator|(
name|CHAR2
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
operator|==
literal|'D'
operator|)
operator|&&
operator|(
name|CHAR3
argument_list|(
name|byte1
argument_list|,
name|byte2
argument_list|)
operator|==
literal|'P'
operator|)
operator|&&
operator|(
operator|(
name|byte3
operator|==
literal|0
operator|)
operator|||
operator|(
name|byte3
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|dev
operator|->
name|id_iobase
operator|=
name|port
expr_stmt|;
return|return
name|ahbprobe1
argument_list|(
name|dev
argument_list|)
return|;
block|}
name|ahb_slot
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the device can be found at the port given  * and if so, set it up ready for further work  * as an argument, takes the isa_device structure from  * autoconf.c.  */
end_comment

begin_function
name|int
name|ahbprobe1
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
name|int
name|unit
init|=
name|ahb_unit
decl_stmt|;
name|struct
name|ahb_data
modifier|*
name|ahb
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NAHB
condition|)
block|{
name|printf
argument_list|(
literal|"ahb: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|dev
operator|->
name|id_unit
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|ahbdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ahb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahb_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahb
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|ahb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahb_data
argument_list|)
argument_list|)
expr_stmt|;
name|ahbdata
index|[
name|unit
index|]
operator|=
name|ahb
expr_stmt|;
name|ahb
operator|->
name|baseport
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
comment|/* 	 * Try initialise a unit at this location 	 * sets up dma and bus speed, loads ahb->vect 	 */
if|if
condition|(
name|ahb_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahbdata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ahb
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If it's there, put in it's interrupt vectors 	 */
name|dev
operator|->
name|id_irq
operator|=
operator|(
literal|1
operator|<<
name|ahb
operator|->
name|vect
operator|)
expr_stmt|;
name|dev
operator|->
name|id_drq
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use EISA dma */
name|ahb_unit
operator|++
expr_stmt|;
return|return
literal|0x1000
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahb_attach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NetBSD
name|int
name|unit
init|=
name|dev
operator|->
name|id_masunit
decl_stmt|;
else|#
directive|else
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
endif|#
directive|endif
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|ahb
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|ahb
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahb
operator|->
name|our_id
expr_stmt|;
name|ahb
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahb_switch
expr_stmt|;
name|ahb
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahb_dev
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ahb
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and it's capabilities  */
end_comment

begin_function
name|u_int32
name|ahb_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|int
name|ahbintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
name|u_char
name|ahbstat
decl_stmt|;
name|int
name|target
decl_stmt|;
name|long
name|int
name|mboxval
decl_stmt|;
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahb
operator|->
name|baseport
decl_stmt|;
ifdef|#
directive|ifdef
name|AHBDEBUG
name|printf
argument_list|(
literal|"ahbintr "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHBDEBUG */
while|while
condition|(
name|inb
argument_list|(
name|port
operator|+
name|G2STAT
argument_list|)
operator|&
name|G2STAT_INT_PEND
condition|)
block|{
comment|/* 		 * First get all the information and then  		 * acknowlege the interrupt 		 */
name|ahbstat
operator|=
name|inb
argument_list|(
name|port
operator|+
name|G2INTST
argument_list|)
expr_stmt|;
name|target
operator|=
name|ahbstat
operator|&
name|G2INTST_TARGET
expr_stmt|;
name|stat
operator|=
name|ahbstat
operator|&
name|G2INTST_INT_STAT
expr_stmt|;
name|mboxval
operator|=
name|inl
argument_list|(
name|port
operator|+
name|MBOXIN0
argument_list|)
expr_stmt|;
comment|/* don't know this will work */
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
name|G2CNTRL_CLEAR_EISA_INT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHBDEBUG
name|printf
argument_list|(
literal|"status = 0x%x "
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHBDEBUG */
comment|/* 		 * Process the completed operation 		 */
if|if
condition|(
name|stat
operator|==
name|AHB_ECB_OK
condition|)
block|{
comment|/* common case is fast */
name|ecb
operator|=
name|ahb_ecb_phys_kv
argument_list|(
name|ahb
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|AHB_IMMED_OK
case|:
name|ecb
operator|=
name|ahb
operator|->
name|immed_ecb
expr_stmt|;
name|ahb
operator|->
name|immed_ecb
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AHB_IMMED_ERR
case|:
name|ecb
operator|=
name|ahb
operator|->
name|immed_ecb
expr_stmt|;
name|ecb
operator|->
name|flags
operator||=
name|ECB_IMMED_FAIL
expr_stmt|;
name|ahb
operator|->
name|immed_ecb
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AHB_ASN
case|:
comment|/* for target mode */
name|printf
argument_list|(
literal|"ahb%d: Unexpected ASN interrupt(%x)\n"
argument_list|,
name|unit
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
name|ecb
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AHB_HW_ERR
case|:
name|printf
argument_list|(
literal|"ahb%d: Hardware error interrupt(%x)\n"
argument_list|,
name|unit
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
name|ecb
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AHB_ECB_RECOVERED
case|:
name|ecb
operator|=
name|ahb_ecb_phys_kv
argument_list|(
name|ahb
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
break|break;
case|case
name|AHB_ECB_ERR
case|:
name|ecb
operator|=
name|ahb_ecb_phys_kv
argument_list|(
name|ahb
argument_list|,
name|mboxval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unknown return from ahb%d(%x)\n"
argument_list|,
name|unit
argument_list|,
name|ahbstat
argument_list|)
expr_stmt|;
name|ecb
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ecb
condition|)
block|{
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWCMDS
condition|)
block|{
name|show_scsi_cmd
argument_list|(
name|ecb
operator|->
name|xs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahb_debug
operator|&
name|AHB_SHOWECBS
operator|)
operator|&&
name|ecb
condition|)
name|printf
argument_list|(
literal|"<int ecb(%x)>"
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHBDEBUG */
name|untimeout
argument_list|(
operator|(
name|timeout_t
operator|)
name|ahb_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|)
expr_stmt|;
name|ahb_done
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
operator|(
operator|(
name|stat
operator|==
name|AHB_ECB_OK
operator|)
condition|?
name|SUCCESS
else|:
name|FAIL
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * We have a ecb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahb_done
parameter_list|(
name|unit
parameter_list|,
name|ecb
parameter_list|,
name|state
parameter_list|)
name|int
name|unit
decl_stmt|,
name|state
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
name|struct
name|ahb_ecb_status
modifier|*
name|stat
init|=
operator|&
name|ecb
operator|->
name|ecb_status
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ecb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahb_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, put the results of the operation 	 * into the xfer and call whoever started it 	 */
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_IMMED
condition|)
block|{
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_IMMED_FAIL
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|state
operator|==
name|SUCCESS
operator|)
operator|||
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|s1
operator|=
operator|&
operator|(
name|ecb
operator|->
name|ecb_sense
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|stat
operator|->
name|ha_status
condition|)
block|{
switch|switch
condition|(
name|stat
operator|->
name|ha_status
condition|)
block|{
case|case
name|HS_SCSI_RESET_ADAPTER
case|:
break|break;
case|case
name|HS_SCSI_RESET_INCOMING
case|:
break|break;
case|case
name|HS_CMD_ABORTED_HOST
case|:
comment|/* No response */
case|case
name|HS_CMD_ABORTED_ADAPTER
case|:
comment|/* No response */
break|break;
case|case
name|HS_TIMED_OUT
case|:
comment|/* No response */
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"timeout reported back\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*AHBDEBUG */
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected ha_status: %x\n"
argument_list|,
name|stat
operator|->
name|ha_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*AHBDEBUG */
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|stat
operator|->
name|targ_status
condition|)
block|{
case|case
name|TS_CHECK_CONDITION
case|:
comment|/* structure copy!!!!! */
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
break|break;
case|case
name|TS_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|stat
operator|->
name|targ_status
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*AHBDEBUG */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|ahb_free_ecb
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A ecb (and hence a mbx-out is put onto the   * free list.  */
end_comment

begin_function
name|void
name|ahb_free_ecb
parameter_list|(
name|unit
parameter_list|,
name|ecb
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ecb
operator|->
name|next
operator|=
name|ahb
operator|->
name|free_ecb
expr_stmt|;
name|ahb
operator|->
name|free_ecb
operator|=
name|ecb
expr_stmt|;
name|ecb
operator|->
name|flags
operator|=
name|ECB_FREE
expr_stmt|;
comment|/* 	 * If there were none, wake abybody waiting for 	 * one to come free, starting with queued entries 	 */
if|if
condition|(
operator|!
name|ecb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahb
operator|->
name|free_ecb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free ecb   * If there are none, see if we can allocate a  * new one. If so, put it in the hash table too  * otherwise either return an error or sleep  */
end_comment

begin_function
name|struct
name|ecb
modifier|*
name|ahb_get_ecb
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecbp
decl_stmt|;
name|int
name|hashnum
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one. 	 */
while|while
condition|(
operator|!
operator|(
name|ecbp
operator|=
name|ahb
operator|->
name|free_ecb
operator|)
condition|)
block|{
if|if
condition|(
name|ahb
operator|->
name|numecbs
operator|<
name|AHB_ECB_MAX
condition|)
block|{
name|ecbp
operator|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ecbp
condition|)
block|{
name|bzero
argument_list|(
name|ecbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ecb
argument_list|)
argument_list|)
expr_stmt|;
name|ahb
operator|->
name|numecbs
operator|++
expr_stmt|;
name|ecbp
operator|->
name|flags
operator|=
name|ECB_ACTIVE
expr_stmt|;
comment|/* 				 * put in the phystokv hash table 				 * Never gets taken out. 				 */
name|ecbp
operator|->
name|hashkey
operator|=
name|KVTOPHYS
argument_list|(
name|ecbp
argument_list|)
expr_stmt|;
name|hashnum
operator|=
name|ECB_HASH
argument_list|(
name|ecbp
operator|->
name|hashkey
argument_list|)
expr_stmt|;
name|ecbp
operator|->
name|nexthash
operator|=
name|ahb
operator|->
name|ecbhash
index|[
name|hashnum
index|]
expr_stmt|;
name|ahb
operator|->
name|ecbhash
index|[
name|hashnum
index|]
operator|=
name|ecbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahb%d: Can't malloc ECB\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahb
operator|->
name|free_ecb
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahbecb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ecbp
condition|)
block|{
comment|/* Get ECB from from free list */
name|ahb
operator|->
name|free_ecb
operator|=
name|ecbp
operator|->
name|next
expr_stmt|;
name|ecbp
operator|->
name|flags
operator|=
name|ECB_ACTIVE
expr_stmt|;
block|}
name|gottit
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|ecbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a physical address, find the ecb that  * it corresponds to:  */
end_comment

begin_function
name|struct
name|ecb
modifier|*
name|ahb_ecb_phys_kv
parameter_list|(
name|ahb
parameter_list|,
name|ecb_phys
parameter_list|)
name|struct
name|ahb_data
modifier|*
name|ahb
decl_stmt|;
name|physaddr
name|ecb_phys
decl_stmt|;
block|{
name|int
name|hashnum
init|=
name|ECB_HASH
argument_list|(
name|ecb_phys
argument_list|)
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecbp
init|=
name|ahb
operator|->
name|ecbhash
index|[
name|hashnum
index|]
decl_stmt|;
while|while
condition|(
name|ecbp
condition|)
block|{
if|if
condition|(
name|ecbp
operator|->
name|hashkey
operator|==
name|ecb_phys
condition|)
break|break;
name|ecbp
operator|=
name|ecbp
operator|->
name|nexthash
expr_stmt|;
block|}
return|return
name|ecbp
return|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahb_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|port
init|=
name|ahb
operator|->
name|baseport
decl_stmt|;
name|int
name|intdef
decl_stmt|;
name|int
name|wait
init|=
literal|1000
decl_stmt|;
comment|/* 1 sec enough? */
name|int
name|i
decl_stmt|;
name|int
name|stport
init|=
name|port
operator|+
name|G2STAT
decl_stmt|;
define|#
directive|define
name|NO_NO
value|1
ifdef|#
directive|ifdef
name|NO_NO
comment|/* 	 * reset board, If it doesn't respond, assume  	 * that it's not there.. good for the probe 	 */
name|outb
argument_list|(
name|port
operator|+
name|EBCTRL
argument_list|,
name|CDEN
argument_list|)
expr_stmt|;
comment|/* enable full card */
name|outb
argument_list|(
name|port
operator|+
name|PORTADDR
argument_list|,
name|PORTADDR_ENHANCED
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
name|G2CNTRL_HARD_RESET
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|G2STAT_BUSY
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"ahb_init: No answer from aha1742 board\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHBDEBUG */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|i
operator|=
name|inb
argument_list|(
name|port
operator|+
name|MBOXIN0
argument_list|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"self test failed, val = 0x%x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
endif|#
directive|endif
while|while
condition|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|G2STAT_INT_PEND
condition|)
block|{
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|G2CNTRL
argument_list|,
name|G2CNTRL_CLEAR_EISA_INT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|port
operator|+
name|EBCTRL
argument_list|,
name|CDEN
argument_list|)
expr_stmt|;
comment|/* enable full card */
name|outb
argument_list|(
name|port
operator|+
name|PORTADDR
argument_list|,
name|PORTADDR_ENHANCED
argument_list|)
expr_stmt|;
comment|/* 	 * Assume we have a board at this stage 	 * setup dma channel from jumpers and save int 	 * level 	 */
name|printf
argument_list|(
literal|"ahb%d: reading board settings, "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|intdef
operator|=
name|inb
argument_list|(
name|port
operator|+
name|INTDEF
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intdef
operator|&
literal|0x07
condition|)
block|{
case|case
name|INT9
case|:
name|ahb
operator|->
name|vect
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|INT10
case|:
name|ahb
operator|->
name|vect
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|INT11
case|:
name|ahb
operator|->
name|vect
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|ahb
operator|->
name|vect
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|INT14
case|:
name|ahb
operator|->
name|vect
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|INT15
case|:
name|ahb
operator|->
name|vect
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"int=%d\n"
argument_list|,
name|ahb
operator|->
name|vect
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
operator|+
name|INTDEF
argument_list|,
operator|(
name|intdef
operator||
name|INTEN
operator|)
argument_list|)
expr_stmt|;
comment|/* make sure we can interrupt */
comment|/* who are we on the scsi bus? */
name|ahb
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|port
operator|+
name|SCSIDEF
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahb
operator|->
name|flags
operator||=
name|AHB_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* min */
end_comment

begin_function
name|void
name|ahbminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHB_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHB_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address. Also needs the unit, target  * and lu  */
end_comment

begin_function
name|int32
name|ahb_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|struct
name|ahb_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahb_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * get a ecb (mbox-out) to use. If the transfer 	 * is from a buf (possibly from interrupt time) 	 * then we can't allow it to sleep 	 */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: Already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahb%d: Not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ecb
operator|=
name|ahb_get_ecb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|cheat
operator|=
name|ecb
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start ecb(%x)\n"
operator|,
name|ecb
operator|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
comment|/* 	 * If it's a reset, we need to do an 'immediate' 	 * command, and store it's ecb for later 	 * if there is already an immediate waiting,  	 * then WE must wait 	 */
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|ecb
operator|->
name|flags
operator||=
name|ECB_IMMED
expr_stmt|;
if|if
condition|(
name|ahb
operator|->
name|immed_ecb
condition|)
block|{
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|ahb
operator|->
name|immed_ecb
operator|=
name|ecb
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ahb_send_immed
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|AHB_TARG_RESET
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|timeout_t
operator|)
name|ahb_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
else|else
block|{
name|ahb_send_immed
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|AHB_TARG_RESET
argument_list|)
expr_stmt|;
comment|/* 			 * If we can't use interrupts, poll on completion 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"wait\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahb_poll
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
name|ahb_free_ecb
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
block|}
comment|/* 	 * Put all the arguments for the xfer in the ecb 	 */
name|ecb
operator|->
name|opcode
operator|=
name|ECB_SCSI_OP
expr_stmt|;
name|ecb
operator|->
name|opt1
operator|=
name|ECB_SES
operator||
name|ECB_DSB
operator||
name|ECB_ARS
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
name|ecb
operator|->
name|opt1
operator||=
name|ECB_S_G
expr_stmt|;
block|}
name|ecb
operator|->
name|opt2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator||
name|ECB_NRB
expr_stmt|;
name|ecb
operator|->
name|cdblen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|ecb
operator|->
name|sense
operator|=
name|KVTOPHYS
argument_list|(
operator|&
operator|(
name|ecb
operator|->
name|ecb_sense
operator|)
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|senselen
operator|=
sizeof|sizeof
argument_list|(
name|ecb
operator|->
name|ecb_sense
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|status
operator|=
name|KVTOPHYS
argument_list|(
operator|&
operator|(
name|ecb
operator|->
name|ecb_status
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|ecb
operator|->
name|data
operator|=
name|KVTOPHYS
argument_list|(
name|ecb
operator|->
name|ahb_dma
argument_list|)
expr_stmt|;
name|sg
operator|=
name|ecb
operator|->
name|ahb_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TFS
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHB_NSEG
operator|)
condition|)
block|{
name|sg
operator|->
name|addr
operator|=
operator|(
name|physaddr
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|xs
operator|->
name|datalen
operator|+=
name|sg
operator|->
name|len
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x@0x%x)"
operator|,
name|iovp
operator|->
name|iov_len
operator|,
name|iovp
operator|->
name|iov_base
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/*TFS */
block|{
comment|/* 			 * Set up the scatter gather block 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%d @0x%x:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHB_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%x"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 					 * This page is contiguous (physically) with    					 * the the last, just extend the length              					 */
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * next page isn't contiguous, finish the seg  				 */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of iov/kv decision */
name|ecb
operator|->
name|datalen
operator|=
name|seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ahb_dma_seg
argument_list|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"ahb_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|AHB_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahb_free_ecb
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data xfer, use non S/G values */
name|ecb
operator|->
name|data
operator|=
operator|(
name|physaddr
operator|)
literal|0
expr_stmt|;
name|ecb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
name|ecb
operator|->
name|chain
operator|=
operator|(
name|physaddr
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Put the scsi command in the ecb and start it 	 */
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
name|ecb
operator|->
name|cdb
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
comment|/* 	 * Usually return SUCCESSFULLY QUEUED 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ahb_send_mbox
argument_list|(
name|unit
argument_list|,
name|OP_START_ECB
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
operator|(
name|timeout_t
operator|)
name|ahb_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* 	 * If we can't use interrupts, poll on completion 	 */
name|ahb_send_mbox
argument_list|(
name|unit
argument_list|,
name|OP_START_ECB
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_wait\n"
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ahb_poll
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|ahb_send_mbox
argument_list|(
name|unit
argument_list|,
name|OP_ABORT_ECB
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahb_poll
argument_list|(
name|unit
argument_list|,
literal|2000
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"abort failed in wait\n"
argument_list|)
expr_stmt|;
name|ahb_free_ecb
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
comment|/* something (?) else finished */
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahb_timeout
parameter_list|(
name|caddr_t
name|arg1
parameter_list|)
block|{
name|struct
name|ecb
modifier|*
name|ecb
init|=
operator|(
expr|struct
name|ecb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|ahb_data
modifier|*
name|ahb
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|unit
operator|=
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|ahb
operator|=
name|ahbdata
index|[
name|unit
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"ahb%d:%d:%d (%s%d) timed out "
argument_list|,
name|unit
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHBDEBUG
if|if
condition|(
name|ahb_debug
operator|&
name|AHB_SHOWECBS
condition|)
name|ahb_print_active_ecb
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHBDEBUG */
comment|/* 	 * If it's immediate, don't try abort it  	 */
if|if
condition|(
name|ecb
operator|->
name|flags
operator|&
name|ECB_IMMED
condition|)
block|{
name|ecb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ecb
operator|->
name|flags
operator||=
name|ECB_IMMED_FAIL
expr_stmt|;
name|ahb_done
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If it has been through before, then 	 * a previous abort has failed, don't 	 * try abort again 	 */
if|if
condition|(
name|ecb
operator|->
name|flags
operator|==
name|ECB_ABORTED
condition|)
block|{
comment|/* 		 * abort timed out 		 */
name|printf
argument_list|(
literal|"AGAIN"
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ecb
operator|->
name|ecb_status
operator|.
name|ha_status
operator|=
name|HS_CMD_ABORTED_HOST
expr_stmt|;
name|ahb_done
argument_list|(
name|unit
argument_list|,
name|ecb
argument_list|,
name|FAIL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahb_send_mbox
argument_list|(
name|unit
argument_list|,
name|OP_ABORT_ECB
argument_list|,
name|ecb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|ecb
argument_list|)
expr_stmt|;
comment|/* 2 secs for the abort */
name|timeout
argument_list|(
operator|(
name|timeout_t
operator|)
name|ahb_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ecb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ecb
operator|->
name|flags
operator|=
name|ECB_ABORTED
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AHBDEBUG
end_ifdef

begin_function
name|void
name|ahb_print_ecb
parameter_list|(
name|ecb
parameter_list|)
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"ecb:%x op:%x cmdlen:%d senlen:%d\n"
argument_list|,
name|ecb
argument_list|,
name|ecb
operator|->
name|opcode
argument_list|,
name|ecb
operator|->
name|cdblen
argument_list|,
name|ecb
operator|->
name|senselen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	datlen:%d hstat:%x tstat:%x flags:%x\n"
argument_list|,
name|ecb
operator|->
name|datalen
argument_list|,
name|ecb
operator|->
name|ecb_status
operator|.
name|ha_status
argument_list|,
name|ecb
operator|->
name|ecb_status
operator|.
name|targ_status
argument_list|,
name|ecb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|show_scsi_cmd
argument_list|(
name|ecb
operator|->
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahb_print_active_ecb
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ahb_data
modifier|*
name|ahb
init|=
name|ahbdata
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|ecb
modifier|*
name|ecb
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|ECB_HASH_SIZE
condition|)
block|{
name|ecb
operator|=
name|ahb
operator|->
name|ecbhash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ecb
condition|)
block|{
if|if
condition|(
name|ecb
operator|->
name|flags
operator|!=
name|ECB_FREE
condition|)
block|{
name|ahb_print_ecb
argument_list|(
name|ecb
argument_list|)
expr_stmt|;
block|}
name|ecb
operator|=
name|ecb
operator|->
name|nexthash
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*AHBDEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*KERNEL */
end_comment

end_unit

