begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * LP (Laptop Package)  *   * Copyright (c) 1994 by HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  *  * This software may be used, modified, copied, and distributed, in  * both source and binary form provided that the above copyright and  * these terms are retained. Under no circumstances is the author   * responsible for the proper functioning of this software, nor does   * the author assume any responsibility for damages incurred with its   * use.  *  * Sep, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)  */
end_comment

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|"apm_setup.h"
end_include

begin_comment
comment|/* static data */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apm_initialized
init|=
literal|0
decl_stmt|,
name|active
init|=
literal|0
decl_stmt|,
name|halt_cpu
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|minorversion
decl_stmt|,
name|majorversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs32_base
decl_stmt|,
name|cs16_base
decl_stmt|,
name|ds_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs_limit
decl_stmt|,
name|ds_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|intversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|idle_cpu
decl_stmt|,
name|disabled
decl_stmt|,
name|disengaged
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Map version number to integer (keeps ordering of version numbers) */
end_comment

begin_define
define|#
directive|define
name|INTVERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major)*100 + (minor))
end_define

begin_decl_stmt
specifier|static
name|timeout_t
name|apm_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setup APM GDT discriptors */
end_comment

begin_function
specifier|static
name|void
name|setup_apm_gdt
parameter_list|(
name|u_int
name|code32_base
parameter_list|,
name|u_int
name|code16_base
parameter_list|,
name|u_int
name|data_base
parameter_list|,
name|u_int
name|code_limit
parameter_list|,
name|u_int
name|data_limit
parameter_list|)
block|{
comment|/* setup 32bit code segment */
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code32_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup 16bit code segment */
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code16_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup data segment */
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_base
operator|=
name|data_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|data_limit
expr_stmt|;
comment|/* reflect these changes on physical GDT */
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE32_SEL
argument_list|,
name|gdt
operator|+
name|GAPMCODE32_SEL
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE16_SEL
argument_list|,
name|gdt
operator|+
name|GAPMCODE16_SEL
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMDATA_SEL
argument_list|,
name|gdt
operator|+
name|GAPMDATA_SEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 48bit far pointer */
end_comment

begin_struct
struct|struct
name|addr48
block|{
name|u_long
name|offset
decl_stmt|;
name|u_short
name|segment
decl_stmt|;
block|}
name|apm_addr
struct|;
end_struct

begin_comment
comment|/* register structure for BIOS call */
end_comment

begin_union
union|union
name|real_regs
block|{
struct|struct
name|xregs
block|{
name|u_short
name|ax
decl_stmt|;
name|u_short
name|bx
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|cx
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|dx
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|si
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|di
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|cf
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
comment|/* carry */
block|}
name|x
struct|;
struct|struct
name|hlregs
block|{
name|u_char
name|al
decl_stmt|;
name|u_char
name|ah
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|bl
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|bh
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|cl
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|ch
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|dl
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_char
name|dh
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|si
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|di
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
name|u_short
name|cf
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
decl_stmt|;
comment|/* carry */
block|}
name|hl
struct|;
block|}
union|;
end_union

begin_comment
comment|/* call APM BIOS */
end_comment

begin_function_decl
specifier|extern
name|void
name|call_apm
parameter_list|(
name|union
name|real_regs
modifier|*
name|regs
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|u_char
name|apm_errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable/disable power management */
end_comment

begin_function
specifier|static
name|int
name|apm_enable_disable_pm
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|union
name|real_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|hl
operator|.
name|ah
operator|=
name|APM_BIOS
expr_stmt|;
name|regs
operator|.
name|hl
operator|.
name|al
operator|=
name|APM_ENABLEDISABLEPM
expr_stmt|;
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
block|}
else|else
block|{
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
literal|0xffff
expr_stmt|;
comment|/* APM version 1.0 only */
block|}
name|regs
operator|.
name|x
operator|.
name|cx
operator|=
name|enable
expr_stmt|;
name|call_apm
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|x
operator|.
name|cf
return|;
block|}
end_function

begin_comment
comment|/* engage/disengage power management (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_engage_disengage_pm
parameter_list|(
name|int
name|engage
parameter_list|)
block|{
name|union
name|real_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|hl
operator|.
name|ah
operator|=
name|APM_BIOS
expr_stmt|;
name|regs
operator|.
name|hl
operator|.
name|al
operator|=
name|APM_ENGAGEDISENGAGEPM
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|cx
operator|=
name|engage
expr_stmt|;
name|call_apm
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
name|regs
operator|.
name|x
operator|.
name|cf
return|;
block|}
end_function

begin_comment
comment|/* get PM event */
end_comment

begin_function
specifier|static
name|u_int
name|apm_getevent
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|real_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|hl
operator|.
name|ah
operator|=
name|APM_BIOS
expr_stmt|;
name|regs
operator|.
name|hl
operator|.
name|al
operator|=
name|APM_GETPMEVENT
expr_stmt|;
name|call_apm
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|x
operator|.
name|cf
condition|)
block|{
if|#
directive|if
literal|0
block|printf("No event: errcode = %d\n", apm_errno);
endif|#
directive|endif
return|return
name|PMEV_NOEVENT
return|;
block|}
return|return
operator|(
name|u_int
operator|)
name|regs
operator|.
name|x
operator|.
name|bx
return|;
block|}
end_function

begin_comment
comment|/*  * In many cases, the first event that occured after resume, needs  * special treatment. This binary flag make this process possible.  * Initial value of this variable is 1, because the bootstrap  * condition is equivalent to resumed condition for the power  * manager.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|resumed_event
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* suspend entire system */
end_comment

begin_function
specifier|static
name|int
name|apm_suspend_system
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|real_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|hl
operator|.
name|ah
operator|=
name|APM_BIOS
expr_stmt|;
name|regs
operator|.
name|hl
operator|.
name|al
operator|=
name|APM_SETPWSTATE
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|cx
operator|=
name|PMST_SUSPEND
expr_stmt|;
name|call_apm
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|x
operator|.
name|cf
condition|)
block|{
name|printf
argument_list|(
literal|"Entire system suspend failure: errcode = %d\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|resumed_event
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* APM Battery low handler */
end_comment

begin_function
specifier|static
name|void
name|apm_battery_low
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Currently, this routine has not been implemented. Sorry... */
block|}
end_function

begin_comment
comment|/* APM driver calls some functions automatically when the system wakes up */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_hook
parameter_list|(
name|apm_hook_func_t
name|list
parameter_list|)
block|{
name|apm_hook_func_t
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|func
operator|)
operator|)
operator|(
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: APM hook of %s failed"
argument_list|,
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* APM hook manager */
end_comment

begin_function
specifier|static
name|apm_hook_func_t
name|apm_hook_init
parameter_list|(
name|apm_hook_func_t
modifier|*
name|list
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|apm_hook_func_t
name|p
decl_stmt|,
name|prev
decl_stmt|,
name|new_node
decl_stmt|;
name|pl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|new_node
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_node
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"Can't allocate device buffer for apm_resume_hook."
argument_list|)
expr_stmt|;
block|}
name|new_node
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|new_node
operator|->
name|name
operator|=
name|name
expr_stmt|;
if|#
directive|if
literal|0
block|new_node->next = *list; 	*list = new_node;
else|#
directive|else
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|->
name|order
operator|>
name|order
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|new_node
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|new_node
expr_stmt|;
block|}
else|else
block|{
name|new_node
operator|->
name|next
operator|=
name|prev
operator|->
name|next
expr_stmt|;
name|prev
operator|->
name|next
operator|=
name|new_node
expr_stmt|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
name|new_node
return|;
block|}
end_function

begin_function
name|void
name|apm_hook_delete
parameter_list|(
name|apm_hook_func_t
modifier|*
name|list
parameter_list|,
name|apm_hook_func_t
name|delete_node
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|apm_hook_func_t
name|p
decl_stmt|,
name|prev
decl_stmt|;
name|pl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
if|if
condition|(
name|p
operator|==
name|delete_node
condition|)
block|{
goto|goto
name|deleteit
goto|;
block|}
block|}
name|panic
argument_list|(
literal|"Tried to delete unregistered apm_resume_hook."
argument_list|)
expr_stmt|;
goto|goto
name|nosuchnode
goto|;
name|deleteit
label|:
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|list
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|free
argument_list|(
name|delete_node
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|nosuchnode
label|:
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|suspend_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default APM hook functions */
end_comment

begin_function
specifier|static
name|int
name|apm_default_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|second
decl_stmt|,
name|minute
decl_stmt|,
name|hour
decl_stmt|;
name|struct
name|timeval
name|resume_time
decl_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
name|microtime
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
operator|-
name|suspend_time
operator|.
name|tv_sec
expr_stmt|;
name|hour
operator|=
name|second
operator|/
literal|3600
expr_stmt|;
name|second
operator|%=
literal|3600
expr_stmt|;
name|minute
operator|=
name|second
operator|/
literal|60
expr_stmt|;
name|second
operator|%=
literal|60
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resumed from suspended mode (slept %02d:%02d:%02d)\n"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_default_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
if|#
directive|if
literal|0
block|pl = splhigh(); 	sync(curproc, NULL, NULL); 	splx(pl);
endif|#
directive|endif
name|microtime
argument_list|(
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* list structure for hook */
end_comment

begin_decl_stmt
specifier|static
name|apm_hook_func_t
name|apm_resume_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|apm_hook_func_t
name|apm_suspend_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* execute resume hook */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_resume_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|apm_execute_hook
argument_list|(
name|apm_resume_hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a node on resume hook */
end_comment

begin_function
name|apm_hook_func_t
name|apm_resume_hook_init
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|apm_hook_init
argument_list|(
operator|&
name|apm_resume_hook
argument_list|,
name|func
argument_list|,
name|name
argument_list|,
name|order
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* delete a node from resume hook */
end_comment

begin_function
name|void
name|apm_resume_hook_delete
parameter_list|(
name|apm_hook_func_t
name|delete_node
parameter_list|)
block|{
name|apm_hook_delete
argument_list|(
operator|&
name|apm_resume_hook
argument_list|,
name|delete_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* execute suspend hook */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_suspend_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|apm_execute_hook
argument_list|(
name|apm_suspend_hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* add a node on resume hook */
end_comment

begin_function
name|apm_hook_func_t
name|apm_suspend_hook_init
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|order
parameter_list|)
block|{
return|return
name|apm_hook_init
argument_list|(
operator|&
name|apm_suspend_hook
argument_list|,
name|func
argument_list|,
name|name
argument_list|,
name|order
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* delete a node from resume hook */
end_comment

begin_function
name|void
name|apm_suspend_hook_delete
parameter_list|(
name|apm_hook_func_t
name|delete_node
parameter_list|)
block|{
name|apm_hook_delete
argument_list|(
operator|&
name|apm_suspend_hook
argument_list|,
name|delete_node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get APM information */
end_comment

begin_function
specifier|static
name|int
name|apm_get_info
parameter_list|(
name|apm_info_t
name|aip
parameter_list|)
block|{
name|union
name|real_regs
name|regs
decl_stmt|;
name|regs
operator|.
name|hl
operator|.
name|ah
operator|=
name|APM_BIOS
expr_stmt|;
name|regs
operator|.
name|hl
operator|.
name|al
operator|=
name|APM_GETPWSTATUS
expr_stmt|;
name|regs
operator|.
name|x
operator|.
name|bx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|call_apm
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
operator|.
name|x
operator|.
name|cf
condition|)
block|{
name|printf
argument_list|(
literal|"Get APM info failure: errcode = %d\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|aip
operator|->
name|ai_major
operator|=
operator|(
name|u_int
operator|)
name|majorversion
expr_stmt|;
name|aip
operator|->
name|ai_minor
operator|=
operator|(
name|u_int
operator|)
name|minorversion
expr_stmt|;
name|aip
operator|->
name|ai_acline
operator|=
operator|(
name|u_int
operator|)
name|regs
operator|.
name|hl
operator|.
name|bh
expr_stmt|;
name|aip
operator|->
name|ai_batt_stat
operator|=
operator|(
name|u_int
operator|)
name|regs
operator|.
name|hl
operator|.
name|bl
expr_stmt|;
name|aip
operator|->
name|ai_batt_life
operator|=
operator|(
name|u_int
operator|)
name|regs
operator|.
name|hl
operator|.
name|cl
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define equivalent event sets */
end_comment

begin_decl_stmt
specifier|static
name|int
name|equiv_event_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|apm_eqv_event
name|equiv_events
index|[
name|APM_MAX_EQUIV_EVENTS
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_def_eqv
parameter_list|(
name|apm_eqv_event_t
name|aee
parameter_list|)
block|{
if|if
condition|(
name|equiv_event_num
operator|==
name|APM_MAX_EQUIV_EVENTS
condition|)
block|{
return|return
literal|1
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|equiv_events
index|[
name|equiv_event_num
index|]
argument_list|,
name|aee
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|apm_eqv_event
argument_list|)
argument_list|)
expr_stmt|;
name|equiv_event_num
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_flush_eqv
parameter_list|(
name|void
parameter_list|)
block|{
name|equiv_event_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Public interface to the suspend/resume:  *  * Execute suspend and resume hook before and after sleep, respectively.  */
end_comment

begin_function
name|void
name|apm_suspend_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
if|#
directive|if
literal|0
block|printf("Called apm_suspend_resume();\n");
endif|#
directive|endif
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|apm_execute_suspend_hook
argument_list|()
expr_stmt|;
name|apm_suspend_system
argument_list|()
expr_stmt|;
name|apm_execute_resume_hook
argument_list|()
expr_stmt|;
name|apm_processevent
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is idle */
end_comment

begin_function
name|void
name|apm_cpu_idle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|idle_cpu
condition|)
block|{
if|if
condition|(
name|active
condition|)
block|{
asm|asm("movw $0x5305, %ax; lcall _apm_addr");
block|}
block|}
comment|/* 	 * Some APM implementation halts CPU in BIOS, whenever  	 * "CPU-idle" function are invoked, but swtch() of 	 * FreeBSD halts CPU, therefore, CPU is halted twice 	 * in the sched loop. It makes the interrupt latency 	 * terribly long and be able to cause a serious problem 	 * in interrupt processing. We prevent it by removing 	 * "hlt" operation from swtch() and managed it under 	 * APM driver. 	 */
if|if
condition|(
operator|!
name|active
operator|||
name|halt_cpu
condition|)
block|{
asm|asm("sti ; hlt");
comment|/* wait for interrupt */
block|}
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is busy */
end_comment

begin_function
name|void
name|apm_cpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|idle_cpu
operator|&&
name|active
condition|)
block|{
asm|asm("movw $0x5306, %ax; lcall _apm_addr");
block|}
block|}
end_function

begin_comment
comment|/*  * APM timeout routine:  *  * This routine is automatically called by timer two times within one   * seconed.  */
end_comment

begin_function
specifier|static
name|void
name|apm_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
if|#
directive|if
literal|0
block|printf("Called apm_timeout\n");
endif|#
directive|endif
name|apm_processevent
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* 2 Hz */
comment|/* APM driver must polls APM event a time per second */
block|}
end_function

begin_comment
comment|/* enable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_enable
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|printf("called apm_event_enable()\n");
endif|#
directive|endif
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|active
operator|=
literal|1
expr_stmt|;
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* disable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_disable
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|printf("called apm_event_disable()\n");
endif|#
directive|endif
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|untimeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|halt_cpu
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* don't halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_not_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|halt_cpu
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* device driver definitions */
end_comment

begin_function_decl
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|apmdriver
init|=
block|{
name|apmprobe
block|,
name|apmattach
block|,
literal|"apm"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * probe APM (dummy):  *  * APM probing routine is placed on locore.s and apm_init.S because  * this process forces the CPU to turn to real mode or V86 mode.  * Current version uses real mode, but on future version, we want  * to use V86 mode in APM initialization.  */
end_comment

begin_function
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
switch|switch
condition|(
name|apm_version
condition|)
block|{
case|case
name|APMINI_CANTFIND
case|:
comment|/* silent */
return|return
literal|0
return|;
case|case
name|APMINI_NOT32BIT
case|:
name|printf
argument_list|(
literal|"apm%d: 32bit connection is not supported.\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|APMINI_CONNECTERR
case|:
name|printf
argument_list|(
literal|"apm%d: 32-bit connection error.\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x0100
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>=
literal|0x00a0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>=
literal|0x000a
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|is_enabled
parameter_list|(
name|int
name|enabled
parameter_list|)
block|{
if|if
condition|(
name|enabled
condition|)
block|{
return|return
literal|"enabled"
return|;
block|}
return|return
literal|"disabled"
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|apm_error
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|apm_errno
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|"APM OK."
return|;
default|default:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"Unknown Error 0x%x"
argument_list|,
operator|(
name|u_int
operator|)
name|apm_errno
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
end_function

begin_comment
comment|/* Process APM event */
end_comment

begin_function
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|apm_event
decl_stmt|;
name|getevent
label|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|apm_event
operator|=
name|apm_getevent
argument_list|()
operator|)
operator|==
name|PMEV_NOEVENT
condition|)
block|{
break|break;
block|}
if|#
directive|if
literal|0
if|#
directive|if
literal|1
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: break;
else|#
directive|else
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: printf("Original APM Event: " #symbol "\n"); break
endif|#
directive|endif
block|switch (apm_event) { 			OPMEV_DEBUGMESSAGE(PMEV_NOEVENT); 			OPMEV_DEBUGMESSAGE(PMEV_STANDBYREQ); 			OPMEV_DEBUGMESSAGE(PMEV_SUSPENDREQ); 			OPMEV_DEBUGMESSAGE(PMEV_NORMRESUME); 			OPMEV_DEBUGMESSAGE(PMEV_CRITRESUME); 			OPMEV_DEBUGMESSAGE(PMEV_BATTERYLOW); 			OPMEV_DEBUGMESSAGE(PMEV_POWERSTATECHANGE); 			OPMEV_DEBUGMESSAGE(PMEV_UPDATETIME); 			OPMEV_DEBUGMESSAGE(PMEV_CRITSUSPEND); 			OPMEV_DEBUGMESSAGE(PMEV_USERSUSPENDREQ); 			OPMEV_DEBUGMESSAGE(PMEV_STANDBYRESUME); 			default: 				printf("Unknown Original APM Event 0x%x\n", apm_event); 				break; 		}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|equiv_event_num
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|equiv_events
index|[
name|i
index|]
operator|.
name|aee_event
operator|==
name|apm_event
condition|)
block|{
name|u_int
name|tmp
init|=
name|PMEV_DEFAULT
decl_stmt|;
if|if
condition|(
name|resumed_event
condition|)
block|{
name|tmp
operator|=
name|equiv_events
index|[
name|i
index|]
operator|.
name|aee_resume
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|equiv_events
index|[
name|i
index|]
operator|.
name|aee_equiv
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|!=
name|PMEV_DEFAULT
condition|)
block|{
name|apm_event
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|#
directive|if
literal|1
if|#
directive|if
literal|1
define|#
directive|define
name|PMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: break;
else|#
directive|else
define|#
directive|define
name|PMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: printf("APM Event: " #symbol "\n"); break
endif|#
directive|endif
switch|switch
condition|(
name|apm_event
condition|)
block|{
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NOEVENT
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYREQ
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_SUSPENDREQ
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NORMRESUME
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITRESUME
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_BATTERYLOW
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_POWERSTATECHANGE
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_UPDATETIME
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITSUSPEND
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSUSPENDREQ
argument_list|)
expr_stmt|;
name|PMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYRESUME
argument_list|)
expr_stmt|;
default|default:
name|printf
argument_list|(
literal|"Unknown APM Event 0x%x\n"
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|apm_event
condition|)
block|{
case|case
name|PMEV_NOEVENT
case|:
case|case
name|PMEV_STANDBYREQ
case|:
case|case
name|PMEV_POWERSTATECHANGE
case|:
case|case
name|PMEV_CRITSUSPEND
case|:
case|case
name|PMEV_USERSTANDBYREQ
case|:
case|case
name|PMEV_USERSUSPENDREQ
case|:
break|break;
case|case
name|PMEV_BATTERYLOW
case|:
name|apm_battery_low
argument_list|()
expr_stmt|;
break|break;
case|case
name|PMEV_SUSPENDREQ
case|:
name|apm_suspend_resume
argument_list|()
expr_stmt|;
break|break;
case|case
name|PMEV_NORMRESUME
case|:
case|case
name|PMEV_CRITRESUME
case|:
case|case
name|PMEV_UPDATETIME
case|:
case|case
name|PMEV_STANDBYRESUME
case|:
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
break|break;
block|}
block|}
name|resumed_event
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach APM:  *  * Initialize APM driver (APM BIOS itself has been initialized in locore.s)  */
end_comment

begin_function
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
comment|/* setup APM parameters */
name|minorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|majorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|intversion
operator|=
name|INTVERSION
argument_list|(
name|majorversion
argument_list|,
name|minorversion
argument_list|)
expr_stmt|;
name|cs32_base
operator|=
operator|(
name|apm_cs32_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|cs16_base
operator|=
operator|(
name|apm_cs16_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|ds_base
operator|=
operator|(
name|apm_ds_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|cs_limit
operator|=
name|apm_cs_limit
expr_stmt|;
name|ds_limit
operator|=
name|apm_ds_limit
expr_stmt|;
name|cs_entry
operator|=
name|apm_cs_entry
expr_stmt|;
name|idle_cpu
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_CPUIDLE_SLOW
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|disabled
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISABLED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|disengaged
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISENGAGED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* print bootstrap messages */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|" found APM BIOS version %d.%d\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|majorversion
argument_list|,
name|minorversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Code32 0x%08x, Code16 0x%08x, Data 0x%08x\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|cs32_base
argument_list|,
name|cs16_base
argument_list|,
name|ds_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Code entry 0x%08x, Idling CPU %s, Management %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|cs_entry
argument_list|,
name|is_enabled
argument_list|(
name|idle_cpu
argument_list|)
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|disabled
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|" found APM BIOS version %d.%d\n"
argument_list|,
name|majorversion
argument_list|,
name|minorversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Idling CPU %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|is_enabled
argument_list|(
name|idle_cpu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * APM 1.0 does not have: 	 *  	 * 	1. segment limit parameters 	 * 	 *	2. engage/disengage operations 	 */
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"apm%d: Engaged control %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|disengaged
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cs_limit
operator|=
literal|0xffff
expr_stmt|;
name|ds_limit
operator|=
literal|0xffff
expr_stmt|;
block|}
comment|/* setup GDT */
name|setup_apm_gdt
argument_list|(
name|cs32_base
argument_list|,
name|cs16_base
argument_list|,
name|ds_base
argument_list|,
name|cs_limit
argument_list|,
name|ds_limit
argument_list|)
expr_stmt|;
comment|/* setup entry point 48bit pointer */
name|apm_addr
operator|.
name|segment
operator|=
name|GSEL
argument_list|(
name|GAPMCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|apm_addr
operator|.
name|offset
operator|=
name|cs_entry
expr_stmt|;
comment|/* enable power management */
if|if
condition|(
name|disabled
condition|)
block|{
if|if
condition|(
name|apm_enable_disable_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: APM enable function failed! [%s]\n"
argument_list|,
name|apm_error
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* engage power managment (APM 1.1 or later) */
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|disengaged
condition|)
block|{
if|if
condition|(
name|apm_engage_disengage_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: APM engage function failed [%s]\n"
argument_list|,
name|apm_error
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|apm_suspend_hook_init
argument_list|(
name|apm_default_suspend
argument_list|,
literal|"default suspend"
argument_list|,
name|APM_MAX_ORDER
argument_list|)
expr_stmt|;
name|apm_resume_hook_init
argument_list|(
name|apm_default_resume
argument_list|,
literal|"default resume"
argument_list|,
name|APM_MIN_ORDER
argument_list|)
expr_stmt|;
name|apm_initialized
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|apm_initialized
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
switch|switch
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* apm0 */
break|break;
name|defaults
label|:
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|pl
decl_stmt|;
if|#
directive|if
literal|0
block|printf("APM ioctl: minor = %d, cmd = 0x%x\n", minor(dev), cmd);
endif|#
directive|endif
name|pl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|apm_initialized
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_SUSPEND
case|:
name|apm_suspend_resume
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_GETINFO
case|:
if|if
condition|(
name|apm_get_info
argument_list|(
operator|(
name|apm_info_t
operator|)
name|addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_DEFEQV
case|:
if|if
condition|(
name|apm_def_eqv
argument_list|(
operator|(
name|apm_eqv_event_t
operator|)
name|addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_FLUSHEQV
case|:
name|apm_flush_eqv
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_ENABLE
case|:
name|apm_event_enable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISABLE
case|:
name|apm_event_disable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_HALTCPU
case|:
name|apm_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_NOTHALTCPU
case|:
name|apm_not_halt_cpu
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

end_unit

