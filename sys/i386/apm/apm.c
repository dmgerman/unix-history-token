begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_define
define|#
directive|define
name|APM_DEBUG
value|1
end_define

begin_comment
comment|/*  * LP (Laptop Package)  *   * Copyright (c) 1994 by HOSOKAWA, Tatsumi<hosokawa@mt.cs.keio.ac.jp>  *  * This software may be used, modified, copied, and distributed, in  * both source and binary form provided that the above copyright and  * these terms are retained. Under no circumstances is the author   * responsible for the proper functioning of this software, nor does   * the author assume any responsibility for damages incurred with its   * use.  *  * Sep, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)  *  *	$Id: apm.c,v 1.9 1994/12/16 07:09:22 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|"apm.h"
end_include

begin_if
if|#
directive|if
name|NAPM
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|"apm_setup.h"
end_include

begin_comment
comment|/* static data */
end_comment

begin_decl_stmt
specifier|static
name|int
name|apm_initialized
init|=
literal|0
decl_stmt|,
name|active
init|=
literal|0
decl_stmt|,
name|halt_cpu
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|minorversion
decl_stmt|,
name|majorversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs32_base
decl_stmt|,
name|cs16_base
decl_stmt|,
name|ds_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs_limit
decl_stmt|,
name|ds_limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|cs_entry
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|intversion
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|idle_cpu
decl_stmt|,
name|disabled
decl_stmt|,
name|disengaged
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|is_enabled
parameter_list|(
name|foo
parameter_list|)
value|((foo) ? "enabled" : "disabled")
end_define

begin_comment
comment|/* Map version number to integer (keeps ordering of version numbers) */
end_comment

begin_define
define|#
directive|define
name|INTVERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major)*100 + (minor))
end_define

begin_decl_stmt
specifier|static
name|timeout_t
name|apm_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setup APM GDT discriptors */
end_comment

begin_function
specifier|static
name|void
name|setup_apm_gdt
parameter_list|(
name|u_int
name|code32_base
parameter_list|,
name|u_int
name|code16_base
parameter_list|,
name|u_int
name|data_base
parameter_list|,
name|u_int
name|code_limit
parameter_list|,
name|u_int
name|data_limit
parameter_list|)
block|{
comment|/* setup 32bit code segment */
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code32_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup 16bit code segment */
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code16_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup data segment */
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_base
operator|=
name|data_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|data_limit
expr_stmt|;
comment|/* reflect these changes on physical GDT */
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE32_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE16_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMDATA_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 48bit far pointer */
end_comment

begin_struct
struct|struct
name|addr48
block|{
name|u_long
name|offset
decl_stmt|;
name|u_short
name|segment
decl_stmt|;
block|}
name|apm_addr
struct|;
end_struct

begin_decl_stmt
name|int
name|apm_errno
decl_stmt|;
end_decl_stmt

begin_function
specifier|inline
name|int
name|apm_int
parameter_list|(
name|u_long
modifier|*
name|eax
parameter_list|,
name|u_long
modifier|*
name|ebx
parameter_list|,
name|u_long
modifier|*
name|ecx
parameter_list|)
block|{
name|u_long
name|cf
decl_stmt|;
asm|__asm ("pushl	%%ebp 		pushl	%%edx 		pushl	%%esi 		xorl	%3,%3 		movl	%3,%%esi 		lcall	_apm_addr 		jnc	1f 		incl	%3 	1:	 		popl	%%esi 		popl	%%edx 		popl	%%ebp"
block|:
literal|"=a"
operator|(
operator|*
name|eax
operator|)
operator|,
literal|"=b"
operator|(
operator|*
name|ebx
operator|)
operator|,
literal|"=c"
operator|(
operator|*
name|ecx
operator|)
operator|,
literal|"=D"
operator|(
name|cf
operator|)
operator|:
literal|"0"
operator|(
operator|*
name|eax
operator|)
operator|,
literal|"1"
operator|(
operator|*
name|ebx
operator|)
operator|,
literal|"2"
operator|(
operator|*
name|ecx
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|apm_errno
operator|=
operator|(
operator|(
operator|*
name|eax
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|cf
return|;
end_return

begin_comment
unit|}
comment|/* enable/disable power management */
end_comment

begin_function
unit|static
name|int
name|apm_enable_disable_pm
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENABLEDISABLEPM
expr_stmt|;
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
block|}
else|else
block|{
name|ebx
operator|=
literal|0xffff
expr_stmt|;
comment|/* APM version 1.0 only */
block|}
name|ecx
operator|=
name|enable
expr_stmt|;
return|return
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tell APM-BIOS that WE will do 1.1 and see what they say... */
end_comment

begin_function
specifier|static
name|void
name|apm_driver_version
parameter_list|()
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_INSTCHECK
expr_stmt|;
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|ecx
operator|=
literal|0x0101
expr_stmt|;
name|i
operator|=
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%04lx %04lx %04lx %ld %02x]\n"
argument_list|,
name|eax
argument_list|,
name|ebx
argument_list|,
name|ecx
argument_list|,
name|i
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_DRVVERSION
expr_stmt|;
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|ecx
operator|=
literal|0x0101
expr_stmt|;
if|if
condition|(
operator|!
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
condition|)
name|apm_version
operator|=
name|eax
operator|&
literal|0xffff
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_INSTCHECK
expr_stmt|;
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|ecx
operator|=
literal|0x0101
expr_stmt|;
name|i
operator|=
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%04lx %04lx %04lx %ld %02x]\n"
argument_list|,
name|eax
argument_list|,
name|ebx
argument_list|,
name|ecx
argument_list|,
name|i
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* engage/disengage power management (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_engage_disengage_pm
parameter_list|(
name|int
name|engage
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|i
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENGAGEDISENGAGEPM
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|engage
expr_stmt|;
name|i
operator|=
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* get PM event */
end_comment

begin_function
specifier|static
name|u_int
name|apm_getevent
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPMEVENT
expr_stmt|;
name|ebx
operator|=
literal|0
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
condition|)
return|return
name|PMEV_NOEVENT
return|;
return|return
name|ebx
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* suspend entire system */
end_comment

begin_function
specifier|static
name|int
name|apm_suspend_system
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_SUSPEND
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Entire system suspend failure: errcode = %ld\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* APM Battery low handler */
end_comment

begin_function
specifier|static
name|void
name|apm_battery_low
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\007\007 * * * BATTERY IS LOW * * * \007\007"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|suspend_time
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_default_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|second
decl_stmt|,
name|minute
decl_stmt|,
name|hour
decl_stmt|;
name|struct
name|timeval
name|resume_time
decl_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
name|microtime
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
operator|-
name|suspend_time
operator|.
name|tv_sec
expr_stmt|;
name|hour
operator|=
name|second
operator|/
literal|3600
expr_stmt|;
name|second
operator|%=
literal|3600
expr_stmt|;
name|minute
operator|=
name|second
operator|/
literal|60
expr_stmt|;
name|second
operator|%=
literal|60
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resumed from suspended mode (slept %02d:%02d:%02d)\n"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_default_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|apm_suspend_system
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* get APM information */
end_comment

begin_function
specifier|static
name|int
name|apm_get_info
parameter_list|(
name|apm_info_t
name|aip
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPWSTATUS
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|)
condition|)
return|return
literal|1
return|;
name|aip
operator|->
name|ai_acline
operator|=
operator|(
name|ebx
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_stat
operator|=
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_life
operator|=
name|ecx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_major
operator|=
operator|(
name|u_int
operator|)
name|majorversion
expr_stmt|;
name|aip
operator|->
name|ai_minor
operator|=
operator|(
name|u_int
operator|)
name|minorversion
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* inform APM BIOS that CPU is idle */
end_comment

begin_function
name|void
name|apm_cpu_idle
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|idle_cpu
condition|)
block|{
if|if
condition|(
name|active
condition|)
block|{
asm|__asm ("movw $0x5305, %ax; lcall _apm_addr");
block|}
block|}
comment|/* 	 * Some APM implementation halts CPU in BIOS, whenever  	 * "CPU-idle" function are invoked, but swtch() of 	 * FreeBSD halts CPU, therefore, CPU is halted twice 	 * in the sched loop. It makes the interrupt latency 	 * terribly long and be able to cause a serious problem 	 * in interrupt processing. We prevent it by removing 	 * "hlt" operation from swtch() and managed it under 	 * APM driver. 	 */
if|if
condition|(
operator|!
name|active
operator|||
name|halt_cpu
condition|)
block|{
asm|__asm("sti ; hlt");
comment|/* wait for interrupt */
block|}
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is busy */
end_comment

begin_function
name|void
name|apm_cpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|idle_cpu
operator|&&
name|active
condition|)
block|{
asm|__asm("movw $0x5306, %ax; lcall _apm_addr");
block|}
block|}
end_function

begin_comment
comment|/*  * APM timeout routine:  *  * This routine is automatically called by timer once per second.  */
end_comment

begin_function
specifier|static
name|void
name|apm_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|apm_processevent
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* More than 1 Hz */
block|}
end_function

begin_comment
comment|/* enable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_enable
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_enable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|active
operator|=
literal|1
expr_stmt|;
name|apm_timeout
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* disable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_disable
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_disable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|untimeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|halt_cpu
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* don't halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_not_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|apm_initialized
condition|)
block|{
name|halt_cpu
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* device driver definitions */
end_comment

begin_function_decl
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|apmdriver
init|=
block|{
name|apmprobe
block|,
name|apmattach
block|,
literal|"apm"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * probe APM (dummy):  *  * APM probing routine is placed on locore.s and apm_init.S because  * this process forces the CPU to turn to real mode or V86 mode.  * Current version uses real mode, but on future version, we want  * to use V86 mode in APM initialization.  */
end_comment

begin_function
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
switch|switch
condition|(
name|apm_version
condition|)
block|{
case|case
name|APMINI_CANTFIND
case|:
comment|/* silent */
return|return
literal|0
return|;
case|case
name|APMINI_NOT32BIT
case|:
name|printf
argument_list|(
literal|"apm%d: 32bit connection is not supported.\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|APMINI_CONNECTERR
case|:
name|printf
argument_list|(
literal|"apm%d: 32-bit connection error.\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0xff00
operator|)
operator|!=
literal|0x0100
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>=
literal|0x00a0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>=
literal|0x000a
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process APM event */
end_comment

begin_function
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|apm_event
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: \ 	printf("Original APM Event: " #symbol "\n");
else|#
directive|else
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol:
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|apm_event
operator|=
name|apm_getevent
argument_list|()
expr_stmt|;
if|if
condition|(
name|apm_event
operator|==
name|PMEV_NOEVENT
condition|)
break|break;
switch|switch
condition|(
name|apm_event
condition|)
block|{
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYREQ
argument_list|)
expr_stmt|;
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_SUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITSUSPEND
argument_list|)
expr_stmt|;
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NORMRESUME
argument_list|)
expr_stmt|;
name|apm_default_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITRESUME
argument_list|)
expr_stmt|;
name|apm_default_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYRESUME
argument_list|)
expr_stmt|;
name|apm_default_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_BATTERYLOW
argument_list|)
expr_stmt|;
name|apm_battery_low
argument_list|()
expr_stmt|;
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_POWERSTATECHANGE
argument_list|)
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_UPDATETIME
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown Original APM Event 0x%x\n"
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Attach APM:  *  * Initialize APM driver (APM BIOS itself has been initialized in locore.s)  *  * Now, unless I'm mad, (not quite ruled out yet), the APM-1.1 spec is bogus:  *   * Appendix C says under the header "APM 1.0/APM 1.1 Modal BIOS Behavior"  * that "When an APM Driver connects with an APM 1.1 BIOS, the APM 1.1 BIOS  * will default to an APM 1.0 connection.  After an APM Driver calls the APM  * Driver Version function, specifying that it supports APM 1.1, and [sic!]  * APM BIOS will change its behavior to an APM 1.1 connection.  If the APM  * BIOS is an APM 1.0 BIOS, the APM Driver Version function call will fail,  * and the connection will remain an APM 1.0 connection."  *  * OK so I can establish a 1.0 connection, and then tell that I'm a 1.1  * and maybe then the BIOS will tell that it too is a 1.1.  * Fine.  * Now how will I ever get the segment-limits for instance ?  There is no   * way I can see that I can get a 1.1 response back from an "APM Protected   * Mode 32-bit Interface Connect" function ???  *   * Who made this,  Intel and Microsoft ?  -- How did you guess !  *  * /phk  */
end_comment

begin_function
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
comment|/* setup APM parameters */
name|cs32_base
operator|=
operator|(
name|apm_cs32_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|cs16_base
operator|=
operator|(
name|apm_cs16_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|ds_base
operator|=
operator|(
name|apm_ds_base
operator|<<
literal|4
operator|)
operator|+
name|KERNBASE
expr_stmt|;
name|cs_limit
operator|=
name|apm_cs_limit
expr_stmt|;
name|ds_limit
operator|=
name|apm_ds_limit
expr_stmt|;
name|cs_entry
operator|=
name|apm_cs_entry
expr_stmt|;
name|idle_cpu
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_CPUIDLE_SLOW
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|disabled
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISABLED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|disengaged
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISENGAGED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* print bootstrap messages */
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|" found APM BIOS version %04x\n"
argument_list|,
name|apm_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Code32 0x%08x, Code16 0x%08x, Data 0x%08x\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|cs32_base
argument_list|,
name|cs16_base
argument_list|,
name|ds_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Code entry 0x%08x, Idling CPU %s, Management %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|cs_entry
argument_list|,
name|is_enabled
argument_list|(
name|idle_cpu
argument_list|)
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|disabled
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: CS_limit=%x, DS_limit=%x\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|cs_limit
argument_list|,
name|ds_limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_DEBUG */
name|cs_limit
operator|=
literal|0xffff
expr_stmt|;
name|ds_limit
operator|=
literal|0xffff
expr_stmt|;
comment|/* setup GDT */
name|setup_apm_gdt
argument_list|(
name|cs32_base
argument_list|,
name|cs16_base
argument_list|,
name|ds_base
argument_list|,
name|cs_limit
argument_list|,
name|ds_limit
argument_list|)
expr_stmt|;
comment|/* setup entry point 48bit pointer */
name|apm_addr
operator|.
name|segment
operator|=
name|GSEL
argument_list|(
name|GAPMCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|apm_addr
operator|.
name|offset
operator|=
name|cs_entry
expr_stmt|;
comment|/* Try to kick bios into 1.1 mode */
name|apm_driver_version
argument_list|()
expr_stmt|;
name|minorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|majorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|intversion
operator|=
name|INTVERSION
argument_list|(
name|majorversion
argument_list|,
name|minorversion
argument_list|)
expr_stmt|;
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"apm%d: Engaged control %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|disengaged
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" found APM BIOS version %d.%d\n"
argument_list|,
name|majorversion
argument_list|,
name|minorversion
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm%d: Idling CPU %s\n"
argument_list|,
name|dvp
operator|->
name|id_unit
argument_list|,
name|is_enabled
argument_list|(
name|idle_cpu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enable power management */
if|if
condition|(
name|disabled
condition|)
block|{
if|if
condition|(
name|apm_enable_disable_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: APM enable function failed! [%x]\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* engage power managment (APM 1.1 or later) */
if|if
condition|(
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|disengaged
condition|)
block|{
if|if
condition|(
name|apm_engage_disengage_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: APM engage function failed [%x]\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
block|}
block|}
name|apm_initialized
operator|=
literal|1
expr_stmt|;
name|apm_event_enable
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
operator|!
name|apm_initialized
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|apmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|pl
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"APM ioctl: minor = %d, cmd = 0x%x\n"
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pl
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
operator|!
name|apm_initialized
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_SUSPEND
case|:
name|apm_default_suspend
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_GETINFO
case|:
if|if
condition|(
name|apm_get_info
argument_list|(
operator|(
name|apm_info_t
operator|)
name|addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_ENABLE
case|:
name|apm_event_enable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISABLE
case|:
name|apm_event_disable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_HALTCPU
case|:
name|apm_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_NOTHALTCPU
case|:
name|apm_not_halt_cpu
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NAPM> 0 */
end_comment

end_unit

