begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  * Copyright (c) 2004 Christian Limpach.  * Copyright (c) 2004-2006,2008 Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Christian Limpach.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/asmacros.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenfunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenpmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xenfunc.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/memory.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/features.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/privatespace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_define
define|#
directive|define
name|IDTVEC
parameter_list|(
name|name
parameter_list|)
value|__CONCAT(X,name)
end_define

begin_decl_stmt
specifier|extern
name|inthand_t
name|IDTVEC
argument_list|(
name|div
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|dbg
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|nmi
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|bpt
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|ofl
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|bnd
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|ill
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|dna
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|fpusegm
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|tss
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|missing
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|stk
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|prot
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|page
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|mchk
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|fpu
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|align
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|xmm
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|lcall_syscall
argument_list|)
decl_stmt|,
name|IDTVEC
argument_list|(
name|int0x80_syscall
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xendebug_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|start_info_t
modifier|*
name|xen_start_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|shared_info_t
modifier|*
name|HYPERVISOR_shared_info
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xen_pfn_t
modifier|*
name|xen_machine_phys
init|=
name|machine_to_phys_mapping
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|xen_pfn_t
modifier|*
name|xen_phys_machine
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|preemptable
decl_stmt|,
name|init_first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|avail_space
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ni_cli
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ni_sti
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ni_cli
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm__("pushl %edx;" 		"pushl %eax;" 		);
name|__cli
argument_list|()
expr_stmt|;
asm|__asm__("popl %eax;" 		"popl %edx;" 		);
block|}
end_function

begin_function
name|void
name|ni_sti
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm__("pushl %edx;" 		"pushl %esi;" 		"pushl %eax;" 		);
name|__sti
argument_list|()
expr_stmt|;
asm|__asm__("popl %eax;" 		"popl %esi;" 		"popl %edx;" 		);
block|}
end_function

begin_comment
comment|/*  * Modify the cmd_line by converting ',' to NULLs so that it is in a  format   * suitable for the static env vars.  */
end_comment

begin_function
name|char
modifier|*
name|xen_setbootenv
parameter_list|(
name|char
modifier|*
name|cmd_line
parameter_list|)
block|{
name|char
modifier|*
name|cmd_line_next
decl_stmt|;
comment|/* Skip leading spaces */
for|for
control|(
init|;
operator|*
name|cmd_line
operator|==
literal|' '
condition|;
name|cmd_line
operator|++
control|)
empty_stmt|;
name|printk
argument_list|(
literal|"xen_setbootenv(): cmd_line='%s'\n"
argument_list|,
name|cmd_line
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd_line_next
operator|=
name|cmd_line
init|;
name|strsep
argument_list|(
operator|&
name|cmd_line_next
argument_list|,
literal|","
argument_list|)
operator|!=
name|NULL
condition|;
control|)
empty_stmt|;
return|return
name|cmd_line
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|ev
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|}
name|howto_names
index|[]
init|=
block|{
block|{
literal|"boot_askname"
block|,
name|RB_ASKNAME
block|}
block|,
block|{
literal|"boot_single"
block|,
name|RB_SINGLE
block|}
block|,
block|{
literal|"boot_nosync"
block|,
name|RB_NOSYNC
block|}
block|,
block|{
literal|"boot_halt"
block|,
name|RB_ASKNAME
block|}
block|,
block|{
literal|"boot_serial"
block|,
name|RB_SERIAL
block|}
block|,
block|{
literal|"boot_cdrom"
block|,
name|RB_CDROM
block|}
block|,
block|{
literal|"boot_gdb"
block|,
name|RB_GDB
block|}
block|,
block|{
literal|"boot_gdb_pause"
block|,
name|RB_RESERVED1
block|}
block|,
block|{
literal|"boot_verbose"
block|,
name|RB_VERBOSE
block|}
block|,
block|{
literal|"boot_multicons"
block|,
name|RB_MULTIPLE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|int
name|xen_boothowto
parameter_list|(
name|char
modifier|*
name|envp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|howto
init|=
literal|0
decl_stmt|;
comment|/* get equivalents from the environment */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|howto_names
index|[
name|i
index|]
operator|.
name|ev
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|getenv
argument_list|(
name|howto_names
index|[
name|i
index|]
operator|.
name|ev
argument_list|)
operator|!=
name|NULL
condition|)
name|howto
operator||=
name|howto_names
index|[
name|i
index|]
operator|.
name|mask
expr_stmt|;
return|return
name|howto
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PRINTK_BUFSIZE
value|1024
end_define

begin_function
name|void
name|printk
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|__va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|PRINTK_BUFSIZE
index|]
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|=
name|vsnprintf
argument_list|(
name|buf
argument_list|,
name|PRINTK_BUFSIZE
operator|-
literal|1
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|buf
index|[
name|retval
index|]
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|HYPERVISOR_console_write
argument_list|(
name|buf
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|XPQUEUE_SIZE
value|128
end_define

begin_struct
struct|struct
name|mmu_log
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* per-cpu queues and indices */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mmu_log
name|xpq_queue_log
index|[
name|MAX_VIRT_CPUS
index|]
index|[
name|XPQUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|xpq_idx
index|[
name|MAX_VIRT_CPUS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mmu_update_t
name|xpq_queue
index|[
name|MAX_VIRT_CPUS
index|]
index|[
name|XPQUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XPQ_QUEUE_LOG
value|xpq_queue_log[vcpu]
end_define

begin_define
define|#
directive|define
name|XPQ_QUEUE
value|xpq_queue[vcpu]
end_define

begin_define
define|#
directive|define
name|XPQ_IDX
value|xpq_idx[vcpu]
end_define

begin_define
define|#
directive|define
name|SET_VCPU
parameter_list|()
value|int vcpu = smp_processor_id()
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|mmu_update_t
name|xpq_queue
index|[
name|XPQUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mmu_log
name|xpq_queue_log
index|[
name|XPQUEUE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xpq_idx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|XPQ_QUEUE_LOG
value|xpq_queue_log
end_define

begin_define
define|#
directive|define
name|XPQ_QUEUE
value|xpq_queue
end_define

begin_define
define|#
directive|define
name|XPQ_IDX
value|xpq_idx
end_define

begin_define
define|#
directive|define
name|SET_VCPU
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMP */
end_comment

begin_define
define|#
directive|define
name|XPQ_IDX_INC
value|atomic_add_int(&XPQ_IDX, 1);
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void xen_dump_queue(void) { 	int _xpq_idx = XPQ_IDX; 	int i;  	if (_xpq_idx<= 1) 		return;  	printk("xen_dump_queue(): %u entries\n", _xpq_idx); 	for (i = 0; i< _xpq_idx; i++) { 		printk(" val: %llx ptr: %llx\n", XPQ_QUEUE[i].val, XPQ_QUEUE[i].ptr); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|void
name|_xen_flush_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|SET_VCPU
argument_list|()
expr_stmt|;
name|int
name|_xpq_idx
init|=
name|XPQ_IDX
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* window of vulnerability here? */
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_enter
argument_list|()
expr_stmt|;
name|XPQ_IDX
operator|=
literal|0
expr_stmt|;
comment|/* Make sure index is cleared first to avoid double updates. */
name|error
operator|=
name|HYPERVISOR_mmu_update
argument_list|(
operator|(
name|mmu_update_t
operator|*
operator|)
operator|&
name|XPQ_QUEUE
argument_list|,
name|_xpq_idx
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (__predict_true(gdtset)) 	for (i = _xpq_idx; i> 0;) { 		if (i>= 3) { 			CTR6(KTR_PMAP, "mmu:val: %lx ptr: %lx val: %lx " 			    "ptr: %lx val: %lx ptr: %lx", 			    (XPQ_QUEUE[i-1].val& 0xffffffff), 			    (XPQ_QUEUE[i-1].ptr& 0xffffffff), 			    (XPQ_QUEUE[i-2].val& 0xffffffff), 			    (XPQ_QUEUE[i-2].ptr& 0xffffffff), 			    (XPQ_QUEUE[i-3].val& 0xffffffff), 			    (XPQ_QUEUE[i-3].ptr& 0xffffffff)); 			    i -= 3; 		} else if (i == 2) { 			CTR4(KTR_PMAP, "mmu: val: %lx ptr: %lx val: %lx ptr: %lx", 			    (XPQ_QUEUE[i-1].val& 0xffffffff), 			    (XPQ_QUEUE[i-1].ptr& 0xffffffff), 			    (XPQ_QUEUE[i-2].val& 0xffffffff), 			    (XPQ_QUEUE[i-2].ptr& 0xffffffff)); 			i = 0; 		} else { 			CTR2(KTR_PMAP, "mmu: val: %lx ptr: %lx",  			    (XPQ_QUEUE[i-1].val& 0xffffffff), 			    (XPQ_QUEUE[i-1].ptr& 0xffffffff)); 			i = 0; 		} 	}
endif|#
directive|endif
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_exit
argument_list|()
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|error
operator|<
literal|0
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_xpq_idx
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"val: %llx ptr: %llx\n"
argument_list|,
name|XPQ_QUEUE
index|[
name|i
index|]
operator|.
name|val
argument_list|,
name|XPQ_QUEUE
index|[
name|i
index|]
operator|.
name|ptr
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Failed to execute MMU updates: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xen_flush_queue
parameter_list|(
name|void
parameter_list|)
block|{
name|SET_VCPU
argument_list|()
expr_stmt|;
if|if
condition|(
name|XPQ_IDX
operator|!=
literal|0
condition|)
name|_xen_flush_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|xen_increment_idx
parameter_list|(
name|void
parameter_list|)
block|{
name|SET_VCPU
argument_list|()
expr_stmt|;
name|XPQ_IDX
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|XPQ_IDX
operator|==
name|XPQUEUE_SIZE
argument_list|)
condition|)
name|xen_flush_queue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_check_queue
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|SET_VCPU
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|XPQ_IDX
operator|==
literal|0
argument_list|,
operator|(
literal|"pending operations XPQ_IDX=%d"
operator|,
name|XPQ_IDX
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|xen_invlpg
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_INVLPG_ALL
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|linear_addr
operator|=
name|va
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_load_cr3
parameter_list|(
name|u_int
name|val
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|SET_VCPU
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|XPQ_IDX
operator|==
literal|0
argument_list|,
operator|(
literal|"pending operations XPQ_IDX=%d"
operator|,
name|XPQ_IDX
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_NEW_BASEPTR
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|xpmap_ptom
argument_list|(
name|val
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_restore_flags
parameter_list|(
name|u_int
name|eflags
parameter_list|)
block|{
if|if
condition|(
name|eflags
operator|>
literal|1
condition|)
name|eflags
operator|=
operator|(
operator|(
name|eflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
name|__restore_flags
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xen_save_and_cli
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|eflags
decl_stmt|;
name|__save_and_cli
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|eflags
operator|)
return|;
block|}
end_function

begin_function
name|void
name|xen_cli
parameter_list|(
name|void
parameter_list|)
block|{
name|__cli
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_sti
parameter_list|(
name|void
parameter_list|)
block|{
name|__sti
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|u_int
name|xen_rcr2
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|HYPERVISOR_shared_info
operator|->
name|vcpu_info
index|[
name|curcpu
index|]
operator|.
name|arch
operator|.
name|cr2
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_xen_machphys_update
parameter_list|(
name|vm_paddr_t
name|mfn
parameter_list|,
name|vm_paddr_t
name|pfn
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|SET_VCPU
argument_list|()
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_enter
argument_list|()
expr_stmt|;
name|XPQ_QUEUE
index|[
name|XPQ_IDX
index|]
operator|.
name|ptr
operator|=
operator|(
name|mfn
operator|<<
name|PAGE_SHIFT
operator|)
operator||
name|MMU_MACHPHYS_UPDATE
expr_stmt|;
name|XPQ_QUEUE
index|[
name|XPQ_IDX
index|]
operator|.
name|val
operator|=
name|pfn
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|XPQ_QUEUE_LOG
index|[
name|XPQ_IDX
index|]
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|XPQ_QUEUE_LOG
index|[
name|XPQ_IDX
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
endif|#
directive|endif
name|xen_increment_idx
argument_list|()
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_xen_queue_pt_update
parameter_list|(
name|vm_paddr_t
name|ptr
parameter_list|,
name|vm_paddr_t
name|val
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|SET_VCPU
argument_list|()
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|mtx_assert
argument_list|(
operator|&
name|vm_page_queue_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ptr
operator|&
literal|7
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"misaligned update"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_enter
argument_list|()
expr_stmt|;
name|XPQ_QUEUE
index|[
name|XPQ_IDX
index|]
operator|.
name|ptr
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|ptr
operator|)
operator||
name|MMU_NORMAL_PT_UPDATE
expr_stmt|;
name|XPQ_QUEUE
index|[
name|XPQ_IDX
index|]
operator|.
name|val
operator|=
operator|(
name|uint64_t
operator|)
name|val
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|XPQ_QUEUE_LOG
index|[
name|XPQ_IDX
index|]
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|XPQ_QUEUE_LOG
index|[
name|XPQ_IDX
index|]
operator|.
name|line
operator|=
name|line
expr_stmt|;
endif|#
directive|endif
name|xen_increment_idx
argument_list|()
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
name|gdtset
argument_list|)
condition|)
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_pgdpt_pin
parameter_list|(
name|vm_paddr_t
name|ma
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_PIN_L3_TABLE
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|ma
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_pgd_pin
parameter_list|(
name|vm_paddr_t
name|ma
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_PIN_L2_TABLE
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|ma
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_pgd_unpin
parameter_list|(
name|vm_paddr_t
name|ma
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_UNPIN_TABLE
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|ma
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_pt_pin
parameter_list|(
name|vm_paddr_t
name|ma
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_PIN_L1_TABLE
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|ma
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|printk
argument_list|(
literal|"xen_pt_pin(): mfn=%x\n"
argument_list|,
name|op
operator|.
name|arg1
operator|.
name|mfn
argument_list|)
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_pt_unpin
parameter_list|(
name|vm_paddr_t
name|ma
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_UNPIN_TABLE
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|mfn
operator|=
name|ma
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_set_ldt
parameter_list|(
name|vm_paddr_t
name|ptr
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_SET_LDT
expr_stmt|;
name|op
operator|.
name|arg1
operator|.
name|linear_addr
operator|=
name|ptr
expr_stmt|;
name|op
operator|.
name|arg2
operator|.
name|nr_ents
operator|=
name|len
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_tlb_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mmuext_op
name|op
decl_stmt|;
name|op
operator|.
name|cmd
operator|=
name|MMUEXT_TLB_FLUSH_LOCAL
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_mmuext_op
argument_list|(
operator|&
name|op
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|DOMID_SELF
argument_list|)
operator|<
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|xen_update_descriptor
parameter_list|(
name|union
name|descriptor
modifier|*
name|table
parameter_list|,
name|union
name|descriptor
modifier|*
name|entry
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|pt_entry_t
modifier|*
name|ptp
decl_stmt|;
name|ptp
operator|=
name|vtopte
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|table
argument_list|)
expr_stmt|;
name|pa
operator|=
operator|(
operator|*
name|ptp
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
operator|(
name|vm_offset_t
operator|)
name|table
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|HYPERVISOR_update_descriptor
argument_list|(
name|pa
argument_list|,
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|entry
argument_list|)
condition|)
name|panic
argument_list|(
literal|"HYPERVISOR_update_descriptor failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Bitmap is indexed by page number. If bit is set, the page is part of a  * xen_create_contiguous_region() area of memory.  */
end_comment

begin_endif
unit|unsigned long *contiguous_bitmap;  static void  contiguous_bitmap_set(unsigned long first_page, unsigned long nr_pages) { 	unsigned long start_off, end_off, curr_idx, end_idx;  	curr_idx  = first_page / BITS_PER_LONG; 	start_off = first_page& (BITS_PER_LONG-1); 	end_idx   = (first_page + nr_pages) / BITS_PER_LONG; 	end_off   = (first_page + nr_pages)& (BITS_PER_LONG-1);  	if (curr_idx == end_idx) { 		contiguous_bitmap[curr_idx] |= 			((1UL<<end_off)-1)& -(1UL<<start_off); 	} else { 		contiguous_bitmap[curr_idx] |= -(1UL<<start_off); 		while ( ++curr_idx< end_idx ) 			contiguous_bitmap[curr_idx] = ~0UL; 		contiguous_bitmap[curr_idx] |= (1UL<<end_off)-1; 	} }  static void  contiguous_bitmap_clear(unsigned long first_page, unsigned long nr_pages) { 	unsigned long start_off, end_off, curr_idx, end_idx;  	curr_idx  = first_page / BITS_PER_LONG; 	start_off = first_page& (BITS_PER_LONG-1); 	end_idx   = (first_page + nr_pages) / BITS_PER_LONG; 	end_off   = (first_page + nr_pages)& (BITS_PER_LONG-1);  	if (curr_idx == end_idx) { 		contiguous_bitmap[curr_idx]&= 			-(1UL<<end_off) | ((1UL<<start_off)-1); 	} else { 		contiguous_bitmap[curr_idx]&= (1UL<<start_off)-1; 		while ( ++curr_idx != end_idx ) 			contiguous_bitmap[curr_idx] = 0; 		contiguous_bitmap[curr_idx]&= -(1UL<<end_off); 	} }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Ensure multi-page extents are contiguous in machine memory. */
end_comment

begin_function
name|int
name|xen_create_contiguous_region
parameter_list|(
name|vm_page_t
name|pages
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|unsigned
name|long
name|mfn
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|order
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
init|=
block|{
operator|.
name|nr_extents
operator|=
literal|1
block|,
operator|.
name|extent_order
operator|=
literal|0
block|,
operator|.
name|domid
operator|=
name|DOMID_SELF
block|}
decl_stmt|;
name|set_xen_guest_handle
argument_list|(
name|reservation
operator|.
name|extent_start
argument_list|,
operator|&
name|mfn
argument_list|)
expr_stmt|;
name|balloon_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* can currently only handle power of two allocation */
name|PANIC_IF
argument_list|(
name|ffs
argument_list|(
name|npages
argument_list|)
operator|!=
name|fls
argument_list|(
name|npages
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0. determine order */
name|order
operator|=
operator|(
name|ffs
argument_list|(
name|npages
argument_list|)
operator|==
name|fls
argument_list|(
name|npages
argument_list|)
operator|)
condition|?
name|fls
argument_list|(
name|npages
argument_list|)
operator|-
literal|1
else|:
name|fls
argument_list|(
name|npages
argument_list|)
expr_stmt|;
comment|/* 1. give away machine pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pfn
decl_stmt|;
name|pfn
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pages
index|[
name|i
index|]
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|mfn
operator|=
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
expr_stmt|;
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
operator|=
name|INVALID_P2M_ENTRY
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_decrease_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 2. Get a new contiguous memory extent. */
name|reservation
operator|.
name|extent_order
operator|=
name|order
expr_stmt|;
comment|/* xenlinux hardcodes this because of aacraid - maybe set to 0 if we're not  	 * running with a broxen driver XXXEN 	 */
name|reservation
operator|.
name|address_bits
operator|=
literal|31
expr_stmt|;
if|if
condition|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_increase_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|fail
goto|;
comment|/* 3. Map the new extent in place of old pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pfn
decl_stmt|;
name|pfn
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pages
index|[
name|i
index|]
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|xen_machphys_update
argument_list|(
name|mfn
operator|+
name|i
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
operator|=
name|mfn
operator|+
name|i
expr_stmt|;
block|}
name|xen_tlb_flush
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|contiguous_bitmap_set(VM_PAGE_TO_PHYS(&pages[0])>> PAGE_SHIFT, 1UL<< order);
endif|#
directive|endif
name|balloon_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|reservation
operator|.
name|extent_order
operator|=
literal|0
expr_stmt|;
name|reservation
operator|.
name|address_bits
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pfn
decl_stmt|;
name|pfn
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
operator|&
name|pages
index|[
name|i
index|]
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_increase_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|xen_machphys_update
argument_list|(
name|mfn
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
operator|=
name|mfn
expr_stmt|;
block|}
name|xen_tlb_flush
argument_list|()
expr_stmt|;
name|balloon_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
end_function

begin_function
name|void
name|xen_destroy_contiguous_region
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|npages
parameter_list|)
block|{
name|unsigned
name|long
name|mfn
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|,
name|order
decl_stmt|,
name|pfn0
decl_stmt|;
name|struct
name|xen_memory_reservation
name|reservation
init|=
block|{
operator|.
name|nr_extents
operator|=
literal|1
block|,
operator|.
name|extent_order
operator|=
literal|0
block|,
operator|.
name|domid
operator|=
name|DOMID_SELF
block|}
decl_stmt|;
name|set_xen_guest_handle
argument_list|(
name|reservation
operator|.
name|extent_start
argument_list|,
operator|&
name|mfn
argument_list|)
expr_stmt|;
name|pfn0
operator|=
name|vtophys
argument_list|(
name|addr
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
if|#
directive|if
literal|0
block|scrub_pages(vstart, 1<< order);
endif|#
directive|endif
comment|/* can currently only handle power of two allocation */
name|PANIC_IF
argument_list|(
name|ffs
argument_list|(
name|npages
argument_list|)
operator|!=
name|fls
argument_list|(
name|npages
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0. determine order */
name|order
operator|=
operator|(
name|ffs
argument_list|(
name|npages
argument_list|)
operator|==
name|fls
argument_list|(
name|npages
argument_list|)
operator|)
condition|?
name|fls
argument_list|(
name|npages
argument_list|)
operator|-
literal|1
else|:
name|fls
argument_list|(
name|npages
argument_list|)
expr_stmt|;
name|balloon_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|contiguous_bitmap_clear(vtophys(addr)>> PAGE_SHIFT, 1UL<< order);
endif|#
directive|endif
comment|/* 1. Zap current PTEs, giving away the underlying pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pfn
decl_stmt|;
name|uint64_t
name|new_val
init|=
literal|0
decl_stmt|;
name|pfn
operator|=
name|vtomach
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_update_va_mapping
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
argument_list|,
name|new_val
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
operator|=
name|INVALID_P2M_ENTRY
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_decrease_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 2. Map new pages in place of old pages. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|1
operator|<<
name|order
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pfn
decl_stmt|;
name|uint64_t
name|new_val
decl_stmt|;
name|pfn
operator|=
name|pfn0
operator|+
name|i
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_memory_op
argument_list|(
name|XENMEM_increase_reservation
argument_list|,
operator|&
name|reservation
argument_list|)
operator|!=
literal|1
argument_list|)
expr_stmt|;
name|new_val
operator|=
name|mfn
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_update_va_mapping
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|new_val
argument_list|,
name|PG_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
name|xen_machphys_update
argument_list|(
name|mfn
argument_list|,
name|pfn
argument_list|)
expr_stmt|;
name|PFNTOMFN
argument_list|(
name|pfn
argument_list|)
operator|=
name|mfn
expr_stmt|;
block|}
name|xen_tlb_flush
argument_list|()
expr_stmt|;
name|balloon_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|cpu0prvpage
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|long
modifier|*
name|SMPpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|user
modifier|*
name|proc0uarea
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|vm_offset_t
name|proc0kstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vm86paddr
decl_stmt|,
name|vm86phystk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|bootmem_start
decl_stmt|,
modifier|*
name|bootmem_current
decl_stmt|,
modifier|*
name|bootmem_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pteinfo_t
modifier|*
name|pteinfo_list
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|initvalues
parameter_list|(
name|start_info_t
modifier|*
name|startinfo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|ringbuf_head
modifier|*
name|xen_store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX move me */
end_comment

begin_decl_stmt
name|char
modifier|*
name|console_page
decl_stmt|;
end_decl_stmt

begin_function
name|void
modifier|*
name|bootmem_alloc
parameter_list|(
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|retptr
decl_stmt|;
name|retptr
operator|=
name|bootmem_current
expr_stmt|;
name|PANIC_IF
argument_list|(
name|retptr
operator|+
name|size
operator|>
name|bootmem_end
argument_list|)
expr_stmt|;
name|bootmem_current
operator|+=
name|size
expr_stmt|;
return|return
name|retptr
return|;
block|}
end_function

begin_function
name|void
name|bootmem_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|tptr
decl_stmt|;
name|tptr
operator|=
name|ptr
expr_stmt|;
name|PANIC_IF
argument_list|(
name|tptr
operator|!=
name|bootmem_current
operator|-
name|size
operator|||
name|bootmem_current
operator|-
name|size
operator|<
name|bootmem_start
argument_list|)
expr_stmt|;
name|bootmem_current
operator|-=
name|size
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|static vm_paddr_t xpmap_mtop2(vm_paddr_t mpa) {         return ((machine_to_phys_mapping[mpa>> PAGE_SHIFT]<< PAGE_SHIFT)             ) | (mpa& ~PG_FRAME); }  static pd_entry_t  xpmap_get_bootpde(vm_paddr_t va) {          return ((pd_entry_t *)xen_start_info->pt_base)[va>> 22]; }  static pd_entry_t xpmap_get_vbootpde(vm_paddr_t va) {         pd_entry_t pde;          pde = xpmap_get_bootpde(va);         if ((pde& PG_V) == 0)                 return (pde& ~PG_FRAME);         return (pde& ~PG_FRAME) |                 (xpmap_mtop2(pde& PG_FRAME) + KERNBASE); }  static pt_entry_t 8* xpmap_get_bootptep(vm_paddr_t va) {         pd_entry_t pde;          pde = xpmap_get_vbootpde(va);         if ((pde& PG_V) == 0)                 return (void *)-1;
define|#
directive|define
name|PT_MASK
value|0x003ff000
end_define

begin_comment
comment|/* page table address bits */
end_comment

begin_endif
unit|return&(((pt_entry_t *)(pde& PG_FRAME))[(va& PT_MASK)>> PAGE_SHIFT]); }  static pt_entry_t xpmap_get_bootpte(vm_paddr_t va) {          return xpmap_get_bootptep(va)[0]; }
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ADD_ISA_HOLE
end_ifdef

begin_function
specifier|static
name|void
name|shift_phys_machine
parameter_list|(
name|unsigned
name|long
modifier|*
name|phys_machine
parameter_list|,
name|int
name|nr_pages
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|tmp_page
decl_stmt|,
modifier|*
name|current_page
decl_stmt|,
modifier|*
name|next_page
decl_stmt|;
name|int
name|i
decl_stmt|;
name|tmp_page
operator|=
name|bootmem_alloc
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|current_page
operator|=
name|phys_machine
operator|+
name|nr_pages
operator|-
operator|(
name|PAGE_SIZE
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|)
expr_stmt|;
name|next_page
operator|=
name|current_page
operator|-
operator|(
name|PAGE_SIZE
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|phys_machine
argument_list|,
name|tmp_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|current_page
operator|>
name|phys_machine
condition|)
block|{
comment|/*  save next page */
name|bcopy
argument_list|(
name|next_page
argument_list|,
name|tmp_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* shift down page */
name|bcopy
argument_list|(
name|current_page
argument_list|,
name|next_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/*  finish swap */
name|bcopy
argument_list|(
name|tmp_page
argument_list|,
name|current_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|current_page
operator|-=
operator|(
name|PAGE_SIZE
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|)
expr_stmt|;
name|next_page
operator|-=
operator|(
name|PAGE_SIZE
operator|/
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
operator|)
expr_stmt|;
block|}
name|bootmem_free
argument_list|(
name|tmp_page
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nr_pages
condition|;
name|i
operator|++
control|)
block|{
name|xen_machphys_update
argument_list|(
name|phys_machine
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|phys_machine
argument_list|,
name|INVALID_P2M_ENTRY
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ADD_ISA_HOLE */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|long
name|physfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pdir
decl_stmt|,
name|curoffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initvalues
parameter_list|(
name|start_info_t
modifier|*
name|startinfo
parameter_list|)
block|{
name|int
name|l3_pages
decl_stmt|,
name|l2_pages
decl_stmt|,
name|l1_pages
decl_stmt|,
name|offset
decl_stmt|;
name|vm_offset_t
name|cur_space
decl_stmt|,
name|cur_space_pt
decl_stmt|;
name|struct
name|physdev_set_iopl
name|set_iopl
decl_stmt|;
name|vm_paddr_t
name|console_page_ma
decl_stmt|,
name|xen_store_ma
decl_stmt|;
name|vm_offset_t
name|tmpva
decl_stmt|;
name|vm_paddr_t
name|shinfo
decl_stmt|;
ifdef|#
directive|ifdef
name|PAE
name|vm_paddr_t
name|IdlePDPTma
decl_stmt|,
name|IdlePDPTnewma
decl_stmt|;
name|vm_paddr_t
name|IdlePTDnewma
index|[
literal|4
index|]
decl_stmt|;
name|pd_entry_t
modifier|*
name|IdlePDPTnew
decl_stmt|,
modifier|*
name|IdlePTDnew
decl_stmt|;
name|vm_paddr_t
name|IdlePTDma
index|[
literal|4
index|]
decl_stmt|;
else|#
directive|else
name|vm_paddr_t
name|IdlePTDma
index|[
literal|1
index|]
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|ncpus
init|=
name|MAXCPU
decl_stmt|;
name|nkpt
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|max
argument_list|(
operator|(
name|startinfo
operator|->
name|nr_pages
operator|>>
name|NPGPTD_SHIFT
operator|)
argument_list|,
name|nkpt
argument_list|)
argument_list|,
name|NPGPTD
operator|*
name|NPDEPG
operator|-
name|KPTDI
argument_list|)
argument_list|,
operator|(
name|HYPERVISOR_VIRT_START
operator|-
name|KERNBASE
operator|)
operator|>>
name|PDRSHIFT
argument_list|)
expr_stmt|;
name|HYPERVISOR_vm_assist
argument_list|(
name|VMASST_CMD_enable
argument_list|,
name|VMASST_TYPE_4gb_segments
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * need to install handler 	 */
name|HYPERVISOR_vm_assist
argument_list|(
name|VMASST_CMD_enable
argument_list|,
name|VMASST_TYPE_4gb_segments_notify
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xen_start_info
operator|=
name|startinfo
expr_stmt|;
name|xen_phys_machine
operator|=
operator|(
name|xen_pfn_t
operator|*
operator|)
name|startinfo
operator|->
name|mfn_list
expr_stmt|;
name|IdlePTD
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|startinfo
operator|->
name|pt_base
operator|+
name|PAGE_SIZE
operator|)
expr_stmt|;
name|l1_pages
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PAE
name|l3_pages
operator|=
literal|1
expr_stmt|;
name|l2_pages
operator|=
literal|0
expr_stmt|;
name|IdlePDPT
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|startinfo
operator|->
name|pt_base
expr_stmt|;
name|IdlePDPTma
operator|=
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|startinfo
operator|->
name|pt_base
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|KERNBASE
operator|>>
literal|30
operator|)
init|;
operator|(
name|i
operator|<
literal|4
operator|)
operator|&&
operator|(
name|IdlePDPT
index|[
name|i
index|]
operator|!=
literal|0
operator|)
condition|;
name|i
operator|++
control|)
name|l2_pages
operator|++
expr_stmt|;
comment|/* 	 * Note that only one page directory has been allocated at this point. 	 * Thus, if KERNBASE 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l2_pages
condition|;
name|i
operator|++
control|)
name|IdlePTDma
index|[
name|i
index|]
operator|=
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|IdlePTD
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|l2_pages
operator|=
operator|(
name|l2_pages
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
name|l2_pages
expr_stmt|;
else|#
directive|else
name|l3_pages
operator|=
literal|0
expr_stmt|;
name|l2_pages
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
operator|(
operator|(
operator|(
name|KERNBASE
operator|>>
literal|18
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
init|;
operator|(
name|i
operator|<
name|l2_pages
operator|*
name|NPDEPG
operator|)
operator|&&
operator|(
name|i
operator|<
operator|(
name|VM_MAX_KERNEL_ADDRESS
operator|>>
name|PDRSHIFT
operator|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IdlePTD
index|[
name|i
index|]
operator|==
literal|0
condition|)
break|break;
name|l1_pages
operator|++
expr_stmt|;
block|}
comment|/* number of pages allocated after the pts + 1*/
empty_stmt|;
name|cur_space
operator|=
name|xen_start_info
operator|->
name|pt_base
operator|+
operator|(
name|l3_pages
operator|+
name|l2_pages
operator|+
name|l1_pages
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|printk
argument_list|(
literal|"initvalues(): wooh - availmem=%x,%x\n"
argument_list|,
name|avail_space
argument_list|,
name|cur_space
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"KERNBASE=%x,pt_base=%x, VTOPFN(base)=%x, nr_pt_frames=%x\n"
argument_list|,
name|KERNBASE
argument_list|,
name|xen_start_info
operator|->
name|pt_base
argument_list|,
name|VTOPFN
argument_list|(
name|xen_start_info
operator|->
name|pt_base
argument_list|)
argument_list|,
name|xen_start_info
operator|->
name|nr_pt_frames
argument_list|)
expr_stmt|;
name|xendebug_flags
operator|=
literal|0
expr_stmt|;
comment|/* 0xffffffff; */
ifdef|#
directive|ifdef
name|ADD_ISA_HOLE
name|shift_phys_machine
argument_list|(
name|xen_phys_machine
argument_list|,
name|xen_start_info
operator|->
name|nr_pages
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*  	 * pre-zero unused mapped pages - mapped on 4MB boundary 	 */
name|XENPRINTF
argument_list|(
literal|"IdlePTD %p\n"
argument_list|,
name|IdlePTD
argument_list|)
expr_stmt|;
name|XENPRINTF
argument_list|(
literal|"nr_pages: %ld shared_info: 0x%lx flags: 0x%lx pt_base: 0x%lx "
literal|"mod_start: 0x%lx mod_len: 0x%lx\n"
argument_list|,
name|xen_start_info
operator|->
name|nr_pages
argument_list|,
name|xen_start_info
operator|->
name|shared_info
argument_list|,
name|xen_start_info
operator|->
name|flags
argument_list|,
name|xen_start_info
operator|->
name|pt_base
argument_list|,
name|xen_start_info
operator|->
name|mod_start
argument_list|,
name|xen_start_info
operator|->
name|mod_len
argument_list|)
expr_stmt|;
comment|/* Map proc0's KSTACK */
ifdef|#
directive|ifdef
name|PAE
name|IdlePDPTnew
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|bzero
argument_list|(
name|IdlePDPTnew
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|IdlePDPTnewma
operator|=
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|IdlePDPTnew
argument_list|)
argument_list|)
expr_stmt|;
name|IdlePTDnew
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
literal|4
operator|*
name|PAGE_SIZE
expr_stmt|;
name|bzero
argument_list|(
name|IdlePTDnew
argument_list|,
literal|4
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|IdlePTDnewma
index|[
name|i
index|]
operator|=
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|IdlePTDnew
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * L3 	 * 	 * Copy the 4 machine addresses of the new PTDs in to the PDPT 	 *  	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|IdlePDPTnew
index|[
name|i
index|]
operator|=
name|IdlePTDnewma
index|[
name|i
index|]
operator||
name|PG_V
expr_stmt|;
comment|/* 	 * 	 * re-map the new PDPT read-only 	 */
name|PT_SET_MA
argument_list|(
name|IdlePDPTnew
argument_list|,
name|IdlePDPTnewma
operator||
name|PG_V
argument_list|)
expr_stmt|;
comment|/* 	 *  	 * Unpin the current PDPT 	 */
name|xen_pt_unpin
argument_list|(
name|IdlePDPTma
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PAE */
name|proc0kstack
operator|=
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
operator|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|printk
argument_list|(
literal|"proc0kstack=%u\n"
argument_list|,
name|proc0kstack
argument_list|)
expr_stmt|;
comment|/* vm86/bios stack */
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* Map space for the vm86 region */
name|vm86paddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
operator|(
name|PAGE_SIZE
operator|*
literal|3
operator|)
expr_stmt|;
comment|/* allocate 4 pages for bootmem allocator */
name|bootmem_start
operator|=
name|bootmem_current
operator|=
operator|(
name|char
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
operator|(
literal|4
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|bootmem_end
operator|=
operator|(
name|char
operator|*
operator|)
name|cur_space
expr_stmt|;
comment|/* allocate pages for gdt */
name|gdt
operator|=
operator|(
expr|union
name|descriptor
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
operator|*
name|ncpus
expr_stmt|;
comment|/* allocate page for ldt */
name|ldt
operator|=
operator|(
expr|union
name|descriptor
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* unmap remaining pages from initial 4MB chunk 	 * 	 */
for|for
control|(
name|tmpva
operator|=
name|cur_space
init|;
operator|(
name|tmpva
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|22
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|;
name|tmpva
operator|+=
name|PAGE_SIZE
control|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmpva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|tmpva
argument_list|,
operator|(
name|vm_paddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|IdlePTDnew
operator|)
operator|+
operator|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|KERNBASE
operator|>>
literal|18
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|IdlePTD
operator|)
operator|+
operator|(
operator|(
name|KERNBASE
operator|>>
literal|18
operator|)
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|l1_pages
operator|*
sizeof|sizeof
argument_list|(
name|pt_entry_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|PT_SET_MA
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|IdlePTDnew
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
name|IdlePTDnewma
index|[
name|i
index|]
operator||
name|PG_V
argument_list|)
expr_stmt|;
block|}
name|xen_load_cr3
argument_list|(
name|VTOP
argument_list|(
name|IdlePDPTnew
argument_list|)
argument_list|)
expr_stmt|;
name|xen_pgdpt_pin
argument_list|(
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|IdlePDPTnew
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate remainder of nkpt pages */
name|cur_space_pt
operator|=
name|cur_space
expr_stmt|;
for|for
control|(
name|offset
operator|=
operator|(
name|KERNBASE
operator|>>
name|PDRSHIFT
operator|)
operator|,
name|i
operator|=
name|l1_pages
init|;
name|i
operator|<
name|nkpt
condition|;
name|i
operator|++
operator|,
name|cur_space
operator|+=
name|PAGE_SIZE
control|)
block|{
name|pdir
operator|=
operator|(
name|offset
operator|+
name|i
operator|)
operator|/
name|NPDEPG
expr_stmt|;
name|curoffset
operator|=
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|%
name|NPDEPG
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|offset
operator|+
name|i
operator|)
operator|<<
name|PDRSHIFT
operator|)
operator|==
name|VM_MAX_KERNEL_ADDRESS
condition|)
break|break;
comment|/* 		 * make sure that all the initial page table pages 		 * have been zeroed 		 */
name|PT_SET_MA
argument_list|(
name|cur_space
argument_list|,
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|cur_space
argument_list|)
argument_list|)
operator||
name|PG_V
operator||
name|PG_RW
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cur_space
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|cur_space
argument_list|,
operator|(
name|vm_paddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
name|xen_pt_pin
argument_list|(
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|cur_space
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xen_queue_pt_update
argument_list|(
call|(
name|vm_paddr_t
call|)
argument_list|(
name|IdlePTDnewma
index|[
name|pdir
index|]
operator|+
name|curoffset
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|)
argument_list|,
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|cur_space
argument_list|)
argument_list|)
operator||
name|PG_KERNEL
argument_list|)
expr_stmt|;
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|pdir
operator|=
operator|(
name|PTDPTDI
operator|+
name|i
operator|)
operator|/
name|NPDEPG
expr_stmt|;
name|curoffset
operator|=
operator|(
name|PTDPTDI
operator|+
name|i
operator|)
operator|%
name|NPDEPG
expr_stmt|;
name|xen_queue_pt_update
argument_list|(
call|(
name|vm_paddr_t
call|)
argument_list|(
name|IdlePTDnewma
index|[
name|pdir
index|]
operator|+
name|curoffset
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|)
argument_list|,
name|IdlePTDnewma
index|[
name|i
index|]
operator||
name|PG_V
argument_list|)
expr_stmt|;
block|}
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
name|IdlePTD
operator|=
name|IdlePTDnew
expr_stmt|;
name|IdlePDPT
operator|=
name|IdlePDPTnew
expr_stmt|;
name|IdlePDPTma
operator|=
name|IdlePDPTnewma
expr_stmt|;
name|HYPERVISOR_shared_info
operator|=
operator|(
name|shared_info_t
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|xen_store
operator|=
operator|(
expr|struct
name|ringbuf_head
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|console_page
operator|=
operator|(
name|char
operator|*
operator|)
name|cur_space
expr_stmt|;
name|cur_space
operator|+=
name|PAGE_SIZE
expr_stmt|;
comment|/* 	 * shared_info is an unsigned long so this will randomly break if 	 * it is allocated above 4GB - I guess people are used to that 	 * sort of thing with Xen ... sigh 	 */
name|shinfo
operator|=
name|xen_start_info
operator|->
name|shared_info
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|HYPERVISOR_shared_info
argument_list|,
name|shinfo
operator||
name|PG_KERNEL
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"#4\n"
argument_list|)
expr_stmt|;
name|xen_store_ma
operator|=
operator|(
operator|(
operator|(
name|vm_paddr_t
operator|)
name|xen_start_info
operator|->
name|store_mfn
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|xen_store
argument_list|,
name|xen_store_ma
operator||
name|PG_KERNEL
argument_list|)
expr_stmt|;
name|console_page_ma
operator|=
operator|(
operator|(
operator|(
name|vm_paddr_t
operator|)
name|xen_start_info
operator|->
name|console
operator|.
name|domU
operator|.
name|mfn
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|console_page
argument_list|,
name|console_page_ma
operator||
name|PG_KERNEL
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"#5\n"
argument_list|)
expr_stmt|;
name|HYPERVISOR_shared_info
operator|->
name|arch
operator|.
name|pfn_to_mfn_frame_list_list
operator|=
operator|(
name|unsigned
name|long
operator|)
name|xen_phys_machine
expr_stmt|;
name|set_iopl
operator|.
name|iopl
operator|=
literal|1
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_physdev_op
argument_list|(
name|PHYSDEVOP_SET_IOPL
argument_list|,
operator|&
name|set_iopl
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"#6\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* add page table for KERNBASE */
block|xen_queue_pt_update(IdlePTDma + KPTDI*sizeof(vm_paddr_t),  			    xpmap_ptom(VTOP(cur_space) | PG_KERNEL)); 	xen_flush_queue();
ifdef|#
directive|ifdef
name|PAE
block|xen_queue_pt_update(pdir_shadow_ma[3] + KPTDI*sizeof(vm_paddr_t),  			    xpmap_ptom(VTOP(cur_space) | PG_V | PG_A));
else|#
directive|else
block|xen_queue_pt_update(pdir_shadow_ma + KPTDI*sizeof(vm_paddr_t),  			    xpmap_ptom(VTOP(cur_space) | PG_V | PG_A));
endif|#
directive|endif
block|xen_flush_queue(); 	cur_space += PAGE_SIZE; 	printk("#6\n");
endif|#
directive|endif
comment|/* 0 */
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|xen_start_info
operator|->
name|flags
operator|&
name|SIF_INITDOMAIN
condition|)
block|{
comment|/* Map first megabyte */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
literal|256
operator|<<
name|PAGE_SHIFT
operator|)
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
name|PT_SET_MA
argument_list|(
name|KERNBASE
operator|+
name|i
argument_list|,
name|i
operator||
name|PG_KERNEL
operator||
name|PG_NC_PCD
argument_list|)
expr_stmt|;
name|xen_flush_queue
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * re-map kernel text read-only 	 * 	 */
for|for
control|(
name|i
operator|=
operator|(
operator|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|btext
operator|)
operator|&
operator|~
name|PAGE_MASK
operator|)
init|;
name|i
operator|<
operator|(
operator|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|etext
operator|)
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|;
name|i
operator|+=
name|PAGE_SIZE
control|)
name|PT_SET_MA
argument_list|(
name|i
argument_list|,
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|i
argument_list|)
argument_list|)
operator||
name|PG_V
operator||
name|PG_A
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"#7\n"
argument_list|)
expr_stmt|;
name|physfree
operator|=
name|VTOP
argument_list|(
name|cur_space
argument_list|)
expr_stmt|;
name|init_first
operator|=
name|physfree
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|IdlePTD
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|VTOP
argument_list|(
name|IdlePTD
argument_list|)
expr_stmt|;
name|IdlePDPT
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|VTOP
argument_list|(
name|IdlePDPT
argument_list|)
expr_stmt|;
name|setup_xen_features
argument_list|()
expr_stmt|;
name|printk
argument_list|(
literal|"#8, proc0kstack=%u\n"
argument_list|,
name|proc0kstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|trap_info_t
name|trap_table
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|div
argument_list|)
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|dbg
argument_list|)
block|}
block|,
block|{
literal|3
block|,
literal|3
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|bpt
argument_list|)
block|}
block|,
block|{
literal|4
block|,
literal|3
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|ofl
argument_list|)
block|}
block|,
comment|/* This is UPL on Linux and KPL on BSD */
block|{
literal|5
block|,
literal|3
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|bnd
argument_list|)
block|}
block|,
block|{
literal|6
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|ill
argument_list|)
block|}
block|,
block|{
literal|7
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|dna
argument_list|)
block|}
block|,
comment|/* 	 * { 8,   0, GSEL(GCODE_SEL, SEL_KPL), (unsigned long)&IDTVEC(XXX)}, 	 *   no handler for double fault 	 */
block|{
literal|9
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|fpusegm
argument_list|)
block|}
block|,
block|{
literal|10
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|tss
argument_list|)
block|}
block|,
block|{
literal|11
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|missing
argument_list|)
block|}
block|,
block|{
literal|12
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|stk
argument_list|)
block|}
block|,
block|{
literal|13
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|prot
argument_list|)
block|}
block|,
block|{
literal|14
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|page
argument_list|)
block|}
block|,
block|{
literal|15
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|rsvd
argument_list|)
block|}
block|,
block|{
literal|16
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|fpu
argument_list|)
block|}
block|,
block|{
literal|17
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|align
argument_list|)
block|}
block|,
block|{
literal|18
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|mchk
argument_list|)
block|}
block|,
block|{
literal|19
block|,
literal|0
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|xmm
argument_list|)
block|}
block|,
block|{
literal|0x80
block|,
literal|3
block|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
block|,
operator|(
name|unsigned
name|long
operator|)
operator|&
name|IDTVEC
argument_list|(
argument|int0x80_syscall
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/********** CODE WORTH KEEPING ABOVE HERE *****************/
end_comment

begin_function_decl
name|void
name|xen_failsafe_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|xen_failsafe_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|panic
argument_list|(
literal|"xen_failsafe_handler called!\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
name|xen_handle_thread_switch
parameter_list|(
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This is called by cpu_switch() when switching threads. */
end_comment

begin_comment
comment|/* The pcb arg refers to the process control block of the */
end_comment

begin_comment
comment|/* next thread which is to run */
end_comment

begin_function
name|void
name|xen_handle_thread_switch
parameter_list|(
name|struct
name|pcb
modifier|*
name|pcb
parameter_list|)
block|{
name|uint32_t
modifier|*
name|a
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|PCPU_GET
argument_list|(
name|fsgs_gdt
argument_list|)
index|[
literal|0
index|]
decl_stmt|;
name|uint32_t
modifier|*
name|b
init|=
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|pcb
operator|->
name|pcb_fsd
decl_stmt|;
name|multicall_entry_t
name|mcl
index|[
literal|3
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Notify Xen of task switch */
name|mcl
index|[
name|i
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_stack_switch
expr_stmt|;
name|mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|mcl
index|[
name|i
operator|++
index|]
operator|.
name|args
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pcb
expr_stmt|;
comment|/* Check for update of fsd */
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|||
operator|*
operator|(
name|a
operator|+
literal|1
operator|)
operator|!=
operator|*
operator|(
name|b
operator|+
literal|1
operator|)
condition|)
block|{
name|mcl
index|[
name|i
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_update_descriptor
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|vtomach
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|a
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mcl
index|[
name|i
operator|++
index|]
operator|.
name|args
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|b
expr_stmt|;
block|}
name|a
operator|+=
literal|2
expr_stmt|;
name|b
operator|+=
literal|2
expr_stmt|;
comment|/* Check for update of gsd */
if|if
condition|(
operator|*
name|a
operator|!=
operator|*
name|b
operator|||
operator|*
operator|(
name|a
operator|+
literal|1
operator|)
operator|!=
operator|*
operator|(
name|b
operator|+
literal|1
operator|)
condition|)
block|{
name|mcl
index|[
name|i
index|]
operator|.
name|op
operator|=
name|__HYPERVISOR_update_descriptor
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mcl
index|[
name|i
index|]
operator|.
name|args
index|[
literal|0
index|]
operator|=
name|vtomach
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|a
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|mcl
index|[
name|i
operator|++
index|]
operator|.
name|args
index|[
literal|2
index|]
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|b
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|HYPERVISOR_multicall
argument_list|(
name|mcl
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

