begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996, by Steve Passe  * Copyright (c) 2008, by Kip Macy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_apic.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_mp_watchdog.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
end_if

begin_error
error|#
directive|error
error|How did you get here?
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEV_APIC
end_ifndef

begin_error
error|#
directive|error
error|The apic device is required for SMP, add "device apic" to your config file.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CPU_DISABLE_CMPXCHG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|COMPILING_LINT
argument_list|)
end_if

begin_error
error|#
directive|error
error|SMP not supported with CPU_DISABLE_CMPXCHG
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cngetc() */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mp_watchdog.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/xen/xen-os.h>
end_include

begin_include
include|#
directive|include
file|<xen/evtchn.h>
end_include

begin_include
include|#
directive|include
file|<xen/xen_intr.h>
end_include

begin_include
include|#
directive|include
file|<xen/hypervisor.h>
end_include

begin_include
include|#
directive|include
file|<xen/interface/vcpu.h>
end_include

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bootAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|descriptor
modifier|*
name|bootAPgdt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|resched_name
index|[
name|NR_CPUS
index|]
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|callfunc_name
index|[
name|NR_CPUS
index|]
index|[
literal|15
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free these after use */
end_comment

begin_decl_stmt
name|void
modifier|*
name|bootstacks
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|stoppcbs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables needed for SMP tlb shootdown. */
end_comment

begin_decl_stmt
name|vm_offset_t
name|smp_tlb_addr1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|smp_tlb_addr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|int
name|smp_tlb_wait
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|void
name|call_data_func_t
parameter_list|(
name|uintptr_t
parameter_list|,
name|uintptr_t
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|u_int
name|logical_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|cpumask_t
name|ipi_nmi_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to hold the AP's until we are ready to release them */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ap_boot_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 once we're ready to let the APs out of the pen. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|aps_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Store data from cpu_add() until later in the boot when we actually setup  * the APs.  */
end_comment

begin_struct
struct|struct
name|cpu_info
block|{
name|int
name|cpu_present
range|:
literal|1
decl_stmt|;
name|int
name|cpu_bsp
range|:
literal|1
decl_stmt|;
name|int
name|cpu_disabled
range|:
literal|1
decl_stmt|;
block|}
decl|static
name|cpu_info
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
struct|;
end_struct

begin_decl_stmt
name|int
name|cpu_apic_ids
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_cpuids
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds pending bitmap based IPIs per CPU */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|cpu_ipi_pending
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_logical
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cpu_cores
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|assign_cpu_ids
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_interrupt_apic_ids
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|start_all_aps
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|hyperthreading_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cpumask_t
name|hyperthreading_cpus_mask
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|Xhypervisor_callback
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|failsafe_callback
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pmap_lazyfix_action
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|cpu_group
modifier|*
name|cpu_topo
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cpu_cores
operator|==
literal|0
condition|)
name|cpu_cores
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cpu_logical
operator|==
literal|0
condition|)
name|cpu_logical
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|%
operator|(
name|cpu_cores
operator|*
name|cpu_logical
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: Non-uniform processors.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"WARNING: Using suboptimal topology.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|smp_topo_none
argument_list|()
operator|)
return|;
block|}
comment|/* 	 * No multi-core or hyper-threaded. 	 */
if|if
condition|(
name|cpu_logical
operator|*
name|cpu_cores
operator|==
literal|1
condition|)
return|return
operator|(
name|smp_topo_none
argument_list|()
operator|)
return|;
comment|/* 	 * Only HTT no multi-core. 	 */
if|if
condition|(
name|cpu_logical
operator|>
literal|1
operator|&&
name|cpu_cores
operator|==
literal|1
condition|)
return|return
operator|(
name|smp_topo_1level
argument_list|(
name|CG_SHARE_L1
argument_list|,
name|cpu_logical
argument_list|,
name|CG_FLAG_HTT
argument_list|)
operator|)
return|;
comment|/* 	 * Only multi-core no HTT. 	 */
if|if
condition|(
name|cpu_cores
operator|>
literal|1
operator|&&
name|cpu_logical
operator|==
literal|1
condition|)
return|return
operator|(
name|smp_topo_1level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
name|cpu_cores
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* 	 * Both HTT and multi-core. 	 */
return|return
operator|(
name|smp_topo_2level
argument_list|(
name|CG_SHARE_NONE
argument_list|,
name|cpu_cores
argument_list|,
name|CG_SHARE_L1
argument_list|,
name|cpu_logical
argument_list|,
name|CG_FLAG_HTT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
return|return
operator|(
name|basemem
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cpu_add
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|char
name|boot_cpu
parameter_list|)
block|{
if|if
condition|(
name|apic_id
operator|>
name|MAX_APIC_ID
condition|)
block|{
name|panic
argument_list|(
literal|"SMP: APIC ID %d too high"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|==
literal|0
argument_list|,
operator|(
literal|"CPU %d added twice"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
block|{
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"CPU %d claims to be BSP, but CPU %d already is"
operator|,
name|apic_id
operator|,
name|boot_cpu_id
operator|)
argument_list|)
expr_stmt|;
name|boot_cpu_id
operator|=
name|apic_id
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mp_ncpus
operator|<
name|MAXCPU
condition|)
name|mp_ncpus
operator|++
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"SMP: Added CPU %d (%s)\n"
argument_list|,
name|apic_id
argument_list|,
name|boot_cpu
condition|?
literal|"BSP"
else|:
literal|"AP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpu_mp_setmaxid
parameter_list|(
name|void
parameter_list|)
block|{
name|mp_maxid
operator|=
name|MAXCPU
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Always record BSP in CPU map so that the mbuf init code works 	 * correctly. 	 */
name|all_cpus
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No CPUs were found, so this must be a UP system.  Setup 		 * the variables to represent a system with a single CPU 		 * with an id of 0. 		 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At least one CPU was found. */
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
block|{
comment|/* 		 * One CPU was found, so this must be a UP system with 		 * an I/O APIC. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At least two CPUs were found. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the IPI handlers and start up the AP's.  */
end_comment

begin_function
name|void
name|cpu_mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Initialize the logical ID to APIC ID table. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|cpu_apic_ids
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|cpu_ipi_pending
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Set boot_cpu_id if needed. */
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
block|{
name|boot_cpu_id
operator|=
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|boot_cpu_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|,
operator|(
literal|"BSP's APIC ID doesn't match boot_cpu_id"
operator|)
argument_list|)
expr_stmt|;
name|cpu_apic_ids
index|[
literal|0
index|]
operator|=
name|boot_cpu_id
expr_stmt|;
name|apic_cpuids
index|[
name|boot_cpu_id
index|]
operator|=
literal|0
expr_stmt|;
name|assign_cpu_ids
argument_list|()
expr_stmt|;
comment|/* Start each Application Processor */
name|start_all_aps
argument_list|()
expr_stmt|;
comment|/* Setup the initial logical CPUs info. */
name|logical_cpus
operator|=
name|logical_cpus_mask
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpu_feature
operator|&
name|CPUID_HTT
condition|)
name|logical_cpus
operator|=
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
expr_stmt|;
name|set_interrupt_apic_ids
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iv_rendezvous
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|smp_rendezvous_action
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iv_invltlb
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|xen_tlb_flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iv_invlpg
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|xen_invlpg
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iv_invlrng
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|vm_offset_t
name|start
init|=
operator|(
name|vm_offset_t
operator|)
name|a
decl_stmt|;
name|vm_offset_t
name|end
init|=
operator|(
name|vm_offset_t
operator|)
name|b
decl_stmt|;
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|xen_invlpg
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iv_invlcache
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|wbinvd
argument_list|()
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iv_lazypmap
parameter_list|(
name|uintptr_t
name|a
parameter_list|,
name|uintptr_t
name|b
parameter_list|)
block|{
name|pmap_lazyfix_action
argument_list|()
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These start from "IPI offset" APIC_IPI_INTS  */
end_comment

begin_decl_stmt
specifier|static
name|call_data_func_t
modifier|*
name|ipi_vectors
index|[
literal|6
index|]
init|=
block|{
name|iv_rendezvous
block|,
name|iv_invltlb
block|,
name|iv_invlpg
block|,
name|iv_invlrng
block|,
name|iv_invlcache
block|,
name|iv_lazypmap
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reschedule call back. Nothing to do,  * all the work is done automatically when  * we return from the interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|smp_reschedule_interrupt
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|u_int
name|ipi_bitmap
decl_stmt|;
name|ipi_bitmap
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_PREEMPT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_preempt_counts
index|[
name|cpu
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
name|sched_preempt
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_AST
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_ast_counts
index|[
name|cpu
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Nothing to do for AST */
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|_call_data
block|{
name|uint16_t
name|func_id
decl_stmt|;
name|uint16_t
name|wait
decl_stmt|;
name|uintptr_t
name|arg1
decl_stmt|;
name|uintptr_t
name|arg2
decl_stmt|;
name|atomic_t
name|started
decl_stmt|;
name|atomic_t
name|finished
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|_call_data
modifier|*
name|call_data
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|smp_call_function_interrupt
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|call_data_func_t
modifier|*
name|func
decl_stmt|;
name|uintptr_t
name|arg1
init|=
name|call_data
operator|->
name|arg1
decl_stmt|;
name|uintptr_t
name|arg2
init|=
name|call_data
operator|->
name|arg2
decl_stmt|;
name|int
name|wait
init|=
name|call_data
operator|->
name|wait
decl_stmt|;
name|atomic_t
modifier|*
name|started
init|=
operator|&
name|call_data
operator|->
name|started
decl_stmt|;
name|atomic_t
modifier|*
name|finished
init|=
operator|&
name|call_data
operator|->
name|finished
decl_stmt|;
comment|/* We only handle function IPIs, not bitmap IPIs */
if|if
condition|(
name|call_data
operator|->
name|func_id
operator|<
name|APIC_IPI_INTS
operator|||
name|call_data
operator|->
name|func_id
operator|>
name|IPI_BITMAP_VECTOR
condition|)
name|panic
argument_list|(
literal|"invalid function id %u"
argument_list|,
name|call_data
operator|->
name|func_id
argument_list|)
expr_stmt|;
name|func
operator|=
name|ipi_vectors
index|[
name|call_data
operator|->
name|func_id
operator|-
name|APIC_IPI_INTS
index|]
expr_stmt|;
comment|/* 	 * Notify initiating CPU that I've grabbed the data and am 	 * about to execute the function 	 */
name|mb
argument_list|()
expr_stmt|;
name|atomic_inc
argument_list|(
name|started
argument_list|)
expr_stmt|;
comment|/* 	 * At this point the info structure may be out of scope unless wait==1 	 */
call|(
modifier|*
name|func
call|)
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
condition|)
block|{
name|mb
argument_list|()
expr_stmt|;
name|atomic_inc
argument_list|(
name|finished
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|cpu_mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|x
decl_stmt|;
comment|/* List CPUs */
name|printf
argument_list|(
literal|" cpu0 (BSP): APIC ID: %2d\n"
argument_list|,
name|boot_cpu_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|MAX_APIC_ID
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_present
operator|||
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|x
index|]
operator|.
name|cpu_disabled
condition|)
name|printf
argument_list|(
literal|"  cpu (AP): APIC ID: %2d (disabled)\n"
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|i
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"mp_ncpus and actual cpus are out of whack"
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cpu%d (AP): APIC ID: %2d\n"
argument_list|,
name|i
operator|++
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xen_smp_intr_init
parameter_list|(
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|per_cpu
argument_list|(
name|resched_irq
argument_list|,
name|cpu
argument_list|)
operator|=
name|per_cpu
argument_list|(
name|callfunc_irq
argument_list|,
name|cpu
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|resched_name
index|[
name|cpu
index|]
argument_list|,
literal|"resched%u"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bind_ipi_to_irqhandler
argument_list|(
name|RESCHEDULE_VECTOR
argument_list|,
name|cpu
argument_list|,
name|resched_name
index|[
name|cpu
index|]
argument_list|,
name|smp_reschedule_interrupt
argument_list|,
name|INTR_FAST
operator||
name|INTR_TYPE_TTY
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[XEN] IPI cpu=%d irq=%d vector=RESCHEDULE_VECTOR (%d)\n"
argument_list|,
name|cpu
argument_list|,
name|irq
argument_list|,
name|RESCHEDULE_VECTOR
argument_list|)
expr_stmt|;
name|per_cpu
argument_list|(
name|resched_irq
argument_list|,
name|cpu
argument_list|)
operator|=
name|irq
expr_stmt|;
name|sprintf
argument_list|(
name|callfunc_name
index|[
name|cpu
index|]
argument_list|,
literal|"callfunc%u"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bind_ipi_to_irqhandler
argument_list|(
name|CALL_FUNCTION_VECTOR
argument_list|,
name|cpu
argument_list|,
name|callfunc_name
index|[
name|cpu
index|]
argument_list|,
name|smp_call_function_interrupt
argument_list|,
name|INTR_FAST
operator||
name|INTR_TYPE_TTY
operator||
name|INTR_MPSAFE
argument_list|,
operator|&
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|per_cpu
argument_list|(
name|callfunc_irq
argument_list|,
name|cpu
argument_list|)
operator|=
name|irq
expr_stmt|;
name|printf
argument_list|(
literal|"[XEN] IPI cpu=%d irq=%d vector=CALL_FUNCTION_VECTOR (%d)\n"
argument_list|,
name|cpu
argument_list|,
name|irq
argument_list|,
name|CALL_FUNCTION_VECTOR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpu
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|rc
operator|=
name|ap_cpu_initclocks
argument_list|(
name|cpu
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|fail
goto|;
return|return
literal|0
return|;
name|fail
label|:
if|if
condition|(
name|per_cpu
argument_list|(
name|resched_irq
argument_list|,
name|cpu
argument_list|)
operator|>=
literal|0
condition|)
name|unbind_from_irqhandler
argument_list|(
name|per_cpu
argument_list|(
name|resched_irq
argument_list|,
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|per_cpu
argument_list|(
name|callfunc_irq
argument_list|,
name|cpu
argument_list|)
operator|>=
literal|0
condition|)
name|unbind_from_irqhandler
argument_list|(
name|per_cpu
argument_list|(
name|callfunc_irq
argument_list|,
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xen_smp_intr_init_cpus
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
name|xen_smp_intr_init
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MTOPSIZE
value|(1<<(14 + PAGE_SHIFT))
end_define

begin_comment
comment|/*  * AP CPU's call this to initialize themselves.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|int
name|gsel_tss
decl_stmt|;
comment|/* bootAP is set in start_ap() to our ID. */
name|PCPU_SET
argument_list|(
name|currentldt
argument_list|,
name|_default_ldt
argument_list|)
expr_stmt|;
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|gdt[bootAP * NGDT + GPROC0_SEL].sd.sd_type = SDT_SYS386TSS;
endif|#
directive|endif
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_esp0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* not used until after switch */
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_ss0
argument_list|,
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|common_tss
operator|.
name|tss_ioopt
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|i386tss
argument_list|)
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|PCPU_SET(tss_gdt,&gdt[bootAP * NGDT + GPROC0_SEL].sd);  	PCPU_SET(common_tssd, *PCPU_GET(tss_gdt));
endif|#
directive|endif
name|PCPU_SET
argument_list|(
name|fsgs_gdt
argument_list|,
operator|&
name|gdt
index|[
name|GUFS_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
comment|/* 	 * Set to a known state: 	 * Set by mpboot.s: CR0_PG, CR0_PE 	 * Set by cpu_setregs: CR0_NE, CR0_MP, CR0_TS, CR0_WP, CR0_AM 	 */
comment|/* 	 * signal our startup to the BSP. 	 */
name|mp_naps
operator|++
expr_stmt|;
comment|/* Spin until the BSP releases the AP's. */
while|while
condition|(
operator|!
name|aps_ready
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
comment|/* BSP may have changed PTD while we were waiting */
name|invltlb
argument_list|()
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|NKPT
operator|*
name|NBPDR
operator|-
literal|1
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
name|invlpg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* set up FPU state on the AP */
name|npxinit
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* set up SSE registers */
block|enable_sse();
endif|#
directive|endif
if|#
directive|if
literal|0
operator|&&
name|defined
argument_list|(
name|PAE
argument_list|)
comment|/* Enable the PTE no-execute bit. */
block|if ((amd_feature& AMDID_NX) != 0) { 		uint64_t msr;  		msr = rdmsr(MSR_EFER) | EFER_NXE; 		wrmsr(MSR_EFER, msr); 	}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* A quick check from sanity claus */
block|if (PCPU_GET(apic_id) != lapic_id()) { 		printf("SMP: cpuid = %d\n", PCPU_GET(cpuid)); 		printf("SMP: actual apic_id = %d\n", lapic_id()); 		printf("SMP: correct apic_id = %d\n", PCPU_GET(apic_id)); 		panic("cpuid mismatch! boom!!"); 	}
endif|#
directive|endif
comment|/* Initialize curthread. */
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no idle thread"
operator|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curthread
argument_list|,
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Init local apic for irq's */
block|lapic_setup(1);
endif|#
directive|endif
name|smp_cpus
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"SMP: AP CPU #%d Launched"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d Launched!\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if we are a logical CPU. */
if|if
condition|(
name|logical_cpus
operator|>
literal|1
operator|&&
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|%
name|logical_cpus
operator|!=
literal|0
condition|)
name|logical_cpus_mask
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Determine if we are a hyperthread. */
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
name|hyperthreading_cpus_mask
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Build our map of 'other' CPUs. */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (bootverbose) 		lapic_dump("AP");
endif|#
directive|endif
if|if
condition|(
name|smp_cpus
operator|==
name|mp_ncpus
condition|)
block|{
comment|/* enable IPI's, tlb shootdown, freezes etc */
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_started
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|smp_active
operator|=
literal|1
expr_stmt|;
comment|/* historic */
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* wait until all the AP's are up */
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curthread
argument_list|,
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
argument_list|)
expr_stmt|;
comment|/* enter the scheduler */
name|sched_throw
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"scheduler returned us to %s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * We tell the I/O APIC code about all the CPUs we want to receive  * interrupts.  If we don't want certain CPUs to receive IRQs we  * can simply not tell the I/O APIC code about them in this function.  * We also do not tell it about the BSP since it tells itself about  * the BSP internally to work with UP kernels and on UP machines.  */
end_comment

begin_function
specifier|static
name|void
name|set_interrupt_apic_ids
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|apic_id
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|apic_id
operator|=
name|cpu_apic_ids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|apic_id
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_disabled
condition|)
continue|continue;
comment|/* Don't let hyperthreads service interrupts. */
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|apic_id
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
continue|continue;
name|intr_add_cpu
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Assign logical CPU IDs to local APICs.  */
end_comment

begin_function
specifier|static
name|void
name|assign_cpu_ids
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
comment|/* Check for explicitly disabled CPUs. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_APIC_ID
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_present
operator|||
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
comment|/* Don't use this CPU if it has been disabled by a tunable. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"lapic"
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 	 * Assign CPU IDs to local APIC IDs and disable any CPUs 	 * beyond MAXCPU.  CPU 0 has already been assigned to the BSP, 	 * so we only have to assign IDs for APs. 	 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_APIC_ID
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_present
operator|||
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_bsp
operator|||
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_disabled
condition|)
continue|continue;
if|if
condition|(
name|mp_ncpus
operator|<
name|MAXCPU
condition|)
block|{
name|cpu_apic_ids
index|[
name|mp_ncpus
index|]
operator|=
name|i
expr_stmt|;
name|apic_cpuids
index|[
name|i
index|]
operator|=
name|mp_ncpus
expr_stmt|;
name|mp_ncpus
operator|++
expr_stmt|;
block|}
else|else
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|mp_maxid
operator|>=
name|mp_ncpus
operator|-
literal|1
argument_list|,
operator|(
literal|"%s: counters out of sync: max %d, count %d"
operator|,
name|__func__
operator|,
name|mp_maxid
operator|,
name|mp_ncpus
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start each AP in our list  */
end_comment

begin_comment
comment|/* Lowest 1MB is already mapped: don't touch*/
end_comment

begin_define
define|#
directive|define
name|TMPMAP_START
value|1
end_define

begin_function
name|int
name|start_all_aps
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|apic_id
decl_stmt|,
name|cpu
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|,
literal|"ap boot"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* set up temporary P==V mapping for AP boot */
comment|/* XXX this is a hack, we should boot the AP on its own stack/PTD */
comment|/* start each AP */
for|for
control|(
name|cpu
operator|=
literal|1
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
name|apic_id
operator|=
name|cpu_apic_ids
index|[
name|cpu
index|]
expr_stmt|;
name|bootAP
operator|=
name|cpu
expr_stmt|;
name|bootAPgdt
operator|=
name|gdt
operator|+
operator|(
literal|512
operator|*
name|cpu
operator|)
expr_stmt|;
comment|/* Get per-cpu data */
name|pc
operator|=
operator|&
name|__pcpu
index|[
name|bootAP
index|]
expr_stmt|;
name|pcpu_init
argument_list|(
name|pc
argument_list|,
name|bootAP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pcpu
argument_list|)
argument_list|)
expr_stmt|;
name|dpcpu_init
argument_list|(
operator|(
name|void
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|DPCPU_SIZE
argument_list|)
argument_list|,
name|bootAP
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_apic_id
operator|=
name|cpu_apic_ids
index|[
name|bootAP
index|]
expr_stmt|;
name|pc
operator|->
name|pc_prvspace
operator|=
name|pc
expr_stmt|;
name|pc
operator|->
name|pc_curthread
operator|=
literal|0
expr_stmt|;
name|gdt_segs
index|[
name|GPRIV_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
name|pc
expr_stmt|;
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|pc
operator|->
name|pc_common_tss
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|bootAPgdt
argument_list|,
name|xpmap_ptom
argument_list|(
name|VTOP
argument_list|(
name|bootAPgdt
argument_list|)
argument_list|)
operator||
name|PG_V
operator||
name|PG_RW
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bootAPgdt
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NGDT
condition|;
name|x
operator|++
control|)
name|ssdtosd
argument_list|(
operator|&
name|gdt_segs
index|[
name|x
index|]
argument_list|,
operator|&
name|bootAPgdt
index|[
name|x
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|PT_SET_MA
argument_list|(
name|bootAPgdt
argument_list|,
name|vtomach
argument_list|(
name|bootAPgdt
argument_list|)
operator||
name|PG_V
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
if|if
condition|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_get_physid
argument_list|,
name|cpu
argument_list|,
operator|&
name|cpu_id
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apicid
operator|=
name|xen_vcpu_physid_to_x86_apicid
argument_list|(
name|cpu_id
operator|.
name|phys_id
argument_list|)
expr_stmt|;
name|acpiid
operator|=
name|xen_vcpu_physid_to_x86_acpiid
argument_list|(
name|cpu_id
operator|.
name|phys_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_ACPI
if|if
condition|(
name|acpiid
operator|!=
literal|0xff
condition|)
name|x86_acpiid_to_apicid
index|[
name|acpiid
index|]
operator|=
name|apicid
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* attempt to start the Application Processor */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AP #%d (PHY# %d) failed!\n"
argument_list|,
name|cpu
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
comment|/* better panic as the AP may be running loose */
name|printf
argument_list|(
literal|"panic y/n? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cngetc
argument_list|()
operator|!=
literal|'n'
condition|)
name|panic
argument_list|(
literal|"bye-bye"
argument_list|)
expr_stmt|;
block|}
name|all_cpus
operator||=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* build our map of 'other' CPUs */
name|PCPU_SET
argument_list|(
name|other_cpus
argument_list|,
name|all_cpus
operator|&
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
literal|0
argument_list|,
name|NKPT
operator|*
name|NBPDR
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_naps
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|uint8_t
modifier|*
name|pcpu_boot_stack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|trap_info_t
name|trap_table
index|[]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|smp_trap_init
parameter_list|(
name|trap_info_t
modifier|*
name|trap_ctxt
parameter_list|)
block|{
specifier|const
name|trap_info_t
modifier|*
name|t
init|=
name|trap_table
decl_stmt|;
for|for
control|(
name|t
operator|=
name|trap_table
init|;
name|t
operator|->
name|address
condition|;
name|t
operator|++
control|)
block|{
name|trap_ctxt
index|[
name|t
operator|->
name|vector
index|]
operator|.
name|flags
operator|=
name|t
operator|->
name|flags
expr_stmt|;
name|trap_ctxt
index|[
name|t
operator|->
name|vector
index|]
operator|.
name|cs
operator|=
name|t
operator|->
name|cs
expr_stmt|;
name|trap_ctxt
index|[
name|t
operator|->
name|vector
index|]
operator|.
name|address
operator|=
name|t
operator|->
name|address
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cpu_initialize_context
parameter_list|(
name|unsigned
name|int
name|cpu
parameter_list|)
block|{
comment|/* vcpu_guest_context_t is too large to allocate on the stack. 	 * Hence we allocate statically and protect it with a lock */
name|vm_page_t
name|m
index|[
literal|4
index|]
decl_stmt|;
specifier|static
name|vcpu_guest_context_t
name|ctxt
decl_stmt|;
name|vm_offset_t
name|boot_stack
decl_stmt|;
name|vm_offset_t
name|newPTD
decl_stmt|;
name|vm_paddr_t
name|ma
index|[
name|NPGPTD
index|]
decl_stmt|;
specifier|static
name|int
name|color
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Page 0,[0-3]	PTD 	 * Page 1, [4]	boot stack 	 * Page [5]	PDPT 	 * 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPGPTD
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|m
index|[
name|i
index|]
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|color
operator|++
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
name|pmap_zero_page
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|boot_stack
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|newPTD
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|NPGPTD
argument_list|)
expr_stmt|;
name|ma
index|[
literal|0
index|]
operator|=
name|xpmap_ptom
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator||
name|PG_V
expr_stmt|;
ifdef|#
directive|ifdef
name|PAE
name|pmap_kenter
argument_list|(
name|boot_stack
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|NPGPTD
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPGPTD
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|(
name|vm_paddr_t
operator|*
operator|)
name|boot_stack
operator|)
index|[
name|i
index|]
operator|=
name|ma
index|[
name|i
index|]
operator|=
name|xpmap_ptom
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
operator||
name|PG_V
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Copy cpu0 IdlePTD to new IdlePTD - copying only 	 * kernel mappings 	 */
name|pmap_qenter
argument_list|(
name|newPTD
argument_list|,
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|uint8_t
operator|*
operator|)
name|newPTD
operator|+
name|KPTDI
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|PTOV
argument_list|(
name|IdlePTD
argument_list|)
operator|+
name|KPTDI
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|,
name|nkpt
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_qremove
argument_list|(
name|newPTD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|newPTD
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* 	 * map actual idle stack to boot_stack 	 */
name|pmap_kenter
argument_list|(
name|boot_stack
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|NPGPTD
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|xen_pgdpt_pin
argument_list|(
name|xpmap_ptom
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|NPGPTD
operator|+
literal|1
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pdir
init|=
operator|(
name|PTDPTDI
operator|+
name|i
operator|)
operator|/
name|NPDEPG
decl_stmt|;
name|int
name|curoffset
init|=
operator|(
name|PTDPTDI
operator|+
name|i
operator|)
operator|%
name|NPDEPG
decl_stmt|;
name|xen_queue_pt_update
argument_list|(
call|(
name|vm_paddr_t
call|)
argument_list|(
operator|(
name|ma
index|[
name|pdir
index|]
operator|&
operator|~
name|PG_V
operator|)
operator|+
operator|(
name|curoffset
operator|*
sizeof|sizeof
argument_list|(
name|vm_paddr_t
argument_list|)
operator|)
argument_list|)
argument_list|,
name|ma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|PT_UPDATES_FLUSH
argument_list|()
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|flags
operator|=
name|VGCF_IN_KERNEL
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|ds
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|es
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|fs
operator|=
name|GSEL
argument_list|(
name|GPRIV_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|gs
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|cs
operator|=
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|init_secondary
expr_stmt|;
name|ctxt
operator|.
name|user_regs
operator|.
name|eflags
operator|=
name|PSL_KERNEL
operator||
literal|0x1000
expr_stmt|;
comment|/* IOPL_RING1 */
name|memset
argument_list|(
operator|&
name|ctxt
operator|.
name|fpu_ctxt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ctxt
operator|.
name|fpu_ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|smp_trap_init
argument_list|(
name|ctxt
operator|.
name|trap_ctxt
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|ldt_ents
operator|=
literal|0
expr_stmt|;
name|ctxt
operator|.
name|gdt_frames
index|[
literal|0
index|]
operator|=
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|)
name|vtomach
argument_list|(
name|bootAPgdt
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|gdt_ents
operator|=
literal|512
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|ctxt
operator|.
name|user_regs
operator|.
name|esp
operator|=
name|boot_stack
operator|+
name|PAGE_SIZE
expr_stmt|;
name|ctxt
operator|.
name|kernel_ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|kernel_sp
operator|=
name|boot_stack
operator|+
name|PAGE_SIZE
expr_stmt|;
name|ctxt
operator|.
name|event_callback_cs
operator|=
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|event_callback_eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|Xhypervisor_callback
expr_stmt|;
name|ctxt
operator|.
name|failsafe_callback_cs
operator|=
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|failsafe_callback_eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|failsafe_callback
expr_stmt|;
name|ctxt
operator|.
name|ctrlreg
index|[
literal|3
index|]
operator|=
name|xpmap_ptom
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|NPGPTD
operator|+
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* __x86_64__ */
name|ctxt
operator|.
name|user_regs
operator|.
name|esp
operator|=
name|idle
operator|->
name|thread
operator|.
name|rsp0
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|pt_regs
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|kernel_ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|kernel_sp
operator|=
name|idle
operator|->
name|thread
operator|.
name|rsp0
expr_stmt|;
name|ctxt
operator|.
name|event_callback_eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hypervisor_callback
expr_stmt|;
name|ctxt
operator|.
name|failsafe_callback_eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|failsafe_callback
expr_stmt|;
name|ctxt
operator|.
name|syscall_callback_eip
operator|=
operator|(
name|unsigned
name|long
operator|)
name|system_call
expr_stmt|;
name|ctxt
operator|.
name|ctrlreg
index|[
literal|3
index|]
operator|=
name|xen_pfn_to_cr3
argument_list|(
name|virt_to_mfn
argument_list|(
name|init_level4_pgt
argument_list|)
argument_list|)
expr_stmt|;
name|ctxt
operator|.
name|gs_base_kernel
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|cpu_pda
argument_list|(
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"gdtpfn=%lx pdptpfn=%lx\n"
argument_list|,
name|ctxt
operator|.
name|gdt_frames
index|[
literal|0
index|]
argument_list|,
name|ctxt
operator|.
name|ctrlreg
index|[
literal|3
index|]
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_initialise
argument_list|,
name|cpu
argument_list|,
operator|&
name|ctxt
argument_list|)
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|3000
argument_list|)
expr_stmt|;
name|PANIC_IF
argument_list|(
name|HYPERVISOR_vcpu_op
argument_list|(
name|VCPUOP_up
argument_list|,
name|cpu
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It isn't pretty,  * but it seems to work.  */
end_comment

begin_decl_stmt
name|int
name|cpus
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|apic_id
parameter_list|)
block|{
name|int
name|ms
decl_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_naps
expr_stmt|;
name|cpu_initialize_context
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
comment|/* Wait up to 5 seconds for it to start. */
for|for
control|(
name|ms
operator|=
literal|0
init|;
name|ms
operator|<
literal|5000
condition|;
name|ms
operator|++
control|)
block|{
if|if
condition|(
name|mp_naps
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
end_function

begin_comment
comment|/*  * Flush the TLB on all other CPU's  */
end_comment

begin_function
specifier|static
name|void
name|smp_tlb_shootdown
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
name|u_int
name|ncpu
decl_stmt|;
name|struct
name|_call_data
name|data
decl_stmt|;
name|ncpu
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
comment|/* does not shootdown self */
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
comment|/* no other cpus */
if|if
condition|(
operator|!
operator|(
name|read_eflags
argument_list|()
operator|&
name|PSL_I
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: interrupts disabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|call_data
operator|==
name|NULL
argument_list|,
operator|(
literal|"call_data isn't null?!"
operator|)
argument_list|)
expr_stmt|;
name|call_data
operator|=
operator|&
name|data
expr_stmt|;
name|call_data
operator|->
name|func_id
operator|=
name|vector
expr_stmt|;
name|call_data
operator|->
name|arg1
operator|=
name|addr1
expr_stmt|;
name|call_data
operator|->
name|arg2
operator|=
name|addr2
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ipi_all_but_self
argument_list|(
name|vector
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_tlb_wait
operator|<
name|ncpu
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|call_data
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smp_targeted_tlb_shootdown
parameter_list|(
name|cpumask_t
name|mask
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
name|int
name|ncpu
decl_stmt|,
name|othercpus
decl_stmt|;
name|struct
name|_call_data
name|data
decl_stmt|;
name|othercpus
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|mask
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
block|{
name|ncpu
operator|=
name|othercpus
expr_stmt|;
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
block|}
else|else
block|{
name|mask
operator|&=
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return;
name|ncpu
operator|=
name|bitcount32
argument_list|(
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncpu
operator|>
name|othercpus
condition|)
block|{
comment|/* XXX this should be a panic offence */
name|printf
argument_list|(
literal|"SMP: tlb shootdown to %d other cpus (only have %d)\n"
argument_list|,
name|ncpu
argument_list|,
name|othercpus
argument_list|)
expr_stmt|;
name|ncpu
operator|=
name|othercpus
expr_stmt|;
block|}
comment|/* XXX should be a panic, implied by mask == 0 above */
if|if
condition|(
name|ncpu
operator|<
literal|1
condition|)
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|read_eflags
argument_list|()
operator|&
name|PSL_I
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: interrupts disabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|call_data
operator|==
name|NULL
argument_list|,
operator|(
literal|"call_data isn't null?!"
operator|)
argument_list|)
expr_stmt|;
name|call_data
operator|=
operator|&
name|data
expr_stmt|;
name|call_data
operator|->
name|func_id
operator|=
name|vector
expr_stmt|;
name|call_data
operator|->
name|arg1
operator|=
name|addr1
expr_stmt|;
name|call_data
operator|->
name|arg2
operator|=
name|addr2
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_tlb_wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
operator|(
name|u_int
operator|)
operator|-
literal|1
condition|)
name|ipi_all_but_self
argument_list|(
name|vector
argument_list|)
expr_stmt|;
else|else
name|ipi_selected
argument_list|(
name|mask
argument_list|,
name|vector
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_tlb_wait
operator|<
name|ncpu
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|call_data
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_cache_flush
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLCACHE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_invltlb
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLTLB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_invlpg
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLPG
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_invlpg_range
parameter_list|(
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_tlb_shootdown
argument_list|(
name|IPI_INVLRNG
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invltlb
parameter_list|(
name|cpumask_t
name|mask
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLTLB
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg
parameter_list|(
name|cpumask_t
name|mask
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLPG
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg_range
parameter_list|(
name|cpumask_t
name|mask
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLRNG
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * send an IPI to a set of cpus.  */
end_comment

begin_function
name|void
name|ipi_selected
parameter_list|(
name|cpumask_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|u_int
name|bitmap
init|=
literal|0
decl_stmt|;
name|u_int
name|old_pending
decl_stmt|;
name|u_int
name|new_pending
decl_stmt|;
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
condition|)
block|{
name|bitmap
operator|=
literal|1
operator|<<
name|ipi
expr_stmt|;
name|ipi
operator|=
name|IPI_BITMAP_VECTOR
expr_stmt|;
block|}
comment|/* 	 * IPI_STOP_HARD maps to a NMI and the trap handler needs a bit 	 * of help in order to understand what is the source. 	 * Set the mask of receiving CPUs for this purpose. 	 */
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP_HARD
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|ipi_nmi_pending
argument_list|,
name|cpus
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpus: %x ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cpu
operator|=
name|ffs
argument_list|(
name|cpus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|cpus
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu_apic_ids
index|[
name|cpu
index|]
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"IPI to non-existent CPU %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap
condition|)
block|{
do|do
block|{
name|old_pending
operator|=
name|cpu_ipi_pending
index|[
name|cpu
index|]
expr_stmt|;
name|new_pending
operator|=
name|old_pending
operator||
name|bitmap
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|,
name|old_pending
argument_list|,
name|new_pending
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|old_pending
condition|)
name|ipi_pcpu
argument_list|(
name|cpu
argument_list|,
name|RESCHEDULE_VECTOR
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|call_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"call_data not set"
operator|)
argument_list|)
expr_stmt|;
name|ipi_pcpu
argument_list|(
name|cpu
argument_list|,
name|CALL_FUNCTION_VECTOR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * send an IPI to all CPUs EXCEPT myself  */
end_comment

begin_function
name|void
name|ipi_all_but_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
comment|/* 	 * IPI_STOP_HARD maps to a NMI and the trap handler needs a bit 	 * of help in order to understand what is the source. 	 * Set the mask of receiving CPUs for this purpose. 	 */
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP_HARD
condition|)
name|atomic_set_int
argument_list|(
operator|&
name|ipi_nmi_pending
argument_list|,
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|ipi_selected
argument_list|(
name|PCPU_GET
argument_list|(
name|other_cpus
argument_list|)
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ipi_nmi_handler
parameter_list|()
block|{
name|cpumask_t
name|cpumask
decl_stmt|;
comment|/* 	 * As long as there is not a simple way to know about a NMI's 	 * source, if the bitmask for the current CPU is present in 	 * the global pending bitword an IPI_STOP_HARD has been issued 	 * and should be handled. 	 */
name|cpumask
operator|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ipi_nmi_pending
operator|&
name|cpumask
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|atomic_clear_int
argument_list|(
operator|&
name|ipi_nmi_pending
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
name|cpustop_handler
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an IPI_STOP by saving our current context and spinning until we  * are resumed.  */
end_comment

begin_function
name|void
name|cpustop_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|int
name|cpumask
init|=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
decl_stmt|;
name|savectx
argument_list|(
operator|&
name|stoppcbs
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
comment|/* Indicate that we are stopped */
name|atomic_set_int
argument_list|(
operator|&
name|stopped_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
comment|/* Wait for restart */
while|while
condition|(
operator|!
operator|(
name|started_cpus
operator|&
name|cpumask
operator|)
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|started_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
name|atomic_clear_int
argument_list|(
operator|&
name|stopped_cpus
argument_list|,
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
literal|0
operator|&&
name|cpustop_restartfunc
operator|!=
name|NULL
condition|)
block|{
name|cpustop_restartfunc
argument_list|()
expr_stmt|;
name|cpustop_restartfunc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called once the rest of the system is up and running and we're  * ready to let the AP's out of the pen.  */
end_comment

begin_function
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
return|return;
name|atomic_store_rel_int
argument_list|(
operator|&
name|aps_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|start_aps
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|release_aps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|start_ipis
argument_list|,
name|SI_SUB_INTR
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|xen_smp_intr_init_cpus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

