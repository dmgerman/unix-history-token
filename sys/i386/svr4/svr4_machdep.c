begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Mark Newton  * Copyright (c) 1994 Christos Zoulas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/sysarch.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_types.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_signal.h>
end_include

begin_include
include|#
directive|include
file|<i386/svr4/svr4_machdep.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_ucontext.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_util.h>
end_include

begin_undef
undef|#
directive|undef
name|sigcode
end_undef

begin_undef
undef|#
directive|undef
name|szsigcode
end_undef

begin_decl_stmt
specifier|extern
name|int
name|svr4_szsigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|svr4_sigcode
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_udatasel
decl_stmt|,
name|_ucodesel
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|svr4_getsiginfo
parameter_list|(
name|union
name|svr4_siginfo
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_comment
comment|/* taken from /sys/arch/i386/include/psl.h on NetBSD-1.3 */
end_comment

begin_define
define|#
directive|define
name|PSL_MBZ
value|0xffc08028
end_define

begin_define
define|#
directive|define
name|PSL_USERSTATIC
value|(PSL_USER | PSL_MBZ | PSL_IOPL | PSL_NT | PSL_VM | PSL_VIF | PSL_VIP)
end_define

begin_define
define|#
directive|define
name|USERMODE
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
value|(ISPL(c) == SEL_UPL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|void
name|svr4_setregs
parameter_list|(
name|td
parameter_list|,
name|epp
parameter_list|,
name|stack
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|exec_package
modifier|*
name|epp
decl_stmt|;
name|u_long
name|stack
decl_stmt|;
block|{
specifier|register
name|struct
name|pcb
modifier|*
name|pcb
init|=
name|td
operator|->
name|td_pcb
decl_stmt|;
name|pcb
operator|->
name|pcb_savefpu
operator|.
name|sv_env
operator|.
name|en_cw
operator|=
name|__SVR4_NPXCW__
expr_stmt|;
name|setregs
argument_list|(
name|td
argument_list|,
name|epp
argument_list|,
name|stack
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_function
name|void
name|svr4_getcontext
parameter_list|(
name|td
parameter_list|,
name|uc
parameter_list|,
name|mask
parameter_list|,
name|oonstack
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_ucontext
modifier|*
name|uc
decl_stmt|;
name|sigset_t
modifier|*
name|mask
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
name|svr4_greg_t
modifier|*
name|r
init|=
name|uc
operator|->
name|uc_mcontext
operator|.
name|greg
decl_stmt|;
name|struct
name|svr4_sigaltstack
modifier|*
name|s
init|=
operator|&
name|uc
operator|->
name|uc_stack
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONE_MORE_SIGALTSTACK_WORK
argument_list|)
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|sf
decl_stmt|;
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONE_MORE_SIGALTSTACK_WORK
argument_list|)
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|sf
operator|=
operator|&
name|p
operator|->
name|p_sigstk
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
name|uc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|svr4_ucontext
argument_list|)
argument_list|)
expr_stmt|;
name|uc
operator|->
name|uc_link
operator|=
name|p
operator|->
name|p_emuldata
expr_stmt|;
comment|/* 	 * Set the general purpose registers 	 */
ifdef|#
directive|ifdef
name|VM86
if|if
condition|(
name|tf
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|r
index|[
name|SVR4_X86_GS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_gs
expr_stmt|;
name|r
index|[
name|SVR4_X86_FS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_fs
expr_stmt|;
name|r
index|[
name|SVR4_X86_ES
index|]
operator|=
name|tf
operator|->
name|tf_vm86_es
expr_stmt|;
name|r
index|[
name|SVR4_X86_DS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_ds
expr_stmt|;
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|=
name|get_vflags
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
asm|__asm("movl %%gs,%w0" : "=r" (r[SVR4_X86_GS]));
asm|__asm("movl %%fs,%w0" : "=r" (r[SVR4_X86_FS]));
else|#
directive|else
name|r
index|[
name|SVR4_X86_GS
index|]
operator|=
name|rgs
argument_list|()
expr_stmt|;
name|r
index|[
name|SVR4_X86_FS
index|]
operator|=
name|tf
operator|->
name|tf_fs
expr_stmt|;
endif|#
directive|endif
name|r
index|[
name|SVR4_X86_ES
index|]
operator|=
name|tf
operator|->
name|tf_es
expr_stmt|;
name|r
index|[
name|SVR4_X86_DS
index|]
operator|=
name|tf
operator|->
name|tf_ds
expr_stmt|;
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|=
name|tf
operator|->
name|tf_eflags
expr_stmt|;
block|}
name|r
index|[
name|SVR4_X86_EDI
index|]
operator|=
name|tf
operator|->
name|tf_edi
expr_stmt|;
name|r
index|[
name|SVR4_X86_ESI
index|]
operator|=
name|tf
operator|->
name|tf_esi
expr_stmt|;
name|r
index|[
name|SVR4_X86_EBP
index|]
operator|=
name|tf
operator|->
name|tf_ebp
expr_stmt|;
name|r
index|[
name|SVR4_X86_ESP
index|]
operator|=
name|tf
operator|->
name|tf_esp
expr_stmt|;
name|r
index|[
name|SVR4_X86_EBX
index|]
operator|=
name|tf
operator|->
name|tf_ebx
expr_stmt|;
name|r
index|[
name|SVR4_X86_EDX
index|]
operator|=
name|tf
operator|->
name|tf_edx
expr_stmt|;
name|r
index|[
name|SVR4_X86_ECX
index|]
operator|=
name|tf
operator|->
name|tf_ecx
expr_stmt|;
name|r
index|[
name|SVR4_X86_EAX
index|]
operator|=
name|tf
operator|->
name|tf_eax
expr_stmt|;
name|r
index|[
name|SVR4_X86_TRAPNO
index|]
operator|=
name|tf
operator|->
name|tf_trapno
expr_stmt|;
name|r
index|[
name|SVR4_X86_ERR
index|]
operator|=
name|tf
operator|->
name|tf_err
expr_stmt|;
name|r
index|[
name|SVR4_X86_EIP
index|]
operator|=
name|tf
operator|->
name|tf_eip
expr_stmt|;
name|r
index|[
name|SVR4_X86_CS
index|]
operator|=
name|tf
operator|->
name|tf_cs
expr_stmt|;
name|r
index|[
name|SVR4_X86_UESP
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|SVR4_X86_SS
index|]
operator|=
name|tf
operator|->
name|tf_ss
expr_stmt|;
comment|/* 	 * Set the signal stack 	 */
if|#
directive|if
name|defined
argument_list|(
name|DONE_MORE_SIGALTSTACK_WORK
argument_list|)
name|bsd_to_svr4_sigaltstack
argument_list|(
name|sf
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|->
name|ss_sp
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_long
operator|)
name|tf
operator|->
name|tf_esp
operator|)
operator|&
operator|~
operator|(
literal|16384
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|s
operator|->
name|ss_size
operator|=
literal|16384
expr_stmt|;
name|s
operator|->
name|ss_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Set the signal mask 	 */
name|bsd_to_svr4_sigset
argument_list|(
name|mask
argument_list|,
operator|&
name|uc
operator|->
name|uc_sigmask
argument_list|)
expr_stmt|;
comment|/* 	 * Set the flags 	 */
name|uc
operator|->
name|uc_flags
operator|=
name|SVR4_UC_SIGMASK
operator||
name|SVR4_UC_CPU
operator||
name|SVR4_UC_STACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set to ucontext specified. Reset signal mask and  * stack state from context.  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|svr4_setcontext
parameter_list|(
name|td
parameter_list|,
name|uc
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_ucontext
modifier|*
name|uc
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|DONE_MORE_SIGALTSTACK_WORK
argument_list|)
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
endif|#
directive|endif
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|svr4_greg_t
modifier|*
name|r
init|=
name|uc
operator|->
name|uc_mcontext
operator|.
name|greg
decl_stmt|;
name|struct
name|svr4_sigaltstack
modifier|*
name|s
init|=
operator|&
name|uc
operator|->
name|uc_stack
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|sf
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DONE_MORE_SIGALTSTACK_WORK
argument_list|)
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
endif|#
directive|endif
name|sf
operator|=
operator|&
name|p
operator|->
name|p_sigstk
expr_stmt|;
comment|/* 	 * XXX: 	 * Should we check the value of flags to determine what to restore? 	 * What to do with uc_link? 	 * What to do with floating point stuff? 	 * Should we bother with the rest of the registers that we 	 * set to 0 right now? 	 */
if|if
condition|(
operator|(
name|uc
operator|->
name|uc_flags
operator|&
name|SVR4_UC_CPU
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|DPRINTF
argument_list|(
operator|(
literal|"svr4_setcontext(%d)\n"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|tf
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
comment|/* 	 * Restore register context. 	 */
ifdef|#
directive|ifdef
name|VM86
warning|#
directive|warning
literal|"VM86 doesn't work yet, please don't try to use it."
if|if
condition|(
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|&
name|PSL_VM
condition|)
block|{
name|tf
operator|->
name|tf_vm86_gs
operator|=
name|r
index|[
name|SVR4_X86_GS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_fs
operator|=
name|r
index|[
name|SVR4_X86_FS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_es
operator|=
name|r
index|[
name|SVR4_X86_ES
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_ds
operator|=
name|r
index|[
name|SVR4_X86_DS
index|]
expr_stmt|;
name|set_vflags
argument_list|(
name|td
argument_list|,
name|r
index|[
name|SVR4_X86_EFL
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * Check for security violations.  If we're returning to 		 * protected mode, the CPU will validate the segment registers 		 * automatically and generate a trap on violations.  We handle 		 * the trap, rather than doing all of the checking here. 		 */
if|if
condition|(
operator|(
operator|(
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|^
name|tf
operator|->
name|tf_eflags
operator|)
operator|&
name|PSL_USERSTATIC
operator|)
operator|!=
literal|0
operator|||
operator|!
name|USERMODE
argument_list|(
name|r
index|[
name|SVR4_X86_CS
index|]
argument_list|,
name|r
index|[
name|SVR4_X86_EFL
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* %fs and %gs were restored by the trampoline. */
else|#
directive|else
comment|/* %gs was restored by the trampoline. */
name|tf
operator|->
name|tf_fs
operator|=
name|r
index|[
name|SVR4_X86_FS
index|]
expr_stmt|;
endif|#
directive|endif
name|tf
operator|->
name|tf_es
operator|=
name|r
index|[
name|SVR4_X86_ES
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|r
index|[
name|SVR4_X86_DS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eflags
operator|=
name|r
index|[
name|SVR4_X86_EFL
index|]
expr_stmt|;
block|}
name|tf
operator|->
name|tf_edi
operator|=
name|r
index|[
name|SVR4_X86_EDI
index|]
expr_stmt|;
name|tf
operator|->
name|tf_esi
operator|=
name|r
index|[
name|SVR4_X86_ESI
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ebp
operator|=
name|r
index|[
name|SVR4_X86_EBP
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ebx
operator|=
name|r
index|[
name|SVR4_X86_EBX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_edx
operator|=
name|r
index|[
name|SVR4_X86_EDX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ecx
operator|=
name|r
index|[
name|SVR4_X86_ECX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eax
operator|=
name|r
index|[
name|SVR4_X86_EAX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_trapno
operator|=
name|r
index|[
name|SVR4_X86_TRAPNO
index|]
expr_stmt|;
name|tf
operator|->
name|tf_err
operator|=
name|r
index|[
name|SVR4_X86_ERR
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
name|r
index|[
name|SVR4_X86_EIP
index|]
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|r
index|[
name|SVR4_X86_CS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|r
index|[
name|SVR4_X86_SS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_esp
operator|=
name|r
index|[
name|SVR4_X86_ESP
index|]
expr_stmt|;
name|p
operator|->
name|p_emuldata
operator|=
name|uc
operator|->
name|uc_link
expr_stmt|;
comment|/* 	 * restore signal stack 	 */
if|if
condition|(
name|uc
operator|->
name|uc_flags
operator|&
name|SVR4_UC_STACK
condition|)
block|{
name|svr4_to_bsd_sigaltstack
argument_list|(
name|s
argument_list|,
name|sf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * restore signal mask 	 */
if|if
condition|(
name|uc
operator|->
name|uc_flags
operator|&
name|SVR4_UC_SIGMASK
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|DPRINTF
argument_list|(
operator|(
literal|"\tuc_sigmask[%d] = %lx\n"
operator|,
name|i
operator|,
name|uc
operator|->
name|uc_sigmask
operator|.
name|bits
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|svr4_to_bsd_sigset
argument_list|(
operator|&
name|uc
operator|->
name|uc_sigmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|SIG_CANTMASK
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|=
name|mask
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/*EJUSTRETURN;*/
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_getsiginfo
parameter_list|(
name|si
parameter_list|,
name|sig
parameter_list|,
name|code
parameter_list|,
name|addr
parameter_list|)
name|union
name|svr4_siginfo
modifier|*
name|si
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|u_long
name|code
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
name|si
operator|->
name|si_signo
operator|=
name|bsd_to_svr4_sig
index|[
name|sig
index|]
expr_stmt|;
name|si
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|si_addr
operator|=
name|addr
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_ILL_PRVOPC
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PRIVINFLT
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_TRAP_BRKPT
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_BPTFLT
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_INTOVF
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_PROTFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_ACCERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PROTFLT
expr_stmt|;
break|break;
case|case
name|T_TRCTRAP
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_TRAP_TRACE
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_TRCTRAP
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_ACCERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PAGEFLT
expr_stmt|;
break|break;
case|case
name|T_ALIGNFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_BUS_ADRALN
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_ALIGNFLT
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTDIV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_OFLOW
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTOVF
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTSUB
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_BOUND
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTINV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DNA
expr_stmt|;
break|break;
case|case
name|T_FPOPFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTINV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_FPOPFLT
expr_stmt|;
break|break;
case|case
name|T_SEGNPFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_MAPERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_SEGNPFLT
expr_stmt|;
break|break;
case|case
name|T_STKFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_ILL_BADSTK
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_STKFLT
expr_stmt|;
break|break;
default|default:
name|si
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
name|printf
argument_list|(
literal|"sig %d code %ld\n"
argument_list|,
name|sig
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*		panic("svr4_getsiginfo");*/
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine. After the handler is  * done svr4 will call setcontext for us  * with the user context we just set up, and we  * will return to the user pc, psl.  */
end_comment

begin_function
name|void
name|svr4_sendsig
parameter_list|(
name|catcher
parameter_list|,
name|sig
parameter_list|,
name|mask
parameter_list|,
name|code
parameter_list|)
name|sig_t
name|catcher
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|sigset_t
modifier|*
name|mask
decl_stmt|;
name|u_long
name|code
decl_stmt|;
block|{
specifier|register
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|struct
name|svr4_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
name|printf
argument_list|(
literal|"svr4_sendsig(%d)\n"
argument_list|,
name|sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|psp
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|tf
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|oonstack
operator|=
name|sigonstack
argument_list|(
name|tf
operator|->
name|tf_esp
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
name|SIGISMEMBER
argument_list|(
name|psp
operator|->
name|ps_sigonstack
argument_list|,
name|sig
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|svr4_sigframe
operator|*
operator|)
operator|(
name|p
operator|->
name|p_sigstk
operator|.
name|ss_sp
operator|+
name|p
operator|->
name|p_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|svr4_sigframe
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|p_sigstk
operator|.
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
operator|(
expr|struct
name|svr4_sigframe
operator|*
operator|)
name|tf
operator|->
name|tf_esp
operator|-
literal|1
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/*  	 * Build the argument list for the signal handler. 	 * Notes: 	 * 	- we always build the whole argument list, even when we 	 *	  don't need to [when SA_SIGINFO is not set, we don't need 	 *	  to pass all sf_si and sf_uc] 	 *	- we don't pass the correct signal address [we need to 	 *	  modify many kernel files to enable that] 	 */
name|svr4_getcontext
argument_list|(
name|td
argument_list|,
operator|&
name|frame
operator|.
name|sf_uc
argument_list|,
name|mask
argument_list|,
name|oonstack
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
name|printf
argument_list|(
literal|"obtained ucontext\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|svr4_getsiginfo
argument_list|(
operator|&
name|frame
operator|.
name|sf_si
argument_list|,
name|sig
argument_list|,
name|code
argument_list|,
operator|(
name|caddr_t
operator|)
name|tf
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
name|printf
argument_list|(
literal|"obtained siginfo\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|frame
operator|.
name|sf_signum
operator|=
name|frame
operator|.
name|sf_si
operator|.
name|si_signo
expr_stmt|;
name|frame
operator|.
name|sf_sip
operator|=
operator|&
name|fp
operator|->
name|sf_si
expr_stmt|;
name|frame
operator|.
name|sf_ucp
operator|=
operator|&
name|fp
operator|->
name|sf_uc
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|catcher
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_SVR4
argument_list|)
name|printf
argument_list|(
literal|"sig = %d, sip %p, ucp = %p, handler = %p\n"
argument_list|,
name|frame
operator|.
name|sf_signum
argument_list|,
name|frame
operator|.
name|sf_sip
argument_list|,
name|frame
operator|.
name|sf_ucp
argument_list|,
name|frame
operator|.
name|sf_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigexit
argument_list|(
name|td
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * Build context to run handler in. 	 */
name|tf
operator|->
name|tf_es
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|PS_STRINGS
operator|)
operator|-
name|svr4_szsigcode
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_eflags
operator|&=
operator|~
operator|(
name|PSL_T
operator||
name|PSL_VM
operator||
name|PSL_AC
operator|)
expr_stmt|;
name|tf
operator|->
name|tf_esp
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
else|#
directive|else
name|tf
operator|->
name|tf_esp
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|PS_STRINGS
operator|)
operator|-
operator|*
operator|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|_ucodesel
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|tf
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|tf
operator|->
name|tf_fs
operator|=
name|_udatasel
expr_stmt|;
name|load_gs
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|svr4_sys_sysarch
parameter_list|(
name|td
parameter_list|,
name|v
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_sysarch_args
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|svr4_sys_sysarch_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
if|#
directive|if
literal|0
comment|/* USER_LDT */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
block|caddr_t sg = stackgap_init(p->p_emul);
else|#
directive|else
block|caddr_t sg = stackgap_init();
endif|#
directive|endif
block|int error;
endif|#
directive|endif
switch|switch
condition|(
name|uap
operator|->
name|op
condition|)
block|{
case|case
name|SVR4_SYSARCH_FPHW
case|:
return|return
literal|0
return|;
case|case
name|SVR4_SYSARCH_DSCR
case|:
if|#
directive|if
literal|0
comment|/* USER_LDT */
warning|#
directive|warning
literal|"USER_LDT doesn't work - are you sure you want this?"
block|{ 			struct i386_set_ldt_args sa, *sap; 			struct sys_sysarch_args ua;  			struct svr4_ssd ssd; 			union descriptor bsd;  			if ((error = copyin(SCARG(uap, a1),&ssd, 					    sizeof(ssd))) != 0) { 				printf("Cannot copy arg1\n"); 				return error; 			}  			printf("s=%x, b=%x, l=%x, a1=%x a2=%x\n", 			       ssd.selector, ssd.base, ssd.limit, 			       ssd.access1, ssd.access2);
comment|/* We can only set ldt's for now. */
block|if (!ISLDT(ssd.selector)) { 				printf("Not an ldt\n"); 				return EPERM; 			}
comment|/* Oh, well we don't cleanup either */
block|if (ssd.access1 == 0) 				return 0;  			bsd.sd.sd_lobase = ssd.base& 0xffffff; 			bsd.sd.sd_hibase = (ssd.base>> 24)& 0xff;  			bsd.sd.sd_lolimit = ssd.limit& 0xffff; 			bsd.sd.sd_hilimit = (ssd.limit>> 16)& 0xf;  			bsd.sd.sd_type = ssd.access1& 0x1f; 			bsd.sd.sd_dpl =  (ssd.access1>> 5)& 0x3; 			bsd.sd.sd_p = (ssd.access1>> 7)& 0x1;  			bsd.sd.sd_xx = ssd.access2& 0x3; 			bsd.sd.sd_def32 = (ssd.access2>> 2)& 0x1; 			bsd.sd.sd_gran = (ssd.access2>> 3)& 0x1;  			sa.start = IDXSEL(ssd.selector); 			sa.desc = stackgap_alloc(&sg, sizeof(union descriptor)); 			sa.num = 1; 			sap = stackgap_alloc(&sg, 					     sizeof(struct i386_set_ldt_args));  			if ((error = copyout(&sa, sap, sizeof(sa))) != 0) { 				printf("Cannot copyout args\n"); 				return error; 			}  			SCARG(&ua, op) = I386_SET_LDT; 			SCARG(&ua, parms) = (char *) sap;  			if ((error = copyout(&bsd, sa.desc, sizeof(bsd))) != 0) { 				printf("Cannot copyout desc\n"); 				return error; 			}  			return sys_sysarch(td,&ua, retval); 		}
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"svr4_sysarch(%d), a1 %p\n"
argument_list|,
name|uap
operator|->
name|op
argument_list|,
name|uap
operator|->
name|a1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

