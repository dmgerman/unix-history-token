begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Mark Newton  * Copyright (c) 1994 Christos Zoulas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf32.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/sysarch.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_types.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_signal.h>
end_include

begin_include
include|#
directive|include
file|<i386/svr4/svr4_machdep.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_ucontext.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_proto.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_util.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_exec.h>
end_include

begin_undef
undef|#
directive|undef
name|sigcode
end_undef

begin_undef
undef|#
directive|undef
name|szsigcode
end_undef

begin_decl_stmt
specifier|extern
name|int
name|svr4_szsigcode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|svr4_sigcode
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_udatasel
decl_stmt|,
name|_ucodesel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|svr4_getsiginfo
name|__P
argument_list|(
operator|(
expr|union
name|svr4_siginfo
operator|*
operator|,
name|int
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|bsd_to_svr4_sig
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_comment
comment|/* taken from /sys/arch/i386/include/psl.h on NetBSD-1.3 */
end_comment

begin_define
define|#
directive|define
name|PSL_MBZ
value|0xffc08028
end_define

begin_define
define|#
directive|define
name|PSL_USERSTATIC
value|(PSL_USER | PSL_MBZ | PSL_IOPL | PSL_NT | PSL_VM | PSL_VIF | PSL_VIP)
end_define

begin_define
define|#
directive|define
name|USERMODE
parameter_list|(
name|c
parameter_list|,
name|f
parameter_list|)
value|(ISPL(c) == SEL_UPL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|void
name|svr4_setregs
parameter_list|(
name|p
parameter_list|,
name|epp
parameter_list|,
name|stack
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|exec_package
modifier|*
name|epp
decl_stmt|;
name|u_long
name|stack
decl_stmt|;
block|{
specifier|register
name|struct
name|pcb
modifier|*
name|pcb
init|=
operator|&
name|p
operator|->
name|p_addr
operator|->
name|u_pcb
decl_stmt|;
name|pcb
operator|->
name|pcb_savefpu
operator|.
name|sv_env
operator|.
name|en_cw
operator|=
name|__SVR4_NPXCW__
expr_stmt|;
name|setregs
argument_list|(
name|p
argument_list|,
name|epp
argument_list|,
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_function
name|void
name|svr4_getcontext
parameter_list|(
name|p
parameter_list|,
name|uc
parameter_list|,
name|mask
parameter_list|,
name|oonstack
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_ucontext
modifier|*
name|uc
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|oonstack
decl_stmt|;
block|{
name|struct
name|trapframe
modifier|*
name|tf
init|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
init|=
name|p
operator|->
name|p_sigacts
decl_stmt|;
name|svr4_greg_t
modifier|*
name|r
init|=
name|uc
operator|->
name|uc_mcontext
operator|.
name|greg
decl_stmt|;
name|struct
name|svr4_sigaltstack
modifier|*
name|s
init|=
operator|&
name|uc
operator|->
name|uc_stack
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|sf
init|=
operator|&
name|psp
operator|->
name|ps_sigstk
decl_stmt|;
name|memset
argument_list|(
name|uc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|svr4_ucontext
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the general purpose registers 	 */
ifdef|#
directive|ifdef
name|VM86
if|if
condition|(
name|tf
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|r
index|[
name|SVR4_X86_GS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_gs
expr_stmt|;
name|r
index|[
name|SVR4_X86_FS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_fs
expr_stmt|;
name|r
index|[
name|SVR4_X86_ES
index|]
operator|=
name|tf
operator|->
name|tf_vm86_es
expr_stmt|;
name|r
index|[
name|SVR4_X86_DS
index|]
operator|=
name|tf
operator|->
name|tf_vm86_ds
expr_stmt|;
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|=
name|get_vflags
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
asm|__asm("movl %%gs,%w0" : "=r" (r[SVR4_X86_GS]));
asm|__asm("movl %%fs,%w0" : "=r" (r[SVR4_X86_FS]));
name|r
index|[
name|SVR4_X86_ES
index|]
operator|=
name|tf
operator|->
name|tf_es
expr_stmt|;
name|r
index|[
name|SVR4_X86_DS
index|]
operator|=
name|tf
operator|->
name|tf_ds
expr_stmt|;
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|=
name|tf
operator|->
name|tf_eflags
expr_stmt|;
block|}
name|r
index|[
name|SVR4_X86_EDI
index|]
operator|=
name|tf
operator|->
name|tf_edi
expr_stmt|;
name|r
index|[
name|SVR4_X86_ESI
index|]
operator|=
name|tf
operator|->
name|tf_esi
expr_stmt|;
name|r
index|[
name|SVR4_X86_EBP
index|]
operator|=
name|tf
operator|->
name|tf_ebp
expr_stmt|;
name|r
index|[
name|SVR4_X86_ESP
index|]
operator|=
name|tf
operator|->
name|tf_esp
expr_stmt|;
name|r
index|[
name|SVR4_X86_EBX
index|]
operator|=
name|tf
operator|->
name|tf_ebx
expr_stmt|;
name|r
index|[
name|SVR4_X86_EDX
index|]
operator|=
name|tf
operator|->
name|tf_edx
expr_stmt|;
name|r
index|[
name|SVR4_X86_ECX
index|]
operator|=
name|tf
operator|->
name|tf_ecx
expr_stmt|;
name|r
index|[
name|SVR4_X86_EAX
index|]
operator|=
name|tf
operator|->
name|tf_eax
expr_stmt|;
name|r
index|[
name|SVR4_X86_TRAPNO
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|SVR4_X86_ERR
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|SVR4_X86_EIP
index|]
operator|=
name|tf
operator|->
name|tf_eip
expr_stmt|;
name|r
index|[
name|SVR4_X86_CS
index|]
operator|=
name|tf
operator|->
name|tf_cs
expr_stmt|;
name|r
index|[
name|SVR4_X86_UESP
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|SVR4_X86_SS
index|]
operator|=
name|tf
operator|->
name|tf_ss
expr_stmt|;
comment|/* 	 * Set the signal stack 	 */
name|bsd_to_svr4_sigaltstack
argument_list|(
name|sf
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Set the signal mask 	 */
name|bsd_to_svr4_sigset
argument_list|(
operator|&
name|mask
argument_list|,
operator|&
name|uc
operator|->
name|uc_sigmask
argument_list|)
expr_stmt|;
comment|/* 	 * Set the flags 	 */
name|uc
operator|->
name|uc_flags
operator|=
name|SVR4_UC_ALL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set to ucontext specified.  * has been taken.  Reset signal mask and  * stack state from context.  * Return to previous pc and psl as specified by  * context left by sendsig. Check carefully to  * make sure that the user has not modified the  * psl to gain improper privileges or to cause  * a machine fault.  */
end_comment

begin_function
name|int
name|svr4_setcontext
parameter_list|(
name|p
parameter_list|,
name|uc
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_ucontext
modifier|*
name|uc
decl_stmt|;
block|{
name|struct
name|sigacts
modifier|*
name|psp
init|=
name|p
operator|->
name|p_sigacts
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|svr4_greg_t
modifier|*
name|r
init|=
name|uc
operator|->
name|uc_mcontext
operator|.
name|greg
decl_stmt|;
name|struct
name|svr4_sigaltstack
modifier|*
name|s
init|=
operator|&
name|uc
operator|->
name|uc_stack
decl_stmt|;
name|struct
name|sigaltstack
modifier|*
name|sf
init|=
operator|&
name|psp
operator|->
name|ps_sigstk
decl_stmt|;
name|int
name|mask
decl_stmt|;
comment|/* 	 * XXX: 	 * Should we check the value of flags to determine what to restore? 	 * What to do with uc_link? 	 * What to do with floating point stuff? 	 * Should we bother with the rest of the registers that we 	 * set to 0 right now? 	 */
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
comment|/* 	 * Restore register context. 	 */
ifdef|#
directive|ifdef
name|VM86
if|if
condition|(
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|&
name|PSL_VM
condition|)
block|{
name|tf
operator|->
name|tf_vm86_gs
operator|=
name|r
index|[
name|SVR4_X86_GS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_fs
operator|=
name|r
index|[
name|SVR4_X86_FS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_es
operator|=
name|r
index|[
name|SVR4_X86_ES
index|]
expr_stmt|;
name|tf
operator|->
name|tf_vm86_ds
operator|=
name|r
index|[
name|SVR4_X86_DS
index|]
expr_stmt|;
name|set_vflags
argument_list|(
name|p
argument_list|,
name|r
index|[
name|SVR4_X86_EFL
index|]
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* 		 * Check for security violations.  If we're returning to 		 * protected mode, the CPU will validate the segment registers 		 * automatically and generate a trap on violations.  We handle 		 * the trap, rather than doing all of the checking here. 		 */
if|if
condition|(
operator|(
operator|(
name|r
index|[
name|SVR4_X86_EFL
index|]
operator|^
name|tf
operator|->
name|tf_eflags
operator|)
operator|&
name|PSL_USERSTATIC
operator|)
operator|!=
literal|0
operator|||
operator|!
name|USERMODE
argument_list|(
name|r
index|[
name|SVR4_X86_CS
index|]
argument_list|,
name|r
index|[
name|SVR4_X86_EFL
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* %fs and %gs were restored by the trampoline. */
name|tf
operator|->
name|tf_es
operator|=
name|r
index|[
name|SVR4_X86_ES
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|r
index|[
name|SVR4_X86_DS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eflags
operator|=
name|r
index|[
name|SVR4_X86_EFL
index|]
expr_stmt|;
block|}
name|tf
operator|->
name|tf_edi
operator|=
name|r
index|[
name|SVR4_X86_EDI
index|]
expr_stmt|;
name|tf
operator|->
name|tf_esi
operator|=
name|r
index|[
name|SVR4_X86_ESI
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ebp
operator|=
name|r
index|[
name|SVR4_X86_EBP
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ebx
operator|=
name|r
index|[
name|SVR4_X86_EBX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_edx
operator|=
name|r
index|[
name|SVR4_X86_EDX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ecx
operator|=
name|r
index|[
name|SVR4_X86_ECX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eax
operator|=
name|r
index|[
name|SVR4_X86_EAX
index|]
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
name|r
index|[
name|SVR4_X86_EIP
index|]
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|r
index|[
name|SVR4_X86_CS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|r
index|[
name|SVR4_X86_SS
index|]
expr_stmt|;
name|tf
operator|->
name|tf_esp
operator|=
name|r
index|[
name|SVR4_X86_ESP
index|]
expr_stmt|;
comment|/* 	 * restore signal stack 	 */
name|svr4_to_bsd_sigaltstack
argument_list|(
name|s
argument_list|,
name|sf
argument_list|)
expr_stmt|;
comment|/* 	 * restore signal mask 	 */
name|svr4_to_bsd_sigset
argument_list|(
operator|&
name|uc
operator|->
name|uc_sigmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigmask
operator|=
name|mask
operator|&
operator|~
name|sigcantmask
expr_stmt|;
return|return
literal|0
return|;
comment|/*EJUSTRETURN;*/
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_getsiginfo
parameter_list|(
name|si
parameter_list|,
name|sig
parameter_list|,
name|code
parameter_list|,
name|addr
parameter_list|)
name|union
name|svr4_siginfo
modifier|*
name|si
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|u_long
name|code
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
block|{
name|si
operator|->
name|si_signo
operator|=
name|bsd_to_svr4_sig
index|[
name|sig
index|]
expr_stmt|;
name|si
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|si_addr
operator|=
name|addr
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_ILL_PRVOPC
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PRIVINFLT
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_TRAP_BRKPT
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_BPTFLT
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_INTOVF
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_PROTFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_ACCERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PROTFLT
expr_stmt|;
break|break;
case|case
name|T_TRCTRAP
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_TRAP_TRACE
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_TRCTRAP
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_ACCERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_PAGEFLT
expr_stmt|;
break|break;
case|case
name|T_ALIGNFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_BUS_ADRALN
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_ALIGNFLT
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTDIV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_OFLOW
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTOVF
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DIVIDE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTSUB
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_BOUND
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTINV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_DNA
expr_stmt|;
break|break;
case|case
name|T_FPOPFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_FPE_FLTINV
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_FPOPFLT
expr_stmt|;
break|break;
case|case
name|T_SEGNPFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_SEGV_MAPERR
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_SEGNPFLT
expr_stmt|;
break|break;
case|case
name|T_STKFLT
case|:
name|si
operator|->
name|si_code
operator|=
name|SVR4_ILL_BADSTK
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
name|SVR4_T_STKFLT
expr_stmt|;
break|break;
default|default:
name|si
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|si_trap
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"sig %d code %ld\n"
argument_list|,
name|sig
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"svr4_getsiginfo"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Send an interrupt to process.  *  * Stack is set up to allow sigcode stored  * in u. to call routine. After the handler is  * done svr4 will call setcontext for us  * with the user context we just set up, and we  * will return to the user pc, psl.  */
end_comment

begin_function
name|void
name|svr4_sendsig
parameter_list|(
name|catcher
parameter_list|,
name|sig
parameter_list|,
name|mask
parameter_list|,
name|code
parameter_list|)
name|sig_t
name|catcher
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|mask
decl_stmt|;
name|u_long
name|code
decl_stmt|;
block|{
specifier|register
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
specifier|register
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|struct
name|svr4_sigframe
modifier|*
name|fp
decl_stmt|,
name|frame
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|psp
init|=
name|p
operator|->
name|p_sigacts
decl_stmt|;
name|int
name|oonstack
decl_stmt|;
name|tf
operator|=
name|p
operator|->
name|p_md
operator|.
name|md_regs
expr_stmt|;
name|oonstack
operator|=
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator|&
name|SS_ONSTACK
expr_stmt|;
comment|/* 	 * Allocate space for the signal handler context. 	 */
if|if
condition|(
operator|(
name|psp
operator|->
name|ps_flags
operator|&
name|SAS_ALTSTACK
operator|)
operator|&&
operator|!
name|oonstack
operator|&&
operator|(
name|psp
operator|->
name|ps_sigonstack
operator|&
name|sigmask
argument_list|(
name|sig
argument_list|)
operator|)
condition|)
block|{
name|fp
operator|=
operator|(
expr|struct
name|svr4_sigframe
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_sp
operator|+
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|svr4_sigframe
argument_list|)
operator|)
expr_stmt|;
name|psp
operator|->
name|ps_sigstk
operator|.
name|ss_flags
operator||=
name|SS_ONSTACK
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|=
operator|(
expr|struct
name|svr4_sigframe
operator|*
operator|)
name|tf
operator|->
name|tf_esp
operator|-
literal|1
expr_stmt|;
block|}
comment|/*  	 * Build the argument list for the signal handler. 	 * Notes: 	 * 	- we always build the whole argument list, even when we 	 *	  don't need to [when SA_SIGINFO is not set, we don't need 	 *	  to pass all sf_si and sf_uc] 	 *	- we don't pass the correct signal address [we need to 	 *	  modify many kernel files to enable that] 	 */
name|svr4_getcontext
argument_list|(
name|p
argument_list|,
operator|&
name|frame
operator|.
name|sf_uc
argument_list|,
name|mask
argument_list|,
name|oonstack
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"obtained ucontext\n"
operator|)
argument_list|)
expr_stmt|;
name|svr4_getsiginfo
argument_list|(
operator|&
name|frame
operator|.
name|sf_si
argument_list|,
name|sig
argument_list|,
name|code
argument_list|,
operator|(
name|caddr_t
operator|)
name|tf
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"obtained siginfo\n"
operator|)
argument_list|)
expr_stmt|;
name|frame
operator|.
name|sf_signum
operator|=
name|frame
operator|.
name|sf_si
operator|.
name|si_signo
expr_stmt|;
name|frame
operator|.
name|sf_sip
operator|=
operator|&
name|fp
operator|->
name|sf_si
expr_stmt|;
name|frame
operator|.
name|sf_ucp
operator|=
operator|&
name|fp
operator|->
name|sf_uc
expr_stmt|;
name|frame
operator|.
name|sf_handler
operator|=
name|catcher
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SVR4
name|printf
argument_list|(
literal|"sig = %d, sip %p, ucp = %p, handler = %p\n"
argument_list|,
name|frame
operator|.
name|sf_signum
argument_list|,
name|frame
operator|.
name|sf_sip
argument_list|,
name|frame
operator|.
name|sf_ucp
argument_list|,
name|frame
operator|.
name|sf_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|frame
argument_list|,
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|frame
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Process has trashed its stack; give it an illegal 		 * instruction to halt it in its tracks. 		 */
name|sigexit
argument_list|(
name|p
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * Build context to run handler in. 	 */
name|tf
operator|->
name|tf_es
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|PS_STRINGS
operator|)
operator|-
name|svr4_szsigcode
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_eflags
operator|&=
operator|~
operator|(
name|PSL_T
operator||
name|PSL_VM
operator||
name|PSL_AC
operator|)
expr_stmt|;
name|tf
operator|->
name|tf_esp
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|GSEL
argument_list|(
name|GUSERLDT_SEL
argument_list|,
name|SEL_UPL
argument_list|)
expr_stmt|;
else|#
directive|else
name|tf
operator|->
name|tf_esp
operator|=
operator|(
name|int
operator|)
name|fp
expr_stmt|;
name|tf
operator|->
name|tf_eip
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|PS_STRINGS
operator|)
operator|-
operator|*
operator|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_szsigcode
operator|)
argument_list|)
expr_stmt|;
name|tf
operator|->
name|tf_cs
operator|=
name|_ucodesel
expr_stmt|;
name|tf
operator|->
name|tf_ds
operator|=
name|_udatasel
expr_stmt|;
name|tf
operator|->
name|tf_es
operator|=
name|_udatasel
expr_stmt|;
name|tf
operator|->
name|tf_ss
operator|=
name|_udatasel
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|svr4_sys_sysarch
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_sysarch_args
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|svr4_sys_sysarch_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
ifdef|#
directive|ifdef
name|USER_LDT
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|(
name|p
operator|->
name|p_emul
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|uap
operator|->
name|op
condition|)
block|{
case|case
name|SVR4_SYSARCH_FPHW
case|:
return|return
literal|0
return|;
case|case
name|SVR4_SYSARCH_DSCR
case|:
ifdef|#
directive|ifdef
name|USER_LDT
block|{
name|struct
name|i386_set_ldt_args
name|sa
decl_stmt|,
modifier|*
name|sap
decl_stmt|;
name|struct
name|sys_sysarch_args
name|ua
decl_stmt|;
name|struct
name|svr4_ssd
name|ssd
decl_stmt|;
name|union
name|descriptor
name|bsd
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|a1
argument_list|)
argument_list|,
operator|&
name|ssd
argument_list|,
sizeof|sizeof
argument_list|(
name|ssd
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot copy arg1\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|printf
argument_list|(
literal|"s=%x, b=%x, l=%x, a1=%x a2=%x\n"
argument_list|,
name|ssd
operator|.
name|selector
argument_list|,
name|ssd
operator|.
name|base
argument_list|,
name|ssd
operator|.
name|limit
argument_list|,
name|ssd
operator|.
name|access1
argument_list|,
name|ssd
operator|.
name|access2
argument_list|)
expr_stmt|;
comment|/* We can only set ldt's for now. */
if|if
condition|(
operator|!
name|ISLDT
argument_list|(
name|ssd
operator|.
name|selector
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Not an ldt\n"
argument_list|)
expr_stmt|;
return|return
name|EPERM
return|;
block|}
comment|/* Oh, well we don't cleanup either */
if|if
condition|(
name|ssd
operator|.
name|access1
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|bsd
operator|.
name|sd
operator|.
name|sd_lobase
operator|=
name|ssd
operator|.
name|base
operator|&
literal|0xffffff
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_hibase
operator|=
operator|(
name|ssd
operator|.
name|base
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_lolimit
operator|=
name|ssd
operator|.
name|limit
operator|&
literal|0xffff
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_hilimit
operator|=
operator|(
name|ssd
operator|.
name|limit
operator|>>
literal|16
operator|)
operator|&
literal|0xf
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_type
operator|=
name|ssd
operator|.
name|access1
operator|&
literal|0x1f
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_dpl
operator|=
operator|(
name|ssd
operator|.
name|access1
operator|>>
literal|5
operator|)
operator|&
literal|0x3
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_p
operator|=
operator|(
name|ssd
operator|.
name|access1
operator|>>
literal|7
operator|)
operator|&
literal|0x1
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_xx
operator|=
name|ssd
operator|.
name|access2
operator|&
literal|0x3
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_def32
operator|=
operator|(
name|ssd
operator|.
name|access2
operator|>>
literal|2
operator|)
operator|&
literal|0x1
expr_stmt|;
name|bsd
operator|.
name|sd
operator|.
name|sd_gran
operator|=
operator|(
name|ssd
operator|.
name|access2
operator|>>
literal|3
operator|)
operator|&
literal|0x1
expr_stmt|;
name|sa
operator|.
name|start
operator|=
name|IDXSEL
argument_list|(
name|ssd
operator|.
name|selector
argument_list|)
expr_stmt|;
name|sa
operator|.
name|desc
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|descriptor
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|num
operator|=
literal|1
expr_stmt|;
name|sap
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|i386_set_ldt_args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sa
argument_list|,
name|sap
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot copyout args\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|SCARG
argument_list|(
operator|&
name|ua
argument_list|,
name|op
argument_list|)
operator|=
name|I386_SET_LDT
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ua
argument_list|,
name|parms
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|sap
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bsd
argument_list|,
name|sa
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|bsd
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot copyout desc\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
name|sys_sysarch
argument_list|(
name|p
argument_list|,
operator|&
name|ua
argument_list|,
name|retval
argument_list|)
return|;
block|}
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"svr4_sysarch(%d), a1 %p\n"
argument_list|,
name|uap
operator|->
name|op
argument_list|,
name|uap
operator|->
name|a1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

