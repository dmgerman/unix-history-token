begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Sean Eric Fagan  * Copyright (c) 1994 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/coff.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_util.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sysentvec
name|ibcs2_svr3_sysvec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|coff_load_file
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exec_coff_imgact
name|__P
argument_list|(
operator|(
expr|struct
name|image_params
operator|*
name|imgp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|load_coff_section
name|__P
argument_list|(
operator|(
expr|struct
name|vmspace
operator|*
name|vmspace
operator|,
expr|struct
name|vnode
operator|*
name|vp
operator|,
name|vm_offset_t
name|offset
operator|,
name|caddr_t
name|vmaddr
operator|,
name|size_t
name|memsz
operator|,
name|size_t
name|filsz
operator|,
name|vm_prot_t
name|prot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|load_coff_section
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|caddr_t
name|vmaddr
parameter_list|,
name|size_t
name|memsz
parameter_list|,
name|size_t
name|filsz
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|size_t
name|map_len
decl_stmt|;
name|vm_offset_t
name|map_offset
decl_stmt|;
name|vm_offset_t
name|map_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data_buf
init|=
literal|0
decl_stmt|;
name|size_t
name|copy_len
decl_stmt|;
name|map_offset
operator|=
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|map_addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memsz
operator|>
name|filsz
condition|)
block|{
comment|/* 		 * We have the stupid situation that 		 * the section is longer than it is on file, 		 * which means it has zero-filled areas, and 		 * we have to work for it.  Stupid iBCS! 		 */
name|map_len
operator|=
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|map_offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The only stuff we care about is on disk, and we 		 * don't care if we map in more than is really there. 		 */
name|map_len
operator|=
name|round_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|map_offset
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d):  vm_mmap(&vmspace->vm_map,&0x%08lx, 0x%x, 0x%x, "
literal|"VM_PROT_ALL, MAP_PRIVATE | MAP_FIXED, vp, 0x%x)\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|map_addr
operator|,
name|map_len
operator|,
name|prot
operator|,
name|map_offset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|map_addr
argument_list|,
name|map_len
argument_list|,
name|prot
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|map_offset
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|memsz
operator|==
name|filsz
condition|)
block|{
comment|/* We're done! */
return|return
literal|0
return|;
block|}
comment|/* 	 * Now we have screwball stuff, to accomodate stupid COFF. 	 * We have to map the remaining bit of the file into the kernel's 	 * memory map, allocate some anonymous memory, copy that last 	 * bit into it, and then we're done. *sigh* 	 * For clean-up reasons, we actally map in the file last. 	 */
name|copy_len
operator|=
operator|(
name|offset
operator|+
name|filsz
operator|)
operator|-
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_len
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|memsz
argument_list|)
operator|-
name|map_addr
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): vm_map_find(&vmspace->vm_map, NULL, 0,&0x%08lx,0x%x, FALSE, VM_PROT_ALL, VM_PROT_ALL, 0)\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|map_addr
operator|,
name|map_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|map_addr
argument_list|,
name|map_len
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|data_buf
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyout
argument_list|(
name|data_buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|map_addr
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|data_buf
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|data_buf
operator|+
name|PAGE_SIZE
argument_list|)
condition|)
name|panic
argument_list|(
literal|"load_coff_section vm_map_remove failed"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|coff_load_file
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|filehdr
modifier|*
name|fhdr
decl_stmt|;
name|struct
name|aouthdr
modifier|*
name|ahdr
decl_stmt|;
name|struct
name|scnhdr
modifier|*
name|scns
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
name|int
name|nscns
decl_stmt|;
name|unsigned
name|long
name|text_offset
init|=
literal|0
decl_stmt|,
name|text_address
init|=
literal|0
decl_stmt|,
name|text_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|data_offset
init|=
literal|0
decl_stmt|,
name|data_address
init|=
literal|0
decl_stmt|,
name|data_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|bss_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX use of 'curproc' should be 'p'?*/
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|LOCKLEAF
operator||
name|FOLLOW
operator||
name|SAVENAME
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|name
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
name|ENOEXEC
return|;
if|if
condition|(
name|vp
operator|->
name|v_writecount
condition|)
block|{
name|error
operator|=
name|ETXTBSY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|attr
operator|.
name|va_size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Lose the lock on the vnode. It's no longer needed, and must not 	 * exist for the pagefault paging to work below. 	 */
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|ptr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|fhdr
operator|=
operator|(
expr|struct
name|filehdr
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|fhdr
operator|->
name|f_magic
operator|!=
name|I386_COFF
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|dealloc_and_fail
goto|;
block|}
name|nscns
operator|=
name|fhdr
operator|->
name|f_nscns
expr_stmt|;
if|if
condition|(
operator|(
name|nscns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scnhdr
argument_list|)
operator|)
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/*      		 * XXX -- just fail.  I'm so lazy.      		 */
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|dealloc_and_fail
goto|;
block|}
name|ahdr
operator|=
operator|(
expr|struct
name|aouthdr
operator|*
operator|)
operator|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
operator|)
expr_stmt|;
name|scns
operator|=
operator|(
expr|struct
name|scnhdr
operator|*
operator|)
operator|(
name|ptr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aouthdr
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_NOLOAD
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_TEXT
condition|)
block|{
name|text_address
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_vaddr
expr_stmt|;
name|text_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
name|text_offset
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_DATA
condition|)
block|{
name|data_address
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_vaddr
expr_stmt|;
name|data_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
name|data_offset
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_BSS
condition|)
block|{
name|bss_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|load_coff_section
argument_list|(
name|vmspace
argument_list|,
name|vp
argument_list|,
name|text_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|text_address
argument_list|,
name|text_size
argument_list|,
name|text_size
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|dealloc_and_fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|load_coff_section
argument_list|(
name|vmspace
argument_list|,
name|vp
argument_list|,
name|data_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|data_address
argument_list|,
name|data_size
operator|+
name|bss_size
argument_list|,
name|data_size
argument_list|,
name|VM_PROT_ALL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|dealloc_and_fail
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|dealloc_and_fail
label|:
if|if
condition|(
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptr
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ptr
operator|+
name|PAGE_SIZE
argument_list|)
condition|)
name|panic
argument_list|(
name|__FUNCTION__
literal|" vm_map_remove failed"
argument_list|)
expr_stmt|;
name|fail
label|:
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|exec_coff_imgact
parameter_list|(
name|imgp
parameter_list|)
name|struct
name|image_params
modifier|*
name|imgp
decl_stmt|;
block|{
specifier|const
name|struct
name|filehdr
modifier|*
name|fhdr
init|=
operator|(
specifier|const
expr|struct
name|filehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
specifier|const
name|struct
name|aouthdr
modifier|*
name|ahdr
decl_stmt|;
specifier|const
name|struct
name|scnhdr
modifier|*
name|scns
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
decl_stmt|;
name|int
name|nscns
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|long
name|text_offset
init|=
literal|0
decl_stmt|,
name|text_address
init|=
literal|0
decl_stmt|,
name|text_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|data_offset
init|=
literal|0
decl_stmt|,
name|data_address
init|=
literal|0
decl_stmt|,
name|data_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|bss_size
init|=
literal|0
decl_stmt|;
name|caddr_t
name|hole
decl_stmt|;
if|if
condition|(
name|fhdr
operator|->
name|f_magic
operator|!=
name|I386_COFF
operator|||
operator|!
operator|(
name|fhdr
operator|->
name|f_flags
operator|&
name|F_EXEC
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): return -1\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|nscns
operator|=
name|fhdr
operator|->
name|f_nscns
expr_stmt|;
if|if
condition|(
operator|(
name|nscns
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|scnhdr
argument_list|)
operator|)
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* 	   	 * For now, return an error -- need to be able to 	   	 * read in all of the section structures. 	   	 */
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): return -1\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ahdr
operator|=
operator|(
specifier|const
expr|struct
name|aouthdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
operator|)
expr_stmt|;
name|imgp
operator|->
name|entry_addr
operator|=
name|ahdr
operator|->
name|entry
expr_stmt|;
name|scns
operator|=
operator|(
specifier|const
expr|struct
name|scnhdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|filehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|aouthdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|exec_extract_strings
argument_list|(
name|imgp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d):  return %d\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|exec_new_vmspace
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
name|vmspace
operator|=
name|imgp
operator|->
name|proc
operator|->
name|p_vmspace
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscns
condition|;
name|i
operator|++
control|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"i = %d, scns[i].s_name = %s, scns[i].s_vaddr = %08lx, "
literal|"scns[i].s_scnptr = %d\n"
operator|,
name|i
operator|,
name|scns
index|[
name|i
index|]
operator|.
name|s_name
operator|,
name|scns
index|[
name|i
index|]
operator|.
name|s_vaddr
operator|,
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_NOLOAD
condition|)
block|{
comment|/* 	     	 * A section that is not loaded, for whatever 	     	 * reason.  It takes precedance over other flag 	     	 * bits... 	     	 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_TEXT
condition|)
block|{
name|text_address
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_vaddr
expr_stmt|;
name|text_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
name|text_offset
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_DATA
condition|)
block|{
comment|/* .data section */
name|data_address
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_vaddr
expr_stmt|;
name|data_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
name|data_offset
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_BSS
condition|)
block|{
comment|/* .bss section */
name|bss_size
operator|=
name|scns
index|[
name|i
index|]
operator|.
name|s_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_flags
operator|&
name|STYP_LIB
condition|)
block|{
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|int
name|foff
init|=
name|trunc_page
argument_list|(
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
argument_list|)
decl_stmt|;
name|int
name|off
init|=
name|scns
index|[
name|i
index|]
operator|.
name|s_scnptr
operator|-
name|foff
decl_stmt|;
name|int
name|len
init|=
name|round_page
argument_list|(
name|scns
index|[
name|i
index|]
operator|.
name|s_size
operator|+
name|PAGE_SIZE
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|len
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|imgp
operator|->
name|vp
argument_list|,
name|foff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
name|ENOEXEC
return|;
block|}
if|if
condition|(
name|scns
index|[
name|i
index|]
operator|.
name|s_size
condition|)
block|{
name|char
modifier|*
name|libbuf
decl_stmt|;
name|int
name|emul_path_len
init|=
name|strlen
argument_list|(
name|ibcs2_emul_path
argument_list|)
decl_stmt|;
name|libbuf
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
operator|+
name|emul_path_len
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|libbuf
argument_list|,
name|ibcs2_emul_path
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|off
init|;
name|j
operator|<
name|scns
index|[
name|i
index|]
operator|.
name|s_size
operator|+
name|off
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|libname
decl_stmt|;
name|libname
operator|=
name|buf
operator|+
name|j
operator|+
literal|4
operator|*
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|buf
operator|+
name|j
operator|+
literal|4
operator|)
expr_stmt|;
name|j
operator|+=
literal|4
operator|*
operator|*
operator|(
name|long
operator|*
operator|)
operator|(
name|buf
operator|+
name|j
operator|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d):  shared library %s\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|libname
operator|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|libbuf
index|[
name|emul_path_len
index|]
argument_list|,
name|libname
argument_list|)
expr_stmt|;
name|error
operator|=
name|coff_load_file
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|libbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|coff_load_file
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|libname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|free
argument_list|(
name|libbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|buf
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|buf
operator|+
name|len
argument_list|)
condition|)
name|panic
argument_list|(
literal|"exec_coff_imgact vm_map_remove failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Map in .text now 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d):  load_coff_section(vmspace, "
literal|"imgp->vp, %08lx, %08lx, 0x%x, 0x%x, 0x%x)\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|text_offset
operator|,
name|text_address
operator|,
name|text_size
operator|,
name|text_size
operator|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|load_coff_section
argument_list|(
name|vmspace
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|text_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|text_address
argument_list|,
name|text_size
argument_list|,
name|text_size
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): error = %d\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Map in .data and .bss now 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): load_coff_section(vmspace, "
literal|"imgp->vp, 0x%08lx, 0x%08lx, 0x%x, 0x%x, 0x%x)\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|data_offset
operator|,
name|data_address
operator|,
name|data_size
operator|+
name|bss_size
operator|,
name|data_size
operator|,
name|VM_PROT_ALL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|load_coff_section
argument_list|(
name|vmspace
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|data_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|data_address
argument_list|,
name|data_size
operator|+
name|bss_size
argument_list|,
name|data_size
argument_list|,
name|VM_PROT_ALL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): error = %d\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|imgp
operator|->
name|interpreted
operator|=
literal|0
expr_stmt|;
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|=
operator|&
name|ibcs2_svr3_sysvec
expr_stmt|;
name|vmspace
operator|->
name|vm_tsize
operator|=
name|round_page
argument_list|(
name|text_size
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_dsize
operator|=
name|round_page
argument_list|(
name|data_size
operator|+
name|bss_size
argument_list|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_taddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|text_address
expr_stmt|;
name|vmspace
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|data_address
expr_stmt|;
name|hole
operator|=
operator|(
name|caddr_t
operator|)
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmspace
operator|->
name|vm_daddr
argument_list|)
operator|+
name|ctob
argument_list|(
name|vmspace
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d): vm_map_find(&vmspace->vm_map, NULL, 0,&0x%08lx, PAGE_SIZE, FALSE, VM_PROT_ALL, VM_PROT_ALL, 0)\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|,
name|hole
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"imgact: error = %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|hole
argument_list|,
name|PAGE_SIZE
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"IBCS2: start vm_dsize = 0x%x, vm_daddr = 0x%x end = 0x%x\n"
operator|,
name|ctob
argument_list|(
name|vmspace
operator|->
name|vm_dsize
argument_list|)
operator|,
name|vmspace
operator|->
name|vm_daddr
operator|,
name|ctob
argument_list|(
name|vmspace
operator|->
name|vm_dsize
argument_list|)
operator|+
name|vmspace
operator|->
name|vm_daddr
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%s(%d):  returning successfully!\n"
operator|,
name|__FILE__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* Indicate that this file should not be modified */
name|imgp
operator|->
name|vp
operator|->
name|v_flag
operator||=
name|VTEXT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Tell kern_execve.c about it, with a little help from the linker.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|execsw
name|coff_execsw
init|=
block|{
name|exec_coff_imgact
block|,
literal|"coff"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EXEC_SET
argument_list|(
name|coff
argument_list|,
name|coff_execsw
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

