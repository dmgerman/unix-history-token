begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 SÃ¸ren Schmidt  * Copyright (c) 1994 Sean Eric Fagan  * All rights reserved.  *  * Copyright (c) 1982, 1986, 1989, 1991 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_decl_stmt
name|int
name|ibcs2_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ibcs2_traceemu_args
block|{
name|int
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_traceemu
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_traceemu_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
operator|*
name|retval
operator|=
name|ibcs2_trace
expr_stmt|;
name|ibcs2_trace
operator|=
name|args
operator|->
name|options
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_access
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'access'\n"
argument_list|)
expr_stmt|;
return|return
name|access
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_alarm_args
block|{
name|unsigned
name|int
name|secs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_alarm
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_alarm_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
specifier|extern
name|struct
name|timeval
name|time
decl_stmt|;
name|struct
name|itimerval
name|it
decl_stmt|,
name|oit
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'alarm' secs=%d\n"
argument_list|,
name|args
operator|->
name|secs
argument_list|)
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|args
operator|->
name|secs
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|oit
operator|=
name|p
operator|->
name|p_realtimer
expr_stmt|;
if|if
condition|(
name|timerisset
argument_list|(
operator|&
name|oit
operator|.
name|it_value
argument_list|)
condition|)
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|oit
operator|.
name|it_value
argument_list|,
operator|&
name|time
argument_list|,
operator|<
argument_list|)
condition|)
name|timerclear
argument_list|(
operator|&
name|oit
operator|.
name|it_value
argument_list|)
expr_stmt|;
else|else
name|timevalsub
argument_list|(
operator|&
name|oit
operator|.
name|it_value
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|)
operator|||
name|itimerfix
argument_list|(
operator|&
name|it
operator|.
name|it_interval
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
name|untimeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|timerisset
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|)
condition|)
block|{
name|timevaladd
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|realitexpire
argument_list|,
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|hzto
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_realtimer
operator|=
name|it
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|oit
operator|.
name|it_value
operator|.
name|tv_usec
condition|)
name|oit
operator|.
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
operator|*
name|retval
operator|=
name|oit
operator|.
name|it_value
operator|.
name|tv_sec
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_break_args
block|{
name|char
modifier|*
name|dsend
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_break
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_break_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|;
name|int
name|rv
decl_stmt|,
name|diff
decl_stmt|;
specifier|extern
name|int
name|swap_pager_full
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'break' dsend=%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|args
operator|->
name|dsend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vm_offset_t
operator|)
name|args
operator|->
name|dsend
operator|<
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|dsend
operator|-
operator|(
name|caddr_t
operator|)
name|vm
operator|->
name|vm_daddr
operator|)
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
return|return
name|ENOMEM
return|;
name|old
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
argument_list|)
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|new
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|args
operator|->
name|dsend
argument_list|)
expr_stmt|;
name|diff
operator|=
name|new
operator|-
name|old
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|swap_pager_full
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|rv
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|old
argument_list|,
name|diff
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
name|vm
operator|->
name|vm_dsize
operator|+=
name|btoc
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
name|rv
operator|=
name|vm_map_remove
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|new
argument_list|,
name|new
operator|+
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
name|ENOMEM
return|;
name|vm
operator|->
name|vm_dsize
operator|-=
name|btoc
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chdir
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'chdir'\n"
argument_list|)
expr_stmt|;
return|return
name|chdir
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chmod
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'chmod'\n"
argument_list|)
expr_stmt|;
return|return
name|chmod
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chown
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'chown'\n"
argument_list|)
expr_stmt|;
return|return
name|chown
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chroot
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'chroot'\n"
argument_list|)
expr_stmt|;
return|return
name|chroot
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|exec_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_exec
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|exec_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|execve_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
name|execve_args
struct|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'exec' name=%s\n"
argument_list|,
name|args
operator|->
name|name
argument_list|)
expr_stmt|;
name|execve_args
operator|.
name|name
operator|=
name|args
operator|->
name|name
expr_stmt|;
name|execve_args
operator|.
name|argv
operator|=
name|args
operator|->
name|argv
expr_stmt|;
name|execve_args
operator|.
name|envp
operator|=
literal|0
expr_stmt|;
return|return
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|execve_args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_exece_args
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_exece
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_exece_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'exece' name=%s\n"
argument_list|,
name|args
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
name|execve
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_exit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'exit'\n"
argument_list|)
expr_stmt|;
return|return
name|exit
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_fork
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'fork'\n"
argument_list|)
expr_stmt|;
return|return
name|fork
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_fsync
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'fsync'\n"
argument_list|)
expr_stmt|;
return|return
name|fsync
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_getgid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'getgid'\n"
argument_list|)
expr_stmt|;
return|return
name|getgid
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_getgroups_args
block|{
name|int
name|gidsetsize
decl_stmt|;
name|ibcs2_gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_getgroups
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_getgroups_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|getgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
name|tmp
struct|;
name|ibcs2_gid_t
modifier|*
name|ibcs2_gidset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'getgroups'\n"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|gidsetsize
operator|=
name|args
operator|->
name|gidsetsize
expr_stmt|;
name|tmp
operator|.
name|gidset
operator|=
operator|(
name|gid_t
operator|*
operator|)
name|UA_ALLOC
argument_list|()
expr_stmt|;
name|ibcs2_gidset
operator|=
operator|(
name|ibcs2_gid_t
operator|*
operator|)
operator|&
name|tmp
operator|.
name|gidset
index|[
name|NGROUPS_MAX
index|]
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|getgroups
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retval
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
name|ibcs2_gidset
index|[
name|i
index|]
operator|=
operator|(
name|ibcs2_gid_t
operator|)
name|tmp
operator|.
name|gidset
index|[
name|i
index|]
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|ibcs2_gidset
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|gidset
argument_list|,
sizeof|sizeof
argument_list|(
name|ibcs2_gid_t
argument_list|)
operator|*
name|retval
index|[
literal|0
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_getpid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'getpid'\n"
argument_list|)
expr_stmt|;
return|return
name|getpid
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_getuid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'getuid'\n"
argument_list|)
expr_stmt|;
return|return
name|getuid
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|gtime_args
block|{
name|long
modifier|*
name|timeptr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_gtime
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|gtime_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'gtime'\n"
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|args
condition|)
operator|(
name|long
operator|)
name|args
operator|->
name|timeptr
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_link
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'link'\n"
argument_list|)
expr_stmt|;
return|return
name|link
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_mkdir
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'mkdir'\n"
argument_list|)
expr_stmt|;
return|return
name|mkdir
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_mknod_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|fmode
decl_stmt|;
name|ibcs2_dev_t
name|dev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_mknod
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_mknod_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'mknod'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|args
operator|->
name|fmode
argument_list|)
condition|)
return|return
name|mkfifo
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
return|return
name|mknod
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_nice_args
block|{
name|int
name|niceval
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_nice
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_nice_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'nice'\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|donice
argument_list|(
name|p
argument_list|,
name|p
argument_list|,
name|args
operator|->
name|niceval
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_nice
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_pathconf_args
block|{
name|long
name|unused
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_pathconf
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_pathconf_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: '(f)pathconf'\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
literal|0
case|:
comment|/* _PC_LINK_MAX */
operator|*
name|retval
operator|=
operator|(
name|LINK_MAX
operator|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* _PC_MAX_CANON */
operator|*
name|retval
operator|=
operator|(
name|MAX_CANON
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* _PC_MAX_INPUT */
operator|*
name|retval
operator|=
operator|(
name|MAX_INPUT
operator|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* _PC_PATH_MAX */
operator|*
name|retval
operator|=
operator|(
name|PATH_MAX
operator|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* _PC_VDISABLE */
operator|*
name|retval
operator|=
operator|(
name|_POSIX_VDISABLE
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* _PC_NAME_MAX */
operator|*
name|retval
operator|=
operator|(
name|NAME_MAX
operator|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* _PC_PATH_MAX */
operator|*
name|retval
operator|=
operator|(
name|PATH_MAX
operator|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* _PC_CHOWN_RESTRICTED */
ifdef|#
directive|ifdef
name|_POSIX_CHOWN_RESTRICTED
operator|*
name|retval
operator|=
operator|(
literal|1
operator|)
expr_stmt|;
else|#
directive|else
operator|*
name|retval
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|7
case|:
comment|/* _PC_NO_TRUNC */
ifdef|#
directive|ifdef
name|_POSIX_NO_TRUNC
operator|*
name|retval
operator|=
operator|(
literal|1
operator|)
expr_stmt|;
else|#
directive|else
operator|*
name|retval
operator|=
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
operator|*
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_pause
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|mask
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'pause'\n"
argument_list|)
expr_stmt|;
return|return
name|sigsuspend
argument_list|(
name|p
argument_list|,
operator|&
name|mask
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_pipe
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'pipe'\n"
argument_list|)
expr_stmt|;
return|return
name|pipe
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_poll
block|{
name|int
name|fd
decl_stmt|;
name|short
name|events
decl_stmt|;
name|short
name|revents
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ibcs2_poll_args
block|{
name|struct
name|ibcs2_poll
modifier|*
name|fds
decl_stmt|;
name|unsigned
name|long
name|nfds
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_poll
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_poll_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|ibcs2_poll
name|conv
decl_stmt|;
name|fd_set
modifier|*
name|readfds
decl_stmt|,
modifier|*
name|writefds
decl_stmt|,
modifier|*
name|exceptfds
decl_stmt|;
name|struct
name|timeval
modifier|*
name|timeout
decl_stmt|;
struct|struct
name|select_args
block|{
name|u_int
name|nd
decl_stmt|;
name|fd_set
modifier|*
name|in
decl_stmt|,
modifier|*
name|ou
decl_stmt|,
modifier|*
name|ex
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|}
name|tmp_select
struct|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'poll'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|nfds
operator|>
name|FD_SETSIZE
condition|)
return|return
name|EINVAL
return|;
name|readfds
operator|=
operator|(
name|fd_set
operator|*
operator|)
name|UA_ALLOC
argument_list|()
expr_stmt|;
name|FD_ZERO
argument_list|(
name|readfds
argument_list|)
expr_stmt|;
name|writefds
operator|=
operator|(
name|fd_set
operator|*
operator|)
name|UA_ALLOC
argument_list|()
operator|+
sizeof|sizeof
argument_list|(
name|fd_set
operator|*
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|writefds
argument_list|)
expr_stmt|;
name|exceptfds
operator|=
operator|(
name|fd_set
operator|*
operator|)
name|UA_ALLOC
argument_list|()
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|fd_set
operator|*
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
name|exceptfds
argument_list|)
expr_stmt|;
name|timeout
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|UA_ALLOC
argument_list|()
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|fd_set
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|timeout
operator|==
operator|-
literal|1
condition|)
name|timeout
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|timeout
operator|->
name|tv_usec
operator|=
operator|(
name|args
operator|->
name|timeout
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|timeout
operator|->
name|tv_sec
operator|=
name|args
operator|->
name|timeout
operator|/
literal|1000
expr_stmt|;
block|}
name|tmp_select
operator|.
name|nd
operator|=
literal|0
expr_stmt|;
name|tmp_select
operator|.
name|in
operator|=
name|readfds
expr_stmt|;
name|tmp_select
operator|.
name|ou
operator|=
name|writefds
expr_stmt|;
name|tmp_select
operator|.
name|ex
operator|=
name|exceptfds
expr_stmt|;
name|tmp_select
operator|.
name|tv
operator|=
name|timeout
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|fds
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_poll
argument_list|)
argument_list|,
operator|&
name|conv
argument_list|,
sizeof|sizeof
argument_list|(
name|conv
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
name|conv
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conv
operator|.
name|fd
operator|<
literal|0
operator|||
name|conv
operator|.
name|fd
operator|>
name|FD_SETSIZE
condition|)
continue|continue;
if|if
condition|(
name|conv
operator|.
name|fd
operator|>=
name|tmp_select
operator|.
name|nd
condition|)
name|tmp_select
operator|.
name|nd
operator|=
name|conv
operator|.
name|fd
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|conv
operator|.
name|events
operator|&
name|IBCS2_READPOLL
condition|)
name|FD_SET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|readfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|conv
operator|.
name|events
operator|&
name|IBCS2_WRITEPOLL
condition|)
name|FD_SET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|writefds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|exceptfds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|select
argument_list|(
name|p
argument_list|,
operator|&
name|tmp_select
argument_list|,
name|retval
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|*
name|retval
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|*
name|retval
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
name|copyin
argument_list|(
name|args
operator|->
name|fds
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_poll
argument_list|)
argument_list|,
operator|&
name|conv
argument_list|,
sizeof|sizeof
argument_list|(
name|conv
argument_list|)
argument_list|)
expr_stmt|;
name|conv
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conv
operator|.
name|fd
operator|<
literal|0
operator|||
name|conv
operator|.
name|fd
operator|>
name|FD_SETSIZE
condition|)
comment|/* should check for open as well */
name|conv
operator|.
name|revents
operator||=
name|IBCS2_POLLNVAL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|FD_ISSET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|readfds
argument_list|)
condition|)
name|conv
operator|.
name|revents
operator||=
name|IBCS2_POLLIN
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|writefds
argument_list|)
condition|)
name|conv
operator|.
name|revents
operator||=
name|IBCS2_POLLOUT
expr_stmt|;
if|if
condition|(
name|FD_ISSET
argument_list|(
name|conv
operator|.
name|fd
argument_list|,
name|exceptfds
argument_list|)
condition|)
name|conv
operator|.
name|revents
operator||=
name|IBCS2_POLLERR
expr_stmt|;
if|if
condition|(
name|conv
operator|.
name|revents
condition|)
operator|++
operator|*
name|retval
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|conv
argument_list|,
name|args
operator|->
name|fds
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_poll
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|conv
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_procids_args
block|{
name|int
name|req
decl_stmt|;
name|int
name|eax
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_procids
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_procids_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'procids' request=%d,  eax=%x\n"
argument_list|,
name|args
operator|->
name|req
argument_list|,
name|args
operator|->
name|eax
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|req
condition|)
block|{
case|case
literal|0
case|:
comment|/* getpgrp */
return|return
name|getpgrp
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
case|case
literal|1
case|:
comment|/* setpgrp */
block|{
struct|struct
name|setpgid_args
block|{
name|int
name|pid
decl_stmt|;
name|int
name|pgid
decl_stmt|;
block|}
name|tmp
struct|;
name|tmp
operator|.
name|pid
operator|=
name|tmp
operator|.
name|pgid
operator|=
literal|0
expr_stmt|;
return|return
name|setpgid
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
return|;
block|}
case|case
literal|2
case|:
comment|/* setpgid */
return|return
name|setpgid
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
case|case
literal|3
case|:
comment|/* setsid */
return|return
name|setsid
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
name|int
name|ibcs2_profil
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'profil'\n"
argument_list|)
expr_stmt|;
return|return
name|profil
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_ptrace
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'ptrace'\n"
argument_list|)
expr_stmt|;
return|return
name|ptrace
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_readlink
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'readlink'\n"
argument_list|)
expr_stmt|;
return|return
name|readlink
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_rename
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'rename'\n"
argument_list|)
expr_stmt|;
return|return
name|rename
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_rmdir
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'rmdir'\n"
argument_list|)
expr_stmt|;
return|return
name|rmdir
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_secure_args
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|arg1
decl_stmt|;
name|int
name|arg2
decl_stmt|;
name|int
name|arg3
decl_stmt|;
name|int
name|arg4
decl_stmt|;
name|int
name|arg5
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_secure
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_secure_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|tf
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'secure'\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
literal|1
case|:
comment|/* get login uid */
operator|*
name|retval
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
return|return
name|EPERM
return|;
case|case
literal|2
case|:
comment|/* set login uid */
default|default:
name|printf
argument_list|(
literal|"IBCS2: 'secure' cmd=%d not implemented\n"
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_setgid_args
block|{
name|ibcs2_gid_t
name|gid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_setgid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_setgid_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|setgid_args
block|{
name|gid_t
name|gid
decl_stmt|;
block|}
name|tmp
struct|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'setgid'\n"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|gid
operator|=
operator|(
name|gid_t
operator|)
name|args
operator|->
name|gid
expr_stmt|;
return|return
name|setgid
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_setgroups_args
block|{
name|int
name|gidsetsize
decl_stmt|;
name|ibcs2_gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_setgroups
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_setgroups_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|setgroups_args
block|{
name|u_int
name|gidsetsize
decl_stmt|;
name|gid_t
modifier|*
name|gidset
decl_stmt|;
block|}
name|tmp
struct|;
name|ibcs2_gid_t
modifier|*
name|ibcs2_gidset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'setgroups'\n"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|gidsetsize
operator|=
name|args
operator|->
name|gidsetsize
expr_stmt|;
name|tmp
operator|.
name|gidset
operator|=
operator|(
name|gid_t
operator|*
operator|)
name|UA_ALLOC
argument_list|()
expr_stmt|;
name|ibcs2_gidset
operator|=
operator|(
name|ibcs2_gid_t
operator|*
operator|)
operator|&
name|tmp
operator|.
name|gidset
index|[
name|NGROUPS_MAX
index|]
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|gidset
argument_list|,
operator|(
name|caddr_t
operator|)
name|ibcs2_gidset
argument_list|,
sizeof|sizeof
argument_list|(
name|ibcs2_gid_t
argument_list|)
operator|*
name|tmp
operator|.
name|gidsetsize
argument_list|)
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tmp
operator|.
name|gidsetsize
condition|;
name|i
operator|++
control|)
name|tmp
operator|.
name|gidset
index|[
name|i
index|]
operator|=
operator|(
name|gid_t
operator|)
name|ibcs2_gidset
index|[
name|i
index|]
expr_stmt|;
return|return
name|setgroups
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_setuid_args
block|{
name|ibcs2_uid_t
name|uid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_setuid
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_setuid_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|setuid_args
block|{
name|uid_t
name|uid
decl_stmt|;
block|}
name|tmp
struct|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'setuid'\n"
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|args
operator|->
name|uid
expr_stmt|;
return|return
name|setuid
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_smount
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'smount'\n"
argument_list|)
expr_stmt|;
return|return
name|mount
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_stime_args
block|{
name|long
modifier|*
name|timeptr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_stime
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_stime_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'stime'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|args
operator|->
name|timeptr
condition|)
block|{
if|#
directive|if
literal|0
comment|/* WHAT DO WE DO ABOUT PENDING REAL-TIME TIMEOUTS??? */
block|boottime.tv_sec += (long)args->timeptr - time.tv_sec; 		s = splhigh(); 		time.tv_sec = (long)args->timeptr; 		time.tv_usec = 0; 		splx(s); 		resettodr();
else|#
directive|else
name|printf
argument_list|(
literal|"IBCS2: trying to set system time %d\n"
argument_list|,
operator|(
name|long
operator|)
name|args
operator|->
name|timeptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_sumount
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'sumount'\n"
argument_list|)
expr_stmt|;
return|return
name|unmount
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_symlink
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'symlink'\n"
argument_list|)
expr_stmt|;
return|return
name|symlink
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_sync
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'sync'\n"
argument_list|)
expr_stmt|;
return|return
name|sync
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_sysacct
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'sysacct'\n"
argument_list|)
expr_stmt|;
return|return
name|acct
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_tms
block|{
name|long
name|tms_utime
decl_stmt|;
name|long
name|tms_stime
decl_stmt|;
name|long
name|tms_cutime
decl_stmt|;
name|long
name|tms_cstime
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_times
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_tms
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
specifier|extern
name|int
name|hz
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|ibcs2_tms
name|tms
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'times'\n"
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_utime
operator|=
name|p
operator|->
name|p_uticks
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|p
operator|->
name|p_sticks
expr_stmt|;
name|tms
operator|.
name|tms_cutime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_utime
operator|.
name|tv_sec
operator|*
name|hz
operator|+
operator|(
operator|(
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_utime
operator|.
name|tv_usec
operator|*
name|hz
operator|)
operator|/
literal|1000000
operator|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_stime
operator|.
name|tv_sec
operator|*
name|hz
operator|+
operator|(
operator|(
name|p
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_stime
operator|.
name|tv_usec
operator|*
name|hz
operator|)
operator|/
literal|1000000
operator|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|tv
operator|.
name|tv_sec
operator|*
name|hz
operator|+
operator|(
name|tv
operator|.
name|tv_usec
operator|*
name|hz
operator|)
operator|/
literal|1000000
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tms
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|tms_utime
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_tms
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_ulimit_args
block|{
name|int
name|cmd
decl_stmt|;
name|long
name|limit
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_ulimit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_ulimit_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'ulimit'\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
name|IBCS2_GETFSIZE
case|:
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_SETFSIZE
case|:
return|return
name|EINVAL
return|;
case|case
name|IBCS2_GETPSIZE
case|:
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_RSS
index|]
operator|.
name|rlim_cur
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_GETMOPEN
case|:
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_NOFILE
index|]
operator|.
name|rlim_cur
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_umask
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'umask'\n"
argument_list|)
expr_stmt|;
return|return
name|umask
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_unlink
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'unlink'\n"
argument_list|)
expr_stmt|;
return|return
name|unlink
argument_list|(
name|p
argument_list|,
name|args
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_utime_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|ibcs2_time_t
modifier|*
name|timeptr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_utime
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_utime_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|bsd_utimes_args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tptr
decl_stmt|;
block|}
name|bsdutimes
struct|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'utime'\n"
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|args
operator|->
name|timeptr
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|bsdutimes
operator|.
name|tptr
operator|=
operator|&
name|tv
expr_stmt|;
name|bsdutimes
operator|.
name|fname
operator|=
name|args
operator|->
name|fname
expr_stmt|;
return|return
name|utimes
argument_list|(
name|p
argument_list|,
operator|&
name|bsdutimes
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ibcs2_utssys_args
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|mv
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|ibcs2_utssys
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ibcs2_utssys_args
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
struct|struct
name|ibcs2_utsname
block|{
name|char
name|sysname
index|[
literal|9
index|]
decl_stmt|;
name|char
name|nodename
index|[
literal|9
index|]
decl_stmt|;
name|char
name|release
index|[
literal|9
index|]
decl_stmt|;
name|char
name|version
index|[
literal|9
index|]
decl_stmt|;
name|char
name|machine
index|[
literal|9
index|]
decl_stmt|;
block|}
name|ibcs2_uname
struct|;
specifier|extern
name|char
name|ostype
index|[]
decl_stmt|,
name|hostname
index|[]
decl_stmt|,
name|osrelease
index|[]
decl_stmt|,
name|machine
index|[]
decl_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'utssys' cmd=%d\n"
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
literal|0
case|:
comment|/* uname */
name|bzero
argument_list|(
operator|&
name|ibcs2_uname
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_utsname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ibcs2_uname
operator|.
name|sysname
argument_list|,
name|ostype
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ibcs2_uname
operator|.
name|nodename
argument_list|,
name|hostname
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ibcs2_uname
operator|.
name|release
argument_list|,
name|osrelease
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ibcs2_uname
operator|.
name|version
argument_list|,
name|version
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ibcs2_uname
operator|.
name|machine
argument_list|,
name|machine
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ibcs2_uname
argument_list|,
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_utsname
argument_list|)
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
comment|/* ustat */
name|printf
argument_list|(
literal|"IBCS2: utssys(ustat) not implemented yet\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
case|case
literal|1
case|:
comment|/* umask, obsolete */
default|default:
name|printf
argument_list|(
literal|"IBCS2: 'utssys cmd (%d) not implemented yet'\n"
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
name|int
name|ibcs2_wait
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
modifier|*
name|retval
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|tf
init|=
operator|(
expr|struct
name|trapframe
operator|*
operator|)
name|p
operator|->
name|p_md
operator|.
name|md_regs
decl_stmt|;
struct|struct
name|ibcs2_waitpid_args
block|{
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
block|}
modifier|*
name|t
init|=
name|args
struct|;
struct|struct
name|wait4_args
block|{
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|status
decl_stmt|;
name|int
name|options
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rusage
decl_stmt|;
name|int
name|compat
decl_stmt|;
block|}
name|tmp
struct|;
name|tmp
operator|.
name|compat
operator|=
literal|1
expr_stmt|;
name|tmp
operator|.
name|rusage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ibcs2_trace
operator|&
name|IBCS2_TRACE_MISC
condition|)
name|printf
argument_list|(
literal|"IBCS2: 'wait'\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tf
operator|->
name|tf_eflags
operator|&
operator|(
name|PSL_Z
operator||
name|PSL_PF
operator||
name|PSL_N
operator||
name|PSL_V
operator|)
operator|)
operator|==
operator|(
name|PSL_Z
operator||
name|PSL_PF
operator||
name|PSL_N
operator||
name|PSL_V
operator|)
condition|)
block|{
name|tmp
operator|.
name|pid
operator|=
name|t
operator|->
name|pid
expr_stmt|;
name|tmp
operator|.
name|status
operator|=
name|t
operator|->
name|status
expr_stmt|;
name|tmp
operator|.
name|options
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|options
operator|&
literal|02
condition|)
name|tmp
operator|.
name|options
operator||=
name|WUNTRACED
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|options
operator|&
literal|01
condition|)
name|tmp
operator|.
name|options
operator||=
name|WNOHANG
expr_stmt|;
name|tmp
operator|.
name|options
operator|=
name|t
operator|->
name|options
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|.
name|pid
operator|=
name|WAIT_ANY
expr_stmt|;
name|tmp
operator|.
name|status
operator|=
operator|(
name|int
operator|*
operator|)
name|t
operator|->
name|pid
expr_stmt|;
name|tmp
operator|.
name|options
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|wait1
argument_list|(
name|p
argument_list|,
operator|&
name|tmp
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

end_unit

