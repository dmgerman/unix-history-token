begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995 Steven Wallace  * Copyright (c) 1994, 1995 Scott Bartram  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: Header: sun_misc.c,v 1.16 93/04/07 02:46:27 torek Exp   *  *	@(#)sun_misc.c	8.1 (Berkeley) 6/18/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IBCS2 compatibility module.  *  * IBCS2 system calls that are implemented differently in BSD are  * handled here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must come after sys/malloc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_dirent.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_signal.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_proto.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_unistd.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_util.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_utime.h>
end_include

begin_include
include|#
directive|include
file|<i386/ibcs2/ibcs2_xenix.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_function
name|int
name|ibcs2_ulimit
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_ulimit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|rlimit
name|rl
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
define|#
directive|define
name|IBCS2_GETFSIZE
value|1
define|#
directive|define
name|IBCS2_SETFSIZE
value|2
define|#
directive|define
name|IBCS2_GETPSIZE
value|3
define|#
directive|define
name|IBCS2_GETDTABLESIZE
value|4
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IBCS2_GETFSIZE
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|lim_cur
argument_list|(
name|p
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
operator|-
literal|1
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_SETFSIZE
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rl
operator|.
name|rlim_max
operator|=
name|lim_max
argument_list|(
name|p
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rl
operator|.
name|rlim_cur
operator|=
name|uap
operator|->
name|newlimit
expr_stmt|;
name|error
operator|=
name|kern_setrlimit
argument_list|(
name|td
argument_list|,
name|RLIMIT_FSIZE
argument_list|,
operator|&
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|lim_cur
argument_list|(
name|p
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"failed "
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
case|case
name|IBCS2_GETPSIZE
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|lim_cur
argument_list|(
name|p
argument_list|,
name|RLIMIT_RSS
argument_list|)
expr_stmt|;
comment|/* XXX */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_GETDTABLESIZE
case|:
name|uap
operator|->
name|cmd
operator|=
name|IBCS2_SC_OPEN_MAX
expr_stmt|;
return|return
name|ibcs2_sysconf
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|ibcs2_sysconf_args
operator|*
operator|)
name|uap
argument_list|)
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IBCS2_WSTOPPED
value|0177
end_define

begin_define
define|#
directive|define
name|IBCS2_STOPCODE
parameter_list|(
name|sig
parameter_list|)
value|((sig)<< 8 | IBCS2_WSTOPPED)
end_define

begin_function
name|int
name|ibcs2_wait
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_wait_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|options
decl_stmt|,
name|status
decl_stmt|;
name|int
modifier|*
name|statusp
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
init|=
name|td
operator|->
name|td_frame
decl_stmt|;
if|if
condition|(
operator|(
name|tf
operator|->
name|tf_eflags
operator|&
operator|(
name|PSL_Z
operator||
name|PSL_PF
operator||
name|PSL_N
operator||
name|PSL_V
operator|)
operator|)
operator|==
operator|(
name|PSL_Z
operator||
name|PSL_PF
operator||
name|PSL_N
operator||
name|PSL_V
operator|)
condition|)
block|{
comment|/* waitpid */
name|pid
operator|=
name|uap
operator|->
name|a1
expr_stmt|;
name|statusp
operator|=
operator|(
name|int
operator|*
operator|)
name|uap
operator|->
name|a2
expr_stmt|;
name|options
operator|=
name|uap
operator|->
name|a3
expr_stmt|;
block|}
else|else
block|{
comment|/* wait */
name|pid
operator|=
name|WAIT_ANY
expr_stmt|;
name|statusp
operator|=
operator|(
name|int
operator|*
operator|)
name|uap
operator|->
name|a1
expr_stmt|;
name|options
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|statusp
condition|)
block|{
comment|/* 		 * Convert status/signal result. 		 */
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|<=
literal|0
operator|||
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
operator|>
name|IBCS2_SIGTBLSZ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|status
operator|=
name|IBCS2_STOPCODE
argument_list|(
name|bsd_to_ibcs2_sig
index|[
name|_SIG_IDX
argument_list|(
name|WSTOPSIG
argument_list|(
name|status
argument_list|)
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|<=
literal|0
operator|||
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|>
name|IBCS2_SIGTBLSZ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|status
operator|=
name|bsd_to_ibcs2_sig
index|[
name|_SIG_IDX
argument_list|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* else exit status -- identical */
comment|/* record result/status */
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|status
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|status
argument_list|,
name|statusp
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_execv
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_execv_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|image_args
name|eargs
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|exec_copyin_args
argument_list|(
operator|&
name|eargs
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_execve
argument_list|(
name|td
argument_list|,
operator|&
name|eargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_execve
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_execve_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|image_args
name|eargs
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|exec_copyin_args
argument_list|(
operator|&
name|eargs
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|argp
argument_list|,
name|uap
operator|->
name|envp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_execve
argument_list|(
name|td
argument_list|,
operator|&
name|eargs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_umount
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_umount_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|unmount_args
name|um
decl_stmt|;
name|um
operator|.
name|path
operator|=
name|uap
operator|->
name|name
expr_stmt|;
name|um
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
return|return
name|unmount
argument_list|(
name|td
argument_list|,
operator|&
name|um
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_mount
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_mount_args
modifier|*
name|uap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|notyet
name|int
name|oflags
init|=
name|uap
operator|->
name|flags
decl_stmt|,
name|nflags
decl_stmt|,
name|error
decl_stmt|;
name|char
name|fsname
index|[
name|MFSNAMELEN
index|]
decl_stmt|;
if|if
condition|(
name|oflags
operator|&
operator|(
name|IBCS2_MS_NOSUB
operator||
name|IBCS2_MS_SYS5
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|oflags
operator|&
name|IBCS2_MS_NEWTYPE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|IBCS2_MS_RDONLY
condition|)
name|nflags
operator||=
name|MNT_RDONLY
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|IBCS2_MS_NOSUID
condition|)
name|nflags
operator||=
name|MNT_NOSUID
expr_stmt|;
if|if
condition|(
name|oflags
operator|&
name|IBCS2_MS_REMOUNT
condition|)
name|nflags
operator||=
name|MNT_UPDATE
expr_stmt|;
name|uap
operator|->
name|flags
operator|=
name|nflags
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|type
argument_list|,
name|fsname
argument_list|,
sizeof|sizeof
name|fsname
argument_list|,
operator|(
name|u_int
operator|*
operator|)
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|fsname
argument_list|,
literal|"4.2"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uap
operator|->
name|type
operator|=
operator|(
name|caddr_t
operator|)
name|STACK_ALLOC
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyout
argument_list|(
literal|"ufs"
argument_list|,
name|uap
operator|->
name|type
argument_list|,
sizeof|sizeof
argument_list|(
literal|"ufs"
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fsname
argument_list|,
literal|"nfs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ibcs2_nfs_args
name|sna
decl_stmt|;
name|struct
name|sockaddr_in
name|sain
decl_stmt|;
name|struct
name|nfs_args
name|na
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|sna
argument_list|,
sizeof|sizeof
name|sna
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|sna
operator|.
name|addr
argument_list|,
operator|&
name|sain
argument_list|,
sizeof|sizeof
name|sain
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|sain
argument_list|,
operator|&
name|sa
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
name|sain
argument_list|)
expr_stmt|;
name|uap
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|STACK_ALLOC
argument_list|()
expr_stmt|;
name|na
operator|.
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|int
operator|)
name|uap
operator|->
name|data
operator|+
sizeof|sizeof
name|na
operator|)
expr_stmt|;
name|na
operator|.
name|sotype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|na
operator|.
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
name|na
operator|.
name|fh
operator|=
operator|(
name|nfsv2fh_t
operator|*
operator|)
name|sna
operator|.
name|fh
expr_stmt|;
name|na
operator|.
name|flags
operator|=
name|sna
operator|.
name|flags
expr_stmt|;
name|na
operator|.
name|wsize
operator|=
name|sna
operator|.
name|wsize
expr_stmt|;
name|na
operator|.
name|rsize
operator|=
name|sna
operator|.
name|rsize
expr_stmt|;
name|na
operator|.
name|timeo
operator|=
name|sna
operator|.
name|timeo
expr_stmt|;
name|na
operator|.
name|retrans
operator|=
name|sna
operator|.
name|retrans
expr_stmt|;
name|na
operator|.
name|hostname
operator|=
name|sna
operator|.
name|hostname
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sa
argument_list|,
name|na
operator|.
name|addr
argument_list|,
sizeof|sizeof
name|sa
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|na
argument_list|,
name|uap
operator|->
name|data
argument_list|,
sizeof|sizeof
name|na
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|mount
argument_list|(
name|td
argument_list|,
name|uap
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Read iBCS2-style directory entries.  We suck them into kernel space so  * that they can be massaged before being copied out to user code.  Like  * SunOS, we squish out `empty' entries.  *  * This is quite ugly, but what do you expect from compatibility code?  */
end_comment

begin_function
name|int
name|ibcs2_getdents
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|ibcs2_getdents_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|caddr_t
name|outp
decl_stmt|;
comment|/* iBCS2-format */
specifier|register
name|int
name|resid
decl_stmt|;
comment|/* iBCS2-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|ibcs2_dirent
name|idb
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|,
name|vfslocked
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookiep
decl_stmt|;
name|int
name|ncookies
decl_stmt|;
define|#
directive|define
name|BSD_DIRENT
parameter_list|(
name|cp
parameter_list|)
value|((struct dirent *)(cp))
define|#
directive|define
name|IBCS2_RECLEN
parameter_list|(
name|reclen
parameter_list|)
value|(reclen + sizeof(u_short))
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
comment|/* XXX  vnode readdir op should do this */
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
define|#
directive|define
name|DIRBLKSIZ
value|512
comment|/* XXX we used to use ufs's DIRBLKSIZ */
name|buflen
operator|=
name|max
argument_list|(
name|DIRBLKSIZ
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|min
argument_list|(
name|buflen
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_vnode_check_readdir
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
comment|/* 	 * First we read into the malloc'ed buffer, then 	 * we massage it into user space, one record at a time. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|resid
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|eof
goto|;
name|cookiep
operator|=
name|cookies
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
comment|/* 		 * When using cookies, the vfs has the option of reading from 		 * a different offset than that supplied (UFS truncates the 		 * offset to a block boundary to make sure that it never reads 		 * partway through a directory entry, even if the directory 		 * has been compacted). 		 */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
operator|*
name|cookiep
operator|<=
name|off
condition|)
block|{
name|len
operator|-=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
name|inp
operator|+=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
if|if
condition|(
name|cookiep
operator|&&
name|ncookies
operator|==
literal|0
condition|)
break|break;
name|reclen
operator|=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"ibcs2_getdents: reclen=%d\n"
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|IBCS2_RECLEN
argument_list|(
name|reclen
argument_list|)
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Massage in place to make an iBCS2-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 */
name|idb
operator|.
name|d_ino
operator|=
operator|(
name|ibcs2_ino_t
operator|)
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
expr_stmt|;
name|idb
operator|.
name|d_off
operator|=
operator|(
name|ibcs2_off_t
operator|)
name|off
expr_stmt|;
name|idb
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|IBCS2_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|idb
argument_list|,
name|outp
argument_list|,
literal|10
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_name
argument_list|,
name|outp
operator|+
literal|10
argument_list|,
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_namlen
operator|+
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past iBCS2-shaped entry */
name|outp
operator|+=
name|IBCS2_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
name|resid
operator|-=
name|IBCS2_RECLEN
argument_list|(
name|reclen
argument_list|)
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|uap
operator|->
name|buf
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|uap
operator|->
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_read
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_read_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
specifier|register
name|caddr_t
name|outp
decl_stmt|;
comment|/* iBCS2-format */
specifier|register
name|int
name|resid
decl_stmt|;
comment|/* iBCS2-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
struct|struct
name|ibcs2_direct
block|{
name|ibcs2_ino_t
name|ino
decl_stmt|;
name|char
name|name
index|[
literal|14
index|]
decl_stmt|;
block|}
name|idb
struct|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|,
name|size
decl_stmt|,
name|vfslocked
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookiep
decl_stmt|;
name|int
name|ncookies
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINVAL
condition|)
return|return
name|read
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|read_args
operator|*
operator|)
name|uap
argument_list|)
return|;
else|else
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|read
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|read_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"ibcs2_read: read directory\n"
operator|)
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|max
argument_list|(
name|DIRBLKSIZ
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|min
argument_list|(
name|buflen
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_vnode_check_readdir
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
comment|/* 	 * First we read into the malloc'ed buffer, then 	 * we massage it into user space, one record at a time. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"VOP_READDIR failed: %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|resid
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|<=
literal|0
condition|)
goto|goto
name|eof
goto|;
name|cookiep
operator|=
name|cookies
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
comment|/* 		 * When using cookies, the vfs has the option of reading from 		 * a different offset than that supplied (UFS truncates the 		 * offset to a block boundary to make sure that it never reads 		 * partway through a directory entry, even if the directory 		 * has been compacted). 		 */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
operator|*
name|cookiep
operator|<=
name|off
condition|)
block|{
name|len
operator|-=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
name|inp
operator|+=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
operator|&&
name|resid
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
if|if
condition|(
name|cookiep
operator|&&
name|ncookies
operator|==
literal|0
condition|)
break|break;
name|reclen
operator|=
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"ibcs2_read: reclen=%d\n"
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_direct
argument_list|)
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Massage in place to make an iBCS2-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 * 		 * TODO: if length(filename)> 14, then break filename into 		 * multiple entries and set inode = 0xffff except last 		 */
name|idb
operator|.
name|ino
operator|=
operator|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
operator|>
literal|0xfffe
operator|)
condition|?
literal|0xfffe
else|:
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_fileno
expr_stmt|;
operator|(
name|void
operator|)
name|copystr
argument_list|(
name|BSD_DIRENT
argument_list|(
name|inp
argument_list|)
operator|->
name|d_name
argument_list|,
name|idb
operator|.
name|name
argument_list|,
literal|14
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|idb
operator|.
name|name
operator|+
name|size
argument_list|,
literal|14
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|idb
argument_list|,
name|outp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_direct
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past iBCS2-shaped entry */
name|outp
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_direct
argument_list|)
expr_stmt|;
name|resid
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ibcs2_direct
argument_list|)
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|uap
operator|->
name|buf
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|uap
operator|->
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_mknod
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_mknod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTCREAT
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|uap
operator|->
name|mode
argument_list|)
condition|)
name|error
operator|=
name|kern_mkfifo
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|kern_mknod
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
name|uap
operator|->
name|dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_getgroups
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_getgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
name|ibcs2_gid_t
modifier|*
name|iset
decl_stmt|;
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|ngrp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|gidsetsize
operator|<
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|gidsetsize
operator|==
literal|0
condition|)
name|ngrp
operator|=
literal|0
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
name|ngrp
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
expr_stmt|;
name|gp
operator|=
name|malloc
argument_list|(
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|gp
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_getgroups
argument_list|(
name|td
argument_list|,
operator|&
name|ngrp
argument_list|,
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|uap
operator|->
name|gidsetsize
operator|>
literal|0
condition|)
block|{
name|iset
operator|=
name|malloc
argument_list|(
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iset
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ngrp
condition|;
name|i
operator|++
control|)
name|iset
index|[
name|i
index|]
operator|=
operator|(
name|ibcs2_gid_t
operator|)
name|gp
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|iset
argument_list|,
name|uap
operator|->
name|gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|ibcs2_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iset
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|gp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_setgroups
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_setgroups_args
modifier|*
name|uap
decl_stmt|;
block|{
name|ibcs2_gid_t
modifier|*
name|iset
decl_stmt|;
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|gidsetsize
operator|<
literal|0
operator|||
name|uap
operator|->
name|gidsetsize
operator|>
name|ngroups_max
operator|+
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|gidsetsize
operator|&&
name|uap
operator|->
name|gidset
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gp
operator|=
name|malloc
argument_list|(
name|uap
operator|->
name|gidsetsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|gp
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|gidsetsize
condition|)
block|{
name|iset
operator|=
name|malloc
argument_list|(
name|uap
operator|->
name|gidsetsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|iset
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|gidset
argument_list|,
name|iset
argument_list|,
sizeof|sizeof
argument_list|(
name|ibcs2_gid_t
argument_list|)
operator|*
name|uap
operator|->
name|gidsetsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|iset
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|gidsetsize
condition|;
name|i
operator|++
control|)
name|gp
index|[
name|i
index|]
operator|=
operator|(
name|gid_t
operator|)
name|iset
index|[
name|i
index|]
expr_stmt|;
block|}
name|error
operator|=
name|kern_setgroups
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|gidsetsize
argument_list|,
name|gp
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|gp
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_setuid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_setuid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|setuid_args
name|sa
decl_stmt|;
name|sa
operator|.
name|uid
operator|=
operator|(
name|uid_t
operator|)
name|uap
operator|->
name|uid
expr_stmt|;
return|return
name|setuid
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_setgid
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_setgid_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|setgid_args
name|sa
decl_stmt|;
name|sa
operator|.
name|gid
operator|=
operator|(
name|gid_t
operator|)
name|uap
operator|->
name|gid
expr_stmt|;
return|return
name|setgid
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_time
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_time_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|tp
condition|)
return|return
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
operator|.
name|tv_sec
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|ibcs2_time_t
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_pathconf
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_pathconf_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|uap
operator|->
name|name
operator|++
expr_stmt|;
comment|/* iBCS2 _PC_* defines are offset by one */
name|error
operator|=
name|kern_pathconf
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|name
argument_list|,
name|FOLLOW
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_fpathconf
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_fpathconf_args
modifier|*
name|uap
decl_stmt|;
block|{
name|uap
operator|->
name|name
operator|++
expr_stmt|;
comment|/* iBCS2 _PC_* defines are offset by one */
return|return
name|fpathconf
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|fpathconf_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_sysconf
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_sysconf_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|,
name|value
decl_stmt|,
name|len
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|name
condition|)
block|{
case|case
name|IBCS2_SC_ARG_MAX
case|:
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_ARGMAX
expr_stmt|;
break|break;
case|case
name|IBCS2_SC_CHILD_MAX
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_NPROC
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_SC_CLK_TCK
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|hz
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_SC_NGROUPS_MAX
case|:
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_NGROUPS
expr_stmt|;
break|break;
case|case
name|IBCS2_SC_OPEN_MAX
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_NOFILE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|IBCS2_SC_JOB_CONTROL
case|:
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_JOB_CONTROL
expr_stmt|;
break|break;
case|case
name|IBCS2_SC_SAVED_IDS
case|:
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_SAVED_IDS
expr_stmt|;
break|break;
case|case
name|IBCS2_SC_VERSION
case|:
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_POSIX1
expr_stmt|;
break|break;
case|case
name|IBCS2_SC_PASS_MAX
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|128
expr_stmt|;
comment|/* XXX - should we create PASS_MAX ? */
return|return
literal|0
return|;
case|case
name|IBCS2_SC_XOPEN_VERSION
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|2
expr_stmt|;
comment|/* XXX: What should that be? */
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|error
operator|=
name|kernel_sysctl
argument_list|(
name|td
argument_list|,
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_alarm
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_alarm_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|itimerval
name|itv
decl_stmt|,
name|oitv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|timevalclear
argument_list|(
operator|&
name|itv
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|uap
operator|->
name|sec
expr_stmt|;
name|itv
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kern_setitimer
argument_list|(
name|td
argument_list|,
name|ITIMER_REAL
argument_list|,
operator|&
name|itv
argument_list|,
operator|&
name|oitv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|oitv
operator|.
name|it_value
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
name|oitv
operator|.
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|oitv
operator|.
name|it_value
operator|.
name|tv_sec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_times
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_times_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|rusage
name|ru
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|struct
name|tms
name|tms
decl_stmt|;
name|int
name|error
decl_stmt|;
define|#
directive|define
name|CONVTCK
parameter_list|(
name|r
parameter_list|)
value|(r.tv_sec * hz + r.tv_usec / (1000000 / hz))
name|error
operator|=
name|kern_getrusage
argument_list|(
name|td
argument_list|,
name|RUSAGE_SELF
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tms
operator|.
name|tms_utime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_getrusage
argument_list|(
name|td
argument_list|,
name|RUSAGE_CHILDREN
argument_list|,
operator|&
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tms
operator|.
name|tms_cutime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|CONVTCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tms
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_stime
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_stime_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|secs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timep
argument_list|,
operator|&
name|secs
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tv
operator|.
name|tv_sec
operator|=
name|secs
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kern_settimeofday
argument_list|(
name|td
argument_list|,
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_utime
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_utime_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|ibcs2_utimbuf
name|ubuf
decl_stmt|;
name|struct
name|timeval
name|tbuf
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|buf
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|ubuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|ubuf
operator|.
name|actime
expr_stmt|;
name|tbuf
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|ubuf
operator|.
name|modtime
expr_stmt|;
name|tbuf
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|tbuf
expr_stmt|;
block|}
else|else
name|tp
operator|=
name|NULL
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_utimes
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_nice
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_nice_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|setpriority_args
name|sa
decl_stmt|;
name|sa
operator|.
name|which
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|sa
operator|.
name|who
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|prio
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_nice
operator|+
name|uap
operator|->
name|incr
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|setpriority
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|EPERM
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_nice
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * iBCS2 getpgrp, setpgrp, setsid, and setpgid  */
end_comment

begin_function
name|int
name|ibcs2_pgrpsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_pgrpsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/* getpgrp */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* setpgrp */
block|{
name|struct
name|setpgid_args
name|sa
decl_stmt|;
name|sa
operator|.
name|pid
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|pgid
operator|=
literal|0
expr_stmt|;
name|setpgid
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
literal|2
case|:
comment|/* setpgid */
block|{
name|struct
name|setpgid_args
name|sa
decl_stmt|;
name|sa
operator|.
name|pid
operator|=
name|uap
operator|->
name|pid
expr_stmt|;
name|sa
operator|.
name|pgid
operator|=
name|uap
operator|->
name|pgid
expr_stmt|;
return|return
name|setpgid
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
case|case
literal|3
case|:
comment|/* setsid */
return|return
name|setsid
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|)
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX - need to check for nested calls  */
end_comment

begin_function
name|int
name|ibcs2_plock
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_plock_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
define|#
directive|define
name|IBCS2_UNLOCK
value|0
define|#
directive|define
name|IBCS2_PROCLOCK
value|1
define|#
directive|define
name|IBCS2_TEXTLOCK
value|2
define|#
directive|define
name|IBCS2_DATALOCK
value|4
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IBCS2_UNLOCK
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VM_MUNLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX - TODO */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|IBCS2_PROCLOCK
case|:
case|case
name|IBCS2_TEXTLOCK
case|:
case|case
name|IBCS2_DATALOCK
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VM_MLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX - TODO */
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_uadmin
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_uadmin_args
modifier|*
name|uap
decl_stmt|;
block|{
define|#
directive|define
name|SCO_A_REBOOT
value|1
define|#
directive|define
name|SCO_A_SHUTDOWN
value|2
define|#
directive|define
name|SCO_A_REMOUNT
value|4
define|#
directive|define
name|SCO_A_CLOCK
value|8
define|#
directive|define
name|SCO_A_SETCONFIG
value|128
define|#
directive|define
name|SCO_A_GETDEV
value|130
define|#
directive|define
name|SCO_AD_HALT
value|0
define|#
directive|define
name|SCO_AD_BOOT
value|1
define|#
directive|define
name|SCO_AD_IBOOT
value|2
define|#
directive|define
name|SCO_AD_PWRDOWN
value|3
define|#
directive|define
name|SCO_AD_PWRNAP
value|4
define|#
directive|define
name|SCO_AD_PANICBOOT
value|1
define|#
directive|define
name|SCO_AD_GETBMAJ
value|0
define|#
directive|define
name|SCO_AD_GETCMAJ
value|1
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SCO_A_REBOOT
case|:
case|case
name|SCO_A_SHUTDOWN
case|:
switch|switch
condition|(
name|uap
operator|->
name|func
condition|)
block|{
name|struct
name|reboot_args
name|r
decl_stmt|;
case|case
name|SCO_AD_HALT
case|:
case|case
name|SCO_AD_PWRDOWN
case|:
case|case
name|SCO_AD_PWRNAP
case|:
name|r
operator|.
name|opt
operator|=
name|RB_HALT
expr_stmt|;
return|return
operator|(
name|reboot
argument_list|(
name|td
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
case|case
name|SCO_AD_BOOT
case|:
case|case
name|SCO_AD_IBOOT
case|:
name|r
operator|.
name|opt
operator|=
name|RB_AUTOBOOT
expr_stmt|;
return|return
operator|(
name|reboot
argument_list|(
name|td
argument_list|,
operator|&
name|r
argument_list|)
operator|)
return|;
block|}
return|return
name|EINVAL
return|;
case|case
name|SCO_A_REMOUNT
case|:
case|case
name|SCO_A_CLOCK
case|:
case|case
name|SCO_A_SETCONFIG
case|:
return|return
literal|0
return|;
case|case
name|SCO_A_GETDEV
case|:
return|return
name|EINVAL
return|;
comment|/* XXX - TODO */
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_sysfs
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_sysfs_args
modifier|*
name|uap
decl_stmt|;
block|{
define|#
directive|define
name|IBCS2_GETFSIND
value|1
define|#
directive|define
name|IBCS2_GETFSTYP
value|2
define|#
directive|define
name|IBCS2_GETNFSTYP
value|3
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IBCS2_GETFSIND
case|:
case|case
name|IBCS2_GETFSTYP
case|:
case|case
name|IBCS2_GETNFSTYP
case|:
break|break;
block|}
return|return
name|EINVAL
return|;
comment|/* XXX - TODO */
block|}
end_function

begin_function
name|int
name|ibcs2_unlink
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_unlink_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_unlink
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chdir
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_chdir_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_chdir
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chmod
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_chmod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_chmod
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_chown
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_chown_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_chown
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|uid
argument_list|,
name|uap
operator|->
name|gid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_rmdir
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_rmdir_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_rmdir
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_mkdir
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_mkdir_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_mkdir
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|mode
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_symlink
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_symlink_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|link
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
comment|/* 	 * Have to expand CHECKALTCREAT() so that 'path' can be freed on 	 * errors. 	 */
name|error
operator|=
name|ibcs2_emul_find
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|link
argument_list|,
name|UIO_USERSPACE
argument_list|,
operator|&
name|link
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|kern_symlink
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|link
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|link
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_rename
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_rename_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|from
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
comment|/* 	 * Have to expand CHECKALTCREAT() so that 'from' can be freed on 	 * errors. 	 */
name|error
operator|=
name|ibcs2_emul_find
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|to
argument_list|,
name|UIO_USERSPACE
argument_list|,
operator|&
name|to
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|from
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|kern_rename
argument_list|(
name|td
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|from
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ibcs2_readlink
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ibcs2_readlink_args
modifier|*
name|uap
decl_stmt|;
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_readlink
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|count
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

