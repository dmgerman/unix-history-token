begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** ** **  $Id: pci.c,v 2.0.0.8 94/08/21 19:57:39 wolf Exp $ ** **  General subroutines for the PCI bus on 80*86 systems. **  pci_configure () ** **  386bsd / FreeBSD ** **------------------------------------------------------------------------- ** ** Copyright (c) 1994 Wolfgang Stanglmeier.  All rights reserved. ** ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** 3. The name of the author may not be used to endorse or promote products **    derived from this software without specific prior written permission. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR ** IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES ** OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. ** IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, ** INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT ** NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, ** DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY ** THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT ** (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF ** THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ** **------------------------------------------------------------------------- ** **  $Log:	pci.c,v $ **  Revision 2.0.0.8  94/08/21  19:57:39  wolf **  Unneeded declarations removed (FreeBSD2.0) **   **  Revision 2.0.0.7  94/08/21  19:25:54  wolf **  pci_intr simplified. **  new not_supported() function. **  Vendor and device ids moved into tables. **   **  Revision 2.0.0.6  94/08/18  22:58:23  wolf **  Symbolic names for pci configuration space registers. **  last_device: from configuration mode **  last_bus: from pcibios. **  PCI_MAX_DPI: changed to 4 (settable by config) **  interrupt configuration by line or pin **   **  Revision 2.0.0.5  94/08/11  19:04:10  wolf **  display of interrupt line configuration register. **   **  Revision 2.0.0.4  94/08/01  20:36:28  wolf **  Tiny clean up. **   **  Revision 2.0.0.3  94/08/01  18:52:33  wolf **  New vendor entry:  S3. **  Scan pci busses #0..#255 as default. **  Number of scanned busses and devices settable as option. **  Show these numbers before starting the scan. **   **  Revision 2.0.0.2  94/07/27  09:27:19  wolf **  New option PCI_QUIET: suppress log messages. **   **  Revision 2.0.0.1  94/07/19  19:06:44  wolf **  New vendor entry:  MATROX **   **  Revision 2.0  94/07/10  15:53:29  wolf **  FreeBSD release. **   **  Revision 1.0  94/06/07  20:02:19  wolf **  Beta release. **   *************************************************************************** */
end_comment

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*======================================================== ** **	Configuration ** **======================================================== */
end_comment

begin_comment
comment|/* **	maximum number of devices which share one interrupt line */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_MAX_DPI
end_ifndef

begin_define
define|#
directive|define
name|PCI_MAX_DPI
value|(4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*PCI_MAX_DPI*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	#includes  and  declarations ** **======================================================== */
end_comment

begin_include
include|#
directive|include
file|<types.h>
end_include

begin_include
include|#
directive|include
file|<cdefs.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/pci.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/pci_device.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/pcibios.h>
end_include

begin_decl_stmt
name|char
name|ident_pci_c
index|[]
init|=
literal|"\n$Id: pci.c,v 2.0.0.8 94/08/21 19:57:39 wolf Exp $\n"
literal|"Copyright (c) 1994, Wolfgang Stanglmeier\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	Function prototypes missing in system headers */
end_comment

begin_function_decl
specifier|extern
name|int
name|printf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ffs
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
operator|(
name|__FreeBSD__
operator|>=
literal|2
operator|)
end_if

begin_function_decl
specifier|extern
name|pmap_t
name|pmap_kernel
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	Autoconfiguration (of isa bus) ** **======================================================== */
end_comment

begin_comment
comment|/* **      per device (interrupt) data structure. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|u_short
name|number
decl_stmt|;
name|u_short
name|isanum
decl_stmt|;
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|proc
function_decl|)
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
name|dev_t
name|unit
decl_stmt|;
block|}
name|vector
index|[
name|PCI_MAX_DPI
index|]
struct|;
block|}
name|pcidata
index|[
name|NPCI
index|]
struct|;
end_struct

begin_comment
comment|/* **	check device ready */
end_comment

begin_function
specifier|static
name|int
name|pciprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|id_unit
operator|>=
name|NPCI
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|pci_conf_mode
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	initialize the driver structure */
end_comment

begin_function
specifier|static
name|int
name|pciattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|isdp
parameter_list|)
block|{
name|pcidata
index|[
name|isdp
operator|->
name|id_unit
index|]
operator|.
name|number
operator|=
literal|0
expr_stmt|;
name|pcidata
index|[
name|isdp
operator|->
name|id_unit
index|]
operator|.
name|isanum
operator|=
name|ffs
argument_list|(
name|isdp
operator|->
name|id_irq
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **      ISA driver structure */
end_comment

begin_decl_stmt
name|struct
name|isa_driver
name|pcidriver
init|=
block|{
name|pciprobe
block|,
name|pciattach
block|,
literal|"pci"
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	Interrupt forward from isa to pci devices. ** **======================================================== */
end_comment

begin_function
name|void
name|pciintr
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|u_short
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NPCI
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcidata
index|[
name|unit
index|]
operator|.
name|number
condition|;
name|i
operator|++
control|)
block|{
call|(
name|void
call|)
argument_list|(
operator|*
name|pcidata
index|[
name|unit
index|]
operator|.
name|vector
index|[
name|i
index|]
operator|.
name|proc
argument_list|)
argument_list|(
name|pcidata
index|[
name|unit
index|]
operator|.
name|vector
index|[
name|i
index|]
operator|.
name|unit
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*======================================================== ** **	Autoconfiguration of pci devices. ** **	This is reverse to the isa configuration. **	(1) find a pci device. **	(2) look for a driver. ** **======================================================== */
end_comment

begin_comment
comment|/*-------------------------------------------------------- ** **	The pci devices can be mapped to any address. **	As default we start at the last gigabyte. ** **-------------------------------------------------------- */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PCI_PMEM_START
end_ifndef

begin_define
define|#
directive|define
name|PCI_PMEM_START
value|0xc0000000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pci_paddr
init|=
name|PCI_PMEM_START
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*--------------------------------------------------------- ** **	pci_configure () ** **--------------------------------------------------------- */
end_comment

begin_function_decl
specifier|static
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|pci_configure
parameter_list|()
block|{
name|u_char
name|device
decl_stmt|,
name|last_device
decl_stmt|;
name|u_short
name|bus
decl_stmt|,
name|last_bus
decl_stmt|;
name|pcici_t
name|tag
decl_stmt|;
name|pcidi_t
name|type
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|int
name|intpin
decl_stmt|;
name|int
name|isanum
decl_stmt|;
name|int
name|pci_mode
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|drp
decl_stmt|;
name|struct
name|pci_device
modifier|*
name|dvp
decl_stmt|;
comment|/* 	**	check pci bus present 	*/
name|pci_mode
operator|=
name|pci_conf_mode
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|pci_mode
condition|)
return|return;
name|last_bus
operator|=
name|pci_last_bus
argument_list|()
expr_stmt|;
name|last_device
operator|=
name|pci_mode
operator|==
literal|1
condition|?
literal|31
else|:
literal|15
expr_stmt|;
comment|/* 	**	hello world .. 	*/
ifndef|#
directive|ifndef
name|PCI_QUIET
name|printf
argument_list|(
literal|"PCI configuration mode %d.\n"
argument_list|,
name|pci_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Scanning device 0..%d on pci bus 0..%d "
literal|"($Revision: 2.0.0.8 $)\n"
argument_list|,
name|last_device
argument_list|,
name|last_bus
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<=
name|last_bus
condition|;
name|bus
operator|++
control|)
for|for
control|(
name|device
operator|=
literal|0
init|;
name|device
operator|<=
name|last_device
condition|;
name|device
operator|++
control|)
block|{
name|tag
operator|=
name|pcitag
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|type
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_ID_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|type
operator|)
operator|||
operator|(
name|type
operator|==
literal|0xfffffffful
operator|)
condition|)
continue|continue;
comment|/* 		**	lookup device in ioconfiguration: 		*/
for|for
control|(
name|dvp
operator|=
name|pci_devtab
init|;
name|drp
operator|=
name|dvp
operator|->
name|pd_driver
condition|;
name|dvp
operator|++
control|)
block|{
if|if
condition|(
name|drp
operator|->
name|device_id
operator|==
name|type
condition|)
break|break;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|PCI_QUIET
if|if
condition|(
operator|!
name|drp
condition|)
continue|continue;
endif|#
directive|endif
name|printf
argument_list|(
literal|"on pci%d:%d "
argument_list|,
name|bus
argument_list|,
name|device
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PCI_QUIET
if|if
condition|(
operator|!
name|drp
condition|)
block|{
name|not_supported
argument_list|(
name|tag
argument_list|,
name|type
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
endif|#
directive|endif
comment|/* 		**	found it. 		**	probe returns the device unit. 		*/
name|printf
argument_list|(
literal|"<%s>"
argument_list|,
name|drp
operator|->
name|vendor
argument_list|)
expr_stmt|;
name|unit
operator|=
call|(
modifier|*
name|drp
operator|->
name|probe
call|)
argument_list|(
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" probe failed.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
comment|/* 		**	install interrupts 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_INTERRUPT_REG
argument_list|)
expr_stmt|;
name|intpin
operator|=
name|PCI_INTERRUPT_PIN_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|intpin
condition|)
block|{
name|int
name|idx
init|=
name|NPCI
decl_stmt|;
comment|/* 			**  Usage of int line register (if set by bios) 			**  Matt Thomas<thomas@lkg.dec.com> 			*/
name|isanum
operator|=
name|PCI_INTERRUPT_LINE_EXTRACT
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|isanum
condition|)
block|{
name|printf
argument_list|(
literal|" il=%d"
argument_list|,
name|isanum
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NPCI
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|pcidata
index|[
name|idx
index|]
operator|.
name|isanum
operator|==
name|isanum
condition|)
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 			**	Or believe to the interrupt pin register. 			*/
if|if
condition|(
name|idx
operator|>=
name|NPCI
condition|)
name|idx
operator|=
name|intpin
operator|-
literal|1
expr_stmt|;
comment|/* 			**	And install the interrupt. 			*/
if|if
condition|(
name|idx
operator|<
name|NPCI
condition|)
block|{
name|u_short
name|entry
init|=
name|pcidata
index|[
name|idx
index|]
operator|.
name|number
decl_stmt|;
name|printf
argument_list|(
literal|" irq %c"
argument_list|,
literal|0x60
operator|+
name|intpin
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|<
name|PCI_MAX_DPI
condition|)
block|{
name|pcidata
index|[
name|idx
index|]
operator|.
name|vector
index|[
name|entry
index|]
operator|.
name|proc
operator|=
name|drp
operator|->
name|intr
expr_stmt|;
name|pcidata
index|[
name|idx
index|]
operator|.
name|vector
index|[
name|entry
index|]
operator|.
name|unit
operator|=
name|unit
expr_stmt|;
name|entry
operator|++
expr_stmt|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|" isa=%d [%d]"
argument_list|,
name|pcidata
index|[
name|idx
index|]
operator|.
name|isanum
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|pcidata
index|[
name|idx
index|]
operator|.
name|number
operator|=
name|entry
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" not installed"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
empty_stmt|;
comment|/* 		**	enable memory access 		*/
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|PCI_COMMAND_STATUS_REG
argument_list|)
operator|&
literal|0xffff
operator||
name|PCI_COMMAND_MEM_ENABLE
expr_stmt|;
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
operator|(
name|u_char
operator|)
name|PCI_COMMAND_STATUS_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 		**	attach device 		**	may produce additional log messages, 		**	i.e. when installing subdevices. 		*/
name|printf
argument_list|(
literal|" as %s%d\n"
argument_list|,
name|drp
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|drp
operator|->
name|attach
argument_list|)
argument_list|(
name|tag
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"pci uses physical addresses from %x to %x\n"
argument_list|,
name|PCI_PMEM_START
argument_list|,
name|pci_paddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into port space. ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_decl_stmt
specifier|extern
name|vm_map_t
name|kernel_map
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pci_map_port
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|u_short
modifier|*
name|pa
parameter_list|)
block|{
comment|/* 	**	@MAPIO@ not yet implemented. 	*/
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*----------------------------------------------------------------------- ** **	Map device into virtual and physical space ** **	PCI-Specification:  6.2.5.1: address maps ** **----------------------------------------------------------------------- */
end_comment

begin_function
name|int
name|pci_map_mem
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|reg
parameter_list|,
name|vm_offset_t
modifier|*
name|va
parameter_list|,
name|vm_offset_t
modifier|*
name|pa
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|,
name|result
decl_stmt|;
name|vm_size_t
name|vsize
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
comment|/* 	**	sanity check 	*/
if|if
condition|(
name|reg
operator|<=
name|PCI_MAP_REG_START
operator|||
name|reg
operator|>=
name|PCI_MAP_REG_END
operator|||
operator|(
name|reg
operator|&
literal|3
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	**	get size and type of memory 	** 	**	type is in the lowest four bits. 	**	If device requires 2^n bytes, the next 	**	n-4 bits are read as 0. 	*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
literal|0xfffffffful
argument_list|)
expr_stmt|;
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|data
operator|&
literal|0x0f
condition|)
block|{
case|case
name|PCI_MAP_MEMORY_TYPE_32BIT
case|:
comment|/* 32 bit non cachable */
break|break;
default|default:
comment|/* unknown */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	mask out the type, 	**	and round up to a page size 	*/
name|vsize
operator|=
name|round_page
argument_list|(
operator|-
operator|(
name|data
operator|&
name|PCI_MAP_MEMORY_ADDRESS_MASK
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          memory size=0x%x"
argument_list|,
name|vsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	**	try to map device to virtual space 	*/
name|vaddr
operator|=
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|&
name|vaddr
argument_list|,
name|vsize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|printf
argument_list|(
literal|" vm_map_find failed(%d)\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
empty_stmt|;
comment|/* 	**	align physical address to virtual size 	*/
if|if
condition|(
name|data
operator|=
name|pci_paddr
operator|%
name|vsize
condition|)
name|pci_paddr
operator|+=
name|vsize
operator|-
name|data
expr_stmt|;
comment|/* 	**	display values. 	*/
name|printf
argument_list|(
literal|" virtual=0x%x physical=0x%x\n"
argument_list|,
name|vaddr
argument_list|,
name|pci_paddr
argument_list|)
expr_stmt|;
comment|/* 	**	return them to the driver 	*/
operator|*
name|va
operator|=
name|vaddr
expr_stmt|;
operator|*
name|pa
operator|=
name|pci_paddr
expr_stmt|;
comment|/* 	**	set device address 	*/
name|pci_conf_write
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|,
name|pci_paddr
argument_list|)
expr_stmt|;
comment|/* 	**	map physical 	*/
while|while
condition|(
name|vsize
operator|>=
name|NBPG
condition|)
block|{
name|pmap_enter
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|vaddr
argument_list|,
name|pci_paddr
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|vaddr
operator|+=
name|NBPG
expr_stmt|;
name|pci_paddr
operator|+=
name|NBPG
expr_stmt|;
name|vsize
operator|-=
name|NBPG
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|vt
block|{
name|u_short
name|ident
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dt
block|{
name|u_long
name|ident
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|vt
name|VendorTable
index|[]
init|=
block|{
block|{
literal|0x1002
block|,
literal|"ATI TECHNOLOGIES INC"
block|}
block|,
block|{
literal|0x1011
block|,
literal|"DIGITAL EQUIPMENT COMPANY"
block|}
block|,
block|{
literal|0x101A
block|,
literal|"NCR"
block|}
block|,
block|{
literal|0x102B
block|,
literal|"MATROX"
block|}
block|,
block|{
literal|0x1045
block|,
literal|"OPTI"
block|}
block|,
block|{
literal|0x5333
block|,
literal|"S3 INC."
block|}
block|,
block|{
literal|0x8086
block|,
literal|"INTEL CORPORATION"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dt
name|DeviceTable
index|[]
init|=
block|{
block|{
literal|0x04848086
block|,
literal|" 82378IB pci-isa bridge"
block|}
block|,
block|{
literal|0x04838086
block|,
literal|" 82424ZX cache dram controller"
block|}
block|,
block|{
literal|0x04828086
block|,
literal|" 82375EB pci-eisa bridge"
block|}
block|,
block|{
literal|0x04A38086
block|,
literal|" 82434LX pci cache memory controller"
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|not_supported
parameter_list|(
name|pcici_t
name|tag
parameter_list|,
name|u_long
name|type
parameter_list|)
block|{
name|u_char
name|reg
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|struct
name|vt
modifier|*
name|vp
decl_stmt|;
name|struct
name|dt
modifier|*
name|dp
decl_stmt|;
comment|/* 	**	lookup the names. 	*/
for|for
control|(
name|vp
operator|=
name|VendorTable
init|;
name|vp
operator|->
name|ident
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|vp
operator|->
name|ident
operator|==
operator|(
name|type
operator|&
literal|0xffff
operator|)
condition|)
break|break;
for|for
control|(
name|dp
operator|=
name|DeviceTable
init|;
name|dp
operator|->
name|ident
condition|;
name|dp
operator|++
control|)
if|if
condition|(
name|dp
operator|->
name|ident
operator|==
name|type
condition|)
break|break;
comment|/* 	**	and display them. 	*/
if|if
condition|(
name|vp
operator|->
name|ident
condition|)
name|printf
argument_list|(
name|vp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"vendor=%x"
argument_list|,
name|type
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|ident
condition|)
name|printf
argument_list|(
name|dp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", device=%x"
argument_list|,
name|type
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" [not supported]\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|PCI_MAP_REG_START
init|;
name|reg
operator|<
name|PCI_MAP_REG_END
condition|;
name|reg
operator|+=
literal|4
control|)
block|{
name|data
operator|=
name|pci_conf_read
argument_list|(
name|tag
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
continue|continue;
switch|switch
condition|(
name|data
operator|&
literal|7
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|5
case|:
name|printf
argument_list|(
literal|"	map(%x): io(%x)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|3
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"	map(%x): mem32(%x)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"	map(%x): mem20(%x)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|"	map(%x): mem64(%x)\n"
argument_list|,
name|reg
argument_list|,
name|data
operator|&
operator|~
literal|7
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

