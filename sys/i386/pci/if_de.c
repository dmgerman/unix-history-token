begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994 Matt Thomas (thomas@lkg.dec.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $Id: if_de.c,v 1.6 1994/10/11 18:20:10 thomas Exp $  *  * $Log: if_de.c,v $  * Revision 1.6  1994/10/11  18:20:10  thomas  * new pci interface  * new 100mb/s prelim support  *  * Revision 1.5  1994/10/01  16:10:24  thomas  * Modifications for FreeBSD 2.0  *  * Revision 1.4  1994/09/09  21:10:05  thomas  * mbuf debugging code  * transmit fifo owkraroudns  *  * Revision 1.3  1994/08/16  20:40:56  thomas  * New README files (one per driver)  * Minor updates to drivers (DEPCA support and add pass to attach  * output)  *  * Revision 1.2  1994/08/15  20:41:22  thomas  * Support AUI and TP.  Autosense either.  * Revamp receive logic to use private kmem_alloc'ed 64K region.  * Some cleanup  *  * Revision 1.1  1994/08/12  21:01:18  thomas  * Initial revision  *  */
end_comment

begin_comment
comment|/*  * DEC DC21040 PCI Ethernet Controller  *  * Written by Matt Thomas  * BPF support code stolen directly from if_ec.c  *  *   This driver supports the DEC DE435 or any other PCI  *   board which support DC21040.  */
end_comment

begin_include
include|#
directive|include
file|<de.h>
end_include

begin_if
if|#
directive|if
name|NDE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<param.h>
end_include

begin_include
include|#
directive|include
file|<systm.h>
end_include

begin_include
include|#
directive|include
file|<mbuf.h>
end_include

begin_include
include|#
directive|include
file|<protosw.h>
end_include

begin_include
include|#
directive|include
file|<socket.h>
end_include

begin_include
include|#
directive|include
file|<ioctl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<malloc.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<bpfilter.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS
end_ifdef

begin_include
include|#
directive|include
file|<netns/ns.h>
end_include

begin_include
include|#
directive|include
file|<netns/ns_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<pci.h>
end_include

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<i386/pci/pcireg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<i386/pci/dc21040.h>
end_include

begin_comment
comment|/*  * This module supports the DEC DC21040 PCI Ethernet Controller.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
block|}
name|tulip_addrvec_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|tulip_desc_t
modifier|*
name|ri_first
decl_stmt|;
name|tulip_desc_t
modifier|*
name|ri_last
decl_stmt|;
name|tulip_desc_t
modifier|*
name|ri_nextin
decl_stmt|;
name|tulip_desc_t
modifier|*
name|ri_nextout
decl_stmt|;
name|int
name|ri_max
decl_stmt|;
name|int
name|ri_free
decl_stmt|;
block|}
name|tulip_ringinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_busmode
decl_stmt|;
comment|/* CSR0 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_txpoll
decl_stmt|;
comment|/* CSR1 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_rxpoll
decl_stmt|;
comment|/* CSR2 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_rxlist
decl_stmt|;
comment|/* CSR3 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_txlist
decl_stmt|;
comment|/* CSR4 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_status
decl_stmt|;
comment|/* CSR5 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_command
decl_stmt|;
comment|/* CSR6 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_intr
decl_stmt|;
comment|/* CSR7 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_missed_frame
decl_stmt|;
comment|/* CSR8 */
specifier|volatile
name|tulip_sint32_t
modifier|*
name|csr_enetrom
decl_stmt|;
comment|/* CSR9 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_reserved
decl_stmt|;
comment|/* CSR10 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_full_duplex
decl_stmt|;
comment|/* CSR11 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_sia_status
decl_stmt|;
comment|/* CSR12 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_sia_connectivity
decl_stmt|;
comment|/* CSR13 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_sia_tx_rx
decl_stmt|;
comment|/* CSR14 */
specifier|volatile
name|tulip_uint32_t
modifier|*
name|csr_sia_general
decl_stmt|;
comment|/* CSR15 */
block|}
name|tulip_regfile_t
typedef|;
end_typedef

begin_comment
comment|/*  * The DC21040 has a stupid restriction in that the receive  * buffers must be longword aligned.  But since Ethernet  * headers are not a multiple of longwords in size this forces  * the data to non-longword aligned.  Since IP requires the  * data to be longword aligned, we can to copy it after it has  * been DMA'ed in our memory.  *  * Since we have to copy it anyways, we might as well as allocate  * dedicated receive space for the input.  This allows to use a  * small receive buffer size and more ring entries to be able to  * better keep with a foold of tiny Ethernet packets.  *  * The receive space MUST ALWAYS be a multiple of the page size.  * And the number of receive descriptors multiplied by the size  * of the receive buffers must equal the recevive space.  This  * is that we can manipulate the page tables so that even if a  * packet wraps around the end of the receive space, we can   * treat it as virtually contiguous.  */
end_comment

begin_define
define|#
directive|define
name|TULIP_RXBUFSIZE
value|512
end_define

begin_define
define|#
directive|define
name|TULIP_RXDESCS
value|128
end_define

begin_define
define|#
directive|define
name|TULIP_RXSPACE
value|(TULIP_RXBUFSIZE * TULIP_RXDESCS)
end_define

begin_define
define|#
directive|define
name|TULIP_TXDESCS
value|128
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|arpcom
name|tulip_ac
decl_stmt|;
name|tulip_regfile_t
name|tulip_csrs
decl_stmt|;
name|vm_offset_t
name|tulip_rxspace
decl_stmt|;
name|unsigned
name|tulip_high_intrspins
decl_stmt|;
name|unsigned
name|tulip_flags
decl_stmt|;
define|#
directive|define
name|TULIP_WANTSETUP
value|0x01
define|#
directive|define
name|TULIP_WANTHASH
value|0x02
define|#
directive|define
name|TULIP_DOINGSETUP
value|0x04
define|#
directive|define
name|TULIP_ALTPHYS
value|0x08
comment|/* use AUI */
name|unsigned
name|char
name|tulip_rombuf
index|[
literal|32
index|]
decl_stmt|;
name|tulip_uint32_t
name|tulip_setupbuf
index|[
literal|192
operator|/
sizeof|sizeof
argument_list|(
name|tulip_uint32_t
argument_list|)
index|]
decl_stmt|;
name|tulip_uint32_t
name|tulip_setupdata
index|[
literal|192
operator|/
sizeof|sizeof
argument_list|(
name|tulip_uint32_t
argument_list|)
index|]
decl_stmt|;
name|tulip_uint32_t
name|tulip_intrmask
decl_stmt|;
name|tulip_uint32_t
name|tulip_cmdmode
decl_stmt|;
name|tulip_uint32_t
name|tulip_revinfo
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|caddr_t
name|tulip_bpf
decl_stmt|;
comment|/* BPF context */
endif|#
directive|endif
name|struct
name|ifqueue
name|tulip_txq
decl_stmt|;
name|tulip_ringinfo_t
name|tulip_rxinfo
decl_stmt|;
name|tulip_ringinfo_t
name|tulip_txinfo
decl_stmt|;
block|}
name|tulip_softc_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|IFF_ALTPHYS
end_ifndef

begin_define
define|#
directive|define
name|IFF_ALTPHYS
value|IFF_LINK0
end_define

begin_comment
comment|/* In case it isn't defined */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
enum|enum
block|{
name|TULIP_DC21040
block|,
name|TULIP_DC21140
block|}
name|tulip_chipid_t
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|char
modifier|*
name|tulip_chipdescs
index|[]
init|=
block|{
literal|"DC21040 [10Mb/s]"
block|,
literal|"DC21140 [100Mb/s]"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tulip_softc_t
modifier|*
name|tulips
index|[
name|NDE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|tulip_chipid_t
name|tulip_chipids
index|[
name|NDE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|tulip_intrs
index|[
name|NDE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|tulip_if
value|tulip_ac.ac_if
end_define

begin_define
define|#
directive|define
name|tulip_unit
value|tulip_ac.ac_if.if_unit
end_define

begin_define
define|#
directive|define
name|tulip_name
value|tulip_ac.ac_if.if_name
end_define

begin_define
define|#
directive|define
name|tulip_hwaddr
value|tulip_ac.ac_enaddr
end_define

begin_define
define|#
directive|define
name|TULIP_CRC32_POLY
value|0xEDB88320UL
end_define

begin_comment
comment|/* CRC-32 Poly -- Little Endian */
end_comment

begin_define
define|#
directive|define
name|TULIP_CHECK_RXCRC
value|0
end_define

begin_define
define|#
directive|define
name|TULIP_MAX_TXSEG
value|32
end_define

begin_define
define|#
directive|define
name|TULIP_ADDREQUAL
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|(((u_short *)a1)[0] == ((u_short *)a2)[0] \ 	 || ((u_short *)a1)[1] == ((u_short *)a2)[1] \ 	 || ((u_short *)a1)[2] == ((u_short *)a2)[2])
end_define

begin_define
define|#
directive|define
name|TULIP_ADDRBRDCST
parameter_list|(
name|a1
parameter_list|)
define|\
value|(((u_short *)a1)[0] == 0xFFFFU \ 	 || ((u_short *)a1)[1] == 0xFFFFU \ 	 || ((u_short *)a1)[2] == 0xFFFFU)
end_define

begin_function_decl
specifier|static
name|void
name|tulip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__FreeBSD__
operator|>
literal|1
end_if

begin_define
define|#
directive|define
name|TULIP_IFRESET_ARGS
value|int unit
end_define

begin_define
define|#
directive|define
name|TULIP_RESET
parameter_list|(
name|sc
parameter_list|)
value|tulip_reset((sc)->tulip_unit)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TULIP_IFRESET_ARGS
value|int unit, int uban
end_define

begin_define
define|#
directive|define
name|TULIP_RESET
parameter_list|(
name|sc
parameter_list|)
value|tulip_reset((sc)->tulip_unit, 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tulip_reset
parameter_list|(
name|TULIP_IFRESET_ARGS
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
name|tulips
index|[
name|unit
index|]
decl_stmt|;
name|tulip_ringinfo_t
modifier|*
name|ri
decl_stmt|;
name|tulip_desc_t
modifier|*
name|di
decl_stmt|;
name|vm_offset_t
name|vmoff
decl_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_busmode
operator|=
name|TULIP_BUSMODE_SWRESET
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* Wait 10 microsends (actually 50 PCI cycles but at  		   33MHz that comes to two microseconds but wait a 		   bit longer anyways) */
comment|/*      * Use the       */
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|TULIP_SIACONN_RESET
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"%s%d: enabling Thinwire/AUI port\n"
argument_list|,
name|sc
operator|->
name|tulip_if
operator|.
name|if_name
argument_list|,
name|sc
operator|->
name|tulip_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|TULIP_SIACONN_AUI
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
name|printf
argument_list|(
literal|"%s%d: enabling 10baseT/UTP port\n"
argument_list|,
name|sc
operator|->
name|tulip_if
operator|.
name|if_name
argument_list|,
name|sc
operator|->
name|tulip_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|TULIP_SIACONN_10BASET
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_ALTPHYS
expr_stmt|;
block|}
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txlist
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxlist
operator|=
name|vtophys
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rxinfo
operator|.
name|ri_first
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
literal|0
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_busmode
operator|=
literal|0x4800
expr_stmt|;
name|sc
operator|->
name|tulip_txq
operator|.
name|ifq_maxlen
operator|=
name|TULIP_TXDESCS
expr_stmt|;
comment|/*      * Free all the mbufs that were on the transmit ring.      */
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_txinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
control|)
name|di
operator|->
name|d_status
operator|=
literal|0
expr_stmt|;
comment|/*      * We need to collect all the mbufs were on the       * receive ring before we reinit it either to put      * them back on or to know if we have to allocate      * more.      */
name|ri
operator|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
expr_stmt|;
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|=
name|ri
operator|->
name|ri_max
expr_stmt|;
for|for
control|(
name|vmoff
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tulip_rxspace
argument_list|)
operator|,
name|di
operator|=
name|ri
operator|->
name|ri_first
init|;
name|di
operator|<
name|ri
operator|->
name|ri_last
condition|;
name|di
operator|++
operator|,
name|vmoff
operator|+=
name|TULIP_RXBUFSIZE
control|)
block|{
name|di
operator|->
name|d_status
operator||=
name|TULIP_DSTS_OWNER
expr_stmt|;
name|di
operator|->
name|d_length1
operator|=
name|TULIP_RXBUFSIZE
expr_stmt|;
name|di
operator|->
name|d_addr1
operator|=
name|vmoff
expr_stmt|;
name|di
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|di
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_intrmask
operator|=
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_RXINTR
operator||
name|TULIP_STS_TXINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator||
name|TULIP_STS_SYSERROR
operator||
name|TULIP_STS_TXSTOPPED
operator||
name|TULIP_STS_TXBABBLE
operator||
name|TULIP_STS_LINKFAIL
operator||
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
operator|(
name|TULIP_DOINGSETUP
operator||
name|TULIP_WANTSETUP
operator|)
expr_stmt|;
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_init
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
name|tulips
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_PROMISCUOUS
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&
name|IFF_ALLMULTI
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_ALLMULTI
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_TXRUN
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
name|tulip_start
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_THRSHLD160
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
name|sc
operator|->
name|tulip_intrmask
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|sc
operator|->
name|tulip_cmdmode
expr_stmt|;
block|}
else|else
block|{
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_struct
specifier|static
struct|struct
block|{
name|unsigned
name|notwhole
decl_stmt|;
name|unsigned
name|rxerror
decl_stmt|;
name|unsigned
name|nombufs
index|[
literal|2
index|]
decl_stmt|;
name|unsigned
name|rcvs
decl_stmt|;
if|#
directive|if
name|TULIP_CHECK_RXCRC
name|unsigned
name|badcrc
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|badsop
decl_stmt|;
block|}
name|tulip_rx
struct|;
end_struct

begin_if
if|#
directive|if
name|TULIP_CHECK_RXCRC
end_if

begin_function
specifier|static
name|unsigned
name|tulip_crc32
parameter_list|(
name|u_char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|int
name|crc
init|=
literal|0xFFFFFFFF
decl_stmt|;
specifier|static
name|unsigned
name|int
name|crctbl
index|[
literal|256
index|]
decl_stmt|;
name|int
name|idx
decl_stmt|;
specifier|static
name|int
name|done
decl_stmt|;
comment|/*      * initialize the multicast address CRC table      */
for|for
control|(
name|idx
operator|=
literal|0
init|;
operator|!
name|done
operator|&&
name|idx
operator|<
literal|256
condition|;
name|idx
operator|++
control|)
block|{
name|unsigned
name|int
name|tmp
init|=
name|idx
decl_stmt|;
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|tmp
operator|=
operator|(
name|tmp
operator|>>
literal|1
operator|)
operator|^
operator|(
name|tmp
operator|&
literal|1
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
comment|/* XOR */
name|crctbl
index|[
name|idx
index|]
operator|=
name|tmp
expr_stmt|;
block|}
name|done
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
name|crctbl
index|[
operator|*
name|addr
operator|++
index|]
operator|^
name|crctbl
index|[
name|crc
operator|&
literal|0xFF
index|]
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tulip_rx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_rxinfo
decl_stmt|;
for|for
control|(
init|;
condition|;
name|tulip_rx
operator|.
name|rcvs
operator|++
control|)
block|{
name|tulip_desc_t
modifier|*
name|eop
decl_stmt|;
name|int
name|total_len
decl_stmt|,
name|ndescs
decl_stmt|;
name|caddr_t
name|bufaddr
init|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|tulip_rxspace
decl_stmt|;
for|for
control|(
name|ndescs
operator|=
literal|1
operator|,
name|eop
operator|=
name|ri
operator|->
name|ri_nextin
init|;
condition|;
name|ndescs
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|eop
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
return|return;
if|if
condition|(
operator|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxFIRSTDESC
operator|)
operator|&&
name|eop
operator|!=
name|ri
operator|->
name|ri_nextin
condition|)
block|{
name|tulip_rx
operator|.
name|badsop
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_RxLASTDESC
condition|)
break|break;
if|if
condition|(
operator|++
name|eop
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|eop
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
name|bufaddr
operator|+=
name|TULIP_RXBUFSIZE
operator|*
operator|(
name|ri
operator|->
name|ri_nextin
operator|-
name|ri
operator|->
name|ri_first
operator|)
expr_stmt|;
name|total_len
operator|=
operator|(
operator|(
name|eop
operator|->
name|d_status
operator|>>
literal|16
operator|)
operator|&
literal|0x7FF
operator|)
operator|-
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|eop
operator|->
name|d_status
operator|&
name|TULIP_DSTS_ERRSUM
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|#
directive|if
name|TULIP_CHECK_RXCRC
name|unsigned
name|crc
init|=
name|tulip_crc32
argument_list|(
name|bufaddr
argument_list|,
name|total_len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|~
name|crc
operator|!=
operator|*
operator|(
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|bufaddr
index|[
name|total_len
index|]
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"de0: %d: bad rx crc: %08x [rx] != %08x\n"
argument_list|,
name|tulip_rx
operator|.
name|rcvs
argument_list|,
operator|*
operator|(
operator|(
name|unsigned
operator|*
operator|)
operator|&
name|bufaddr
index|[
name|total_len
index|]
operator|)
argument_list|,
operator|~
name|crc
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
name|eh
operator|=
operator|*
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|bufaddr
expr_stmt|;
name|eh
operator|.
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh
operator|.
name|ether_type
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|tulip_bpf
operator|!=
name|NULL
condition|)
block|{
name|bpf_tap
argument_list|(
name|sc
operator|->
name|tulip_bpf
argument_list|,
name|bufaddr
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|.
name|ether_type
operator|!=
name|ETHERTYPE_IP
operator|&&
name|eh
operator|.
name|ether_type
operator|!=
name|ETHERTYPE_ARP
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
operator|(
name|eh
operator|.
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
operator|!
name|TULIP_ADDREQUAL
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|,
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|)
condition|)
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TULIP_ADDREQUAL
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|,
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|)
operator|&&
operator|!
name|TULIP_ADDRBRDCST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
condition|)
block|{
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|total_len
operator|-=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_len
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tulip_rx
operator|.
name|nombufs
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
block|}
name|bcopy
argument_list|(
name|bufaddr
operator|+
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|total_len
expr_stmt|;
name|ether_input
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|,
operator|&
name|eh
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tulip_rx
operator|.
name|nombufs
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|tulip_rx
operator|.
name|rxerror
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
name|next
label|:
name|sc
operator|->
name|tulip_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
while|while
condition|(
name|ndescs
operator|--
operator|>
literal|0
condition|)
block|{
name|ri
operator|->
name|ri_nextin
operator|->
name|d_status
operator||=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_tx_intr
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|tulip_ringinfo_t
modifier|*
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|xmits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ri
operator|->
name|ri_free
operator|<
name|ri
operator|->
name|ri_max
condition|)
block|{
if|if
condition|(
operator|(
operator|(
specifier|volatile
name|tulip_desc_t
operator|*
operator|)
name|ri
operator|->
name|ri_nextin
operator|)
operator|->
name|d_status
operator|&
name|TULIP_DSTS_OWNER
condition|)
break|break;
if|if
condition|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
operator|&
name|TULIP_DFLAG_TxLASTSEG
condition|)
block|{
if|if
condition|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_flag
operator|&
name|TULIP_DFLAG_TxSETUPPKT
condition|)
block|{
comment|/* 		 * We've just finished processing a setup packet. 		 * Mark that we can finished it.  If there's not 		 * another pending, startup the TULIP receiver. 		 */
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_DOINGSETUP
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator||=
name|TULIP_STS_RXSTOPPED
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|sc
operator|->
name|tulip_cmdmode
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
name|sc
operator|->
name|tulip_intrmask
expr_stmt|;
block|}
block|}
else|else
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_collisions
operator|+=
operator|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_status
operator|&
name|TULIP_DSTS_TxCOLLMASK
operator|)
operator|>>
name|TULIP_DSTS_V_TxCOLLCNT
expr_stmt|;
if|if
condition|(
name|ri
operator|->
name|ri_nextin
operator|->
name|d_status
operator|&
name|TULIP_DSTS_ERRSUM
condition|)
name|sc
operator|->
name|tulip_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|xmits
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextin
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextin
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_if
operator|.
name|if_opackets
operator|+=
name|xmits
expr_stmt|;
return|return
name|xmits
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_txsegment
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|tulip_addrvec_t
modifier|*
name|avp
parameter_list|,
name|size_t
name|maxseg
parameter_list|)
block|{
name|int
name|segcnt
decl_stmt|;
for|for
control|(
name|segcnt
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|len
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|caddr_t
name|addr
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
decl_stmt|;
name|unsigned
name|clsize
init|=
name|CLBYTES
operator|-
operator|(
operator|(
operator|(
name|u_long
operator|)
name|addr
operator|)
operator|&
operator|(
name|CLBYTES
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|slen
init|=
name|min
argument_list|(
name|len
argument_list|,
name|clsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|segcnt
operator|<
name|maxseg
condition|)
block|{
name|avp
operator|->
name|addr
operator|=
name|vtophys
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|avp
operator|->
name|length
operator|=
name|slen
expr_stmt|;
block|}
name|len
operator|-=
name|slen
expr_stmt|;
name|addr
operator|+=
name|slen
expr_stmt|;
name|clsize
operator|=
name|CLBYTES
expr_stmt|;
name|avp
operator|++
expr_stmt|;
name|segcnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|segcnt
operator|>=
name|maxseg
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: tulip_txsegment: extremely fragmented packet dropped (%d segments)\n"
argument_list|,
name|sc
operator|->
name|tulip_name
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|,
name|segcnt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|avp
operator|->
name|addr
operator|=
literal|0
expr_stmt|;
name|avp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|segcnt
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
init|=
operator|&
name|ifp
operator|->
name|if_snd
decl_stmt|;
name|tulip_ringinfo_t
modifier|*
name|ri
init|=
operator|&
name|sc
operator|->
name|tulip_txinfo
decl_stmt|;
name|tulip_desc_t
modifier|*
name|sop
decl_stmt|,
modifier|*
name|eop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|tulip_addrvec_t
name|addrvec
index|[
name|TULIP_MAX_TXSEG
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|avp
decl_stmt|;
name|int
name|segcnt
decl_stmt|;
name|tulip_uint32_t
name|d_status
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTSETUP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_DOINGSETUP
operator|)
operator|||
name|ri
operator|->
name|ri_free
operator|==
literal|1
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
name|sc
operator|->
name|tulip_setupbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTSETUP
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_DOINGSETUP
expr_stmt|;
name|ri
operator|->
name|ri_free
operator|--
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
operator||
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxSETUPPKT
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_WANTHASH
condition|)
name|ri
operator|->
name|ri_nextout
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxHASHFILT
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length1
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr1
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|tulip_setupbuf
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_length2
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_addr2
operator|=
literal|0
expr_stmt|;
name|ri
operator|->
name|ri_nextout
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txpoll
operator|=
literal|1
expr_stmt|;
comment|/* 	     * Advance the ring for the next transmit packet. 	     */
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* 	 * First find out how many and which different pages 	 * the mbuf data occupies.  Then check to see if we 	 * have enough descriptor space in our transmit ring 	 * to actually send it. 	 */
name|segcnt
operator|=
name|tulip_txsegment
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|addrvec
argument_list|,
name|min
argument_list|(
name|ri
operator|->
name|ri_max
operator|-
literal|1
argument_list|,
name|TULIP_MAX_TXSEG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|segcnt
operator|<
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|struct mbuf *m0; 	    MGETHDR(m0, M_DONTWAIT, MT_DATA); 	    if (m0 != NULL) { 		if (m->m_pkthdr.len> MHLEN) { 		    MCLGET(m0, M_DONTWAIT); 		    if ((m0->m_flags& M_EXT) == 0) { 			m_freem(m); 			continue; 		    } 		} 		m_copydata(m, 0, mtod(m0, caddr_t), m->m_pkthdr.len); 		m0->m_pkthdr.len = m0->m_len = m->m_pkthdr.len; 		m_freem(m); 		IF_PREPEND(ifq, m0); 		continue; 	    } else {
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
if|#
directive|if
literal|0
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|ri
operator|->
name|ri_free
operator|-
literal|2
operator|<=
operator|(
name|segcnt
operator|+
literal|1
operator|)
operator|/
literal|2
condition|)
break|break;
name|ri
operator|->
name|ri_free
operator|-=
operator|(
name|segcnt
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Now we fill in our transmit descriptors.  This is 	 * a bit reminiscent of going on the Ark two by two 	 * since each descriptor for the TULIP can describe 	 * two buffers.  So we advance through the address 	 * vector two entries at a time to to fill each 	 * descriptor.  Clear the first and last segment bits 	 * in each descriptor (actually just clear everything 	 * but the end-of-ring or chain bits) to make sure 	 * we don't get messed up by previously sent packets. 	 */
name|sop
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|d_status
operator|=
literal|0
expr_stmt|;
name|avp
operator|=
name|addrvec
expr_stmt|;
do|do
block|{
name|eop
operator|=
name|ri
operator|->
name|ri_nextout
expr_stmt|;
name|eop
operator|->
name|d_flag
operator|&=
name|TULIP_DFLAG_ENDRING
operator||
name|TULIP_DFLAG_CHAIN
expr_stmt|;
name|eop
operator|->
name|d_status
operator|=
name|d_status
expr_stmt|;
name|eop
operator|->
name|d_addr1
operator|=
name|avp
operator|->
name|addr
expr_stmt|;
name|eop
operator|->
name|d_length1
operator|=
name|avp
operator|->
name|length
expr_stmt|;
name|avp
operator|++
expr_stmt|;
name|eop
operator|->
name|d_addr2
operator|=
name|avp
operator|->
name|addr
expr_stmt|;
name|eop
operator|->
name|d_length2
operator|=
name|avp
operator|->
name|length
expr_stmt|;
name|avp
operator|++
expr_stmt|;
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
if|if
condition|(
operator|++
name|ri
operator|->
name|ri_nextout
operator|==
name|ri
operator|->
name|ri_last
condition|)
name|ri
operator|->
name|ri_nextout
operator|=
name|ri
operator|->
name|ri_first
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|segcnt
operator|-=
literal|2
operator|)
operator|>
literal|0
condition|)
do|;
comment|/* 	 * The descriptors have been filled in.  Mark the first 	 * and last segments, indicate we want a transmit complete 	 * interrupt, give the descriptors to the TULIP, and tell 	 * it to transmit! 	 */
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|tulip_txq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|eop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxLASTSEG
operator||
name|TULIP_DFLAG_TxWANTINTR
expr_stmt|;
name|sop
operator|->
name|d_flag
operator||=
name|TULIP_DFLAG_TxFIRSTSEG
expr_stmt|;
name|sop
operator|->
name|d_status
operator|=
name|TULIP_DSTS_OWNER
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txpoll
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
name|IF_PREPEND
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_intr
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|tulip_uint32_t
name|csr
decl_stmt|;
name|unsigned
name|spins
init|=
literal|0
decl_stmt|;
name|tulip_intrs
index|[
name|sc
operator|->
name|tulip_unit
index|]
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_status
operator|)
operator|&
operator|(
name|TULIP_STS_NORMALINTR
operator||
name|TULIP_STS_ABNRMLINTR
operator|)
condition|)
block|{
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_status
operator|=
name|csr
operator|&
name|sc
operator|->
name|tulip_intrmask
expr_stmt|;
name|spins
operator|++
expr_stmt|;
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_SYSERROR
condition|)
block|{
if|if
condition|(
operator|(
name|csr
operator|&
name|TULIP_STS_ERRORMASK
operator|)
operator|==
name|TULIP_STS_ERR_PARITY
condition|)
block|{
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_init
argument_list|(
name|sc
operator|->
name|tulip_unit
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_RXINTR
condition|)
name|tulip_rx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_free
operator|<
name|sc
operator|->
name|tulip_txinfo
operator|.
name|ri_max
condition|)
block|{
name|tulip_tx_intr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_start
argument_list|(
operator|&
name|sc
operator|->
name|tulip_if
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csr
operator|&
name|TULIP_STS_ABNRMLINTR
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: abnormal interrupt: 0x%05x [0x%05x]\n"
argument_list|,
name|sc
operator|->
name|tulip_name
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|,
name|csr
argument_list|,
name|csr
operator|&
name|sc
operator|->
name|tulip_intrmask
argument_list|)
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|sc
operator|->
name|tulip_cmdmode
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spins
operator|>
name|sc
operator|->
name|tulip_high_intrspins
condition|)
name|sc
operator|->
name|tulip_high_intrspins
operator|=
name|spins
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  *  This is the standard method of reading the DEC Address ROMS.  */
end_comment

begin_function
specifier|static
name|int
name|tulip_read_macaddr
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|cksum
decl_stmt|,
name|rom_cksum
decl_stmt|,
name|idx
decl_stmt|;
name|tulip_sint32_t
name|csr
decl_stmt|;
name|unsigned
name|char
name|tmpbuf
index|[
literal|8
index|]
decl_stmt|;
specifier|static
name|u_char
name|testpat
index|[]
init|=
block|{
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|,
literal|0xFF
block|,
literal|0
block|,
literal|0x55
block|,
literal|0xAA
block|}
decl_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_enetrom
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|csr
operator|=
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_enetrom
operator|)
operator|<
literal|0
operator|&&
name|cnt
operator|<
literal|10000
condition|)
name|cnt
operator|++
expr_stmt|;
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
operator|=
name|csr
operator|&
literal|0xFF
expr_stmt|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|16
index|]
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|4
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|24
index|]
argument_list|,
name|testpat
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|3
return|;
name|tmpbuf
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|15
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|1
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|14
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|2
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|13
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|3
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|12
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|4
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|11
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|10
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|6
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|9
index|]
expr_stmt|;
name|tmpbuf
index|[
literal|7
index|]
operator|=
name|sc
operator|->
name|tulip_rombuf
index|[
literal|8
index|]
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|0
index|]
argument_list|,
name|tmpbuf
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|2
return|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_rombuf
argument_list|,
name|sc
operator|->
name|tulip_hwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|cksum
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|0
index|]
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|cksum
operator|>
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|cksum
operator|+=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_hwaddr
index|[
literal|4
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|>=
literal|65535
condition|)
name|cksum
operator|-=
literal|65535
expr_stmt|;
name|rom_cksum
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|&
name|sc
operator|->
name|tulip_rombuf
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|cksum
operator|!=
name|rom_cksum
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MULTICAST
end_ifdef

begin_function
specifier|static
name|unsigned
name|tulip_mchash
parameter_list|(
name|unsigned
name|char
modifier|*
name|mca
parameter_list|)
block|{
name|u_int
name|idx
decl_stmt|,
name|bit
decl_stmt|,
name|data
decl_stmt|,
name|crc
init|=
literal|0xFFFFFFFFUL
decl_stmt|;
ifdef|#
directive|ifdef
name|__alpha
for|for
control|(
name|data
operator|=
operator|*
operator|(
name|__unaligned
name|u_long
operator|*
operator|)
name|mca
operator|,
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|48
condition|;
name|bit
operator|++
operator|,
name|data
operator|>>=
literal|1
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|(
operator|(
name|crc
operator|^
name|data
operator|)
operator|&
literal|1
operator|)
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
else|#
directive|else
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|6
condition|;
name|idx
operator|++
control|)
for|for
control|(
name|data
operator|=
operator|*
name|mca
operator|++
operator|,
name|bit
operator|=
literal|0
init|;
name|bit
operator|<
literal|8
condition|;
name|bit
operator|++
operator|,
name|data
operator|>>=
literal|1
control|)
name|crc
operator|=
operator|(
name|crc
operator|>>
literal|1
operator|)
operator|^
operator|(
operator|(
operator|(
name|crc
operator|^
name|data
operator|)
operator|&
literal|1
operator|)
condition|?
name|TULIP_CRC32_POLY
else|:
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|crc
operator|&
literal|0x1FF
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|MULTICAST
end_endif

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_addr_filter
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|tulip_uint32_t
modifier|*
name|sp
init|=
name|sc
operator|->
name|tulip_setupdata
decl_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|struct
name|ether_multistep
name|step
decl_stmt|;
name|struct
name|ether_multi
modifier|*
name|enm
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|tulip_flags
operator|&=
operator|~
name|TULIP_WANTHASH
expr_stmt|;
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_WANTSETUP
expr_stmt|;
name|sc
operator|->
name|tulip_cmdmode
operator|&=
operator|~
name|TULIP_CMD_RXRUN
expr_stmt|;
name|sc
operator|->
name|tulip_intrmask
operator|&=
operator|~
name|TULIP_STS_RXSTOPPED
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
if|if
condition|(
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_multicnt
operator|>
literal|14
condition|)
block|{
name|unsigned
name|hash
decl_stmt|;
comment|/* 	 * If we have more than 14 multicasts, we have 	 * go into hash perfect mode (512 bit multicast 	 * hash and one perfect hardware). 	 */
name|bzero
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|tulip_setupdata
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|etherbroadcastaddr
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
expr_stmt|;
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
while|while
condition|(
name|enm
operator|!=
name|NULL
condition|)
block|{
name|hash
operator|=
name|tulip_mchash
argument_list|(
name|enm
operator|->
name|enm_addrlo
argument_list|)
expr_stmt|;
name|sp
index|[
name|hash
operator|>>
literal|4
index|]
operator||=
literal|1
operator|<<
operator|(
name|hash
operator|&
literal|0xF
operator|)
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|tulip_cmdmode
operator||=
name|TULIP_WANTHASH
expr_stmt|;
name|sp
index|[
literal|40
index|]
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|0
index|]
expr_stmt|;
name|sp
index|[
literal|41
index|]
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|1
index|]
expr_stmt|;
name|sp
index|[
literal|42
index|]
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* 	 * Else can get perfect filtering for 16 addresses. 	 */
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ETHER_FIRST_MULTI
argument_list|(
name|step
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|,
name|enm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|enm
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|enm
operator|->
name|enm_addrlo
operator|)
index|[
literal|2
index|]
expr_stmt|;
name|ETHER_NEXT_MULTI
argument_list|(
name|step
argument_list|,
name|enm
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If an IP address is enabled, turn on broadcast 	 */
if|if
condition|(
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_ipaddr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
literal|0xFFFF
expr_stmt|;
block|}
comment|/* 	 * Pad the rest with our hardware address 	 */
for|for
control|(
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|sp
operator|++
operator|=
operator|(
operator|(
name|u_short
operator|*
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
index|[
literal|2
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MULTICAST
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|tulip_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
init|=
name|tulips
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
operator|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
operator|)
operator|->
name|ac_ipaddr
operator|=
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|arpwhohas
argument_list|(
operator|(
expr|struct
name|arpcom
operator|*
operator|)
name|ifp
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ifa
argument_list|)
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|NS
comment|/* This magic copied from if_is.c; I don't use XNS, 		 * so I have no way of telling if this actually 		 * works or not. 		 */
case|case
name|AF_NS
case|:
block|{
name|struct
name|ns_addr
modifier|*
name|ina
init|=
operator|&
operator|(
name|IA_SNS
argument_list|(
name|ifa
argument_list|)
operator|->
name|sns_addr
operator|)
decl_stmt|;
if|if
condition|(
name|ns_nullhost
argument_list|(
operator|*
name|ina
argument_list|)
condition|)
block|{
name|ina
operator|->
name|x_host
operator|=
operator|*
operator|(
expr|union
name|ns_host
operator|*
operator|)
operator|(
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ina
operator|->
name|x_host
operator|.
name|c_host
argument_list|,
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* NS */
default|default:
block|{
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
case|case
name|SIOCSIFFLAGS
case|:
block|{
comment|/* 	     * Changing the connection forces a reset. 	     */
if|if
condition|(
name|sc
operator|->
name|tulip_flags
operator|&
name|TULIP_ALTPHYS
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
operator|)
operator|==
literal|0
condition|)
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_ALTPHYS
condition|)
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|MULTICAST
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
block|{
comment|/* 	     * Update multicast listeners 	     */
if|if
condition|(
name|cmd
operator|==
name|SIOCADDMULTI
condition|)
name|error
operator|=
name|ether_addmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ether_delmulti
argument_list|(
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
argument_list|,
operator|&
name|sc
operator|->
name|tulip_ac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENETRESET
condition|)
block|{
name|tulip_addr_filter
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* reset multicast filtering */
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
comment|/* MULTICAST */
default|default:
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_attach
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|tulip_if
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|ifp
operator|->
name|if_addrlist
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_NOTRAILERS
expr_stmt|;
ifdef|#
directive|ifdef
name|MULTICAST
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_MULTICAST
expr_stmt|;
endif|#
directive|endif
comment|/* MULTICAST */
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
literal|0
expr_stmt|;
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|TULIP_SIACONN_10BASET
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|240000
condition|;
name|cnt
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|&
name|TULIP_SIASTS_LINKFAIL
operator|)
operator|==
literal|0
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|&
name|TULIP_SIASTS_LINKFAIL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALTPHYS
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|tulip_flags
operator||=
name|TULIP_ALTPHYS
expr_stmt|;
block|}
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|tulip_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|tulip_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ether_output
expr_stmt|;
name|ifp
operator|->
name|if_reset
operator|=
name|tulip_reset
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|tulip_start
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|6
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|14
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: %s pass %d.%d ethernet address %s\n"
argument_list|,
name|sc
operator|->
name|tulip_name
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|,
name|tulip_chipdescs
index|[
name|tulip_chipids
index|[
name|sc
operator|->
name|tulip_unit
index|]
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|,
name|ether_sprintf
argument_list|(
name|sc
operator|->
name|tulip_hwaddr
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|tulip_bpf
argument_list|,
name|ifp
argument_list|,
name|DLT_EN10MB
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
while|while
condition|(
name|ifa
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
comment|/* 	 * Provide our ether address to the higher layers 	 */
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
literal|6
expr_stmt|;
name|sdl
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|tulip_ac
operator|.
name|ac_enaddr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_initcsrs
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|,
specifier|volatile
name|tulip_uint32_t
modifier|*
name|va_csrs
parameter_list|,
name|size_t
name|csr_size
parameter_list|)
block|{
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_busmode
operator|=
name|va_csrs
operator|+
literal|0
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txpoll
operator|=
name|va_csrs
operator|+
literal|1
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxpoll
operator|=
name|va_csrs
operator|+
literal|2
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_rxlist
operator|=
name|va_csrs
operator|+
literal|3
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_txlist
operator|=
name|va_csrs
operator|+
literal|4
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_status
operator|=
name|va_csrs
operator|+
literal|5
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_command
operator|=
name|va_csrs
operator|+
literal|6
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_intr
operator|=
name|va_csrs
operator|+
literal|7
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_missed_frame
operator|=
name|va_csrs
operator|+
literal|8
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_enetrom
operator|=
name|va_csrs
operator|+
literal|9
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_reserved
operator|=
name|va_csrs
operator|+
literal|10
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_full_duplex
operator|=
name|va_csrs
operator|+
literal|11
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_status
operator|=
name|va_csrs
operator|+
literal|12
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_connectivity
operator|=
name|va_csrs
operator|+
literal|13
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_tx_rx
operator|=
name|va_csrs
operator|+
literal|14
operator|*
name|csr_size
expr_stmt|;
name|sc
operator|->
name|tulip_csrs
operator|.
name|csr_sia_general
operator|=
name|va_csrs
operator|+
literal|15
operator|*
name|csr_size
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|tulip_initring
parameter_list|(
name|tulip_softc_t
modifier|*
name|sc
parameter_list|,
name|tulip_ringinfo_t
modifier|*
name|ri
parameter_list|,
name|tulip_desc_t
modifier|*
name|descs
parameter_list|,
name|int
name|ndescs
parameter_list|)
block|{
name|ri
operator|->
name|ri_max
operator|=
name|ndescs
expr_stmt|;
name|ri
operator|->
name|ri_first
operator|=
name|descs
expr_stmt|;
name|ri
operator|->
name|ri_last
operator|=
name|ri
operator|->
name|ri_first
operator|+
name|ri
operator|->
name|ri_max
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ri
operator|->
name|ri_first
argument_list|,
sizeof|sizeof
argument_list|(
name|ri
operator|->
name|ri_first
index|[
literal|0
index|]
argument_list|)
operator|*
name|ri
operator|->
name|ri_max
argument_list|)
expr_stmt|;
name|ri
operator|->
name|ri_last
index|[
operator|-
literal|1
index|]
operator|.
name|d_flag
operator|=
name|TULIP_DFLAG_ENDRING
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
name|NPCI
operator|>
literal|0
end_if

begin_comment
comment|/*  * This is the PCI configuration support.  Since the DC21040 is available  * on both EISA and PCI boards, one must be careful in how defines the  * DC21040 in the config file.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|tulip_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_long
name|tulip_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pci_driver
name|dedevice
init|=
block|{
name|tulip_pci_probe
block|,
name|tulip_pci_attach
block|,
operator|&
name|tulip_count
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PCI_CFID
value|0x00
end_define

begin_comment
comment|/* Configuration ID */
end_comment

begin_define
define|#
directive|define
name|PCI_CFCS
value|0x04
end_define

begin_comment
comment|/* Configurtion Command/Status */
end_comment

begin_define
define|#
directive|define
name|PCI_CFRV
value|0x08
end_define

begin_comment
comment|/* Configuration Revision */
end_comment

begin_define
define|#
directive|define
name|PCI_CFLT
value|0x0c
end_define

begin_comment
comment|/* Configuration Latency Timer */
end_comment

begin_define
define|#
directive|define
name|PCI_CBIO
value|0x10
end_define

begin_comment
comment|/* Configuration Base IO Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CBMA
value|0x14
end_define

begin_comment
comment|/* Configuration Base Memory Address */
end_comment

begin_define
define|#
directive|define
name|PCI_CFIT
value|0x3c
end_define

begin_comment
comment|/* Configuration Interrupt */
end_comment

begin_define
define|#
directive|define
name|PCI_CFDA
value|0x40
end_define

begin_comment
comment|/* Configuration Driver Area */
end_comment

begin_define
define|#
directive|define
name|TULIP_PCI_CSRSIZE
value|(8 / sizeof(tulip_uint32_t))
end_define

begin_function
specifier|static
name|char
modifier|*
name|tulip_pci_probe
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|pcidi_t
name|device_id
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NDE
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|tulips
index|[
name|idx
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|device_id
operator|==
literal|0x00021011ul
condition|)
block|{
name|tulip_chipids
index|[
name|idx
index|]
operator|=
name|TULIP_DC21040
expr_stmt|;
return|return
literal|"digital dc21040 ethernet"
return|;
block|}
if|if
condition|(
name|device_id
operator|==
literal|0x00091011ul
condition|)
block|{
name|tulip_chipids
index|[
name|idx
index|]
operator|=
name|TULIP_DC21140
expr_stmt|;
return|return
literal|"digital dc21140 fast ethernet"
return|;
block|}
return|return
name|NULL
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tulip_pci_attach
parameter_list|(
name|pcici_t
name|config_id
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|tulip_softc_t
modifier|*
name|sc
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|idx
decl_stmt|;
name|vm_offset_t
name|va_csrs
decl_stmt|,
name|pa_csrs
decl_stmt|;
name|tulip_desc_t
modifier|*
name|rxdescs
decl_stmt|,
modifier|*
name|txdescs
decl_stmt|;
name|sc
operator|=
operator|(
name|tulip_softc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|rxdescs
operator|=
operator|(
name|tulip_desc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
operator|*
name|TULIP_RXDESCS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxdescs
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|txdescs
operator|=
operator|(
name|tulip_desc_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tulip_desc_t
argument_list|)
operator|*
name|TULIP_TXDESCS
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|txdescs
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rxdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero out the softc*/
name|sc
operator|->
name|tulip_rxspace
operator|=
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|TULIP_RXSPACE
operator|+
name|NBPG
argument_list|)
expr_stmt|;
comment|/*      * We've allocated an extra page of receive space so we can double map      * the first page of the receive space into the page after the last page      * of the receive space.  This means that even if a receive wraps around      * the end of the receive space, it will still virtually contiguous and      * that greatly simplifies the recevie logic.      */
name|pmap_enter
argument_list|(
name|pmap_kernel
argument_list|()
argument_list|,
name|sc
operator|->
name|tulip_rxspace
operator|+
name|TULIP_RXSPACE
argument_list|,
name|vtophys
argument_list|(
name|sc
operator|->
name|tulip_rxspace
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|tulip_name
operator|=
literal|"de"
expr_stmt|;
name|retval
operator|=
name|pci_map_mem
argument_list|(
name|config_id
argument_list|,
name|PCI_CBMA
argument_list|,
operator|&
name|va_csrs
argument_list|,
operator|&
name|pa_csrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|retval
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|sc
operator|->
name|tulip_rxspace
argument_list|,
name|TULIP_RXSPACE
operator|+
name|NBPG
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|txdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rxdescs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
name|tulips
index|[
name|unit
index|]
operator|=
name|sc
expr_stmt|;
name|tulip_initcsrs
argument_list|(
name|sc
argument_list|,
operator|(
specifier|volatile
name|tulip_uint32_t
operator|*
operator|)
name|va_csrs
argument_list|,
name|TULIP_PCI_CSRSIZE
argument_list|)
expr_stmt|;
name|tulip_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_rxinfo
argument_list|,
name|rxdescs
argument_list|,
name|TULIP_RXDESCS
argument_list|)
expr_stmt|;
name|tulip_initring
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|tulip_txinfo
argument_list|,
name|txdescs
argument_list|,
name|TULIP_TXDESCS
argument_list|)
expr_stmt|;
name|sc
operator|->
name|tulip_revinfo
operator|=
name|pci_conf_read
argument_list|(
name|config_id
argument_list|,
name|PCI_CFRV
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|tulip_read_macaddr
argument_list|(
name|sc
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"de%d: can't read ENET ROM (why=%d) ("
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|,
name|retval
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
literal|32
condition|;
name|idx
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|sc
operator|->
name|tulip_rombuf
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d: %s %d.%d ethernet address %s\n"
argument_list|,
name|sc
operator|->
name|tulip_name
argument_list|,
name|sc
operator|->
name|tulip_unit
argument_list|,
name|tulip_chipdescs
index|[
name|tulip_chipids
index|[
name|sc
operator|->
name|tulip_unit
index|]
index|]
argument_list|,
operator|(
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0xF0
operator|)
operator|>>
literal|4
argument_list|,
name|sc
operator|->
name|tulip_revinfo
operator|&
literal|0x0F
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pci_map_int
argument_list|(
name|config_id
argument_list|,
name|tulip_intr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc
argument_list|,
operator|&
name|net_imask
argument_list|)
expr_stmt|;
name|TULIP_RESET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tulip_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPCI> 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NDE> 0 */
end_comment

end_unit

