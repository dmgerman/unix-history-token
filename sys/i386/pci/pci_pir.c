begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * Copyright (c) 2000, Michael Smith<msmith@freebsd.org>  * Copyright (c) 2000, BSDi  * Copyright (c) 2004, John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<machine/pci_cfgreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/pc/bios.h>
end_include

begin_define
define|#
directive|define
name|NUM_ISA_INTERRUPTS
value|16
end_define

begin_comment
comment|/*  * A link device.  Loosely based on the ACPI PCI link device.  This doesn't  * try to support priorities for different ISA interrupts.  */
end_comment

begin_struct
struct|struct
name|pci_link
block|{
name|TAILQ_ENTRY
argument_list|(
argument|pci_link
argument_list|)
name|pl_links
expr_stmt|;
name|uint8_t
name|pl_id
decl_stmt|;
name|uint8_t
name|pl_irq
decl_stmt|;
name|uint16_t
name|pl_irqmask
decl_stmt|;
name|int
name|pl_references
decl_stmt|;
name|int
name|pl_routed
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_link_lookup
block|{
name|struct
name|pci_link
modifier|*
modifier|*
name|pci_link_ptr
decl_stmt|;
name|int
name|bus
decl_stmt|;
name|int
name|device
decl_stmt|;
name|int
name|pin
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_dev_lookup
block|{
name|uint8_t
name|link
decl_stmt|;
name|int
name|bus
decl_stmt|;
name|int
name|device
decl_stmt|;
name|int
name|pin
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
name|pir_entry_handler
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|void
name|pci_print_irqmask
parameter_list|(
name|u_int16_t
name|irqs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_pir_biosroute
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|pin
parameter_list|,
name|int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_pir_choose_irq
parameter_list|(
name|struct
name|pci_link
modifier|*
name|pci_link
parameter_list|,
name|int
name|irqmask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_create_links
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_dump_links
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pci_link
modifier|*
name|pci_pir_find_link
parameter_list|(
name|uint8_t
name|link_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_find_link_handler
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_initial_irqs
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_parse
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|pci_pir_search_irq
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|pin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pci_pir_valid_irq
parameter_list|(
name|struct
name|pci_link
modifier|*
name|pci_link
parameter_list|,
name|int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pci_pir_walk_table
parameter_list|(
name|pir_entry_handler
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PIR
argument_list|,
literal|"$PIR"
argument_list|,
literal|"$PIR structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|PIR_table
modifier|*
name|pci_route_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
name|pir_device
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci_route_count
decl_stmt|,
name|pir_bios_irqs
decl_stmt|,
name|pir_parsed
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pci_link
argument_list|)
name|pci_links
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pir_interrupt_weight
index|[
name|NUM_ISA_INTERRUPTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_hw_pci
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX this likely should live in a header file */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_comment
comment|/* IRQs 3, 5, 7, 9, 10, 11, 12, 13 */
end_comment

begin_define
define|#
directive|define
name|PCI_IRQ_OVERRIDE_MASK
value|0x3e68
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IRQs 3, 4, 5, 6, 7, 9, 10, 11, 12, 14, 15 */
end_comment

begin_define
define|#
directive|define
name|PCI_IRQ_OVERRIDE_MASK
value|0xdef8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|uint32_t
name|pci_irq_override_mask
init|=
name|PCI_IRQ_OVERRIDE_MASK
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pci
argument_list|,
name|OID_AUTO
argument_list|,
name|irq_override_mask
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|pci_irq_override_mask
argument_list|,
name|PCI_IRQ_OVERRIDE_MASK
argument_list|,
literal|"Mask of allowed irqs to try to route when it has no good clue about\n"
literal|"which irqs it should use."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Look for the interrupt routing table.  *  * We use PCI BIOS's PIR table if it's available. $PIR is the standard way  * to do this.  Sadly, some machines are not standards conforming and have  * _PIR instead.  We shrug and cope by looking for both.  */
end_comment

begin_function
name|void
name|pci_pir_open
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|PIR_table
modifier|*
name|pt
decl_stmt|;
name|uint32_t
name|sigaddr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint8_t
name|ck
decl_stmt|,
modifier|*
name|cv
decl_stmt|;
ifdef|#
directive|ifdef
name|XEN
return|return;
else|#
directive|else
comment|/* Don't try if we've already found a table. */
if|if
condition|(
name|pci_route_table
operator|!=
name|NULL
condition|)
return|return;
comment|/* Look for $PIR and then _PIR. */
name|sigaddr
operator|=
name|bios_sigsearch
argument_list|(
literal|0
argument_list|,
literal|"$PIR"
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaddr
operator|==
literal|0
condition|)
name|sigaddr
operator|=
name|bios_sigsearch
argument_list|(
literal|0
argument_list|,
literal|"_PIR"
argument_list|,
literal|4
argument_list|,
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigaddr
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* If we found something, check the checksum and length. */
comment|/* XXX - Use pmap_mapdev()? */
name|pt
operator|=
operator|(
expr|struct
name|PIR_table
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|BIOS_PADDRTOVADDR
argument_list|(
name|sigaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|->
name|pt_header
operator|.
name|ph_length
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|PIR_header
argument_list|)
condition|)
return|return;
for|for
control|(
name|cv
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|pt
operator|,
name|ck
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|pt
operator|->
name|pt_header
operator|.
name|ph_length
operator|)
condition|;
name|i
operator|++
control|)
name|ck
operator|+=
name|cv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ck
operator|!=
literal|0
condition|)
return|return;
comment|/* Ok, we've got a valid table. */
name|pci_route_table
operator|=
name|pt
expr_stmt|;
name|pci_route_count
operator|=
operator|(
name|pt
operator|->
name|pt_header
operator|.
name|ph_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|PIR_header
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|PIR_entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the pci_link structure for a given link ID.  */
end_comment

begin_function
specifier|static
name|struct
name|pci_link
modifier|*
name|pci_pir_find_link
parameter_list|(
name|uint8_t
name|link_id
parameter_list|)
block|{
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pci_link
argument_list|,
argument|&pci_links
argument_list|,
argument|pl_links
argument_list|)
block|{
if|if
condition|(
name|pci_link
operator|->
name|pl_id
operator|==
name|link_id
condition|)
return|return
operator|(
name|pci_link
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the link device associated with a PCI device in the table.  */
end_comment

begin_function
specifier|static
name|void
name|pci_pir_find_link_handler
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_link_lookup
modifier|*
name|lookup
decl_stmt|;
name|lookup
operator|=
operator|(
expr|struct
name|pci_link_lookup
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|pe_bus
operator|==
name|lookup
operator|->
name|bus
operator|&&
name|entry
operator|->
name|pe_device
operator|==
name|lookup
operator|->
name|device
operator|&&
name|intpin
operator|-
name|entry
operator|->
name|pe_intpin
operator|==
name|lookup
operator|->
name|pin
condition|)
operator|*
name|lookup
operator|->
name|pci_link_ptr
operator|=
name|pci_pir_find_link
argument_list|(
name|intpin
operator|->
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a possible IRQ setting is valid.  */
end_comment

begin_function
specifier|static
name|int
name|pci_pir_valid_irq
parameter_list|(
name|struct
name|pci_link
modifier|*
name|pci_link
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pci_link
operator|->
name|pl_irqmask
operator|&
operator|(
literal|1
operator|<<
name|irq
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the $PIR executing the worker function for each valid intpin entry  * in the table.  The handler is passed a pointer to both the entry and  * the intpin in the entry.  */
end_comment

begin_function
specifier|static
name|void
name|pci_pir_walk_table
parameter_list|(
name|pir_entry_handler
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|PIR_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|PIR_intpin
modifier|*
name|intpin
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pin
decl_stmt|;
name|entry
operator|=
operator|&
name|pci_route_table
operator|->
name|pt_entry
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_route_count
condition|;
name|i
operator|++
operator|,
name|entry
operator|++
control|)
block|{
name|intpin
operator|=
operator|&
name|entry
operator|->
name|pe_intpin
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|4
condition|;
name|pin
operator|++
operator|,
name|intpin
operator|++
control|)
if|if
condition|(
name|intpin
operator|->
name|link
operator|!=
literal|0
condition|)
name|handler
argument_list|(
name|entry
argument_list|,
name|intpin
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pci_pir_create_links
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|pci_link
operator|=
name|pci_pir_find_link
argument_list|(
name|intpin
operator|->
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_link
operator|!=
name|NULL
condition|)
block|{
name|pci_link
operator|->
name|pl_references
operator|++
expr_stmt|;
if|if
condition|(
name|intpin
operator|->
name|irqs
operator|!=
name|pci_link
operator|->
name|pl_irqmask
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"$PIR: Entry %d.%d.INT%c has different mask for link %#x, merging\n"
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
operator|(
name|intpin
operator|-
name|entry
operator|->
name|pe_intpin
operator|)
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
name|pci_link
operator|->
name|pl_irqmask
operator|&=
name|intpin
operator|->
name|irqs
expr_stmt|;
block|}
block|}
else|else
block|{
name|pci_link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pci_link
argument_list|)
argument_list|,
name|M_PIR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pci_link
operator|->
name|pl_id
operator|=
name|intpin
operator|->
name|link
expr_stmt|;
name|pci_link
operator|->
name|pl_irqmask
operator|=
name|intpin
operator|->
name|irqs
expr_stmt|;
name|pci_link
operator|->
name|pl_irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
name|pci_link
operator|->
name|pl_references
operator|=
literal|1
expr_stmt|;
name|pci_link
operator|->
name|pl_routed
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pci_links
argument_list|,
name|pci_link
argument_list|,
name|pl_links
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Look to see if any of the function on the PCI device at bus/device have  * an interrupt routed to intpin 'pin' by the BIOS.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|pci_pir_search_irq
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|uint8_t
name|func
decl_stmt|,
name|maxfunc
decl_stmt|;
comment|/* See if we have a valid device at function 0. */
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|,
name|PCIR_HDRTYPE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|PCIM_HDRTYPE
operator|)
operator|>
name|PCI_MAXHDRTYPE
condition|)
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
if|if
condition|(
name|value
operator|&
name|PCIM_MFDEV
condition|)
name|maxfunc
operator|=
name|PCI_FUNCMAX
expr_stmt|;
else|else
name|maxfunc
operator|=
literal|0
expr_stmt|;
comment|/* Scan all possible functions at this device. */
for|for
control|(
name|func
operator|=
literal|0
init|;
name|func
operator|<=
name|maxfunc
condition|;
name|func
operator|++
control|)
block|{
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_DEVVENDOR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0xffffffff
condition|)
continue|continue;
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_INTPIN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * See if it uses the pin in question.  Note that the passed 		 * in pin uses 0 for A, .. 3 for D whereas the intpin 		 * register uses 0 for no interrupt, 1 for A, .. 4 for D. 		 */
if|if
condition|(
name|value
operator|!=
name|pin
operator|+
literal|1
condition|)
continue|continue;
name|value
operator|=
name|pci_cfgregread
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|PCIR_INTLINE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"$PIR: Found matching pin for %d.%d.INT%c at func %d: %d\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|func
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|PCI_INVALID_IRQ
condition|)
return|return
operator|(
name|value
operator|)
return|;
block|}
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to initialize IRQ based on this device's IRQ.  */
end_comment

begin_function
specifier|static
name|void
name|pci_pir_initial_irqs
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|uint8_t
name|irq
decl_stmt|,
name|pin
decl_stmt|;
name|pin
operator|=
name|intpin
operator|-
name|entry
operator|->
name|pe_intpin
expr_stmt|;
name|pci_link
operator|=
name|pci_pir_find_link
argument_list|(
name|intpin
operator|->
name|link
argument_list|)
expr_stmt|;
name|irq
operator|=
name|pci_pir_search_irq
argument_list|(
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|PCI_INVALID_IRQ
operator|||
name|irq
operator|==
name|pci_link
operator|->
name|pl_irq
condition|)
return|return;
comment|/* Don't trust any BIOS IRQs greater than 15. */
if|if
condition|(
name|irq
operator|>=
name|NUM_ISA_INTERRUPTS
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Ignoring invalid BIOS IRQ %d from %d.%d.INT%c for link %#x\n"
argument_list|,
name|irq
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we don't have an IRQ for this link yet, then we trust the 	 * BIOS, even if it seems invalid from the $PIR entries. 	 */
if|if
condition|(
name|pci_link
operator|->
name|pl_irq
operator|==
name|PCI_INVALID_IRQ
condition|)
block|{
if|if
condition|(
operator|!
name|pci_pir_valid_irq
argument_list|(
name|pci_link
argument_list|,
name|irq
argument_list|)
condition|)
name|printf
argument_list|(
literal|"$PIR: Using invalid BIOS IRQ %d from %d.%d.INT%c for link %#x\n"
argument_list|,
name|irq
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
name|pci_link
operator|->
name|pl_irq
operator|=
name|irq
expr_stmt|;
name|pci_link
operator|->
name|pl_routed
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* 	 * We have an IRQ and it doesn't match the current IRQ for this 	 * link.  If the new IRQ is invalid, then warn about it and ignore 	 * it.  If the old IRQ is invalid and the new IRQ is valid, then 	 * prefer the new IRQ instead.  If both IRQs are valid, then just 	 * use the first one.  Note that if we ever get into this situation 	 * we are having to guess which setting the BIOS actually routed. 	 * Perhaps we should just give up instead. 	 */
if|if
condition|(
operator|!
name|pci_pir_valid_irq
argument_list|(
name|pci_link
argument_list|,
name|irq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: BIOS IRQ %d for %d.%d.INT%c is not valid for link %#x\n"
argument_list|,
name|irq
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pci_pir_valid_irq
argument_list|(
name|pci_link
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Preferring valid BIOS IRQ %d from %d.%d.INT%c for link %#x to IRQ %d\n"
argument_list|,
name|irq
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
name|pci_link
operator|->
name|pl_irq
operator|=
name|irq
expr_stmt|;
name|pci_link
operator|->
name|pl_routed
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"$PIR: BIOS IRQ %d for %d.%d.INT%c does not match link %#x irq %d\n"
argument_list|,
name|irq
argument_list|,
name|entry
operator|->
name|pe_bus
argument_list|,
name|entry
operator|->
name|pe_device
argument_list|,
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse $PIR to enumerate link devices and attempt to determine their  * initial state.  This could perhaps be cleaner if we had drivers for the  * various interrupt routers as they could read the initial IRQ for each  * link.  */
end_comment

begin_function
specifier|static
name|void
name|pci_pir_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|tunable_buffer
index|[
literal|64
index|]
decl_stmt|;
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|int
name|i
decl_stmt|,
name|irq
decl_stmt|;
comment|/* Only parse once. */
if|if
condition|(
name|pir_parsed
condition|)
return|return;
name|pir_parsed
operator|=
literal|1
expr_stmt|;
comment|/* Enumerate link devices. */
name|TAILQ_INIT
argument_list|(
operator|&
name|pci_links
argument_list|)
expr_stmt|;
name|pci_pir_walk_table
argument_list|(
name|pci_pir_create_links
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Links after initial probe:\n"
argument_list|)
expr_stmt|;
name|pci_pir_dump_links
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Check to see if the BIOS has already routed any of the links by 	 * checking each device connected to each link to see if it has a 	 * valid IRQ. 	 */
name|pci_pir_walk_table
argument_list|(
name|pci_pir_initial_irqs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Links after initial IRQ discovery:\n"
argument_list|)
expr_stmt|;
name|pci_pir_dump_links
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Allow the user to override the IRQ for a given link device.  We 	 * allow invalid IRQs to be specified but warn about them.  An IRQ 	 * of 255 or 0 clears any preset IRQ. 	 */
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pci_link
argument_list|,
argument|&pci_links
argument_list|,
argument|pl_links
argument_list|)
block|{
name|snprintf
argument_list|(
name|tunable_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|tunable_buffer
argument_list|)
argument_list|,
literal|"hw.pci.link.%#x.irq"
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv_int
argument_list|(
name|tunable_buffer
argument_list|,
operator|&
name|irq
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|irq
operator|==
literal|0
condition|)
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
if|if
condition|(
name|irq
operator|!=
name|PCI_INVALID_IRQ
operator|&&
operator|!
name|pci_pir_valid_irq
argument_list|(
name|pci_link
argument_list|,
name|irq
argument_list|)
operator|&&
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"$PIR: Warning, IRQ %d for link %#x is not listed as valid\n"
argument_list|,
name|irq
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
name|pci_link
operator|->
name|pl_routed
operator|=
literal|0
expr_stmt|;
name|pci_link
operator|->
name|pl_irq
operator|=
name|irq
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|i
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Links after tunable overrides:\n"
argument_list|)
expr_stmt|;
name|pci_pir_dump_links
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * Build initial interrupt weights as well as bitmap of "known-good" 	 * IRQs that the BIOS has already used for PCI link devices. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|pci_link
argument_list|,
argument|&pci_links
argument_list|,
argument|pl_links
argument_list|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|pci_link
operator|->
name|pl_irq
argument_list|)
condition|)
continue|continue;
name|pir_bios_irqs
operator||=
literal|1
operator|<<
name|pci_link
operator|->
name|pl_irq
expr_stmt|;
name|pir_interrupt_weight
index|[
name|pci_link
operator|->
name|pl_irq
index|]
operator|+=
name|pci_link
operator|->
name|pl_references
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: IRQs used by BIOS: "
argument_list|)
expr_stmt|;
name|pci_print_irqmask
argument_list|(
name|pir_bios_irqs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$PIR: Interrupt Weights:\n[ "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ISA_INTERRUPTS
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ]\n[ "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ISA_INTERRUPTS
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %3d"
argument_list|,
name|pir_interrupt_weight
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Use the PCI BIOS to route an interrupt for a given device.  *  * Input:  * AX = PCIBIOS_ROUTE_INTERRUPT  * BH = bus  * BL = device [7:3] / function [2:0]  * CH = IRQ  * CL = Interrupt Pin (0x0A = A, ... 0x0D = D)  */
end_comment

begin_function
specifier|static
name|int
name|pci_pir_biosroute
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|pin
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|bios_regs
name|args
decl_stmt|;
name|args
operator|.
name|eax
operator|=
name|PCIBIOS_ROUTE_INTERRUPT
expr_stmt|;
name|args
operator|.
name|ebx
operator|=
operator|(
name|bus
operator|<<
literal|8
operator|)
operator||
operator|(
name|device
operator|<<
literal|3
operator|)
operator||
name|func
expr_stmt|;
name|args
operator|.
name|ecx
operator|=
operator|(
name|irq
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xa
operator|+
name|pin
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XEN
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|bios32
argument_list|(
operator|&
name|args
argument_list|,
name|PCIbios
operator|.
name|ventry
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Route a PCI interrupt using a link device from the $PIR.  */
end_comment

begin_function
name|int
name|pci_pir_route_interrupt
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|func
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|struct
name|pci_link_lookup
name|lookup
decl_stmt|;
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|int
name|error
decl_stmt|,
name|irq
decl_stmt|;
if|if
condition|(
name|pci_route_table
operator|==
name|NULL
condition|)
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
comment|/* Lookup link device for this PCI device/pin. */
name|pci_link
operator|=
name|NULL
expr_stmt|;
name|lookup
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|lookup
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|lookup
operator|.
name|pin
operator|=
name|pin
operator|-
literal|1
expr_stmt|;
name|lookup
operator|.
name|pci_link_ptr
operator|=
operator|&
name|pci_link
expr_stmt|;
name|pci_pir_walk_table
argument_list|(
name|pci_pir_find_link_handler
argument_list|,
operator|&
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_link
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: No matching entry for %d.%d.INT%c\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|-
literal|1
operator|+
literal|'A'
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
comment|/* 	 * Pick a new interrupt if we don't have one already.  We look 	 * for an interrupt from several different sets.  First, if 	 * this link only has one valid IRQ, use that.  Second, we 	 * check the set of PCI only interrupts from the $PIR.  Third, 	 * we check the set of known-good interrupts that the BIOS has 	 * already used.  Lastly, we check the "all possible valid 	 * IRQs" set. 	 */
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|pci_link
operator|->
name|pl_irq
argument_list|)
condition|)
block|{
if|if
condition|(
name|pci_link
operator|->
name|pl_irqmask
operator|!=
literal|0
operator|&&
name|powerof2
argument_list|(
name|pci_link
operator|->
name|pl_irqmask
argument_list|)
condition|)
name|irq
operator|=
name|ffs
argument_list|(
name|pci_link
operator|->
name|pl_irqmask
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|irq
operator|=
name|pci_pir_choose_irq
argument_list|(
name|pci_link
argument_list|,
name|pci_route_table
operator|->
name|pt_header
operator|.
name|ph_pci_irqs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
name|irq
operator|=
name|pci_pir_choose_irq
argument_list|(
name|pci_link
argument_list|,
name|pir_bios_irqs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
name|irq
operator|=
name|pci_pir_choose_irq
argument_list|(
name|pci_link
argument_list|,
name|pci_irq_override_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"$PIR: Failed to route interrupt for %d:%d INT%c\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|-
literal|1
operator|+
literal|'A'
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
name|pci_link
operator|->
name|pl_irq
operator|=
name|irq
expr_stmt|;
block|}
comment|/* Ask the BIOS to route this IRQ if we haven't done so already. */
if|if
condition|(
operator|!
name|pci_link
operator|->
name|pl_routed
condition|)
block|{
name|error
operator|=
name|pci_pir_biosroute
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|func
argument_list|,
name|pin
operator|-
literal|1
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
comment|/* Ignore errors when routing a unique interrupt. */
if|if
condition|(
name|error
operator|&&
operator|!
name|powerof2
argument_list|(
name|pci_link
operator|->
name|pl_irqmask
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: ROUTE_INTERRUPT failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
name|pci_link
operator|->
name|pl_routed
operator|=
literal|1
expr_stmt|;
comment|/* Ensure the interrupt is set to level/low trigger. */
name|KASSERT
argument_list|(
name|pir_device
operator|!=
name|NULL
argument_list|,
operator|(
literal|"missing pir device"
operator|)
argument_list|)
expr_stmt|;
name|BUS_CONFIG_INTR
argument_list|(
name|pir_device
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|,
name|INTR_TRIGGER_LEVEL
argument_list|,
name|INTR_POLARITY_LOW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"$PIR: %d:%d INT%c routed to irq %d\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|-
literal|1
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|pci_link
operator|->
name|pl_irq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to pick an interrupt for the specified link from the interrupts  * set in the mask.  */
end_comment

begin_function
specifier|static
name|int
name|pci_pir_choose_irq
parameter_list|(
name|struct
name|pci_link
modifier|*
name|pci_link
parameter_list|,
name|int
name|irqmask
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|irq
decl_stmt|,
name|realmask
decl_stmt|;
comment|/* XXX: Need to have a #define of known bad IRQs to also mask out? */
name|realmask
operator|=
name|pci_link
operator|->
name|pl_irqmask
operator|&
name|irqmask
expr_stmt|;
if|if
condition|(
name|realmask
operator|==
literal|0
condition|)
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
comment|/* Find IRQ with lowest weight. */
name|irq
operator|=
name|PCI_INVALID_IRQ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ISA_INTERRUPTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|realmask
operator|&
literal|1
operator|<<
name|i
operator|)
condition|)
continue|continue;
if|if
condition|(
name|irq
operator|==
name|PCI_INVALID_IRQ
operator|||
name|pir_interrupt_weight
index|[
name|i
index|]
operator|<
name|pir_interrupt_weight
index|[
name|irq
index|]
condition|)
name|irq
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|PCI_INTERRUPT_VALID
argument_list|(
name|irq
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"$PIR: Found IRQ %d for link %#x from "
argument_list|,
name|irq
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
name|pci_print_irqmask
argument_list|(
name|realmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pci_print_irqmask
parameter_list|(
name|u_int16_t
name|irqs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
if|if
condition|(
name|irqs
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
return|return;
block|}
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
operator|,
name|irqs
operator|>>=
literal|1
control|)
if|if
condition|(
name|irqs
operator|&
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
name|first
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Display link devices.  */
end_comment

begin_function
specifier|static
name|void
name|pci_pir_dump_links
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|printf
argument_list|(
literal|"Link  IRQ  Rtd  Ref  IRQs\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pci_link
argument_list|,
argument|&pci_links
argument_list|,
argument|pl_links
argument_list|)
block|{
name|printf
argument_list|(
literal|"%#4x  %3d   %c   %3d  "
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|,
name|pci_link
operator|->
name|pl_routed
condition|?
literal|'Y'
else|:
literal|'N'
argument_list|,
name|pci_link
operator|->
name|pl_references
argument_list|)
expr_stmt|;
name|pci_print_irqmask
argument_list|(
name|pci_link
operator|->
name|pl_irqmask
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * See if any interrupts for a given PCI bus are routed in the PIR.  Don't  * even bother looking if the BIOS doesn't support routing anyways.  If we  * are probing a PCI-PCI bridge, then require_parse will be true and we should  * only succeed if a host-PCI bridge has already attached and parsed the PIR.  */
end_comment

begin_function
name|int
name|pci_pir_probe
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|require_parse
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pci_route_table
operator|==
name|NULL
operator|||
operator|(
name|require_parse
operator|&&
operator|!
name|pir_parsed
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pci_route_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pci_route_table
operator|->
name|pt_entry
index|[
name|i
index|]
operator|.
name|pe_bus
operator|==
name|bus
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The driver for the new-bus psuedo device pir0 for the $PIR table.  */
end_comment

begin_function
specifier|static
name|int
name|pir_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"PCI Interrupt Routing Table: %d Entries"
argument_list|,
name|pci_route_count
argument_list|)
expr_stmt|;
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pir_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pci_pir_parse
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|pir_device
operator|==
name|NULL
argument_list|,
operator|(
literal|"Multiple pir devices"
operator|)
argument_list|)
expr_stmt|;
name|pir_device
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pir_resume_find_device
parameter_list|(
name|struct
name|PIR_entry
modifier|*
name|entry
parameter_list|,
name|struct
name|PIR_intpin
modifier|*
name|intpin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_dev_lookup
modifier|*
name|pd
decl_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|pci_dev_lookup
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|intpin
operator|->
name|link
operator|!=
name|pd
operator|->
name|link
operator|||
name|pd
operator|->
name|bus
operator|!=
operator|-
literal|1
condition|)
return|return;
name|pd
operator|->
name|bus
operator|=
name|entry
operator|->
name|pe_bus
expr_stmt|;
name|pd
operator|->
name|device
operator|=
name|entry
operator|->
name|pe_device
expr_stmt|;
name|pd
operator|->
name|pin
operator|=
name|intpin
operator|-
name|entry
operator|->
name|pe_intpin
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pir_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev_lookup
name|pd
decl_stmt|;
name|struct
name|pci_link
modifier|*
name|pci_link
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Ask the BIOS to re-route each link that was already routed. */
name|TAILQ_FOREACH
argument_list|(
argument|pci_link
argument_list|,
argument|&pci_links
argument_list|,
argument|pl_links
argument_list|)
block|{
if|if
condition|(
operator|!
name|PCI_INTERRUPT_VALID
argument_list|(
name|pci_link
operator|->
name|pl_irq
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|pci_link
operator|->
name|pl_routed
argument_list|,
operator|(
literal|"link %#x is routed but has invalid PCI IRQ"
operator|,
name|pci_link
operator|->
name|pl_id
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|pci_link
operator|->
name|pl_routed
condition|)
block|{
name|pd
operator|.
name|bus
operator|=
operator|-
literal|1
expr_stmt|;
name|pd
operator|.
name|link
operator|=
name|pci_link
operator|->
name|pl_id
expr_stmt|;
name|pci_pir_walk_table
argument_list|(
name|pir_resume_find_device
argument_list|,
operator|&
name|pd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|.
name|bus
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"did not find matching entry for link %#x in the $PIR table"
operator|,
name|pci_link
operator|->
name|pl_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using %d.%d.INT%c to route link %#x to IRQ %d\n"
argument_list|,
name|pd
operator|.
name|bus
argument_list|,
name|pd
operator|.
name|device
argument_list|,
name|pd
operator|.
name|pin
operator|+
literal|'A'
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
name|error
operator|=
name|pci_pir_biosroute
argument_list|(
name|pd
operator|.
name|bus
argument_list|,
name|pd
operator|.
name|device
argument_list|,
literal|0
argument_list|,
name|pd
operator|.
name|pin
argument_list|,
name|pci_link
operator|->
name|pl_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ROUTE_INTERRUPT on resume for link %#x failed.\n"
argument_list|,
name|pci_link
operator|->
name|pl_id
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pir_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|pir_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|pir_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|pir_resume
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|pir_driver
init|=
block|{
literal|"pir"
block|,
name|pir_methods
block|,
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|pir_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|pir
argument_list|,
name|legacy
argument_list|,
name|pir_driver
argument_list|,
name|pir_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

