begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Interface for the 93C46/26/06 serial eeprom parts.  *  * Copyright (c) 1995 Daniel M. Eischen  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    Daniel M. Eischen.  * 4. Modifications may be freely made to this file if the above conditions  *    are met.  *  *      $Id: 93cx6.c,v 1.4 1995/11/20 12:14:02 phk Exp $  */
end_comment

begin_comment
comment|/*  *   The instruction set of the 93C46/26/06 chips are as follows:  *  *               Start  OP  *     Function   Bit  Code  Address    Data     Description  *     -------------------------------------------------------------------  *     READ        1    10   A5 - A0             Reads data stored in memory,  *                                               starting at specified address  *     EWEN        1    00   11XXXX              Write enable must preceed  *                                               all programming modes  *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0  *     WRITE       1    01   A5 - A0   D15 - D0  Writes register  *     ERAL        1    00   10XXXX              Erase all registers  *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers  *     EWDS        1    00   00XXXX              Disables all programming  *                                               instructions  *     *Note: A value of X for address is a don't care condition.  *  *   The 93C46 has a four wire interface: clock, chip select, data in, and  *   data out.  In order to perform one of the above functions, you need  *   to enable the chip select for a clock period (typically a minimum of  *   1 usec, with the clock high and low a minimum of 750 and 250 nsec  *   respectively.  While the chip select remains high, you can clock in  *   the instructions (above) starting with the start bit, followed by the  *   OP code, Address, and Data (if needed).  For the READ instruction, the  *   requested 16-bit register contents is read from the data out line but  *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB  *   first).  The clock cycling from low to high initiates the next data  *   bit to be sent from the chip.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/scsi/93cx6.h>
end_include

begin_comment
comment|/*  * Right now, we only have to read the SEEPROM.  But we make it easier to  * add other 93Cx6 functions.  */
end_comment

begin_struct
specifier|static
struct|struct
name|seeprom_cmd
block|{
name|unsigned
name|char
name|len
decl_stmt|;
name|unsigned
name|char
name|bits
index|[
literal|3
index|]
decl_stmt|;
block|}
name|seeprom_read
init|=
block|{
literal|3
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Wait for the SEERDY to go high; about 800 ns.  */
end_comment

begin_define
define|#
directive|define
name|CLOCK_PULSE
parameter_list|(
name|p
parameter_list|,
name|rdy
parameter_list|)
define|\
value|while ((inb(p)& rdy) == 0) {		\ 		;
comment|/* Do nothing */
value|\ 	}
end_define

begin_comment
comment|/*  * Read the serial EEPROM and returns 1 if successful and 0 if  * not successful.  */
end_comment

begin_function
name|int
name|read_seeprom
parameter_list|(
name|u_long
name|offset
parameter_list|,
name|u_short
modifier|*
name|buf
parameter_list|,
name|u_int
name|start_addr
parameter_list|,
name|int
name|count
parameter_list|,
name|u_short
name|CS
parameter_list|,
comment|/* chip select */
name|u_short
name|CK
parameter_list|,
comment|/* clock */
name|u_short
name|DO
parameter_list|,
comment|/* data out */
name|u_short
name|DI
parameter_list|,
comment|/* data in */
name|u_short
name|RDY
parameter_list|,
comment|/* ready */
name|u_short
name|MS
comment|/* mode select */
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|temp
decl_stmt|;
comment|/* 	 * Read the requested registers of the seeprom.  The loop 	 * will range from 0 to count-1. 	 */
for|for
control|(
name|k
operator|=
name|start_addr
init|;
name|k
operator|<
name|count
operator|+
name|start_addr
condition|;
name|k
operator|=
name|k
operator|+
literal|1
control|)
block|{
comment|/* Send chip select for one clock cycle. */
name|outb
argument_list|(
name|offset
argument_list|,
name|MS
operator||
name|CK
operator||
name|CS
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
comment|/* 		 * Now we're ready to send the read command followed by the 		 * address of the 16-bit register we want to read. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seeprom_read
operator|.
name|len
condition|;
name|i
operator|=
name|i
operator|+
literal|1
control|)
block|{
if|if
condition|(
name|seeprom_read
operator|.
name|bits
index|[
name|i
index|]
condition|)
name|temp
operator|=
name|MS
operator||
name|CS
operator||
name|DO
expr_stmt|;
else|else
name|temp
operator|=
name|MS
operator||
name|CS
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|^
name|CK
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
block|}
comment|/* Send the 6 bit address (MSB first, LSB last). */
for|for
control|(
name|i
operator|=
literal|5
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|i
operator|-
literal|1
control|)
block|{
comment|/* k is the address, i is the bit */
if|if
condition|(
name|k
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|temp
operator|=
name|MS
operator||
name|CS
operator||
name|DO
expr_stmt|;
else|else
name|temp
operator|=
name|MS
operator||
name|CS
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|^
name|CK
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now read the 16 bit register.  An initial 0 precedes the 		 * register contents which begins with bit 15 (MSB) and ends 		 * with bit 0 (LSB).  The initial 0 will be shifted off the 		 * top of our word as we let the loop run from 0 to 16. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|16
condition|;
name|i
operator|=
name|i
operator|+
literal|1
control|)
block|{
name|temp
operator|=
name|MS
operator||
name|CS
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
name|temp
operator|=
name|temp
operator|^
name|CK
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|offset
argument_list|)
operator|&
name|DI
condition|)
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|=
operator|(
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|<<
literal|1
operator|)
operator||
literal|0x1
expr_stmt|;
else|else
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|=
operator|(
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the chip select for the next command cycle. */
name|outb
argument_list|(
name|offset
argument_list|,
name|MS
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|MS
operator||
name|CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|MS
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|offset
argument_list|,
name|RDY
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("Serial EEPROM:"); 	for (k = 0; k< count; k = k + 1) { 		if (((k % 8) == 0)&& (k != 0)) 		{ 			printf ("\n              "); 		} 		printf (" 0x%x", buf[k]); 	} 	printf ("\n");
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

