begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Interface for the 93C66/56/46/26/06 serial eeprom parts.  *  * Copyright (c) 1995, 1996 Daniel M. Eischen  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    Daniel M. Eischen.  * 4. Modifications may be freely made to this file if the above conditions  *    are met.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  *   The instruction set of the 93C66/56/46/26/06 chips are as follows:  *  *               Start  OP	    *  *     Function   Bit  Code  Address**  Data     Description  *     -------------------------------------------------------------------  *     READ        1    10   A5 - A0             Reads data stored in memory,  *                                               starting at specified address  *     EWEN        1    00   11XXXX              Write enable must preceed  *                                               all programming modes  *     ERASE       1    11   A5 - A0             Erase register A5A4A3A2A1A0  *     WRITE       1    01   A5 - A0   D15 - D0  Writes register  *     ERAL        1    00   10XXXX              Erase all registers  *     WRAL        1    00   01XXXX    D15 - D0  Writes to all registers  *     EWDS        1    00   00XXXX              Disables all programming  *                                               instructions  *     *Note: A value of X for address is a don't care condition.  *    **Note: There are 8 address bits for the 93C56/66 chips unlike  *	      the 93C46/26/06 chips which have 6 address bits.  *  *   The 93C46 has a four wire interface: clock, chip select, data in, and  *   data out.  In order to perform one of the above functions, you need  *   to enable the chip select for a clock period (typically a minimum of  *   1 usec, with the clock high and low a minimum of 750 and 250 nsec  *   respectively).  While the chip select remains high, you can clock in  *   the instructions (above) starting with the start bit, followed by the  *   OP code, Address, and Data (if needed).  For the READ instruction, the  *   requested 16-bit register contents is read from the data out line but  *   is preceded by an initial zero (leading 0, followed by 16-bits, MSB  *   first).  The clock cycling from low to high initiates the next data  *   bit to be sent from the chip.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<i386/scsi/93cx6.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/smc93cx6var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Right now, we only have to read the SEEPROM.  But we make it easier to  * add other 93Cx6 functions.  */
end_comment

begin_struct
specifier|static
struct|struct
name|seeprom_cmd
block|{
name|unsigned
name|char
name|len
decl_stmt|;
name|unsigned
name|char
name|bits
index|[
literal|3
index|]
decl_stmt|;
block|}
name|seeprom_read
init|=
block|{
literal|3
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Wait for the SEERDY to go high; about 800 ns.  */
end_comment

begin_define
define|#
directive|define
name|CLOCK_PULSE
parameter_list|(
name|sd
parameter_list|,
name|rdy
parameter_list|)
define|\
value|while ((SEEPROM_INB(sd)& rdy) == 0) {	\ 		;
comment|/* Do nothing */
value|\ 	}
end_define

begin_comment
comment|/*  * Read the serial EEPROM and returns 1 if successful and 0 if  * not successful.  */
end_comment

begin_function
name|int
name|read_seeprom
parameter_list|(
name|sd
parameter_list|,
name|buf
parameter_list|,
name|start_addr
parameter_list|,
name|count
parameter_list|)
name|struct
name|seeprom_descriptor
modifier|*
name|sd
decl_stmt|;
name|u_int16_t
modifier|*
name|buf
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|u_int
name|start_addr
decl_stmt|;
name|u_int
name|count
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|bus_io_size_t
name|start_addr
decl_stmt|;
name|bus_io_size_t
name|count
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|u_int
name|k
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|v
decl_stmt|;
name|u_int8_t
name|temp
decl_stmt|;
comment|/* 	 * Read the requested registers of the seeprom.  The loop 	 * will range from 0 to count-1. 	 */
for|for
control|(
name|k
operator|=
name|start_addr
init|;
name|k
operator|<
name|count
operator|+
name|start_addr
condition|;
name|k
operator|++
control|)
block|{
comment|/* Send chip select for one clock cycle. */
name|temp
operator|=
name|sd
operator|->
name|sd_MS
operator|^
name|sd
operator|->
name|sd_CS
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
comment|/* 		 * Now we're ready to send the read command followed by the 		 * address of the 16-bit register we want to read. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seeprom_read
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|seeprom_read
operator|.
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
if|if
condition|(
name|seeprom_read
operator|.
name|bits
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
block|}
comment|/* Send the 6 or 8 bit address (MSB first, LSB last). */
for|for
control|(
name|i
operator|=
operator|(
name|sd
operator|->
name|sd_chip
operator|-
literal|1
operator|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|k
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|temp
operator|^=
name|sd
operator|->
name|sd_DO
expr_stmt|;
block|}
comment|/* 		 * Now read the 16 bit register.  An initial 0 precedes the 		 * register contents which begins with bit 15 (MSB) and ends 		 * with bit 0 (LSB).  The initial 0 will be shifted off the 		 * top of our word as we let the loop run from 0 to 16. 		 */
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|v
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|SEEPROM_INB
argument_list|(
name|sd
argument_list|)
operator|&
name|sd
operator|->
name|sd_DI
condition|)
name|v
operator||=
literal|1
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|k
operator|-
name|start_addr
index|]
operator|=
name|v
expr_stmt|;
comment|/* Reset the chip select for the next command cycle. */
name|temp
operator|=
name|sd
operator|->
name|sd_MS
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
operator|^
name|sd
operator|->
name|sd_CK
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
name|SEEPROM_OUTB
argument_list|(
name|sd
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|CLOCK_PULSE
argument_list|(
name|sd
argument_list|,
name|sd
operator|->
name|sd_RDY
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf ("Serial EEPROM:"); 	for (k = 0; k< count; k = k + 1) { 		if (((k % 8) == 0)&& (k != 0)) 		{ 			printf ("\n              "); 		} 		printf (" 0x%x", buf[k]); 	} 	printf ("\n");
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

