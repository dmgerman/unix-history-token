begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the Advanced Systems Inc. SCSI controllers  * Product specific probe and attach routines can be found in:  *   * i386/isa/adv_isa.c	ABP5140, ABP542, ABP5150, ABP842, ABP852  *  * Copyright (c) 1996 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: advansys.c,v 1.1.1.1 1996/10/07 02:07:07 gibbs Exp $  */
end_comment

begin_comment
comment|/*  * Ported from:  * advansys.c - Linux Host Driver for AdvanSys SCSI Adapters  *       * Copyright (c) 1995-1996 Advanced System Products, Inc.  * All Rights Reserved.  *     * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that redistributions of source  * code retain the above copyright notice and this comment without  * modification.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/scsi/advansys.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|adv_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|advminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|adv_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_qdone
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|adv_done
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|adv
operator|,
expr|struct
name|adv_q_done_info
operator|*
name|qdonep
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adv_poll
name|__P
argument_list|(
operator|(
expr|struct
name|adv_softc
operator|*
name|ahc
operator|,
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|adv_softc
modifier|*
name|advsoftcs
index|[
name|NADV
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX Config should handle this */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|adv_switch
init|=
block|{
name|adv_scsi_cmd
block|,
name|advminphys
block|,
name|NULL
block|,
name|NULL
block|,
literal|"adv"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|adv_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_scsi_q
name|scsiq
decl_stmt|;
name|struct
name|adv_sg_head
name|sghead
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"adv_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|scsibus
operator|->
name|adpt_link
operator|.
name|adpt_softc
expr_stmt|;
comment|/* 	 * Build up the request 	 */
name|scsiq
operator|.
name|q1
operator|.
name|cntl
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|sg_queue_cnt
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|q_no
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|target_id
operator|=
name|ADV_TID_TO_TARGET_ID
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|target_lun
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|sense_addr
operator|=
operator|(
name|u_int32_t
operator|)
name|vtophys
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|sense_len
operator|=
sizeof|sizeof
argument_list|(
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_cnt
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_addr
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|user_def
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|xs_ptr
operator|=
operator|(
name|u_int32_t
operator|)
name|xs
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|target_ix
operator|=
name|ADV_TIDLUN_TO_IX
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|flag
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|cdb_len
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|tag_code
operator|=
name|xs
operator|->
name|tag_type
expr_stmt|;
name|scsiq
operator|.
name|q2
operator|.
name|vm_id
operator|=
literal|0
expr_stmt|;
name|scsiq
operator|.
name|sg_head
operator|=
name|NULL
expr_stmt|;
name|scsiq
operator|.
name|cdbptr
operator|=
operator|&
name|xs
operator|->
name|cmd
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* 		 * Determin the number of segments needed for this 		 * transfer.  We should only use SG if we need more 		 * than one. 		 */
name|int
name|seg
decl_stmt|;
name|u_int32_t
name|datalen
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|nextpaddr
decl_stmt|;
name|struct
name|adv_sg_entry
modifier|*
name|sg
decl_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|sg
operator|=
operator|&
name|sghead
operator|.
name|sg_list
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|seg
operator|<
name|ADV_MAX_SG_LIST
operator|)
condition|)
block|{
comment|/* put in the base address and length */
name|sg
operator|->
name|addr
operator|=
name|paddr
expr_stmt|;
name|sg
operator|->
name|bytes
operator|=
literal|0
expr_stmt|;
comment|/* do it at least once */
name|nextpaddr
operator|=
name|paddr
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|paddr
operator|==
name|nextpaddr
operator|)
condition|)
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* 				 * This page is contiguous (physically) 				 * with the the last, just extend the 				 * length 				 */
comment|/* how far to the end of the page */
name|nextpaddr
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* 				 * Compute the maximum size 				 */
name|size
operator|=
name|nextpaddr
operator|-
name|paddr
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
name|sg
operator|->
name|bytes
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * next page isn't contiguous, finish the seg 			 */
name|seg
operator|++
expr_stmt|;
name|sg
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|seg
operator|>
literal|1
condition|)
block|{
name|scsiq
operator|.
name|q1
operator|.
name|cntl
operator||=
name|QC_SG_HEAD
expr_stmt|;
name|scsiq
operator|.
name|sg_head
operator|=
operator|&
name|sghead
expr_stmt|;
name|sghead
operator|.
name|entry_cnt
operator|=
name|sghead
operator|.
name|entry_to_copy
operator|=
name|seg
expr_stmt|;
name|sghead
operator|.
name|res
operator|=
literal|0
expr_stmt|;
block|}
name|scsiq
operator|.
name|q1
operator|.
name|data_addr
operator|=
name|sghead
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|addr
expr_stmt|;
name|scsiq
operator|.
name|q1
operator|.
name|data_cnt
operator|=
name|sghead
operator|.
name|sg_list
index|[
literal|0
index|]
operator|.
name|bytes
expr_stmt|;
block|}
if|if
condition|(
name|adv_execute_scsi_queue
argument_list|(
name|adv
argument_list|,
operator|&
name|scsiq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_QUEUE_RESOURCE_SHORTAGE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_POLL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we can't use interrupts, poll for completion 		 */
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|adv_poll
argument_list|(
name|adv
argument_list|,
name|xs
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|adv_timeout
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|advminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|ADV_MAX_SG_LIST
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
condition|)
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|ADV_MAX_SG_LIST
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adv_timeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"adv: Ooops. Had a timeout\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|adv_softc
modifier|*
name|adv_alloc
parameter_list|(
name|unit
parameter_list|,
name|iobase
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NADV
condition|)
block|{
name|printf
argument_list|(
literal|"adv: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|advsoftcs
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|adv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|adv_softc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|adv
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|adv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|adv_softc
argument_list|)
argument_list|)
expr_stmt|;
name|advsoftcs
index|[
name|unit
index|]
operator|=
name|adv
expr_stmt|;
name|adv
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|adv
operator|->
name|iobase
operator|=
name|iobase
expr_stmt|;
comment|/* Set reasonable defaults incase we can't read the EEPROM */
name|adv
operator|->
name|max_openings
operator|=
name|ADV_DEF_MAX_TOTAL_QNG
expr_stmt|;
name|adv
operator|->
name|start_motor
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|disc_enable
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|cmd_qng_enabled
operator|=
name|TARGET_BIT_VECTOR_SET
expr_stmt|;
name|adv
operator|->
name|scsi_id
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ADV_MAX_TID
condition|;
name|i
operator|++
control|)
name|adv
operator|->
name|sdtr_data
index|[
name|i
index|]
operator|=
name|ADV_DEF_SDTR_OFFSET
operator||
operator|(
name|ADV_DEF_SDTR_INDEX
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
operator|(
name|adv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_free
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
if|if
condition|(
name|adv
operator|->
name|sense_buffers
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|adv
operator|->
name|sense_buffers
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|adv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adv_init
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|struct
name|adv_eeprom_config
name|eeprom_config
decl_stmt|;
name|int
name|checksum
decl_stmt|,
name|i
decl_stmt|;
name|u_int16_t
name|config_lsw
decl_stmt|;
name|u_int16_t
name|config_msw
decl_stmt|;
name|adv_get_board_type
argument_list|(
name|adv
argument_list|)
expr_stmt|;
comment|/* 	 * Stop script execution. 	 */
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADV_HALTCODE_W
argument_list|,
literal|0x00FE
argument_list|)
expr_stmt|;
name|adv_stop_execution
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|adv_reset_chip_and_scsi_bus
argument_list|(
name|adv
argument_list|)
expr_stmt|;
comment|/* 	 * The generic SCSI code does a minimum delay for us 	 * already. 	 */
comment|/* DELAY(3 * 1000 * 1000);*/
comment|/* 3 Second Delay */
if|if
condition|(
name|adv_is_chip_halted
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to halt adapter. Initialization"
literal|"failed\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|,
name|ADV_MCODE_START_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_REG_PROG_COUNTER
argument_list|)
operator|!=
name|ADV_MCODE_START_ADDR
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to set program counter. Initialization"
literal|"failed\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|config_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
name|config_msw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX Move to PCI probe code */
block|if (adv->type& ADV_PCI) {
if|#
directive|if
name|CC_DISABLE_PCI_PARITY_INT
block|config_msw&= 0xFFC0; 		ADV_OUTW(adv, ADV_CONFIG_MSW, config_msw);
endif|#
directive|endif
block|if (asc_dvc->cfg->pci_device_id == ASC_PCI_DEVICE_ID_REV_A) { 			asc_dvc->bug_fix_cntl |= ASC_BUG_FIX_ADD_ONE_BYTE; 		} 	}
endif|#
directive|endif
if|if
condition|(
operator|(
name|config_msw
operator|&
name|ADV_CFG_MSW_CLR_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|config_msw
operator|&=
operator|(
operator|~
operator|(
name|ADV_CFG_MSW_CLR_MASK
operator|)
operator|)
expr_stmt|;
comment|/* 		 * XXX The Linux code flags this as an error, 		 * but what should we report to the user??? 		 * It seems that clearing the config register 		 * makes this error recoverable. 		 */
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|,
name|config_msw
argument_list|)
expr_stmt|;
block|}
comment|/* Suck in the configuration from the EEProm */
name|checksum
operator|=
name|adv_get_eeprom_config
argument_list|(
name|adv
argument_list|,
operator|&
name|eeprom_config
argument_list|)
expr_stmt|;
name|eeprom_config
operator|.
name|cfg_msw
operator|&=
operator|(
operator|~
operator|(
name|ADV_CFG_MSW_CLR_MASK
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|&
name|ADV_CSW_AUTO_CONFIG
condition|)
block|{
comment|/* 		 * XXX The Linux code sets a warning level for this 		 * condition, yet nothing of meaning is printed to 		 * the user.  What does this mean??? 		 */
if|if
condition|(
name|adv
operator|->
name|chip_version
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|eeprom_config
operator|.
name|cfg_lsw
operator|!=
name|config_lsw
condition|)
block|{
comment|/* XXX Yet another supposed Warning */
name|eeprom_config
operator|.
name|cfg_lsw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_LSW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|cfg_msw
operator|!=
name|config_msw
condition|)
block|{
comment|/* XXX Yet another supposed Warning */
name|eeprom_config
operator|.
name|cfg_msw
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|eeprom_config
operator|.
name|cfg_lsw
operator||=
name|ADV_CFG_LSW_HOST_INT_ON
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
name|eeprom_config
operator|.
name|chksum
condition|)
block|{
if|if
condition|(
name|adv_test_external_lram
argument_list|(
name|adv
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_PCI
condition|)
block|{
name|eeprom_config
operator|.
name|cfg_msw
operator||=
literal|0x0800
expr_stmt|;
name|config_msw
operator||=
literal|0x0800
expr_stmt|;
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_CONFIG_MSW
argument_list|,
name|config_msw
argument_list|)
expr_stmt|;
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MAX_PCI_INRAM_TOTAL_QNG
expr_stmt|;
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|ADV_MAX_INRAM_TAG_QNG
expr_stmt|;
block|}
block|}
comment|/* XXX What about wide bussed cards?? */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|7
condition|;
name|i
operator|++
control|)
name|adv
operator|->
name|sdtr_data
index|[
name|i
index|]
operator|=
name|eeprom_config
operator|.
name|sdtr_data
index|[
name|i
index|]
expr_stmt|;
comment|/* Range/Sanity checking */
if|if
condition|(
name|eeprom_config
operator|.
name|max_total_qng
operator|<
name|ADV_MIN_TOTAL_QNG
condition|)
block|{
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MIN_TOTAL_QNG
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_total_qng
operator|>
name|ADV_MAX_TOTAL_QNG
condition|)
block|{
name|eeprom_config
operator|.
name|max_total_qng
operator|=
name|ADV_MAX_TOTAL_QNG
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_tag_qng
operator|>
name|eeprom_config
operator|.
name|max_total_qng
condition|)
block|{
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|eeprom_config
operator|.
name|max_total_qng
expr_stmt|;
block|}
if|if
condition|(
name|eeprom_config
operator|.
name|max_tag_qng
operator|<
name|ADV_MIN_TAG_Q_PER_DVC
condition|)
block|{
name|eeprom_config
operator|.
name|max_tag_qng
operator|=
name|ADV_MIN_TAG_Q_PER_DVC
expr_stmt|;
block|}
name|adv
operator|->
name|max_openings
operator|=
name|eeprom_config
operator|.
name|max_total_qng
expr_stmt|;
if|if
condition|(
operator|(
name|eeprom_config
operator|.
name|use_cmd_qng
operator|&
name|eeprom_config
operator|.
name|disc_enable
operator|)
operator|!=
name|eeprom_config
operator|.
name|use_cmd_qng
condition|)
block|{
name|eeprom_config
operator|.
name|disc_enable
operator||=
name|eeprom_config
operator|.
name|use_cmd_qng
expr_stmt|;
name|printf
argument_list|(
literal|"adv:%d: WARNING! One or more targets with tagged "
literal|"queuing enabled have the disconnection priveledge "
literal|"disabled.\n"
literal|"adv:%d: Overriding disconnection settings to "
literal|"allow tagged queueing devices to disconnect.\n "
argument_list|,
name|adv
operator|->
name|unit
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * XXX We should range check our target ID 		 * based on the width of our bus 		 */
block|EEPROM_SET_SCSIID(eeprom_config, 				  EEPROM_SCSIID(eeprom_config)& ADV_MAX_TID);
endif|#
directive|endif
name|adv
operator|->
name|initiate_sdtr
operator|=
name|eeprom_config
operator|.
name|init_sdtr
expr_stmt|;
name|adv
operator|->
name|disc_enable
operator|=
name|eeprom_config
operator|.
name|disc_enable
expr_stmt|;
name|adv
operator|->
name|cmd_qng_enabled
operator|=
name|eeprom_config
operator|.
name|use_cmd_qng
expr_stmt|;
name|adv
operator|->
name|isa_dma_speed
operator|=
name|EEPROM_DMA_SPEED
argument_list|(
name|eeprom_config
argument_list|)
expr_stmt|;
name|adv
operator|->
name|scsi_id
operator|=
name|EEPROM_SCSIID
argument_list|(
name|eeprom_config
argument_list|)
expr_stmt|;
name|adv
operator|->
name|start_motor
operator|=
name|eeprom_config
operator|.
name|start_motor
expr_stmt|;
name|adv
operator|->
name|control
operator|=
name|eeprom_config
operator|.
name|cntl
expr_stmt|;
name|adv
operator|->
name|no_scam
operator|=
name|eeprom_config
operator|.
name|no_scam
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Use the defaults that adv was initialized with. 		 */
comment|/* 		 * XXX Fixup EEPROM with default values??? 		 */
name|printf
argument_list|(
literal|"adv%d: Warning EEPROM Checksum mismatch. "
literal|"Using default device parameters\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX Do this in the PCI probe */
block|if ((adv->btype& ADV_PCI)&& 		!(asc_dvc->dvc_cntl& ASC_CNTL_NO_PCI_FIX_ASYN_XFER)) { 		if ((asc_dvc->cfg->pci_device_id == ASC_PCI_DEVICE_ID_REV_A) || 			(asc_dvc->cfg->pci_device_id == ASC_PCI_DEVICE_ID_REV_B)) { 			asc_dvc->pci_fix_asyn_xfer = ASC_ALL_DEVICE_BIT_SET; 		} 	}
endif|#
directive|endif
if|if
condition|(
name|adv_set_eeprom_config
argument_list|(
name|adv
argument_list|,
operator|&
name|eeprom_config
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"adv:%d: WARNING! Failure writing to EEPROM.\n"
argument_list|)
expr_stmt|;
comment|/* Allocate space for our sense buffers */
comment|/* XXX this should really be done by the generic SCSI layer by ensuring 	 * that all scsi_xfer structs are allocated below 16M if any controller 	 * needs to bounce. 	 */
if|if
condition|(
name|adv
operator|->
name|type
operator|&
name|ADV_ISA
condition|)
block|{
name|adv
operator|->
name|sense_buffers
operator|=
operator|(
expr|struct
name|scsi_sense_data
operator|*
operator|)
name|contigmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
operator|*
name|adv
operator|->
name|max_openings
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xfffffful
argument_list|,
literal|1ul
argument_list|,
literal|0x10000ul
argument_list|)
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|sense_buffers
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: Unable to allocate sense buffer space.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|adv_init_lram_and_mcode
argument_list|(
name|adv
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|u_int16_t
name|chipstat
decl_stmt|;
name|u_int16_t
name|saved_ram_addr
decl_stmt|;
name|u_int8_t
name|ctrl_reg
decl_stmt|;
name|u_int8_t
name|saved_ctrl_reg
decl_stmt|;
name|int
name|status
decl_stmt|;
name|u_int8_t
name|host_flag
decl_stmt|;
name|adv
operator|=
operator|(
expr|struct
name|adv_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|ctrl_reg
operator|=
name|ADV_INB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|)
expr_stmt|;
name|saved_ctrl_reg
operator|=
name|ctrl_reg
operator|&
operator|(
operator|~
operator|(
name|ADV_CC_SCSI_RESET
operator||
name|ADV_CC_CHIP_RESET
operator||
name|ADV_CC_SINGLE_STEP
operator||
name|ADV_CC_DIAG
operator||
name|ADV_CC_TEST
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipstat
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_STATUS
argument_list|)
operator|)
operator|&
name|ADV_CSW_INT_PENDING
condition|)
block|{
name|adv_ack_interrupt
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|host_flag
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
operator||
name|ADV_HOST_FLAG_IN_ISR
argument_list|)
expr_stmt|;
name|saved_ram_addr
operator|=
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chipstat
operator|&
name|ADV_CSW_HALTED
operator|)
operator|&&
operator|(
name|ctrl_reg
operator|&
name|ADV_CC_SINGLE_STEP
operator|)
condition|)
block|{
name|adv_isr_chip_halted
argument_list|(
name|adv
argument_list|)
expr_stmt|;
name|saved_ctrl_reg
operator|&=
operator|~
name|ADV_CC_HALT
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|adv
operator|->
name|control
operator|&
name|ADV_CNTL_INT_MULTI_Q
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
operator|(
name|status
operator|=
name|adv_qdone
argument_list|(
name|adv
argument_list|)
operator|)
operator|&
literal|0x01
operator|)
operator|!=
literal|0
condition|)
empty_stmt|;
block|}
else|else
block|{
do|do
block|{
name|status
operator|=
name|adv_qdone
argument_list|(
name|adv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|==
literal|0x11
condition|)
do|;
block|}
block|}
name|ADV_OUTW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|,
name|saved_ram_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ADV_INW
argument_list|(
name|adv
argument_list|,
name|ADV_LRAM_ADDR
argument_list|)
operator|!=
name|saved_ram_addr
condition|)
name|panic
argument_list|(
literal|"adv_intr: Unable to set LRAM addr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|ADVV_HOST_FLAG_B
argument_list|,
name|host_flag
argument_list|)
expr_stmt|;
block|}
name|ADV_OUTB
argument_list|(
name|adv
argument_list|,
name|ADV_CHIP_CTRL
argument_list|,
name|saved_ctrl_reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|adv_qdone
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|u_int8_t
name|next_qp
decl_stmt|;
name|u_int8_t
name|i
decl_stmt|;
name|u_int8_t
name|n_q_used
decl_stmt|;
name|u_int8_t
name|sg_list_qp
decl_stmt|;
name|u_int8_t
name|sg_queue_cnt
decl_stmt|;
name|u_int8_t
name|done_q_tail
decl_stmt|;
name|u_int8_t
name|tid_no
decl_stmt|;
name|target_bit_vector
name|target_id
decl_stmt|;
name|u_int16_t
name|q_addr
decl_stmt|;
name|u_int16_t
name|sg_q_addr
decl_stmt|;
name|struct
name|adv_q_done_info
name|scsiq_buf
decl_stmt|;
name|struct
name|adv_q_done_info
modifier|*
name|scsiq
decl_stmt|;
name|int
name|false_overrun
decl_stmt|;
name|u_int8_t
name|tag_code
decl_stmt|;
name|n_q_used
operator|=
literal|1
expr_stmt|;
name|scsiq
operator|=
operator|&
name|scsiq_buf
expr_stmt|;
name|done_q_tail
operator|=
name|adv_read_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|done_q_tail
argument_list|)
expr_stmt|;
name|next_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_qp
operator|!=
name|ADV_QLINK_END
condition|)
block|{
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|,
name|next_qp
argument_list|)
expr_stmt|;
name|q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|next_qp
argument_list|)
expr_stmt|;
name|sg_queue_cnt
operator|=
name|adv_copy_lram_doneq
argument_list|(
name|adv
argument_list|,
name|q_addr
argument_list|,
name|scsiq
argument_list|,
name|adv
operator|->
name|max_dma_count
argument_list|)
expr_stmt|;
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|scsiq
operator|->
name|q_status
operator|&
operator|~
operator|(
name|QS_READY
operator||
name|QS_ABORTED
operator|)
argument_list|)
expr_stmt|;
name|tid_no
operator|=
name|ADV_TIX_TO_TID
argument_list|(
name|scsiq
operator|->
name|d2
operator|.
name|target_ix
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|ADV_TIX_TO_TARGET_ID
argument_list|(
name|scsiq
operator|->
name|d2
operator|.
name|target_ix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|->
name|cntl
operator|&
name|QC_SG_HEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|sg_q_addr
operator|=
name|q_addr
expr_stmt|;
name|sg_list_qp
operator|=
name|next_qp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sg_queue_cnt
condition|;
name|i
operator|++
control|)
block|{
name|sg_list_qp
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|sg_q_addr
operator|+
name|ADV_SCSIQ_B_FWD
argument_list|)
expr_stmt|;
name|sg_q_addr
operator|=
name|ADV_QNO_TO_QADDR
argument_list|(
name|sg_list_qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|sg_list_qp
operator|==
name|ASC_QLINK_END
condition|)
block|{
name|panic
argument_list|(
literal|"adv_qdone: Corrupted SG list encountered"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|adv_write_lram_8
argument_list|(
name|adv
argument_list|,
name|sg_q_addr
operator|+
name|ADV_SCSIQ_B_STATUS
argument_list|,
name|QS_FREE
argument_list|)
expr_stmt|;
block|}
name|n_q_used
operator|=
name|sg_queue_cnt
operator|+
literal|1
expr_stmt|;
name|adv_write_lram_16
argument_list|(
name|adv
argument_list|,
name|ADVV_DONE_Q_TAIL_W
argument_list|,
name|sg_list_qp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* XXX Fix later */
block|if (adv->queue_full_or_busy& target_id) { 			cur_target_qng = adv_read_lram_8(adv, 							 ADV_QADR_BEG + scsiq->d2.target_ix); 			if (cur_target_qng< adv->max_dvc_qng[tid_no]) { 				scsi_busy = adv_read_lram_8(adv, ADVV_SCSIBUSY_B); 				scsi_busy&= ~target_id; 				adv_write_lram_8(adv, ADVV_SCSIBUSY_B, scsi_busy); 				adv->queue_full_or_busy&= ~target_id; 			} 		}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|adv
operator|->
name|cur_total_qng
operator|<
name|n_q_used
condition|)
name|panic
argument_list|(
literal|"adv_qdone: Attempting to free more queues than are active"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|adv
operator|->
name|cur_active
operator|-=
name|n_q_used
expr_stmt|;
if|if
condition|(
operator|(
name|scsiq
operator|->
name|d2
operator|.
name|xs_ptr
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|scsiq
operator|->
name|q_status
operator|&
name|QS_ABORTED
operator|)
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
literal|0x11
operator|)
return|;
elseif|else
if|if
condition|(
name|scsiq
operator|->
name|q_status
operator|==
name|QS_DONE
condition|)
block|{
name|false_overrun
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|bug_fix_control
operator|&
name|ADV_BUG_FIX_ADD_ONE_BYTE
condition|)
block|{
name|tag_code
operator|=
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_B_TAG_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_code
operator|&
name|ADV_TAG_FLAG_ADD_ONE_BYTE
condition|)
block|{
if|if
condition|(
name|scsiq
operator|->
name|remain_bytes
operator|!=
literal|0
condition|)
block|{
name|scsiq
operator|->
name|remain_bytes
operator|--
expr_stmt|;
if|if
condition|(
name|scsiq
operator|->
name|remain_bytes
operator|==
literal|0
condition|)
name|false_overrun
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|scsiq
operator|->
name|d3
operator|.
name|done_stat
operator|==
name|QD_WITH_ERROR
operator|)
operator|&&
operator|(
name|scsiq
operator|->
name|d3
operator|.
name|host_stat
operator|==
name|QHSTA_M_DATA_OVER_RUN
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|scsiq
operator|->
name|cntl
operator|&
operator|(
name|QC_DATA_IN
operator||
name|QC_DATA_OUT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|scsiq
operator|->
name|d3
operator|.
name|done_stat
operator|=
name|QD_NO_ERROR
expr_stmt|;
name|scsiq
operator|->
name|d3
operator|.
name|host_stat
operator|=
name|QHSTA_NO_ERROR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|false_overrun
condition|)
block|{
name|scsiq
operator|->
name|d3
operator|.
name|done_stat
operator|=
name|QD_NO_ERROR
expr_stmt|;
name|scsiq
operator|->
name|d3
operator|.
name|host_stat
operator|=
name|QHSTA_NO_ERROR
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|scsiq
operator|->
name|cntl
operator|&
name|QC_NO_CALLBACK
operator|)
operator|==
literal|0
condition|)
name|adv_done
argument_list|(
name|adv
argument_list|,
name|scsiq
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|adv_read_lram_8
argument_list|(
name|adv
argument_list|,
name|q_addr
operator|+
name|ADV_SCSIQ_CDB_BEG
argument_list|)
operator|==
name|START_STOP
operator|)
condition|)
block|{
name|adv
operator|->
name|unit_not_ready
operator|&=
operator|~
name|target_id
expr_stmt|;
if|if
condition|(
name|scsiq
operator|->
name|d3
operator|.
name|done_stat
operator|!=
name|QD_NO_ERROR
condition|)
name|adv
operator|->
name|start_motor
operator|&=
operator|~
name|target_id
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"adv_qdone: completed scsiq with unknown status"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 			 * XXX Doesn't this simply indicate a software bug? 			 *     What does setting the lram error code do for 			 *     you.  Would we even recover? 			 */
block|AscSetLibErrorCode(asc_dvc, ASCQ_ERR_Q_STATUS);  		  FATAL_ERR_QDONE: 			if ((scsiq->cntl& QC_NO_CALLBACK) == 0) { 				(*asc_isr_callback) (asc_dvc, scsiq); 			} 			return (0x80);
endif|#
directive|endif
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|adv_done
parameter_list|(
name|adv
parameter_list|,
name|qdonep
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|adv_q_done_info
modifier|*
name|qdonep
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|xs
operator|=
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
name|qdonep
operator|->
name|d2
operator|.
name|xs_ptr
expr_stmt|;
name|xs
operator|->
name|status
operator|=
name|qdonep
operator|->
name|d3
operator|.
name|scsi_stat
expr_stmt|;
comment|/* 	 * 'qdonep' contains the command's ending status. 	 */
switch|switch
condition|(
name|qdonep
operator|->
name|d3
operator|.
name|done_stat
condition|)
block|{
case|case
name|QD_NO_ERROR
case|:
switch|switch
condition|(
name|qdonep
operator|->
name|d3
operator|.
name|host_stat
condition|)
block|{
case|case
name|QHSTA_NO_ERROR
case|:
break|break;
case|case
name|QHSTA_M_SEL_TIMEOUT
case|:
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
break|break;
default|default:
comment|/* QHSTA error occurred */
if|#
directive|if
literal|0
comment|/* XXX Can I get more explicit information here? */
block|xs->error = XS_DRIVER_STUFFUP;
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|QD_WITH_ERROR
case|:
switch|switch
condition|(
name|qdonep
operator|->
name|d3
operator|.
name|host_stat
condition|)
block|{
case|case
name|QHSTA_NO_ERROR
case|:
if|if
condition|(
operator|(
name|qdonep
operator|->
name|d3
operator|.
name|scsi_stat
operator|==
name|STATUS_CHECK_CONDITION
operator|)
operator|||
operator|(
name|qdonep
operator|->
name|d3
operator|.
name|scsi_stat
operator|==
name|STATUS_COMMAND_TERMINATED
operator|)
condition|)
block|{
comment|/* We have valid sense information to return */
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|if
condition|(
name|adv
operator|->
name|sense_buffers
operator|!=
name|NULL
condition|)
comment|/* Structure copy */
name|xs
operator|->
name|sense
operator|=
name|adv
operator|->
name|sense_buffers
index|[
name|qdonep
operator|->
name|q_no
index|]
expr_stmt|;
block|}
break|break;
case|case
name|QHSTA_M_SEL_TIMEOUT
case|:
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
break|break;
default|default:
if|#
directive|if
literal|0
comment|/* XXX Can I get more explicit information here? */
block|xs->error = XS_DRIVER_STUFFUP;
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|QD_ABORTED_BY_HOST
case|:
comment|/* XXX Should have an explicit ABORTED error code */
name|xs
operator|->
name|error
operator|=
name|XS_ABORTED
expr_stmt|;
break|break;
default|default:
if|#
directive|if
literal|0
block|printf("adv_done: Unknown done status 0x%x\n", 			qdonep->d3.done_stat); 		xs->error = XS_DRIVER_STUFFUP;
endif|#
directive|endif
break|break;
block|}
name|xs
operator|->
name|flags
operator||=
name|SCSI_ITSDONE
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when  * interrupts are disabled (crash dumps)  */
end_comment

begin_function
specifier|static
name|int
name|adv_poll
parameter_list|(
name|adv
parameter_list|,
name|xs
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|int
name|wait
decl_stmt|;
name|wait
operator|=
name|xs
operator|->
name|timeout
expr_stmt|;
do|do
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|adv_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|adv
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|wait
operator|&&
operator|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ITSDONE
operator|)
operator|==
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"adv%d: board is not responding\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|adv_attach
parameter_list|(
name|adv
parameter_list|)
name|struct
name|adv_softc
modifier|*
name|adv
decl_stmt|;
block|{
name|struct
name|scsi_bus
modifier|*
name|scbus
decl_stmt|;
name|struct
name|scsi_queue
modifier|*
name|scsiq
decl_stmt|;
name|scsiq
operator|=
name|scsi_alloc_queue
argument_list|(
name|adv
operator|->
name|max_openings
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsiq
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	 * Prepare the scsi_bus area for the upperlevel scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|(
operator|&
name|adv_switch
argument_list|,
name|adv
argument_list|,
name|adv
operator|->
name|unit
argument_list|,
name|scsiq
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbus
operator|==
name|NULL
condition|)
block|{
name|scsi_free_queue
argument_list|(
name|scsiq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Override defaults */
if|if
condition|(
operator|(
name|adv
operator|->
name|type
operator|&
name|ADV_ISA
operator|)
operator|!=
literal|0
condition|)
name|scbus
operator|->
name|adpt_link
operator|.
name|adpt_flags
operator||=
name|SADPT_BOUNCE
expr_stmt|;
name|scbus
operator|->
name|adpt_link
operator|.
name|adpt_target
operator|=
name|adv
operator|->
name|scsi_id
expr_stmt|;
name|scbus
operator|->
name|adpt_link
operator|.
name|adpt_openings
operator|=
literal|2
expr_stmt|;
comment|/* XXX Is this correct for these cards? */
name|scbus
operator|->
name|adpt_link
operator|.
name|adpt_tagged_openings
operator|=
name|adv
operator|->
name|max_openings
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"adv%d: Probing SCSI bus\n"
argument_list|,
name|adv
operator|->
name|unit
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

