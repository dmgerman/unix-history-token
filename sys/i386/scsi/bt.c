begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *      $Id: bt.c,v 1.14 1997/07/20 16:21:36 bde Exp $  */
end_comment

begin_comment
comment|/*  * Bulogic/Bustek 32 bit Addressing Mode SCSI driver.  *  * NOTE: 1. Some bt5xx card can NOT handle 32 bit addressing mode.  *       2. OLD bt445s Revision A,B,C,D(nowired) + any firmware version  *          has broken busmaster for handling 32 bit addressing on H/W bus  *	    side.  *  *       3. Extended probing still needs confirmation from our user base, due  *	    to several H/W and firmware dependencies. If you have a problem  *	    with extended probing, please contact 'amurai@spec.co.jp'  *  *						amurai@spec.co.jp 94/6/16  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_include
include|#
directive|include
file|<i386/scsi/btreg.h>
end_include

begin_decl_stmt
name|struct
name|bt_data
modifier|*
name|btdata
index|[
name|NBT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * I/O Port Interface  */
end_comment

begin_define
define|#
directive|define
name|BT_BASE
value|bt->bt_base
end_define

begin_define
define|#
directive|define
name|BT_CTRL_STAT_PORT
value|(BT_BASE + 0x0)
end_define

begin_comment
comment|/* control& status */
end_comment

begin_comment
comment|/*			      ReadOps WriteOps			*/
end_comment

begin_define
define|#
directive|define
name|BT_HRST
value|0x80
end_define

begin_comment
comment|/* Hardware reset */
end_comment

begin_define
define|#
directive|define
name|BT_SRST
value|0x40
end_define

begin_comment
comment|/* Software reset */
end_comment

begin_define
define|#
directive|define
name|BT_IRST
value|0x20
end_define

begin_comment
comment|/* Interrupt reset */
end_comment

begin_define
define|#
directive|define
name|BT_SCRST
value|0x10
end_define

begin_comment
comment|/* SCSI bus reset */
end_comment

begin_define
define|#
directive|define
name|BT_STST
value|0x80
end_define

begin_comment
comment|/* Self test in Progress */
end_comment

begin_define
define|#
directive|define
name|BT_DIAGF
value|0x40
end_define

begin_comment
comment|/* Diagnostic Failure */
end_comment

begin_define
define|#
directive|define
name|BT_INIT
value|0x20
end_define

begin_comment
comment|/* Mbx Init required */
end_comment

begin_define
define|#
directive|define
name|BT_IDLE
value|0x10
end_define

begin_comment
comment|/* Host Adapter Idle */
end_comment

begin_define
define|#
directive|define
name|BT_CDF
value|0x08
end_define

begin_comment
comment|/* cmd/data out port full */
end_comment

begin_define
define|#
directive|define
name|BT_DF
value|0x04
end_define

begin_comment
comment|/* Data in port full */
end_comment

begin_define
define|#
directive|define
name|BT_INVDCMD
value|0x01
end_define

begin_comment
comment|/* Invalid command */
end_comment

begin_define
define|#
directive|define
name|BT_STAT_MASK
define|\
value|(BT_STST | BT_DIAGF | BT_INIT | BT_IDLE | BT_CDF | BT_DF | BT_INVDCMD)
end_define

begin_define
define|#
directive|define
name|BT_CMD_DATA_PORT
value|(BT_BASE + 0x1)
end_define

begin_comment
comment|/* cmds and datas */
end_comment

begin_comment
comment|/*			      ReadOps WriteOps			*/
end_comment

begin_define
define|#
directive|define
name|BT_NOP
value|0x00
end_define

begin_comment
comment|/* No operation */
end_comment

begin_define
define|#
directive|define
name|BT_MBX_INIT
value|0x01
end_define

begin_comment
comment|/* Mbx initialization */
end_comment

begin_define
define|#
directive|define
name|BT_START_SCSI
value|0x02
end_define

begin_comment
comment|/* start scsi command */
end_comment

begin_define
define|#
directive|define
name|BT_START_BIOS
value|0x03
end_define

begin_comment
comment|/* start bios command */
end_comment

begin_define
define|#
directive|define
name|BT_INQUIRE
value|0x04
end_define

begin_comment
comment|/* Adapter Inquiry */
end_comment

begin_define
define|#
directive|define
name|BT_MBO_INTR_EN
value|0x05
end_define

begin_comment
comment|/* Enable MBO available intr */
end_comment

begin_define
define|#
directive|define
name|BT_SEL_TIMEOUT_SET
value|0x06
end_define

begin_comment
comment|/* set selection time-out */
end_comment

begin_define
define|#
directive|define
name|BT_BUS_ON_TIME_SET
value|0x07
end_define

begin_comment
comment|/* set bus-on time */
end_comment

begin_define
define|#
directive|define
name|BT_BUS_OFF_TIME_SET
value|0x08
end_define

begin_comment
comment|/* set bus-off time */
end_comment

begin_define
define|#
directive|define
name|BT_SPEED_SET
value|0x09
end_define

begin_comment
comment|/* set transfer speed */
end_comment

begin_define
define|#
directive|define
name|BT_DEV_GET
value|0x0a
end_define

begin_comment
comment|/* return installed devices */
end_comment

begin_define
define|#
directive|define
name|BT_CONF_GET
value|0x0b
end_define

begin_comment
comment|/* return configuration data */
end_comment

begin_define
define|#
directive|define
name|BT_TARGET_EN
value|0x0c
end_define

begin_comment
comment|/* enable target mode */
end_comment

begin_define
define|#
directive|define
name|BT_SETUP_GET
value|0x0d
end_define

begin_comment
comment|/* return setup data */
end_comment

begin_define
define|#
directive|define
name|BT_WRITE_CH2
value|0x1a
end_define

begin_comment
comment|/* write channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|BT_READ_CH2
value|0x1b
end_define

begin_comment
comment|/* read channel 2 buffer */
end_comment

begin_define
define|#
directive|define
name|BT_WRITE_FIFO
value|0x1c
end_define

begin_comment
comment|/* write fifo buffer */
end_comment

begin_define
define|#
directive|define
name|BT_READ_FIFO
value|0x1d
end_define

begin_comment
comment|/* read fifo buffer */
end_comment

begin_define
define|#
directive|define
name|BT_ECHO
value|0x1e
end_define

begin_comment
comment|/* Echo command data */
end_comment

begin_define
define|#
directive|define
name|BT_MBX_INIT_EXTENDED
value|0x81
end_define

begin_comment
comment|/* Mbx initialization */
end_comment

begin_define
define|#
directive|define
name|BT_INQUIRE_REV_THIRD
value|0x84
end_define

begin_comment
comment|/* Get FirmWare version #3 */
end_comment

begin_define
define|#
directive|define
name|BT_INQUIRE_REV_FOURTH
value|0x85
end_define

begin_comment
comment|/* Get FirmWare version #4 */
end_comment

begin_define
define|#
directive|define
name|BT_INQUIRE_EXTENDED
value|0x8D
end_define

begin_comment
comment|/* Adapter Setup Inquiry */
end_comment

begin_comment
comment|/* The following commands appeared at FirmWare 3.31 */
end_comment

begin_define
define|#
directive|define
name|BT_ROUND_ROBIN
value|0x8f
end_define

begin_comment
comment|/* Enable/Disable round robin */
end_comment

begin_define
define|#
directive|define
name|BT_STRICT_ROUND_ROBIN
value|0x00
end_define

begin_comment
comment|/* Parameter for strict mode */
end_comment

begin_define
define|#
directive|define
name|BT_AGRES_ROUND_ROBIN
value|0x01
end_define

begin_comment
comment|/* Parameter for back compat */
end_comment

begin_define
define|#
directive|define
name|BT_INTR_PORT
value|(BT_BASE + 0x2)
end_define

begin_comment
comment|/* Intr. stat */
end_comment

begin_comment
comment|/*			      ReadOps WriteOps			*/
end_comment

begin_define
define|#
directive|define
name|BT_ANY_INTR
value|0x80
end_define

begin_comment
comment|/* Any interrupt */
end_comment

begin_define
define|#
directive|define
name|BT_SCRD
value|0x08
end_define

begin_comment
comment|/* SCSI reset detected */
end_comment

begin_define
define|#
directive|define
name|BT_HACC
value|0x04
end_define

begin_comment
comment|/* Command complete */
end_comment

begin_define
define|#
directive|define
name|BT_MBOA
value|0x02
end_define

begin_comment
comment|/* MBX out empty */
end_comment

begin_define
define|#
directive|define
name|BT_MBIF
value|0x01
end_define

begin_comment
comment|/* MBX in full */
end_comment

begin_struct
struct|struct
name|bt_cmd_buf
block|{
name|u_char
name|byte
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CCB_HASH_SHIFT
value|9
end_define

begin_comment
comment|/* only hash on multiples of 512 */
end_comment

begin_define
define|#
directive|define
name|CCB_HASH
parameter_list|(
name|x
parameter_list|)
value|((((long int)(x))>>CCB_HASH_SHIFT) % CCB_HASH_SIZE)
end_define

begin_define
define|#
directive|define
name|bt_nextmbx
parameter_list|(
name|wmb
parameter_list|,
name|mbx
parameter_list|,
name|mbio
parameter_list|)
define|\
value|if ( (wmb) ==&((mbx)->mbio[BT_MBX_SIZE - 1 ]) ) \ 		(wmb) =&((mbx)->mbio[0]); \ 	else \ 		(wmb)++;
end_define

begin_struct
struct|struct
name|bt_boardID
block|{
name|u_char
name|board_type
decl_stmt|;
name|u_char
name|custom_feture
decl_stmt|;
name|char
name|firm_revision
decl_stmt|;
name|u_char
name|firm_version
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bt_setup
block|{
name|u_char
name|sync_neg
range|:
literal|1
decl_stmt|;
name|u_char
name|parity
range|:
literal|1
decl_stmt|;
name|u_char
label|:
literal|6
expr_stmt|;
name|u_char
name|speed
decl_stmt|;
name|u_char
name|bus_on
decl_stmt|;
name|u_char
name|bus_off
decl_stmt|;
name|u_char
name|num_mbx
decl_stmt|;
name|u_char
name|mbx
index|[
literal|3
index|]
decl_stmt|;
comment|/* for backwards compatibility */
struct|struct
block|{
name|u_char
name|offset
range|:
literal|4
decl_stmt|;
name|u_char
name|period
range|:
literal|3
decl_stmt|;
name|u_char
name|valid
range|:
literal|1
decl_stmt|;
block|}
name|sync
index|[
literal|8
index|]
struct|;
name|u_char
name|disc_sts
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bt_config
block|{
name|u_char
name|chan
decl_stmt|;
define|#
directive|define
name|BUSDMA
value|0x00
define|#
directive|define
name|CHAN0
value|0x01
define|#
directive|define
name|CHAN5
value|0x20
define|#
directive|define
name|CHAN6
value|0x40
define|#
directive|define
name|CHAN7
value|0x80
name|u_char
name|intr
decl_stmt|;
define|#
directive|define
name|INT9
value|0x01
define|#
directive|define
name|INT10
value|0x02
define|#
directive|define
name|INT11
value|0x04
define|#
directive|define
name|INT12
value|0x08
define|#
directive|define
name|INT14
value|0x20
define|#
directive|define
name|INT15
value|0x40
name|u_char
name|scsi_dev
range|:
literal|3
decl_stmt|;
comment|/* XXX What about Wide Controllers? */
name|u_char
label|:
literal|5
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Determine 32bit address/Data firmware functionality from the bus type  * Note: bt742a/747[s|d]/757/946/445s will return 'E'  *       bt542b/545s/545d will return 'A'  *				94/05/18 amurai@spec.co.jp  */
end_comment

begin_struct
struct|struct
name|bt_ext_info
block|{
name|u_char
name|bus_type
decl_stmt|;
comment|/* Host adapter bus type */
define|#
directive|define
name|BT_BUS_TYPE_24bit
value|'A'
comment|/* PC/AT 24 bit address bus type */
define|#
directive|define
name|BT_BUS_TYPE_32bit
value|'E'
comment|/* EISA/VLB/PCI 32 bit address type */
define|#
directive|define
name|BT_BUS_TYPE_MCA
value|'M'
comment|/* Micro chanel? */
name|u_char
name|bios_addr
decl_stmt|;
comment|/* Bios Address-Not used */
name|u_short
name|max_seg
decl_stmt|;
comment|/* Max segment List */
name|u_char
name|num_mbx
decl_stmt|;
comment|/* Number of mailbox */
name|int32_t
name|mbx_base
decl_stmt|;
comment|/* mailbox base address */
struct|struct
block|{
name|u_char
name|resv1
range|:
literal|1
decl_stmt|;
comment|/* ??? */
name|u_char
name|force
range|:
literal|1
decl_stmt|;
comment|/* ON: force sync */
name|u_char
name|maxsync
range|:
literal|1
decl_stmt|;
comment|/* ON: 10MB/s , OFF: 5MB/s */
name|u_char
name|resv2
range|:
literal|2
decl_stmt|;
comment|/* ??? */
name|u_char
name|sync
range|:
literal|1
decl_stmt|;
comment|/* ON: Sync,  OFF: async ONLY!! */
name|u_char
name|resv3
range|:
literal|2
decl_stmt|;
comment|/* ??? */
block|}
name|s
struct|;
name|u_char
name|firmid
index|[
literal|3
index|]
decl_stmt|;
comment|/* Firmware ver.& rev. w/o last char */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BT_GET_BOARD_INFO
value|0x8b
end_define

begin_comment
comment|/* Get H/W ID and Revision */
end_comment

begin_struct
struct|struct
name|bt_board_info
block|{
name|u_char
name|id
index|[
literal|4
index|]
decl_stmt|;
comment|/* i.e bt742a -> '7','4','2','A'  */
name|u_char
name|ver
index|[
literal|2
index|]
decl_stmt|;
comment|/* i.e Board Revision 'H' -> 'H', 0x00 */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BT_GET_SYNC_VALUE
value|0x8c
end_define

begin_comment
comment|/* Get Synchronous Value */
end_comment

begin_struct
struct|struct
name|bt_sync_value
block|{
name|u_char
name|value
index|[
literal|8
index|]
decl_stmt|;
comment|/* Synchrnous value (value * 10 nsec) */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|INVALIDATE_CACHE
value|{asm volatile( ".byte	0x0F ;.byte 0x08" ); }
end_define

begin_comment
comment|/***********debug values *************/
end_comment

begin_define
define|#
directive|define
name|BT_SHOWCCBS
value|0x01
end_define

begin_define
define|#
directive|define
name|BT_SHOWINTS
value|0x02
end_define

begin_define
define|#
directive|define
name|BT_SHOWCMDS
value|0x04
end_define

begin_define
define|#
directive|define
name|BT_SHOWMISC
value|0x08
end_define

begin_decl_stmt
specifier|static
name|int
name|bt_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|bt_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bt_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|bt_adapter_info
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bt_ccb
modifier|*
name|bt_ccb_phys_kv
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
name|physaddr
name|ccb_phys
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
name|int
name|icnt
operator|,
name|int
name|ocnt
operator|,
name|int
name|wait
operator|,
name|u_char
operator|*
name|retval
operator|,
name|u_char
name|opcode
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bt_done
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
expr|struct
name|bt_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bt_free_ccb
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
expr|struct
name|bt_ccb
operator|*
name|ccb
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bt_ccb
modifier|*
name|bt_get_ccb
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bt_inquire_setup_information
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
expr|struct
name|bt_ext_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|btminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bt_poll
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|,
expr|struct
name|bt_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UTEST
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|bt_print_active_ccbs
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bt_print_ccb
name|__P
argument_list|(
operator|(
expr|struct
name|bt_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int32_t
name|bt_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|BT_MBO
modifier|*
name|bt_send_mbo
name|__P
argument_list|(
operator|(
expr|struct
name|bt_data
operator|*
name|bt
operator|,
name|int
name|flags
operator|,
name|int
name|cmd
operator|,
expr|struct
name|bt_ccb
operator|*
name|ccb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|bt_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|bt_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|btprobing
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * Do our own re-probe protection until a configuration  * manager can do it for us.  This ensures that we don't  * reprobe a card already found by the EISA or PCI probes.  */
end_comment

begin_struct
struct|struct
name|bt_found
block|{
name|u_long
name|port
decl_stmt|;
name|char
name|probed
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bt_found
name|found
index|[]
init|=
block|{
block|{
literal|0x330
block|,
literal|0
block|}
block|,
block|{
literal|0x334
block|,
literal|0
block|}
block|,
block|{
literal|0x230
block|,
literal|0
block|}
block|,
block|{
literal|0x234
block|,
literal|0
block|}
block|,
block|{
literal|0x130
block|,
literal|0
block|}
block|,
block|{
literal|0x134
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|bt_switch
init|=
block|{
name|bt_scsi_cmd
block|,
name|btminphys
block|,
literal|0
block|,
literal|0
block|,
name|bt_adapter_info
block|,
literal|"bt"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for out link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|bt_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"bt"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BT_RESET_TIMEOUT
value|1000
end_define

begin_comment
comment|/*  * bt_cmd(bt, icnt, ocnt, wait, retval, opcode, ...)  *  * Activate Adapter command  *    icnt:   number of args (outbound bytes written after opcode)  *    ocnt:   number of expected returned bytes  *    wait:   number of seconds to wait for response  *    retval: buffer where to place returned bytes  *    opcode: opcode BT_NOP, BT_MBX_INIT, BT_START_SCSI ...  *    ...:    parameters to the command specified by opcode  *  * Performs an adapter command through the ports.  Not to be confused with a  * scsi command, which is read in via the dma; one of the adapter commands  * tells it to read in a scsi command.  */
end_comment

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|__STDC__
name|bt_cmd
parameter_list|(
name|struct
name|bt_data
modifier|*
name|bt
parameter_list|,
name|int
name|icnt
parameter_list|,
name|int
name|ocnt
parameter_list|,
name|int
name|wait
parameter_list|,
name|u_char
modifier|*
name|retval
parameter_list|,
name|u_char
name|opcode
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|bt_cmd
parameter_list|(
name|bt
parameter_list|,
name|icnt
parameter_list|,
name|ocnt
parameter_list|,
name|wait
parameter_list|,
name|retval
parameter_list|,
name|opcode
parameter_list|,
name|va_alist
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|int
name|icnt
decl_stmt|,
name|ocnt
decl_stmt|,
name|wait
decl_stmt|;
name|u_char
modifier|*
name|retval
decl_stmt|;
name|u_char
name|opcode
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|u_char
name|data
decl_stmt|;
name|u_char
name|oc
decl_stmt|;
specifier|register
name|i
expr_stmt|;
name|int
name|sts
decl_stmt|;
comment|/* 	 * multiply the wait argument by a big constant 	 * zero defaults to 1 	 */
if|if
condition|(
name|wait
condition|)
name|wait
operator|*=
literal|100000
expr_stmt|;
else|else
name|wait
operator|=
literal|100000
expr_stmt|;
comment|/* 	 * Wait for the adapter to go idle, unless it's one of 	 * the commands which don't need this 	 */
if|if
condition|(
name|opcode
operator|!=
name|BT_MBX_INIT
operator|&&
name|opcode
operator|!=
name|BT_START_SCSI
condition|)
block|{
name|i
operator|=
literal|100000
expr_stmt|;
comment|/* 1 sec? */
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|BT_IDLE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|btprobing
condition|)
name|printf
argument_list|(
literal|"bt%d: bt_cmd, host not idle(0x%x)\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Now that it is idle, if we expect output, preflush the 	 * queue feeding to us. 	 */
if|if
condition|(
name|ocnt
condition|)
block|{
while|while
condition|(
operator|(
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
operator|)
operator|&
name|BT_DF
condition|)
name|inb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Output the command and the number of arguments given 	 * for each byte, first check the port is empty. 	 */
name|va_start
argument_list|(
name|ap
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
comment|/* test icnt>= 0, to include the command in data sent */
for|for
control|(
name|data
operator|=
name|opcode
init|;
name|icnt
operator|>=
literal|0
condition|;
name|icnt
operator|--
operator|,
name|data
operator|=
operator|(
name|u_char
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sts
operator|&
name|BT_CDF
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|btprobing
condition|)
name|printf
argument_list|(
literal|"bt%d: bt_cmd, cmd/data port full\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_SRST
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * If we expect input, loop that many times, each time, 	 * looking for the data register to have valid data 	 */
while|while
condition|(
name|ocnt
operator|--
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|BT_DF
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|btprobing
condition|)
name|printf
argument_list|(
literal|"bt%d: bt_cmd, cmd/data port empty %d\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|ocnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|oc
operator|=
name|inb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
operator|*
name|retval
operator|++
operator|=
name|oc
expr_stmt|;
block|}
comment|/* 	 * Wait for the board to report a finised instruction 	 */
name|i
operator|=
literal|100000
expr_stmt|;
comment|/* 1 sec? */
while|while
condition|(
operator|--
name|i
condition|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|&
name|BT_HACC
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|btprobing
condition|)
name|printf
argument_list|(
literal|"bt%d: bt_cmd, host not finished(0x%x)\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|sts
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_IRST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|bt_data
modifier|*
name|bt_alloc
parameter_list|(
name|unit
parameter_list|,
name|iobase
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
block|{
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NBT
condition|)
block|{
name|printf
argument_list|(
literal|"bt: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|btdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Ensure that we haven't already been probed 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|found
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|bt_found
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|found
index|[
name|i
index|]
operator|.
name|port
operator|==
name|iobase
condition|)
block|{
if|if
condition|(
name|found
index|[
name|i
index|]
operator|.
name|probed
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|found
index|[
name|i
index|]
operator|.
name|probed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
name|bt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bt_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bt
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|bt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bt_data
argument_list|)
argument_list|)
expr_stmt|;
name|btdata
index|[
name|unit
index|]
operator|=
name|bt
expr_stmt|;
name|bt
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|bt
operator|->
name|bt_base
operator|=
name|iobase
expr_stmt|;
return|return
operator|(
name|bt
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bt_free
parameter_list|(
name|bt
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
block|{
name|btdata
index|[
name|bt
operator|->
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|bt
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|bt_attach
parameter_list|(
name|bt
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
name|btprobing
operator|=
literal|0
expr_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|bt
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|bt
operator|->
name|unit
expr_stmt|;
name|bt
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|bt
operator|->
name|bt_scsi_dev
expr_stmt|;
name|bt
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|bt
expr_stmt|;
name|bt
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|bt_switch
expr_stmt|;
name|bt
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|bt_dev
expr_stmt|;
name|bt
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|bt
operator|->
name|bt_bounce
condition|?
name|SDEV_BOUNCE
else|:
literal|0
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
comment|/* XXX scbus->magtarg should be adjusted for Wide cards */
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|bt
operator|->
name|sc_link
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about the adapter and its  * capabilities.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|bt_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|void
name|bt_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|BT_MBI
modifier|*
name|wmbi
decl_stmt|;
name|struct
name|bt_mbx
modifier|*
name|wmbx
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
name|unsigned
name|char
name|stat
decl_stmt|;
name|int
name|i
decl_stmt|,
name|wait
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_data
operator|*
operator|)
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|UTEST
name|printf
argument_list|(
literal|"bt_intr "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * First acknowlege the interrupt, Then if it's 	 * not telling about a completed operation 	 * just return. 	 */
name|stat
operator|=
name|inb
argument_list|(
name|BT_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|&
name|BT_STAT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Shared interrupt */
return|return;
block|}
comment|/* Mail Box out empty ? */
if|if
condition|(
name|stat
operator|&
name|BT_MBOA
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Available Free mbo post\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
comment|/* Disable MBO available interrupt */
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
name|BT_MBO_INTR_EN
argument_list|)
expr_stmt|;
name|wait
operator|=
literal|100000
expr_stmt|;
comment|/* 1 sec enough? */
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
operator|&
name|BT_CDF
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: bt_intr, cmd/data port full\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_SRST
argument_list|)
expr_stmt|;
return|return;
block|}
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* Disable */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bt
operator|->
name|bt_mbx
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_IRST
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|stat
operator|&
name|BT_MBIF
operator|)
condition|)
block|{
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_IRST
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If it IS then process the competed operation 	 */
name|wmbx
operator|=
operator|&
name|bt
operator|->
name|bt_mbx
expr_stmt|;
name|wmbi
operator|=
name|wmbx
operator|->
name|tmbi
expr_stmt|;
name|AGAIN
label|:
while|while
condition|(
name|wmbi
operator|->
name|stat
operator|!=
name|BT_MBI_FREE
condition|)
block|{
name|ccb
operator|=
name|bt_ccb_phys_kv
argument_list|(
name|bt
argument_list|,
operator|(
name|wmbi
operator|->
name|ccb_addr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ccb
condition|)
block|{
name|wmbi
operator|->
name|stat
operator|=
name|BT_MBI_FREE
expr_stmt|;
name|printf
argument_list|(
literal|"bt: BAD CCB ADDR!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stat
operator|=
name|wmbi
operator|->
name|stat
operator|)
operator|!=
name|BT_MBI_OK
condition|)
block|{
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|BT_MBI_ABORT
case|:
ifdef|#
directive|ifdef
name|UTEST
if|if
condition|(
name|bt_debug
operator|&
name|BT_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"abort "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ccb
operator|->
name|host_stat
operator|=
name|BT_ABORTED
expr_stmt|;
break|break;
case|case
name|BT_MBI_UNKNOWN
case|:
name|ccb
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|UTEST
if|if
condition|(
name|bt_debug
operator|&
name|BT_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"unknown ccb for abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|BT_MBI_ERROR
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"Impossible mbxi status"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UTEST
if|if
condition|(
operator|(
name|bt_debug
operator|&
name|BT_SHOWCMDS
operator|)
operator|&&
name|ccb
condition|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|ccb
operator|->
name|scsi_cmd
expr_stmt|;
name|printf
argument_list|(
literal|"op=%x %x %x %x %x %x\n"
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|,
name|cp
index|[
literal|4
index|]
argument_list|,
name|cp
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stat %x for mbi addr = 0x%08x\n"
argument_list|,
name|wmbi
operator|->
name|stat
argument_list|,
name|wmbi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr = 0x%x\n"
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|wmbi
operator|->
name|stat
operator|=
name|BT_MBI_FREE
expr_stmt|;
if|if
condition|(
name|ccb
condition|)
block|{
name|untimeout
argument_list|(
name|bt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|xfer
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|bt_done
argument_list|(
name|bt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
comment|/* Set the IN mail Box pointer for next */
name|bt_nextmbx
argument_list|(
name|wmbi
argument_list|,
name|wmbx
argument_list|,
name|mbi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|wmbi
operator|->
name|stat
operator|!=
name|BT_MBI_FREE
condition|)
block|{
name|found
operator|++
expr_stmt|;
break|break;
block|}
name|bt_nextmbx
argument_list|(
name|wmbi
argument_list|,
name|wmbx
argument_list|,
name|mbi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"bt%d: mbi at 0x%08x should be found, stat=%02x..resync\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|wmbi
argument_list|,
name|stat
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|found
operator|=
literal|0
expr_stmt|;
goto|goto
name|AGAIN
goto|;
block|}
block|}
name|wmbx
operator|->
name|tmbi
operator|=
name|wmbi
expr_stmt|;
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_IRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A ccb is put onto the free list.  */
end_comment

begin_function
specifier|static
name|void
name|bt_free_ccb
parameter_list|(
name|bt
parameter_list|,
name|ccb
parameter_list|,
name|flags
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ccb
operator|->
name|next
operator|=
name|bt
operator|->
name|bt_ccb_free
expr_stmt|;
name|bt
operator|->
name|bt_ccb_free
operator|=
name|ccb
expr_stmt|;
name|ccb
operator|->
name|flags
operator|=
name|CCB_FREE
expr_stmt|;
comment|/* 	 * If there were none, wake anybody waiting for one to come free, 	 * starting with queued entries. 	 */
if|if
condition|(
operator|!
name|ccb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bt
operator|->
name|bt_ccb_free
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free ccb  *  * If there are none, see if we can allocate a new one.  If so, put it in  * the hash table too otherwise either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|bt_ccb
modifier|*
name|bt_get_ccb
parameter_list|(
name|bt
parameter_list|,
name|flags
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|opri
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccbp
decl_stmt|;
name|int
name|hashnum
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one. 	 */
while|while
condition|(
operator|!
operator|(
name|ccbp
operator|=
name|bt
operator|->
name|bt_ccb_free
operator|)
condition|)
block|{
if|if
condition|(
name|bt
operator|->
name|numccbs
operator|<
name|BT_CCB_MAX
condition|)
block|{
if|if
condition|(
name|ccbp
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bt_ccb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|ccbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bt_ccb
argument_list|)
argument_list|)
expr_stmt|;
name|bt
operator|->
name|numccbs
operator|++
expr_stmt|;
name|ccbp
operator|->
name|flags
operator|=
name|CCB_ACTIVE
expr_stmt|;
comment|/* 				 * put in the phystokv hash table 				 * Never gets taken out. 				 */
name|ccbp
operator|->
name|hashkey
operator|=
name|KVTOPHYS
argument_list|(
name|ccbp
argument_list|)
expr_stmt|;
name|hashnum
operator|=
name|CCB_HASH
argument_list|(
name|ccbp
operator|->
name|hashkey
argument_list|)
expr_stmt|;
name|ccbp
operator|->
name|nexthash
operator|=
name|bt
operator|->
name|ccbhash
index|[
name|hashnum
index|]
expr_stmt|;
name|bt
operator|->
name|ccbhash
index|[
name|hashnum
index|]
operator|=
name|ccbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bt%d: Can't malloc CCB\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bt
operator|->
name|bt_ccb_free
argument_list|,
name|PRIBIO
argument_list|,
literal|"btccb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|ccbp
condition|)
block|{
comment|/* Get CCB from from free list */
name|bt
operator|->
name|bt_ccb_free
operator|=
name|ccbp
operator|->
name|next
expr_stmt|;
name|ccbp
operator|->
name|flags
operator|=
name|CCB_ACTIVE
expr_stmt|;
block|}
name|gottit
label|:
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|ccbp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a physical address, find the ccb that  * it corresponds to:  */
end_comment

begin_function
specifier|static
name|struct
name|bt_ccb
modifier|*
name|bt_ccb_phys_kv
parameter_list|(
name|bt
parameter_list|,
name|ccb_phys
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|physaddr
name|ccb_phys
decl_stmt|;
block|{
name|int
name|hashnum
init|=
name|CCB_HASH
argument_list|(
name|ccb_phys
argument_list|)
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccbp
init|=
name|bt
operator|->
name|ccbhash
index|[
name|hashnum
index|]
decl_stmt|;
while|while
condition|(
name|ccbp
condition|)
block|{
if|if
condition|(
name|ccbp
operator|->
name|hashkey
operator|==
name|ccb_phys
condition|)
break|break;
name|ccbp
operator|=
name|ccbp
operator|->
name|nexthash
expr_stmt|;
block|}
return|return
name|ccbp
return|;
block|}
end_function

begin_comment
comment|/*  * Get a MBO and then Send it  */
end_comment

begin_function
specifier|static
name|BT_MBO
modifier|*
name|bt_send_mbo
parameter_list|(
name|bt
parameter_list|,
name|flags
parameter_list|,
name|cmd
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|unsigned
name|opri
decl_stmt|;
name|BT_MBO
modifier|*
name|wmbo
decl_stmt|;
comment|/* Mail Box Out pointer */
name|struct
name|bt_mbx
modifier|*
name|wmbx
decl_stmt|;
comment|/* Mail Box pointer specified unit */
name|int
name|i
decl_stmt|,
name|wait
decl_stmt|;
name|wmbx
operator|=
operator|&
name|bt
operator|->
name|bt_mbx
expr_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Get the Target OUT mail Box pointer and move to Next */
name|wmbo
operator|=
name|wmbx
operator|->
name|tmbo
expr_stmt|;
name|wmbx
operator|->
name|tmbo
operator|=
operator|(
name|wmbo
operator|==
operator|&
operator|(
name|wmbx
operator|->
name|mbo
index|[
name|BT_MBX_SIZE
operator|-
literal|1
index|]
operator|)
condition|?
operator|&
operator|(
name|wmbx
operator|->
name|mbo
index|[
literal|0
index|]
operator|)
else|:
name|wmbo
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 * Check the outmail box is free or not. 	 * Note: Under the normal operation, it shuld NOT happen to wait. 	 */
while|while
condition|(
name|wmbo
operator|->
name|cmd
operator|!=
name|BT_MBO_FREE
condition|)
block|{
name|wait
operator|=
literal|100000
expr_stmt|;
comment|/* 1 sec enough? */
comment|/* Enable MBO available interrupt */
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
name|BT_MBO_INTR_EN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wait
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
operator|&
name|BT_CDF
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: bt_send_mbo, cmd/data port full\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_SRST
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|BT_MBO
operator|*
operator|)
literal|0
operator|)
return|;
block|}
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
comment|/* Enable */
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|wmbx
argument_list|,
name|PRIBIO
argument_list|,
literal|"btsend"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/*can't do this! */
comment|/* May be servicing an int */
block|}
comment|/* Link CCB to the Mail Box */
name|wmbo
operator|->
name|ccb_addr
operator|=
name|KVTOPHYS
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|mbx
operator|=
name|wmbo
expr_stmt|;
name|wmbo
operator|->
name|cmd
operator|=
name|cmd
expr_stmt|;
comment|/* Send it! */
name|outb
argument_list|(
name|BT_CMD_DATA_PORT
argument_list|,
name|BT_START_SCSI
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|wmbo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have a ccb which has been processed by the  * adaptor, now we look to see how the operation  * went. Wake up the owner if waiting  */
end_comment

begin_function
specifier|static
name|void
name|bt_done
parameter_list|(
name|bt
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|ccb
operator|->
name|xfer
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"bt_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, put the results of the operation 	 * into the xfer and call whoever started it 	 */
if|if
condition|(
operator|(
name|ccb
operator|->
name|host_stat
operator|!=
name|BT_OK
operator|||
name|ccb
operator|->
name|target_stat
operator|!=
name|SCSI_OK
operator|)
operator|&&
operator|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|)
condition|)
block|{
name|s1
operator|=
operator|&
operator|(
name|ccb
operator|->
name|scsi_sense
operator|)
expr_stmt|;
name|s2
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
switch|switch
condition|(
name|ccb
operator|->
name|host_stat
condition|)
block|{
case|case
name|BT_ABORTED
case|:
comment|/* No response */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"timeout reported back\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
break|break;
case|case
name|BT_SEL_TIMEOUT
case|:
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"selection timeout reported back\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
break|break;
default|default:
comment|/* Other scsi protocol messes */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"unexpected host_stat: %x\n"
operator|,
name|ccb
operator|->
name|host_stat
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|ccb
operator|->
name|target_stat
condition|)
block|{
case|case
literal|0x02
case|:
operator|*
name|s2
operator|=
operator|*
name|s1
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"unexpected target_stat: %x\n"
operator|,
name|ccb
operator|->
name|target_stat
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|bt_free_ccb
argument_list|(
name|bt
argument_list|,
name|ccb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|bt_init
parameter_list|(
name|bt
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
block|{
name|unsigned
name|char
name|ad
index|[
literal|4
index|]
decl_stmt|;
specifier|volatile
name|int
name|i
decl_stmt|,
name|sts
decl_stmt|;
name|struct
name|bt_config
name|conf
decl_stmt|;
name|struct
name|bt_ext_info
name|info
decl_stmt|;
name|struct
name|bt_board_info
name|binfo
decl_stmt|;
comment|/* 	 * reset board, If it doesn't respond, assume 	 * that it's not there.. good for the probe 	 */
name|outb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|,
name|BT_HRST
operator||
name|BT_SRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BT_RESET_TIMEOUT
init|;
name|i
condition|;
name|i
operator|--
control|)
block|{
name|sts
operator|=
name|inb
argument_list|(
name|BT_CTRL_STAT_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sts
operator|==
operator|(
name|BT_IDLE
operator||
name|BT_INIT
operator|)
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|UTEST
name|printf
argument_list|(
literal|"bt_init: No answer from board\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/*          * Displaying Board ID and Hardware Revision          *                                   94/05/18 amurai@spec.co.jp          */
name|i
operator|=
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|binfo
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|binfo
argument_list|,
name|BT_GET_BOARD_INFO
argument_list|,
sizeof|sizeof
argument_list|(
name|binfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
condition|)
return|return
name|i
return|;
name|printf
argument_list|(
literal|"bt%d: Bt%c%c%c%c/%c%d-"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|binfo
operator|.
name|id
index|[
literal|0
index|]
argument_list|,
name|binfo
operator|.
name|id
index|[
literal|1
index|]
argument_list|,
name|binfo
operator|.
name|id
index|[
literal|2
index|]
argument_list|,
name|binfo
operator|.
name|id
index|[
literal|3
index|]
argument_list|,
name|binfo
operator|.
name|ver
index|[
literal|0
index|]
argument_list|,
operator|(
name|unsigned
operator|)
name|binfo
operator|.
name|ver
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/*          * Make sure board has a capability of 32bit addressing.          *   and Firmware also need a capability of 32bit addressing pointer          *   in Extended mailbox and ccb structure.          *                                   94/05/18 amurai@spec.co.jp          */
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|info
argument_list|,
name|BT_INQUIRE_EXTENDED
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|.
name|bus_type
condition|)
block|{
case|case
name|BT_BUS_TYPE_24bit
case|:
comment|/* PC/AT 24 bit address bus */
name|printf
argument_list|(
literal|"ISA(24bit) bus\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_BUS_TYPE_32bit
case|:
comment|/* EISA/VLB/PCI 32 bit bus */
name|printf
argument_list|(
literal|"(32bit) bus\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BT_BUS_TYPE_MCA
case|:
comment|/* forget it right now */
name|printf
argument_list|(
literal|"MCA bus architecture..."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown state..."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"giving up\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|binfo
operator|.
name|id
index|[
literal|0
index|]
operator|==
literal|'4'
operator|&&
name|binfo
operator|.
name|id
index|[
literal|1
index|]
operator|==
literal|'4'
operator|&&
name|binfo
operator|.
name|id
index|[
literal|2
index|]
operator|==
literal|'5'
operator|&&
name|binfo
operator|.
name|id
index|[
literal|3
index|]
operator|==
literal|'S'
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Your card cannot DMA above 16MB boundary. Bounce buffering enabled.\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_bounce
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|binfo
operator|.
name|id
index|[
literal|0
index|]
operator|==
literal|'5'
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: This driver is designed for using 32 bit addressing\n"
literal|"bt%d: mode firmware and EISA/PCI/VLB bus architectures\n"
literal|"bt%d: Bounce-buffering will be used (and is necessary)\n"
literal|"bt%d: if you have more than 16MBytes memory.\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_bounce
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|info
operator|.
name|bus_type
operator|==
name|BT_BUS_TYPE_24bit
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Your board should report a 32bit bus architecture type..\n"
literal|"bt%d: The firmware on your board may have a problem with over\n"
literal|"bt%d: 16MBytes memory handling with this driver.\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_bounce
operator|++
expr_stmt|;
block|}
comment|/* 	 * Assume we have a board at this stage 	 * setup dma channel from jumpers and save int 	 * level 	 */
name|printf
argument_list|(
literal|"bt%d: reading board settings, "
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|conf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|conf
argument_list|,
name|BT_CONF_GET
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|chan
condition|)
block|{
case|case
name|BUSDMA
case|:
name|bt
operator|->
name|bt_dma
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|CHAN0
case|:
name|outb
argument_list|(
literal|0x0b
argument_list|,
literal|0x0c
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x0a
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_dma
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CHAN5
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x01
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_dma
operator|=
literal|5
expr_stmt|;
break|break;
case|case
name|CHAN6
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x02
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_dma
operator|=
literal|6
expr_stmt|;
break|break;
case|case
name|CHAN7
case|:
name|outb
argument_list|(
literal|0xd6
argument_list|,
literal|0xc3
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0xd4
argument_list|,
literal|0x03
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_dma
operator|=
literal|7
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal dma setting %x\n"
argument_list|,
name|conf
operator|.
name|chan
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|bt
operator|->
name|bt_dma
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"busmastering, "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"dma=%d, "
argument_list|,
name|bt
operator|->
name|bt_dma
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conf
operator|.
name|intr
condition|)
block|{
case|case
name|INT9
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|9
expr_stmt|;
break|break;
case|case
name|INT10
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|INT11
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|INT12
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|12
expr_stmt|;
break|break;
case|case
name|INT14
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|14
expr_stmt|;
break|break;
case|case
name|INT15
case|:
name|bt
operator|->
name|bt_int
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal int setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"int=%d\n"
argument_list|,
name|bt
operator|->
name|bt_int
argument_list|)
expr_stmt|;
comment|/* who are we on the scsi bus */
name|bt
operator|->
name|bt_scsi_dev
operator|=
name|conf
operator|.
name|scsi_dev
expr_stmt|;
comment|/* 	 * Initialize mail box 	 */
operator|*
operator|(
operator|(
name|physaddr
operator|*
operator|)
name|ad
operator|)
operator|=
name|KVTOPHYS
argument_list|(
operator|&
name|bt
operator|->
name|bt_mbx
argument_list|)
expr_stmt|;
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BT_MBX_INIT_EXTENDED
argument_list|,
name|BT_MBX_SIZE
argument_list|,
name|ad
index|[
literal|0
index|]
argument_list|,
name|ad
index|[
literal|1
index|]
argument_list|,
name|ad
index|[
literal|2
index|]
argument_list|,
name|ad
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set Pointer chain null for just in case 	 * Link the ccb's into a free-list W/O mbox 	 * Initialize mail box status to free 	 */
if|if
condition|(
name|bt
operator|->
name|bt_ccb_free
operator|!=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: bt_ccb_free is NOT initialized but init here\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bt_ccb_free
operator|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BT_MBX_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|bt
operator|->
name|bt_mbx
operator|.
name|mbo
index|[
name|i
index|]
operator|.
name|cmd
operator|=
name|BT_MBO_FREE
expr_stmt|;
name|bt
operator|->
name|bt_mbx
operator|.
name|mbi
index|[
name|i
index|]
operator|.
name|stat
operator|=
name|BT_MBI_FREE
expr_stmt|;
block|}
comment|/* 	 * Set up initial mail box for round-robin operation. 	 */
name|bt
operator|->
name|bt_mbx
operator|.
name|tmbo
operator|=
operator|&
name|bt
operator|->
name|bt_mbx
operator|.
name|mbo
index|[
literal|0
index|]
expr_stmt|;
name|bt
operator|->
name|bt_mbx
operator|.
name|tmbi
operator|=
operator|&
name|bt
operator|->
name|bt_mbx
operator|.
name|mbi
index|[
literal|0
index|]
expr_stmt|;
name|bt_inquire_setup_information
argument_list|(
name|bt
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_inquire_setup_information
parameter_list|(
name|bt
parameter_list|,
name|info
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|struct
name|bt_ext_info
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|bt_setup
name|setup
decl_stmt|;
name|struct
name|bt_sync_value
name|sync
decl_stmt|;
name|char
name|dummy
index|[
literal|8
index|]
decl_stmt|;
name|char
name|sub_ver
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|bt_boardID
name|bID
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Inquire Installed Devices */
name|bzero
argument_list|(
operator|&
name|dummy
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|,
literal|100
argument_list|,
operator|&
name|dummy
index|[
literal|0
index|]
argument_list|,
name|BT_DEV_GET
argument_list|)
expr_stmt|;
comment|/* 	 * If board has a capbility of Syncrhonouse mode,          * Get a SCSI Synchronous value 	 */
if|if
condition|(
name|info
operator|->
name|s
operator|.
name|force
condition|)
block|{
comment|/* Assume fast sync capability */
name|info
operator|->
name|s
operator|.
name|sync
operator|=
literal|1
expr_stmt|;
comment|/* It's appear at 4.25? version */
name|info
operator|->
name|s
operator|.
name|maxsync
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|s
operator|.
name|sync
condition|)
block|{
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|sync
argument_list|)
argument_list|,
literal|100
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sync
argument_list|,
name|BT_GET_SYNC_VALUE
argument_list|,
sizeof|sizeof
argument_list|(
name|sync
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Inquire Board ID to board for firmware version 	 */
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bID
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|bID
argument_list|,
name|BT_INQUIRE
argument_list|)
expr_stmt|;
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|sub_ver
index|[
literal|0
index|]
argument_list|,
name|BT_INQUIRE_REV_THIRD
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|bID
operator|.
name|firm_revision
operator|-
literal|'0'
argument_list|)
operator|)
operator|*
literal|10
operator|+
call|(
name|int
call|)
argument_list|(
name|bID
operator|.
name|firm_version
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|33
condition|)
block|{
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|sub_ver
index|[
literal|1
index|]
argument_list|,
name|BT_INQUIRE_REV_FOURTH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*                  * Below rev 3.3 firmware has a problem for issuing 		 * the BT_INQUIRE_REV_FOURTH command.  		 */
name|sub_ver
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|sub_ver
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sub_ver
index|[
literal|1
index|]
operator|==
literal|' '
condition|)
name|sub_ver
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"bt%d: version %c.%c%s, "
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|bID
operator|.
name|firm_revision
argument_list|,
name|bID
operator|.
name|firm_version
argument_list|,
name|sub_ver
argument_list|)
expr_stmt|;
comment|/* 	 * Obtain setup information from board. 	 */
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|setup
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|setup
argument_list|,
name|BT_SETUP_GET
argument_list|,
sizeof|sizeof
argument_list|(
name|setup
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setup
operator|.
name|sync_neg
operator|&&
name|info
operator|->
name|s
operator|.
name|sync
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|s
operator|.
name|maxsync
condition|)
block|{
name|printf
argument_list|(
literal|"fast sync, "
argument_list|)
expr_stmt|;
comment|/* Max 10MB/s */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"sync, "
argument_list|)
expr_stmt|;
comment|/* Max 5MB/s */
block|}
block|}
else|else
block|{
if|if
condition|(
name|info
operator|->
name|s
operator|.
name|sync
condition|)
block|{
name|printf
argument_list|(
literal|"async, "
argument_list|)
expr_stmt|;
comment|/* Never try by board */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"async only, "
argument_list|)
expr_stmt|;
comment|/* Doesn't has a capability on board */
block|}
block|}
if|if
condition|(
name|setup
operator|.
name|parity
condition|)
block|{
name|printf
argument_list|(
literal|"parity, "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"no parity, "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d mbxs, %d ccbs\n"
argument_list|,
name|setup
operator|.
name|num_mbx
argument_list|,
name|BT_CCB_MAX
argument_list|)
expr_stmt|;
comment|/* 	 * Displayi SCSI negotiation value by each target.          *   						amurai@spec.co.jp          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|setup
operator|.
name|sync
index|[
name|i
index|]
operator|.
name|valid
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|!
name|setup
operator|.
name|sync
index|[
name|i
index|]
operator|.
name|offset
operator|&&
operator|!
name|setup
operator|.
name|sync
index|[
name|i
index|]
operator|.
name|period
operator|)
operator|||
operator|!
name|info
operator|->
name|s
operator|.
name|sync
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: targ %d async\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bt%d: targ %d sync rate=%2d.%02dMB/s(%dns), offset=%02d\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|i
argument_list|,
literal|100
operator|/
name|sync
operator|.
name|value
index|[
name|i
index|]
argument_list|,
operator|(
literal|100
operator|%
name|sync
operator|.
name|value
index|[
name|i
index|]
operator|)
operator|*
literal|100
operator|/
name|sync
operator|.
name|value
index|[
name|i
index|]
argument_list|,
name|sync
operator|.
name|value
index|[
name|i
index|]
operator|*
literal|10
argument_list|,
name|setup
operator|.
name|sync
index|[
name|i
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * Enable round-robin scheme - appeared at firmware rev. 3.31 	 *   Below rev 3.XX firmware has a problem for issuing          *    BT_ROUND_ROBIN command  amurai@spec.co.jp 	 */
if|if
condition|(
name|bID
operator|.
name|firm_revision
operator|>=
literal|'3'
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Using Strict Round robin scheme\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|bt_cmd
argument_list|(
name|bt
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BT_ROUND_ROBIN
argument_list|,
name|BT_STRICT_ROUND_ROBIN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"bt%d: Not using Strict Round robin scheme\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|min
end_ifndef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(x< y ? x : y)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* min */
end_comment

begin_function
specifier|static
name|void
name|btminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|BT_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|BT_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and the data address.  Also needs  * the unit, target and lu.  */
end_comment

begin_function
specifier|static
name|int32_t
name|bt_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
name|struct
name|bt_scat_gath
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|bt
operator|=
operator|(
expr|struct
name|bt_data
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"bt_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * get a ccb (mbox-out) to use. If the transfer 	 * is from a buf (possibly from interrupt time) 	 * then we can't allow it to sleep 	 */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Already done?\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: Not in use?\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ccb
operator|=
name|bt_get_ccb
argument_list|(
name|bt
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start ccb(%p)\n"
operator|,
name|ccb
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Put all the arguments for the xfer in the ccb 	 */
name|ccb
operator|->
name|xfer
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|ccb
operator|->
name|opcode
operator|=
name|BT_RESET_CCB
expr_stmt|;
block|}
else|else
block|{
comment|/* can't use S/G if zero length */
name|ccb
operator|->
name|opcode
operator|=
operator|(
name|xs
operator|->
name|datalen
condition|?
name|BT_INIT_SCAT_GATH_CCB
else|:
name|BT_INITIATOR_CCB
operator|)
expr_stmt|;
block|}
name|ccb
operator|->
name|target
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|ccb
operator|->
name|data_out
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|data_in
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|lun
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|ccb
operator|->
name|scsi_cmd_length
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|ccb
operator|->
name|sense_ptr
operator|=
name|KVTOPHYS
argument_list|(
operator|&
operator|(
name|ccb
operator|->
name|scsi_sense
operator|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|req_sense_length
operator|=
sizeof|sizeof
argument_list|(
name|ccb
operator|->
name|scsi_sense
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|datalen
operator|)
operator|&&
operator|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
operator|)
condition|)
block|{
comment|/* can use S/G only if not zero length */
name|ccb
operator|->
name|data_addr
operator|=
name|KVTOPHYS
argument_list|(
name|ccb
operator|->
name|scat_gath
argument_list|)
expr_stmt|;
name|sg
operator|=
name|ccb
operator|->
name|scat_gath
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TFS
if|if
condition|(
name|flags
operator|&
name|SCSI_DATA_UIO
condition|)
block|{
name|struct
name|iovec
modifier|*
name|iovp
decl_stmt|;
name|iovp
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iov
expr_stmt|;
name|datalen
operator|=
operator|(
operator|(
expr|struct
name|uio
operator|*
operator|)
name|xs
operator|->
name|data
operator|)
operator|->
name|uio_iovcnt
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|BT_NSEG
operator|)
condition|)
block|{
name|sg
operator|->
name|seg_addr
operator|=
operator|(
name|physaddr
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
name|xs
operator|->
name|datalen
operator|+=
name|sg
operator|->
name|seg_len
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x@0x%x)"
operator|,
name|iovp
operator|->
name|iov_len
operator|,
name|iovp
operator|->
name|iov_base
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|iovp
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
name|datalen
operator|--
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* TFS */
block|{
comment|/* 			 * Set up the scatter gather block 			 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%ld @%p:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|BT_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|seg_addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%lx"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
comment|/* 					 * This page is contiguous (physically) with 					 * the the last, just extend the length 					 */
block|{
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * next page isn't contiguous, finish the seg 				 */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|seg_len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/* end of iov/kv decision */
name|ccb
operator|->
name|data_length
operator|=
name|seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bt_scat_gath
argument_list|)
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* 			 * there's still data, must have run out of segs! 			 */
name|printf
argument_list|(
literal|"bt%d: bt_scsi_cmd, more than %d DMA segs\n"
argument_list|,
name|bt
operator|->
name|unit
argument_list|,
name|BT_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|bt_free_ccb
argument_list|(
name|bt
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* No data xfer, use non S/G values */
name|ccb
operator|->
name|data_addr
operator|=
operator|(
name|physaddr
operator|)
literal|0
expr_stmt|;
name|ccb
operator|->
name|data_length
operator|=
literal|0
expr_stmt|;
block|}
name|ccb
operator|->
name|link_id
operator|=
literal|0
expr_stmt|;
name|ccb
operator|->
name|link_addr
operator|=
operator|(
name|physaddr
operator|)
literal|0
expr_stmt|;
comment|/* 	 * Put the scsi command in the ccb and start it 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|xs
operator|->
name|cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmd
argument_list|,
name|ccb
operator|->
name|scsi_cmd_length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bt_send_mbo
argument_list|(
name|bt
argument_list|,
name|flags
argument_list|,
name|BT_MBO_START
argument_list|,
name|ccb
argument_list|)
operator|==
operator|(
name|BT_MBO
operator|*
operator|)
literal|0
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|bt_free_ccb
argument_list|(
name|bt
argument_list|,
name|ccb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
comment|/* 	 * Usually return SUCCESSFULLY QUEUED 	 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|xs
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|bt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* 	 * If we can't use interrupts, poll on completion 	 */
return|return
operator|(
name|bt_poll
argument_list|(
name|bt
argument_list|,
name|xs
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Poll a particular unit, looking for a particular xs  */
end_comment

begin_function
specifier|static
name|int
name|bt_poll
parameter_list|(
name|bt
parameter_list|,
name|xs
parameter_list|,
name|ccb
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|int
name|count
init|=
name|xs
operator|->
name|timeout
decl_stmt|;
name|u_char
name|stat
decl_stmt|;
comment|/* timeouts are in msec, so we loop in 1000 usec cycles */
while|while
condition|(
name|count
condition|)
block|{
comment|/* 		 * If we had interrupts enabled, would we 		 * have got an interrupt? 		 */
name|stat
operator|=
name|inb
argument_list|(
name|BT_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|BT_ANY_INTR
condition|)
block|{
name|bt_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* only happens in boot so ok */
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We timed out, so call the timeout handler manually, 		 * accounting for the fact that the clock is not running yet 		 * by taking out the clock queue entry it makes. 		 */
name|bt_timeout
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
comment|/* 		 * because we are polling, take out the timeout entry 		 * bt_timeout made 		 */
name|untimeout
argument_list|(
name|bt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|xfer
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|count
operator|=
literal|2000
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
comment|/* 			 * Once again, wait for the int bit 			 */
name|stat
operator|=
name|inb
argument_list|(
name|BT_INTR_PORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|&
name|BT_ANY_INTR
condition|)
block|{
name|bt_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* only happens in boot so ok */
name|count
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We timed out again...  This is bad.  Notice that 			 * this time there is no clock queue entry to remove. 			 */
name|bt_timeout
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|xs
operator|->
name|error
condition|)
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|bt_ccb
modifier|*
name|ccb
init|=
operator|(
expr|struct
name|bt_ccb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
comment|/*          * A timeout routine in kernel DONOT unlink 	 * Entry chains when time outed....So infinity Loop..          *                              94/04/20 amurai@spec.co.jp          */
name|untimeout
argument_list|(
name|bt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
name|ccb
operator|->
name|xfer
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|unit
operator|=
name|ccb
operator|->
name|xfer
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|bt
operator|=
name|btdata
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|UTEST
name|bt_print_active_ccbs
argument_list|(
name|bt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the ccb's mbx is not free, then the board has gone Far East? 	 */
if|if
condition|(
name|bt_ccb_phys_kv
argument_list|(
name|bt
argument_list|,
name|ccb
operator|->
name|mbx
operator|->
name|ccb_addr
argument_list|)
operator|==
name|ccb
operator|&&
name|ccb
operator|->
name|mbx
operator|->
name|cmd
operator|!=
name|BT_MBO_FREE
condition|)
block|{
name|printf
argument_list|(
literal|"bt%d: not taking commands!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"bt742a"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If it has been through before, then 	 * a previous abort has failed, don't 	 * try abort again 	 */
if|if
condition|(
name|ccb
operator|->
name|flags
operator|==
name|CCB_ABORTED
condition|)
block|{
comment|/* 		 * abort timed out 		 */
name|printf
argument_list|(
literal|"bt%d: Abort Operation has timed out\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|xfer
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ccb
operator|->
name|host_stat
operator|=
name|BT_ABORTED
expr_stmt|;
name|bt_done
argument_list|(
name|bt
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"bt%d: Try to abort\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bt_send_mbo
argument_list|(
name|bt
argument_list|,
operator|~
name|SCSI_NOMASK
argument_list|,
name|BT_MBO_ABORT
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
comment|/* 2 secs for the abort */
name|ccb
operator|->
name|flags
operator|=
name|CCB_ABORTED
expr_stmt|;
name|ccb
operator|->
name|xfer
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|bt_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|ccb
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UTEST
end_ifdef

begin_function
specifier|static
name|void
name|bt_print_ccb
parameter_list|(
name|ccb
parameter_list|)
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"ccb:%x op:%x cmdlen:%d senlen:%d\n"
argument_list|,
name|ccb
argument_list|,
name|ccb
operator|->
name|opcode
argument_list|,
name|ccb
operator|->
name|scsi_cmd_length
argument_list|,
name|ccb
operator|->
name|req_sense_length
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	datlen:%d hstat:%x tstat:%x flags:%x\n"
argument_list|,
name|ccb
operator|->
name|data_length
argument_list|,
name|ccb
operator|->
name|host_stat
argument_list|,
name|ccb
operator|->
name|target_stat
argument_list|,
name|ccb
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bt_print_active_ccbs
parameter_list|(
name|bt
parameter_list|)
name|struct
name|bt_data
modifier|*
name|bt
decl_stmt|;
block|{
name|struct
name|bt_ccb
modifier|*
name|ccb
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|CCB_HASH_SIZE
condition|)
block|{
name|ccb
operator|=
name|bt
operator|->
name|ccbhash
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|ccb
condition|)
block|{
if|if
condition|(
name|ccb
operator|->
name|flags
operator|!=
name|CCB_FREE
condition|)
name|bt_print_ccb
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
name|ccb
operator|=
name|ccb
operator|->
name|nexthash
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*UTEST */
end_comment

end_unit

