begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Product specific probe and attach routines can be found in:  * i386/eisa/aic7770.c	27/284X and aic7770 motherboard controllers  * pci/aic7870.c	3940, 2940, aic7880, aic7870, aic7860,  *			and aic7850 controllers  *  * Copyright (c) 1994, 1995, 1996, 1997 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: aic7xxx.c,v 1.81.2.29 1997/09/21 17:11:24 itojun Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  *	Implement Target Mode  *  * A few notes on features of the driver.  *  * SCB paging takes advantage of the fact that devices stay disconnected  * from the bus a relatively long time and that while they're disconnected,  * having the SCBs for these transactions down on the host adapter is of  * little use.  Instead of leaving this idle SCB down on the card we copy  * it back up into kernel memory and reuse the SCB slot on the card to  * schedule another transaction.  This can be a real payoff when doing random  * I/O to tagged queueing devices since there are more transactions active at  * once for the device to sort for optimal seek reduction. The algorithm goes  * like this...  *  * The sequencer maintains two lists of its hardware SCBs.  The first is the  * singly linked free list which tracks all SCBs that are not currently in  * use.  The second is the doubly linked disconnected list which holds the  * SCBs of transactions that are in the disconnected state sorted most  * recently disconnected first.  When the kernel queues a transaction to  * the card, a hardware SCB to "house" this transaction is retrieved from  * either of these two lists.  If the SCB came from the disconnected list,  * a check is made to see if any data transfer or SCB linking (more on linking  * in a bit) information has been changed since it was copied from the host  * and if so, DMAs the SCB back up before it can be used.  Once a hardware  * SCB has been obtained, the SCB is DMAed from the host.  Before any work  * can begin on this SCB, the sequencer must ensure that either the SCB is  * for a tagged transaction or the target is not already working on another  * non-tagged transaction.  If a conflict arises in the non-tagged case, the  * sequencer finds the SCB for the active transactions and sets the SCB_LINKED  * field in that SCB to this next SCB to execute.  To facilitate finding  * active non-tagged SCBs, the last four bytes of up to the first four hardware  * SCBs serve as a storage area for the currently active SCB ID for each  * target.  *  * When a device reconnects, a search is made of the hardware SCBs to find  * the SCB for this transaction.  If the search fails, a hardware SCB is  * pulled from either the free or disconnected SCB list and the proper  * SCB is DMAed from the host.  If the SCB_ABORTED control bit is set  * in the control byte of the SCB while it was disconnected, the sequencer  * will send an abort or abort tag message to the target during the  * reconnection and signal the kernel that the abort was successfull.  *  * When a command completes, a check for non-zero status and residuals is  * made.  If either of these conditions exists, the SCB is DMAed back up to  * the host so that it can interpret this information.  Additionally, in the  * case of bad status, the sequencer generates a special interrupt and pauses  * itself.  This allows the host to setup a request sense command if it   * chooses for this target synchronously with the error so that sense  * information isn't lost.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_message.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/scsi/aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/sequencer.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_reg.h>
end_include

begin_include
include|#
directive|include
file|<aic7xxx_seq.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__FreeBSD__) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/ic/aic7xxxreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/aic7xxxvar.h>
end_include

begin_define
define|#
directive|define
name|bootverbose
value|1
end_define

begin_if
if|#
directive|if
name|DEBUGTARGET
operator|<
literal|0
end_if

begin_comment
comment|/* Negative numbers for disabling cause warnings */
end_comment

begin_define
define|#
directive|define
name|DEBUGTARGET
value|17
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ALL_TARGETS
value|-1
end_define

begin_define
define|#
directive|define
name|ALL_LUNS
value|-1
end_define

begin_define
define|#
directive|define
name|ALL_CHANNELS
value|'\0'
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|u_long
name|ahc_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_DEBUG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
end_ifdef

begin_decl_stmt
name|int
name|ahc_broken_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "wbinvd" cause writing back whole cache (both CPU internal& external)  * to memory, so that the instruction takes a lot of time.  * This makes machine slow.  */
end_comment

begin_define
define|#
directive|define
name|INVALIDATE_CACHE
parameter_list|()
value|__asm __volatile("wbinvd")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x07
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_define
define|#
directive|define
name|HWSCSIID
value|0x0f
end_define

begin_comment
comment|/* our SCSI ID if Wide Bus */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ahcminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|ahc_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_run_waiting_queue
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_free_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scb
modifier|*
name|ahc_alloc_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|pause_sequencer
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|unpause_sequencer
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|unpause_always
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|restart_sequencer
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AHC_BUSRESET_DELAY
value|1000
end_define

begin_comment
comment|/* Reset delay in us */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|ahc_switch
init|=
block|{
name|ahc_scsi_cmd
block|,
name|ahcminphys
block|,
name|NULL
block|,
name|NULL
block|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|NULL
block|,
literal|"ahc"
block|,
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|ahc_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
literal|"ahc"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|pause_sequencer
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|pause
argument_list|)
expr_stmt|;
comment|/* 	 * Since the sequencer can disable pausing in a critical section, we 	 * must loop until it actually stops. 	 */
while|while
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|PAUSE
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|unpause_sequencer
parameter_list|(
name|ahc
parameter_list|,
name|unpause_always
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|unpause_always
decl_stmt|;
block|{
if|if
condition|(
name|unpause_always
operator|||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
operator|(
name|SCSIINT
operator||
name|SEQINT
operator||
name|BRKADRINT
operator|)
operator|)
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|ahc
operator|->
name|unpause
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|restart_sequencer
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|SEQRESET
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_define
define|#
directive|define
name|IS_SCSIBUS_B
parameter_list|(
name|ahc
parameter_list|,
name|sc_link
parameter_list|)
define|\
value|(((u_int32_t)((sc_link)->fordriver)& SELBUSB) != 0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NetBSD/OpenBSD */
end_comment

begin_define
define|#
directive|define
name|IS_SCSIBUS_B
parameter_list|(
name|ahc
parameter_list|,
name|sc_link
parameter_list|)
define|\
value|((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SCB_TARGET
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& TID)>> 4)
end_define

begin_define
define|#
directive|define
name|SCB_LUN
parameter_list|(
name|scb
parameter_list|)
define|\
value|((scb)->hscb->tcl& LID)
end_define

begin_define
define|#
directive|define
name|SCB_IS_SCSIBUS_B
parameter_list|(
name|scb
parameter_list|)
define|\
value|(((scb)->hscb->tcl& SELBUSB) != 0)
end_define

begin_decl_stmt
specifier|static
name|u_int8_t
name|ahc_abort_wscb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|,
name|u_int8_t
name|scbpos
operator|,
name|u_int8_t
name|prev
operator|,
name|u_int32_t
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_done
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_handle_seqint
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|u_int8_t
name|intstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_handle_scsiint
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|u_int8_t
name|intstat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_handle_devreset
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_loadseq
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|patch
modifier|*
name|ahc_next_patch
name|__P
argument_list|(
operator|(
expr|struct
name|patch
operator|*
name|cur_patch
operator|,
name|int
name|options
operator|,
name|int
name|instrptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|options
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|ahc_match_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|int
name|lun
operator|,
name|u_int8_t
name|tag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_poll
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|wait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ahc_print_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int8_t
name|ahc_find_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_search_qinfifo
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|int
name|lun
operator|,
name|u_int8_t
name|tag
operator|,
name|u_int32_t
name|flags
operator|,
name|u_int32_t
name|xs_error
operator|,
name|int
name|requeue
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_channel
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|char
name|channel
operator|,
name|u_int32_t
name|xs_error
operator|,
name|int
name|initiate_reset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_device
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|int
name|lun
operator|,
name|u_int8_t
name|tag
operator|,
name|u_int32_t
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int8_t
name|ahc_rem_scb_from_disc_list
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|u_int8_t
name|scbptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_add_curscb_to_free_list
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_clear_intstat
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_reset_current_bus
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_run_done_queue
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_untimeout_done_queue
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_scsirate
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|u_int8_t
operator|*
name|scsirate
operator|,
name|u_int8_t
operator|*
name|period
operator|,
name|u_int8_t
operator|*
name|offset
operator|,
name|char
name|channel
operator|,
name|int
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|void
name|ahc_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int8_t
name|ahc_index_busy_target
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|int
name|unbusy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_busy_target
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|u_int8_t
name|scbid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_construct_sdtr
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|start_byte
operator|,
name|u_int8_t
name|period
operator|,
name|u_int8_t
name|offset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_construct_wdtr
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_softc
operator|*
name|ahc
operator|,
name|int
name|start_byte
operator|,
name|u_int8_t
name|bus_width
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_calc_residual
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|char
modifier|*
name|ahc_name
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ahc%d"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
name|struct
name|cfdriver
name|ahc_cd
init|=
block|{
name|NULL
block|,
literal|"ahc"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
init|=
name|scb
operator|->
name|hscb
decl_stmt|;
name|printf
argument_list|(
literal|"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
argument_list|,
name|scb
argument_list|,
name|hscb
operator|->
name|control
argument_list|,
name|hscb
operator|->
name|tcl
argument_list|,
name|hscb
operator|->
name|cmdlen
argument_list|,
name|hscb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
argument_list|,
name|hscb
operator|->
name|datalen
argument_list|,
name|hscb
operator|->
name|data
argument_list|,
name|hscb
operator|->
name|SG_segment_count
argument_list|,
name|hscb
operator|->
name|SG_list_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%lx sg_len:%ld\n"
argument_list|,
name|hscb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|hscb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_int8_t
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|PARERR
block|,
literal|"Sequencer Ram Parity Error"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|sxfr
decl_stmt|;
comment|/* Rates in Ultra mode have bit 8 of sxfr set */
define|#
directive|define
name|ULTRA_SXFR
value|0x100
name|u_int8_t
name|period
decl_stmt|;
comment|/* Period to send to SCSI target */
name|char
modifier|*
name|rate
decl_stmt|;
block|}
name|ahc_syncrates
index|[]
init|=
block|{
block|{
literal|0x100
block|,
literal|12
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x110
block|,
literal|15
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x120
block|,
literal|18
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x000
block|,
literal|25
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x010
block|,
literal|31
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x020
block|,
literal|37
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x030
block|,
literal|43
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x040
block|,
literal|50
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x050
block|,
literal|56
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x060
block|,
literal|62
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x070
block|,
literal|68
block|,
literal|"3.6"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ahc_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|ahc_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a controller structure for a new device and initialize it.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|ahc_softc
modifier|*
name|ahc_alloc
argument_list|(
name|unit
argument_list|,
name|iobase
argument_list|,
name|maddr
argument_list|,
name|type
argument_list|,
name|flags
argument_list|,
name|scb_data
argument_list|)
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|iobase
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_function
name|void
name|ahc_construct
parameter_list|(
name|ahc
parameter_list|,
name|bc
parameter_list|,
name|ioh
parameter_list|,
name|maddr
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|bus_chipset_tag_t
name|bc
decl_stmt|;
name|bus_io_handle_t
name|ioh
decl_stmt|;
endif|#
directive|endif
name|vm_offset_t
name|maddr
decl_stmt|;
name|ahc_type
name|type
decl_stmt|;
name|ahc_flag
name|flags
decl_stmt|;
name|struct
name|scb_data
modifier|*
name|scb_data
decl_stmt|;
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
comment|/* 		 * We are not sharing SCB space with another controller 		 * so allocate our own SCB data space. 		 */
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|full_ahc_softc
argument_list|)
expr_stmt|;
else|else
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_softc
argument_list|)
expr_stmt|;
name|ahc
operator|=
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|scb_data
operator|==
name|NULL
condition|)
block|{
name|struct
name|full_ahc_softc
modifier|*
name|full_softc
init|=
operator|(
expr|struct
name|full_ahc_softc
operator|*
operator|)
name|ahc
decl_stmt|;
name|ahc
operator|->
name|scb_data
operator|=
operator|&
name|full_softc
operator|->
name|scb_data_storage
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|scb_data
operator|=
name|scb_data
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|cmplete_scbs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|baseport
operator|=
name|iobase
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_bc
operator|=
name|bc
expr_stmt|;
name|ahc
operator|->
name|sc_ioh
operator|=
name|ioh
expr_stmt|;
endif|#
directive|endif
name|ahc
operator|->
name|maddr
operator|=
operator|(
specifier|volatile
name|u_int8_t
operator|*
operator|)
name|maddr
expr_stmt|;
name|ahc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return
operator|(
name|ahc
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ahc_reset
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|u_int8_t
name|hcntrl
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* Retain the IRQ type accross the chip reset */
name|hcntrl
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|PAUSE
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|,
name|hcntrl
operator||
name|PAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_scsirate
parameter_list|(
name|ahc
parameter_list|,
name|scsirate
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|,
name|channel
parameter_list|,
name|target
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int8_t
modifier|*
name|scsirate
decl_stmt|;
name|u_int8_t
modifier|*
name|period
decl_stmt|;
name|u_int8_t
modifier|*
name|offset
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int32_t
name|ultra_enb_addr
decl_stmt|;
name|u_int8_t
name|sxfrctl0
decl_stmt|;
name|u_int8_t
name|ultra_enb
decl_stmt|;
name|i
operator|=
name|ahc_num_syncrates
expr_stmt|;
comment|/* Default to async */
if|if
condition|(
operator|*
name|period
operator|>=
name|ahc_syncrates
index|[
literal|0
index|]
operator|.
name|period
operator|&&
operator|*
name|offset
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|period
operator|<=
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
condition|)
block|{
comment|/* 				 * Watch out for Ultra speeds when ultra is not 				 * enabled and vice-versa. 				 */
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
operator|)
operator|&&
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
operator|)
condition|)
block|{
comment|/* 					 * This should only happen if the 					 * drive is the first to negotiate 					 * and chooses a high rate.  We'll 					 * just move down the table util 					 * we hit a non ultra speed. 					 */
continue|continue;
block|}
operator|*
name|scsirate
operator|=
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
literal|0xF0
operator|)
operator||
operator|(
operator|*
name|offset
operator|&
literal|0x0f
operator|)
expr_stmt|;
operator|*
name|period
operator|=
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d synchronous at "
literal|"%sMHz, offset = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|,
operator|*
name|offset
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|i
operator|>=
name|ahc_num_syncrates
condition|)
block|{
comment|/* Use asynchronous transfers. */
operator|*
name|scsirate
operator|=
literal|0
expr_stmt|;
operator|*
name|period
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: target %d using asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ensure Ultra mode is set properly for 	 * this target. 	 */
name|ultra_enb_addr
operator|=
name|ULTRA_ENB
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
operator|||
name|target
operator|>
literal|7
condition|)
name|ultra_enb_addr
operator|++
expr_stmt|;
name|ultra_enb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ultra_enb_addr
argument_list|)
expr_stmt|;
name|sxfrctl0
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scsirate
operator|!=
literal|0
operator|&&
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
operator|)
condition|)
block|{
name|ultra_enb
operator||=
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
expr_stmt|;
name|sxfrctl0
operator||=
name|FAST20
expr_stmt|;
block|}
else|else
block|{
name|ultra_enb
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|sxfrctl0
operator|&=
operator|~
name|FAST20
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|ultra_enb_addr
argument_list|,
name|ultra_enb
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|sxfrctl0
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|int
name|ahcprint
parameter_list|(
name|aux
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: scsibus "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|UNCONF
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
if|if
condition|(
name|cpu_class
operator|==
name|CPUCLASS_386
condition|)
comment|/* doesn't have "wbinvd" instruction */
name|ahc_broken_cache
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * fill in the prototype scsi_links. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|ahc
operator|->
name|unit
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_target
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
endif|#
directive|endif
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|ahc
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahc_switch
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|opennings
operator|=
literal|2
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahc_dev
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|DEBUGLEVEL
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* Configure the second scsi bus */
name|ahc
operator|->
name|sc_link_b
operator|=
name|ahc
operator|->
name|sc_link
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_bus
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|fordriver
operator|=
operator|(
name|void
operator|*
operator|)
name|SELBUSB
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_target
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
operator|&
name|ahc
operator|->
name|sc_link_b
else|:
operator|&
name|ahc
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing channel %c\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
operator|&
name|ahc
operator|->
name|sc_link
else|:
operator|&
name|ahc
operator|->
name|sc_link_b
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing Channel %c\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * XXX - Update MI SCSI code 	 * 	 * if(ahc->type& AHC_WIDE) 	 *	max target of both channel A and B = 15; 	 */
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* make IS_SCSIBUS_B() == false, while probing channel A */
name|ahc
operator|->
name|sc_link_b
operator|.
name|scsibus
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
name|printf
argument_list|(
literal|"%s: Probing channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Probing channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link_b
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * if implementation of IS_SCSIBUS_B() is changed to use 		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;" 		 * is needed, here. 		 */
comment|/* assert(ahc->type& AHC_TWIN); */
name|printf
argument_list|(
literal|"%s: Probing channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link_b
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Probing channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|void
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
endif|#
directive|endif
name|ahc_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int8_t
name|intstat
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|arg
expr_stmt|;
name|intstat
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
comment|/* 	 * Is this interrupt for me? or for 	 * someone who is sharing my interrupt? 	 */
if|if
condition|(
operator|!
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int8_t
name|scb_index
decl_stmt|;
name|u_int8_t
name|qoutcnt
decl_stmt|;
name|int
name|int_cleared
decl_stmt|;
name|int_cleared
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|qoutcnt
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QOUTCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ahc
operator|->
name|cmdoutcnt
operator|+=
name|qoutcnt
expr_stmt|;
for|for
control|(
init|;
name|qoutcnt
operator|>
literal|0
condition|;
name|qoutcnt
operator|--
control|)
block|{
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QOUTFIFO
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING "
literal|"no command for scb %d "
literal|"(cmdcmplt)\nQOUTCNT == %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|,
name|qoutcnt
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahc
operator|->
name|cmplete_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|cmdoutcnt
operator|>=
name|ahc
operator|->
name|qfullcount
condition|)
block|{
comment|/* 					 * Since paging only occurs on 					 * aic78X0 chips, we can use 					 * Auto Access Pause to clear 					 * the command count. 					 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDOUTCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|cmdoutcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|scb
operator|=
name|ahc
operator|->
name|cmplete_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|cmplete_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 				 * Save off the residual if there is one. 				 */
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_segment_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_QUEUED_ABORT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Have to clean up any possible 					 * entries in the waiting queue and 					 * QINFIFO. 					 */
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|u_int8_t
name|tag
decl_stmt|;
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|target
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|lun
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|channel
operator|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|int_cleared
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|int_cleared
operator|==
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* 		 * We upset the sequencer :-( 		 * Lookup the error message 		 */
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|num_errors
decl_stmt|;
name|error
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
expr_stmt|;
name|num_errors
operator|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"%s: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|ALL_CHANNELS
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_DRIVER_STUFFUP
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
name|ahc_handle_seqint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
name|ahc_handle_scsiint
argument_list|(
name|ahc
argument_list|,
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|!=
name|NULL
condition|)
name|ahc_run_waiting_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_seqint
parameter_list|(
name|ahc
parameter_list|,
name|intstat
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int8_t
name|intstat
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_int16_t
name|targ_mask
decl_stmt|;
name|u_int8_t
name|target
decl_stmt|;
name|int
name|scratch_offset
decl_stmt|;
name|char
name|channel
decl_stmt|;
if|if
condition|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|RESELECTED
operator|)
operator|!=
literal|0
condition|)
name|target
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SELID
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
expr_stmt|;
name|target
operator|=
operator|(
name|target
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
expr_stmt|;
name|scratch_offset
operator|=
name|target
expr_stmt|;
name|channel
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scratch_offset
operator|+=
literal|8
expr_stmt|;
name|targ_mask
operator|=
operator|(
literal|0x01
operator|<<
name|scratch_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|NO_MATCH
case|:
block|{
comment|/* 		 * This could be for a normal abort request. 		 * Figure out the SCB that we were trying to find 		 * and only give an error if we didn't ask for this 		 * to happen. 		 */
name|u_int8_t
name|scb_index
decl_stmt|;
name|u_int8_t
name|busy_scbid
decl_stmt|;
name|u_int8_t
name|arg1
decl_stmt|;
name|busy_scbid
operator|=
name|ahc_index_busy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
comment|/*unbusy*/
name|FALSE
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg1
operator|==
name|SCB_LIST_NULL
condition|)
comment|/* Untagged Request */
name|scb_index
operator|=
name|busy_scbid
expr_stmt|;
else|else
name|scb_index
operator|=
name|arg1
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|ABORT_SCB
condition|)
block|{
comment|/* 				 * We expected this.  Let the busfree 				 * handler take care of this when we 				 * the abort is finially sent. 				 * Set IDENTIFY_SEEN so that the busfree 				 * handler knows that there is an SCB to 				 * cleanup. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator||
name|IDENTIFY_SEEN
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"reconnect SCB abort successfull\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for reconnecting "
literal|"target - issuing BUS DEVICE RESET\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_TCL == 0x%x ARG_1 == 0x%x SEQADDR == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|,
name|arg1
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_MATCH_BUSY
case|:
block|{
comment|/* 		 * XXX Leave this as a panic for the time being since 		 * it indicates a bug in the timeout code for this 		 * to happen. 		 */
name|u_int8_t
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|CUR_SCBID
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|panic
argument_list|(
literal|"%s:%c:%d: Target busy link failure.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
block|}
case|case
name|SEND_REJECT
case|:
block|{
name|u_int8_t
name|rejbyte
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Warning - unknown message received from "
literal|"target (0x%x).  SEQ_FLAGS == 0x%x.  Rejecting\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|rejbyte
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_IDENT
case|:
block|{
comment|/* 		 * The reconnecting target either did not send an identify 		 * message, or did, but we didn't find and SCB to match and 		 * before it could respond to our ATN/abort, it hit a dataphase. 		 * The only safe thing to do is to blow it away with a bus 		 * reset. 		 */
name|int
name|found
decl_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: Target did not send an IDENTIFY message. "
literal|"LASTPHASE = 0x%x, SAVED_TCL == 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|XS_TIMEOUT
argument_list|,
comment|/*initiate reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_PHASE
case|:
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
operator|==
name|P_BUSFREE
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: Missed busfree.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase.  Attempting "
literal|"to continue\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|EXTENDED_MSG
case|:
block|{
name|u_int8_t
name|message_length
decl_stmt|;
name|u_int8_t
name|message_code
decl_stmt|;
name|u_int8_t
name|scb_index
decl_stmt|;
name|message_length
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSGIN_EXT_LEN
argument_list|)
expr_stmt|;
name|message_code
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSGIN_EXT_OPCODE
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
switch|switch
condition|(
name|message_code
condition|)
block|{
case|case
name|MSG_EXT_SDTR
case|:
block|{
name|u_int8_t
name|period
decl_stmt|;
name|u_int8_t
name|offset
decl_stmt|;
name|u_int8_t
name|saved_offset
decl_stmt|;
name|u_int8_t
name|targ_scratch
decl_stmt|;
name|u_int8_t
name|maxoffset
decl_stmt|;
name|u_int8_t
name|rate
decl_stmt|;
if|if
condition|(
name|message_length
operator|!=
name|MSG_EXT_SDTR_LEN
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
break|break;
block|}
name|period
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSGIN_EXT_BYTES
argument_list|)
expr_stmt|;
name|saved_offset
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSGIN_EXT_BYTES
operator|+
literal|1
argument_list|)
expr_stmt|;
name|targ_scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_scratch
operator|&
name|WIDEXFER
condition|)
name|maxoffset
operator|=
name|MAX_OFFSET_16BIT
expr_stmt|;
else|else
name|maxoffset
operator|=
name|MAX_OFFSET_8BIT
expr_stmt|;
name|offset
operator|=
name|MIN
argument_list|(
name|saved_offset
argument_list|,
name|maxoffset
argument_list|)
expr_stmt|;
name|ahc_scsirate
argument_list|(
name|ahc
argument_list|,
operator|&
name|rate
argument_list|,
operator|&
name|period
argument_list|,
operator|&
name|offset
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Preserve the WideXfer flag */
name|targ_scratch
operator|=
name|rate
operator||
operator|(
name|targ_scratch
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
comment|/* 			 * Update both the target scratch area and the 			 * current SCSIRATE. 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
comment|/* 			 * See if we initiated Sync Negotiation 			 * and didn't have to fall down to async 			 * transfers. 			 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We started it */
if|if
condition|(
name|saved_offset
operator|==
name|offset
condition|)
block|{
comment|/* 					 * Don't send an SDTR back to 					 * the target 					 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Went too low - force async */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Send our own SDTR in reply 				 */
name|printf
argument_list|(
literal|"Sending SDTR!!\n"
argument_list|)
expr_stmt|;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
comment|/*start_byte*/
literal|0
argument_list|,
name|period
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_MSG
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
break|break;
block|}
case|case
name|MSG_EXT_WDTR
case|:
block|{
name|u_int8_t
name|scratch
decl_stmt|,
name|bus_width
decl_stmt|;
if|if
condition|(
name|message_length
operator|!=
name|MSG_EXT_WDTR_LEN
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
break|break;
block|}
name|bus_width
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSGIN_EXT_BYTES
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Don't send a WDTR back to the 				 * target, since we asked first. 				 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: target %d using "
literal|"16Bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
name|WIDEXFER
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
comment|/* 					 * How can we do 32bit transfers 					 * on a 16bit bus? 					 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target %d requested 32Bit "
literal|"transfers.  Rejecting...\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* 				 * Send our own WDTR in reply 				 */
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
block|{
comment|/* Negotiate 16_BITS */
name|bus_width
operator|=
name|BUS_16_BIT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: target %d "
literal|"using 16Bit "
literal|"transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
name|WIDEXFER
expr_stmt|;
block|}
else|else
name|bus_width
operator|=
name|BUS_8_BIT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
comment|/*start_byte*/
literal|0
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_MSG
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Unknown extended message.  Reject it. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|REJECT_MSG
case|:
block|{
comment|/* 		 * What we care about here is if we had an 		 * outstanding SDTR or WDTR message for this 		 * target.  If we did, this is a signal that 		 * the target is refusing negotiation. 		 */
name|u_int8_t
name|targ_scratch
decl_stmt|;
name|u_int8_t
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|targ_scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* note 8bit xfers and clear flag */
name|targ_scratch
operator|&=
literal|0x7f
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|targ_scratch
operator|&=
literal|0xf0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses synchronous negotiation. "
literal|"Using asynchronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Otherwise, we ignore it. 			 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"%s:%c:%d: Message reject -- ignored\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_STATUS
case|:
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
comment|/* 		 * The sequencer will notify us when a command 		 * has an error that would be of interest to 		 * the kernel.  This allows us to leave the sequencer 		 * running in the common case of command completes 		 * without error.  The sequencer will already have 		 * dma'd the SCB back up to us, so we can reference 		 * the in kernel copy directly. 		 */
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* 		 * Set the default return value to 0 (don't 		 * send sense).  The sense code will change 		 * this if needed and this reduces code 		 * duplication. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: ahc_intr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|xs
operator|->
name|status
operator|=
name|hscb
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|hscb
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of"
literal|" 0???\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_CHECK
case|:
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: requests Check Status\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|)
operator|&&
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|&
operator|(
name|scb
operator|->
name|sense_cmd
operator|)
decl_stmt|;
comment|/* 				 * Save off the residual if there is one. 				 */
if|if
condition|(
name|hscb
operator|->
name|residual_SG_segment_count
operator|!=
literal|0
condition|)
name|ahc_calc_residual
argument_list|(
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|byte2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|vtophys
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
comment|/* XXX should allow disconnection, but 				 * can't as it might allow overlapped 				 * tagged commands. 				 */
comment|/* hscb->control&= DISCENB; */
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|SG_segment_count
operator|=
literal|1
expr_stmt|;
name|hscb
operator|->
name|SG_list_pointer
operator|=
name|vtophys
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|data
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
comment|/* Maintain SCB_LINKED_NEXT */
name|hscb
operator|->
name|datalen
operator|&=
literal|0xFF000000
expr_stmt|;
name|hscb
operator|->
name|datalen
operator||=
name|sg
operator|->
name|len
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|vtophys
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
name|hscb
operator|->
name|SG_segment_count
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
comment|/* 				 * Ensure the target is busy since this 				 * will be an untagged request. 				 */
name|ahc_busy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
comment|/* 				 * Ensure we have enough time to actually 				 * retrieve the sense. 				 */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
name|hz
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Clear the SCB_SENSE Flag and have 			 * the sequencer do a normal command 			 * complete with either a "DRIVER_STUFFUP" 			 * error or whatever other error condition 			 * we already had. 			 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|SCSI_QUEUE_FULL
case|:
if|if
condition|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
condition|)
block|{
comment|/* 				 * The upper level SCSI code in 3.0 				 * handles this properly... 				 */
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|sc_link
operator|=
name|xs
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|active
operator|>
literal|2
operator|&&
name|sc_link
operator|->
name|opennings
operator|!=
literal|0
condition|)
block|{
comment|/* truncate the opennings */
name|sc_link
operator|->
name|opennings
operator|=
literal|0
expr_stmt|;
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Tagged openings reduced to "
literal|"%d\n"
argument_list|,
name|sc_link
operator|->
name|active
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * XXX requeue this unconditionally. 				 */
name|scb
operator|->
name|xs
operator|->
name|retries
operator|++
expr_stmt|;
name|scb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
block|}
comment|/* Else treat as if it is a BUSY condition */
name|scb
operator|->
name|hscb
operator|->
name|status
operator|=
name|SCSI_BUSY
expr_stmt|;
comment|/* Fall Through... */
case|case
name|SCSI_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target Busy\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_RSVD
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
comment|/*XXX*/
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target Reserved\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|hscb
operator|->
name|status
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|AWAITING_MSG
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|u_int8_t
name|message_offset
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 		 * This SCB had MK_MESSAGE set in its control byte, 		 * informing the sequencer that we wanted to send a 		 * special message to this target. 		 */
name|message_offset
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|MSG_BUS_DEV_RESET
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
condition|)
block|{
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
name|message_offset
argument_list|,
name|MSG_ABORT_TAG
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
name|message_offset
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
name|message_offset
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Abort Message Sent\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
condition|)
block|{
name|ahc_construct_wdtr
argument_list|(
name|ahc
argument_list|,
name|message_offset
argument_list|,
name|BUS_16_BIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
condition|)
block|{
name|int
name|sxfr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u_int16_t
name|ultraenable
decl_stmt|;
name|u_int8_t
name|target_scratch
decl_stmt|;
comment|/* Pull the user defined setting */
name|target_scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
name|sxfr
operator|=
name|target_scratch
operator|&
name|SXFR
expr_stmt|;
name|ultraenable
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|ultraenable
operator|&
name|targ_mask
condition|)
comment|/* Want an ultra speed in the table */
name|sxfr
operator||=
literal|0x100
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sxfr
operator|==
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
condition|)
break|break;
name|ahc_construct_sdtr
argument_list|(
name|ahc
argument_list|,
name|message_offset
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
argument_list|,
operator|(
name|target_scratch
operator|&
name|WIDEXFER
operator|)
condition|?
name|MAX_OFFSET_16BIT
else|:
name|MAX_OFFSET_8BIT
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ahc_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_OVERRUN
case|:
block|{
comment|/* 		 * When the sequencer detects an overrun, it 		 * sets STCNT to 0x00ffffff and allows the 		 * target to complete its transfer in 		 * BITBUCKET mode. 		 */
name|u_int8_t
name|scbindex
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|u_int8_t
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|u_int32_t
name|overrun
decl_stmt|;
name|int
name|i
decl_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbindex
index|]
expr_stmt|;
name|overrun
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|STCNT
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|STCNT
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|STCNT
operator|+
literal|2
argument_list|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|overrun
operator|=
literal|0x00ffffff
operator|-
name|overrun
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data overrun of %d bytes detected in %s phase."
literal|"  Tag == 0x%x.  Forcing a retry.\n"
argument_list|,
name|overrun
argument_list|,
name|lastphase
operator|==
name|P_DATAIN
condition|?
literal|"Data-In"
else|:
literal|"Data-Out"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s seen Data Phase.  Length = %d.  NumSGs = %d.\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|)
operator|&
name|DPHASE
condition|?
literal|"Have"
else|:
literal|"Haven't"
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|datalen
argument_list|,
name|scb
operator|->
name|sg_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scb
operator|->
name|sg_count
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"sg[%d] - Addr 0x%x : Length %d\n"
argument_list|,
name|i
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Set this and it will take affect when the 		 * target does a command complete. 		 */
name|scb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|NOT_YET
comment|/* XXX Fill these in later */
case|case
name|MESG_BUFFER_BUSY
case|:
break|break;
case|case
name|MSGIN_PHASEMIS
case|:
break|break;
endif|#
directive|endif
if|#
directive|if
literal|0
block|case SCB_TRACE_POINT: 	{
comment|/* 		 * Print out the bus phase 		 */
block|char	 *phase; 		u_int8_t scbindex = ahc_inb(ahc, SCB_TAG); 		u_int8_t lastphase = ahc_inb(ahc, LASTPHASE);  		scb = ahc->scb_data->scbarray[scbindex]; 		sc_print_addr(scb->xs->sc_link);  		switch (lastphase) { 		case P_DATAOUT: 			phase = "Data-Out"; 			break; 		case P_DATAIN: 			phase = "Data-In"; 			break; 		case P_COMMAND: 			phase = "Command"; 			break; 		case P_MESGOUT: 			phase = "Message-Out"; 			break; 		case P_STATUS: 			phase = "Status"; 			break; 		case P_MESGIN: 			phase = "Message-In"; 			break; 		default: 			phase = "busfree"; 			break; 		} 		printf("- %s\n", phase); 		break; 	}
endif|#
directive|endif
case|case
name|ABORT_CMDCMPLT
case|:
comment|/* This interrupt serves to pause the sequencer 		 * until we can clean up the QOUTFIFO allowing us 		 * to hanle any abort SCBs that may have completed 		 * yet still have an SCB in the QINFIFO or 		 * waiting for selection queue.  By the time we get 		 * here, we should have already cleaned up the  		 * queues, so all we need to do is unpause the sequencer. 		 */
break|break;
default|default:
name|printf
argument_list|(
literal|"ahc_intr: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|clear
label|:
comment|/* 	 * Clear the upper byte that holds SEQINT status 	 * codes and clear the SEQINT bit. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
comment|/* 	 *  The sequencer is paused immediately on 	 *  a SEQINT, so we should restart it when 	 *  we're done. 	 */
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_scsiint
parameter_list|(
name|ahc
parameter_list|,
name|intstat
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int8_t
name|intstat
decl_stmt|;
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|u_int8_t
name|status
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|status
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIRSTI
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|channel
decl_stmt|;
name|channel
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Someone reset channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|XS_BUSY
argument_list|,
comment|/* Initiate Reset */
name|FALSE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|BUSFREE
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * First look at what phase we were last in. 		 * If its message out, chances are pretty good 		 * that the busfree was in response to one of 		 * our abort requests. 		 */
name|u_int8_t
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|u_int8_t
name|target
init|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|char
name|channel
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
name|int
name|printerror
init|=
literal|1
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastphase
operator|==
name|P_MESGOUT
condition|)
block|{
name|u_int8_t
name|sindex
decl_stmt|;
name|u_int8_t
name|message
decl_stmt|;
name|sindex
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SINDEX
argument_list|)
expr_stmt|;
name|message
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|sindex
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|==
name|MSG_ABORT
condition|)
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort Completed.\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
operator|==
name|MSG_ABORT_TAG
condition|)
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d - Abort Tag Completed.\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
operator|==
name|MSG_BUS_DEV_RESET
condition|)
block|{
name|ahc_handle_devreset
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
name|printerror
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|printerror
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
name|u_int8_t
name|tag
decl_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
condition|)
name|tag
operator|=
name|scb
operator|->
name|hscb
operator|->
name|tag
expr_stmt|;
else|else
name|tag
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LUN
argument_list|(
name|scb
argument_list|)
argument_list|,
name|tag
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX can we handle this better? 				 * Reset the bus?  Send a Bus Device Reset? 				 */
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Unexpected busfree.  LASTPHASE == 0x%x\n"
literal|"SEQADDR == 0x%x\n"
argument_list|,
name|lastphase
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SELTO
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|u_int8_t
name|scbptr
decl_stmt|;
name|u_int8_t
name|nextscb
decl_stmt|;
name|scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|==
literal|0
condition|)
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during SELTO scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQADDR = 0x%x SCSISEQ = 0x%x "
literal|"SSTAT0 = 0x%x SSTAT1 = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * XXX If we queued an abort tag, go clean up the 			 * disconnected list. 			 */
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
comment|/* 			 * Clear any pending messages for the timed out 			 * target, and mark the target as free 			 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_index_busy_target
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET
argument_list|(
name|scb
argument_list|)
argument_list|,
name|SCB_IS_SCSIBUS_B
argument_list|(
name|scb
argument_list|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Shift the waiting Q forward. */
name|nextscb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|nextscb
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the selection */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRBUSFREE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
literal|"SIMODE0 = 0x%x, SIMODE1 = 0x%x, SSTAT0 = 0x%x\n"
literal|"SEQADDR = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|status
operator|&
name|SCSIPERR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Determine the bus phase and 		 * queue an appropriate message 		 */
name|char
modifier|*
name|phase
decl_stmt|;
name|u_int8_t
name|mesg_out
init|=
name|MSG_NOOP
decl_stmt|;
name|u_int8_t
name|lastphase
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lastphase
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|phase
operator|=
literal|"Data-Out"
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|phase
operator|=
literal|"Data-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|phase
operator|=
literal|"Command"
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|phase
operator|=
literal|"Message-Out"
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|phase
operator|=
literal|"Status"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERR
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|phase
operator|=
literal|"Message-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_PARITY_ERROR
expr_stmt|;
break|break;
default|default:
name|phase
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"parity error during %s phase.\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
comment|/* 		 * We've set the hardware to assert ATN if we    		 * get a parity error on "in" phases, so all we   		 * need to do is stuff the message buffer with 		 * the appropriate message.  "In" phases have set 		 * mesg_out to something other than MSG_NOP. 		 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOOP
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* 			 * Should we allow the target to make 			 * this decision for us?  If we get a 			 * sense request from the drive, we will 			 * not fetch it since xs->error != XS_NOERROR. 			 * perhaps we need two error fields in the 			 * xs structure? 			 */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* We want to process the command */
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_handle_devreset
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|{
name|u_int16_t
name|targ_mask
decl_stmt|;
name|u_int8_t
name|targ_scratch
decl_stmt|;
name|int
name|scratch_offset
init|=
name|target
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scratch_offset
operator|+=
literal|8
expr_stmt|;
name|targ_mask
operator|=
operator|(
literal|0x01
operator|<<
name|scratch_offset
operator|)
expr_stmt|;
comment|/* 	 * Go back to async/narrow transfers and 	 * renegotiate. 	 */
name|ahc
operator|->
name|needsdtr
operator||=
name|ahc
operator|->
name|needsdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator||=
name|ahc
operator|->
name|needwdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|targ_scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_NOERROR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Bus Device Reset delivered. %d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have a scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_done
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the recovery SCB completes, we have to be 	 * out of our timeout. 	 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
condition|)
block|{
name|ahc
operator|->
name|in_timeout
operator|=
name|FALSE
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"no longer in timeout\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Put the results of the operation 	 * into the xfer and call whoever started it 	 */
comment|/* Don't override the error value. */
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|!=
literal|0
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
operator|!
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * Since NetBSD doesn't have error ignoring operation mode 	 * (SCSI_ERR_OK in FreeBSD), we don't have to care this case. 	 */
endif|#
directive|endif
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TAGENABLE
comment|/* 	 * This functionality will be provided by the generic SCSI layer  	 * in FreeBSD 3.0. 	 */
if|if
condition|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|==
name|INQUIRY
operator|&&
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|u_int16_t
name|mask
init|=
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
literal|0x08
operator|)
operator|)
decl_stmt|;
comment|/* 		 * Sneak a look at the results of the SCSI Inquiry 		 * command and see if we can do Tagged queing.  This 		 * should really be done by the higher level drivers. 		 */
name|inq_data
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|xs
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d Tagged Queuing Device\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator||=
name|mask
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|>=
literal|16
operator|||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
condition|)
block|{
comment|/* Default to 8 tags */
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Default to 4 tags on whimpy 				 * cards that don't have much SCB 				 * space and can't page.  This prevents 				 * a single device from hogging all 				 * slots.  We should really have a better 				 * way of providing fairness. 				 */
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* AHC_TAGENABLE */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
operator|(
name|SCB_MSGOUT_WDTR
operator||
name|SCB_MSGOUT_SDTR
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Turn off the pending flags for any DTR messages 		 * regardless of whether they completed successfully  		 * or not.  This ensures that we don't have lingering 		 * state after we abort an SCB. 		 */
name|u_int16_t
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_WDTR
condition|)
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_MSGOUT_SDTR
condition|)
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 	 * If we're polling, we rely on the ITS_DONE flag in the xs structure 	 * to know that the command has completed.  Unfortunately, scsi_done 	 * can cause the same xs to get requeued putting us in an infinite 	 * loop.  So, we defer the scsi_done call until the poll routine exits 	 * its loop.  I hate the way this works. 	 */
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|u_int8_t
name|scsi_conf
decl_stmt|,
name|sblkctl
decl_stmt|,
name|sxfrctl1
decl_stmt|,
name|i
decl_stmt|;
name|u_int16_t
name|ultraenable
init|=
literal|0
decl_stmt|;
name|int
name|max_targ
init|=
literal|15
decl_stmt|;
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
comment|/* Handle the SCBPAGING option */
ifndef|#
directive|ifndef
name|AHC_SCBPAGING_ENABLE
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
endif|#
directive|endif
comment|/* Determine channel configuration and who we are on the scsi bus. */
switch|switch
condition|(
operator|(
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
literal|0x0a
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_CHANNEL_B_PRIMARY
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_39X
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|channel
init|=
literal|'A'
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
operator|(
name|AHC_CHNLB
operator||
name|AHC_CHNLC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|channel
operator|=
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'C'
expr_stmt|;
name|printf
argument_list|(
literal|"Channel %c, SCSI Id=%d, "
argument_list|,
name|channel
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Single Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
operator|&
name|HWSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_CHANNEL_B_PRIMARY
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_39X
operator|)
operator|!=
literal|0
condition|)
block|{
name|char
name|channel
init|=
literal|'A'
decl_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
operator|(
name|AHC_CHNLB
operator||
name|AHC_CHNLC
operator|)
operator|)
operator|!=
literal|0
condition|)
name|channel
operator|=
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'C'
expr_stmt|;
name|printf
argument_list|(
literal|"Wide Channel %c, SCSI Id=%d, "
argument_list|,
name|channel
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"Wide Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_WIDE
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
name|WIDE_BUS
operator||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|our_id_b
operator|=
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_TWIN
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQ_FLAGS
argument_list|,
name|TWIN_BUS
operator||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Determine the number of SCBs and initialize them */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|0
condition|)
block|{
comment|/* SCB 0 heads the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AHC_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Clear the control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the next pointer */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Make the tag number invalid */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* No Busy non-tagged targets yet */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BUSYTARGETS
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BUSYTARGETS
operator|+
literal|1
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BUSYTARGETS
operator|+
literal|2
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_BUSYTARGETS
operator|+
literal|3
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Make that the last SCB terminates the free list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Ensure we clear the 0 SCB's control byte. */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|<
name|AHC_SCB_MAX
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
condition|)
block|{
name|u_int8_t
name|max_scbid
init|=
literal|255
decl_stmt|;
comment|/* Determine the number of valid bits in the FIFOs */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|max_scbid
argument_list|)
expr_stmt|;
name|max_scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|=
name|MIN
argument_list|(
name|AHC_SCB_MAX
argument_list|,
name|max_scbid
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d/%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|printf
argument_list|(
literal|"%s: hardware scb %d bytes; kernel scb %d bytes; "
literal|"ahc_dma %d bytes\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * The device is gated to channel B after a chip reset, 		 * so set those values first 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sxfrctl1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
operator|(
name|sxfrctl1
operator|&
name|STPWEN
operator|)
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|FAST20
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Resetting Channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Select Channel A */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
name|sxfrctl1
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
operator|(
name|sxfrctl1
operator|&
name|STPWEN
operator|)
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|FAST20
argument_list|)
expr_stmt|;
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Resetting Channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate synchronous transfers.  If it's zero, 	 * the user or the BIOS has decided to disable synchronous 	 * negotiation to that target so we don't activate the needsdtr 	 * flag. 	 */
name|ahc
operator|->
name|needsdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|discenable
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|discenable
operator|=
operator|~
operator|(
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|target_settings
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|target_settings
operator|=
literal|0
expr_stmt|;
comment|/* 10MHz/20MHz */
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|ultraenable
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Take the settings leftover in scratch RAM. */
name|target_settings
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_settings
operator|&
literal|0x0f
condition|)
block|{
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/*Default to a asynchronous transfers(0 offset)*/
name|target_settings
operator|&=
literal|0xf0
expr_stmt|;
block|}
if|if
condition|(
name|target_settings
operator|&
literal|0x80
condition|)
block|{
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* 				 * We'll set the Wide flag when we 				 * are successful with Wide negotiation. 				 * Turn it off for now so we aren't 				 * confused. 				 */
name|target_settings
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
block|{
comment|/* 				 * Enable Ultra for any target that 				 * has a valid ultra syncrate setting. 				 */
name|u_int8_t
name|rate
init|=
name|target_settings
operator|&
literal|0x70
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0x00
operator|||
name|rate
operator|==
literal|0x10
operator|||
name|rate
operator|==
literal|0x20
operator|||
name|rate
operator|==
literal|0x40
condition|)
block|{
if|if
condition|(
name|rate
operator|==
literal|0x40
condition|)
block|{
comment|/* Treat 10MHz specially */
name|target_settings
operator|&=
operator|~
literal|0x70
expr_stmt|;
block|}
else|else
name|ultraenable
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|i
argument_list|,
name|target_settings
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are not a WIDE device, forget WDTR.  This 	 * makes the driver work on some cards that don't 	 * leave these fields cleared when the BIOS is not 	 * installed. 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
operator|)
operator|==
literal|0
condition|)
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|=
literal|0
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|,
name|ultraenable
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|,
operator|(
name|ultraenable
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
comment|/* How did we do? */
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
literal|"DISCENABLE == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|needsdtr
argument_list|,
name|ahc
operator|->
name|needwdtr
argument_list|,
name|ahc
operator|->
name|discenable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate enough "hardware scbs" to handle 	 * the maximum number of concurrent transactions 	 * we can have active.  We have to use contigmalloc 	 * if this array crosses a page boundary since the 	 * sequencer depends on this array being physically 	 * contiguous. 	 */
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|==
name|NULL
condition|)
block|{
name|size_t
name|array_size
decl_stmt|;
name|u_int32_t
name|hscb_physaddr
decl_stmt|;
name|array_size
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|hardware_scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_size
operator|>
name|PAGE_SIZE
condition|)
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|contigmalloc
argument_list|(
name|array_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0ul
argument_list|,
literal|0xffffffff
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0x10000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|=
operator|(
expr|struct
name|hardware_scb
operator|*
operator|)
name|malloc
argument_list|(
name|array_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unable to allocate hardware SCB array.  "
literal|"Failing attach\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* At least the control byte of each hscb needs to be zeroed */
name|bzero
argument_list|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
argument_list|,
name|array_size
argument_list|)
expr_stmt|;
comment|/* Tell the sequencer where it can find the hscb array. */
name|hscb_physaddr
operator|=
name|vtophys
argument_list|(
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
argument_list|,
name|hscb_physaddr
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|1
argument_list|,
operator|(
name|hscb_physaddr
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|2
argument_list|,
operator|(
name|hscb_physaddr
operator|>>
literal|16
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|HSCB_ADDR
operator|+
literal|3
argument_list|,
operator|(
name|hscb_physaddr
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Q-Full-Count.  Some cards have more Q space 	 * then SCBs. 	 */
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_AIC7770
condition|)
block|{
name|ahc
operator|->
name|qfullcount
operator|=
literal|4
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator|=
literal|0x07
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_AIC7850
condition|)
block|{
name|ahc
operator|->
name|qfullcount
operator|=
literal|8
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator|=
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|==
literal|255
condition|)
block|{
comment|/* 7870/7880 with external SRAM */
name|ahc
operator|->
name|qfullcount
operator|=
literal|255
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
comment|/* 7870/7880 */
name|ahc
operator|->
name|qfullcount
operator|=
literal|16
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator|=
literal|0x1f
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CMDOUTCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't have any waiting selections */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Our disconnection list is empty too */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode.          */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Done\n"
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahc
operator|->
name|flags
operator||=
name|AHC_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/*  * Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|minphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address, target, and lun all of which  * are stored in the scsi_xfer struct  */
end_comment

begin_function
specifier|static
name|int32_t
name|ahc_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int16_t
name|mask
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
comment|/* 	 * get an scb to use. If the transfer 	 * is from a buf (possibly from interrupt time) 	 * then we can't allow it to sleep 	 */
if|if
condition|(
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|,
name|flags
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
comment|/* 	 * Put all the arguments for the xfer in the scb 	 */
if|if
condition|(
name|ahc
operator|->
name|discenable
operator|&
name|mask
condition|)
block|{
name|hscb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
condition|)
name|hscb
operator|->
name|control
operator||=
name|MSG_SIMPLE_Q_TAG
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|orderedtag
operator|&
name|mask
condition|)
block|{
comment|/* XXX this should be handled by the upper SCSI layer */
name|printf
argument_list|(
literal|"Ordered Tag sent\n"
argument_list|)
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MSG_ORDERED_Q_TAG
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|needwdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|ahc
operator|->
name|wdtrpending
operator||=
name|mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_WDTR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|needsdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|ahc
operator|->
name|sdtrpending
operator||=
name|mask
expr_stmt|;
name|hscb
operator|->
name|control
operator||=
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_MSGOUT_SDTR
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Set the trace flag if this is the target we want to trace */
block|if (ahc->unit == 2&& xs->sc_link->target == 3) 		hscb->control |= TRACE_SCB;
endif|#
directive|endif
name|hscb
operator|->
name|tcl
operator|=
operator|(
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator||
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|&
literal|0x07
operator|)
expr_stmt|;
name|hscb
operator|->
name|cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|hscb
operator|->
name|cmdpointer
operator|=
name|vtophys
argument_list|(
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|status
operator|=
literal|0
expr_stmt|;
comment|/* Only use S/G if non-zero length */
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
name|int
name|seg
decl_stmt|;
name|u_int32_t
name|datalen
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|u_int32_t
name|paddr
decl_stmt|;
name|u_int32_t
name|nextpaddr
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
name|hscb
operator|->
name|SG_list_pointer
operator|=
name|vtophys
argument_list|(
name|sg
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHC_NSEG
operator|)
condition|)
block|{
comment|/* put in the base address and length */
name|sg
operator|->
name|addr
operator|=
name|paddr
expr_stmt|;
name|sg
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* do it at least once */
name|nextpaddr
operator|=
name|paddr
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|paddr
operator|==
name|nextpaddr
operator|)
condition|)
block|{
name|u_int32_t
name|size
decl_stmt|;
comment|/* 				 * This page is contiguous (physically) 				 * with the the last, just extend the 				 * length 				 */
comment|/* how far to the end of the page */
name|nextpaddr
operator|=
operator|(
name|paddr
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
comment|/* 				 * Compute the maximum size 				 */
name|size
operator|=
name|nextpaddr
operator|-
name|paddr
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|datalen
condition|)
name|size
operator|=
name|datalen
expr_stmt|;
name|sg
operator|->
name|len
operator|+=
name|size
expr_stmt|;
name|vaddr
operator|+=
name|size
expr_stmt|;
name|datalen
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
literal|0
condition|)
name|paddr
operator|=
name|vtophys
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * next page isn't contiguous, finish the seg 			 */
name|seg
operator|++
expr_stmt|;
name|sg
operator|++
expr_stmt|;
block|}
name|hscb
operator|->
name|SG_segment_count
operator|=
name|seg
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
name|hscb
operator|->
name|SG_segment_count
expr_stmt|;
comment|/* Copy the first SG into the data pointer area */
name|hscb
operator|->
name|data
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|addr
expr_stmt|;
name|hscb
operator|->
name|datalen
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|len
operator||
operator|(
name|SCB_LIST_NULL
operator|<<
literal|24
operator|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"%s: ahc_scsi_cmd: more than %d DMA segs\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|AHC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
if|if
condition|(
name|ahc_broken_cache
condition|)
name|INVALIDATE_CACHE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * No data xfer, use non S/G values 	 	 */
name|hscb
operator|->
name|SG_segment_count
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|sg_count
operator|=
name|hscb
operator|->
name|SG_segment_count
expr_stmt|;
name|hscb
operator|->
name|SG_list_pointer
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|datalen
operator|=
operator|(
name|SCB_LIST_NULL
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
operator|)
operator|&&
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARGET
operator|)
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_ACTIVE
operator||
name|SCB_WAITINGQ
expr_stmt|;
name|ahc_run_waiting_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/* 	 * If we can't use interrupts, poll for completion 	 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_poll\n"
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ahc_poll
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|ahc_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
operator|==
literal|0
condition|)
do|;
comment|/* a non command complete intr */
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for space in the QINFIFO and queue as many SCBs in the waiting  * queue as possible.  Assumes that it is called at splbio().  */
end_comment

begin_function
specifier|static
name|void
name|ahc_run_waiting_queue
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|curqincnt
operator|>=
name|ahc
operator|->
name|qfullcount
condition|)
block|{
name|ahc
operator|->
name|curqincnt
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|scb
operator|=
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ahc
operator|->
name|curqincnt
operator|<
name|ahc
operator|->
name|qfullcount
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_WAITINGQ
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|!=
literal|0
condition|)
comment|/* 			 * We only care about this statistic when paging 			 * since it is impossible to overflow the qinfifo 			 * in the non-paging case. 			 */
name|ahc
operator|->
name|curqincnt
operator|++
expr_stmt|;
block|}
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*Unpause always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * An scb (and hence an scb entry on the board) is put onto the  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_free_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|opri
decl_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* Clean up for the next user */
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|links
operator|.
name|stqe_next
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * If there were no SCBs available, wake anybody waiting 		 * for one to come free. 		 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
name|ahc
operator|->
name|activescbs
operator|--
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb, either one already assigned to a hardware slot  * on the adapter or one that will require an SCB to be paged out before  * use. If there are none, see if we can allocate a new SCB.  Otherwise  * either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|ahc
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one. 	 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
operator|.
name|stqh_first
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
name|ahc_alloc_scb
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: Can't malloc SCB\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
operator|==
literal|0
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|free_scbs
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcscb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|scbp
condition|)
block|{
name|ahc
operator|->
name|activescbs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBCNT
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|activescbs
operator|==
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: Max SCBs active\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_alloc_scb
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
specifier|static
name|struct
name|ahc_dma_seg
modifier|*
name|next_sg_array
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|sg_arrays_free
init|=
literal|0
decl_stmt|;
name|struct
name|scb
modifier|*
name|newscb
decl_stmt|;
name|newscb
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newscb
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|newscb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_sg_array
operator|==
name|NULL
condition|)
block|{
name|size_t
name|alloc_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
operator|*
name|AHC_NSEG
decl_stmt|;
name|sg_arrays_free
operator|=
name|PAGE_SIZE
operator|/
name|alloc_size
expr_stmt|;
name|alloc_size
operator|*=
name|sg_arrays_free
expr_stmt|;
if|if
condition|(
name|alloc_size
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: SG list doesn't fit in a page"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|next_sg_array
operator|=
operator|(
expr|struct
name|ahc_dma_seg
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_sg_array
operator|!=
name|NULL
condition|)
block|{
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|newscb
operator|->
name|ahc_dma
operator|=
name|next_sg_array
expr_stmt|;
name|sg_arrays_free
operator|--
expr_stmt|;
if|if
condition|(
name|sg_arrays_free
operator|==
literal|0
condition|)
name|next_sg_array
operator|=
name|NULL
expr_stmt|;
else|else
name|next_sg_array
operator|=
operator|&
name|next_sg_array
index|[
name|AHC_NSEG
index|]
expr_stmt|;
name|hscb
operator|=
operator|&
name|ahc
operator|->
name|scb_data
operator|->
name|hscbs
index|[
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
index|]
expr_stmt|;
name|newscb
operator|->
name|hscb
operator|=
name|hscb
expr_stmt|;
name|hscb
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|tag
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_SG_segment_count
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
operator|++
expr_stmt|;
comment|/* 			 * Place in the scbarray 			 * Never is removed. 			 */
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|hscb
operator|->
name|tag
index|]
operator|=
name|newscb
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|newscb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|newscb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|newscb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|)
block|{
name|int
name|options
decl_stmt|;
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|downloaded
decl_stmt|;
name|u_int8_t
name|download_consts
index|[
literal|4
index|]
decl_stmt|;
name|options
operator|=
literal|1
expr_stmt|;
comment|/* Code for all options */
name|downloaded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|ULTRA
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
operator|)
operator|!=
literal|0
condition|)
name|options
operator||=
name|TWIN_CHANNEL
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|>
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|)
name|options
operator||=
name|SCB_PAGING
expr_stmt|;
comment|/* Setup downloadable constant table */
name|download_consts
index|[
name|SCBCOUNT
index|]
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
expr_stmt|;
name|download_consts
index|[
name|COMP_SCBCOUNT
index|]
operator|=
operator|-
name|ahc
operator|->
name|scb_data
operator|->
name|maxscbs
operator|&
literal|0xFF
expr_stmt|;
name|download_consts
index|[
name|FIFODEPTH
index|]
operator|=
name|ahc
operator|->
name|qfullcount
expr_stmt|;
name|download_consts
index|[
name|QCNTMASK
index|]
operator|=
name|ahc
operator|->
name|qcntmask
expr_stmt|;
name|cur_patch
operator|=
name|patches
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
operator|/
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cur_patch
operator|=
name|ahc_next_patch
argument_list|(
name|cur_patch
argument_list|,
name|options
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_patch
operator|&&
name|cur_patch
operator|->
name|begin
operator|<=
name|i
operator|&&
name|cur_patch
operator|->
name|end
operator|>
name|i
condition|)
comment|/* Skip this instruction for this configuration */
continue|continue;
name|ahc_download_instr
argument_list|(
name|ahc
argument_list|,
name|options
argument_list|,
name|i
argument_list|,
name|download_consts
argument_list|)
expr_stmt|;
name|downloaded
operator|++
expr_stmt|;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|FASTMODE
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: %d instructions downloaded\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|downloaded
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|patch
modifier|*
name|ahc_next_patch
parameter_list|(
name|cur_patch
parameter_list|,
name|options
parameter_list|,
name|instrptr
parameter_list|)
name|struct
name|patch
modifier|*
name|cur_patch
decl_stmt|;
name|int
name|options
decl_stmt|;
name|int
name|instrptr
decl_stmt|;
block|{
while|while
condition|(
name|cur_patch
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cur_patch
operator|->
name|options
operator|&
name|options
operator|)
operator|!=
literal|0
operator|&&
name|cur_patch
operator|->
name|negative
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|cur_patch
operator|->
name|options
operator|&
name|options
operator|)
operator|==
literal|0
operator|&&
name|cur_patch
operator|->
name|negative
operator|==
name|TRUE
operator|)
operator|||
operator|(
name|instrptr
operator|>=
name|cur_patch
operator|->
name|end
operator|)
condition|)
block|{
comment|/* 			 * Either we want to keep this section of code, 			 * or we have consumed this patch. Skip to the 			 * next patch. 			 */
name|cur_patch
operator|++
expr_stmt|;
if|if
condition|(
name|cur_patch
operator|->
name|options
operator|==
literal|0
condition|)
comment|/* Out of patches */
name|cur_patch
operator|=
name|NULL
expr_stmt|;
block|}
else|else
comment|/* Found an okay patch */
break|break;
block|}
return|return
operator|(
name|cur_patch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_download_instr
parameter_list|(
name|struct
name|ahc_softc
modifier|*
name|ahc
parameter_list|,
name|int
name|options
parameter_list|,
name|int
name|instrptr
parameter_list|,
name|u_int8_t
modifier|*
name|dconsts
parameter_list|)
block|{
name|u_int8_t
name|opcode
decl_stmt|;
name|struct
name|ins_format3
name|instr
decl_stmt|;
comment|/* Structure copy */
name|instr
operator|=
operator|*
operator|(
expr|struct
name|ins_format3
operator|*
operator|)
operator|&
name|seqprog
index|[
name|instrptr
operator|*
literal|4
index|]
expr_stmt|;
comment|/* Pull the opcode */
name|opcode
operator|=
operator|(
name|instr
operator|.
name|opcode_addr
operator|&
operator|~
name|DOWNLOAD_CONST_IMMEDIATE
operator|)
operator|>>
literal|1
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|AIC_OP_JMP
case|:
case|case
name|AIC_OP_JC
case|:
case|case
name|AIC_OP_JNC
case|:
case|case
name|AIC_OP_CALL
case|:
case|case
name|AIC_OP_JNE
case|:
case|case
name|AIC_OP_JNZ
case|:
case|case
name|AIC_OP_JE
case|:
case|case
name|AIC_OP_JZ
case|:
block|{
name|int
name|address_offset
decl_stmt|;
name|u_int
name|address
decl_stmt|;
name|struct
name|patch
modifier|*
name|patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|address_offset
operator|=
literal|0
expr_stmt|;
name|address
operator|=
name|instr
operator|.
name|address
expr_stmt|;
name|address
operator||=
operator|(
name|instr
operator|.
name|opcode_addr
operator|&
name|ADDR_HIGH_BIT
operator|)
operator|<<
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|patches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|patches
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|patch
operator|=
operator|&
name|patches
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|patch
operator|->
name|options
operator|&
name|options
operator|)
operator|==
literal|0
operator|&&
name|patch
operator|->
name|negative
operator|==
name|FALSE
operator|)
operator|||
operator|(
operator|(
name|patch
operator|->
name|options
operator|&
name|options
operator|)
operator|!=
literal|0
operator|&&
name|patch
operator|->
name|negative
operator|==
name|TRUE
operator|)
condition|)
block|{
if|if
condition|(
name|address
operator|>=
name|patch
operator|->
name|end
condition|)
name|address_offset
operator|+=
name|patch
operator|->
name|end
operator|-
name|patch
operator|->
name|begin
expr_stmt|;
block|}
block|}
name|address
operator|-=
name|address_offset
expr_stmt|;
name|instr
operator|.
name|address
operator|=
name|address
operator|&
literal|0xFF
expr_stmt|;
name|instr
operator|.
name|opcode_addr
operator|&=
operator|~
name|ADDR_HIGH_BIT
expr_stmt|;
name|instr
operator|.
name|opcode_addr
operator||=
operator|(
name|address
operator|>>
literal|8
operator|)
operator|&
name|ADDR_HIGH_BIT
expr_stmt|;
comment|/* FALLTHROUGH */
block|}
case|case
name|AIC_OP_OR
case|:
case|case
name|AIC_OP_AND
case|:
case|case
name|AIC_OP_XOR
case|:
case|case
name|AIC_OP_ADD
case|:
case|case
name|AIC_OP_ADC
case|:
if|if
condition|(
operator|(
name|instr
operator|.
name|opcode_addr
operator|&
name|DOWNLOAD_CONST_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
block|{
name|instr
operator|.
name|immediate
operator|=
name|dconsts
index|[
name|instr
operator|.
name|immediate
index|]
expr_stmt|;
block|}
name|instr
operator|.
name|opcode_addr
operator|&=
operator|~
name|DOWNLOAD_CONST_IMMEDIATE
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|AIC_OP_ROL
case|:
name|ahc_outsb
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
operator|&
name|instr
operator|.
name|immediate
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown opcode encountered in seq program"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when  * interrupts are disabled (crash dumps)  */
end_comment

begin_function
specifier|static
name|int
name|ahc_poll
parameter_list|(
name|ahc
parameter_list|,
name|wait
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* in msec */
block|{
while|while
condition|(
operator|--
name|wait
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
break|break;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: board is not responding\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ahc_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_timeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|found
decl_stmt|;
name|u_int8_t
name|bus_state
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_softc
operator|*
operator|)
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Ensure that the card doesn't do anything 	 * behind our back.  Also make sure that we 	 * didn't "just" miss an interrupt that would 	 * affect this timeout. 	 */
do|do
block|{
name|ahc_intr
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
do|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|printf
argument_list|(
literal|"Timedout SCB handled by another timeout\n"
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ahc
operator|->
name|in_timeout
condition|)
block|{
comment|/* 		 * Some other SCB has started a recovery operation 		 * and is still working on cleaning things up. 		 */
if|if
condition|(
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_RECOVERY_SCB
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This is not the SCB that started this timeout 			 * processing.  Give this scb another lifetime so 			 * that it can continue once we deal with the 			 * timeout. 			 */
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEDOUT
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x timedout while recovery in progress\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ahc
operator|->
name|in_timeout
operator|=
name|TRUE
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB 0x%x - timed out "
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * Take a snapshot of the bus state and print out 	 * some information so we can track down driver bugs. 	 */
name|bus_state
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_state
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|printf
argument_list|(
literal|"in dataout phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|printf
argument_list|(
literal|"in datain phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|printf
argument_list|(
literal|"in command phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|printf
argument_list|(
literal|"in message out phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|printf
argument_list|(
literal|"in status phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|printf
argument_list|(
literal|"in message in phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BUSFREE
case|:
name|printf
argument_list|(
literal|"while idle, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/*  		 * We aren't in a valid phase, so assume we're 		 * idle. 		 */
name|printf
argument_list|(
literal|"invalid phase, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", SCSISIGI == 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SEQADDR = 0x%x SCSISEQ = 0x%x SSTAT0 = 0x%x SSTAT1 = 0x%x\n"
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator||
operator|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT0
argument_list|)
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide our course of action */
name|channel
operator|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORT
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|bus_reset
label|:
name|scb
operator|->
name|flags
operator||=
name|SCB_RECOVERY_SCB
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|XS_TIMEOUT
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENTORDEREDTAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We could be starving this command 		 * try sending an ordered tag command 		 * to the target we come from. 		 */
name|u_int16_t
name|mask
decl_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator|)
operator|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENTORDEREDTAG
operator||
name|SCB_RECOVERY_SCB
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator||=
name|mask
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
literal|5
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Ordered Tag queued\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Send an Abort Message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * Our strategy here is to queue an abort message 		 * to the timed out target if it is disconnected. 		 * Otherwise, if we have an active target we stuff the 		 * message buffer with an abort message and assert ATN 		 * in the hopes that the target will let go of the bus 		 * and go to the mesgout phase.  If this fails, we'll 		 * get another timeout 2 seconds later which will attempt 		 * a bus reset. 		 */
name|u_int8_t
name|saved_scbptr
decl_stmt|;
name|u_int8_t
name|active_scb_index
decl_stmt|;
name|struct
name|scb
modifier|*
name|active_scb
decl_stmt|;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|active_scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|active_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|active_scb_index
index|]
expr_stmt|;
if|if
condition|(
name|bus_state
operator|!=
name|P_BUSFREE
condition|)
block|{
if|if
condition|(
name|active_scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
comment|/* Go "immediatly" to the bus reset */
comment|/* 				 * XXX queue an abort for the timedout SCB 				 * instead. 				 */
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Yucky Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
comment|/* Send the abort to the active SCB */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
argument_list|,
operator|(
name|active_scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|==
literal|0
condition|?
name|MSG_ABORT
else|:
name|MSG_ABORT_TAG
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|bus_state
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|active_scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"abort message in message buffer\n"
argument_list|)
expr_stmt|;
name|active_scb
operator|->
name|flags
operator||=
name|SCB_ABORT
operator||
name|SCB_RECOVERY_SCB
expr_stmt|;
if|if
condition|(
name|active_scb
operator|!=
name|scb
condition|)
block|{
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scb
argument_list|)
expr_stmt|;
comment|/* Give scb a new lease on life */
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scb
argument_list|,
operator|(
literal|2000
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|disconnected
decl_stmt|;
name|u_int8_t
name|hscb_index
decl_stmt|;
name|u_int8_t
name|linked_next
decl_stmt|;
name|disconnected
operator|=
name|FALSE
expr_stmt|;
name|hscb_index
operator|=
name|ahc_find_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|hscb_index
operator|==
name|SCB_LIST_NULL
condition|)
block|{
name|disconnected
operator|=
name|TRUE
expr_stmt|;
name|linked_next
operator|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|>>
literal|24
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|hscb_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|DISCONNECTED
condition|)
name|disconnected
operator|=
name|TRUE
expr_stmt|;
name|linked_next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LINKED_NEXT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|disconnected
condition|)
block|{
comment|/* 				 * Simply set the ABORT_SCB control bit 				 * and preserve the linked next pointer 				 */
name|scb
operator|->
name|hscb
operator|->
name|control
operator||=
name|ABORT_SCB
operator||
name|MK_MESSAGE
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator|&=
operator|~
literal|0xFF000000
expr_stmt|;
name|scb
operator|->
name|hscb
operator|->
name|datalen
operator||=
name|linked_next
operator|<<
literal|24
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
operator|==
literal|0
condition|)
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&=
operator|~
name|DISCONNECTED
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_QUEUED_ABORT
operator||
name|SCB_ABORT
operator||
name|SCB_RECOVERY_SCB
expr_stmt|;
if|if
condition|(
name|hscb_index
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int8_t
name|scb_control
decl_stmt|;
name|scb_control
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|scb_control
operator||
name|MK_MESSAGE
operator||
name|ABORT_SCB
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Actually re-queue this SCB in case we can 				 * select the device before it reconnects.  If 				 * the transaction we want to abort is not 				 * tagged, unbusy it first so that we don't 				 * get held back from sending the command. 				 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|target
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|target
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
expr_stmt|;
name|lun
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
expr_stmt|;
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|SCB_LIST_NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/*requeue*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queueing an Abort SCB\n"
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_WAITINGQ
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
literal|2000
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
comment|/* 				 * ahc_run_waiting_queue may unpause us 				 * so do this last. 				 */
name|ahc_run_waiting_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 				 * If we are using AAP, ahc_run_waiting_queue 				 * will not unpause us, so ensure we are 				 * unpaused. 				 */
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Go "immediatly" to the bus reset */
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SCB %d: Immediate reset.  "
literal|"Flags = 0x%x\n"
argument_list|,
name|scb
operator|->
name|hscb
operator|->
name|tag
argument_list|,
name|scb
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|bus_reset
goto|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look through the SCB array of the card and attempt to find the  * hardware SCB that corresponds to the passed in SCB.  Return  * SCB_LIST_NULL if unsuccessful.  This routine assumes that the  * card is already paused.  */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ahc_find_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|u_int8_t
name|saved_scbptr
decl_stmt|;
name|u_int8_t
name|curindex
decl_stmt|;
name|saved_scbptr
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
for|for
control|(
name|curindex
operator|=
literal|0
init|;
name|curindex
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|curindex
operator|++
control|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
operator|==
name|scb
operator|->
name|hscb
operator|->
name|tag
condition|)
break|break;
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_scbptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|curindex
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|)
name|curindex
operator|=
name|SCB_LIST_NULL
expr_stmt|;
return|return
name|curindex
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_search_qinfifo
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|lun
parameter_list|,
name|tag
parameter_list|,
name|flags
parameter_list|,
name|xs_error
parameter_list|,
name|requeue
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|u_int8_t
name|tag
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
name|int
name|requeue
decl_stmt|;
block|{
name|u_int8_t
name|saved_queue
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
name|int
name|queued
init|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|scb
argument_list|)
name|removed_scbs
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|removed_scbs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|queued
operator|-
name|found
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|saved_queue
index|[
name|i
index|]
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|saved_queue
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
comment|/* 			 * We found an scb that needs to be removed. 			 */
if|if
condition|(
name|requeue
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|removed_scbs
argument_list|,
name|scbp
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scbp
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|scbp
operator|->
name|flags
operator|&=
operator|~
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator|=
name|xs_error
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now put the saved scbs back. */
for|for
control|(
name|queued
operator|=
literal|0
init|;
name|queued
operator|<
name|i
condition|;
name|queued
operator|++
control|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|saved_queue
index|[
name|queued
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|requeue
condition|)
block|{
while|while
condition|(
operator|(
name|scbp
operator|=
name|removed_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|removed_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|scbp
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator||=
name|SCB_WAITINGQ
expr_stmt|;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * The device at the given target/channel has been reset.  Abort   * all active and queued scbs for that target/channel.   */
end_comment

begin_function
specifier|static
name|int
name|ahc_reset_device
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|lun
parameter_list|,
name|tag
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|u_int8_t
name|tag
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int8_t
name|active_scb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with the busy target and linked next issues. 	 */
block|{
name|int
name|min_target
decl_stmt|,
name|max_target
decl_stmt|;
name|u_int8_t
name|busy_scbid
decl_stmt|;
comment|/* Make all targets 'relative' to bus A */
if|if
condition|(
name|target
operator|==
name|ALL_TARGETS
condition|)
block|{
switch|switch
condition|(
name|channel
condition|)
block|{
case|case
literal|'A'
case|:
name|min_target
operator|=
literal|0
expr_stmt|;
name|max_target
operator|=
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|?
literal|15
else|:
literal|7
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|min_target
operator|=
literal|8
expr_stmt|;
name|max_target
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|ALL_CHANNELS
case|:
name|min_target
operator|=
literal|0
expr_stmt|;
name|max_target
operator|=
name|ahc
operator|->
name|type
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
condition|?
literal|15
else|:
literal|7
expr_stmt|;
break|break;
default|default:
comment|/* Shutup warning */
name|min_target
operator|=
literal|0
expr_stmt|;
name|max_target
operator|=
literal|0
expr_stmt|;
name|panic
argument_list|(
literal|"ahc_reset_device: Bogus Channel"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|min_target
operator|=
name|max_target
operator|=
name|target
operator|+
operator|(
name|channel
operator|==
literal|'B'
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|min_target
init|;
name|i
operator|<=
name|max_target
condition|;
name|i
operator|++
control|)
block|{
name|busy_scbid
operator|=
name|ahc_index_busy_target
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
literal|'A'
argument_list|,
comment|/*unbusy*/
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy_scbid
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|struct
name|scb
modifier|*
name|busy_scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
name|u_int8_t
name|next_scbid
decl_stmt|;
name|busy_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|busy_scbid
index|]
expr_stmt|;
name|next_scbid
operator|=
name|busy_scb
operator|->
name|hscb
operator|->
name|datalen
operator|>>
literal|24
expr_stmt|;
if|if
condition|(
name|next_scbid
operator|==
name|SCB_LIST_NULL
condition|)
block|{
name|busy_scbid
operator|=
name|ahc_find_scb
argument_list|(
name|ahc
argument_list|,
name|busy_scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|busy_scbid
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|busy_scbid
argument_list|)
expr_stmt|;
name|next_scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LINKED_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|busy_scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|ahc_index_busy_target
argument_list|(
name|ahc
argument_list|,
name|i
argument_list|,
literal|'A'
argument_list|,
comment|/*unbusy*/
name|TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_scbid
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|next_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|next_scbid
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|next_scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
continue|continue;
comment|/* Requeue for later processing */
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|next_scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|next_scb
operator|->
name|flags
operator||=
name|SCB_WAITINGQ
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Remove any entries from the Queue-In FIFO. 	 */
name|found
operator|=
name|ahc_search_qinfifo
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|,
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
argument_list|,
name|xs_error
argument_list|,
comment|/*requeue*/
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Search waiting for selection list. 	 */
block|{
name|u_int8_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Waiting List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|u_int8_t
name|linked_next
decl_stmt|;
name|next
operator|=
name|ahc_abort_wscb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|next
argument_list|,
name|prev
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
name|linked_next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_LINKED_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|linked_next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|struct
name|scb
modifier|*
name|next_scb
decl_stmt|;
comment|/* 					 * Re-queue the waiting SCB via the 					 * waiting list. 					 */
name|next_scb
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|linked_next
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ahc_match_scb
argument_list|(
name|next_scb
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|next_scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|next_scb
operator|->
name|flags
operator||=
name|SCB_WAITINGQ
expr_stmt|;
block|}
block|}
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the disconnected list and remove any entries we 	 * have queued for completion, 0'ing their control byte too. 	 */
block|{
name|u_int8_t
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|u_int8_t
name|scb_index
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_index
operator|>=
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|panic
argument_list|(
literal|"Disconnected List inconsistency. "
literal|"SCB index == %d, yet numscbs == %d."
argument_list|,
name|scb_index
argument_list|,
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_rem_scb_from_disc_list
argument_list|(
name|ahc
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the hardware SCB array looking for commands that 	 * were active but not on any list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|maxhscbs
condition|;
name|i
operator|++
control|)
block|{
name|u_int8_t
name|scbid
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbid
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|scbid
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the entire SCB array now and look for  	 * commands for this target that are still active.  These 	 * are other tagged commands that were disconnected when 	 * the reset occured or untagged commands that were linked 	 * to the command that preceeded it. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|!=
literal|0
operator|&&
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|lun
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|scbp
operator|->
name|flags
operator||=
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
expr_stmt|;
name|scbp
operator|->
name|flags
operator|&=
operator|~
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator|=
name|xs_error
expr_stmt|;
name|found
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_WAITINGQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|scbp
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator|&=
operator|~
name|SCB_WAITINGQ
expr_stmt|;
block|}
block|}
block|}
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ahc_rem_scb_from_disc_list
parameter_list|(
name|ahc
parameter_list|,
name|scbptr
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|u_int8_t
name|scbptr
decl_stmt|;
block|{
name|u_int8_t
name|next
decl_stmt|;
name|u_int8_t
name|prev
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbptr
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|prev
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_add_curscb_to_free_list
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
comment|/* Invalidate the tag so that ahc_find_scb doesn't think it's active */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|FREE_SCBH
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_char
name|ahc_abort_wscb
parameter_list|(
name|ahc
parameter_list|,
name|scbp
parameter_list|,
name|scbpos
parameter_list|,
name|prev
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_int8_t
name|scbpos
decl_stmt|;
name|u_int8_t
name|prev
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
block|{
name|u_int8_t
name|curscb
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbpos
argument_list|)
expr_stmt|;
name|next
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_curscb_to_free_list
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
comment|/* First in the list */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point us back at the original scb position 	 * and inform the SCSI system that the command 	 * has been aborted. 	 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator||=
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
expr_stmt|;
name|scbp
operator|->
name|flags
operator|&=
operator|~
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator|=
name|xs_error
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|ahc_index_busy_target
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|unbusy
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|unbusy
decl_stmt|;
block|{
name|u_int8_t
name|active_scb
decl_stmt|;
name|u_int8_t
name|info_scb
decl_stmt|;
name|u_int8_t
name|busy_scbid
decl_stmt|;
name|u_int32_t
name|scb_offset
decl_stmt|;
name|info_scb
operator|=
name|target
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|info_scb
operator|+=
literal|2
expr_stmt|;
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|info_scb
argument_list|)
expr_stmt|;
name|scb_offset
operator|=
name|SCB_BUSYTARGETS
operator|+
operator|(
name|target
operator|&
literal|0x03
operator|)
expr_stmt|;
name|busy_scbid
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|scb_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|unbusy
condition|)
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|scb_offset
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|busy_scbid
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_busy_target
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|scbid
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_int8_t
name|scbid
decl_stmt|;
block|{
name|u_int8_t
name|active_scb
decl_stmt|;
name|u_int8_t
name|info_scb
decl_stmt|;
name|u_int32_t
name|scb_offset
decl_stmt|;
name|info_scb
operator|=
name|target
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|info_scb
operator|+=
literal|2
expr_stmt|;
name|active_scb
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|info_scb
argument_list|)
expr_stmt|;
name|scb_offset
operator|=
name|SCB_BUSYTARGETS
operator|+
operator|(
name|target
operator|&
literal|0x03
operator|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|scb_offset
argument_list|,
name|scbid
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_clear_intstat
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
comment|/* Clear any interrupt conditions this may have caused */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT0
argument_list|,
name|CLRSELDO
operator||
name|CLRSELDI
operator||
name|CLRSELINGO
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
operator||
name|CLRATNO
operator||
name|CLRSCSIRSTI
operator||
name|CLRBUSFREE
operator||
name|CLRSCSIPERR
operator||
name|CLRPHASECHG
operator||
name|CLRREQINIT
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|u_int8_t
name|scsiseq
decl_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENSCSIRST
argument_list|)
expr_stmt|;
name|scsiseq
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator||
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
name|AHC_BUSRESET_DELAY
argument_list|)
expr_stmt|;
comment|/* Turn off the bus reset */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|scsiseq
operator|&
operator|~
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* Re-enable reset interrupts */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator||
name|ENSCSIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|ahc
parameter_list|,
name|channel
parameter_list|,
name|xs_error
parameter_list|,
name|initiate_reset
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
name|int
name|initiate_reset
decl_stmt|;
block|{
name|u_int32_t
name|offset
decl_stmt|,
name|offset_max
decl_stmt|;
name|int
name|found
decl_stmt|;
name|u_int8_t
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|pause_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|channel
argument_list|,
name|ALL_LUNS
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0xff00
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0x00ff
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|&=
literal|0x00ff
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
operator|+
literal|8
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|16
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0xff00
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|&=
literal|0xff00
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|8
expr_stmt|;
block|}
for|for
control|(
init|;
name|offset
operator|<
name|offset_max
condition|;
name|offset
operator|++
control|)
block|{
comment|/* 		 * Revert to async/narrow transfers 		 * until we renegotiate. 		 */
name|u_int8_t
name|targ_scratch
decl_stmt|;
name|targ_scratch
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the bus if we are initiating this reset and 	 * restart/unpause the sequencer 	 */
name|sblkctl
operator|=
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* Case 1: Command for another bus is active 		 * Stealthily reset the other bus without 		 * upsetting the current bus. 		 */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|unpause_sequencer
argument_list|(
name|ahc
argument_list|,
comment|/*unpause_always*/
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Case 2: A command from this bus is active or we're idle */
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ahc_inb
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|)
operator|&
operator|~
name|ENBUSFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_clear_intstat
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|restart_sequencer
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Untimeout our scbs now in case we have to delay our done 	 * processing. 	 */
name|ahc_untimeout_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_run_done_queue
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_QUEUED_FOR_DONE
condition|)
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_untimeout_done_queue
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|scb_data
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scb_data
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_QUEUED_FOR_DONE
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|scb
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|lun
parameter_list|,
name|tag
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|lun
decl_stmt|;
name|u_int8_t
name|tag
decl_stmt|;
block|{
name|int
name|targ
init|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|char
name|chan
init|=
operator|(
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
name|int
name|slun
init|=
name|scb
operator|->
name|hscb
operator|->
name|tcl
operator|&
literal|0x07
decl_stmt|;
name|int
name|match
decl_stmt|;
name|match
operator|=
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|||
operator|(
name|channel
operator|==
name|ALL_CHANNELS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|targ
operator|==
name|target
operator|)
operator|||
operator|(
name|target
operator|==
name|ALL_TARGETS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|lun
operator|==
name|slun
operator|)
operator|||
operator|(
name|lun
operator|==
name|ALL_LUNS
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
literal|0
condition|)
name|match
operator|=
operator|(
operator|(
name|tag
operator|==
name|scb
operator|->
name|hscb
operator|->
name|tag
operator|)
operator|||
operator|(
name|tag
operator|==
name|SCB_LIST_NULL
operator|)
operator|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_sdtr
parameter_list|(
name|ahc
parameter_list|,
name|start_byte
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|start_byte
decl_stmt|;
name|u_int8_t
name|period
decl_stmt|;
name|u_int8_t
name|offset
decl_stmt|;
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
name|start_byte
argument_list|,
name|MSG_EXTENDED
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|1
operator|+
name|start_byte
argument_list|,
name|MSG_EXT_SDTR_LEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|2
operator|+
name|start_byte
argument_list|,
name|MSG_EXT_SDTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|3
operator|+
name|start_byte
argument_list|,
name|period
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|4
operator|+
name|start_byte
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
name|start_byte
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_construct_wdtr
parameter_list|(
name|ahc
parameter_list|,
name|start_byte
parameter_list|,
name|bus_width
parameter_list|)
name|struct
name|ahc_softc
modifier|*
name|ahc
decl_stmt|;
name|int
name|start_byte
decl_stmt|;
name|u_int8_t
name|bus_width
decl_stmt|;
block|{
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
name|start_byte
argument_list|,
name|MSG_EXTENDED
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|1
operator|+
name|start_byte
argument_list|,
name|MSG_EXT_WDTR_LEN
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|2
operator|+
name|start_byte
argument_list|,
name|MSG_EXT_WDTR
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_OUT
operator|+
literal|3
operator|+
name|start_byte
argument_list|,
name|bus_width
argument_list|)
expr_stmt|;
name|ahc_outb
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
name|start_byte
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_calc_residual
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|hardware_scb
modifier|*
name|hscb
decl_stmt|;
name|int
name|resid_sgs
decl_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|hscb
operator|=
name|scb
operator|->
name|hscb
expr_stmt|;
comment|/* 	 * If the disconnected flag is still set, this is bogus 	 * residual information left over from a sequencer 	 * pagin/pageout, so ignore this case. 	 */
if|if
condition|(
operator|(
name|scb
operator|->
name|hscb
operator|->
name|control
operator|&
name|DISCONNECTED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Remainder of the SG where the transfer 		 * stopped. 		 */
name|xs
operator|->
name|resid
operator|=
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|)
expr_stmt|;
comment|/* 		 * Add up the contents of all residual 		 * SG segments that are after the SG where 		 * the transfer stopped. 		 */
name|resid_sgs
operator|=
name|scb
operator|->
name|hscb
operator|->
name|residual_SG_segment_count
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|resid_sgs
operator|>
literal|0
condition|)
block|{
name|int
name|sg
decl_stmt|;
name|sg
operator|=
name|scb
operator|->
name|sg_count
operator|-
name|resid_sgs
expr_stmt|;
name|xs
operator|->
name|resid
operator|+=
name|scb
operator|->
name|ahc_dma
index|[
name|sg
index|]
operator|.
name|len
expr_stmt|;
name|resid_sgs
operator|--
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* XXX - Update to do this right */
endif|#
directive|endif
block|}
comment|/* 	 * Clean out the residual information in this SCB for its 	 * next consumer. 	 */
name|hscb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|hscb
operator|->
name|residual_SG_segment_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled Residual of %ld bytes\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

