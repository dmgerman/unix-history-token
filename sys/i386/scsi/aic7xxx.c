begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Copyright (c) 1994, 1995 Justin T. Gibbs.  * All rights reserved.  *  * Product specific probe and attach routines can be found in:  * i386/eisa/aic7770.c	27/284X and aic7770 motherboard controllers  * pci/aic7870.c	3940, 2940, aic7870 and aic7850 controllers  *  * Portions of this driver are based on the FreeBSD 1742 Driver:  *  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * commenced: Sun Sep 27 18:14:01 PDT 1992  *  *      $Id: aic7xxx.c,v 1.52 1996/01/05 16:13:44 gibbs Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  *	Implement Target Mode  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/scsi/aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_reg.h>
end_include

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|MAX_TAGS
value|4;
end_define

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a< b) ? a : b)
end_define

begin_define
define|#
directive|define
name|ALL_TARGETS
value|-1
end_define

begin_decl_stmt
name|u_long
name|ahc_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_SHOWABORTS
operator||
name|AHC_SHOWMISC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x07
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_define
define|#
directive|define
name|HWSCSIID
value|0x0f
end_define

begin_comment
comment|/* our SCSI ID if Wide Bus */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|list_head
block|,
name|list_second
block|, }
name|insert_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|u_int32
name|ahc_adapter_info
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahcminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32
name|ahc_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|ahc_switch
init|=
block|{
name|ahc_scsi_cmd
block|,
name|ahcminphys
block|,
literal|0
block|,
literal|0
block|,
name|ahc_adapter_info
block|,
literal|"ahc"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|ahc_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"ahc"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Since the sequencer can disable pausing in a critical section, we  * must loop until it actually stops.  * XXX Should add a timeout in here??  */
end_comment

begin_define
define|#
directive|define
name|PAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb(HCNTRL + ahc->baseport, ahc->pause);		\ 								\ 	while ((inb(HCNTRL + ahc->baseport)& PAUSE) == 0)	\ 		;
end_define

begin_define
define|#
directive|define
name|UNPAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb( HCNTRL + ahc->baseport, ahc->unpause )
end_define

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_define
define|#
directive|define
name|RESTART_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|do {								\ 		outb( SEQCTL + ahc->baseport, SEQRESET|FASTMODE );	\ 	} while (inb(SEQADDR0 + ahc->baseport) != 0&&			\ 		 inb(SEQADDR1 + ahc->baseport != 0));			\ 									\ 	UNPAUSE_SEQUENCER(ahc);
end_define

begin_decl_stmt
specifier|static
name|u_char
name|ahc_abort_wscb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|,
name|u_char
name|prev
operator|,
name|u_long
name|iobase
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_add_waiting_scb
name|__P
argument_list|(
operator|(
name|u_long
name|iobase
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|,
name|insert_t
name|where
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_done
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_free_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_getscb
name|__P
argument_list|(
operator|(
name|u_long
name|iobase
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_loadseq
name|__P
argument_list|(
operator|(
name|u_long
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_match_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ahc_print_active_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_print_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_channel
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|char
name|channel
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_device
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_reset_current_bus
name|__P
argument_list|(
operator|(
name|u_long
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_scb_timeout
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_scsirate
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|u_char
operator|*
name|scsirate
operator|,
name|int
name|period
operator|,
name|int
name|offset
operator|,
name|int
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_send_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_busy_target
name|__P
argument_list|(
operator|(
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|u_long
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_unbusy_target
name|__P
argument_list|(
operator|(
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|u_long
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
argument_list|,
name|scb
argument_list|,
name|scb
operator|->
name|control
argument_list|,
name|scb
operator|->
name|target_channel_lun
argument_list|,
name|scb
operator|->
name|cmdlen
argument_list|,
name|scb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
argument_list|,
name|scb
operator|->
name|datalen
argument_list|,
name|scb
operator|->
name|data
argument_list|,
name|scb
operator|->
name|SG_segment_count
argument_list|,
name|scb
operator|->
name|SG_list_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%lx sg_len:%ld\n"
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_print_active_scb
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|cur_scb_offset
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|cur_scb_offset
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_print_scb
argument_list|(
name|ahc
operator|->
name|scbarray
index|[
name|cur_scb_offset
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PARERR
value|0x08
end_define

begin_define
define|#
directive|define
name|ILLOPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|ILLSADDR
value|0x02
end_define

begin_define
define|#
directive|define
name|ILLHADDR
value|0x01
end_define

begin_struct
specifier|static
struct|struct
block|{
name|u_char
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|PARERR
block|,
literal|"Sequencer Ram Parity Error"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|short
name|sxfr
decl_stmt|;
comment|/* Rates in Ultra mode have bit 8 of sxfr set */
define|#
directive|define
name|ULTRA_SXFR
value|0x100
name|short
name|period
decl_stmt|;
comment|/* in ns */
name|char
modifier|*
name|rate
decl_stmt|;
block|}
name|ahc_syncrates
index|[]
init|=
block|{
block|{
literal|0x100
block|,
literal|50
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x110
block|,
literal|62
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x120
block|,
literal|75
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x140
block|,
literal|100
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x000
block|,
literal|100
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x010
block|,
literal|125
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x020
block|,
literal|150
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x030
block|,
literal|175
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x040
block|,
literal|200
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x050
block|,
literal|225
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x060
block|,
literal|250
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x070
block|,
literal|275
block|,
literal|"3.6"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ahc_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|ahc_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a controller structures for a new device and initialize it.  * ahc_reset should be called before now since we assume that the card  * is paused.  *  */
end_comment

begin_function
name|struct
name|ahc_data
modifier|*
name|ahc_alloc
parameter_list|(
name|unit
parameter_list|,
name|iobase
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
name|ahc_type
name|type
decl_stmt|;
name|ahc_flag
name|flags
decl_stmt|;
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
name|ahc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|ahc
operator|->
name|baseport
operator|=
name|iobase
expr_stmt|;
name|ahc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
operator|(
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
return|return
operator|(
name|ahc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ahc_reset
parameter_list|(
name|iobase
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
block|{
name|u_char
name|hcntrl
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* Retain the IRQ type accross the chip reset */
name|hcntrl
operator|=
operator|(
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|CHIPRST
operator||
name|PAUSE
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure that the reset has finished 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
while|while
condition|(
name|wait
operator|--
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|&
name|CHIPRST
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahc at 0x%lx: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|hcntrl
operator||
name|PAUSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_scsirate
parameter_list|(
name|ahc
parameter_list|,
name|scsirate
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|,
name|target
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_char
modifier|*
name|scsirate
decl_stmt|;
name|short
name|period
decl_stmt|;
name|u_char
name|offset
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|-
name|period
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * Watch out for Ultra speeds when ultra is not 			 * enabled and vice-versa. 			 */
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: target %d requests "
literal|"%sMHz transfers, but adapter "
literal|"in Ultra mode can only sync at "
literal|"10MHz or above\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|)
expr_stmt|;
break|break;
comment|/* Use Async */
block|}
block|}
else|else
block|{
if|if
condition|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
condition|)
block|{
comment|/* 					 * This should only happen if the 					 * drive is the first to negotiate 					 * and chooses a high rate.  We'll 					 * just move down the table util 					 * we hit a non ultra speed. 					 */
continue|continue;
block|}
block|}
operator|*
name|scsirate
operator|=
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x0f
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: target %d synchronous at %sMHz,"
literal|" offset = 0x%x\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Default to asyncronous transfers.  Also reject this SDTR request. */
operator|*
name|scsirate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: target %d using asyncronous transfers\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
comment|/* 	 * fill in the prototype scsi_link. 	 */
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|ahc
operator|->
name|unit
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|ahc
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahc_switch
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|opennings
operator|=
literal|2
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahc_dev
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|DEBUGLEVEL
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|ahc
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing channel A\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* Configure the second scsi bus */
name|ahc
operator|->
name|sc_link_b
operator|=
name|ahc
operator|->
name|sc_link
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_bus
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|fordriver
operator|=
operator|(
name|void
operator|*
operator|)
name|SELBUSB
expr_stmt|;
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|&
name|ahc
operator|->
name|sc_link_b
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing Channel B\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_send_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_getscb
parameter_list|(
name|iobase
parameter_list|,
name|scb
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* SCBAUTO */
name|insb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add this SCB to the "waiting for selection" list.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_add_waiting_scb
parameter_list|(
name|iobase
parameter_list|,
name|scb
parameter_list|,
name|where
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|insert_t
name|where
decl_stmt|;
block|{
name|u_char
name|head
decl_stmt|,
name|tail
decl_stmt|;
name|u_char
name|curscb
decl_stmt|;
name|curscb
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|head
operator|=
name|inb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* List was empty */
name|head
operator|=
name|scb
operator|->
name|position
expr_stmt|;
name|tail
operator|=
name|SCB_LIST_NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|where
operator|==
name|list_head
condition|)
block|{
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|head
operator|=
name|scb
operator|->
name|position
expr_stmt|;
block|}
else|else
comment|/*where == list_second*/
block|{
name|u_char
name|third_scb
decl_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|third_scb
operator|=
name|inb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|third_scb
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|int
name|ahcintr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|intstat
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|NULL
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|arg
decl_stmt|;
name|iobase
operator|=
name|ahc
operator|->
name|baseport
expr_stmt|;
name|intstat
operator|=
name|inb
argument_list|(
name|INTSTAT
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* 	 * Is this interrupt for me? or for 	 * someone who is sharing my interrupt 	 */
if|if
condition|(
operator|!
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* We upset the sequencer :-( */
comment|/* Lookup the error message */
name|int
name|i
decl_stmt|,
name|error
init|=
name|inb
argument_list|(
name|ERROR
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|int
name|num_errors
init|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"ahc%d: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
operator|(
name|inb
argument_list|(
name|SEQADDR1
operator|+
name|iobase
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|SEQADDR0
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
block|{
name|u_short
name|targ_mask
decl_stmt|;
name|u_char
name|target
init|=
operator|(
name|inb
argument_list|(
name|SCSIID
operator|+
name|iobase
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|u_char
name|scratch_offset
init|=
name|target
decl_stmt|;
name|char
name|channel
init|=
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scratch_offset
operator|+=
literal|8
expr_stmt|;
name|targ_mask
operator|=
operator|(
literal|0x01
operator|<<
name|scratch_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|BAD_PHASE
case|:
name|panic
argument_list|(
literal|"ahc%d:%c:%d: unknown scsi bus phase.  "
literal|"Attempting to continue\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|SEND_REJECT
case|:
block|{
name|u_char
name|rejbyte
init|=
name|inb
argument_list|(
name|REJBYTE
operator|+
name|iobase
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rejbyte
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
comment|/* Tagged Message */
name|printf
argument_list|(
literal|"\nahc%d:%c:%d: Tagged message "
literal|"received without identify. "
literal|"Disabling tagged commands "
literal|"for this target.\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|&=
operator|~
name|targ_mask
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"ahc%d:%c:%d: Warning - "
literal|"unknown message recieved from "
literal|"target (0x%x).  Rejecting\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|rejbyte
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_IDENT
case|:
name|panic
argument_list|(
literal|"ahc%d:%c:%d: Target did not send an IDENTIFY "
literal|"message. SAVED_TCL == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|inb
argument_list|(
name|SAVED_TCL
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_MATCH
case|:
block|{
name|printf
argument_list|(
literal|"ahc%d:%c:%d: no active SCB for "
literal|"reconnecting target - "
literal|"issuing ABORT\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_TCL == 0x%x\n"
argument_list|,
name|inb
argument_list|(
name|SAVED_TCL
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|target
argument_list|,
name|channel
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|NEEDDMA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SDTR_MSG
case|:
block|{
name|short
name|period
decl_stmt|;
name|u_char
name|offset
decl_stmt|,
name|rate
decl_stmt|;
name|u_char
name|targ_scratch
decl_stmt|;
name|u_char
name|maxoffset
decl_stmt|;
comment|/*  				 * Help the sequencer to translate the  				 * negotiated transfer rate.  Transfer is  				 * 1/4 the period in ns as is returned by  				 * the sync negotiation message.  So, we must  				 * multiply by four 				 */
name|period
operator|=
name|inb
argument_list|(
name|ARG_1
operator|+
name|iobase
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|offset
operator|=
name|inb
argument_list|(
name|ACCUM
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|targ_scratch
operator|=
name|inb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_scratch
operator|&
name|WIDEXFER
condition|)
name|maxoffset
operator|=
literal|0x08
expr_stmt|;
else|else
name|maxoffset
operator|=
literal|0x0f
expr_stmt|;
name|ahc_scsirate
argument_list|(
name|ahc
argument_list|,
operator|&
name|rate
argument_list|,
name|period
argument_list|,
name|MIN
argument_list|(
name|offset
argument_list|,
name|maxoffset
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Preserve the WideXfer flag */
name|targ_scratch
operator|=
name|rate
operator||
operator|(
name|targ_scratch
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
name|outb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
operator|+
name|iobase
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_scratch
operator|&
literal|0x0f
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The requested rate was so low 					 * that asyncronous transfers are 					 * faster (not to mention the 					 * controller won't support them), 					 * so we issue a message reject to 					 * ensure we go to asyncronous 					 * transfers. 					 */
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
block|}
comment|/* See if we initiated Sync Negotiation */
elseif|else
if|if
condition|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* 					 * Don't send an SDTR back to 					 * the target 					 */
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Send our own SDTR in reply 					 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"Sending SDTR!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Negate the flags 				 */
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
break|break;
block|}
case|case
name|WDTR_MSG
case|:
block|{
name|u_char
name|scratch
decl_stmt|,
name|bus_width
decl_stmt|;
name|bus_width
operator|=
name|inb
argument_list|(
name|ARG_1
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|inb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* 					 * Don't send a WDTR back to the 					 * target, since we asked first. 					 */
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: target "
literal|"%d using 16Bit "
literal|"transfers\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x80
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
comment|/* 						     * How can we do 32bit 						     * transfers on a 16bit 						     * bus? 						     */
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target "
literal|"%d requested 32Bit "
literal|"transfers.  "
literal|"Rejecting...\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * Send our own WDTR in reply 					 */
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
comment|/* Negotiate 16_BITS */
name|bus_width
operator|=
name|BUS_16_BIT
expr_stmt|;
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: target "
literal|"%d using 16Bit "
literal|"transfers\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x80
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
name|bus_width
operator||
name|SEND_WDTR
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|outb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
operator|+
name|iobase
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REJECT_MSG
case|:
block|{
comment|/* 				 * What we care about here is if we had an 				 * outstanding SDTR or WDTR message for this 				 * target.  If we did, this is a signal that 				 * the target is refusing negotiation. 				 */
name|u_char
name|targ_scratch
decl_stmt|;
name|targ_scratch
operator|=
name|inb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* note 8bit xfers and clear flag */
name|targ_scratch
operator|&=
literal|0x7f
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d:%c:%d: refuses "
literal|"WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|targ_scratch
operator|&=
literal|0xf0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d:%c:%d: refuses "
literal|"syncronous negotiation.  Using "
literal|"asyncronous transfers\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Otherwise, we ignore it. 					 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"ahc%d:%c:%d: Message  							reject -- ignored\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|outb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
operator|+
name|iobase
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_STATUS
case|:
block|{
name|int
name|scb_index
decl_stmt|;
comment|/* The sequencer will notify us when a command                            * has an error that would be of interest to                            * the kernel.  This allows us to leave the sequencer                            * running in the common case of command completes                            * without error.                            */
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 			   * Set the default return value to 0 (don't 			   * send sense).  The sense code will change 			   * this if needed and this reduces code 			   * duplication. 			   */
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d:%c:%d: ahcintr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|ahc_getscb
argument_list|(
name|iobase
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
operator|)
operator|&&
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|status
operator|=
name|scb
operator|->
name|target_status
expr_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|target_status
condition|)
block|{
case|case
name|SCSI_OK
case|:
name|printf
argument_list|(
literal|"ahc%d: Interrupted for staus of"
literal|" 0???\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_CHECK
case|:
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"requests Check Status\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|)
operator|&&
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|u_char
name|control
init|=
name|scb
operator|->
name|control
decl_stmt|;
name|u_short
name|active
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|&
operator|(
name|scb
operator|->
name|sense_cmd
operator|)
decl_stmt|;
name|u_char
name|tcl
init|=
name|scb
operator|->
name|target_channel_lun
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
name|scb
operator|->
name|control
operator||=
name|control
operator|&
name|DISCENB
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|sc
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|KVTOPHYS
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|scb
operator|->
name|target_channel_lun
operator|=
name|tcl
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|sg
operator|->
name|len
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* 					 * Ensure that the target is "BUSY" 					 * so we don't get overlapping  					 * commands if we happen to be doing 					 * tagged I/O. 					 */
name|ahc_busy_target
argument_list|(
name|target
argument_list|,
name|channel
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
comment|/* 					 * Make us the next command to run 					 */
name|ahc_add_waiting_scb
argument_list|(
name|iobase
argument_list|,
name|scb
argument_list|,
name|list_head
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|RETURN_1
operator|+
name|iobase
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * Clear the SCB_SENSE Flag and have 				 * the sequencer do a normal command 				 * complete with either a "DRIVER_STUFFUP" 				 * error or whatever other error condition 				 * we already had. 				 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target Busy\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_QUEUE_FULL
case|:
comment|/* 				 * The upper level SCSI code will eventually 				 * handle this properly. 				 */
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queue Full\n"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
break|break;
default|default:
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|scb
operator|->
name|target_status
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|RESIDUAL
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
comment|/* 			 * Don't clobber valid resid info with 			 * a resid coming from a check sense 			 * operation. 			 */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|int
name|resid_sgs
decl_stmt|;
comment|/* 				 * Remainder of the SG where the transfer 				 * stopped. 				 */
name|scb
operator|->
name|xs
operator|->
name|resid
operator|=
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|SCB_RESID_DCNT2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|inb
argument_list|(
name|iobase
operator|+
name|SCB_RESID_DCNT1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|iobase
operator|+
name|SCB_RESID_DCNT0
argument_list|)
expr_stmt|;
comment|/* 				 * Add up the contents of all residual 				 * SG segments that are after the SG where 				 * the transfer stopped. 				 */
name|resid_sgs
operator|=
name|inb
argument_list|(
name|SCB_RESID_SGCNT
operator|+
name|iobase
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|resid_sgs
operator|>
literal|0
condition|)
block|{
name|int
name|sg
decl_stmt|;
name|sg
operator|=
name|scb
operator|->
name|SG_segment_count
operator|-
name|resid_sgs
expr_stmt|;
name|scb
operator|->
name|xs
operator|->
name|resid
operator|+=
name|scb
operator|->
name|ahc_dma
index|[
name|sg
index|]
operator|.
name|len
expr_stmt|;
name|resid_sgs
operator|--
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled Residual of %ld bytes\n"
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
case|case
name|ABORT_TAG
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
comment|/* 			 * We didn't recieve a valid tag back from 			 * the target on a reconnect. 			 */
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"invalid tag recieved -- sending ABORT_TAG\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AWAITING_MSG
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 			 * This SCB had a zero length command, informing 			 * the sequencer that we wanted to send a special 			 * message to this target.  We only do this for 			 * BUS_DEVICE_RESET messages currently. 			 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|outb
argument_list|(
name|MSG0
operator|+
name|iobase
argument_list|,
name|MSG_BUS_DEVICE_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ahcintr: AWAITING_MSG for an SCB that"
literal|"does not have a waiting message"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IMMEDDONE
case|:
block|{
comment|/* 			 * Take care of device reset messages 			 */
name|u_char
name|scbindex
init|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scbindex
index|]
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|u_char
name|targ_scratch
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 				 * Go back to async/narrow transfers and 				 * renegotiate. 				 */
name|ahc_unbusy_target
argument_list|(
name|target
argument_list|,
name|channel
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator||=
name|ahc
operator|->
name|needsdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator||=
name|ahc
operator|->
name|needwdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|targ_scratch
operator|=
name|inb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|outb
argument_list|(
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_NOERROR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset delivered. "
literal|"%d SCBs aborted\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|panic
argument_list|(
literal|"ahcintr: Immediate complete for "
literal|"unknown operation."
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|NOT_YET
comment|/* XXX Fill these in later */
case|case
name|MESG_BUFFER_BUSY
case|:
break|break;
case|case
name|MSGIN_PHASEMIS
case|:
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"ahc: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|inb
argument_list|(
name|SCSISIGI
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|clear
label|:
comment|/* 		 * Clear the upper byte that holds SEQINT status 		 * codes and clear the SEQINT bit. 		 */
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
comment|/* 		 *  The sequencer is paused immediately on 		 *  a SEQINT, so we should restart it when 		 *  we leave this section. 		 */
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
block|{
name|int
name|scb_index
init|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|SSTAT1
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: ahcintr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cmdcomplete
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SELTO
condition|)
block|{
name|u_char
name|waiting
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|ENRSELI
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
comment|/* 			 * Clear any pending messages for the timed out 			 * target, and mark the target as free 			 */
name|flags
operator|=
name|inb
argument_list|(
name|FLAGS
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
operator|(
operator|(
name|long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|NEEDDMA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
comment|/* Shift the waiting for selection queue forward */
name|waiting
operator|=
name|inb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|inb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|SCSIPERR
condition|)
block|{
comment|/* 			 * Determine the bus phase and 			 * queue an appropriate message 			 */
name|char
modifier|*
name|phase
decl_stmt|;
name|u_char
name|mesg_out
init|=
name|MSG_NOP
decl_stmt|;
name|u_char
name|sigstate
init|=
name|inb
argument_list|(
name|SIGSTATE
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sigstate
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|phase
operator|=
literal|"Data-Out"
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|phase
operator|=
literal|"Data-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERROR
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|phase
operator|=
literal|"Command"
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|phase
operator|=
literal|"Message-Out"
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|phase
operator|=
literal|"Status"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERROR
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|phase
operator|=
literal|"Message-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_MSG_PARITY_ERROR
expr_stmt|;
break|break;
default|default:
name|phase
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"parity error during %s phase.\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
comment|/* 			 * We've set the hardware to assert ATN if we 			 * get a parity error on "in" phases, so all we 			 * need to do is stuff the message buffer with 			 * the appropriate message.  In phases have set 			 * mesg_out to something other than MSG_NOP. 			 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOP
condition|)
block|{
name|outb
argument_list|(
name|MSG0
operator|+
name|iobase
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 				 * Should we allow the target to make 				 * this decision for us? 				 */
name|scb
operator|->
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
comment|/* Don't ahc_done the scb */
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|BUSFREE
operator|)
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* We want to process the command */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdcomplete
label|:
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|int
name|scb_index
decl_stmt|;
do|do
block|{
name|scb_index
operator|=
name|inb
argument_list|(
name|QOUTFIFO
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: WARNING "
literal|"no command for scb %d (cmdcmplt)\n"
literal|"QOUTCNT == %d\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|scb_index
argument_list|,
name|inb
argument_list|(
name|QOUTCNT
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|QOUTCNT
operator|+
name|iobase
argument_list|)
condition|)
do|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ahc_eisa_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ahcintr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have a scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_done
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*          * Put the results of the operation          * into the xfer and call whoever started it          */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
operator|!
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TAGENABLE
if|if
condition|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|==
literal|0x12
operator|&&
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|u_short
name|mask
init|=
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|scb
operator|->
name|target_channel_lun
operator|&
literal|0x08
operator|)
operator|)
decl_stmt|;
comment|/* 		 * Sneak a look at the results of the SCSI Inquiry 		 * command and see if we can do Tagged queing.  This 		 * should really be done by the higher level drivers. 		 */
name|inq_data
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|xs
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: target %d Tagged Queuing Device\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator||=
name|mask
expr_stmt|;
ifdef|#
directive|ifdef
name|QUEUE_FULL_SUPPORTED
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|u_char
name|scsi_conf
decl_stmt|,
name|sblkctl
decl_stmt|,
name|i
decl_stmt|;
name|int
name|max_targ
init|=
literal|15
decl_stmt|;
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
comment|/* Determine channel configuration and who we are on the scsi bus. */
switch|switch
condition|(
operator|(
name|sblkctl
operator|=
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
operator|&
literal|0x0a
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|SCSICONF
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_394
condition|)
name|printf
argument_list|(
literal|"Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Single Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|FLAGS
operator|+
name|iobase
argument_list|,
name|SINGLE_BUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|)
operator|&
name|HWSCSIID
operator|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_394
condition|)
name|printf
argument_list|(
literal|"Wide Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Wide Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_WIDE
expr_stmt|;
name|outb
argument_list|(
name|FLAGS
operator|+
name|iobase
argument_list|,
name|WIDE_BUS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|SCSICONF
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|our_id_b
operator|=
operator|(
name|inb
argument_list|(
name|SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_TWIN
expr_stmt|;
name|outb
argument_list|(
name|FLAGS
operator|+
name|iobase
argument_list|,
name|TWIN_BUS
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|struct
name|scb
name|test
decl_stmt|;
name|printf
argument_list|(
literal|"ahc%d: hardware scb %ld bytes; kernel scb; "
literal|"ahc_dma %d bytes\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
operator|(
name|u_long
operator|)
operator|&
operator|(
name|test
operator|.
name|next
operator|)
operator|-
call|(
name|u_long
call|)
argument_list|(
operator|&
name|test
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * The device is gated to channel B after a chip reset, 		 * so set those values first 		 */
name|outb
argument_list|(
name|SCSIID
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|inb
argument_list|(
name|SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|)
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL1
operator|+
name|iobase
argument_list|,
name|scsi_conf
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
operator|+
name|iobase
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|outb
argument_list|(
name|SXFRCTL0
operator|+
name|iobase
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|ULTRAEN
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|SXFRCTL0
operator|+
name|iobase
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* Reset the bus */
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Select Channel A */
name|outb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|SCSIID
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|inb
argument_list|(
name|SCSICONF
operator|+
name|iobase
argument_list|)
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
expr_stmt|;
name|outb
argument_list|(
name|SXFRCTL1
operator|+
name|iobase
argument_list|,
name|scsi_conf
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SIMODE1
operator|+
name|iobase
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|outb
argument_list|(
name|SXFRCTL0
operator|+
name|iobase
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|ULTRAEN
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|SXFRCTL0
operator|+
name|iobase
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
comment|/* Reset the bus */
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate syncronous transfers.  If it's zero, 	 * the user or the BIOS has decided to disable syncronous 	 * negotiation to that target so we don't activate the needsdtr 	 * flag. 	 */
name|ahc
operator|->
name|needsdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|discenable
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|discenable
operator|=
operator|~
operator|(
operator|(
name|inb
argument_list|(
name|DISC_DSB
operator|+
name|iobase
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|DISC_DSB
operator|+
name|iobase
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|u_char
name|target_settings
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|target_settings
operator|=
literal|0
expr_stmt|;
comment|/* 10MHz */
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Take the settings leftover in scratch RAM. */
name|target_settings
operator|=
name|inb
argument_list|(
name|TARG_SCRATCH
operator|+
name|i
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_settings
operator|&
literal|0x0f
condition|)
block|{
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/*Default to a asyncronous transfers(0 offset)*/
name|target_settings
operator|&=
literal|0xf0
expr_stmt|;
block|}
if|if
condition|(
name|target_settings
operator|&
literal|0x80
condition|)
block|{
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* 				 * We'll set the Wide flag when we 				 * are successful with Wide negotiation. 				 * Turn it off for now so we aren't 				 * confused. 				 */
name|target_settings
operator|&=
literal|0x7f
expr_stmt|;
block|}
block|}
name|outb
argument_list|(
name|TARG_SCRATCH
operator|+
name|i
operator|+
name|iobase
argument_list|,
name|target_settings
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are not a WIDE device, forget WDTR.  This 	 * makes the driver work on some cards that don't 	 * leave these fields cleared when the BIOS is not 	 * installed. 	 */
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
operator|)
condition|)
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
comment|/* How did we do? */
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
literal|"DISCENABLE == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|needsdtr
argument_list|,
name|ahc
operator|->
name|needwdtr
argument_list|,
name|ahc
operator|->
name|discenable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clear the control byte for every SCB so that the sequencer 	 * doesn't get confused and think that one of them is valid 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|maxscbs
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the number of availible SCBs 	 */
name|outb
argument_list|(
name|SCBCOUNT
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
comment|/* 	 * 2s compliment of SCBCOUNT 	 */
name|i
operator|=
name|ahc
operator|->
name|maxscbs
expr_stmt|;
name|outb
argument_list|(
name|COMP_SCBCOUNT
operator|+
name|iobase
argument_list|,
operator|-
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* We don't have any busy targets right now */
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_B
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't have any waiting selections */
name|outb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|WAITING_SCBT
operator|+
name|iobase
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|outb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode.          */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Downloading Sequencer Program..."
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Done\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|FASTMODE
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahc
operator|->
name|flags
operator|=
name|AHC_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/*  * Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address, target, and lun all of which  * are stored in the scsi_xfer struct  */
end_comment

begin_function
specifier|static
name|int32
name|ahc_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_short
name|mask
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
operator|(
name|u_long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
literal|0x08
operator|)
operator|)
operator|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*          * get an scb to use. If the transfer          * is from a buf (possibly from interrupt time)          * then we can't allow it to sleep          */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Already done?"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Not in use?"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_IMMED
expr_stmt|;
comment|/*          * Put all the arguments for the xfer in the scb          */
if|if
condition|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
condition|)
name|scb
operator|->
name|control
operator||=
name|TAG_ENB
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|discenable
operator|&
name|mask
condition|)
name|scb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
if|if
condition|(
operator|(
name|ahc
operator|->
name|needwdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|scb
operator|->
name|control
operator||=
name|NEEDWDTR
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator||=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|needsdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|scb
operator|->
name|control
operator||=
name|NEEDSDTR
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator||=
name|mask
expr_stmt|;
block|}
name|scb
operator|->
name|target_channel_lun
operator|=
operator|(
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
literal|0x08
operator|)
operator||
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|&
literal|0x07
operator|)
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|scb
operator|->
name|ahc_dma
argument_list|)
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
block|{
comment|/*                          * Set up the scatter gather block                          */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%ld @%p:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHC_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%lx"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 					 * This page is contiguous (physically) 					 * with the the last, just extend the 					 * length 					 */
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/*                                  * next page isn't contiguous, finish the seg                                  */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of iov/kv decision */
name|scb
operator|->
name|SG_segment_count
operator|=
name|seg
expr_stmt|;
comment|/* Copy the first SG into the data pointer area */
name|scb
operator|->
name|data
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"ahc_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|AHC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * No data xfer, use non S/G values 	 	 */
name|scb
operator|->
name|SG_segment_count
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
operator|)
operator|&&
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
operator|)
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return some information to the caller about  * the adapter and it's capabilities.  */
end_comment

begin_function
specifier|static
name|u_int32
name|ahc_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * A scb (and hence an scb entry on the board is put onto the  * free list.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_free_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|ahc
operator|->
name|free_scb
expr_stmt|;
name|ahc
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
name|ahc
operator|->
name|activescbs
operator|--
expr_stmt|;
endif|#
directive|endif
comment|/*          * If there were none, wake abybody waiting for          * one to come free, starting with queued entries          */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb  * If there are none, see if we can allocate a  * new one.  Otherwise either return an error or sleep  */
end_comment

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|ahc
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|opri
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*          * If we can and have to, sleep waiting for one to come free          * but only if we can't allocate a new one.          */
while|while
condition|(
operator|!
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|free_scb
operator|)
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
name|physaddr
name|scbaddr
init|=
name|KVTOPHYS
argument_list|(
name|scbp
argument_list|)
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|u_char
name|curscb
decl_stmt|;
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|position
operator|=
name|ahc
operator|->
name|numscbs
expr_stmt|;
name|ahc
operator|->
name|numscbs
operator|++
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* 				 * Place in the scbarray 				 * Never is removed.  Position 				 * in ahc->scbarray is the scbarray 				 * position on the board we will 				 * load it into. 				 */
name|ahc
operator|->
name|scbarray
index|[
name|scbp
operator|->
name|position
index|]
operator|=
name|scbp
expr_stmt|;
comment|/* 				 * Initialize the host memory location 				 * of this SCB down on the board and 				 * flag that it should be DMA's before 				 * reference.  Also set its psuedo 				 * next pointer (for use in the psuedo 				 * list of SCBs waiting for selection) 				 * to SCB_LIST_NULL. 				 */
name|scbp
operator|->
name|control
operator|=
name|NEEDDMA
expr_stmt|;
name|scbp
operator|->
name|host_scb
operator|=
name|scbaddr
expr_stmt|;
name|scbp
operator|->
name|next_waiting
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|curscb
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scbp
argument_list|,
name|SCB_HARDWARE_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|control
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc%d: Can't malloc SCB\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcscb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|scbp
condition|)
block|{
comment|/* Get SCB from from free list */
name|ahc
operator|->
name|free_scb
operator|=
name|scbp
operator|->
name|next
expr_stmt|;
name|scbp
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
name|ahc
operator|->
name|activescbs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBCNT
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|activescbs
operator|==
name|ahc
operator|->
name|maxscbs
operator|)
condition|)
name|printf
argument_list|(
literal|"ahc%d: Max SCBs active\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|iobase
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|seqprog
index|[]
init|=
block|{
include|#
directive|include
file|"aic7xxx_seq.h"
block|}
decl_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|PERRORDIS
operator||
name|SEQRESET
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SEQRAM
operator|+
name|iobase
argument_list|,
name|seqprog
argument_list|,
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
do|do
block|{
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|SEQRESET
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|SEQADDR0
operator|+
name|iobase
argument_list|)
operator|!=
literal|0
operator|&&
name|inb
argument_list|(
name|SEQADDR1
operator|+
name|iobase
operator|!=
literal|0
argument_list|)
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_scb_timeout
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|char
name|channel
init|=
name|scb
operator|->
name|target_channel_lun
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
comment|/* 	 * Ensure that the card doesn't do anything 	 * behind our back. 	 */
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * First, determine if we want to do a bus 	 * reset or simply a bus device reset. 	 * If this is the first time that a transaction 	 * has timed out, just schedule a bus device 	 * reset.  Otherwise, we reset the bus and 	 * abort all pending I/Os on that bus. 	 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|scb
operator|->
name|position
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
name|printf
argument_list|(
literal|"ahc%d: Issued Channel %c Bus Reset #1. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * Send a Bus Device Reset Message: 		 * The target we select to send the message to may 		 * be entirely different than the target pointed to 		 * by the scb that timed out.  If the command is 		 * in the QINFIFO or the waiting for selection list, 		 * its not tying up the bus and isn't responsible 		 * for the delay so we pick off the active command 		 * which should be the SCB selected by SCBPTR.  If 		 * its disconnected or active, we device reset the 		 * target scbp points to.  Although it may be that 		 * this target is not responsible for the delay, it 		 * may also be that we're timing out on a command that 		 * just takes too much time, so we try the bus device 		 * reset there first. 		 */
name|u_char
name|active_scb
decl_stmt|,
name|control
decl_stmt|;
name|struct
name|scb
modifier|*
name|active_scbp
decl_stmt|;
name|active_scb
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|active_scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|active_scb
index|]
expr_stmt|;
name|control
operator|=
name|inb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* Test to see if scbp is disconnected */
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|SCB_CONTROL
operator|+
name|iobase
argument_list|)
operator|&
name|DISCONNECTED
condition|)
block|{
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORTED
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_add_waiting_scb
argument_list|(
name|iobase
argument_list|,
name|scb
argument_list|,
name|list_second
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
literal|2
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BUS DEVICE RESET message queued.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Is the active SCB really active? */
elseif|else
if|if
condition|(
operator|(
name|active_scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|&&
operator|(
name|control
operator|&
name|NEEDDMA
operator|)
operator|==
name|NEEDDMA
condition|)
block|{
name|u_char
name|msg_len
init|=
name|inb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg_len
condition|)
block|{
comment|/* 			 * If we're in a message phase, tacking on  			 * another message may confuse the target totally. 			 * The bus is probably wedged, so reset the 			 * channel. 			 */
name|channel
operator|=
operator|(
name|active_scbp
operator|->
name|target_channel_lun
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|scb
operator|->
name|position
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
name|printf
argument_list|(
literal|"ahc%d: Issued Channel %c Bus Reset #2. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/*  			 * Load the message buffer and assert attention. 			 */
name|active_scbp
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORTED
expr_stmt|;
if|if
condition|(
name|active_scbp
operator|!=
name|scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scbp
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scbp
argument_list|,
operator|(
literal|2
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MSG_LEN
operator|+
name|iobase
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|MSG0
operator|+
name|iobase
argument_list|,
name|MSG_BUS_DEVICE_RESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|active_scbp
operator|->
name|target_channel_lun
operator|!=
name|scb
operator|->
name|target_channel_lun
condition|)
block|{
comment|/* Give scb a new lease on life */
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
block|{
name|sc_print_addr
argument_list|(
name|active_scbp
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BUS DEVICE RESET message queued.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * No active command to single out, so reset 			 * the bus for the timed out target. 			 */
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|scb
operator|->
name|position
argument_list|,
name|XS_TIMEOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWABORTS
condition|)
name|printf
argument_list|(
literal|"ahc%d: Issued Channel %c Bus Reset #3. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc
operator|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target %d, lun %d (%s%d) timed out\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSIDEBUG
name|show_scsi_cmd
argument_list|(
name|scb
operator|->
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
condition|)
name|ahc_print_active_scb
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHC_DEBUG */
comment|/* 	 * If it's immediate, don't try to abort it 	 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_IMMED
condition|)
block|{
name|scb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* abort the operation that has timed out */
name|ahc_scb_timeout
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The device at the given target/channel has been reset.  Abort   * all active and queued scbs for that target/channel.   */
end_comment

begin_function
specifier|static
name|int
name|ahc_reset_device
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32
name|xs_error
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_char
name|active_scb
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* 	 * Search the QINFIFO. 	 */
block|{
name|int
name|saved_queue
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
name|int
name|queued
init|=
name|inb
argument_list|(
name|QINCNT
operator|+
name|iobase
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|queued
operator|-
name|found
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|saved_queue
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|saved_queue
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
comment|/* 				 * We found an scb that needs to be aborted. 				 */
name|scbp
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|position
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|NEEDDMA
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now put the saved scbs back. */
for|for
control|(
name|queued
operator|=
literal|0
init|;
name|queued
operator|<
name|i
condition|;
name|queued
operator|++
control|)
block|{
name|outb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|,
name|saved_queue
index|[
name|queued
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Search waiting for selection list. 	 */
block|{
name|u_char
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|inb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|next
index|]
expr_stmt|;
comment|/* 			 * Select the SCB. 			 */
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_abort_wscb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|prev
argument_list|,
name|iobase
argument_list|,
name|timedout_scb
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|inb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the entire SCB array now and look for  	 * commands for this target that are active.  These 	 * are other (most likely tagged) commands that  	 * were disconnected when the reset occured. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|&&
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
comment|/* Ensure the target is "free" */
name|ahc_unbusy_target
argument_list|(
name|target
argument_list|,
name|channel
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|NEEDDMA
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|position
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_char
name|ahc_abort_wscb
parameter_list|(
name|ahc
parameter_list|,
name|scbp
parameter_list|,
name|prev
parameter_list|,
name|iobase
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_char
name|prev
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32
name|xs_error
decl_stmt|;
block|{
name|u_char
name|curscbp
decl_stmt|,
name|next
decl_stmt|;
name|int
name|target
init|=
operator|(
operator|(
name|scbp
operator|->
name|target_channel_lun
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
decl_stmt|;
name|char
name|channel
init|=
operator|(
name|scbp
operator|->
name|target_channel_lun
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscbp
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|next
operator|=
name|inb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|NEEDDMA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|target
argument_list|,
name|channel
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
comment|/* First in the list */
name|outb
argument_list|(
name|WAITING_SCBH
operator|+
name|iobase
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCB_NEXT_WAITING
operator|+
name|iobase
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Update the tale pointer */
if|if
condition|(
name|inb
argument_list|(
name|WAITING_SCBT
operator|+
name|iobase
argument_list|)
operator|==
name|scbp
operator|->
name|position
condition|)
name|outb
argument_list|(
name|WAITING_SCBT
operator|+
name|iobase
argument_list|,
name|prev
argument_list|)
expr_stmt|;
comment|/* 	 * Point us back at the original scb position 	 * and inform the SCSI system that the command 	 * has been aborted. 	 */
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|curscbp
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|position
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_busy_target
parameter_list|(
name|target
parameter_list|,
name|channel
parameter_list|,
name|iobase
parameter_list|)
name|u_char
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
block|{
name|u_char
name|active
decl_stmt|;
name|u_long
name|active_port
init|=
name|ACTIVE_A
operator|+
name|iobase
decl_stmt|;
if|if
condition|(
name|target
operator|>
literal|0x07
operator|||
name|channel
operator|==
literal|'B'
condition|)
block|{
comment|/*  		 * targets on the Second channel or 		 * above id 7 store info in byte two  		 * of HA_ACTIVE 		 */
name|active_port
operator|++
expr_stmt|;
block|}
name|active
operator|=
name|inb
argument_list|(
name|active_port
argument_list|)
expr_stmt|;
name|active
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|outb
argument_list|(
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_unbusy_target
parameter_list|(
name|target
parameter_list|,
name|channel
parameter_list|,
name|iobase
parameter_list|)
name|u_char
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
block|{
name|u_char
name|active
decl_stmt|;
name|u_long
name|active_port
init|=
name|ACTIVE_A
operator|+
name|iobase
decl_stmt|;
if|if
condition|(
name|target
operator|>
literal|0x07
operator|||
name|channel
operator|==
literal|'B'
condition|)
block|{
comment|/*  		 * targets on the Second channel or 		 * above id 7 store info in byte two  		 * of HA_ACTIVE 		 */
name|active_port
operator|++
expr_stmt|;
block|}
name|active
operator|=
name|inb
argument_list|(
name|active_port
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|outb
argument_list|(
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|iobase
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
block|{
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|ahc
parameter_list|,
name|channel
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32
name|xs_error
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|u_char
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|u_long
name|offset
decl_stmt|,
name|offset_max
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|channel
argument_list|,
name|timedout_scb
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0xff00
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0x00ff
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_B
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
literal|8
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_B
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
literal|16
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0xff00
expr_stmt|;
name|outb
argument_list|(
name|ACTIVE_A
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
name|iobase
operator|+
literal|8
expr_stmt|;
block|}
for|for
control|(
init|;
name|offset
operator|<
name|offset_max
condition|;
name|offset
operator|++
control|)
block|{
comment|/* 		 * Revert to async/narrow transfers 		 * until we renegotiate. 		 */
name|u_char
name|targ_scratch
decl_stmt|;
name|targ_scratch
operator|=
name|inb
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|outb
argument_list|(
name|offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the bus and unpause/restart the controller 	 */
comment|/* Case 1: Command for another bus is active */
name|sblkctl
operator|=
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* 		 * Stealthily reset the other bus 		 * without upsetting the current bus 		 */
name|outb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
name|ahc_reset_current_bus
argument_list|(
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Case 2: A command from this bus is active or we're idle */
else|else
block|{
name|ahc_reset_current_bus
argument_list|(
name|iobase
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
return|return
name|found
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|scb
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|{
name|int
name|targ
init|=
operator|(
name|scb
operator|->
name|target_channel_lun
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|char
name|chan
init|=
operator|(
name|scb
operator|->
name|target_channel_lun
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|ALL_TARGETS
condition|)
return|return
operator|(
name|chan
operator|==
name|channel
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|&&
operator|(
name|targ
operator|==
name|target
operator|)
operator|)
return|;
block|}
end_function

end_unit

