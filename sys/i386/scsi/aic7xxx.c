begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Copyright (c) 1994, 1995 Justin T. Gibbs.    * All rights reserved.  *  * Product specific probe and attach routines can be found in:  * i386/isa/aic7770.c	27/284X and aic7770 motherboard controllers  * i386/pci/aic7870.c	294x and aic7870 motherboard controllers  *  * Portions of this driver are based on the FreeBSD 1742 Driver:   *  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * commenced: Sun Sep 27 18:14:01 PDT 1992  *  *      $Id: aic7770.c,v 1.8 1994/12/31 19:31:56 gibbs Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  * 	Add target reset capabilities  *	Implement Target Mode  *	Implement Tagged Queuing  *	Test support for the 294X series cards  *  *	This driver is very stable, and seems to offer performance  *	comprable to the 1742 FreeBSD driver.  I have not experienced  *	any timeouts since the timeout code was written, so in that   *	sense, it is untested.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/aic7xxx.h>
end_include

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_decl_stmt
name|struct
name|ahc_data
modifier|*
name|ahcdata
index|[
name|NAHC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ahc_init
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|ahc_loadseq
name|__P
argument_list|(
operator|(
name|u_long
name|iobase
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int32
name|ahc_scsi_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahc_done
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scb
modifier|*
name|ahc_get_scb
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahc_free_scb
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|ahc_abort_scb
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|ahcminphys
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|scb
modifier|*
name|ahc_scb_phys_kv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|u_int32
name|ahc_adapter_info
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ahc_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Different debugging levels - only one so-far */
end_comment

begin_define
define|#
directive|define
name|AHC_SHOWMISC
value|0x0001
end_define

begin_decl_stmt
name|int
name|ahc_debug
init|=
name|AHC_SHOWMISC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x07
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_define
define|#
directive|define
name|HWSCSIID
value|0x0f
end_define

begin_comment
comment|/* our SCSI ID if Wide Bus */
end_comment

begin_decl_stmt
name|struct
name|scsi_adapter
name|ahc_switch
init|=
block|{
name|ahc_scsi_cmd
block|,
name|ahcminphys
block|,
literal|0
block|,
literal|0
block|,
name|ahc_adapter_info
block|,
literal|"ahc"
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
name|struct
name|scsi_device
name|ahc_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"ahc"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * All of these should be in a separate header file shared by the sequencer  * code and the kernel level driver.  The only catch is that we would need to   * add an additional 0xc00 offset when using them in the kernel driver.  The   * aic7770 assembler must be modified to allow include files as well.  All   * page numbers refer to the Adaptec AIC-7770 Data Book availible from   * Adaptec's Technical Documents Department 1-800-934-2766  */
end_comment

begin_comment
comment|/* -------------------- AIC-7770 offset definitions ----------------------- */
end_comment

begin_comment
comment|/*   * SCSI Sequence Control (p. 3-11).    * Each bit, when set starts a specific SCSI sequence on the bus  */
end_comment

begin_define
define|#
directive|define
name|SCSISEQ
value|0xc00ul
end_define

begin_define
define|#
directive|define
name|TEMODEO
value|0x80
end_define

begin_define
define|#
directive|define
name|ENSELO
value|0x40
end_define

begin_define
define|#
directive|define
name|ENSELI
value|0x20
end_define

begin_define
define|#
directive|define
name|ENRSELI
value|0x10
end_define

begin_define
define|#
directive|define
name|ENAUTOATNO
value|0x08
end_define

begin_define
define|#
directive|define
name|ENAUTOATNI
value|0x04
end_define

begin_define
define|#
directive|define
name|ENAUTOATNP
value|0x02
end_define

begin_define
define|#
directive|define
name|SCSIRSTO
value|0x01
end_define

begin_comment
comment|/*  * SCSI Control Signal Read Register (p. 3-15).   * Reads the actual state of the SCSI bus pins  */
end_comment

begin_define
define|#
directive|define
name|SCSISIGI
value|0xc03ul
end_define

begin_define
define|#
directive|define
name|CDI
value|0x80
end_define

begin_define
define|#
directive|define
name|IOI
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGI
value|0x20
end_define

begin_define
define|#
directive|define
name|ATNI
value|0x10
end_define

begin_define
define|#
directive|define
name|SELI
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYI
value|0x04
end_define

begin_define
define|#
directive|define
name|REQI
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKI
value|0x01
end_define

begin_comment
comment|/*  * SCSI Contol Signal Write Register (p. 3-16).   * Writing to this register modifies the control signals on the bus.  Only   * those signals that are allowed in the current mode (Initiator/Target) are  * asserted.  */
end_comment

begin_define
define|#
directive|define
name|SCSISIGO
value|0xc03ul
end_define

begin_define
define|#
directive|define
name|CDO
value|0x80
end_define

begin_define
define|#
directive|define
name|IOO
value|0x40
end_define

begin_define
define|#
directive|define
name|MSGO
value|0x20
end_define

begin_define
define|#
directive|define
name|ATNO
value|0x10
end_define

begin_define
define|#
directive|define
name|SELO
value|0x08
end_define

begin_define
define|#
directive|define
name|BSYO
value|0x04
end_define

begin_define
define|#
directive|define
name|REQO
value|0x02
end_define

begin_define
define|#
directive|define
name|ACKO
value|0x01
end_define

begin_comment
comment|/* XXX document this thing */
end_comment

begin_define
define|#
directive|define
name|SCSIRATE
value|0xc04ul
end_define

begin_comment
comment|/*  * SCSI ID (p. 3-18).  * Contains the ID of the board and the current target on the  * selected channel  */
end_comment

begin_define
define|#
directive|define
name|SCSIID
value|0xc05ul
end_define

begin_define
define|#
directive|define
name|TID
value|0xf0
end_define

begin_comment
comment|/* Target ID mask */
end_comment

begin_define
define|#
directive|define
name|OID
value|0x0f
end_define

begin_comment
comment|/* Our ID mask */
end_comment

begin_comment
comment|/*  * SCSI Status 0 (p. 3-21)  * Contains one set of SCSI Interrupt codes  * These are most likely of interest to the sequencer  */
end_comment

begin_define
define|#
directive|define
name|SSTAT0
value|0xc0bul
end_define

begin_define
define|#
directive|define
name|TARGET
value|0x80
end_define

begin_comment
comment|/* Board is a target */
end_comment

begin_define
define|#
directive|define
name|SELDO
value|0x40
end_define

begin_comment
comment|/* Selection Done */
end_comment

begin_define
define|#
directive|define
name|SELDI
value|0x20
end_define

begin_comment
comment|/* Board has been selected */
end_comment

begin_define
define|#
directive|define
name|SELINGO
value|0x10
end_define

begin_comment
comment|/* Selection In Progress */
end_comment

begin_define
define|#
directive|define
name|SWRAP
value|0x08
end_define

begin_comment
comment|/* 24bit counter wrap */
end_comment

begin_define
define|#
directive|define
name|SDONE
value|0x04
end_define

begin_comment
comment|/* STCNT = 0x000000 */
end_comment

begin_define
define|#
directive|define
name|SPIORDY
value|0x02
end_define

begin_comment
comment|/* SCSI PIO Ready */
end_comment

begin_define
define|#
directive|define
name|DMADONE
value|0x01
end_define

begin_comment
comment|/* DMA transfer completed */
end_comment

begin_comment
comment|/*  * Clear SCSI Interrupt 1 (p. 3-23)  * Writing a 1 to a bit clears the associated SCSI Interrupt in SSTAT1.  */
end_comment

begin_define
define|#
directive|define
name|CLRSINT1
value|0xc0cul
end_define

begin_define
define|#
directive|define
name|CLRSELTIMEO
value|0x80
end_define

begin_define
define|#
directive|define
name|CLRATNO
value|0x40
end_define

begin_define
define|#
directive|define
name|CLRSCSIRSTI
value|0x20
end_define

begin_comment
comment|/*  UNUSED			0x10 */
end_comment

begin_define
define|#
directive|define
name|CLRBUSFREE
value|0x08
end_define

begin_define
define|#
directive|define
name|CLRSCSIPERR
value|0x04
end_define

begin_define
define|#
directive|define
name|CLRPHASECHG
value|0x02
end_define

begin_define
define|#
directive|define
name|CLRREQINIT
value|0x01
end_define

begin_comment
comment|/*  * SCSI Status 1 (p. 3-24)  * These interrupt bits are of interest to the kernel driver  */
end_comment

begin_define
define|#
directive|define
name|SSTAT1
value|0xc0cul
end_define

begin_define
define|#
directive|define
name|SELTO
value|0x80
end_define

begin_define
define|#
directive|define
name|ATNTARG
value|0x40
end_define

begin_define
define|#
directive|define
name|SCSIRSTI
value|0x20
end_define

begin_define
define|#
directive|define
name|PHASEMIS
value|0x10
end_define

begin_define
define|#
directive|define
name|BUSFREE
value|0x08
end_define

begin_define
define|#
directive|define
name|SCSIPERR
value|0x04
end_define

begin_define
define|#
directive|define
name|PHASECHG
value|0x02
end_define

begin_define
define|#
directive|define
name|REQINIT
value|0x01
end_define

begin_comment
comment|/*  * Selection/Reselection ID (p. 3-31)  * Upper four bits are the device id.  The ONEBIT is set when the re/selecting  * device did not set its own ID.  */
end_comment

begin_define
define|#
directive|define
name|SELID
value|0xc19ul
end_define

begin_define
define|#
directive|define
name|SELID_MASK
value|0xf0
end_define

begin_define
define|#
directive|define
name|ONEBIT
value|0x08
end_define

begin_comment
comment|/*  UNUSED			0x07 */
end_comment

begin_comment
comment|/*  * SCSI Block Control (p. 3-32)  * Controls Bus type and channel selection.  In a twin channel configuration  * addresses 0x00-0x1e are gated to the appropriate channel based on this  * register.  SELWIDE allows for the coexistence of 8bit and 16bit devices  * on a wide bus.  */
end_comment

begin_define
define|#
directive|define
name|SBLKCTL
value|0xc1ful
end_define

begin_comment
comment|/*  UNUSED			0xc0 */
end_comment

begin_define
define|#
directive|define
name|AUTOFLUSHDIS
value|0x20
end_define

begin_comment
comment|/*  UNUSED			0x10 */
end_comment

begin_define
define|#
directive|define
name|SELBUSB
value|0x08
end_define

begin_comment
comment|/*  UNUSED			0x04 */
end_comment

begin_define
define|#
directive|define
name|SELWIDE
value|0x02
end_define

begin_comment
comment|/*  UNUSED			0x01 */
end_comment

begin_comment
comment|/*  * Sequencer Control (p. 3-33)  * Error detection mode and speed configuration  */
end_comment

begin_define
define|#
directive|define
name|SEQCTL
value|0xc60ul
end_define

begin_define
define|#
directive|define
name|PERRORDIS
value|0x80
end_define

begin_define
define|#
directive|define
name|PAUSEDIS
value|0x40
end_define

begin_define
define|#
directive|define
name|FAILDIS
value|0x20
end_define

begin_define
define|#
directive|define
name|FASTMODE
value|0x10
end_define

begin_define
define|#
directive|define
name|BRKADRINTEN
value|0x08
end_define

begin_define
define|#
directive|define
name|STEP
value|0x04
end_define

begin_define
define|#
directive|define
name|SEQRESET
value|0x02
end_define

begin_define
define|#
directive|define
name|LOADRAM
value|0x01
end_define

begin_comment
comment|/*  * Sequencer RAM Data (p. 3-34)  * Single byte window into the Scratch Ram area starting at the address  * specified by SEQADDR0 and SEQADDR1.  To write a full word, simply write  * four bytes in sucessesion.  The SEQADDRs will increment after the most  * significant byte is written  */
end_comment

begin_define
define|#
directive|define
name|SEQRAM
value|0xc61ul
end_define

begin_comment
comment|/*  * Sequencer Address Registers (p. 3-35)   * Only the first bit of SEQADDR1 holds addressing information  */
end_comment

begin_define
define|#
directive|define
name|SEQADDR0
value|0xc62ul
end_define

begin_define
define|#
directive|define
name|SEQADDR1
value|0xc63ul
end_define

begin_define
define|#
directive|define
name|SEQADDR1_MASK
value|0x01
end_define

begin_comment
comment|/*  * Accumulator  * We cheat by passing arguments in the Accumulator up to the kernel driver  */
end_comment

begin_define
define|#
directive|define
name|ACCUM
value|0xc64ul
end_define

begin_define
define|#
directive|define
name|SINDEX
value|0xc65ul
end_define

begin_comment
comment|/*  * Board Control (p. 3-43)  */
end_comment

begin_define
define|#
directive|define
name|BCTL
value|0xc84ul
end_define

begin_comment
comment|/*   RSVD			0xf0 */
end_comment

begin_define
define|#
directive|define
name|ACE
value|0x08
end_define

begin_comment
comment|/* Support for external processors */
end_comment

begin_comment
comment|/*   RSVD			0x06 */
end_comment

begin_define
define|#
directive|define
name|ENABLE
value|0x01
end_define

begin_comment
comment|/*  * Host Control (p. 3-47) R/W  * Overal host control of the device.    */
end_comment

begin_define
define|#
directive|define
name|HCNTRL
value|0xc87ul
end_define

begin_comment
comment|/*    UNUSED			0x80 */
end_comment

begin_define
define|#
directive|define
name|POWRDN
value|0x40
end_define

begin_comment
comment|/*    UNUSED			0x20 */
end_comment

begin_define
define|#
directive|define
name|SWINT
value|0x10
end_define

begin_define
define|#
directive|define
name|IRQMS
value|0x08
end_define

begin_define
define|#
directive|define
name|PAUSE
value|0x04
end_define

begin_define
define|#
directive|define
name|INTEN
value|0x02
end_define

begin_define
define|#
directive|define
name|CHIPRST
value|0x01
end_define

begin_define
define|#
directive|define
name|REQ_PAUSE
value|IRQMS | PAUSE | INTEN
end_define

begin_define
define|#
directive|define
name|UNPAUSE_274X
value|IRQMS | INTEN
end_define

begin_define
define|#
directive|define
name|UNPAUSE_284X
value|INTEN
end_define

begin_comment
comment|/*  * SCB Pointer (p. 3-49)  * Gate one of the four SCBs into the SCBARRAY window.  */
end_comment

begin_define
define|#
directive|define
name|SCBPTR
value|0xc90ul
end_define

begin_comment
comment|/*  * Interrupt Status (p. 3-50)  * Status for system interrupts  */
end_comment

begin_define
define|#
directive|define
name|INTSTAT
value|0xc91ul
end_define

begin_define
define|#
directive|define
name|SEQINT_MASK
value|0xf0
end_define

begin_comment
comment|/* SEQINT Status Codes */
end_comment

begin_define
define|#
directive|define
name|BAD_PHASE
value|0x00
end_define

begin_define
define|#
directive|define
name|MSG_REJECT
value|0x10
end_define

begin_define
define|#
directive|define
name|NO_IDENT
value|0x20
end_define

begin_define
define|#
directive|define
name|NO_MATCH
value|0x30
end_define

begin_define
define|#
directive|define
name|MSG_SDTR
value|0x40
end_define

begin_define
define|#
directive|define
name|BAD_STATUS
value|0x50
end_define

begin_define
define|#
directive|define
name|MSG_WDTR
value|0x60
end_define

begin_define
define|#
directive|define
name|BRKADRINT
value|0x08
end_define

begin_define
define|#
directive|define
name|SCSIINT
value|0x04
end_define

begin_define
define|#
directive|define
name|CMDCMPLT
value|0x02
end_define

begin_define
define|#
directive|define
name|SEQINT
value|0x01
end_define

begin_define
define|#
directive|define
name|INT_PEND
value|SEQINT | SCSIINT | CMDCMPLT
end_define

begin_comment
comment|/* For polling */
end_comment

begin_comment
comment|/*  * Hard Error (p. 3-53)  * Reporting of catastrophic errors.  You usually cannot recover from   * these without a full board reset.  */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|0xc92ul
end_define

begin_comment
comment|/*    UNUSED			0xf0 */
end_comment

begin_define
define|#
directive|define
name|PARERR
value|0x08
end_define

begin_define
define|#
directive|define
name|ILLOPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|ILLSADDR
value|0x02
end_define

begin_define
define|#
directive|define
name|ILLHADDR
value|0x01
end_define

begin_comment
comment|/*  * Clear Interrupt Status (p. 3-52)  */
end_comment

begin_define
define|#
directive|define
name|CLRINT
value|0xc92ul
end_define

begin_define
define|#
directive|define
name|CLRBRKADRINT
value|0x08
end_define

begin_define
define|#
directive|define
name|CLRINTSTAT
value|0x04
end_define

begin_comment
comment|/* UNDOCUMENTED - must be unpaused */
end_comment

begin_define
define|#
directive|define
name|CLRCMDINT
value|0x02
end_define

begin_define
define|#
directive|define
name|CLRSEQINT
value|0x01
end_define

begin_comment
comment|/*  * SCB Auto Increment (p. 3-59)  * Byte offset into the SCB Array and an optional bit to allow auto   * incrementing of the address during download and upload operations  */
end_comment

begin_define
define|#
directive|define
name|SCBCNT
value|0xc9aul
end_define

begin_define
define|#
directive|define
name|SCBAUTO
value|0x80
end_define

begin_define
define|#
directive|define
name|SCBCNT_MASK
value|0x1f
end_define

begin_comment
comment|/*  * Queue In FIFO (p. 3-60)  * Input queue for queued SCBs (commands that the seqencer has yet to start)  */
end_comment

begin_define
define|#
directive|define
name|QINFIFO
value|0xc9bul
end_define

begin_comment
comment|/*  * Queue In Count (p. 3-60)  * Number of queued SCBs  */
end_comment

begin_define
define|#
directive|define
name|QINCNT
value|0xc9cul
end_define

begin_comment
comment|/*  * Queue Out FIFO (p. 3-61)  * Queue of SCBs that have completed and await the host  */
end_comment

begin_define
define|#
directive|define
name|QOUTFIFO
value|0xc9dul
end_define

begin_comment
comment|/*  * Queue Out Count (p. 3-61)  * Number of queued SCBs in the Out FIFO  */
end_comment

begin_define
define|#
directive|define
name|QOUTCNT
value|0xc9eul
end_define

begin_define
define|#
directive|define
name|SCBARRAY
value|0xca0ul
end_define

begin_comment
comment|/* ---------------- END AIC-7770 Register Definitions ----------------- */
end_comment

begin_comment
comment|/* --------------------- AIC-7870-only definitions -------------------- */
end_comment

begin_define
define|#
directive|define
name|DSPCISTATUS
value|0xc86ul
end_define

begin_comment
comment|/* ---------------------- Scratch RAM Offsets ------------------------- */
end_comment

begin_comment
comment|/* These offsets are either to values that are initialized by the board's  * BIOS or are specified by the Linux sequencer code.  If I can figure out  * how to read the EISA configuration info at probe time, the cards could  * be run without BIOS support installed  */
end_comment

begin_comment
comment|/*  * 1 byte per target starting at this address for configuration values  */
end_comment

begin_define
define|#
directive|define
name|HA_TARG_SCRATCH
value|0xc20ul
end_define

begin_comment
comment|/*  * The sequencer will stick the frist byte of any rejected message here so  * we can see what is getting thrown away.  */
end_comment

begin_define
define|#
directive|define
name|HA_REJBYTE
value|0xc31ul
end_define

begin_comment
comment|/*  * Length of pending message  */
end_comment

begin_define
define|#
directive|define
name|HA_MSG_LEN
value|0xc36ul
end_define

begin_comment
comment|/*  * message body  */
end_comment

begin_define
define|#
directive|define
name|HA_MSG_START
value|0xc37ul
end_define

begin_comment
comment|/* outgoing message body */
end_comment

begin_comment
comment|/*  * These are offsets into the card's scratch ram.  Some of the values are  * specified in the AHA2742 technical reference manual and are initialized   * by the BIOS at boot time.  */
end_comment

begin_define
define|#
directive|define
name|HA_ARG_1
value|0xc4cul
end_define

begin_define
define|#
directive|define
name|HA_RETURN_1
value|0xc4cul
end_define

begin_define
define|#
directive|define
name|SEND_WDTR
value|0x80
end_define

begin_define
define|#
directive|define
name|SEND_SDTR
value|0x80
end_define

begin_define
define|#
directive|define
name|HA_SIGSTATE
value|0xc4dul
end_define

begin_define
define|#
directive|define
name|HA_NEEDWDTR0
value|0xc34ul
end_define

begin_define
define|#
directive|define
name|HA_NEEDWDTR1
value|0xc35ul
end_define

begin_define
define|#
directive|define
name|HA_NEEDSDTR0
value|0xc4eul
end_define

begin_define
define|#
directive|define
name|HA_NEEDSDTR1
value|0xc4ful
end_define

begin_define
define|#
directive|define
name|HA_SCBCOUNT
value|0xc56ul
end_define

begin_define
define|#
directive|define
name|HA_FLAGS
value|0xc57ul
end_define

begin_define
define|#
directive|define
name|TWIN_BUS
value|0x01
end_define

begin_define
define|#
directive|define
name|WIDE_BUS
value|0x02
end_define

begin_define
define|#
directive|define
name|CHECK_DTR
value|0x08
end_define

begin_define
define|#
directive|define
name|SENSE
value|0x10
end_define

begin_define
define|#
directive|define
name|ACTIVE_MSG
value|0x20
end_define

begin_define
define|#
directive|define
name|IDENTIFY_SEEN
value|0x40
end_define

begin_define
define|#
directive|define
name|RESELECTING
value|0x80
end_define

begin_define
define|#
directive|define
name|HA_ACTIVE0
value|0xc58ul
end_define

begin_define
define|#
directive|define
name|HA_ACTIVE1
value|0xc59ul
end_define

begin_define
define|#
directive|define
name|HA_SCSICONF
value|0xc5aul
end_define

begin_define
define|#
directive|define
name|INTDEF
value|0xc5cul
end_define

begin_define
define|#
directive|define
name|HA_HOSTCONF
value|0xc5dul
end_define

begin_define
define|#
directive|define
name|MSG_ABORT
value|0x06
end_define

begin_define
define|#
directive|define
name|BUS_8_BIT
value|0x00
end_define

begin_define
define|#
directive|define
name|BUS_16_BIT
value|0x01
end_define

begin_define
define|#
directive|define
name|BUS_32_BIT
value|0x02
end_define

begin_comment
comment|/*  * Since the sequencer can disable pausing in a critical section, we  * must loop until it actually stops.   * XXX Should add a timeout in here??  */
end_comment

begin_define
define|#
directive|define
name|PAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb(HCNTRL + ahc->baseport, REQ_PAUSE);   \ 				\         while ((inb(HCNTRL + ahc->baseport)& PAUSE) == 0)             \                         ;
end_define

begin_define
define|#
directive|define
name|UNPAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|outb( HCNTRL + ahc->baseport, ahc->unpause )
end_define

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_define
define|#
directive|define
name|RESTART_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|do {                                    \                         outb( SEQCTL + ahc->baseport, SEQRESET|FASTMODE );     \                 } while (inb(SEQADDR0 + ahc->baseport) != 0&&   \ 			 inb(SEQADDR1 + ahc->baseport != 0));     \                                                         \                 UNPAUSE_SEQUENCER(ahc);
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|AHCDEBUG
end_ifdef

begin_function
name|void
name|ahc_print_scb
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"scb:%x control:%x tcl:%x cmdlen:%d cmdpointer:%x\n"
argument_list|,
name|scb
argument_list|,
name|scb
operator|->
name|control
argument_list|,
name|scb
operator|->
name|target_channel_lun
argument_list|,
name|scb
operator|->
name|cmdlen
argument_list|,
name|scb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:%x res:%x segs:%x segp:%x\n"
argument_list|,
name|scb
operator|->
name|datalen
index|[
literal|2
index|]
operator|<<
literal|16
operator||
name|scb
operator|->
name|datalen
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|scb
operator|->
name|datalen
index|[
literal|0
index|]
argument_list|,
name|scb
operator|->
name|data
argument_list|,
name|scb
operator|->
name|RESERVED
index|[
literal|1
index|]
operator|<<
literal|8
operator||
name|scb
operator|->
name|RESERVED
index|[
literal|0
index|]
argument_list|,
name|scb
operator|->
name|SG_segment_count
argument_list|,
name|scb
operator|->
name|SG_list_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%x sg_len:%d\n"
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	size:%d\n"
argument_list|,
operator|(
name|int
operator|)
operator|&
operator|(
name|scb
operator|->
name|next
operator|)
operator|-
operator|(
name|int
operator|)
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ahc_print_active_scb
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|cur_scb_offset
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|cur_scb_offset
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|port
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_print_scb
argument_list|(
name|ahc
operator|->
name|scbarray
index|[
name|cur_scb_offset
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PARERR
value|0x08
end_define

begin_define
define|#
directive|define
name|ILLOPCODE
value|0x04
end_define

begin_define
define|#
directive|define
name|ILLSADDR
value|0x02
end_define

begin_define
define|#
directive|define
name|ILLHADDR
value|0x01
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_char
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|,
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|,
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|,
name|PARERR
block|,
literal|"Sequencer Ram Parity Error"
block|, }
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|short
name|sxfr
decl_stmt|;
name|short
name|period
decl_stmt|;
comment|/* in ns */
name|char
modifier|*
name|rate
decl_stmt|;
block|}
name|ahc_syncrates
index|[]
init|=
block|{
literal|0x00
block|,
literal|100
block|,
literal|"10.0"
block|,
literal|0x10
block|,
literal|125
block|,
literal|"8.0"
block|,
literal|0x20
block|,
literal|150
block|,
literal|"6.67"
block|,
literal|0x30
block|,
literal|175
block|,
literal|"5.7"
block|,
literal|0x40
block|,
literal|200
block|,
literal|"5.0"
block|,
literal|0x50
block|,
literal|225
block|,
literal|"4.4"
block|,
literal|0x60
block|,
literal|250
block|,
literal|"4.0"
block|,
literal|0x70
block|,
literal|275
block|,
literal|"3.6"
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ahc_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|ahc_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if the device can be found at the port given  * and if so, determine configuration and set it up for further work.  */
end_comment

begin_function
name|int
name|ahcprobe
parameter_list|(
name|unit
parameter_list|,
name|iobase
parameter_list|,
name|type
parameter_list|)
name|int
name|unit
decl_stmt|;
name|u_long
name|iobase
decl_stmt|;
name|ahc_type
name|type
decl_stmt|;
block|{
comment|/*          * find unit and check we have that many defined          */
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NAHC
condition|)
block|{
name|printf
argument_list|(
literal|"ahc: unit number (%d) too high\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * Allocate a storage area for us          */
if|if
condition|(
name|ahcdata
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: memory already allocated\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ahc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|)
expr_stmt|;
name|ahcdata
index|[
name|unit
index|]
operator|=
name|ahc
expr_stmt|;
name|ahc
operator|->
name|baseport
operator|=
name|iobase
expr_stmt|;
name|ahc
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/*          * Try to initialize a unit at this location          * reset the AIC-7770, read its registers,          * and fill in the dev structure accordingly          */
if|if
condition|(
name|ahc_init
argument_list|(
name|unit
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ahcdata
index|[
name|unit
index|]
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|ahc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_scsirate
parameter_list|(
name|scsirate
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|,
name|unit
parameter_list|,
name|target
parameter_list|)
name|u_char
modifier|*
name|scsirate
decl_stmt|;
name|u_char
name|period
decl_stmt|,
name|offset
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|-
name|period
operator|)
operator|>=
literal|0
condition|)
block|{
operator|*
name|scsirate
operator|=
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target %d synchronous at %sMB/s, "
literal|"offset = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
endif|#
directive|endif
comment|/* AHCDEBUG */
return|return;
block|}
block|}
comment|/* Default to asyncronous transfer */
operator|*
name|scsirate
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target %d using asyncronous transfers\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
endif|#
directive|endif
comment|/* AHCDEBUG */
block|}
end_function

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
comment|/*          * fill in the prototype scsi_link.          */
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|unit
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahc_switch
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahc_dev
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|DEBUGLEVEL
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
comment|/*          * ask the adapter what subunits are present          */
name|printf
argument_list|(
literal|"ahc%d: Probing channel A\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ahc
operator|->
name|sc_link
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_274T
operator|||
name|ahc
operator|->
name|type
operator|==
name|AHC_284T
operator|||
name|ahc
operator|->
name|type
operator|==
name|AHC_294T
condition|)
block|{
comment|/* Configure the second scsi bus */
name|ahc
operator|->
name|sc_link_b
operator|=
name|ahc
operator|->
name|sc_link
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|fordriver
operator|=
operator|(
name|void
operator|*
operator|)
literal|0x0008
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: Probing Channel B\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
operator|&
operator|(
name|ahc
operator|->
name|sc_link_b
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * We should be done with all SDTR and WDTR messages, so 	 * lets tell the  sequencer to stop checking if it should 	 * be doing them.  This makes ~8 tests into 1. 	 */
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|flags
operator|=
name|inb
argument_list|(
name|HA_FLAGS
operator|+
name|ahc
operator|->
name|baseport
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|ahc
operator|->
name|baseport
argument_list|,
name|flags
operator|&
operator|~
name|CHECK_DTR
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ahc_send_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|int
name|old_scbptr
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|old_scbptr
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
name|SCBAUTO
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_DOWN_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|old_scbptr
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_getscb
parameter_list|(
name|iobase
parameter_list|,
name|scb
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* SCBAUTO */
name|insb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_UP_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*                * Catch an interrupt from the adaptor  */
end_comment

begin_function
name|int
name|ahcintr
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|int
name|intstat
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Check that we are in the "running" state, and should be  	 * receiving interrupts.  The reason for doing this is that  	 * we have a choice of edge or level sensitive interrupts,  	 * and if we have the wrong type set, we'll get spurrious  	 * interrupts.  Toggle to the other type if need be. 	 */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|!=
name|AHC_RUNNING
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Switching interrupt type\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|^=
literal|0x8
expr_stmt|;
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|^
literal|0x8
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|intstat
operator|=
name|inb
argument_list|(
name|INTSTAT
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* We upset the sequencer :-( */
comment|/* Lookup the error message */
name|int
name|i
decl_stmt|,
name|error
init|=
name|inb
argument_list|(
name|ERROR
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|int
name|num_errors
init|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"ahc%d: brkadrint, %s at seqaddr = 0x%lx\n"
argument_list|,
name|unit
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
operator|(
name|inb
argument_list|(
name|SEQADDR1
operator|+
name|iobase
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|SEQADDR0
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
block|{
name|unsigned
name|char
name|transfer
decl_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|BAD_PHASE
case|:
name|panic
argument_list|(
literal|"ahc%d: unknown scsi bus phase.  "
literal|"Attempting to continue\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|MSG_REJECT
case|:
name|printf
argument_list|(
literal|"ahc%d: Warning - "
literal|"message reject, message type: 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|inb
argument_list|(
name|HA_REJBYTE
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_IDENT
case|:
name|panic
argument_list|(
literal|"ahc%d: No IDENTIFY message from reconnecting "
literal|"target %d\n"
argument_list|,
name|unit
argument_list|,
operator|(
name|inb
argument_list|(
name|SELID
operator|+
name|iobase
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_MATCH
case|:
block|{
name|u_char
name|active
decl_stmt|;
name|int
name|active_port
init|=
name|HA_ACTIVE0
operator|+
name|iobase
decl_stmt|;
name|int
name|tcl
init|=
name|inb
argument_list|(
name|SCBARRAY
operator|+
literal|1
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|int
name|target
init|=
operator|(
name|tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|printf
argument_list|(
literal|"ahc%d: no active SCB for reconnecting "
literal|"target %d, channel %c - issuing ABORT\n"
argument_list|,
name|unit
argument_list|,
name|target
argument_list|,
name|tcl
operator|&
literal|0x07
argument_list|)
expr_stmt|;
if|if
condition|(
name|tcl
operator|&
literal|0x88
condition|)
block|{
comment|/* Second channel stores its info  					 * in byte two of HA_ACTIVE 					 */
name|active_port
operator|++
expr_stmt|;
block|}
name|active
operator|=
name|inb
argument_list|(
name|active_port
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|outb
argument_list|(
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MSG_SDTR
case|:
block|{
name|int
name|loc
decl_stmt|;
name|u_short
name|needsdtr
decl_stmt|;
name|u_char
name|scsi_id
decl_stmt|,
name|offset
decl_stmt|,
name|rate
decl_stmt|,
name|targ_scratch
decl_stmt|;
comment|/*  				 * Help the sequencer to translate the  				 * negotiated transfer rate.  Transfer is  				 * 1/4 the period in ns as is returned by  				 * the sync negotiation message.  So, we must  				 * multiply by four 				 */
name|transfer
operator|=
name|inb
argument_list|(
name|HA_ARG_1
operator|+
name|iobase
argument_list|)
operator|<<
literal|2
expr_stmt|;
comment|/* The bottom half of SCSIXFER*/
name|offset
operator|=
name|inb
argument_list|(
name|ACCUM
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scsi_id
operator|=
name|inb
argument_list|(
name|SCSIID
operator|+
name|iobase
argument_list|)
operator|>>
literal|0x4
expr_stmt|;
name|ahc_scsirate
argument_list|(
operator|&
name|rate
argument_list|,
name|transfer
argument_list|,
name|offset
argument_list|,
name|unit
argument_list|,
name|scsi_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
operator|&
literal|0x08
condition|)
comment|/* B channel */
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|targ_scratch
operator|=
name|inb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scsi_id
argument_list|)
expr_stmt|;
comment|/* Preserve the WideXfer flag */
name|rate
operator||=
name|targ_scratch
operator|&
literal|0x80
expr_stmt|;
name|outb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scsi_id
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
operator|+
name|iobase
argument_list|,
name|rate
argument_list|)
expr_stmt|;
comment|/* See if we initiated Sync Negotiation */
name|needsdtr
operator|=
operator|(
name|inb
argument_list|(
name|HA_NEEDSDTR1
operator|+
name|iobase
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|HA_NEEDSDTR0
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsdtr
operator|&
operator|(
literal|0x01
operator|<<
name|scsi_id
operator|)
condition|)
block|{
comment|/*  					 * Negate the flag and don't send 					 * an SDTR back to the target 					 */
name|needsdtr
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|scsi_id
operator|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDSDTR0
operator|+
name|iobase
argument_list|,
name|needsdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDSDTR1
operator|+
name|iobase
argument_list|,
name|needsdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_RETURN_1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Send our own SDTR in reply 					 */
name|printf
argument_list|(
literal|"Sending SDTR!!\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_RETURN_1
operator|+
name|iobase
argument_list|,
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MSG_WDTR
case|:
block|{
name|int
name|loc
decl_stmt|;
name|u_short
name|needwdtr
decl_stmt|;
name|u_char
name|scsi_id
decl_stmt|,
name|scratch
decl_stmt|,
name|bus_width
decl_stmt|;
name|bus_width
operator|=
name|inb
argument_list|(
name|ACCUM
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scsi_id
operator|=
name|inb
argument_list|(
name|SCSIID
operator|+
name|iobase
argument_list|)
operator|>>
literal|0x4
expr_stmt|;
name|needwdtr
operator|=
operator|(
name|inb
argument_list|(
name|HA_NEEDWDTR1
operator|+
name|iobase
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|inb
argument_list|(
name|HA_NEEDWDTR0
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
operator|&
literal|0x08
condition|)
comment|/* B channel */
name|scsi_id
operator|+=
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"Recieved MSG_WDTR, scsi_id = %d, "
literal|"needwdtr == 0x%x\n"
argument_list|,
name|scsi_id
argument_list|,
name|needwdtr
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|inb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scsi_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|needwdtr
operator|&
operator|(
literal|0x01
operator|<<
name|scsi_id
operator|)
condition|)
block|{
comment|/*  					 * Negate the flag and don't  					 * send a WDTR back to the  					 * target, since we asked first. 					 */
name|needwdtr
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
name|scsi_id
operator|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR0
operator|+
name|iobase
argument_list|,
name|needwdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR1
operator|+
name|iobase
argument_list|,
name|needwdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_RETURN_1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_16_BIT
case|:
name|printf
argument_list|(
literal|"ahc%d: target "
literal|"%d using 16Bit "
literal|"transfers\n"
argument_list|,
name|unit
argument_list|,
name|scsi_id
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x88
expr_stmt|;
name|scratch
operator|&=
literal|0xf8
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * Send our own WDTR in reply 					 */
name|printf
argument_list|(
literal|"Will Send WDTR!!\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
comment|/* Negotiate 16_BITS */
name|bus_width
operator|=
name|BUS_16_BIT
expr_stmt|;
case|case
name|BUS_16_BIT
case|:
name|printf
argument_list|(
literal|"ahc%d: target "
literal|"%d using 16Bit "
literal|"transfers\n"
argument_list|,
name|unit
argument_list|,
name|scsi_id
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x88
expr_stmt|;
name|scratch
operator|&=
literal|0xf8
expr_stmt|;
break|break;
block|}
name|outb
argument_list|(
name|HA_RETURN_1
operator|+
name|iobase
argument_list|,
name|bus_width
operator||
name|SEND_WDTR
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|iobase
operator|+
name|scsi_id
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSIRATE
operator|+
name|iobase
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_STATUS
case|:
block|{
name|int
name|scb_index
decl_stmt|,
name|saved_scb_index
decl_stmt|;
name|u_short
name|seqaddr
decl_stmt|;
comment|/* The sequencer will notify us when a command                            * has an error that would be of interest to                            * the kernel.  This allows us to leave the sequencer                            * running in the common case of command completes                            * without error.                            */
name|scb_index
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: ahcintr - referenced scb not "
literal|"valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|unit
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|ahc_getscb
argument_list|(
name|iobase
argument_list|,
name|scb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|status
operator|=
name|scb
operator|->
name|target_status
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
operator|(
operator|(
name|scb
operator|->
name|residual_data_count
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|scb
operator|->
name|residual_data_count
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|scb
operator|->
name|residual_data_count
index|[
literal|0
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|target_status
condition|)
block|{
case|case
name|SCSI_OK
case|:
name|printf
argument_list|(
literal|"ahc%d: Interrupted for staus of"
literal|" 0???\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_CHECK
case|:
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: target %d, lun %d (%s%d) "
literal|"requests Check Status\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|)
operator|&&
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|u_char
name|flags
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|&
operator|(
name|scb
operator|->
name|sense_cmd
operator|)
decl_stmt|;
name|u_char
name|tcl
init|=
name|scb
operator|->
name|target_channel_lun
decl_stmt|;
name|int
name|i
decl_stmt|,
name|active
decl_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: target %d, lun %d "
literal|"(%s%d) Sending Sense\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|scb
argument_list|,
name|SCB_DOWN_SIZE
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|sc
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|sc
operator|->
name|byte2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|KVTOPHYS
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|scb
operator|->
name|target_channel_lun
operator|=
name|tcl
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
comment|/* 					 * Download new command. 					 */
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb
argument_list|,
name|SCB_DOWN_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBCNT
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|inb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/*  					 * Have the sequencer handle the sense 					 * request 					 */
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|flags
operator||
name|SENSE
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Clear the SCB_SENSE Flag and have 				 * the sequencer do a normal command 				 * complete with either a "DRIVER_STUFFUP" 				 * error or whatever other error condition 				 * we already had. 				 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: Target Busy\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|scb
operator|->
name|target_status
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
default|default:
name|printf
argument_list|(
literal|"ahc: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|inb
argument_list|(
name|SCSISIGI
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|clear
label|:
comment|/*                              * Clear the upper byte that holds SEQINT status                  * codes and clear the SEQINT bit.                  */
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
comment|/*                              *  The sequencer is paused immediately on                  *  a SEQINT, so we should restart it when                  *  we leave this section.                   */
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
block|{
name|int
name|scb_index
init|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
decl_stmt|;
name|status
operator|=
name|inb
argument_list|(
name|SSTAT1
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: ahcintr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cmdcomplete
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SELTO
condition|)
block|{
name|u_char
name|active
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|u_long
name|active_port
init|=
name|HA_ACTIVE0
operator|+
name|iobase
decl_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_TIMEOUT
expr_stmt|;
comment|/*  			 * Clear any pending messages for the timed out 			 * target, and mark the target as free 			 */
name|flags
operator|=
name|inb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|flags
operator|&
operator|~
name|ACTIVE_MSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|target_channel_lun
operator|&
literal|0x88
condition|)
name|active_port
operator|++
expr_stmt|;
name|active
operator|=
name|inb
argument_list|(
name|active_port
argument_list|)
operator|&
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|outb
argument_list|(
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|SCSIPERR
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: parity error on channel A "
literal|"target %d, lun %d\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|CLRSCSIPERR
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|BUSFREE
condition|)
block|{
if|#
directive|if
literal|0
comment|/*  		      * Has seen busfree since selection, i.e.                       * a "spurious" selection. Shouldn't happen.                       */
block|printf("ahc: unexpected busfree\n");                        xs->error = XS_DRIVER_STUFFUP;                        outb(CLRSINT1 + iobase, BUSFREE);
comment|/* CLRBUSFREE */
endif|#
directive|endif
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc%d: Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRSINT1
operator|+
name|iobase
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRINTSTAT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* We want to process the command */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
name|cmdcomplete
label|:
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|int
name|scb_index
decl_stmt|,
name|saved_scb_index
decl_stmt|;
do|do
block|{
name|scb_index
operator|=
name|inb
argument_list|(
name|QOUTFIFO
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: WARNING "
literal|"no command for scb %d (cmdcmplt)\n"
literal|"QOUTCNT == %d\n"
argument_list|,
name|unit
argument_list|,
name|scb_index
argument_list|,
name|inb
argument_list|(
name|QOUTCNT
operator|+
name|iobase
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|outb
argument_list|(
name|CLRINT
operator|+
name|iobase
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|QOUTCNT
operator|+
name|iobase
argument_list|)
condition|)
do|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * We have a scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
name|void
name|ahc_done
parameter_list|(
name|unit
parameter_list|,
name|scb
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*          * Put the results of the operation          * into the xfer and call whoever started it          */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
operator|!
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|int
name|intdef
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Assume we have a board at this stage 	 * Find out the configured interupt and the card type. 	 */
ifdef|#
directive|ifdef
name|AHCDEBUG
name|printf
argument_list|(
literal|"ahc%d: scb %d bytes; SCB_SIZE %d bytes, ahc_dma %d bytes\n"
argument_list|,
name|unit
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|SCB_DOWN_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* AHCDEBUG */
name|printf
argument_list|(
literal|"ahc%d: reading board settings\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|CHIPRST
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ahc
operator|->
name|type
condition|)
block|{
case|case
name|AHC_274
case|:
name|printf
argument_list|(
literal|"ahc%d: 274x "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
name|UNPAUSE_274X
expr_stmt|;
name|ahc
operator|->
name|maxscbs
operator|=
literal|0x4
expr_stmt|;
break|break;
case|case
name|AHC_284
case|:
name|printf
argument_list|(
literal|"ahc%d: 284x "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
name|UNPAUSE_284X
expr_stmt|;
name|ahc
operator|->
name|maxscbs
operator|=
literal|0x4
expr_stmt|;
break|break;
case|case
name|AHC_294
case|:
name|printf
argument_list|(
literal|"ahc%d: 294x "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
name|UNPAUSE_274X
expr_stmt|;
name|ahc
operator|->
name|maxscbs
operator|=
literal|0x10
expr_stmt|;
define|#
directive|define
name|DFTHRESH
value|3
name|outb
argument_list|(
name|DSPCISTATUS
operator|+
name|iobase
argument_list|,
name|DFTHRESH
operator|<<
literal|6
argument_list|)
expr_stmt|;
comment|/* XXX Hard coded SCSI ID for now */
name|outb
argument_list|(
name|HA_SCSICONF
operator|+
name|iobase
argument_list|,
literal|0x07
operator||
operator|(
name|DFTHRESH
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
comment|/* In case we are a wide card */
name|outb
argument_list|(
name|HA_SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|,
literal|0x07
argument_list|)
expr_stmt|;
break|break;
default|default:
block|}
empty_stmt|;
comment|/* Determine channel configuration and who we are on the scsi bus. */
switch|switch
condition|(
name|inb
argument_list|(
name|SBLKCTL
operator|+
name|iobase
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|0xc0
case|:
comment|/* 294x Adaptors have the top two bits set */
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|HA_SCSICONF
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Single Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|CHECK_DTR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
literal|0xc2
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|HA_SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|)
operator|&
name|HWSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Wide Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator|+=
literal|2
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|WIDE_BUS
operator||
name|CHECK_DTR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|inb
argument_list|(
name|HA_SCSICONF
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|our_id_b
operator|=
operator|(
name|inb
argument_list|(
name|HA_SCSICONF
operator|+
literal|1
operator|+
name|iobase
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator|+=
literal|1
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|TWIN_BUS
operator||
name|CHECK_DTR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Number of SCBs that will be used.  Supposedly some newer rev 	 * aic7770s have more than four so maybe we can detect this in 	 * the future.  Aic7870s have 16 SCBs. 	 */
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|<
name|AHC_294
condition|)
block|{
comment|/* The 294x cards are PCI, so we get their interrupt from the PCI 	 * BIOS.  It doesn't look like the ISA mapped interrupt is reported 	 * correctly this way either. 	 */
name|intdef
operator|=
name|inb
argument_list|(
name|INTDEF
operator|+
name|iobase
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|intdef
operator|&
literal|0xf
condition|)
block|{
case|case
literal|9
case|:
name|ahc
operator|->
name|vect
operator|=
literal|9
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|ahc
operator|->
name|vect
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|ahc
operator|->
name|vect
operator|=
literal|11
expr_stmt|;
break|break;
case|case
literal|12
case|:
name|ahc
operator|->
name|vect
operator|=
literal|12
expr_stmt|;
break|break;
case|case
literal|14
case|:
name|ahc
operator|->
name|vect
operator|=
literal|14
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|ahc
operator|->
name|vect
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"illegal irq setting\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/* 	 * Load the Sequencer program and Enable the adapter. 	 * Place the aic7770 in fastmode which makes a big 	 * difference when doing many small block transfers.          */
name|printf
argument_list|(
literal|"ahc%d: Downloading Sequencer Program..."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|iobase
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Done\n"
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|FASTMODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|<
name|AHC_294
condition|)
name|outb
argument_list|(
name|BCTL
operator|+
name|iobase
argument_list|,
name|ENABLE
argument_list|)
expr_stmt|;
comment|/* Reset the SCSI bus.  Is this necessary? */
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate syncronous transfers.  If it's zero,  	 * the user or the BIOS has decided to disable syncronous  	 * negotiation to that target so we don't activate the needsdr 	 * flag. 	 */
name|ahc
operator|->
name|needsdtr
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|u_char
name|target_settings
init|=
name|inb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|i
operator|+
name|iobase
argument_list|)
decl_stmt|;
if|if
condition|(
name|target_settings
operator|&
literal|0x0f
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* Default to a syncrounous offset of 15 */
name|target_settings
operator||=
literal|0x0f
expr_stmt|;
block|}
if|if
condition|(
name|target_settings
operator|&
literal|0x80
condition|)
block|{
name|ahc
operator|->
name|needwdtr
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* 			 * We'll set the Wide flag when we 			 * are successful with Wide negotiation, 			 * so turn it off for now so we aren't 			 * confused. 			 */
name|target_settings
operator|&=
literal|0x7f
expr_stmt|;
block|}
name|outb
argument_list|(
name|HA_TARG_SCRATCH
operator|+
name|i
operator|+
name|iobase
argument_list|,
name|target_settings
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|HA_NEEDSDTR0
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDSDTR1
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR0
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needwdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR1
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needwdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Set the number of availible SCBs 	 */
name|outb
argument_list|(
name|HA_SCBCOUNT
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|maxscbs
argument_list|)
expr_stmt|;
comment|/* We don't have any busy targets right now */
name|outb
argument_list|(
name|HA_ACTIVE0
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_ACTIVE1
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahc
operator|->
name|flags
operator|=
name|AHC_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahcminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/*   * Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGESIZ
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address, target, and lun all of which   * are stored in the scsi_xfer struct  */
end_comment

begin_function
name|int32
name|ahc_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
name|NULL
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|unit
init|=
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 *Set a flag that states, yes, we can receive interrupts 	 * the reason for doing this is that we have a choice of 	 * edge or level sensitive interrupts, and if we have the 	 * wrong type, we'll get spurrious interrupts.  We check 	 * this flag in the interrupt handler and toggle to the 	 * other type if need be. 	 */
name|ahc
operator|->
name|flags
operator|=
name|AHC_RUNNING
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
comment|/*           * get an scb to use. If the transfer          * is from a buf (possibly from interrupt time)          * then we can't allow it to sleep          */
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
name|flags
operator||=
operator|(
name|SCSI_NOSLEEP
operator|)
expr_stmt|;
comment|/* just to be sure */
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Already done?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: Not in use?"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start scb(%x)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
block|{
comment|/* AR: Needs Implementation */
name|printf
argument_list|(
literal|"ahc0: SCSI_RESET called.\n"
argument_list|)
expr_stmt|;
block|}
comment|/*          * Put all the arguments for the xfer in the scb          */
name|scb
operator|->
name|target_channel_lun
operator|=
operator|(
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
literal|0x08
operator|)
operator||
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|&
literal|0x07
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|scb
operator|->
name|ahc_dma
argument_list|)
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
block|{
comment|/*                          * Set up the scatter gather block                          */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%d @0x%x:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHC_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%x"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 					 * This page is contiguous (physically)  					 * with the the last, just extend the  					 * length 					 */
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGESIZ
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGESIZ
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/*                                  * next page isn't contiguous, finish the seg                                  */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
block|}
comment|/*end of iov/kv decision */
name|scb
operator|->
name|SG_segment_count
operator|=
name|seg
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"ahc_scsi_cmd%d: more than %d DMA segs\n"
argument_list|,
name|unit
argument_list|,
name|AHC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
comment|/*  else No data xfer, use non S/G values  	 *  the SG_segment_count and SG_list_pointer are pre-zeroed, so  	 *  we don't have to do anything 	 */
comment|/*                                         * Usually return SUCCESSFULLY QUEUED          */
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
comment|/*                                        * If we can't use interrupts, poll on completion          */
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_wait\n"
operator|)
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|ahc_poll
argument_list|(
name|unit
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|ahc_abort_scb
argument_list|(
name|unit
argument_list|,
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
comment|/* a non command complete intr */
if|if
condition|(
name|xs
operator|->
name|error
condition|)
block|{
return|return
operator|(
name|HAD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*        * Return some information to the caller about  * the adapter and it's capabilities.    */
end_comment

begin_function
name|u_int32
name|ahc_adapter_info
parameter_list|(
name|unit
parameter_list|)
name|int
name|unit
decl_stmt|;
block|{
return|return
operator|(
literal|2
operator|)
return|;
comment|/* 2 outstanding requests at a time per device */
block|}
end_function

begin_comment
comment|/*  * A scb (and hence an scb entry on the board is put onto the  * free list.  */
end_comment

begin_function
name|void
name|ahc_free_scb
parameter_list|(
name|unit
parameter_list|,
name|scb
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|unsigned
name|int
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|ahc
operator|->
name|free_scb
expr_stmt|;
name|ahc
operator|->
name|free_scb
operator|=
name|scb
expr_stmt|;
comment|/*          * If there were none, wake abybody waiting for          * one to come free, starting with queued entries          */
if|if
condition|(
operator|!
name|scb
operator|->
name|next
condition|)
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb  * If there are none, see if we can allocate a  * new one.  Otherwise either return an error or sleep  */
end_comment

begin_function
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|unsigned
name|opri
init|=
literal|0
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|int
name|position
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*          * If we can and have to, sleep waiting for one to come free          * but only if we can't allocate a new one.          */
while|while
condition|(
operator|!
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|free_scb
operator|)
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|position
operator|=
name|ahc
operator|->
name|numscbs
expr_stmt|;
name|ahc
operator|->
name|numscbs
operator|++
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* 				 * Place in the scbarray 				 * Never is removed.  Position 				 * in ahc->scbarray is the scbarray 				 * position on the board we will 				 * load it into. 				 */
name|ahc
operator|->
name|scbarray
index|[
name|scbp
operator|->
name|position
index|]
operator|=
name|scbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ahc%d: Can't malloc SCB\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|gottit
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scb
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcscb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|scbp
condition|)
block|{
comment|/* Get SCB from from free list */
name|ahc
operator|->
name|free_scb
operator|=
name|scbp
operator|->
name|next
expr_stmt|;
comment|/* preserve the position */
name|position
operator|=
name|scbp
operator|->
name|position
expr_stmt|;
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
name|scbp
operator|->
name|position
operator|=
name|position
expr_stmt|;
block|}
name|gottit
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_loadseq
parameter_list|(
name|iobase
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|seqprog
index|[]
init|=
block|{
include|#
directive|include
file|"aic7xxx_seq.h"
block|}
decl_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|PERRORDIS
operator||
name|SEQRESET
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|outsb
argument_list|(
name|SEQRAM
operator|+
name|iobase
argument_list|,
name|seqprog
argument_list|,
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
do|do
block|{
name|outb
argument_list|(
name|SEQCTL
operator|+
name|iobase
argument_list|,
name|SEQRESET
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|inb
argument_list|(
name|SEQADDR0
operator|+
name|iobase
argument_list|)
operator|!=
literal|0
operator|&&
name|inb
argument_list|(
name|SEQADDR1
operator|+
name|iobase
operator|!=
literal|0
argument_list|)
condition|)
do|;
block|}
end_function

begin_comment
comment|/*                * Function to poll for command completion when in poll mode  */
end_comment

begin_function
name|int
name|ahc_poll
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
comment|/* in msec  */
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
name|ahcdata
index|[
name|unit
index|]
decl_stmt|;
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|u_long
name|stport
init|=
name|INTSTAT
operator|+
name|iobase
decl_stmt|;
name|retry
label|:
while|while
condition|(
operator|--
name|wait
condition|)
block|{
if|if
condition|(
name|inb
argument_list|(
name|stport
argument_list|)
operator|&
name|INT_PEND
condition|)
break|break;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: board not responding\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ahcintr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ahc_abort_scb
parameter_list|(
name|unit
parameter_list|,
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|u_long
name|iobase
init|=
name|ahc
operator|->
name|baseport
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|active_scb
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Case 1: In the QINFIFO 	 */
block|{
name|int
name|saved_queue
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|queued
init|=
name|inb
argument_list|(
name|QINCNT
operator|+
name|iobase
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|queued
operator|-
name|found
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|saved_queue
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_queue
index|[
name|i
index|]
operator|==
name|scb
operator|->
name|position
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Re-insert entries back into the queue */
for|for
control|(
name|queued
operator|=
literal|0
init|;
name|queued
operator|<
name|i
condition|;
name|queued
operator|++
control|)
name|outb
argument_list|(
name|QINFIFO
operator|+
name|iobase
argument_list|,
name|saved_queue
index|[
name|queued
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
goto|goto
name|done
goto|;
block|}
block|}
name|active_scb
operator|=
name|inb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|)
expr_stmt|;
comment|/* 	 * Case 2: Not the active command 	 */
if|if
condition|(
name|active_scb
operator|!=
name|scb
operator|->
name|position
condition|)
block|{
comment|/* 		 * Select the SCB we want to abort 		 * and turn off the disconnected bit. 		 * the driver will then abort the command 		 * and notify us of the abort. 		 */
name|int
name|scb_control
decl_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|scb_control
operator|=
name|inb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|scb_control
operator|&=
operator|~
name|SCB_DIS
expr_stmt|;
name|outb
argument_list|(
name|SCBARRAY
operator|+
name|iobase
argument_list|,
name|scb_control
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCBPTR
operator|+
name|iobase
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Case 3: Currently active command 	 */
if|if
condition|(
operator|(
name|flags
operator|=
name|inb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|)
operator|)
operator|&
name|ACTIVE_MSG
condition|)
block|{
comment|/*  		 * If there's a message in progress,  		 * reset the bus and have all devices renegotiate. 		 */
name|u_char
name|flags
decl_stmt|;
if|if
condition|(
name|scb
operator|->
name|target_channel_lun
operator|&
literal|0x08
condition|)
block|{
name|outb
argument_list|(
name|HA_NEEDSDTR1
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_ACTIVE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_274W
operator|||
name|ahc
operator|->
name|type
operator|==
name|AHC_284W
operator|||
name|ahc
operator|->
name|type
operator|==
name|AHC_294W
condition|)
block|{
name|outb
argument_list|(
name|HA_NEEDSDTR0
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDSDTR1
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR0
argument_list|,
name|ahc
operator|->
name|needwdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_NEEDWDTR1
argument_list|,
name|ahc
operator|->
name|needwdtr
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_ACTIVE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_ACTIVE1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|HA_NEEDSDTR0
operator|+
name|iobase
argument_list|,
name|ahc
operator|->
name|needsdtr
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_ACTIVE0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|inb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|flags
operator||
name|CHECK_DTR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISEQ
operator|+
name|iobase
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*  	 * Otherwise, set up an abort message and have the sequencer 	 * clean up 	 */
name|outb
argument_list|(
name|HA_FLAGS
operator|+
name|iobase
argument_list|,
name|flags
operator||
name|ACTIVE_MSG
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_MSG_LEN
operator|+
name|iobase
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|HA_MSG_START
operator|+
name|iobase
argument_list|,
name|MSG_ABORT
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|SCSISIGO
operator|+
name|iobase
argument_list|,
name|inb
argument_list|(
name|HA_SIGSTATE
operator|+
name|iobase
argument_list|)
operator||
literal|0x10
argument_list|)
expr_stmt|;
name|done
label|:
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ahc_timeout
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg1
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|cur_scb_offset
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|unit
operator|=
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_unit
expr_stmt|;
name|ahc
operator|=
name|ahcdata
index|[
name|unit
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"ahc%d: target %d, lun %d (%s%d) timed out "
argument_list|,
name|unit
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|lun
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHCDEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|ahc_print_active_scb
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*AHCDEBUG */
comment|/*          * If it's immediate, don't try abort it          */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_IMMED
condition|)
block|{
name|scb
operator|->
name|xs
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* I MEAN IT ! */
name|scb
operator|->
name|flags
operator||=
name|SCB_IMMED_FAIL
expr_stmt|;
name|ahc_done
argument_list|(
name|unit
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* abort the operation that has timed out */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ahc_abort_scb
argument_list|(
name|unit
argument_list|,
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

