begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Generic driver for the aic7xxx based adaptec SCSI controllers  * Product specific probe and attach routines can be found in:  * i386/eisa/aic7770.c	27/284X and aic7770 motherboard controllers  * pci/aic7870.c	3940, 2940, aic7870 and aic7850 controllers  *  * Copyright (c) 1994, 1995, 1996 Justin T. Gibbs.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      $Id: aic7xxx.c,v 1.70 1996/05/23 15:02:06 gibbs Exp $  */
end_comment

begin_comment
comment|/*  * TODO:  *	Implement Target Mode  *  * A few notes on how SCB paging works...  *  * SCB paging takes advantage of the fact that devices stay disconnected  * from the bus a relatively long time and that while they're disconnected,  * having the SCBs for that device down on the host adapter is of little use.  * Instead we copy the SCB back up into kernel memory and reuse the SCB slot  * on the card to schedule another transaction.  This can be a real payoff  * when doing random I/O to tagged queueing devices since there are more   * transactions active at once for the device to sort for optimal seek  * reduction. The algorithm goes like this...  *  * At the sequencer level:  * 1) Disconnected SCBs are threaded onto a doubly linked list, headed by  *    DISCONNECTED_SCBH using the SCB_NEXT and SCB_PREV fields.  The most  *    recently disconnected device is always at the head.  *  * 2) The SCB has an added field SCB_TAG that corresponds to the kernel  *    SCB number (ie 0-254).  *  * 3) When a command is queued, the hardware index of the SCB it was downloaded  *    into is placed into the QINFIFO for easy indexing by the sequencer.  *  * 4) The tag field is used as the tag for tagged-queueing, for determining  *    the related kernel SCB, and is the value put into the QOUTFIFO  *    so the kernel doesn't have to upload the SCB to determine the kernel SCB  *    that completed on command completes.  *  * 5) When a reconnect occurs, the sequencer must scan the SCB array (even  *    in the tag case) looking for the appropriate SCB and if it can't find  *    it, it interrupts the kernel so it can page the SCB in.  *  * 6) If the sequencer is successful in finding the SCB, it removes it from  *    the doubly linked list of disconnected SCBS.  *  * At the kernel level:  * 1) There are four queues that a kernel SCB may reside on:  *	free_scbs - SCBs that are not in use and have a hardware slot assigned  *		    to them.  *      page_scbs - SCBs that are not in use and need to have a hardware slot  *		    assigned to them (i.e. they will most likely cause a page  *		    out event).  *	waiting_scbs - SCBs that are active, don't have an assigned hardware  *		    slot assigned to them and are waiting for either a  *		    disconnection or a command complete to free up a slot.  *	assigned_scbs - SCBs that were in the waiting_scbs queue, but were  *		    assigned a slot by ahc_free_scb.  *  * 2) When a new request comes in, an SCB is allocated from the free_scbs or  *    page_scbs queue with preference to SCBs on the free_scbs queue.  *  * 3) If there are no free slots (we retrieved the SCB off of the page_scbs  *    queue), the SCB is inserted onto the tail of the waiting_scbs list and  *    we attempt to run this queue down.  *  * 4) ahc_run_waiing_queues() looks at both the assigned_scbs and waiting_scbs  *    queues.  In the case of the assigned_scbs, the commands are immediately  *    downloaded and started.  For waiting_scbs, we page in all that we can  *    ensuring we don't create a resource deadlock (see comments in  *    ahc_run_waing_queues()).  *  * 5) After we handle a bunch of command completes, we also try running the  *    queues since many SCBs may have disconnected since the last command  *    was started and we have at least one free slot on the card.  *  * 6) ahc_free_scb looks at the waiting_scbs queue for a transaction  *    requiring a slot and moves it to the assigned_scbs queue if it  *    finds one.  Otherwise it puts the current SCB onto the free_scbs  *    queue for later use.  *  * 7) The driver handles page-in requests from the sequencer in response to  *    the NO_MATCH sequencer interrupt.  For tagged commands, the approprite  *    SCB is easily found since the tag is a direct index into our kernel SCB  *    array.  For non-tagged commands, we keep a separate array of 16 pointers  *    that point to the single possible SCB that was paged out for that target.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<i386/scsi/aic7xxx.h>
end_include

begin_include
include|#
directive|include
file|<dev/aic7xxx/aic7xxx_reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__FreeBSD__) */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<dev/ic/aic7xxxreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/ic/aic7xxxvar.h>
end_include

begin_define
define|#
directive|define
name|bootverbose
value|1
end_define

begin_define
define|#
directive|define
name|DEBUGTARG
value|DEBUGTARGET
end_define

begin_if
if|#
directive|if
name|DEBUGTARG
operator|<
literal|0
end_if

begin_comment
comment|/* Negative numbrs for disabling cause warnings */
end_comment

begin_undef
undef|#
directive|undef
name|DEBUGTARG
end_undef

begin_define
define|#
directive|define
name|DEBUGTARG
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__NetBSD__) */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_define
define|#
directive|define
name|KVTOPHYS
parameter_list|(
name|x
parameter_list|)
value|vtophys(x)
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a< b) ? a : b)
end_define

begin_define
define|#
directive|define
name|ALL_TARGETS
value|-1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|u_long
name|ahc_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ahc_debug
init|=
name|AHC_DEBUG
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
end_ifdef

begin_decl_stmt
name|int
name|ahc_broken_cache
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "wbinvd" cause writing back whole cache (both CPU internal& external)  * to memory, so that the instruction takes a lot of time.  * This makes machine slow.  */
end_comment

begin_define
define|#
directive|define
name|INVALIDATE_CACHE
parameter_list|()
value|__asm __volatile("wbinvd")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**** bit definitions for SCSIDEF ****/
end_comment

begin_define
define|#
directive|define
name|HSCSIID
value|0x07
end_define

begin_comment
comment|/* our SCSI ID */
end_comment

begin_define
define|#
directive|define
name|HWSCSIID
value|0x0f
end_define

begin_comment
comment|/* our SCSI ID if Wide Bus */
end_comment

begin_decl_stmt
specifier|static
name|void
name|ahcminphys
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|ahc_scsi_cmd
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_adapter
name|ahc_switch
init|=
block|{
name|ahc_scsi_cmd
block|,
name|ahcminphys
block|,
literal|0
block|,
literal|0
block|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
literal|0
block|,
literal|"ahc"
block|,
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the below structure is so we have a default dev struct for our link struct */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|ahc_dev
init|=
block|{
name|NULL
block|,
comment|/* Use default error handler */
name|NULL
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
literal|"ahc"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Since the sequencer can disable pausing in a critical section, we  * must loop until it actually stops.  * XXX Should add a timeout in here??  */
end_comment

begin_define
define|#
directive|define
name|PAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|AHC_OUTB(ahc, HCNTRL, ahc->pause);			\ 								\ 	while ((AHC_INB(ahc, HCNTRL)& PAUSE) == 0)		\ 		;
end_define

begin_define
define|#
directive|define
name|UNPAUSE_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|AHC_OUTB(ahc, HCNTRL, ahc->unpause )
end_define

begin_comment
comment|/*  * Restart the sequencer program from address zero  */
end_comment

begin_define
define|#
directive|define
name|RESTART_SEQUENCER
parameter_list|(
name|ahc
parameter_list|)
define|\
value|do {								\ 		AHC_OUTB(ahc, SEQCTL, SEQRESET|FASTMODE);		\ 	} while (AHC_INB(ahc, SEQADDR0) != 0&&				\ 		 AHC_INB(ahc, SEQADDR1) != 0);				\ 									\ 	UNPAUSE_SEQUENCER(ahc);
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_comment
comment|/*  * Is device which is pointed by sc_link connected on second scsi bus ?  */
end_comment

begin_define
define|#
directive|define
name|IS_SCSIBUS_B
parameter_list|(
name|ahc
parameter_list|,
name|sc_link
parameter_list|)
define|\
value|((sc_link)->scsibus == (ahc)->sc_link_b.scsibus)
end_define

begin_comment
comment|/*  * convert FreeBSD's SCSI symbols to NetBSD's  */
end_comment

begin_define
define|#
directive|define
name|SCSI_NOMASK
value|SCSI_POLL
end_define

begin_define
define|#
directive|define
name|opennings
value|openings
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_char
name|ahc_abort_wscb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|,
name|u_char
name|prev
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32_t
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_add_waiting_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_done
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scbp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_free_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|ahc_send_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|ahc_fetch_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|ahc_page_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
expr|struct
name|scb
operator|*
name|out_scb
operator|,
expr|struct
name|scb
operator|*
name|in_scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|ahc_run_waiting_queues
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_loadseq
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_match_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_poll
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|wait
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|ahc_print_scb
name|__P
argument_list|(
operator|(
expr|struct
name|scb
operator|*
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_channel
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|char
name|channel
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32_t
name|xs_error
operator|,
name|u_char
name|initiate_reset
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ahc_reset_device
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|,
name|u_char
name|timedout_scb
operator|,
name|u_int32_t
name|xs_error
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_reset_current_bus
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_run_done_queue
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_scsirate
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|u_char
operator|*
name|scsirate
operator|,
name|int
name|period
operator|,
name|int
name|offset
operator|,
name|char
name|channel
operator|,
name|int
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|timeout_t
name|ahc_timeout
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|void
name|ahc_timeout
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|ahc_busy_target
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ahc_unbusy_target
name|__P
argument_list|(
operator|(
expr|struct
name|ahc_data
operator|*
name|ahc
operator|,
name|int
name|target
operator|,
name|char
name|channel
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|char
modifier|*
name|ahc_name
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
specifier|static
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"ahc%d"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_decl_stmt
name|struct
name|cfdriver
name|ahc_cd
init|=
block|{
name|NULL
block|,
literal|"ahc"
block|,
name|DV_DULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ahc_print_scb
parameter_list|(
name|scb
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"scb:%p control:0x%x tcl:0x%x cmdlen:%d cmdpointer:0x%lx\n"
argument_list|,
name|scb
argument_list|,
name|scb
operator|->
name|control
argument_list|,
name|scb
operator|->
name|tcl
argument_list|,
name|scb
operator|->
name|cmdlen
argument_list|,
name|scb
operator|->
name|cmdpointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        datlen:%d data:0x%lx segs:0x%x segp:0x%lx\n"
argument_list|,
name|scb
operator|->
name|datalen
argument_list|,
name|scb
operator|->
name|data
argument_list|,
name|scb
operator|->
name|SG_segment_count
argument_list|,
name|scb
operator|->
name|SG_list_pointer
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	sg_addr:%lx sg_len:%ld\n"
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|scb
operator|->
name|ahc_dma
index|[
literal|0
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|u_char
name|errno
decl_stmt|;
name|char
modifier|*
name|errmesg
decl_stmt|;
block|}
name|hard_error
index|[]
init|=
block|{
block|{
name|ILLHADDR
block|,
literal|"Illegal Host Access"
block|}
block|,
block|{
name|ILLSADDR
block|,
literal|"Illegal Sequencer Address referrenced"
block|}
block|,
block|{
name|ILLOPCODE
block|,
literal|"Illegal Opcode in sequencer program"
block|}
block|,
block|{
name|PARERR
block|,
literal|"Sequencer Ram Parity Error"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Valid SCSIRATE values.  (p. 3-17)  * Provides a mapping of tranfer periods in ns to the proper value to  * stick in the scsiscfr reg to use that transfer rate.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|short
name|sxfr
decl_stmt|;
comment|/* Rates in Ultra mode have bit 8 of sxfr set */
define|#
directive|define
name|ULTRA_SXFR
value|0x100
name|short
name|period
decl_stmt|;
comment|/* in ns */
name|char
modifier|*
name|rate
decl_stmt|;
block|}
name|ahc_syncrates
index|[]
init|=
block|{
block|{
literal|0x100
block|,
literal|50
block|,
literal|"20.0"
block|}
block|,
block|{
literal|0x110
block|,
literal|62
block|,
literal|"16.0"
block|}
block|,
block|{
literal|0x120
block|,
literal|75
block|,
literal|"13.4"
block|}
block|,
block|{
literal|0x000
block|,
literal|100
block|,
literal|"10.0"
block|}
block|,
block|{
literal|0x010
block|,
literal|125
block|,
literal|"8.0"
block|}
block|,
block|{
literal|0x020
block|,
literal|150
block|,
literal|"6.67"
block|}
block|,
block|{
literal|0x030
block|,
literal|175
block|,
literal|"5.7"
block|}
block|,
block|{
literal|0x040
block|,
literal|200
block|,
literal|"5.0"
block|}
block|,
block|{
literal|0x050
block|,
literal|225
block|,
literal|"4.4"
block|}
block|,
block|{
literal|0x060
block|,
literal|250
block|,
literal|"4.0"
block|}
block|,
block|{
literal|0x070
block|,
literal|275
block|,
literal|"3.6"
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|ahc_num_syncrates
init|=
sizeof|sizeof
argument_list|(
name|ahc_syncrates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ahc_syncrates
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate a controller structures for a new device and initialize it.  * ahc_reset should be called before now since we assume that the card  * is paused.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_decl_stmt
name|struct
name|ahc_data
modifier|*
name|ahc_alloc
argument_list|(
name|unit
argument_list|,
name|iobase
argument_list|,
name|type
argument_list|,
name|flags
argument_list|)
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|iobase
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_elif

begin_function
name|void
name|ahc_construct
parameter_list|(
name|ahc
parameter_list|,
name|bc
parameter_list|,
name|ioh
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|bus_chipset_tag_t
name|bc
decl_stmt|;
name|bus_io_handle_t
name|ioh
decl_stmt|;
endif|#
directive|endif
name|ahc_type
name|type
decl_stmt|;
name|ahc_flag
name|flags
decl_stmt|;
block|{
comment|/* 	 * find unit and check we have that many defined 	 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
comment|/* 	 * Allocate a storage area for us 	 */
name|ahc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ahc
condition|)
block|{
name|printf
argument_list|(
literal|"ahc%d: cannot malloc!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|ahc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_data
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|page_scbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ahc
operator|->
name|assigned_scbs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|baseport
operator|=
name|iobase
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_bc
operator|=
name|bc
expr_stmt|;
name|ahc
operator|->
name|sc_ioh
operator|=
name|ioh
expr_stmt|;
endif|#
directive|endif
name|ahc
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ahc
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ahc
operator|->
name|unpause
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|ahc
operator|->
name|pause
operator|=
name|ahc
operator|->
name|unpause
operator||
name|PAUSE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return
operator|(
name|ahc
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ahc_free
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|free
argument_list|(
name|ahc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc_reset
parameter_list|(
name|iobase
parameter_list|)
name|u_long
name|iobase
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
function|ahc_reset
parameter_list|(
name|devname
parameter_list|,
name|bc
parameter_list|,
name|ioh
parameter_list|)
name|char
modifier|*
name|devname
decl_stmt|;
name|bus_chipset_tag_t
name|bc
decl_stmt|;
name|bus_io_handle_t
name|ioh
decl_stmt|;
endif|#
directive|endif
block|{
name|u_char
name|hcntrl
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* Retain the IRQ type accross the chip reset */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|hcntrl
operator|=
operator|(
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|CHIPRST
operator||
name|PAUSE
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|hcntrl
operator|=
operator|(
name|bus_io_read_1
argument_list|(
name|bc
argument_list|,
name|ioh
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|IRQMS
operator|)
operator||
name|INTEN
expr_stmt|;
name|bus_io_write_1
argument_list|(
name|bc
argument_list|,
name|ioh
argument_list|,
name|HCNTRL
argument_list|,
name|CHIPRST
operator||
name|PAUSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Ensure that the reset has finished 	 */
name|wait
operator|=
literal|1000
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
while|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|inb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
while|while
condition|(
operator|--
name|wait
operator|&&
operator|!
operator|(
name|bus_io_read_1
argument_list|(
name|bc
argument_list|,
name|ioh
argument_list|,
name|HCNTRL
argument_list|)
operator|&
name|CHIPRSTACK
operator|)
condition|)
endif|#
directive|endif
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|printf
argument_list|(
literal|"ahc at 0x%lx: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|iobase
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|printf
argument_list|(
literal|"%s: WARNING - Failed chip reset!  "
literal|"Trying to initialize anyway.\n"
argument_list|,
name|devname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|outb
argument_list|(
name|HCNTRL
operator|+
name|iobase
argument_list|,
name|hcntrl
operator||
name|PAUSE
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|bus_io_write_1
argument_list|(
name|bc
argument_list|,
name|ioh
argument_list|,
name|HCNTRL
argument_list|,
name|hcntrl
operator||
name|PAUSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Look up the valid period to SCSIRATE conversion in our table.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_scsirate
parameter_list|(
name|ahc
parameter_list|,
name|scsirate
parameter_list|,
name|period
parameter_list|,
name|offset
parameter_list|,
name|channel
parameter_list|,
name|target
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_char
modifier|*
name|scsirate
decl_stmt|;
name|short
name|period
decl_stmt|;
name|u_char
name|offset
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc_num_syncrates
condition|;
name|i
operator|++
control|)
block|{
name|u_char
name|ultra_enb
decl_stmt|;
name|u_char
name|sxfrctl0
decl_stmt|;
name|u_long
name|ultra_enb_addr
decl_stmt|;
if|if
condition|(
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|period
operator|-
name|period
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * Watch out for Ultra speeds when ultra is not 			 * enabled and vice-versa. 			 */
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
operator|)
operator|&&
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
operator|)
condition|)
block|{
comment|/* 				 * This should only happen if the 				 * drive is the first to negotiate 				 * and chooses a high rate.  We'll 				 * just move down the table util 				 * we hit a non ultra speed. 				 */
continue|continue;
block|}
operator|*
name|scsirate
operator|=
operator|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|)
operator||
operator|(
name|offset
operator|&
literal|0x0f
operator|)
expr_stmt|;
comment|/* 			 * Ensure Ultra mode is set properly for 			 * this target. 			 */
name|ultra_enb_addr
operator|=
name|ULTRA_ENB
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
operator|||
name|target
operator|>
literal|7
condition|)
name|ultra_enb_addr
operator|++
expr_stmt|;
name|ultra_enb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ultra_enb_addr
argument_list|)
expr_stmt|;
name|sxfrctl0
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|sxfr
operator|&
name|ULTRA_SXFR
condition|)
block|{
name|ultra_enb
operator||=
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
expr_stmt|;
name|sxfrctl0
operator||=
name|ULTRAEN
expr_stmt|;
block|}
else|else
block|{
name|ultra_enb
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|sxfrctl0
operator|&=
operator|~
name|ULTRAEN
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ultra_enb_addr
argument_list|,
name|ultra_enb
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|sxfrctl0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d synchronous at %sMHz,"
literal|" offset = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|,
name|ahc_syncrates
index|[
name|i
index|]
operator|.
name|rate
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* Default to asyncronous transfers.  Also reject this SDTR request. */
operator|*
name|scsirate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d using asyncronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|int
name|ahcprint
parameter_list|(
name|aux
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|aux
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: scsibus "
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|UNCONF
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Attach all the sub-devices we can find  */
end_comment

begin_function
name|int
name|ahc_attach
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
if|if
condition|(
name|cpu_class
operator|==
name|CPUCLASS_386
condition|)
comment|/* doesn't have "wbinvd" instruction */
name|ahc_broken_cache
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * fill in the prototype scsi_links. 	 */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_unit
operator|=
name|ahc
operator|->
name|unit
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|fordriver
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_target
operator|=
name|ahc
operator|->
name|our_id
expr_stmt|;
endif|#
directive|endif
name|ahc
operator|->
name|sc_link
operator|.
name|adapter_softc
operator|=
name|ahc
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|adapter
operator|=
operator|&
name|ahc_switch
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|opennings
operator|=
literal|2
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|device
operator|=
operator|&
name|ahc_dev
expr_stmt|;
name|ahc
operator|->
name|sc_link
operator|.
name|flags
operator|=
name|DEBUGLEVEL
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* Configure the second scsi bus */
name|ahc
operator|->
name|sc_link_b
operator|=
name|ahc
operator|->
name|sc_link
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_targ
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_bus
operator|=
literal|1
expr_stmt|;
name|ahc
operator|->
name|sc_link_b
operator|.
name|fordriver
operator|=
operator|(
name|void
operator|*
operator|)
name|SELBUSB
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|ahc
operator|->
name|sc_link_b
operator|.
name|adapter_target
operator|=
name|ahc
operator|->
name|our_id_b
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
operator|&
name|ahc
operator|->
name|sc_link_b
else|:
operator|&
name|ahc
operator|->
name|sc_link
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing channel %c\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
name|scbus
operator|=
name|scsi_alloc_bus
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
return|return
literal|0
return|;
name|scbus
operator|->
name|adapter_link
operator|=
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
operator|&
name|ahc
operator|->
name|sc_link
else|:
operator|&
name|ahc
operator|->
name|sc_link_b
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
name|scbus
operator|->
name|maxtarg
operator|=
literal|15
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"ahc%d: Probing Channel %c\n"
argument_list|,
name|ahc
operator|->
name|unit
argument_list|,
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
condition|?
literal|'A'
else|:
literal|'B'
argument_list|)
expr_stmt|;
name|scsi_attachdevs
argument_list|(
name|scbus
argument_list|)
expr_stmt|;
name|scbus
operator|=
name|NULL
expr_stmt|;
comment|/* Upper-level SCSI code owns this now */
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * XXX - Update MI SCSI code 	 * 	 * if(ahc->type& AHC_WIDE) 	 *	max target of both channel A and B = 15; 	 */
comment|/* 	 * ask the adapter what subunits are present 	 */
if|if
condition|(
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHANNEL_B_PRIMARY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* make IS_SCSIBUS_B() == false, while probing channel A */
name|ahc
operator|->
name|sc_link_b
operator|.
name|scsibus
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
name|printf
argument_list|(
literal|"%s: Probing channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Probing channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link_b
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * if implementation of IS_SCSIBUS_B() is changed to use 		 * ahc->sc_link.scsibus, then "ahc->sc_link.scsibus = 0xff;" 		 * is needed, here. 		 */
comment|/* assert(ahc->type& AHC_TWIN); */
name|printf
argument_list|(
literal|"%s: Probing channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link_b
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Probing channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|config_found
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|,
operator|&
name|ahc
operator|->
name|sc_link
argument_list|,
name|ahcprint
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Send an SCB down to the card via PIO.  * We assume that the proper SCB is already selected in SCBPTR.   */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ahc_send_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBCNT
argument_list|,
name|SCBAUTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_284
condition|)
comment|/* Can only do 8bit PIO */
name|AHC_OUTSB
argument_list|(
name|ahc
argument_list|,
name|SCBARRAY
argument_list|,
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
else|else
name|AHC_OUTSL
argument_list|(
name|ahc
argument_list|,
name|SCBARRAY
argument_list|,
name|scb
argument_list|,
operator|(
name|SCB_PIO_TRANSFER_SIZE
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve an SCB from the card via PIO.  * We assume that the proper SCB is already selected in SCBPTR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ahc_fetch_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBCNT
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* SCBAUTO */
comment|/* Can only do 8bit PIO for reads */
name|AHC_INSB
argument_list|(
name|ahc
argument_list|,
name|SCBARRAY
argument_list|,
name|scb
argument_list|,
name|SCB_PIO_TRANSFER_SIZE
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBCNT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Swap in_scbp for out_scbp down in the cards SCB array.  * We assume that the SCB for out_scbp is already selected in SCBPTR.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|ahc_page_scb
parameter_list|(
name|ahc
parameter_list|,
name|out_scbp
parameter_list|,
name|in_scbp
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|out_scbp
decl_stmt|;
name|struct
name|scb
modifier|*
name|in_scbp
decl_stmt|;
block|{
comment|/* Page-out */
name|ahc_fetch_scb
argument_list|(
name|ahc
argument_list|,
name|out_scbp
argument_list|)
expr_stmt|;
name|out_scbp
operator|->
name|flags
operator||=
name|SCB_PAGED_OUT
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|out_scbp
operator|->
name|control
operator|&
name|TAG_ENB
operator|)
condition|)
block|{
comment|/* Stick in non-tagged array */
name|int
name|index
init|=
operator|(
name|out_scbp
operator|->
name|tcl
operator|>>
literal|4
operator|)
operator||
operator|(
name|out_scbp
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
decl_stmt|;
name|ahc
operator|->
name|pagedout_ntscbs
index|[
name|index
index|]
operator|=
name|out_scbp
expr_stmt|;
block|}
comment|/* Page-in */
name|in_scbp
operator|->
name|position
operator|=
name|out_scbp
operator|->
name|position
expr_stmt|;
name|out_scbp
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|in_scbp
argument_list|)
expr_stmt|;
name|in_scbp
operator|->
name|flags
operator|&=
operator|~
name|SCB_PAGED_OUT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|ahc_run_waiting_queues
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|u_char
name|cur_scb
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|assigned_scbs
operator|.
name|stqh_first
operator|||
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|)
condition|)
return|return;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|cur_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* 	 * First handle SCBs that are waiting but have been 	 * assigned a slot. 	 */
while|while
condition|(
operator|(
name|scb
operator|=
name|ahc
operator|->
name|assigned_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|assigned_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* Mark this as an active command */
name|scb
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now deal with SCBs that require paging */
if|if
condition|(
operator|(
name|scb
operator|=
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|u_char
name|disc_scb
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
decl_stmt|;
name|u_char
name|active
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|FLAGS
argument_list|)
operator|&
operator|(
name|SELECTED
operator||
name|IDENTIFY_SEEN
operator|)
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
do|do
block|{
name|u_char
name|next_scb
decl_stmt|;
comment|/* Attempt to page this SCB in */
if|if
condition|(
name|disc_scb
operator|==
name|SCB_LIST_NULL
condition|)
break|break;
comment|/* 			 * Advance disc_scb to the next on in the 			 * list. 			 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
name|next_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* 			 * We have to be careful about when we allow 			 * an SCB to be paged out.  There must always 			 * be at least one slot availible for a 			 * reconnecting target in case it references 			 * an SCB that has been paged out.  Our 			 * heuristic is that either the disconnected 			 * list has at least two entries in it or 			 * there is one entry and the sequencer is 			 * activily working on an SCB which implies that 			 * it will either complete or disconnect before 			 * another reconnection can occur. 			 */
if|if
condition|(
operator|(
name|next_scb
operator|!=
name|SCB_LIST_NULL
operator|)
operator|||
name|active
condition|)
block|{
name|u_char
name|out_scbi
decl_stmt|;
name|struct
name|scb
modifier|*
name|out_scbp
decl_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
comment|/* 				 * Find the in-core SCB for the one 				 * we're paging out. 				 */
name|out_scbi
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|out_scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|out_scbi
index|]
expr_stmt|;
comment|/* Do the page out */
name|ahc_page_scb
argument_list|(
name|ahc
argument_list|,
name|out_scbp
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* Mark this as an active command */
name|scb
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
comment|/* Queue the command */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|xs
operator|->
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_paged-in\n"
operator|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
comment|/* Advance to the next disconnected SCB */
name|disc_scb
operator|=
name|next_scb
expr_stmt|;
block|}
else|else
break|break;
block|}
do|while
condition|(
operator|(
name|scb
operator|=
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|count
condition|)
block|{
comment|/*  			 * Update the head of the disconnected list. 			 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|disc_scb
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Restore old position */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|cur_scb
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add this SCB to the head of the "waiting for selection" list.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_add_waiting_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|u_char
name|next
decl_stmt|;
name|u_char
name|curscb
decl_stmt|;
name|curscb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|next
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Catch an interrupt from the adapter  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|void
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|int
endif|#
directive|endif
name|ahc_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|intstat
decl_stmt|;
name|u_char
name|status
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
init|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|arg
decl_stmt|;
name|intstat
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
expr_stmt|;
comment|/* 	 * Is this interrupt for me? or for 	 * someone who is sharing my interrupt 	 */
if|if
condition|(
operator|!
operator|(
name|intstat
operator|&
name|INT_PEND
operator|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
return|return;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
literal|0
return|;
endif|#
directive|endif
if|if
condition|(
name|intstat
operator|&
name|BRKADRINT
condition|)
block|{
comment|/* We upset the sequencer :-( */
comment|/* Lookup the error message */
name|int
name|i
decl_stmt|,
name|error
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ERROR
argument_list|)
decl_stmt|;
name|int
name|num_errors
init|=
sizeof|sizeof
argument_list|(
name|hard_error
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|hard_error
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|error
operator|!=
literal|1
operator|&&
name|i
operator|<
name|num_errors
condition|;
name|i
operator|++
control|)
name|error
operator|>>=
literal|1
expr_stmt|;
name|panic
argument_list|(
literal|"%s: brkadrint, %s at seqaddr = 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|hard_error
index|[
name|i
index|]
operator|.
name|errmesg
argument_list|,
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SEQINT
condition|)
block|{
name|u_short
name|targ_mask
decl_stmt|;
name|u_char
name|target
init|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|)
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|u_char
name|scratch_offset
init|=
name|target
decl_stmt|;
name|char
name|channel
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
name|scratch_offset
operator|+=
literal|8
expr_stmt|;
name|targ_mask
operator|=
operator|(
literal|0x01
operator|<<
name|scratch_offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|intstat
operator|&
name|SEQINT_MASK
condition|)
block|{
case|case
name|NO_MATCH
case|:
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
condition|)
block|{
comment|/* SCB Page-in request */
name|u_char
name|tag
decl_stmt|;
name|u_char
name|next
decl_stmt|;
name|u_char
name|disc_scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|outscb
decl_stmt|;
name|u_char
name|arg_1
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
decl_stmt|;
comment|/* 				 * We should succeed, so set this now. 				 * If we don't, and one of the methods 				 * we use to aquire an SCB calls ahc_done, 				 * we may wind up in our start routine 				 * and unpause the adapter without giving 				 * it the correct return value, which will 				 * cause a hang. 				 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SCB_PAGEDIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg_1
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* Non-tagged command */
name|int
name|index
init|=
name|target
operator||
operator|(
name|channel
operator|==
literal|'B'
condition|?
name|SELBUSB
else|:
literal|0
operator|)
decl_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|pagedout_ntscbs
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|arg_1
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PAGED_OUT
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: Request to page in a"
literal|"non paged out SCB."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Now to pick the SCB to page out. 				 * Either take a free SCB, an assigned SCB, 				 * an SCB that just completed, the first 				 * one on the disconnected SCB list, or 				 * as a last resort a queued SCB. 				 */
if|if
condition|(
name|ahc
operator|->
name|free_scbs
operator|.
name|stqh_first
condition|)
block|{
name|outscb
operator|=
name|ahc
operator|->
name|free_scbs
operator|.
name|stqh_first
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|position
operator|=
name|outscb
operator|->
name|position
expr_stmt|;
name|outscb
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|page_scbs
argument_list|,
name|outscb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_PAGED_OUT
expr_stmt|;
goto|goto
name|pagein_done
goto|;
block|}
if|if
condition|(
name|ahc
operator|->
name|assigned_scbs
operator|.
name|stqh_first
condition|)
block|{
name|outscb
operator|=
name|ahc
operator|->
name|assigned_scbs
operator|.
name|stqh_first
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|assigned_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|scb
operator|->
name|position
operator|=
name|outscb
operator|->
name|position
expr_stmt|;
name|outscb
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|outscb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|outscb
operator|->
name|flags
operator|=
name|SCB_WAITINGQ
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_PAGED_OUT
expr_stmt|;
goto|goto
name|pagein_done
goto|;
block|}
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|int
name|scb_index
decl_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QOUTFIFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QOUTCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
operator|)
condition|)
name|intstat
operator|&=
operator|~
name|CMDCMPLT
expr_stmt|;
name|outscb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|outscb
operator|||
operator|!
operator|(
name|outscb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING "
literal|"no command for scb %d (cmdcmplt)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
comment|/* Fall through in hopes of finding another SCB */
block|}
else|else
block|{
name|scb
operator|->
name|position
operator|=
name|outscb
operator|->
name|position
expr_stmt|;
name|outscb
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_PAGED_OUT
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|outscb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|outscb
argument_list|)
expr_stmt|;
goto|goto
name|pagein_done
goto|;
block|}
block|}
name|disc_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|)
expr_stmt|;
if|if
condition|(
name|disc_scb
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
name|tag
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|outscb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|tag
index|]
expr_stmt|;
name|next
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|ahc_page_scb
argument_list|(
name|ahc
argument_list|,
name|outscb
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
condition|)
block|{
comment|/* Pull one of our queued commands as a last resort */
name|disc_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|disc_scb
argument_list|)
expr_stmt|;
name|tag
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|outscb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|tag
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|outscb
operator|->
name|control
operator|&
literal|0x23
operator|)
operator|!=
name|TAG_ENB
condition|)
block|{
comment|/* 						 * This is not a simple tagged command 						 * so its position in the queue 						 * matters.  Take the command at the 						 * end of the queue instead. 						 */
name|int
name|i
decl_stmt|;
name|u_char
name|saved_queue
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
name|u_char
name|queued
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
decl_stmt|;
comment|/* Count the command we removed already */
name|saved_queue
index|[
literal|0
index|]
operator|=
name|disc_scb
expr_stmt|;
name|queued
operator|++
expr_stmt|;
comment|/* Empty the input queue */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|queued
condition|;
name|i
operator|++
control|)
name|saved_queue
index|[
name|i
index|]
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|)
expr_stmt|;
comment|/* Put everyone back put the last entry */
name|queued
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|queued
condition|;
name|i
operator|++
control|)
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|saved_queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_queue
index|[
name|queued
index|]
argument_list|)
expr_stmt|;
name|tag
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|outscb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|tag
index|]
expr_stmt|;
block|}
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|outscb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|position
operator|=
name|outscb
operator|->
name|position
expr_stmt|;
name|outscb
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|outscb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|outscb
operator|->
name|flags
operator|=
name|SCB_WAITINGQ
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_PAGED_OUT
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Page-in request with no candidates"
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pagein_done
label|:
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: no active SCB for "
literal|"reconnecting target - "
literal|"issuing ABORT\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SAVED_TCL == 0x%x\n"
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SEND_REJECT
case|:
block|{
name|u_char
name|rejbyte
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|REJBYTE
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|rejbyte
operator|&
literal|0xf0
operator|)
operator|==
literal|0x20
condition|)
block|{
comment|/* Tagged Message */
name|printf
argument_list|(
literal|"\n%s:%c:%d: Tagged message "
literal|"received without identify. "
literal|"Disabling tagged commands "
literal|"for this target.\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|&=
operator|~
name|targ_mask
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s:%c:%d: Warning - "
literal|"unknown message recieved from "
literal|"target (0x%x - 0x%x).  Rejecting\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|rejbyte
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|REJBYTE_EXT
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NO_IDENT
case|:
name|panic
argument_list|(
literal|"%s:%c:%d: Target did not send an IDENTIFY "
literal|"message. SAVED_TCL == 0x%x\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SAVED_TCL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BAD_PHASE
case|:
name|printf
argument_list|(
literal|"%s:%c:%d: unknown scsi bus phase.  "
literal|"Attempting to continue\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDTR_MSG
case|:
block|{
name|short
name|period
decl_stmt|;
name|u_char
name|offset
decl_stmt|,
name|rate
decl_stmt|;
name|u_char
name|targ_scratch
decl_stmt|;
name|u_char
name|maxoffset
decl_stmt|;
comment|/*  				 * Help the sequencer to translate the  				 * negotiated transfer rate.  Transfer is  				 * 1/4 the period in ns as is returned by  				 * the sync negotiation message.  So, we must  				 * multiply by four 				 */
name|period
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
operator|<<
literal|2
expr_stmt|;
name|offset
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ACCUM
argument_list|)
expr_stmt|;
name|targ_scratch
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_scratch
operator|&
name|WIDEXFER
condition|)
name|maxoffset
operator|=
literal|0x08
expr_stmt|;
else|else
name|maxoffset
operator|=
literal|0x0f
expr_stmt|;
name|ahc_scsirate
argument_list|(
name|ahc
argument_list|,
operator|&
name|rate
argument_list|,
name|period
argument_list|,
name|MIN
argument_list|(
name|offset
argument_list|,
name|maxoffset
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Preserve the WideXfer flag */
name|targ_scratch
operator|=
name|rate
operator||
operator|(
name|targ_scratch
operator|&
name|WIDEXFER
operator|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|targ_scratch
operator|&
literal|0x0f
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * The requested rate was so low 					 * that asyncronous transfers are 					 * faster (not to mention the 					 * controller won't support them), 					 * so we issue a message reject to 					 * ensure we go to asyncronous 					 * transfers. 					 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
block|}
comment|/* See if we initiated Sync Negotiation */
elseif|else
if|if
condition|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* 					 * Don't send an SDTR back to 					 * the target 					 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Send our own SDTR in reply 					 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"Sending SDTR!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SDTR
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Negate the flags 				 */
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
break|break;
block|}
case|case
name|WDTR_MSG
case|:
block|{
name|u_char
name|scratch
decl_stmt|,
name|bus_width
decl_stmt|;
name|bus_width
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|ARG_1
argument_list|)
expr_stmt|;
name|scratch
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* 					 * Don't send a WDTR back to the 					 * target, since we asked first. 					 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: target "
literal|"%d using 16Bit "
literal|"transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x80
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
comment|/* 						     * How can we do 32bit 						     * transfers on a 16bit 						     * bus? 						     */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_REJ
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: target "
literal|"%d requested 32Bit "
literal|"transfers.  "
literal|"Rejecting...\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * Send our own WDTR in reply 					 */
switch|switch
condition|(
name|bus_width
condition|)
block|{
case|case
name|BUS_8_BIT
case|:
name|scratch
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
name|BUS_32_BIT
case|:
case|case
name|BUS_16_BIT
case|:
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
block|{
comment|/* Negotiate 16_BITS */
name|bus_width
operator|=
name|BUS_16_BIT
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: "
literal|"target %d "
literal|"using 16Bit "
literal|"transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|scratch
operator||=
literal|0x80
expr_stmt|;
block|}
else|else
name|bus_width
operator|=
name|BUS_8_BIT
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|bus_width
operator||
name|SEND_WDTR
argument_list|)
expr_stmt|;
block|}
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|REJECT_MSG
case|:
block|{
comment|/* 				 * What we care about here is if we had an 				 * outstanding SDTR or WDTR message for this 				 * target.  If we did, this is a signal that 				 * the target is refusing negotiation. 				 */
name|u_char
name|targ_scratch
decl_stmt|;
name|targ_scratch
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* note 8bit xfers and clear flag */
name|targ_scratch
operator|&=
literal|0x7f
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses "
literal|"WIDE negotiation.  Using "
literal|"8bit transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|targ_mask
condition|)
block|{
comment|/* note asynch xfers and clear flag */
name|targ_scratch
operator|&=
literal|0xf0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|printf
argument_list|(
literal|"%s:%c:%d: refuses "
literal|"syncronous negotiation.  Using "
literal|"asyncronous transfers\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Otherwise, we ignore it. 					 */
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"%s:%c:%d: Message "
literal|"reject -- ignored\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSIRATE
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BAD_STATUS
case|:
block|{
name|int
name|scb_index
decl_stmt|;
comment|/* The sequencer will notify us when a command 			   * has an error that would be of interest to 			   * the kernel.  This allows us to leave the sequencer 			   * running in the common case of command completes 			   * without error. 			   */
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 			   * Set the default return value to 0 (don't 			   * send sense).  The sense code will change 			   * this if needed and this reduces code 			   * duplication. 			   */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%c:%d: ahc_intr - referenced scb "
literal|"not valid during seqint 0x%x scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|target
argument_list|,
name|intstat
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
goto|goto
name|clear
goto|;
block|}
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|scb
operator|->
name|status
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TARGET_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
operator|)
operator|&&
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xs
operator|->
name|status
operator|=
name|scb
operator|->
name|status
expr_stmt|;
switch|switch
condition|(
name|scb
operator|->
name|status
condition|)
block|{
case|case
name|SCSI_OK
case|:
name|printf
argument_list|(
literal|"%s: Interrupted for staus of"
literal|" 0???\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_CHECK
case|:
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"requests Check Status\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
operator|)
operator|&&
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|struct
name|ahc_dma_seg
modifier|*
name|sg
init|=
name|scb
operator|->
name|ahc_dma
decl_stmt|;
name|struct
name|scsi_sense
modifier|*
name|sc
init|=
operator|&
operator|(
name|scb
operator|->
name|sense_cmd
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWSENSE
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sending Sense\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|sc
operator|->
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|sc
operator|->
name|opcode
operator|=
name|REQUEST_SENSE
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|byte2
operator|=
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|<<
literal|5
expr_stmt|;
name|sc
operator|->
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|sg
operator|->
name|addr
operator|=
name|KVTOPHYS
argument_list|(
operator|&
name|xs
operator|->
name|sense
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_sense_data
argument_list|)
expr_stmt|;
name|scb
operator|->
name|control
operator|&=
name|DISCENB
expr_stmt|;
name|scb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|scb
operator|->
name|data
operator|=
name|sg
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|sg
operator|->
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
if|if
condition|(
name|ahc_broken_cache
condition|)
name|INVALIDATE_CACHE
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator||=
name|SCB_SENSE
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* 					 * Ensure that the target is "BUSY" 					 * so we don't get overlapping  					 * commands if we happen to be doing 					 * tagged I/O. 					 */
name|ahc_busy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* 					 * Make us the next command to run 					 */
name|ahc_add_waiting_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|RETURN_1
argument_list|,
name|SEND_SENSE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * Clear the SCB_SENSE Flag and have 				 * the sequencer do a normal command 				 * complete with either a "DRIVER_STUFFUP" 				 * error or whatever other error condition 				 * we already had. 				 */
name|scb
operator|->
name|flags
operator|&=
operator|~
name|SCB_SENSE
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
case|case
name|SCSI_BUSY
case|:
name|xs
operator|->
name|error
operator|=
name|XS_BUSY
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Target Busy\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_QUEUE_FULL
case|:
comment|/* 				 * The upper level SCSI code will someday 				 * handle this properly. 				 */
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Queue Full\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ASSIGNEDQ
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahc
operator|->
name|assigned_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unexpected targ_status: %x\n"
argument_list|,
name|scb
operator|->
name|status
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
break|break;
block|}
break|break;
block|}
case|case
name|RESIDUAL
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
comment|/* 			 * Don't clobber valid resid info with 			 * a resid coming from a check sense 			 * operation. 			 */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
operator|)
condition|)
block|{
name|int
name|resid_sgs
decl_stmt|;
comment|/* 				 * Remainder of the SG where the transfer 				 * stopped. 				 */
name|xs
operator|->
name|resid
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT2
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_DCNT0
argument_list|)
expr_stmt|;
comment|/* 				 * Add up the contents of all residual 				 * SG segments that are after the SG where 				 * the transfer stopped. 				 */
name|resid_sgs
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_RESID_SGCNT
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|resid_sgs
operator|>
literal|0
condition|)
block|{
name|int
name|sg
decl_stmt|;
name|sg
operator|=
name|scb
operator|->
name|SG_segment_count
operator|-
name|resid_sgs
expr_stmt|;
name|xs
operator|->
name|resid
operator|+=
name|scb
operator|->
name|ahc_dma
index|[
name|sg
index|]
operator|.
name|len
expr_stmt|;
name|resid_sgs
operator|--
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* XXX - Update to do this right */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Handled Residual of %ld bytes\n"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
block|}
case|case
name|ABORT_TAG
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
comment|/* 			 * We didn't recieve a valid tag back from 			 * the target on a reconnect. 			 */
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"invalid tag recieved -- sending ABORT_TAG\n"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|AWAITING_MSG
case|:
block|{
name|int
name|scb_index
decl_stmt|;
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
comment|/* 			 * This SCB had a zero length command, informing 			 * the sequencer that we wanted to send a special 			 * message to this target.  We only do this for 			 * BUS_DEVICE_RESET messages currently. 			 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG0
argument_list|,
name|MSG_BUS_DEVICE_RESET
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset Message Sent\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ahc_intr: AWAITING_MSG for an SCB that "
literal|"does not have a waiting message"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IMMEDDONE
case|:
block|{
comment|/* 			 * Take care of device reset messages 			 */
name|u_char
name|scbindex
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scbindex
index|]
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_DEVICE_RESET
condition|)
block|{
name|u_char
name|targ_scratch
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 				 * Go back to async/narrow transfers and 				 * renegotiate. 				 */
name|ahc_unbusy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator||=
name|ahc
operator|->
name|needsdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator||=
name|ahc
operator|->
name|needwdtr_orig
operator|&
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|&=
operator|~
name|targ_mask
expr_stmt|;
name|targ_scratch
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|scratch_offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_NOERROR
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Bus Device Reset delivered. "
literal|"%d SCBs aborted\n"
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|in_timeout
operator|=
name|FALSE
expr_stmt|;
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"ahc_intr: Immediate complete for "
literal|"unknown operation."
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|NOT_YET
comment|/* XXX Fill these in later */
case|case
name|MESG_BUFFER_BUSY
case|:
break|break;
case|case
name|MSGIN_PHASEMIS
case|:
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"ahc_intr: seqint, "
literal|"intstat == 0x%x, scsisigi = 0x%x\n"
argument_list|,
name|intstat
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|clear
label|:
comment|/* 		 * Clear the upper byte that holds SEQINT status 		 * codes and clear the SEQINT bit. 		 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSEQINT
argument_list|)
expr_stmt|;
comment|/* 		 *  The sequencer is paused immediately on 		 *  a SEQINT, so we should restart it when 		 *  we leave this section. 		 */
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intstat
operator|&
name|SCSIINT
condition|)
block|{
name|int
name|scb_index
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
decl_stmt|;
name|status
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SSTAT1
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
name|status
operator|&
name|SCSIRSTI
condition|)
block|{
name|char
name|channel
decl_stmt|;
name|channel
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|channel
operator|=
name|channel
operator|&
name|SELBUSB
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Someone reset channel %c\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|)
expr_stmt|;
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|SCB_LIST_NULL
argument_list|,
name|XS_BUSY
argument_list|,
comment|/* Initiate Reset */
name|FALSE
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|scb
operator|&&
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ahc_intr - referenced scb not "
literal|"valid during scsiint 0x%x scb(%d)\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|status
argument_list|,
name|scb_index
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|SCSIPERR
condition|)
block|{
comment|/* 			 * Determine the bus phase and 			 * queue an appropriate message 			 */
name|char
modifier|*
name|phase
decl_stmt|;
name|u_char
name|mesg_out
init|=
name|MSG_NOP
decl_stmt|;
name|u_char
name|lastphase
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
decl_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lastphase
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|phase
operator|=
literal|"Data-Out"
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|phase
operator|=
literal|"Data-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERROR
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|phase
operator|=
literal|"Command"
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|phase
operator|=
literal|"Message-Out"
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|phase
operator|=
literal|"Status"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_INITIATOR_DET_ERROR
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|phase
operator|=
literal|"Message-In"
expr_stmt|;
name|mesg_out
operator|=
name|MSG_MSG_PARITY_ERROR
expr_stmt|;
break|break;
default|default:
name|phase
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"parity error during %s phase.\n"
argument_list|,
name|phase
argument_list|)
expr_stmt|;
comment|/* 			 * We've set the hardware to assert ATN if we 			 * get a parity error on "in" phases, so all we 			 * need to do is stuff the message buffer with 			 * the appropriate message.  "In" phases have set 			 * mesg_out to something other than MSG_NOP. 			 */
if|if
condition|(
name|mesg_out
operator|!=
name|MSG_NOP
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG0
argument_list|,
name|mesg_out
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* 				 * Should we allow the target to make 				 * this decision for us? 				 */
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|&
name|SELTO
condition|)
block|{
name|u_char
name|waiting
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|xs
operator|=
name|scb
operator|->
name|xs
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_SELTIMEOUT
expr_stmt|;
comment|/* 			 * Clear any pending messages for the timed out 			 * target, and mark the target as free 			 */
name|flags
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|FLAGS
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|(
operator|(
name|long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
name|SELBUSB
operator|)
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
endif|#
directive|endif
condition|?
literal|'B'
else|:
literal|'A'
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
comment|/* Shift the waiting for selection queue forward */
name|waiting
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
name|waiting
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|waiting
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|BUSFREE
operator|)
condition|)
block|{
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unknown SCSIINT. Status = 0x%x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|scb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|scb
operator|!=
name|NULL
condition|)
block|{
comment|/* We want to process the command */
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|intstat
operator|&
name|CMDCMPLT
condition|)
block|{
name|int
name|scb_index
decl_stmt|;
do|do
block|{
name|scb_index
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QOUTFIFO
argument_list|)
expr_stmt|;
name|scb
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|scb_index
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|||
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: WARNING "
literal|"no command for scb %d (cmdcmplt)\n"
literal|"QOUTCNT == %d\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|scb_index
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QOUTCNT
argument_list|)
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRCMDINT
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QOUTCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
condition|)
do|;
name|ahc_run_waiting_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * We have a scb which has been processed by the  * adaptor, now we look to see how the operation  * went.  */
end_comment

begin_function
specifier|static
name|void
name|ahc_done
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
name|scb
operator|->
name|xs
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_done\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Put the results of the operation 	 * into the xfer and call whoever started it 	 */
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
if|if
condition|(
name|xs
operator|->
name|error
operator|!=
name|XS_NOERROR
condition|)
block|{
comment|/* Don't override the error value. */
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENSE
condition|)
name|xs
operator|->
name|error
operator|=
name|XS_SENSE
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_SENTORDEREDTAG
condition|)
name|ahc
operator|->
name|in_timeout
operator|=
name|FALSE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
if|if
condition|(
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
operator|)
operator|&&
operator|!
operator|(
name|xs
operator|->
name|error
operator|==
name|XS_SENSE
operator|)
condition|)
block|{
comment|/* All went correctly  OR errors expected */
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
comment|/* 	 * Since NetBSD doesn't have error ignoring operation mode 	 * (SCSI_ERR_OK in FreeBSD), we don't have to care this case. 	 */
endif|#
directive|endif
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_TAGENABLE
if|if
condition|(
name|xs
operator|->
name|cmd
operator|->
name|opcode
operator|==
name|INQUIRY
operator|&&
name|xs
operator|->
name|error
operator|==
name|XS_NOERROR
condition|)
block|{
name|struct
name|scsi_inquiry_data
modifier|*
name|inq_data
decl_stmt|;
name|u_short
name|mask
init|=
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator||
operator|(
name|scb
operator|->
name|tcl
operator|&
literal|0x08
operator|)
operator|)
decl_stmt|;
comment|/* 		 * Sneak a look at the results of the SCSI Inquiry 		 * command and see if we can do Tagged queing.  This 		 * should really be done by the higher level drivers. 		 */
name|inq_data
operator|=
operator|(
expr|struct
name|scsi_inquiry_data
operator|*
operator|)
name|xs
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|inq_data
operator|->
name|flags
operator|&
name|SID_CmdQue
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: target %d Tagged Queuing Device\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|xs
operator|->
name|sc_link
operator|->
name|target
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator||=
name|mask
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|maxhscbs
operator|>=
literal|16
operator|||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
condition|)
block|{
comment|/* Default to 8 tags */
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Default to 4 tags on whimpy 				 * cards that don't have much SCB 				 * space and can't page.  This prevents 				 * a single device from hogging all 				 * slots.  We should really have a better 				 * way of providing fairness. 				 */
name|xs
operator|->
name|sc_link
operator|->
name|opennings
operator|+=
literal|2
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|scsi_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the board, ready for normal operation  */
end_comment

begin_function
name|int
name|ahc_init
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|u_char
name|scsi_conf
decl_stmt|,
name|sblkctl
decl_stmt|,
name|i
decl_stmt|;
name|u_short
name|ultraenable
init|=
literal|0
decl_stmt|;
name|int
name|max_targ
init|=
literal|15
decl_stmt|;
comment|/* 	 * Assume we have a board at this stage and it has been reset. 	 */
comment|/* Handle the SCBPAGING option */
ifndef|#
directive|ifndef
name|AHC_SCBPAGING_ENABLE
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
endif|#
directive|endif
comment|/* Determine channel configuration and who we are on the scsi bus. */
switch|switch
condition|(
operator|(
name|sblkctl
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
operator|&
literal|0x0a
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_CHANNEL_B_PRIMARY
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_394
condition|)
name|printf
argument_list|(
literal|"Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Single Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|FLAGS
argument_list|,
name|SINGLE_BUS
operator||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
operator|&
name|HWSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_CHANNEL_B_PRIMARY
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|==
name|AHC_394
condition|)
name|printf
argument_list|(
literal|"Wide Channel %c, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|flags
operator|&
name|AHC_CHNLB
condition|?
literal|'B'
else|:
literal|'A'
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Wide Channel, SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_WIDE
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|FLAGS
argument_list|,
name|WIDE_BUS
operator||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|ahc
operator|->
name|our_id
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|ahc
operator|->
name|our_id_b
operator|=
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
operator|&
name|HSCSIID
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"Twin Channel, A SCSI Id=%d, B SCSI Id=%d, "
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|type
operator||=
name|AHC_TWIN
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|FLAGS
argument_list|,
name|TWIN_BUS
operator||
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" Unsupported adapter type.  Ignoring\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Determine the number of SCBs */
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|AHC_SCB_MAX
condition|;
name|i
operator|++
control|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
name|i
condition|)
break|break;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Clear the control byte. */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator||=
name|i
expr_stmt|;
comment|/* Update the count mask. */
block|}
comment|/* Ensure we clear the 0 SCB's control byte. */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|qcntmask
operator||=
name|i
expr_stmt|;
name|ahc
operator|->
name|maxhscbs
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ahc
operator|->
name|maxhscbs
operator|<
name|AHC_SCB_MAX
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
operator|)
condition|)
name|ahc
operator|->
name|maxscbs
operator|=
name|AHC_SCB_MAX
expr_stmt|;
else|else
block|{
name|ahc
operator|->
name|maxscbs
operator|=
name|ahc
operator|->
name|maxhscbs
expr_stmt|;
name|ahc
operator|->
name|flags
operator|&=
operator|~
name|AHC_PAGESCBS
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%d SCBs\n"
argument_list|,
name|ahc
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
block|{
name|struct
name|scb
name|test
decl_stmt|;
name|printf
argument_list|(
literal|"%s: hardware scb %ld bytes; kernel scb; "
literal|"ahc_dma %d bytes\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
operator|&
operator|(
name|test
operator|.
name|next
operator|)
operator|-
call|(
name|u_long
call|)
argument_list|(
operator|&
name|test
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ahc_dma_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AHC_DEBUG */
comment|/* Set the SCSI Id, SXFRCTL0, SXFRCTL1, and SIMODE1, for both channels*/
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_TWIN
condition|)
block|{
comment|/* 		 * The device is gated to channel B after a chip reset, 		 * so set those values first 		 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id_b
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
operator|+
literal|1
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|ULTRAEN
argument_list|)
expr_stmt|;
else|else
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Reseting Channel B\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure we don't get a RSTI interrupt from this */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
comment|/* Select Channel A */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSIID
argument_list|,
name|ahc
operator|->
name|our_id
argument_list|)
expr_stmt|;
name|scsi_conf
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSICONF
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL1
argument_list|,
operator|(
name|scsi_conf
operator|&
operator|(
name|ENSPCHK
operator||
name|STIMESEL
operator|)
operator|)
operator||
name|ENSTIMER
operator||
name|ACTNEGEN
operator||
name|STPWEN
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SIMODE1
argument_list|,
name|ENSELTIMO
operator||
name|ENSCSIRST
operator||
name|ENSCSIPERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
operator||
name|ULTRAEN
argument_list|)
expr_stmt|;
else|else
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SXFRCTL0
argument_list|,
name|DFON
operator||
name|SPIOEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_conf
operator|&
name|RESET_SCSI
condition|)
block|{
comment|/* Reset the bus */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Reseting Channel A\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Ensure we don't get a RSTI interrupt from this */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look at the information that board initialization or 	 * the board bios has left us.  In the lower four bits of each 	 * target's scratch space any value other than 0 indicates 	 * that we should initiate syncronous transfers.  If it's zero, 	 * the user or the BIOS has decided to disable syncronous 	 * negotiation to that target so we don't activate the needsdtr 	 * flag. 	 */
name|ahc
operator|->
name|needsdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
comment|/* Grab the disconnection disable table and invert it for our needs */
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Host Adapter Bios disabled.  Using default SCSI "
literal|"device parameters\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|discenable
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
name|ahc
operator|->
name|discenable
operator|=
operator|~
operator|(
operator|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
operator|+
literal|1
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|DISC_DSB
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
operator|(
name|AHC_WIDE
operator||
name|AHC_TWIN
operator|)
operator|)
condition|)
name|max_targ
operator|=
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max_targ
condition|;
name|i
operator|++
control|)
block|{
name|u_char
name|target_settings
decl_stmt|;
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_USEDEFAULTS
condition|)
block|{
name|target_settings
operator|=
literal|0
expr_stmt|;
comment|/* 10MHz */
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Take the settings leftover in scratch RAM. */
name|target_settings
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_settings
operator|&
literal|0x0f
condition|)
block|{
name|ahc
operator|->
name|needsdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/*Default to a asyncronous transfers(0 offset)*/
name|target_settings
operator|&=
literal|0xf0
expr_stmt|;
block|}
if|if
condition|(
name|target_settings
operator|&
literal|0x80
condition|)
block|{
name|ahc
operator|->
name|needwdtr_orig
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
comment|/* 				 * We'll set the Wide flag when we 				 * are successful with Wide negotiation. 				 * Turn it off for now so we aren't 				 * confused. 				 */
name|target_settings
operator|&=
literal|0x7f
expr_stmt|;
block|}
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_ULTRA
condition|)
block|{
comment|/* 				 * Enable Ultra for any target that 				 * has a valid ultra syncrate setting. 				 */
name|u_char
name|rate
init|=
name|target_settings
operator|&
literal|0x70
decl_stmt|;
if|if
condition|(
name|rate
operator|==
literal|0x00
operator|||
name|rate
operator|==
literal|0x10
operator|||
name|rate
operator|==
literal|0x20
operator|||
name|rate
operator|==
literal|0x40
condition|)
block|{
if|if
condition|(
name|rate
operator|==
literal|0x40
condition|)
block|{
comment|/* Treat 10MHz specially */
name|target_settings
operator|&=
operator|~
literal|0x70
expr_stmt|;
block|}
else|else
name|ultraenable
operator||=
operator|(
literal|0x01
operator|<<
name|i
operator|)
expr_stmt|;
block|}
block|}
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|TARG_SCRATCH
operator|+
name|i
argument_list|,
name|target_settings
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are not a WIDE device, forget WDTR.  This 	 * makes the driver work on some cards that don't 	 * leave these fields cleared when the BIOS is not 	 * installed. 	 */
if|if
condition|(
operator|!
operator|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
operator|)
condition|)
name|ahc
operator|->
name|needwdtr_orig
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|tagenable
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|=
literal|0
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
argument_list|,
name|ultraenable
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ULTRA_ENB
operator|+
literal|1
argument_list|,
operator|(
name|ultraenable
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
comment|/* How did we do? */
if|if
condition|(
name|ahc_debug
operator|&
name|AHC_SHOWMISC
condition|)
name|printf
argument_list|(
literal|"NEEDSDTR == 0x%x\nNEEDWDTR == 0x%x\n"
literal|"DISCENABLE == 0x%x\n"
argument_list|,
name|ahc
operator|->
name|needsdtr
argument_list|,
name|ahc
operator|->
name|needwdtr
argument_list|,
name|ahc
operator|->
name|discenable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set the number of availible SCBs 	 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBCOUNT
argument_list|,
name|ahc
operator|->
name|maxhscbs
argument_list|)
expr_stmt|;
comment|/* 	 * 2's compliment of maximum tag value 	 */
name|i
operator|=
name|ahc
operator|->
name|maxscbs
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|COMP_SCBCOUNT
argument_list|,
operator|-
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* 	 * QCount mask to deal with broken aic7850s that 	 * sporatically get garbage in the upper bits of 	 * their QCount registers. 	 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QCNTMASK
argument_list|,
name|ahc
operator|->
name|qcntmask
argument_list|)
expr_stmt|;
comment|/* We don't have any busy targets right now */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* We don't have any waiting selections */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Our disconnection list is empty too */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
comment|/* Message out buffer starts empty */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 	 * Load the Sequencer program and Enable the adapter 	 * in "fast" mode.          */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: Downloading Sequencer Program..."
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|ahc_loadseq
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Done\n"
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|FASTMODE
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are going and return (to probe) 	 */
name|ahc
operator|->
name|flags
operator||=
name|AHC_INIT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahcminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
comment|/*  * Even though the card can transfer up to 16megs per command  * we are limited by the number of segments in the dma segment  * list that we can hold.  The worst case is that all pages are  * discontinuous physically, hense the "page per segment" limit  * enforced here.  */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
operator|(
operator|(
name|AHC_NSEG
operator|-
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|minphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * start a scsi operation given the command and  * the data address, target, and lun all of which  * are stored in the scsi_xfer struct  */
end_comment

begin_function
specifier|static
name|int32_t
name|ahc_scsi_cmd
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|struct
name|ahc_dma_seg
modifier|*
name|sg
decl_stmt|;
name|int
name|seg
decl_stmt|;
comment|/* scatter gather seg being worked on */
name|int
name|thiskv
decl_stmt|;
name|physaddr
name|thisphys
decl_stmt|,
name|nextphys
decl_stmt|;
name|int
name|bytes_this_seg
decl_stmt|,
name|bytes_this_page
decl_stmt|,
name|datalen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_short
name|mask
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ahc
operator|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
name|mask
operator|=
operator|(
literal|0x01
operator|<<
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator||
operator|(
operator|(
name|u_long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
literal|0x08
operator|)
operator|)
operator|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator||
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
block|)
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ahc_scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*          * get an scb to use. If the transfer          * is from a buf (possibly from interrupt time)          * then we can't allow it to sleep          */
end_comment

begin_expr_stmt
name|flags
operator|=
name|xs
operator|->
name|flags
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|flags
operator|&
name|ITSDONE
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Already done?"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|INUSE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Not in use?"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|INUSE
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|scb
operator|=
name|ahc_get_scb
argument_list|(
name|ahc
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
return|return
operator|(
name|TRY_AGAIN_LATER
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"start scb(%p)\n"
operator|,
name|scb
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scb
operator|->
name|xs
operator|=
name|xs
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|flags
operator|&
name|SCSI_RESET
condition|)
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_IMMED
expr_stmt|;
end_if

begin_comment
comment|/*          * Put all the arguments for the xfer in the scb          */
end_comment

begin_if
if|if
condition|(
name|ahc
operator|->
name|tagenable
operator|&
name|mask
condition|)
block|{
name|scb
operator|->
name|control
operator||=
name|TAG_ENB
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|orderedtag
operator|&
name|mask
condition|)
block|{
name|printf
argument_list|(
literal|"Ordered Tag sent\n"
argument_list|)
expr_stmt|;
name|scb
operator|->
name|control
operator||=
literal|0x02
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|ahc
operator|->
name|discenable
operator|&
name|mask
condition|)
name|scb
operator|->
name|control
operator||=
name|DISCENB
expr_stmt|;
end_if

begin_if
if|if
condition|(
operator|(
name|ahc
operator|->
name|needwdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|wdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|scb
operator|->
name|control
operator||=
name|NEEDWDTR
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator||=
name|mask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ahc
operator|->
name|needsdtr
operator|&
name|mask
operator|)
operator|&&
operator|!
operator|(
name|ahc
operator|->
name|sdtrpending
operator|&
name|mask
operator|)
condition|)
block|{
name|scb
operator|->
name|control
operator||=
name|NEEDSDTR
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator||=
name|mask
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|scb
operator|->
name|tcl
operator|=
operator|(
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|<<
literal|4
operator|)
operator|&
literal|0xF0
operator|)
operator||
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|(
operator|(
name|u_long
operator|)
name|xs
operator|->
name|sc_link
operator|->
name|fordriver
operator|&
literal|0x08
operator|)
operator||
elif|#
directive|elif
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|(
name|IS_SCSIBUS_B
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
condition|?
name|SELBUSB
else|:
literal|0
operator|)
operator||
endif|#
directive|endif
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|lun
operator|&
literal|0x07
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scb
operator|->
name|cmdlen
operator|=
name|xs
operator|->
name|cmdlen
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|scb
operator|->
name|cmdpointer
operator|=
name|KVTOPHYS
argument_list|(
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xs
operator|->
name|status
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/* should use S/G only if not zero length */
name|scb
operator|->
name|SG_list_pointer
operator|=
name|KVTOPHYS
argument_list|(
name|scb
operator|->
name|ahc_dma
argument_list|)
expr_stmt|;
name|sg
operator|=
name|scb
operator|->
name|ahc_dma
expr_stmt|;
name|seg
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Set up the scatter gather block 		 */
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"%ld @%p:- "
operator|,
name|xs
operator|->
name|datalen
operator|,
name|xs
operator|->
name|data
operator|)
argument_list|)
expr_stmt|;
name|datalen
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|thiskv
operator|=
operator|(
name|int
operator|)
name|xs
operator|->
name|data
expr_stmt|;
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|seg
operator|<
name|AHC_NSEG
operator|)
condition|)
block|{
name|bytes_this_seg
operator|=
literal|0
expr_stmt|;
comment|/* put in the base address */
name|sg
operator|->
name|addr
operator|=
name|thisphys
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"0x%lx"
operator|,
name|thisphys
operator|)
argument_list|)
expr_stmt|;
comment|/* do it at least once */
name|nextphys
operator|=
name|thisphys
expr_stmt|;
while|while
condition|(
operator|(
name|datalen
operator|)
operator|&&
operator|(
name|thisphys
operator|==
name|nextphys
operator|)
condition|)
block|{
comment|/* 				 * This page is contiguous (physically) 				 * with the the last, just extend the 				 * length 				 */
comment|/* how far to the end of the page */
name|nextphys
operator|=
operator|(
name|thisphys
operator|&
operator|(
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
name|bytes_this_page
operator|=
name|nextphys
operator|-
name|thisphys
expr_stmt|;
comment|/**** or the data ****/
name|bytes_this_page
operator|=
name|min
argument_list|(
name|bytes_this_page
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|bytes_this_seg
operator|+=
name|bytes_this_page
expr_stmt|;
name|datalen
operator|-=
name|bytes_this_page
expr_stmt|;
comment|/* get more ready for the next page */
name|thiskv
operator|=
operator|(
name|thiskv
operator|&
operator|(
operator|~
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|)
operator|+
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
name|thisphys
operator|=
name|KVTOPHYS
argument_list|(
name|thiskv
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * next page isn't contiguous, finish the seg 			 */
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"(0x%x)"
operator|,
name|bytes_this_seg
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|len
operator|=
name|bytes_this_seg
expr_stmt|;
name|sg
operator|++
expr_stmt|;
name|seg
operator|++
expr_stmt|;
block|}
name|scb
operator|->
name|SG_segment_count
operator|=
name|seg
expr_stmt|;
comment|/* Copy the first SG into the data pointer area */
name|scb
operator|->
name|data
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|addr
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
name|scb
operator|->
name|ahc_dma
operator|->
name|len
expr_stmt|;
name|SC_DEBUGN
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB4
argument_list|,
operator|(
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datalen
condition|)
block|{
comment|/* there's still data, must have run out of segs! */
name|printf
argument_list|(
literal|"%s: ahc_scsi_cmd: more than %d DMA segs\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|AHC_NSEG
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|ahc_free_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|COMPLETE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|AHC_BROKEN_CACHE
if|if
condition|(
name|ahc_broken_cache
condition|)
name|INVALIDATE_CACHE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * No data xfer, use non S/G values 	 	 */
name|scb
operator|->
name|SG_segment_count
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|AHC_DEBUG
end_ifdef

begin_if
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBS
operator|)
operator|&&
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|target
operator|==
name|DEBUGTARG
operator|)
condition|)
name|ahc_print_scb
argument_list|(
name|scb
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|scb
operator|->
name|position
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
comment|/* We already have a valid slot */
name|u_char
name|curscb
decl_stmt|;
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|curscb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscb
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_ACTIVE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_sent\n"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scb
operator|->
name|flags
operator|=
name|SCB_WAITINGQ
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|ahc_run_waiting_queues
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|SUCCESSFULLY_QUEUED
operator|)
return|;
block|}
end_if

begin_comment
comment|/* 	 * If we can't use interrupts, poll for completion 	 */
end_comment

begin_expr_stmt
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"cmd_poll\n"
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_do
do|do
block|{
if|if
condition|(
name|ahc_poll
argument_list|(
name|ahc
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cmd fail\n"
argument_list|)
expr_stmt|;
name|ahc_timeout
argument_list|(
name|scb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
do|;
end_do

begin_comment
comment|/* a non command complete intr */
end_comment

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|COMPLETE
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * A scb (and hence an scb entry on the board is put onto the  * free list.  */
end_comment

begin_function
unit|static
name|void
name|ahc_free_scb
parameter_list|(
name|ahc
parameter_list|,
name|scb
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|wscb
decl_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|scb
operator|->
name|flags
operator|=
name|SCB_FREE
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|position
operator|==
name|SCB_LIST_NULL
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|page_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|->
name|links
operator|.
name|stqe_next
operator|&&
operator|!
name|ahc
operator|->
name|free_scbs
operator|.
name|stqh_first
condition|)
comment|/* 			 * If there were no SCBs availible, wake anybody waiting 			 * for one to come free. 			 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are any SCBS on the waiting queue, 	 * assign the slot of this "freed" SCB to the first 	 * one.  We'll run the waiting queues after all command 	 * completes for a particular interrupt are completed 	 * or when we start another command. 	 */
elseif|else
if|if
condition|(
operator|(
name|wscb
operator|=
name|ahc
operator|->
name|waiting_scbs
operator|.
name|stqh_first
operator|)
operator|!=
name|NULL
condition|)
block|{
name|wscb
operator|->
name|position
operator|=
name|scb
operator|->
name|position
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|waiting_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|assigned_scbs
argument_list|,
name|wscb
argument_list|,
name|links
argument_list|)
expr_stmt|;
name|wscb
operator|->
name|flags
operator|=
name|SCB_ASSIGNEDQ
expr_stmt|;
comment|/*  		 * The "freed" SCB will need to be assigned a slot 		 * before being used, so put it in the page_scbs 		 * queue. 		 */
name|scb
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|page_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scb
operator|->
name|links
operator|.
name|stqe_next
operator|&&
operator|!
name|ahc
operator|->
name|free_scbs
operator|.
name|stqh_first
condition|)
comment|/* 			 * If there were no SCBs availible, wake anybody waiting 			 * for one to come free. 			 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|,
name|scb
argument_list|,
name|links
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
name|ahc
operator|->
name|activescbs
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|scb
operator|->
name|links
operator|.
name|stqe_next
operator|&&
operator|!
name|ahc
operator|->
name|page_scbs
operator|.
name|stqh_first
condition|)
comment|/* 			 * If there were no SCBs availible, wake anybody waiting 			 * for one to come free. 			 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a free scb, either one already assigned to a hardware slot  * on the adapter or one that will require an SCB to be paged out before  * use. If there are none, see if we can allocate a new SCB.  Otherwise  * either return an error or sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|scb
modifier|*
name|ahc_get_scb
parameter_list|(
name|ahc
parameter_list|,
name|flags
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|unsigned
name|opri
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * If we can and have to, sleep waiting for one to come free 	 * but only if we can't allocate a new one. 	 */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|free_scbs
operator|.
name|stqh_first
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|scbp
operator|=
name|ahc
operator|->
name|page_scbs
operator|.
name|stqh_first
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ahc
operator|->
name|page_scbs
argument_list|,
name|links
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|maxscbs
condition|)
block|{
name|scbp
operator|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbp
condition|)
block|{
name|bzero
argument_list|(
name|scbp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scb
argument_list|)
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|tag
operator|=
name|ahc
operator|->
name|numscbs
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|numscbs
operator|<
name|ahc
operator|->
name|maxhscbs
condition|)
name|scbp
operator|->
name|position
operator|=
name|ahc
operator|->
name|numscbs
expr_stmt|;
else|else
name|scbp
operator|->
name|position
operator|=
name|SCB_LIST_NULL
expr_stmt|;
name|ahc
operator|->
name|numscbs
operator|++
expr_stmt|;
comment|/* 				 * Place in the scbarray 				 * Never is removed. 				 */
name|ahc
operator|->
name|scbarray
index|[
name|scbp
operator|->
name|tag
index|]
operator|=
name|scbp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Can't malloc SCB\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ahc
operator|->
name|free_scbs
argument_list|,
name|PRIBIO
argument_list|,
literal|"ahcscb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|scbp
condition|)
block|{
name|scbp
operator|->
name|control
operator|=
literal|0
expr_stmt|;
name|scbp
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|AHC_DEBUG
name|ahc
operator|->
name|activescbs
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ahc_debug
operator|&
name|AHC_SHOWSCBCNT
operator|)
operator|&&
operator|(
name|ahc
operator|->
name|activescbs
operator|==
name|ahc
operator|->
name|maxhscbs
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: Max SCBs active\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
operator|(
name|scbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_loadseq
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
specifier|static
name|unsigned
name|char
name|seqprog
index|[]
init|=
block|{
include|#
directive|include
file|"aic7xxx_seq.h"
block|}
decl_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|PERRORDIS
operator||
name|SEQRESET
operator||
name|LOADRAM
argument_list|)
expr_stmt|;
name|AHC_OUTSB
argument_list|(
name|ahc
argument_list|,
name|SEQRAM
argument_list|,
name|seqprog
argument_list|,
sizeof|sizeof
argument_list|(
name|seqprog
argument_list|)
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|FASTMODE
operator||
name|SEQRESET
argument_list|)
expr_stmt|;
do|do
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SEQCTL
argument_list|,
name|SEQRESET
operator||
name|FASTMODE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SEQADDR0
argument_list|)
operator|!=
literal|0
operator|&&
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SEQADDR1
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Function to poll for command completion when  * interrupts are disabled (crash dumps)  */
end_comment

begin_function
specifier|static
name|int
name|ahc_poll
parameter_list|(
name|ahc
parameter_list|,
name|wait
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|wait
decl_stmt|;
comment|/* in msec */
block|{
while|while
condition|(
operator|--
name|wait
condition|)
block|{
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|INTSTAT
argument_list|)
operator|&
name|INT_PEND
condition|)
break|break;
block|}
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: board is not responding\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ahc_intr
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ahc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_timeout
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scb
init|=
operator|(
expr|struct
name|scb
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|found
decl_stmt|;
name|u_char
name|bus_state
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
condition|)
block|{
comment|/* Previous timeout took care of me already */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|ahc
operator|=
operator|(
expr|struct
name|ahc_data
operator|*
operator|)
name|scb
operator|->
name|xs
operator|->
name|sc_link
operator|->
name|adapter_softc
expr_stmt|;
if|if
condition|(
name|ahc
operator|->
name|in_timeout
condition|)
block|{
comment|/* 		 * Some other SCB has started a recovery operation 		 * and is still working on cleaning things up. 		 */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_TIMEDOUT
condition|)
block|{
comment|/* 			 * This SCB has been here before and is not the 			 * recovery SCB. Cut our losses and panic.  Its 			 * better to do this than trash a filesystem. 			 */
name|panic
argument_list|(
literal|"%s: Timed-out command times out "
literal|"again\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
operator|)
condition|)
block|{
comment|/* 			 * This is not the SCB that started this timeout 			 * processing.  Give this scb another lifetime so 			 * that it can continue once we deal with the 			 * timeout. 			 */
name|scb
operator|->
name|flags
operator||=
name|SCB_TIMEDOUT
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ahc
operator|->
name|in_timeout
operator|=
name|TRUE
expr_stmt|;
comment|/*       	 * Ensure that the card doesn't do anything 	 * behind our back. 	 */
name|PAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timed out "
argument_list|)
expr_stmt|;
comment|/* 	 * Take a snapshot of the bus state and print out 	 * some information so we can track down driver bugs. 	 */
name|bus_state
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|LASTPHASE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bus_state
operator|&
name|PHASE_MASK
condition|)
block|{
case|case
name|P_DATAOUT
case|:
name|printf
argument_list|(
literal|"in dataout phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_DATAIN
case|:
name|printf
argument_list|(
literal|"in datain phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_COMMAND
case|:
name|printf
argument_list|(
literal|"in command phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGOUT
case|:
name|printf
argument_list|(
literal|"in message out phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_STATUS
case|:
name|printf
argument_list|(
literal|"in status phase"
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_MESGIN
case|:
name|printf
argument_list|(
literal|"in message in phase"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"while idle, LASTPHASE == 0x%x"
argument_list|,
name|bus_state
argument_list|)
expr_stmt|;
comment|/*  			 * We aren't in a valid phase, so assume we're 			 * idle. 			 */
name|bus_state
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|", SCSISIGI == 0x%x\n"
argument_list|,
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCSISIGI
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decide our course of action */
if|if
condition|(
name|scb
operator|->
name|flags
operator|&
name|SCB_ABORTED
condition|)
block|{
comment|/* 		 * Been down this road before. 		 * Do a full bus reset. 		 */
name|char
name|channel
init|=
operator|(
name|scb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|scb
operator|->
name|tag
argument_list|,
name|XS_TIMEOUT
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset #1. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|in_timeout
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scb
operator|->
name|control
operator|&
name|TAG_ENB
condition|)
block|{
comment|/* 		 * We could be starving this command 		 * try sending an ordered tag command 		 * to the target we come from. 		 */
name|scb
operator|->
name|flags
operator||=
name|SCB_ABORTED
operator||
name|SCB_SENTORDEREDTAG
expr_stmt|;
name|ahc
operator|->
name|orderedtag
operator||=
literal|0xFF
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
literal|5
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Ordered Tag queued\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
comment|/* 		 * Send a Bus Device Reset Message: 		 * The target that is holding up the bus may not 		 * be the same as the one that triggered this timeout 		 * (different commands have different timeout lengths). 		 * It is also impossible to get a message to a target 		 * if we are in a "frozen" data transfer phase.  Our 		 * strategy here is to queue a bus device reset message 		 * to the timed out target if it is disconnected. 		 * Otherwise, if we have an active target we stuff the 		 * message buffer with a bus device reset message and 		 * assert ATN in the hopes that the target will let go 		 * of the bus and finally disconnect.  If this fails, 		 * we'll get another timeout 2 seconds later which will 		 * cause a bus reset. 		 * 		 * XXX If the SCB is paged out, we simply reset the 		 *     bus.  We should probably queue a new command 		 *     instead. 		 */
comment|/* Test to see if scb is disconnected */
if|if
condition|(
operator|!
operator|(
name|scb
operator|->
name|flags
operator|&
name|SCB_PAGED_OUT
operator|)
condition|)
block|{
name|u_char
name|active_scb
decl_stmt|;
name|struct
name|scb
modifier|*
name|active_scbp
decl_stmt|;
name|active_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|active_scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
index|]
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
if|if
condition|(
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|)
operator|&
name|DISCONNECTED
condition|)
block|{
if|if
condition|(
name|ahc
operator|->
name|flags
operator|&
name|AHC_PAGESCBS
condition|)
block|{
comment|/* 					 * Pull this SCB out of the  					 * disconnected list. 					 */
name|u_char
name|prev
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|)
decl_stmt|;
name|u_char
name|next
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
block|{
comment|/* At the head */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|DISCONNECTED_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_PREV
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scb
operator|->
name|position
argument_list|)
expr_stmt|;
block|}
block|}
name|scb
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORTED
expr_stmt|;
name|scb
operator|->
name|control
operator|&=
name|DISCENB
expr_stmt|;
name|scb
operator|->
name|cmdlen
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_segment_count
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|SG_list_pointer
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|datalen
operator|=
literal|0
expr_stmt|;
name|ahc_send_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|ahc_add_waiting_scb
argument_list|(
name|ahc
argument_list|,
name|scb
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
literal|2
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|scb
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"BUS DEVICE RESET message queued.\n"
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Is the active SCB really active? */
elseif|else
if|if
condition|(
operator|(
name|active_scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|&&
name|bus_state
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|MSG0
argument_list|,
name|MSG_BUS_DEVICE_RESET
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISIGO
argument_list|,
name|bus_state
operator||
name|ATNO
argument_list|)
expr_stmt|;
name|sc_print_addr
argument_list|(
name|active_scbp
operator|->
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"asserted ATN - device reset in "
literal|"message buffer\n"
argument_list|)
expr_stmt|;
name|active_scbp
operator|->
name|flags
operator||=
name|SCB_DEVICE_RESET
operator||
name|SCB_ABORTED
expr_stmt|;
if|if
condition|(
name|active_scbp
operator|!=
name|scb
condition|)
block|{
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scbp
argument_list|)
expr_stmt|;
comment|/* Give scb a new lease on life */
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|,
operator|(
name|scb
operator|->
name|xs
operator|->
name|timeout
operator|*
name|hz
operator|)
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|active_scbp
argument_list|,
operator|(
literal|2
operator|*
name|hz
operator|)
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 		 * No active target or a paged out SCB. 		 * Try reseting the bus. 		 */
name|channel
operator|=
operator|(
name|scb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
name|found
operator|=
name|ahc_reset_channel
argument_list|(
name|ahc
argument_list|,
name|channel
argument_list|,
name|scb
operator|->
name|tag
argument_list|,
name|XS_TIMEOUT
argument_list|,
comment|/*Initiate Reset*/
name|TRUE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Issued Channel %c Bus Reset #2. "
literal|"%d SCBs aborted\n"
argument_list|,
name|ahc_name
argument_list|(
name|ahc
argument_list|)
argument_list|,
name|channel
argument_list|,
name|found
argument_list|)
expr_stmt|;
name|ahc
operator|->
name|in_timeout
operator|=
name|FALSE
expr_stmt|;
block|}
name|done
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The device at the given target/channel has been reset.  Abort   * all active and queued scbs for that target/channel.   */
end_comment

begin_function
specifier|static
name|int
name|ahc_reset_device
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
block|{
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_char
name|active_scb
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* restore this when we're done */
name|active_scb
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
comment|/* 	 * Search the QINFIFO. 	 */
block|{
name|u_char
name|saved_queue
index|[
name|AHC_SCB_MAX
index|]
decl_stmt|;
name|u_char
name|queued
init|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINCNT
argument_list|)
operator|&
name|ahc
operator|->
name|qcntmask
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|queued
operator|-
name|found
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|saved_queue
index|[
name|i
index|]
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|saved_queue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
comment|/* 				 * We found an scb that needs to be aborted. 				 */
name|scbp
operator|->
name|flags
operator|=
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|position
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now put the saved scbs back. */
for|for
control|(
name|queued
operator|=
literal|0
init|;
name|queued
operator|<
name|i
condition|;
name|queued
operator|++
control|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|QINFIFO
argument_list|,
name|saved_queue
index|[
name|queued
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Search waiting for selection list. 	 */
block|{
name|u_char
name|next
decl_stmt|,
name|prev
decl_stmt|;
name|next
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|)
expr_stmt|;
comment|/* Start at head of list. */
name|prev
operator|=
name|SCB_LIST_NULL
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|SCB_LIST_NULL
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_TAG
argument_list|)
index|]
expr_stmt|;
comment|/* 			 * Select the SCB. 			 */
if|if
condition|(
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
name|next
operator|=
name|ahc_abort_wscb
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|,
name|prev
argument_list|,
name|timedout_scb
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Go through the entire SCB array now and look for  	 * commands for this target that are active.  These 	 * are other (most likely tagged) commands that  	 * were disconnected when the reset occured. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_ACTIVE
operator|)
operator|&&
name|ahc_match_scb
argument_list|(
name|scbp
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
condition|)
block|{
comment|/* Ensure the target is "free" */
name|ahc_unbusy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_PAGED_OUT
operator|)
condition|)
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|scbp
operator|->
name|flags
operator|=
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|tag
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|active_scb
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/*  * Manipulate the waiting for selection list and return the  * scb that follows the one that we remove.  */
end_comment

begin_function
specifier|static
name|u_char
name|ahc_abort_wscb
parameter_list|(
name|ahc
parameter_list|,
name|scbp
parameter_list|,
name|prev
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
name|u_char
name|prev
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
block|{
name|u_char
name|curscbp
decl_stmt|,
name|next
decl_stmt|;
name|int
name|target
init|=
operator|(
operator|(
name|scbp
operator|->
name|tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
operator|)
decl_stmt|;
name|char
name|channel
init|=
operator|(
name|scbp
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
comment|/* 	 * Select the SCB we want to abort and 	 * pull the next pointer out of it. 	 */
name|curscbp
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|scbp
operator|->
name|position
argument_list|)
expr_stmt|;
name|next
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|)
expr_stmt|;
comment|/* Clear the necessary fields */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_CONTROL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|SCB_LIST_NULL
argument_list|)
expr_stmt|;
name|ahc_unbusy_target
argument_list|(
name|ahc
argument_list|,
name|target
argument_list|,
name|channel
argument_list|)
expr_stmt|;
comment|/* update the waiting list */
if|if
condition|(
name|prev
operator|==
name|SCB_LIST_NULL
condition|)
comment|/* First in the list */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|WAITING_SCBH
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Select the scb that pointed to us  		 * and update its next pointer. 		 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCB_NEXT
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Point us back at the original scb position 	 * and inform the SCSI system that the command 	 * has been aborted. 	 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCBPTR
argument_list|,
name|curscbp
argument_list|)
expr_stmt|;
name|scbp
operator|->
name|flags
operator|=
name|SCB_ABORTED
operator||
name|SCB_QUEUED_FOR_DONE
expr_stmt|;
name|scbp
operator|->
name|xs
operator|->
name|error
operator||=
name|xs_error
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|tag
operator|!=
name|timedout_scb
condition|)
name|untimeout
argument_list|(
name|ahc_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|scbp
argument_list|)
expr_stmt|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_busy_target
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_char
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|{
name|u_char
name|active
decl_stmt|;
name|u_long
name|active_port
init|=
name|ACTIVE_A
decl_stmt|;
if|if
condition|(
name|target
operator|>
literal|0x07
operator|||
name|channel
operator|==
literal|'B'
condition|)
block|{
comment|/*  		 * targets on the Second channel or 		 * above id 7 store info in byte two  		 * of HA_ACTIVE 		 */
name|active_port
operator|++
expr_stmt|;
block|}
name|active
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|active_port
argument_list|)
expr_stmt|;
name|active
operator||=
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_unbusy_target
parameter_list|(
name|ahc
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|u_char
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|{
name|u_char
name|active
decl_stmt|;
name|u_long
name|active_port
init|=
name|ACTIVE_A
decl_stmt|;
if|if
condition|(
name|target
operator|>
literal|0x07
operator|||
name|channel
operator|==
literal|'B'
condition|)
block|{
comment|/*  		 * targets on the Second channel or 		 * above id 7 store info in byte two  		 * of HA_ACTIVE 		 */
name|active_port
operator|++
expr_stmt|;
block|}
name|active
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|active_port
argument_list|)
expr_stmt|;
name|active
operator|&=
operator|~
operator|(
literal|0x01
operator|<<
operator|(
name|target
operator|&
literal|0x07
operator|)
operator|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|active_port
argument_list|,
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ahc_reset_current_bus
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
name|SCSIRSTO
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SCSISEQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_reset_channel
parameter_list|(
name|ahc
parameter_list|,
name|channel
parameter_list|,
name|timedout_scb
parameter_list|,
name|xs_error
parameter_list|,
name|initiate_reset
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
name|char
name|channel
decl_stmt|;
name|u_char
name|timedout_scb
decl_stmt|;
name|u_int32_t
name|xs_error
decl_stmt|;
name|u_char
name|initiate_reset
decl_stmt|;
block|{
name|u_char
name|sblkctl
decl_stmt|;
name|char
name|cur_channel
decl_stmt|;
name|u_long
name|offset
decl_stmt|,
name|offset_max
decl_stmt|;
name|int
name|found
decl_stmt|;
comment|/* 	 * Clean up all the state information for the 	 * pending transactions on this bus. 	 */
name|found
operator|=
name|ahc_reset_device
argument_list|(
name|ahc
argument_list|,
name|ALL_TARGETS
argument_list|,
name|channel
argument_list|,
name|timedout_scb
argument_list|,
name|xs_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|channel
operator|==
literal|'B'
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0xff00
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0x00ff
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
operator|+
literal|8
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ahc
operator|->
name|type
operator|&
name|AHC_WIDE
condition|)
block|{
name|ahc
operator|->
name|needsdtr
operator|=
name|ahc
operator|->
name|needsdtr_orig
expr_stmt|;
name|ahc
operator|->
name|needwdtr
operator|=
name|ahc
operator|->
name|needwdtr_orig
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|=
literal|0
expr_stmt|;
name|ahc
operator|->
name|wdtrpending
operator|=
literal|0
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_B
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|16
expr_stmt|;
block|}
else|else
block|{
name|ahc
operator|->
name|needsdtr
operator||=
operator|(
name|ahc
operator|->
name|needsdtr_orig
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|ahc
operator|->
name|sdtrpending
operator|&=
literal|0xff00
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|ACTIVE_A
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|TARG_SCRATCH
expr_stmt|;
name|offset_max
operator|=
name|TARG_SCRATCH
operator|+
literal|8
expr_stmt|;
block|}
for|for
control|(
init|;
name|offset
operator|<
name|offset_max
condition|;
name|offset
operator|++
control|)
block|{
comment|/* 		 * Revert to async/narrow transfers 		 * until we renegotiate. 		 */
name|u_char
name|targ_scratch
decl_stmt|;
name|targ_scratch
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|targ_scratch
operator|&=
name|SXFR
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|offset
argument_list|,
name|targ_scratch
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Reset the bus if we are initiating this reset and 	 * restart/unpause the sequencer 	 */
comment|/* Case 1: Command for another bus is active */
name|sblkctl
operator|=
name|AHC_INB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|)
expr_stmt|;
name|cur_channel
operator|=
operator|(
name|sblkctl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
expr_stmt|;
if|if
condition|(
name|cur_channel
operator|!=
name|channel
condition|)
block|{
comment|/* 		 * Stealthily reset the other bus 		 * without upsetting the current bus 		 */
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
operator|^
name|SELBUSB
argument_list|)
expr_stmt|;
if|if
condition|(
name|initiate_reset
condition|)
block|{
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
operator||
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|SBLKCTL
argument_list|,
name|sblkctl
argument_list|)
expr_stmt|;
name|UNPAUSE_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
comment|/* Case 2: A command from this bus is active or we're idle */
else|else
block|{
if|if
condition|(
name|initiate_reset
condition|)
block|{
name|ahc_reset_current_bus
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRSINT1
argument_list|,
name|CLRSCSIRSTI
operator||
name|CLRSELTIMEO
argument_list|)
expr_stmt|;
name|AHC_OUTB
argument_list|(
name|ahc
argument_list|,
name|CLRINT
argument_list|,
name|CLRSCSIINT
argument_list|)
expr_stmt|;
name|RESTART_SEQUENCER
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
block|}
name|ahc_run_done_queue
argument_list|(
name|ahc
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_function
name|void
name|ahc_run_done_queue
parameter_list|(
name|ahc
parameter_list|)
name|struct
name|ahc_data
modifier|*
name|ahc
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|scb
modifier|*
name|scbp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ahc
operator|->
name|numscbs
condition|;
name|i
operator|++
control|)
block|{
name|scbp
operator|=
name|ahc
operator|->
name|scbarray
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|scbp
operator|->
name|flags
operator|&
name|SCB_QUEUED_FOR_DONE
condition|)
name|ahc_done
argument_list|(
name|ahc
argument_list|,
name|scbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ahc_match_scb
parameter_list|(
name|scb
parameter_list|,
name|target
parameter_list|,
name|channel
parameter_list|)
name|struct
name|scb
modifier|*
name|scb
decl_stmt|;
name|int
name|target
decl_stmt|;
name|char
name|channel
decl_stmt|;
block|{
name|int
name|targ
init|=
operator|(
name|scb
operator|->
name|tcl
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
decl_stmt|;
name|char
name|chan
init|=
operator|(
name|scb
operator|->
name|tcl
operator|&
name|SELBUSB
operator|)
condition|?
literal|'B'
else|:
literal|'A'
decl_stmt|;
if|if
condition|(
name|target
operator|==
name|ALL_TARGETS
condition|)
return|return
operator|(
name|chan
operator|==
name|channel
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|chan
operator|==
name|channel
operator|)
operator|&&
operator|(
name|targ
operator|==
name|target
operator|)
operator|)
return|;
block|}
end_function

end_unit

