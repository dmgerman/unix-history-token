begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, Revision 2.2  92/04/04  11:35:49  rpd  *	$Id: disk.c,v 1.25 1997/02/22 09:30:09 peter Exp $  */
end_comment

begin_comment
comment|/*  * 93/10/08  bde  *	If there is no 386BSD partition, initialize the label sector with  *	LABELSECTOR instead of with garbage.  *  * 93/08/22  bde  *	Fixed reading of bad sector table.  It is at the end of the 'c'  *	partition, which is not always at the end of the disk.  */
end_comment

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_endif
endif|#
directive|endif
endif|DO_BAD144
end_endif

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_define
define|#
directive|define
name|BIOS_DEV_FLOPPY
value|0x0
end_define

begin_define
define|#
directive|define
name|BIOS_DEV_WIN
value|0x80
end_define

begin_define
define|#
directive|define
name|BPS
value|512
end_define

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|((((di)>>8)&0xff)+1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|dkbad
name|dkb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_bad144
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DO_BAD144
end_endif

begin_decl_stmt
specifier|static
name|int
name|bsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spt
decl_stmt|,
name|spc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dosdev
decl_stmt|,
name|unit
decl_stmt|,
name|slice
decl_stmt|,
name|part
decl_stmt|,
name|maj
decl_stmt|,
name|boff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*#define EMBEDDED_DISKLABEL 1*/
end_comment

begin_comment
comment|/* Read ahead buffer large enough for one track on a 1440K floppy.  For  * reading from floppies, the bootstrap has to be loaded on a 64K boundary  * to ensure that this buffer doesn't cross a 64K DMA boundary.  */
end_comment

begin_define
define|#
directive|define
name|RA_SECTORS
value|18
end_define

begin_decl_stmt
specifier|static
name|char
name|ra_buf
index|[
name|RA_SECTORS
operator|*
name|BPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_first
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|badsect
parameter_list|(
name|int
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|int
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|devopen
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|dos_partition
modifier|*
name|dptr
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sector
init|=
literal|0
decl_stmt|,
name|di
decl_stmt|,
name|dosdev_copy
decl_stmt|;
name|dosdev_copy
operator|=
name|dosdev
expr_stmt|;
name|di
operator|=
name|get_diskinfo
argument_list|(
name|dosdev_copy
argument_list|)
expr_stmt|;
name|spt
operator|=
name|SPT
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* Hack for 2.88MB floppy drives. */
if|if
condition|(
operator|!
operator|(
name|dosdev_copy
operator|&
literal|0x80
operator|)
operator|&&
name|spt
operator|==
literal|36
condition|)
name|spt
operator|=
literal|18
expr_stmt|;
name|spc
operator|=
name|spt
operator|*
name|HEADS
argument_list|(
name|di
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|RAWBOOT
block|{
ifdef|#
directive|ifdef
name|EMBEDDED_DISKLABEL
name|dl
operator|=
operator|&
name|disklabel
expr_stmt|;
else|#
directive|else
else|EMBEDDED_DISKLABEL
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dptr
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
operator|(
name|p
operator|+
name|DOSPARTOFF
operator|)
expr_stmt|;
name|slice
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|dptr
operator|++
control|)
if|if
condition|(
name|dptr
operator|->
name|dp_typ
operator|==
name|DOSPTYP_386BSD
condition|)
block|{
name|slice
operator|=
name|BASE_SLICE
operator|+
name|i
expr_stmt|;
name|sector
operator|=
name|dptr
operator|->
name|dp_start
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
name|sector
operator|+
name|LABELSECTOR
argument_list|)
expr_stmt|;
name|dl
operator|=
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
name|p
operator|)
expr_stmt|;
name|disklabel
operator|=
operator|*
name|dl
expr_stmt|;
comment|/* structure copy (maybe useful later)*/
endif|#
directive|endif
endif|EMBEDDED_DISKLABEL
if|if
condition|(
name|dl
operator|->
name|d_magic
operator|!=
name|DISKMAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"bad disklabel\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|maj
operator|==
literal|4
operator|)
operator|||
operator|(
name|maj
operator|==
literal|0
operator|)
operator|||
operator|(
name|maj
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|d_type
operator|==
name|DTYPE_SCSI
condition|)
block|{
name|maj
operator|=
literal|4
expr_stmt|;
comment|/* use scsi as boot dev */
block|}
else|else
block|{
name|maj
operator|=
literal|0
expr_stmt|;
comment|/* must be ESDI/IDE */
block|}
block|}
comment|/* This little trick is for OnTrack DiskManager disks */
name|boff
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
operator|-
name|dl
operator|->
name|d_partitions
index|[
literal|2
index|]
operator|.
name|p_offset
operator|+
name|sector
expr_stmt|;
name|bsize
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"empty partition\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|DO_BAD144
name|do_bad144
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|d_flags
operator|&
name|D_BADSECT
condition|)
block|{
comment|/* this disk uses bad144 */
name|int
name|i
decl_stmt|;
name|int
name|dkbbnum
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|dkbptr
decl_stmt|;
comment|/* find the first readable bad sector table */
comment|/* some of this code is copied from ufs/ufs_disksubr.c */
comment|/* including the bugs :-( */
comment|/* read a bad sector table */
define|#
directive|define
name|BAD144_PART
value|2
comment|/* XXX scattered magic numbers */
define|#
directive|define
name|BSD_PART
value|0
comment|/* XXX should be 2 but bad144.c uses 0 */
if|if
condition|(
name|dl
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|dkbbnum
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|dl
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|dkbbnum
operator|=
name|dl
operator|->
name|d_secperunit
expr_stmt|;
name|dkbbnum
operator|-=
name|dl
operator|->
name|d_nsectors
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|d_secsize
operator|>
name|DEV_BSIZE
condition|)
name|dkbbnum
operator|*=
name|dl
operator|->
name|d_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
else|else
name|dkbbnum
operator|/=
name|DEV_BSIZE
operator|/
name|dl
operator|->
name|d_secsize
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|do_bad144
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* XXX: what if the "DOS sector"< 512 bytes ??? */
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
name|dkbbnum
operator|+
name|i
argument_list|)
expr_stmt|;
name|dkbptr
operator|=
operator|(
expr|struct
name|dkbad
operator|*
operator|)
name|p
expr_stmt|;
comment|/* XXX why is this not in<sys/dkbad.h> ??? */
define|#
directive|define
name|DKBAD_MAGIC
value|0x4321
if|if
condition|(
name|dkbptr
operator|->
name|bt_mbz
operator|==
literal|0
operator|&&
name|dkbptr
operator|->
name|bt_flag
operator|==
name|DKBAD_MAGIC
condition|)
block|{
name|dkb
operator|=
operator|*
name|dkbptr
expr_stmt|;
comment|/* structure copy */
name|do_bad144
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|10
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|<
name|dl
operator|->
name|d_nsectors
condition|)
do|;
if|if
condition|(
operator|!
name|do_bad144
condition|)
name|printf
argument_list|(
literal|"Bad bad sector table\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Using bad sector table at %d\n"
argument_list|,
name|dkbbnum
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DO_BAD144 */
block|}
endif|#
directive|endif
comment|/* RAWBOOT */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Be aware that cnt is rounded up to N*BPS  */
end_comment

begin_function
name|void
name|devread
parameter_list|(
name|char
modifier|*
name|iodest
parameter_list|,
name|int
name|sector
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|dosdev_copy
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|cnt
condition|;
name|offset
operator|+=
name|BPS
control|)
block|{
name|dosdev_copy
operator|=
name|dosdev
expr_stmt|;
name|p
operator|=
name|Bread
argument_list|(
name|dosdev_copy
argument_list|,
name|badsect
argument_list|(
name|sector
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|iodest
operator|+
name|offset
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|int
name|sector
parameter_list|)
block|{
if|if
condition|(
name|dosdev
operator|!=
name|ra_dev
operator|||
name|sector
operator|<
name|ra_first
operator|||
name|sector
operator|>=
name|ra_end
condition|)
block|{
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|cyl
operator|=
name|sector
operator|/
name|spc
expr_stmt|;
if|if
condition|(
name|cyl
operator|>
literal|1023
condition|)
block|{
name|printf
argument_list|(
literal|"Error: C:%d> 1023 (BIOS limit)\n"
argument_list|,
name|cyl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
comment|/* loop forever */
block|}
name|head
operator|=
operator|(
name|sector
operator|%
name|spc
operator|)
operator|/
name|spt
expr_stmt|;
name|sec
operator|=
name|sector
operator|%
name|spt
expr_stmt|;
name|nsec
operator|=
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|RA_SECTORS
condition|)
name|nsec
operator|=
name|RA_SECTORS
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
if|if
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nsec
operator|=
literal|1
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
while|while
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: D:0x%x C:%d H:%d S:%d\n"
argument_list|,
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
block|}
block|}
name|ra_dev
operator|=
name|dosdev
expr_stmt|;
name|ra_first
operator|=
name|sector
expr_stmt|;
name|ra_end
operator|=
name|sector
operator|+
name|nsec
expr_stmt|;
block|}
return|return
operator|(
name|ra_buf
operator|+
operator|(
name|sector
operator|-
name|ra_first
operator|)
operator|*
name|BPS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|badsect
parameter_list|(
name|int
name|sector
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DO_BAD144
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|RAWBOOT
argument_list|)
name|int
name|i
decl_stmt|;
if|if
condition|(
name|do_bad144
condition|)
block|{
name|u_short
name|cyl
decl_stmt|;
name|u_short
name|head
decl_stmt|;
name|u_short
name|sec
decl_stmt|;
name|int
name|newsec
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
init|=
operator|&
name|disklabel
decl_stmt|;
comment|/* XXX */
comment|/* from wd.c */
comment|/* bt_cyl = cylinder number in sorted order */
comment|/* bt_trksec is actually (head<< 8) + sec */
comment|/* only remap sectors in the partition */
if|if
condition|(
name|sector
operator|<
name|boff
operator|||
name|sector
operator|>=
name|boff
operator|+
name|bsize
condition|)
block|{
goto|goto
name|no_remap
goto|;
block|}
name|cyl
operator|=
operator|(
name|sector
operator|-
name|boff
operator|)
operator|/
name|dl
operator|->
name|d_secpercyl
expr_stmt|;
name|head
operator|=
operator|(
operator|(
name|sector
operator|-
name|boff
operator|)
operator|%
name|dl
operator|->
name|d_secpercyl
operator|)
operator|/
name|dl
operator|->
name|d_nsectors
expr_stmt|;
name|sec
operator|=
operator|(
name|sector
operator|-
name|boff
operator|)
operator|%
name|dl
operator|->
name|d_nsectors
expr_stmt|;
name|sec
operator|=
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sec
expr_stmt|;
comment|/* now, look in the table for a possible bad sector */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|126
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|==
name|cyl
condition|)
block|{
comment|/* found same cylinder */
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|==
name|sec
condition|)
block|{
comment|/* FOUND! */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|>
name|cyl
condition|)
block|{
name|i
operator|=
literal|126
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|126
condition|)
block|{
comment|/* didn't find bad sector */
goto|goto
name|no_remap
goto|;
block|}
comment|/* otherwise find replacement sector */
if|if
condition|(
name|dl
operator|->
name|d_partitions
index|[
name|BSD_PART
index|]
operator|.
name|p_offset
operator|!=
literal|0
condition|)
name|newsec
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_offset
operator|+
name|dl
operator|->
name|d_partitions
index|[
name|BAD144_PART
index|]
operator|.
name|p_size
expr_stmt|;
else|else
name|newsec
operator|=
name|dl
operator|->
name|d_secperunit
expr_stmt|;
name|newsec
operator|-=
name|dl
operator|->
name|d_nsectors
operator|+
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|newsec
return|;
block|}
name|no_remap
label|:
endif|#
directive|endif
return|return
name|sector
return|;
block|}
end_function

end_unit

