begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, [92/04/03  16:51:14  rvb]  *	$Id: boot.c,v 1.33 1995/03/14 08:21:53 davidg Exp $  */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989, 1990, 1991, 1992     by Intel Corporation, Santa Clara, California.                  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_define
define|#
directive|define
name|ouraddr
value|(BOOTSEG<< 4)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|struct
name|exec
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|init_serial
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|probe_keyboard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|loadflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|end
decl_stmt|;
end_decl_stmt

begin_macro
name|boot
argument_list|(
argument|drive
argument_list|)
end_macro

begin_decl_stmt
name|int
name|drive
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|probe_keyboard
argument_list|()
condition|)
block|{
name|init_serial
argument_list|()
expr_stmt|;
name|loadflags
operator||=
name|RB_SERIAL
expr_stmt|;
name|printf
argument_list|(
literal|"\nNo keyboard found.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Pick up the story from the Bios on geometry of disks */
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
name|N_BIOS_GEOM
condition|;
name|ret
operator|++
control|)
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|ret
index|]
operator|=
name|get_diskinfo
argument_list|(
name|ret
operator|+
literal|0x80
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_basemem
operator|=
name|memsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_extmem
operator|=
name|memsize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_memsizes_valid
operator|=
literal|1
expr_stmt|;
comment|/* This is ugly, but why use 4 printf()s when 1 will do? */
name|printf
argument_list|(
literal|"\n\>> FreeBSD BOOT @ 0x%x: %d/%d k of memory\n\ Use hd(1,a)/kernel to boot sd0 when wd0 is also installed.\n\ Usage: [[%s(%d,a)]%s][-abcdhrsv]\n\ Use ? for file list or press Enter for defaults\n\n"
argument_list|,
name|ouraddr
argument_list|,
name|bootinfo
operator|.
name|bi_basemem
argument_list|,
name|bootinfo
operator|.
name|bi_extmem
argument_list|,
name|devs
index|[
name|drive
operator|&
literal|0x80
condition|?
literal|0
else|:
literal|2
index|]
argument_list|,
name|drive
operator|&
literal|0x7f
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gateA20
argument_list|()
expr_stmt|;
name|loadstart
label|:
comment|/***************************************************************\ 	* As a default set it to the first partition of the boot	* 	* floppy or hard drive						* 	\***************************************************************/
name|part
operator|=
literal|0
expr_stmt|;
name|unit
operator|=
name|drive
operator|&
literal|0x7f
expr_stmt|;
name|maj
operator|=
operator|(
name|drive
operator|&
literal|0x80
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
comment|/* a good first bet */
name|printf
argument_list|(
literal|"Boot: "
argument_list|)
expr_stmt|;
comment|/* 	 * Be paranoid and make doubly sure that the input 	 * buffer is empty. 	 */
if|if
condition|(
name|loadflags
operator|&
name|RB_SERIAL
condition|)
name|init_serial
argument_list|()
expr_stmt|;
name|getbootdev
argument_list|(
operator|&
name|loadflags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|openrd
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Can't find %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
comment|/*	if (inode.i_mode&IEXEC) 		loadflags |= RB_KDB; */
name|loadprog
argument_list|(
name|loadflags
argument_list|)
expr_stmt|;
goto|goto
name|loadstart
goto|;
block|}
end_block

begin_macro
name|loadprog
argument_list|(
argument|howto
argument_list|)
end_macro

begin_decl_stmt
name|int
name|howto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|long
name|int
name|startaddr
decl_stmt|;
name|long
name|int
name|addr
decl_stmt|;
comment|/* physical address.. not directly useable */
name|long
name|int
name|bootdev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|pad
decl_stmt|;
ifdef|#
directive|ifdef
name|REDUNDANT
name|unsigned
name|char
name|tmpbuf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* we need to load the first 4k here */
endif|#
directive|endif
name|read
argument_list|(
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|poff
operator|=
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/*if(poff==0) 		poff = 32;*/
comment|/* 	 * We assume that the entry address is the same as the lowest text 	 * address and that the kernel startup code handles relocation by 	 * this address rounded down to a multiple of 16M. 	 */
name|startaddr
operator|=
name|head
operator|.
name|a_entry
operator|&
literal|0x00FFFFFF
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|printf
argument_list|(
literal|"Booting %s(%d,%c)%s @ 0x%x\n"
argument_list|,
name|devs
index|[
name|maj
index|]
argument_list|,
name|unit
argument_list|,
literal|'a'
operator|+
name|part
argument_list|,
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/*  * With the current scheme of things, addr can never be less than ouraddr,  * so this next bit of code is largely irrelevant. Taking it out saves lots  * of space.  */
ifdef|#
directive|ifdef
name|REDUNDANT
if|if
condition|(
name|addr
operator|<
name|ouraddr
condition|)
block|{
if|if
condition|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|)
operator|>
name|ouraddr
condition|)
block|{
name|printf
argument_list|(
literal|"kernel overlaps loader\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_bss
operator|)
operator|>
literal|0xa0000
condition|)
block|{
name|printf
argument_list|(
literal|"bss exceeds 640k limit\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"text=0x%x "
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* LOAD THE TEXT SEGMENT				*/
ifdef|#
directive|ifdef
name|REDUNDANT
comment|/* don't clobber the first 4k yet (BIOS NEEDS IT) 	*/
comment|/********************************************************/
name|read
argument_list|(
name|tmpbuf
argument_list|,
literal|4096
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|4096
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_text
operator|-
literal|4096
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
operator|-
literal|4096
expr_stmt|;
else|#
directive|else
comment|/* Assume we're loading high, so that the BIOS isn't in the way. */
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
expr_stmt|;
endif|#
directive|endif
comment|/********************************************************/
comment|/* Load the Initialised data after the text		*/
comment|/********************************************************/
while|while
condition|(
name|addr
operator|&
name|CLOFSET
condition|)
operator|*
operator|(
name|char
operator|*
operator|)
name|addr
operator|++
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"data=0x%x "
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/********************************************************/
comment|/* Skip over the uninitialised data			*/
comment|/* (but clear it)					*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"bss=0x%x "
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
comment|/*  * This doesn't do us any good anymore either.  * XXX however, we should be checking that we don't load over the top of  * ourselves or into nonexistent memory.  A full symbol table is unlikely  * to fit on 4MB machines.  */
ifdef|#
directive|ifdef
name|REDUNDANT
if|if
condition|(
operator|(
name|addr
operator|<
name|ouraddr
operator|)
operator|&&
operator|(
operator|(
name|addr
operator|+
name|head
operator|.
name|a_bss
operator|)
operator|>
name|ouraddr
operator|)
condition|)
block|{
name|pbzero
argument_list|(
name|addr
argument_list|,
name|ouraddr
operator|-
operator|(
name|int
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pbzero
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pbzero
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|addr
operator|+=
name|head
operator|.
name|a_bss
expr_stmt|;
comment|/* Pad to a page boundary. */
name|pad
operator|=
operator|(
name|unsigned
operator|)
name|addr
operator|%
name|NBPG
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|NBPG
operator|-
name|pad
expr_stmt|;
name|addr
operator|+=
name|pad
expr_stmt|;
block|}
name|bootinfo
operator|.
name|bi_symtab
operator|=
name|addr
expr_stmt|;
comment|/********************************************************/
comment|/* Copy the symbol table size				*/
comment|/********************************************************/
name|pcpy
argument_list|(
operator|&
name|head
operator|.
name|a_syms
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the symbol table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"symbols=[+0x%x+0x%x+0x%x"
argument_list|,
name|pad
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_syms
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table size				*/
comment|/********************************************************/
name|read
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
operator|&
name|i
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"+0x%x+0x%x] "
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
name|bootinfo
operator|.
name|bi_esymtab
operator|=
name|addr
expr_stmt|;
comment|/* 	 * For backwards compatibility, use the previously-unused adaptor 	 * and controller bitfields to hold the slice number. 	 */
name|bootdev
operator|=
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
operator|(
name|slice
operator|>>
literal|4
operator|)
argument_list|,
name|slice
operator|&
literal|0xf
argument_list|,
name|unit
argument_list|,
name|part
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REDUNDANT
comment|/****************************************************************/
comment|/* copy that first page and overwrite any BIOS variables	*/
comment|/****************************************************************/
comment|/* Under no circumstances overwrite precious BIOS variables! */
name|pcpy
argument_list|(
name|tmpbuf
argument_list|,
name|startaddr
argument_list|,
literal|0x400
argument_list|)
expr_stmt|;
name|pcpy
argument_list|(
name|tmpbuf
operator|+
literal|0x500
argument_list|,
name|startaddr
operator|+
literal|0x500
argument_list|,
literal|4096
operator|-
literal|0x500
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bootinfo
operator|.
name|bi_version
operator|=
name|BOOTINFO_VERSION
expr_stmt|;
name|bootinfo
operator|.
name|bi_kernelname
operator|=
name|name
operator|+
name|ouraddr
expr_stmt|;
name|bootinfo
operator|.
name|bi_nfs_diskless
operator|=
name|NULL
expr_stmt|;
name|bootinfo
operator|.
name|bi_size
operator|=
sizeof|sizeof
argument_list|(
name|bootinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total=0x%x entry point=0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
argument_list|,
operator|(
name|int
operator|)
name|startaddr
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
operator|(
name|int
operator|)
name|startaddr
argument_list|,
name|howto
operator||
name|RB_BOOTINFO
argument_list|,
name|bootdev
argument_list|,
operator|(
name|int
operator|)
operator|&
name|bootinfo
operator|+
name|ouraddr
argument_list|)
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|NAMEBUF_LEN
value|100
end_define

begin_decl_stmt
name|char
name|namebuf
index|[
name|NAMEBUF_LEN
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|getbootdev
argument_list|(
argument|howto
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|howto
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|ptr
init|=
name|namebuf
decl_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|namebuf
argument_list|)
condition|)
block|{
while|while
condition|(
name|c
operator|=
operator|*
name|ptr
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
operator|*
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
return|return;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|&&
name|c
operator|!=
literal|' '
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|howto
operator||=
name|RB_ASKNAME
expr_stmt|;
continue|continue;
case|case
literal|'b'
case|:
operator|*
name|howto
operator||=
name|RB_HALT
expr_stmt|;
continue|continue;
case|case
literal|'c'
case|:
operator|*
name|howto
operator||=
name|RB_CONFIG
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
operator|*
name|howto
operator||=
name|RB_KDB
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
operator|*
name|howto
operator|^=
name|RB_SERIAL
expr_stmt|;
if|if
condition|(
operator|*
name|howto
operator|&
name|RB_SERIAL
condition|)
name|init_serial
argument_list|()
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
operator|*
name|howto
operator||=
name|RB_DFLTROOT
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
operator|*
name|howto
operator||=
name|RB_SINGLE
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
operator|*
name|howto
operator||=
name|RB_VERBOSE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|name
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|&&
name|c
operator|!=
literal|' '
condition|)
empty_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

