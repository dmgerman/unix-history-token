begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, Revision 2.2  92/04/04  11:35:49  rpd  *	$Id$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_include
include|#
directive|include
file|"dkbad.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"disklabe.h"
end_include

begin_include
include|#
directive|include
file|"diskslic.h"
end_include

begin_define
define|#
directive|define
name|BIOS_DEV_FLOPPY
value|0x0
end_define

begin_define
define|#
directive|define
name|BIOS_DEV_WIN
value|0x80
end_define

begin_define
define|#
directive|define
name|BPS
value|512
end_define

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|((((di)>>8)&0xff)+1)
end_define

begin_decl_stmt
specifier|static
name|char
name|i_buf
index|[
name|BPS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|I_ADDR
value|((void *) i_buf)
end_define

begin_comment
comment|/* XXX where all reads go */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_decl_stmt
name|struct
name|dkbad
name|dkb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_bad144
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bsize
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|spt
decl_stmt|,
name|spc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iodest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dosdev
decl_stmt|,
name|slice
decl_stmt|,
name|unit
decl_stmt|,
name|part
decl_stmt|,
name|maj
decl_stmt|,
name|boff
decl_stmt|,
name|poff
decl_stmt|,
name|bnum
decl_stmt|,
name|cnt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|biosread
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|track
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|sector
parameter_list|,
name|int
name|cnt
parameter_list|,
name|unsigned
name|char
name|far
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|disklabel
name|disklabel
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|badsect
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|unsigned
name|long
name|get_diskinfo
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|char
name|dr
init|=
operator|(
name|char
operator|)
name|drive
decl_stmt|;
name|unsigned
name|long
name|rt
decl_stmt|;
name|_asm
block|{
name|mov
name|ah
decl_stmt|,8		;
name|get
name|diskinfo
name|mov
name|dl
decl_stmt|,
name|dr
decl_stmt|;
name|drive
name|int
literal|13h
name|cmp
name|ah
operator|,
literal|0
name|je
name|ok
expr_stmt|;
empty_stmt|;
name|Failure
operator|!
name|We
name|assume
name|it
literal|'s a floppy! 		; 		sub ax,ax 		mov bh,ah 		mov bl,2 		mov ch,79 		mov cl,15 		mov dh,1 		mov dl,1 	ok: 		mov ah,dh 		mov al,cl 		and al,3fh 		mov word ptr rt,ax  		xor bx,bx 		mov bl,cl 		and bl,0c0h 		shl bx,2 		mov bl,ch 		mov word ptr rt+2,bx 	} 	return rt; }  int devopen(void) { 	struct dos_partition *dptr; 	struct disklabel *dl; 	int dosdev = (int) inode.i_dev; 	int i; 	long di, sector; 	 	di = get_diskinfo(dosdev); 	spc = (spt = (int)SPT(di)) * (int)HEADS(di); 	if (dosdev == 2) 	{ 		boff = 0; 		part = (spt == 15 ? 3 : 1); 	} 	else 	{ #ifdef	EMBEDDED_DISKLABEL 		dl =&disklabel; #else	EMBEDDED_DISKLABEL 		Bread(dosdev, 0); 		dptr = (struct dos_partition *)(((char *)I_ADDR)+DOSPARTOFF); 		sector = LABELSECTOR; 		slice = WHOLE_DISK_SLICE; 		for (i = 0; i< NDOSPART; i++, dptr++) 			if (dptr->dp_typ == DOSPTYP_386BSD) { 				slice = BASE_SLICE + i; 				sector = dptr->dp_start + LABELSECTOR; 				break; 			} 		Bread(dosdev, sector++); 		dl=((struct disklabel *)I_ADDR); 		disklabel = *dl;	/* structure copy (maybe useful later)*/ #endif	EMBEDDED_DISKLABEL 		if (dl->d_magic != DISKMAGIC) { 			printf("bad disklabel"); 			return 1; 		}  		if( (maj == 4) || (maj == 0) || (maj == 1)) { 			if (dl->d_type == DTYPE_SCSI) 				maj = 4; /* use scsi as boot dev */ 			else 				maj = 0; /* must be ESDI/IDE */ 		}  		boff = dl->d_partitions[part].p_offset; #ifdef DO_BAD144 		bsize = dl->d_partitions[part].p_size; 		do_bad144 = 0; 		if (dl->d_flags& D_BADSECT) { 		    /* this disk uses bad144 */ 		    int i; 		    long dkbbnum; 		    struct dkbad *dkbptr;  		    /* find the first readable bad sector table */ 		    /* some of this code is copied from ufs/ufs_disksubr.c */ 		    /* including the bugs :-( */ 		    /* read a bad sector table */  #define BAD144_PART	2	/* XXX scattered magic numbers */ #define BSD_PART	0	/* XXX should be 2 but bad144.c uses 0 */ 		    if (dl->d_partitions[BSD_PART].p_offset != 0) 			    dkbbnum = dl->d_partitions[BAD144_PART].p_offset 				      + dl->d_partitions[BAD144_PART].p_size; 		    else 			    dkbbnum = dl->d_secperunit; 		    dkbbnum -= dl->d_nsectors;  		    if (dl->d_secsize> DEV_BSIZE) 		      dkbbnum *= dl->d_secsize / DEV_BSIZE; 		    else 		      dkbbnum /= DEV_BSIZE / dl->d_secsize; 		    i = 0; 		    do_bad144 = 0; 		    do { 			/* XXX: what if the "DOS sector"< 512 bytes ??? */ 			Bread(dosdev, dkbbnum + i); 			dkbptr = (struct dkbad *) I_ADDR; /* XXX why is this not in<sys/dkbad.h> ??? */ #define DKBAD_MAGIC 0x4321 			if (dkbptr->bt_mbz == 0&& 			        dkbptr->bt_flag == DKBAD_MAGIC) { 			    dkb = *dkbptr;	/* structure copy */ 			    do_bad144 = 1; 			    break; 			} 			i += 2; 		    } while (i< 10&& (u_long) i< dl->d_nsectors); 		    if (!do_bad144) 		      printf("Bad badsect table\n"); 		    else 		      printf("Using bad144 bad sector at %ld\n", dkbbnum+i); 		} #endif 	} 	return 0; }  void devread(void) { 	long offset, sector = bnum; 	int dosdev = (int) inode.i_dev; 	for (offset = 0; offset< cnt; offset += BPS) 	{ 		Bread(dosdev, badsect(dosdev, sector++)); 		bcopy(I_ADDR, iodest+offset, BPS); 	} }  /* Read ahead buffer large enough for one track on a 1440K floppy.  For  * reading from floppies, the bootstrap has to be loaded on a 64K boundary  * to ensure that this buffer doesn'
name|t
name|cross
name|a
literal|64K
name|DMA
name|boundary
operator|.
modifier|*
expr|/
define|#
directive|define
name|RA_SECTORS
value|18
specifier|static
name|char
name|ra_buf
index|[
name|RA_SECTORS
operator|*
name|BPS
index|]
expr_stmt|;
specifier|static
name|int
name|ra_dev
decl_stmt|;
specifier|static
name|long
name|ra_end
decl_stmt|;
specifier|static
name|long
name|ra_first
decl_stmt|;
specifier|static
name|void
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
block|{
if|if
condition|(
name|dosdev
operator|!=
name|ra_dev
operator|||
name|sector
operator|<
name|ra_first
operator|||
name|sector
operator|>=
name|ra_end
condition|)
block|{
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|cyl
operator|=
call|(
name|int
call|)
argument_list|(
name|sector
operator|/
operator|(
name|long
operator|)
name|spc
argument_list|)
expr_stmt|;
name|head
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|sector
operator|%
operator|(
name|long
operator|)
name|spc
operator|)
operator|/
operator|(
name|long
operator|)
name|spt
argument_list|)
expr_stmt|;
name|sec
operator|=
call|(
name|int
call|)
argument_list|(
name|sector
operator|%
operator|(
name|long
operator|)
name|spt
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|RA_SECTORS
condition|)
name|nsec
operator|=
name|RA_SECTORS
expr_stmt|;
if|if
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nsec
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Error: C:%d H:%d S:%d\n"
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|ra_dev
operator|=
name|dosdev
expr_stmt|;
name|ra_first
operator|=
name|sector
expr_stmt|;
name|ra_end
operator|=
name|sector
operator|+
name|nsec
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|ra_buf
operator|+
operator|(
name|sector
operator|-
name|ra_first
operator|)
operator|*
name|BPS
argument_list|,
name|I_ADDR
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
specifier|static
name|long
name|badsect
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DO_BAD144
name|int
name|i
decl_stmt|;
if|if
condition|(
name|do_bad144
condition|)
block|{
name|u_short
name|cyl
decl_stmt|;
name|u_short
name|head
decl_stmt|;
name|u_short
name|sec
decl_stmt|;
name|long
name|newsec
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
init|=
operator|&
name|disklabel
decl_stmt|;
comment|/* XXX */
comment|/* from wd.c */
comment|/* bt_cyl = cylinder number in sorted order */
comment|/* bt_trksec is actually (head<< 8) + sec */
comment|/* only remap sectors in the partition */
if|if
condition|(
name|sector
operator|<
name|boff
operator|||
name|sector
operator|>=
name|boff
operator|+
name|bsize
condition|)
block|{
goto|goto
name|no_remap
goto|;
block|}
name|cyl
operator|=
call|(
name|u_short
call|)
argument_list|(
name|sector
operator|/
name|dl
operator|->
name|d_secpercyl
argument_list|)
expr_stmt|;
name|head
operator|=
call|(
name|u_short
call|)
argument_list|(
operator|(
name|sector
operator|%
name|dl
operator|->
name|d_secpercyl
operator|)
operator|/
name|dl
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
name|sec
operator|=
call|(
name|u_short
call|)
argument_list|(
name|sector
operator|%
name|dl
operator|->
name|d_nsectors
argument_list|)
expr_stmt|;
name|sec
operator|=
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sec
expr_stmt|;
comment|/* now, look in the table for a possible bad sector */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|126
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|==
name|cyl
condition|)
block|{
comment|/* found same cylinder */
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|==
name|sec
condition|)
block|{
comment|/* FOUND! */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|>
name|cyl
condition|)
block|{
name|i
operator|=
literal|126
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|126
condition|)
block|{
comment|/* didn't find bad sector */
goto|goto
name|no_remap
goto|;
block|}
comment|/* otherwise find replacement sector */
name|newsec
operator|=
name|dl
operator|->
name|d_secperunit
operator|-
name|dl
operator|->
name|d_nsectors
operator|-
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|newsec
return|;
block|}
name|no_remap
label|:
endif|#
directive|endif
return|return
name|sector
return|;
block|}
end_function

end_unit

