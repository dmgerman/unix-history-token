begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, Revision 2.2  92/04/04  11:35:49  rpd  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_define
define|#
directive|define
name|bcopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|memcpy(b,a,c)
end_define

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|"disklabe.h"
end_include

begin_include
include|#
directive|include
file|"diskslic.h"
end_include

begin_define
define|#
directive|define
name|BIOS_DEV_FLOPPY
value|0x0
end_define

begin_define
define|#
directive|define
name|BIOS_DEV_WIN
value|0x80
end_define

begin_define
define|#
directive|define
name|BPS
value|512
end_define

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|((((di)>>8)&0xff)+1)
end_define

begin_decl_stmt
specifier|static
name|char
name|i_buf
index|[
name|BPS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|I_ADDR
value|((void *) i_buf)
end_define

begin_comment
comment|/* XXX where all reads go */
end_comment

begin_decl_stmt
specifier|static
name|int
name|spt
decl_stmt|,
name|spc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iodest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|dosdev
decl_stmt|,
name|slice
decl_stmt|,
name|unit
decl_stmt|,
name|part
decl_stmt|,
name|maj
decl_stmt|,
name|boff
decl_stmt|,
name|poff
decl_stmt|,
name|bnum
decl_stmt|,
name|cnt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|biosread
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|track
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|sector
parameter_list|,
name|int
name|cnt
parameter_list|,
name|unsigned
name|char
name|far
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|disklabel
name|disklabel
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|unsigned
name|long
name|get_diskinfo
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|char
name|dr
init|=
operator|(
name|char
operator|)
name|drive
decl_stmt|;
name|unsigned
name|long
name|rt
decl_stmt|;
name|_asm
block|{
name|mov
name|ah
decl_stmt|,8		;
name|get
name|diskinfo
name|mov
name|dl
decl_stmt|,
name|dr
decl_stmt|;
name|drive
name|int
literal|13h
name|cmp
name|ah
operator|,
literal|0
name|je
name|ok
expr_stmt|;
empty_stmt|;
name|Failure
operator|!
name|We
name|assume
name|it
literal|'s a floppy! 		; 		sub ax,ax 		mov bh,ah 		mov bl,2 		mov ch,79 		mov cl,15 		mov dh,1 		mov dl,1 	ok: 		mov ah,dh 		mov al,cl 		and al,3fh 		mov word ptr rt,ax  		xor bx,bx 		mov bl,cl 		and bl,0c0h 		shl bx,2 		mov bl,ch 		mov word ptr rt+2,bx 	} 	return rt; }  int devopen(void) { 	struct dos_partition *dptr; 	struct disklabel *dl; 	int dosdev = (int) inode.i_dev; 	int i; 	long di, sector; 	 	di = get_diskinfo(dosdev); 	spc = (spt = (int)SPT(di)) * (int)HEADS(di); 	if (dosdev == 2) 	{ 		boff = 0; 		part = (spt == 15 ? 3 : 1); 	} 	else 	{ #ifdef	EMBEDDED_DISKLABEL 		dl =&disklabel; #else	EMBEDDED_DISKLABEL 		Bread(dosdev, 0); 		dptr = (struct dos_partition *)(((char *)I_ADDR)+DOSPARTOFF); 		sector = LABELSECTOR; 		slice = WHOLE_DISK_SLICE; 		for (i = 0; i< NDOSPART; i++, dptr++) 			if (dptr->dp_typ == DOSPTYP_386BSD) { 				slice = BASE_SLICE + i; 				sector = dptr->dp_start + LABELSECTOR; 				break; 			} 		Bread(dosdev, sector++); 		dl=((struct disklabel *)I_ADDR); 		disklabel = *dl;	/* structure copy (maybe useful later)*/ #endif	EMBEDDED_DISKLABEL 		if (dl->d_magic != DISKMAGIC) { 			printf("bad disklabel"); 			return 1; 		}  		if( (maj == 4) || (maj == 0) || (maj == 1)) { 			if (dl->d_type == DTYPE_SCSI) 				maj = 4; /* use scsi as boot dev */ 			else 				maj = 0; /* must be ESDI/IDE */ 		}  		boff = dl->d_partitions[part].p_offset; 	} 	return 0; }  void devread(void) { 	long offset, sector = bnum; 	int dosdev = (int) inode.i_dev; 	for (offset = 0; offset< cnt; offset += BPS) 	{ 		Bread(dosdev, sector++); 		bcopy(I_ADDR, iodest+offset, BPS); 	} }  /* Read ahead buffer large enough for one track on a 1440K floppy.  For  * reading from floppies, the bootstrap has to be loaded on a 64K boundary  * to ensure that this buffer doesn'
name|t
name|cross
name|a
literal|64K
name|DMA
name|boundary
operator|.
modifier|*
expr|/
define|#
directive|define
name|RA_SECTORS
value|18
specifier|static
name|char
name|ra_buf
index|[
name|RA_SECTORS
operator|*
name|BPS
index|]
expr_stmt|;
specifier|static
name|int
name|ra_dev
decl_stmt|;
specifier|static
name|long
name|ra_end
decl_stmt|;
specifier|static
name|long
name|ra_first
decl_stmt|;
specifier|static
name|void
name|Bread
parameter_list|(
name|int
name|dosdev
parameter_list|,
name|long
name|sector
parameter_list|)
block|{
if|if
condition|(
name|dosdev
operator|!=
name|ra_dev
operator|||
name|sector
operator|<
name|ra_first
operator|||
name|sector
operator|>=
name|ra_end
condition|)
block|{
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|cyl
operator|=
call|(
name|int
call|)
argument_list|(
name|sector
operator|/
operator|(
name|long
operator|)
name|spc
argument_list|)
expr_stmt|;
name|head
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|sector
operator|%
operator|(
name|long
operator|)
name|spc
operator|)
operator|/
operator|(
name|long
operator|)
name|spt
argument_list|)
expr_stmt|;
name|sec
operator|=
call|(
name|int
call|)
argument_list|(
name|sector
operator|%
operator|(
name|long
operator|)
name|spt
argument_list|)
expr_stmt|;
name|nsec
operator|=
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|RA_SECTORS
condition|)
name|nsec
operator|=
name|RA_SECTORS
expr_stmt|;
if|if
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nsec
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Error: C:%d H:%d S:%d\n"
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
name|ra_dev
operator|=
name|dosdev
expr_stmt|;
name|ra_first
operator|=
name|sector
expr_stmt|;
name|ra_end
operator|=
name|sector
operator|+
name|nsec
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|ra_buf
operator|+
operator|(
name|sector
operator|-
name|ra_first
operator|)
operator|*
name|BPS
argument_list|,
name|I_ADDR
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

