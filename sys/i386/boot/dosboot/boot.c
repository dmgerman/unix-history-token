begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, [92/04/03  16:51:14  rvb]  *	$Id: boot.c,v 1.9.2.1 1994/05/01 05:14:49 rgrimes Exp $  */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989, 1990, 1991, 1992     by Intel Corporation, Santa Clara, California.                  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<conio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|"protmod.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|"bootinfo.h"
end_include

begin_include
include|#
directive|include
file|"reboot.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_function_decl
name|int
name|openrd
parameter_list|(
name|char
modifier|*
name|kernel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ufs_read
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|long
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|xread
parameter_list|(
name|unsigned
name|long
name|addr
parameter_list|,
name|long
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|exec
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|argv
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|buf
index|[
name|__LDPGSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
name|startaddr
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pbzero
parameter_list|(
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|__LDPGSZ
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|s
operator|=
name|size
operator|>
name|__LDPGSZ
condition|?
name|__LDPGSZ
else|:
name|size
expr_stmt|;
name|pm_copy
argument_list|(
name|buf
argument_list|,
name|addr
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|size
operator|-=
name|s
expr_stmt|;
name|addr
operator|+=
name|s
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|loadprog
parameter_list|(
name|int
name|howto
parameter_list|,
name|long
modifier|*
name|hsize
parameter_list|)
block|{
name|long
name|int
name|addr
decl_stmt|;
comment|/* physical address.. not directly useable */
name|long
name|int
name|hmaddress
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
function_decl|(
modifier|*
name|x_entry
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
name|argv
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|ufs_read
argument_list|(
operator|&
name|head
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|poff
operator|=
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|startaddr
operator|=
operator|(
name|long
operator|)
name|head
operator|.
name|a_entry
expr_stmt|;
name|addr
operator|=
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
expr_stmt|;
comment|/* some MEG boundary */
name|printf
argument_list|(
literal|"Booting @ 0x%lx\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0x100000l
condition|)
block|{
name|printf
argument_list|(
literal|"kernel linked for wrong address!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Only hope is to link the kernel for> 1MB\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|hsize
operator|=
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_bss
expr_stmt|;
name|addr
operator|=
name|hmaddress
operator|=
name|get_high_memory
argument_list|(
operator|*
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hmaddress
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, can't allocate enough memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/********************************************************/
comment|/* LOAD THE TEXT SEGMENT                                */
comment|/********************************************************/
name|printf
argument_list|(
literal|"text=0x%lx "
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
expr_stmt|;
comment|/********************************************************/
comment|/* Load the Initialised data after the text		*/
comment|/********************************************************/
while|while
condition|(
name|addr
operator|&
name|CLOFSET
condition|)
name|pm_copy
argument_list|(
literal|"\0"
argument_list|,
name|addr
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data=0x%lx "
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|xread
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/********************************************************/
comment|/* Skip over the uninitialised data			*/
comment|/* (but clear it)					*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"bss=0x%lx "
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|pbzero
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
operator|(
name|addr
operator|+=
name|head
operator|.
name|a_bss
operator|)
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|+=
operator|-
name|hmaddress
operator|+
literal|0x100000l
expr_stmt|;
comment|/********************************************************/
comment|/* and note the end address of all this			*/
comment|/********************************************************/
name|addr
operator|=
name|addr
operator|-
name|hmaddress
operator|+
literal|0x100000l
expr_stmt|;
name|argv
index|[
literal|4
index|]
operator|=
operator|(
operator|(
name|addr
operator|+
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1l
operator|)
operator|)
operator|&
operator|~
operator|(
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1l
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"total=0x%lx "
argument_list|,
name|argv
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* 	 *  We now pass the various bootstrap parameters to the loaded 	 *  image via the argument list 	 *  (THIS IS A BIT OF HISTORY FROM MACH.. LEAVE FOR NOW) 	 *  arg1 = boot flags 	 *  arg2 = boot device 	 *  arg3 = start of symbol table (0 if not loaded) 	 *  arg4 = end of symbol table (0 if not loaded) 	 *  arg5 = transfer address from image 	 *  arg6 = transfer address for next image pointer 	 */
switch|switch
condition|(
name|maj
condition|)
block|{
case|case
literal|2
case|:
name|printf
argument_list|(
literal|"\n\nInsert file system floppy in drive A or B\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Press 'A', 'B' or any other key for the default "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c: "
argument_list|,
name|unit
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|i
operator|=
name|_getche
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'0'
operator|||
name|i
operator|==
literal|'A'
operator|||
name|i
operator|==
literal|'a'
condition|)
name|unit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'1'
operator|||
name|i
operator|==
literal|'B'
operator|||
name|i
operator|==
literal|'b'
condition|)
name|unit
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
break|break;
block|}
name|argv
index|[
literal|1
index|]
operator|=
name|howto
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
operator|(
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
operator|(
name|slice
operator|>>
literal|4
operator|)
argument_list|,
operator|(
name|slice
operator|&
literal|0xf
operator|)
argument_list|,
name|unit
argument_list|,
name|part
argument_list|)
operator|)
expr_stmt|;
name|argv
index|[
literal|5
index|]
operator|=
operator|(
name|head
operator|.
name|a_entry
operator|&=
literal|0xfffffff
operator|)
expr_stmt|;
name|argv
index|[
literal|6
index|]
operator|=
operator|(
name|long
operator|)
operator|&
name|x_entry
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"entry point=0x%lx\n"
argument_list|,
operator|(
operator|(
name|long
operator|)
name|startaddr
operator|)
operator|&
literal|0xffffff
argument_list|)
expr_stmt|;
return|return
name|hmaddress
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|memsize
parameter_list|(
name|int
name|x
parameter_list|)
block|{
name|unsigned
name|int
name|rt
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|x
condition|)
block|{
case|case
literal|1
case|:
name|_asm
block|{
name|mov
name|bl
decl_stmt|,1
name|mov
name|ah
decl_stmt|,88h
name|int
decl|15h
name|mov
name|rt
decl_stmt|,
name|ax
block|}
break|break;
default|default:
name|_asm
block|{
name|int
literal|12h
name|mov
name|rt
operator|,
name|ax
block|}
break|break;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_function
name|void
name|bsdboot
parameter_list|(
name|int
name|drive
parameter_list|,
name|int
name|loadflags
parameter_list|,
name|char
modifier|*
name|kernel
parameter_list|)
block|{
name|long
name|hmaddress
decl_stmt|,
name|size
decl_stmt|;
name|argv
index|[
literal|7
index|]
operator|=
name|memsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|argv
index|[
literal|8
index|]
operator|=
name|memsize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/***************************************************************\ 	* As a default set it to the first partition of the first	* 	* floppy or hard drive						* 	\***************************************************************/
name|part
operator|=
name|unit
operator|=
literal|0
expr_stmt|;
name|maj
operator|=
operator|(
name|drive
operator|&
literal|0x80
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
comment|/* a good first bet */
if|if
condition|(
name|openrd
argument_list|(
name|kernel
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Can't find %s\n"
argument_list|,
name|kernel
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|hmaddress
operator|=
name|loadprog
argument_list|(
name|loadflags
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
name|hmaddress
argument_list|,
name|size
argument_list|,
operator|(
operator|(
name|long
operator|)
name|startaddr
operator|&
literal|0xffffffl
operator|)
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

