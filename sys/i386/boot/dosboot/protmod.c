begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	protmod.c		Protected Mode Utilities  *  *	(C) 1994 by Christian Gusenbauer (cg@fimp01.fim.uni-linz.ac.at)  *	All Rights Reserved.  *   *	Permission to use, copy, modify and distribute this software and its  *	documentation is hereby granted, provided that both the copyright  *	notice and this permission notice appear in all copies of the  *	software, derivative works or modified versions, and any portions  *	thereof, and that both notices appear in supporting documentation.  *   *	I ALLOW YOU USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION. I DISCLAIM  *	ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE  *	USE OF THIS SOFTWARE.  *   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|"bootinfo.h"
end_include

begin_include
include|#
directive|include
file|"protmod.h"
end_include

begin_define
define|#
directive|define
name|data32
value|_emit 0x66
end_define

begin_define
define|#
directive|define
name|addr32
value|_emit 0x67
end_define

begin_define
define|#
directive|define
name|SEG
parameter_list|(
name|a
parameter_list|)
value|((unsigned int)(((long)(a))>>16l))
end_define

begin_define
define|#
directive|define
name|OFF
parameter_list|(
name|a
parameter_list|)
value|((unsigned int)((long)(a)))
end_define

begin_define
define|#
directive|define
name|ptr2lin
parameter_list|(
name|a
parameter_list|)
value|((unsigned long)(SEG(a)*0x10l+(long)OFF(a)))
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|short
name|limit
decl_stmt|;
comment|/* Segment limit */
name|unsigned
name|long
name|addr
range|:
literal|24
decl_stmt|;
comment|/* address */
name|unsigned
name|long
name|rights
range|:
literal|8
decl_stmt|;
comment|/* access rights */
name|unsigned
name|short
name|reserved
decl_stmt|;
comment|/* reserved on 80286 */
block|}
name|DTENTRY
typedef|;
end_typedef

begin_struct
struct|struct
name|dtr
block|{
name|unsigned
name|short
name|limit
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|unsigned
name|long
name|cr3
decl_stmt|;
name|unsigned
name|long
name|GdtrAddress
decl_stmt|;
name|unsigned
name|long
name|IdtrAddress
decl_stmt|;
name|unsigned
name|short
name|LDTR
decl_stmt|;
name|unsigned
name|short
name|TR
decl_stmt|;
name|unsigned
name|long
name|EIP
decl_stmt|;
name|unsigned
name|short
name|CS
decl_stmt|;
block|}
name|VCPI
struct|;
end_struct

begin_decl_stmt
specifier|static
name|DTENTRY
name|gdt
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dummy */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* GDT itself */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* FROM */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* TO */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BIOS CS */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* SS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DTENTRY
name|gdt2
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* Dummy */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* GDT itself */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* IDT */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* DS */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* ES */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* SS */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* CS */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* BIOS CS, uninitialized */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
comment|/* VCPI: TSS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DTENTRY
name|FreeBSDGdt
index|[]
init|=
block|{
block|{
literal|0x0000
block|,
literal|0
block|,
literal|0x00
block|,
literal|0x0000
block|}
block|,
comment|/*  0: empty */
block|{
literal|0xffff
block|,
literal|0
block|,
literal|0x9f
block|,
literal|0x00cf
block|}
block|,
comment|/*  1: kernel code */
block|{
literal|0xffff
block|,
literal|0
block|,
literal|0x93
block|,
literal|0x00cf
block|}
block|,
comment|/*  2: kernel data */
block|{
literal|0xffff
block|,
literal|0
block|,
literal|0x9e
block|,
literal|0x0040
block|}
block|,
comment|/*  3: boot code */
block|{
literal|0xffff
block|,
literal|0
block|,
literal|0x92
block|,
literal|0x0040
block|}
block|,
comment|/*  4: boot data */
block|{
literal|0xffff
block|,
literal|0
block|,
literal|0x9e
block|,
literal|0x0000
block|}
block|,
comment|/*  5: 16bit boot code */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DTENTRY
name|Ldt
index|[]
init|=
block|{
block|{
literal|0x0000
block|,
literal|0
block|,
literal|0x00
block|,
literal|0x0000
block|}
block|,
comment|/* 0: empty */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|DTENTRY
name|idt2
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|Tss
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dtr
name|FreeBSDGdtr
init|=
block|{
sizeof|sizeof
name|FreeBSDGdt
operator|-
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dtr
name|Gdtr
init|=
block|{
sizeof|sizeof
name|gdt2
operator|-
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dtr
name|Idtr
init|=
block|{
sizeof|sizeof
name|idt2
operator|-
literal|1
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|VCPIboot
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pm_copy
parameter_list|(
name|char
name|far
modifier|*
name|from
parameter_list|,
name|unsigned
name|long
name|to
parameter_list|,
name|unsigned
name|long
name|count
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|unsigned
name|short
name|cnt
init|=
operator|(
name|unsigned
name|short
operator|)
name|count
decl_stmt|;
if|if
condition|(
name|count
operator|==
literal|0l
condition|)
return|return
operator|-
literal|1
return|;
comment|/* count has to be> 0!! */
name|gdt
index|[
literal|2
index|]
operator|.
name|limit
operator|=
name|cnt
operator|-
literal|1
expr_stmt|;
comment|/* so much bytes to receive */
name|gdt
index|[
literal|2
index|]
operator|.
name|addr
operator|=
name|_FP_SEG
argument_list|(
name|from
argument_list|)
operator|*
literal|0x10l
operator|+
name|_FP_OFF
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|gdt
index|[
literal|2
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
name|gdt
index|[
literal|3
index|]
operator|.
name|limit
operator|=
name|cnt
operator|-
literal|1
expr_stmt|;
comment|/* so much bytes to read */
name|gdt
index|[
literal|3
index|]
operator|.
name|addr
operator|=
name|to
expr_stmt|;
comment|/* from HiMem */
name|gdt
index|[
literal|3
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
name|cnt
operator|>>=
literal|1
expr_stmt|;
name|_asm
block|{
name|pusha
name|mov
name|ah
decl_stmt|,87h		;
name|move
name|words
name|mov
name|cx
decl_stmt|,
name|cnt
decl_stmt|;
name|that
name|many
name|mov
name|bx
decl_stmt|,
name|seg
name|gdt
decl_stmt|;
name|es
label|:
name|si
name|points
name|to
name|the
name|GDT
name|mov
name|es
decl_stmt|,
name|bx
name|mov
name|si
decl_stmt|,
name|offset
name|gdt
name|int
decl|15h
decl_stmt|;
name|now
name|move
name|the
name|memory
name|block
name|mov
name|status
decl_stmt|,
name|ah
decl_stmt|;
name|status
name|is
name|the
return|return
name|value
operator|:
return|;
literal|0
operator|..
name|no
name|error
operator|,
expr_stmt|;
literal|1
operator|..
name|parity
name|error
operator|,
expr_stmt|;
literal|2
operator|..
name|exception
name|interrupt
expr_stmt|;
literal|3
operator|..
name|gate
name|A20
name|failed
name|popa
block|}
return|return
operator|(
name|int
operator|)
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pm_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|status
decl_stmt|;
name|unsigned
name|int
name|segment
decl_stmt|;
comment|/* setup GDT entry 1: GDT */
name|gdt2
index|[
literal|1
index|]
operator|.
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|gdt2
argument_list|)
operator|-
literal|1
expr_stmt|;
name|gdt2
index|[
literal|1
index|]
operator|.
name|addr
operator|=
name|ptr2lin
argument_list|(
name|gdt2
argument_list|)
expr_stmt|;
name|gdt2
index|[
literal|1
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 2: IDT */
name|gdt2
index|[
literal|2
index|]
operator|.
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|idt2
argument_list|)
operator|-
literal|1
expr_stmt|;
name|gdt2
index|[
literal|2
index|]
operator|.
name|addr
operator|=
name|ptr2lin
argument_list|(
name|idt2
argument_list|)
expr_stmt|;
name|gdt2
index|[
literal|2
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 3: DS */
name|_asm
name|mov
name|segment
decl_stmt|,
name|ds
name|gdt2
index|[
literal|3
index|]
decl|.
name|limit
init|=
literal|0xffff
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|3
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|3
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 4: ES */
name|_asm
name|mov
name|segment
decl_stmt|,
name|es
name|gdt2
index|[
literal|4
index|]
decl|.
name|limit
init|=
literal|0xffff
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|4
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|4
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 5: SS */
name|_asm
name|mov
name|segment
decl_stmt|,
name|ss
name|gdt2
index|[
literal|5
index|]
decl|.
name|limit
init|=
literal|0
decl_stmt|;
comment|/* max. offset = 64 K!! */
name|gdt2
index|[
literal|5
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|5
index|]
operator|.
name|rights
operator|=
literal|0x96
expr_stmt|;
comment|/* Stack Segment: r/w, expansion direction=down */
comment|/* setup GDT entry 7: uninitialized! */
comment|/* setup GDT entry 6: CS */
name|_asm
name|mov
name|segment
decl_stmt|,
name|cs
name|gdt2
index|[
literal|6
index|]
decl|.
name|limit
init|=
literal|0xffff
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|6
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|6
index|]
operator|.
name|rights
operator|=
literal|0x9a
expr_stmt|;
comment|/* Code Segment: execute only */
name|_asm
block|{
name|pusha
name|mov
name|ah
decl_stmt|,89h		;
name|enter
name|protected
name|mode
name|mov
name|bx
decl_stmt|,
name|seg
name|gdt2
decl_stmt|;
name|es
label|:
name|si
name|points
name|to
name|the
name|GDT
name|mov
name|es
decl_stmt|,
name|bx
name|mov
name|si
decl_stmt|,
name|offset
name|gdt2
name|mov
name|bx
decl_stmt|,2820h		;
name|setup
name|Interrupt
name|Levels
name|int
literal|15h
expr_stmt|;
name|now
name|move
name|the
name|memory
name|block
name|mov
name|status
decl_stmt|,
name|ah
decl_stmt|;
name|status
name|is
name|the
return|return
name|value
name|and
literal|0
if|if no error occurred 		popa
block|}
if|if
condition|(
name|status
condition|)
return|return
operator|(
name|int
operator|)
name|status
return|;
comment|/* no protected mode; return status */
name|_asm
block|{
name|mov
name|ax
decl_stmt|,30h
name|mov
name|word
name|ptr
name|ss
range|:
index|[
name|bp
operator|+
literal|4
index|]
decl_stmt|,
name|ax
decl_stmt|;
name|patch
name|code
name|selector
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setupVCPI
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|segment
decl_stmt|;
comment|/* setup GDT entry 1: VCPI 1 (code) */
name|gdt2
index|[
literal|1
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|1
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|1
index|]
operator|.
name|rights
operator|=
literal|0
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 2: VCPI 2 */
name|gdt2
index|[
literal|2
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|2
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|2
index|]
operator|.
name|rights
operator|=
literal|0
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 3: VCPI 3 */
name|gdt2
index|[
literal|3
index|]
operator|.
name|limit
operator|=
literal|0
expr_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|3
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|3
index|]
operator|.
name|rights
operator|=
literal|0
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 4: code segment (use16) */
name|_asm
name|mov
name|segment
decl_stmt|,
name|cs
name|gdt2
index|[
literal|4
index|]
decl|.
name|limit
init|=
literal|0xffff
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|4
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|4
index|]
operator|.
name|rights
operator|=
literal|0x9a
expr_stmt|;
comment|/* Code Segment */
comment|/* setup GDT entry 5: data segment (use16) */
name|_asm
name|mov
name|segment
decl_stmt|,
name|ds
name|gdt2
index|[
literal|5
index|]
decl|.
name|limit
init|=
literal|0xffff
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|5
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|5
index|]
operator|.
name|rights
operator|=
literal|0x92
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 6: stack segment */
name|_asm
name|mov
name|segment
decl_stmt|,
name|ss
name|gdt2
index|[
literal|6
index|]
decl|.
name|limit
init|=
literal|0
decl_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|6
index|]
operator|.
name|addr
operator|=
name|segment
operator|*
literal|0x10l
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|6
index|]
operator|.
name|rights
operator|=
literal|0x96
expr_stmt|;
comment|/* Stack Segment: r/w */
comment|/* setup GDT entry 7: LDT selector */
name|gdt2
index|[
literal|7
index|]
operator|.
name|limit
operator|=
literal|7
expr_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|7
index|]
operator|.
name|addr
operator|=
name|ptr2lin
argument_list|(
name|Ldt
argument_list|)
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|7
index|]
operator|.
name|rights
operator|=
literal|0x82
expr_stmt|;
comment|/* Data Segment: r/w */
comment|/* setup GDT entry 8: 286-TSS */
name|gdt2
index|[
literal|8
index|]
operator|.
name|limit
operator|=
literal|43
expr_stmt|;
comment|/* max. offset */
name|gdt2
index|[
literal|8
index|]
operator|.
name|addr
operator|=
name|ptr2lin
argument_list|(
name|Tss
argument_list|)
expr_stmt|;
comment|/* segment starts at */
name|gdt2
index|[
literal|8
index|]
operator|.
name|rights
operator|=
literal|0x81
expr_stmt|;
comment|/* TSS */
block|}
end_function

begin_function
name|long
name|get_high_memory
parameter_list|(
name|long
name|size
parameter_list|)
block|{
name|int
name|kb
init|=
operator|(
call|(
name|int
call|)
argument_list|(
name|size
operator|/
literal|1024l
argument_list|)
operator|+
literal|3
operator|)
operator|&
literal|0xfffc
decl_stmt|;
comment|/* we need this much KB */
name|int
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|vcpiVer
decl_stmt|,
name|vcpiStatus
decl_stmt|;
name|int
function_decl|(
name|far
modifier|*
name|xms_entry
function_decl|)
parameter_list|()
function_decl|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* 	 * Let's check for VCPI services. 	 */
name|fp
operator|=
name|fopen
argument_list|(
literal|"EMMXXXX0"
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_asm
block|{
name|pusha
name|mov
name|ax
decl_stmt|,0de00h
name|int
decl|67h
name|mov
name|vcpiVer
decl_stmt|,
name|bx
name|mov
name|vcpiStatus
decl_stmt|,
name|ax
name|popa
block|}
if|if
condition|(
operator|!
operator|(
name|vcpiStatus
operator|&
literal|0xff00
operator|)
condition|)
block|{
name|VCPIboot
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|"VCPI services Version %d.%d detected!\n"
argument_list|,
name|vcpiVer
operator|>>
literal|8
argument_list|,
name|vcpiVer
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * I don't know why, but 386max seems to use the first 64 KB of that 	 * XMS area?! So I allocate more ram than I need! 	 */
name|kb
operator|+=
literal|128
expr_stmt|;
name|_asm
block|{
name|pusha
name|mov
name|ax
decl_stmt|,4300h
name|int
decl|2fh
decl_stmt|;
name|let
literal|'s look if we have XMS 		cmp al,80h 		je wehaveit		; ok, we have it 		popa 	} 	return 0x110000l;		/* default load address */  no:	_asm popa 	return 0l;  	_asm { wehaveit:	mov ax,4310h 		int 2fh			; get xms entry point 		mov word ptr [xms_entry],bx 		mov word ptr [xms_entry+2],es  		mov ah,8h 		call [xms_entry]  		cmp ax,kb 		jb no  		mov dx,kb 		mov ah,9h 		call [xms_entry]	; get memory 		cmp ax,0 		je no			; sorry, no memory  		mov ah,0ch 		call [xms_entry]	; lock memory block (dx = handle) 		cmp ax,0 		je no 		mov lo,bx 		mov hi,dx 		popa 	} 	return (long)hi*0x10000l+(long)lo + 128l*1024l; }  void startprog(long hmaddress, long hmsize, long startaddr, long loadflags, 			   long bootdev) { 	long GDTaddr=ptr2lin(FreeBSDGdt); 	long *stack=_MK_FP(0x9f00, 0);	/* prepare stack for starting the kernel */ 	unsigned int pmseg, pmoff; 	unsigned int segment, pcxoff, psioff, pdioff; 	long h, BOOTaddr, ourret; 	unsigned char *page; 	int status;  	/* 	 * The MSVC 1.5 inline assembler is not able to work with 	 * 386 opcodes (ie. extended registers like eax). So we have 	 * to use a workaround (god save Micro$oft and their customers ;) 	 */  	_asm { 		mov segment,cs 		mov ax, offset our_return 		mov pmoff,ax 	} 	BOOTaddr = segment*0x10l; 	ourret = BOOTaddr + (long) pmoff;  	_asm { 		push ds  		mov ax,cs 		mov ds,ax 		mov bx,offset lab		; patch the far jump after 		mov byte ptr ds:[patch],bl	; switching gdt for FreeBSD 		mov byte ptr ds:[patch+1],bh  		mov bx,offset pcx 		mov pcxoff,bx 		mov bx,offset psi 		mov psioff,bx 		mov bx,offset pdi 		mov pdioff,bx 		mov segment,ds  		pop ds 	}  	*((long *)_MK_FP(segment, pcxoff+1)) = hmsize; 	*((long *)_MK_FP(segment, psioff+1)) = hmaddress; 	*((long *)_MK_FP(segment, pdioff+1)) = startaddr;  	h = ptr2lin(&VCPI);  	_asm { 		push ds 		mov ax,cs 		mov ds,ax  		mov bx,word ptr ss:[h] 		mov cx,word ptr ss:[h+2]  		mov byte ptr ds:[patch2+1],bl 		mov byte ptr ds:[patch2+2],bh 		mov byte ptr ds:[patch2+3],cl 		mov byte ptr ds:[patch2+4],ch  		pop ds 	}  	/* 	 * Setup the stack for executing the kernel. These parameters are 	 * put on the stack in reversed order (addresses are INCREMENTED)! 	 */  	*stack++ = startaddr;		/* that'
name|s
name|the
name|startaddress
operator|*
operator|/
operator|*
name|stack
operator|++
operator|=
literal|8l
expr_stmt|;
comment|/* new CS */
operator|*
name|stack
operator|++
operator|=
name|ourret
expr_stmt|;
comment|/* ourreturn */
operator|*
name|stack
operator|++
operator|=
name|loadflags
expr_stmt|;
comment|/* howto */
operator|*
name|stack
operator|++
operator|=
name|bootdev
expr_stmt|;
comment|/* bootdev */
operator|*
name|stack
operator|++
operator|=
literal|0l
expr_stmt|;
comment|/* Parameter 4 */
operator|*
name|stack
operator|++
operator|=
literal|0l
expr_stmt|;
comment|/* Parameter 5 */
operator|*
name|stack
operator|++
operator|=
literal|0l
expr_stmt|;
comment|/* Parameter 6 */
operator|*
name|stack
operator|++
operator|=
name|ptr2lin
argument_list|(
operator|&
name|bootinfo
argument_list|)
expr_stmt|;
comment|/* bootinfo */
comment|/* 	 * Initialize FreeBSD GDT and GDTR 	 */
name|FreeBSDGdtr
operator|.
name|base
operator|=
name|GDTaddr
expr_stmt|;
name|FreeBSDGdt
index|[
literal|3
index|]
operator|.
name|addr
operator|=
name|BOOTaddr
expr_stmt|;
comment|/* 	 * Now, we have to start the kernel at the given startaddress. To do this, we must 	 * switch to protected mode using INT15 with AH=0x89. This call uses its own layout 	 * of the GDT, so we switch to our own GDT after we return from the INT15 call. But 	 * before we do this, we must copy the 64 K which overwrites the HIMEM at 0x100000. 	 */
if|if
condition|(
operator|!
name|VCPIboot
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|status
operator|=
name|pm_enter
argument_list|()
operator|)
condition|)
block|{
name|_asm
block|{
name|cli
name|mov
name|ax
decl_stmt|,18h
name|mov
name|ds
decl_stmt|,
name|ax
block|}
goto|goto
name|nowgo
goto|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't switch to protected mode!\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Giving up :-(!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * OK. Let's use VCPI services. 	 */
name|Gdtr
operator|.
name|base
operator|=
name|ptr2lin
argument_list|(
name|gdt2
argument_list|)
expr_stmt|;
name|Idtr
operator|.
name|base
operator|=
name|ptr2lin
argument_list|(
name|idt2
argument_list|)
expr_stmt|;
name|setupVCPI
argument_list|()
expr_stmt|;
name|page
operator|=
name|malloc
argument_list|(
literal|8192
argument_list|)
expr_stmt|;
comment|/* allocate 8 KB */
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"not enough memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|page
argument_list|,
literal|0
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|h
operator|=
operator|(
name|ptr2lin
argument_list|(
name|page
argument_list|)
operator|+
literal|4095l
operator|)
operator|&
literal|0xfffff000l
expr_stmt|;
name|pmseg
operator|=
call|(
name|unsigned
name|short
call|)
argument_list|(
name|h
operator|>>
literal|4l
argument_list|)
expr_stmt|;
comment|/* 	 * We *do* have VCPI services, so let's get the protected mode 	 * interface and page table 0 from the server. 	 */
name|_asm
block|{
name|push
name|ds
name|push
name|si
name|push
name|di
name|mov
name|ax
decl_stmt|,
name|seg
name|gdt2
name|mov
name|ds
decl_stmt|,
name|ax
name|mov
name|ax
decl_stmt|,
name|offset
name|gdt2
name|add
name|ax
decl_stmt|,8
name|mov
name|si
decl_stmt|,
name|ax
name|mov
name|ax
decl_stmt|,
name|pmseg
name|mov
name|es
decl_stmt|,
name|ax
name|xor
name|di
decl_stmt|,
name|di
name|mov
name|ax
decl_stmt|,0xde01
name|int
decl|0x67
name|pop
name|di
name|pop
name|si
name|pop
name|ds
block|}
comment|/* 	 * setup values for the mode change call 	 */
operator|*
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|MK_FP
argument_list|(
name|pmseg
argument_list|,
literal|0x1000
argument_list|)
operator|)
operator|=
name|h
operator|+
literal|3l
expr_stmt|;
name|VCPI
operator|.
name|cr3
operator|=
name|h
operator|+
literal|0x1000l
expr_stmt|;
comment|/* page dir is the next page */
name|VCPI
operator|.
name|GdtrAddress
operator|=
name|ptr2lin
argument_list|(
operator|&
name|Gdtr
argument_list|)
expr_stmt|;
name|VCPI
operator|.
name|IdtrAddress
operator|=
name|ptr2lin
argument_list|(
operator|&
name|Idtr
argument_list|)
expr_stmt|;
name|VCPI
operator|.
name|LDTR
operator|=
literal|7
operator|*
literal|8
expr_stmt|;
name|VCPI
operator|.
name|TR
operator|=
literal|8
operator|*
literal|8
expr_stmt|;
name|_asm
block|{
name|mov
name|ax
decl_stmt|,
name|offset
name|nowgoVCPI
name|mov
name|pmoff
decl_stmt|,
name|ax
block|}
name|VCPI
operator|.
name|EIP
operator|=
operator|(
name|long
operator|)
name|pmoff
expr_stmt|;
name|VCPI
operator|.
name|CS
operator|=
literal|4
operator|*
literal|8
expr_stmt|;
name|_asm
block|{
name|cli
name|data32
name|patch2
range|:
name|mov
name|si
decl_stmt|,0
name|_emit
decl|0
name|_emit
decl|0
name|mov
name|ax
decl_stmt|,0de0ch
name|int
decl|67h
name|nowgoVCPI
range|:
decl_stmt|;
name|we
name|are
name|now
name|executing
name|in
name|protected
name|mode
decl_stmt|;
name|first
operator|,
name|we
name|turn
name|paging
name|off
operator|!
name|data32
name|_emit
literal|0fh
expr_stmt|;
name|this
name|is
literal|"mov eax,CR0"
name|_emit
literal|20h
expr_stmt|;
name|_emit
literal|0c0h
expr_stmt|;
name|data32
name|and
name|ax
decl_stmt|,0ffffh
name|_emit
decl|0ffh
name|_emit
decl|7fh
name|data32
name|_emit
decl|0fh
decl_stmt|;
name|this
name|is
literal|"mov CR0,eax"
name|_emit
literal|22h
expr_stmt|;
name|and
name|turns
name|paging
name|off
name|_emit
literal|0c0h
expr_stmt|;
name|data32
name|xor
name|ax
decl_stmt|,
name|ax
name|data32
name|_emit
decl|0fh
decl_stmt|;
name|this
name|is
literal|"mov CR3,eax"
name|_emit
literal|22h
expr_stmt|;
name|and
name|clears
name|the
name|page
name|cache
name|_emit
literal|0d8h
expr_stmt|;
name|mov
name|ax
decl_stmt|,28h
name|mov
name|ds
decl_stmt|,
name|ax
decl_stmt|;
name|load
name|new
name|DS
name|mov
name|es
decl_stmt|,
name|ax
name|mov
name|ax
decl_stmt|,6
modifier|*
decl_stmt|8
name|mov
name|ss
decl_stmt|,
name|ax
block|}
comment|/*******************************************************************************  * now this is all executed in protected mode!!!  */
comment|/* setup new gdt for the FreeBSD kernel */
name|_asm
block|{
name|nowgo
label|:
name|cli
name|lgdt
name|FreeBSDGdtr
name|data32
name|_emit
literal|0eah
expr_stmt|;
name|far
name|jump
name|to
literal|"lab"
operator|(
switch|switch cs
expr|)
name|patch
operator|:
name|_emit
literal|0
expr_stmt|;
name|these
name|two
name|bytes
name|are
name|patched
name|with
name|the
name|_emit
literal|0
expr_stmt|;
name|correct
name|offset
name|of
literal|"lab"
name|_emit
literal|0
name|_emit
literal|0
name|_emit
literal|18h
name|_emit
literal|0
expr_stmt|;
name|Setup
name|SS
decl_stmt|,
name|DS
name|and
name|ES
name|registers
name|with
name|correct
name|values
decl_stmt|,
name|initialize
name|the
decl_stmt|;
name|stackpointer
name|to
name|the
name|correct
name|value
name|and
name|execute
name|kernel
name|lab
range|:
name|mov
name|bx
decl_stmt|,10h
name|_emit
decl|0
name|_emit
decl|0
name|mov
name|ds
decl_stmt|,
name|bx
name|mov
name|es
decl_stmt|,
name|bx
name|mov
name|ss
decl_stmt|,
name|bx
decl_stmt|;
name|move
name|kernel
name|to
name|its
name|correct
name|address
name|pcx
range|:
name|_emit
literal|0b9h
decl_stmt|;
name|Micro$oft
name|knows
decl_stmt|,
name|why
decl|"mov cx,0"
name|does
name|not
name|_emit
decl|0
decl_stmt|;
name|work
name|here
name|_emit
literal|0
name|_emit
literal|0
name|_emit
literal|0
name|psi
operator|:
name|_emit
literal|0beh
expr_stmt|;
name|mov
name|si
decl_stmt|,0
name|_emit
decl|0
name|_emit
decl|0
name|_emit
decl|0
name|_emit
decl|0
name|pdi
range|:
name|_emit
literal|0bfh
decl_stmt|;
name|mov
name|di
decl_stmt|,0
name|_emit
decl|0
name|_emit
decl|0
name|_emit
decl|0x10
name|_emit
decl|0
name|rep
name|movsb
decl_stmt|;
name|MSVC
name|is
name|unable
name|to
name|assemble
name|this
name|instruction
range|:
name|mov
name|esp
decl_stmt|,09f000h
name|mov
name|sp
decl_stmt|,0f000h
name|_emit
decl|9h
name|_emit
decl|0
name|retf
decl_stmt|;
name|execute
name|kernel
name|our_return
range|:
name|jmp
name|our_return
block|}
comment|/* not reached */
block|}
end_function

end_unit

