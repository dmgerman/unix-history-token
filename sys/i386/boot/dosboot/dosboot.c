begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *	dosboot.c		Boot FreeBSD from DOS partition  *  *	(C) 1994 by Christian Gusenbauer (cg@fimp01.fim.uni-linz.ac.at)  *	All Rights Reserved.  *   *	Permission to use, copy, modify and distribute this software and its  *	documentation is hereby granted, provided that both the copyright  *	notice and this permission notice appear in all copies of the  *	software, derivative works or modified versions, and any portions  *	thereof, and that both notices appear in supporting documentation.  *   *	I ALLOW YOU USE OF THIS SOFTWARE IN ITS "AS IS" CONDITION. I DISCLAIM  *	ANY LIABILITY OF ANY KIND FOR ANY DAMAGES WHATSOEVER RESULTING FROM THE  *	USE OF THIS SOFTWARE.  *   *	Parts of this file are  *	Copyright (c) 1992, 1991 Carnegie Mellon University  *	All Rights Reserved.  *   *	Permission to use, copy, modify and distribute this software and its  *	documentation is hereby granted, provided that both the copyright  *	notice and this permission notice appear in all copies of the  *	software, derivative works or modified versions, and any portions  *	thereof, and that both notices appear in supporting documentation.  *   *	CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  *	CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  *	ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   *	Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   *	any improvements or extensions that they make and grant Carnegie Mellon  *	the rights to redistribute these changes.  */
end_comment

begin_include
include|#
directive|include
file|<bios.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|"protmod.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|"bootinfo.h"
end_include

begin_include
include|#
directive|include
file|"reboot.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_define
define|#
directive|define
name|BUFSIZE
value|4096
end_define

begin_decl_stmt
specifier|static
name|struct
name|exec
name|head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|argv
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|startaddr
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|biosread
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|track
parameter_list|,
name|int
name|head
parameter_list|,
name|int
name|sector
parameter_list|,
name|int
name|cnt
parameter_list|,
name|unsigned
name|char
name|far
modifier|*
name|buffer
parameter_list|)
block|{
name|struct
name|_diskinfo_t
name|di
decl_stmt|;
name|int
name|r
decl_stmt|;
name|di
operator|.
name|drive
operator|=
name|dev
expr_stmt|;
comment|/* first hard disk */
name|di
operator|.
name|head
operator|=
name|head
expr_stmt|;
comment|/* head # */
name|di
operator|.
name|track
operator|=
name|track
expr_stmt|;
comment|/* track # */
name|di
operator|.
name|sector
operator|=
name|sector
operator|+
literal|1
expr_stmt|;
comment|/* sector # */
name|di
operator|.
name|nsectors
operator|=
name|cnt
expr_stmt|;
comment|/* only 1 sector */
name|di
operator|.
name|buffer
operator|=
operator|(
name|void
name|far
operator|*
operator|)
name|buffer
expr_stmt|;
comment|/* sector buffer */
name|r
operator|=
name|_bios_disk
argument_list|(
name|_DISK_READ
argument_list|,
operator|&
name|di
argument_list|)
expr_stmt|;
return|return
name|r
operator|&
literal|0xFF00
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dosxread
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|long
name|size
parameter_list|)
block|{
specifier|extern
name|char
name|buf
index|[
name|BUFSIZE
index|]
decl_stmt|;
name|int
name|count
init|=
name|BUFSIZE
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0l
condition|)
block|{
if|if
condition|(
name|BUFSIZE
operator|>
name|size
condition|)
name|count
operator|=
operator|(
name|int
operator|)
name|size
expr_stmt|;
name|fread
argument_list|(
name|buf
argument_list|,
name|count
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|pm_copy
argument_list|(
name|buf
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|size
operator|-=
name|count
expr_stmt|;
name|addr
operator|+=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|loadprog
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|long
modifier|*
name|hsize
parameter_list|)
block|{
name|long
name|int
name|addr
decl_stmt|;
comment|/* physical address.. not directly useable */
name|long
name|int
name|hmaddress
decl_stmt|,
name|pad
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|int
function_decl|(
modifier|*
name|x_entry
function_decl|)
parameter_list|()
init|=
literal|0
function_decl|;
name|fread
argument_list|(
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
literal|4096
operator|-
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|N_BADMAG
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|startaddr
operator|=
operator|(
name|long
operator|)
name|head
operator|.
name|a_entry
expr_stmt|;
name|addr
operator|=
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
expr_stmt|;
comment|/* some MEG boundary */
name|printf
argument_list|(
literal|"Booting @ 0x%lx\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0x100000l
condition|)
block|{
name|printf
argument_list|(
literal|"Start address too low!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|poff
operator|=
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
operator|+
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_syms
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|poff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fread
argument_list|(
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|hsize
operator|=
name|head
operator|.
name|a_text
operator|+
name|head
operator|.
name|a_data
operator|+
name|head
operator|.
name|a_bss
expr_stmt|;
operator|*
name|hsize
operator|=
operator|(
operator|*
name|hsize
operator|+
name|NBPG
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|NBPG
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|hsize
operator|+=
name|i
operator|+
literal|4
operator|+
name|head
operator|.
name|a_syms
expr_stmt|;
name|addr
operator|=
name|hmaddress
operator|=
name|get_high_memory
argument_list|(
operator|*
name|hsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hmaddress
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, can't allocate enough memory!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|poff
operator|=
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp
argument_list|,
name|poff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* LOAD THE TEXT SEGMENT				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"text=0x%lx "
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|dosxread
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_text
expr_stmt|;
comment|/********************************************************/
comment|/* Load the Initialised data after the text		*/
comment|/********************************************************/
while|while
condition|(
name|addr
operator|&
name|CLOFSET
condition|)
name|pm_copy
argument_list|(
literal|"\0"
argument_list|,
name|addr
operator|++
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data=0x%lx "
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|dosxread
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/********************************************************/
comment|/* Skip over the uninitialised data			*/
comment|/* (but clear it)					*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"bss=0x%lx "
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|pbzero
argument_list|(
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_bss
expr_stmt|;
comment|/* Pad to a page boundary. */
name|pad
operator|=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|addr
operator|-
name|hmaddress
operator|+
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
argument_list|)
operator|%
name|NBPG
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|NBPG
operator|-
name|pad
expr_stmt|;
name|addr
operator|+=
name|pad
expr_stmt|;
block|}
name|bootinfo
operator|.
name|bi_symtab
operator|=
name|addr
operator|-
name|hmaddress
operator|+
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
expr_stmt|;
comment|/********************************************************/
comment|/* Copy the symbol table size				*/
comment|/********************************************************/
name|pm_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|head
operator|.
name|a_syms
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the symbol table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"symbols=[+0x%lx+0x%lx+0x%lx"
argument_list|,
name|pad
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|dosxread
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_syms
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table size				*/
comment|/********************************************************/
name|fread
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|pm_copy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/********************************************************/
comment|/* Load the string table				*/
comment|/********************************************************/
name|printf
argument_list|(
literal|"+0x%x+0x%lx] "
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dosxread
argument_list|(
name|fp
argument_list|,
name|addr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|i
expr_stmt|;
name|bootinfo
operator|.
name|bi_esymtab
operator|=
name|addr
operator|-
name|hmaddress
operator|+
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
expr_stmt|;
comment|/* 	 * For backwards compatibility, use the previously-unused adaptor 	 * and controller bitfields to hold the slice number. 	 */
name|printf
argument_list|(
literal|"total=0x%lx entry point=0x%lx\n"
argument_list|,
name|addr
operator|-
name|hmaddress
operator|+
operator|(
name|startaddr
operator|&
literal|0x00ffffffl
operator|)
argument_list|,
name|startaddr
operator|&
literal|0x00ffffffl
argument_list|)
expr_stmt|;
return|return
name|hmaddress
return|;
block|}
end_function

begin_function
name|void
name|dosboot
parameter_list|(
name|long
name|howto
parameter_list|,
name|char
modifier|*
name|kernel
parameter_list|)
block|{
name|long
name|hmaddress
decl_stmt|,
name|size
decl_stmt|,
name|bootdev
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|kernel
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
comment|/* open kernel for reading */
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, can't open %s!\n"
argument_list|,
name|kernel
argument_list|)
expr_stmt|;
return|return;
block|}
name|hmaddress
operator|=
name|loadprog
argument_list|(
name|fp
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|bootdev
operator|=
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
operator|(
name|slice
operator|>>
literal|4
operator|)
argument_list|,
name|slice
operator|&
literal|0xf
argument_list|,
name|unit
argument_list|,
name|part
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
name|hmaddress
argument_list|,
name|size
argument_list|,
operator|(
operator|(
name|long
operator|)
name|startaddr
operator|&
literal|0xffffffl
operator|)
argument_list|,
name|howto
operator||
name|RB_BOOTINFO
argument_list|,
name|bootdev
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

