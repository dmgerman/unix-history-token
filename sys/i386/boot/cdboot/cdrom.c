begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright © 1997 Pluto Technologies International, Inc.  Boulder CO  * Copyright © 1997 interface business GmbH, Dresden.  *	All rights reserved.  *  * This code was written by Jörg Wunsch, Dresden.  * Direct comments to<joerg_wunsch@interface-business.de>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<isofs/cd9660/iso.h>
end_include

begin_define
define|#
directive|define
name|BLKSIZE
value|2048
end_define

begin_comment
comment|/* CD-ROM data block size */
end_comment

begin_define
define|#
directive|define
name|BIOSSEC
value|512
end_define

begin_comment
comment|/* BIOS sector size */
end_comment

begin_define
define|#
directive|define
name|CD2LBA
parameter_list|(
name|rba
parameter_list|)
value|((rba)<< 2)
end_define

begin_comment
comment|/* CD-ROM relative block to BIOS LBA */
end_comment

begin_decl_stmt
name|u_int32_t
name|sessionstart
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|iso_primary_descriptor
name|pdesc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rootdirbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|rootdirsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|xbuf
index|[
name|BLKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|curblk
decl_stmt|,
name|startblk
decl_stmt|,
name|filesize
decl_stmt|,
name|offset
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bread
parameter_list|(
name|u_int32_t
name|rba
parameter_list|,
name|size_t
name|nblks
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|badread
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|u_int32_t
name|blkno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|iso_directory_record
modifier|*
name|find
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|list_only
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_rr_name
parameter_list|(
name|struct
name|iso_directory_record
modifier|*
name|dirp
parameter_list|,
name|size_t
modifier|*
name|len_ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iread
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
function_decl|(
modifier|*
name|copyfun
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|size
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|daddrpacket
name|dpkt
init|=
block|{
literal|0x10
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|devopen
parameter_list|(
name|u_int32_t
name|session
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|u_int32_t
name|rootdirblk
decl_stmt|;
name|struct
name|iso_directory_record
modifier|*
name|rootdirp
decl_stmt|;
if|if
condition|(
operator|(
name|rv
operator|=
name|bread
argument_list|(
name|session
operator|+
literal|16
argument_list|,
literal|1
argument_list|,
operator|&
name|pdesc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error reading primary ISO descriptor: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rootdirp
operator|=
operator|(
expr|struct
name|iso_directory_record
operator|*
operator|)
name|pdesc
operator|.
name|root_directory_record
expr_stmt|;
name|rootdirblk
operator|=
name|isonum_733
argument_list|(
name|rootdirp
operator|->
name|extent
argument_list|)
expr_stmt|;
name|rootdirsize
operator|=
name|isonum_733
argument_list|(
name|rootdirp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* just in case, round up */
name|rootdirsize
operator|=
operator|(
name|rootdirsize
operator|+
name|BLKSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|rootdirbuf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rootdirbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rootdirbuf
operator|=
name|malloc
argument_list|(
name|rootdirsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot allocate memory for the root "
literal|"directory buffer.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|rv
operator|=
name|bread
argument_list|(
name|rootdirblk
argument_list|,
name|rootdirsize
operator|/
name|BLKSIZE
argument_list|,
name|rootdirbuf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error reading root directory: %d\n"
argument_list|,
name|rv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"Root directory is 0x%x bytes @ %d\n"
operator|,
name|rootdirsize
operator|,
name|rootdirblk
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bread
parameter_list|(
name|u_int32_t
name|rba
parameter_list|,
name|size_t
name|nblks
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rv
operator|=
operator|-
literal|1
init|;
name|rv
operator|!=
literal|0
operator|&&
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|dpkt
operator|.
name|nblocks
operator|=
name|nblks
operator|*
operator|(
name|BLKSIZE
operator|/
name|BIOSSEC
operator|)
expr_stmt|;
name|dpkt
operator|.
name|boffs
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|buf
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|dpkt
operator|.
name|bseg
operator|=
name|BOOTSEG
expr_stmt|;
name|dpkt
operator|.
name|lba
operator|=
name|CD2LBA
argument_list|(
name|rba
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_VERBOSE
name|DPRINTF
argument_list|(
operator|(
literal|"Calling biosreadlba(%d blocks, lba %d) = "
operator|,
name|dpkt
operator|.
name|nblocks
operator|,
name|dpkt
operator|.
name|lba
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rv
operator|=
name|biosreadlba
argument_list|(
operator|&
name|dpkt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_VERBOSE
name|DPRINTF
argument_list|(
operator|(
literal|"%d\n"
operator|,
name|rv
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|rv
return|;
block|}
end_function

begin_function
name|void
name|seek
parameter_list|(
name|u_int32_t
name|offs
parameter_list|)
block|{
name|offset
operator|=
name|offs
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badread
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|u_int32_t
name|blkno
parameter_list|)
block|{
name|printf
argument_list|(
literal|"Error reading block %d from CD-ROM: %s\n"
argument_list|,
name|blkno
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|size_t
name|minlen
parameter_list|(
name|size_t
name|a
parameter_list|,
name|size_t
name|b
parameter_list|)
block|{
return|return
name|a
operator|<
name|b
condition|?
name|a
else|:
name|b
return|;
block|}
end_function

begin_comment
comment|/*  * Internal form of read()/xread().  */
end_comment

begin_function
specifier|static
name|int
name|iread
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
function_decl|(
modifier|*
name|copyfun
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|size
parameter_list|)
parameter_list|)
block|{
name|u_int32_t
name|newblk
decl_stmt|,
name|ptr
decl_stmt|;
name|size_t
name|bsize
decl_stmt|;
name|newblk
operator|=
name|offset
operator|/
name|BLKSIZE
operator|+
name|startblk
expr_stmt|;
if|if
condition|(
name|newblk
operator|!=
name|curblk
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|len
operator|>=
name|filesize
condition|)
block|{
name|badread
argument_list|(
literal|"access beyond file limit"
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bread
argument_list|(
name|newblk
argument_list|,
literal|1
argument_list|,
name|xbuf
argument_list|)
condition|)
block|{
name|badread
argument_list|(
literal|"BIOS read error"
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|curblk
operator|=
name|newblk
expr_stmt|;
block|}
name|ptr
operator|=
name|offset
operator|&
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|>
literal|0
condition|)
block|{
comment|/* initial short transfer */
name|bsize
operator|=
name|minlen
argument_list|(
name|BLKSIZE
operator|-
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|copyfun
argument_list|(
name|xbuf
operator|+
name|ptr
argument_list|,
name|buf
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bsize
expr_stmt|;
name|len
operator|-=
name|bsize
expr_stmt|;
name|offset
operator|+=
name|bsize
expr_stmt|;
block|}
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|bsize
control|)
block|{
name|bsize
operator|=
name|minlen
argument_list|(
name|len
argument_list|,
name|BLKSIZE
argument_list|)
expr_stmt|;
name|newblk
operator|=
name|offset
operator|/
name|BLKSIZE
operator|+
name|startblk
expr_stmt|;
if|if
condition|(
name|newblk
operator|!=
name|curblk
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|bsize
operator|>
name|filesize
condition|)
block|{
name|badread
argument_list|(
literal|"access beyond file limit"
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|bread
argument_list|(
name|newblk
argument_list|,
literal|1
argument_list|,
name|xbuf
argument_list|)
condition|)
block|{
name|badread
argument_list|(
literal|"BIOS read error"
argument_list|,
name|newblk
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|curblk
operator|=
name|newblk
expr_stmt|;
block|}
name|copyfun
argument_list|(
name|xbuf
argument_list|,
name|buf
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|bsize
expr_stmt|;
name|offset
operator|+=
name|bsize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|read
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"read(0x%x, %d)\n"
operator|,
operator|(
name|int
operator|)
name|buf
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|iread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|bcopy
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|xread
parameter_list|(
name|u_char
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"xread(0x%x, %d)\n"
operator|,
operator|(
name|int
operator|)
name|buf
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
return|return
name|iread
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|pcpy
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|get_rr_name
parameter_list|(
name|struct
name|iso_directory_record
modifier|*
name|dirp
parameter_list|,
name|size_t
modifier|*
name|len_ret
parameter_list|)
block|{
struct|struct
name|rr_header
block|{
name|char
name|type
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|len
decl_stmt|;
name|u_char
name|version
decl_stmt|;
block|}
modifier|*
name|rrp
struct|;
struct|struct
name|rr_nm_header
block|{
name|struct
name|rr_header
name|rrh
decl_stmt|;
name|u_char
name|flags
decl_stmt|;
name|char
name|name
index|[
literal|0
index|]
decl_stmt|;
comment|/* XXX -- using gcc extension */
block|}
modifier|*
name|rrnmp
struct|;
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|dirp
operator|->
name|name
operator|+
operator|(
name|u_char
operator|)
name|dirp
operator|->
name|name_len
index|[
literal|0
index|]
expr_stmt|;
comment|/* round up to 16-bit boundary; ugly */
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
operator|(
name|int
operator|)
name|cp
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
operator|)
expr_stmt|;
name|rrp
operator|=
operator|(
expr|struct
name|rr_header
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|rrp
operator|->
name|type
index|[
literal|0
index|]
operator|!=
literal|'R'
operator|||
name|rrp
operator|->
name|type
index|[
literal|1
index|]
operator|!=
literal|'R'
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no RR, "
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"RR attribs: "
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rrp
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|dirp
operator|<=
operator|(
name|u_char
operator|)
name|dirp
operator|->
name|length
index|[
literal|0
index|]
condition|)
block|{
name|rrp
operator|=
operator|(
expr|struct
name|rr_header
operator|*
operator|)
name|cp
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"%c%c "
operator|,
name|rrp
operator|->
name|type
index|[
literal|0
index|]
operator|,
name|rrp
operator|->
name|type
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrp
operator|->
name|type
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|rrp
operator|->
name|type
index|[
literal|1
index|]
operator|==
literal|'M'
condition|)
block|{
name|rrnmp
operator|=
operator|(
expr|struct
name|rr_nm_header
operator|*
operator|)
name|rrp
expr_stmt|;
operator|*
name|len_ret
operator|=
name|rrp
operator|->
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rr_nm_header
argument_list|)
expr_stmt|;
return|return
name|rrnmp
operator|->
name|name
return|;
block|}
name|cp
operator|+=
name|rrp
operator|->
name|len
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|iso_directory_record
modifier|*
name|find
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|list_only
parameter_list|)
block|{
name|struct
name|iso_directory_record
modifier|*
name|dirp
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|rrname
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|entrylen
decl_stmt|;
name|char
name|namebuf
index|[
literal|256
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|comp
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
while|while
condition|(
operator|*
name|path
operator|&&
operator|*
name|path
operator|==
literal|'/'
condition|)
name|path
operator|++
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|rootdirbuf
operator|,
name|i
operator|=
literal|1
init|;
name|ptr
operator|<
name|rootdirbuf
operator|+
name|rootdirsize
condition|;
name|ptr
operator|+=
name|entrylen
operator|,
name|i
operator|++
control|)
block|{
name|dirp
operator|=
operator|(
expr|struct
name|iso_directory_record
operator|*
operator|)
name|ptr
expr_stmt|;
name|entrylen
operator|=
operator|(
name|u_char
operator|)
name|dirp
operator|->
name|length
index|[
literal|0
index|]
expr_stmt|;
name|len
operator|=
operator|(
name|u_char
operator|)
name|dirp
operator|->
name|name_len
index|[
literal|0
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"# %d: offset 0x%x, length 0x%x = %d, "
operator|,
name|i
operator|,
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|rootdirbuf
argument_list|)
operator|,
name|entrylen
operator|,
name|entrylen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entrylen
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Dir entry of length 0.  That's the last 			 * entry in this block, advance to the next 			 * block (if any).  In case we get beyond the 			 * end of the directory, we'll fall off the 			 * loop due to the rootdirsize condition in 			 * the `for' statement. 			 */
name|DPRINTF
argument_list|(
operator|(
literal|"entrylen 0\n"
operator|)
argument_list|)
expr_stmt|;
name|entrylen
operator|=
operator|(
operator|~
operator|(
operator|(
name|ptr
operator|-
name|rootdirbuf
operator|)
operator|+
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"name_len 0\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|==
literal|1
operator|&&
operator|(
name|dirp
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|dirp
operator|->
name|name
index|[
literal|1
index|]
operator|==
literal|'\1'
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"dot/dot-dot entry\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* don't consider directories */
if|if
condition|(
name|dirp
operator|->
name|flags
index|[
literal|0
index|]
operator|&
literal|2
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"directory\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rrname
operator|=
name|get_rr_name
argument_list|(
name|dirp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|comp
operator|=
name|rrname
condition|?
name|strcmp
else|:
name|strcasecmp
expr_stmt|;
name|bcopy
argument_list|(
name|rrname
condition|?
name|rrname
else|:
name|dirp
operator|->
name|name
argument_list|,
name|namebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|namebuf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"name `%s'\n"
operator|,
name|namebuf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_only
condition|)
block|{
ifndef|#
directive|ifndef
name|DEBUG
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|comp
argument_list|(
name|path
argument_list|,
name|namebuf
argument_list|)
operator|==
literal|0
condition|)
return|return
name|dirp
return|;
block|}
ifndef|#
directive|ifndef
name|DEBUG
if|if
condition|(
name|list_only
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|openrd
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|u_int32_t
name|oldsession
decl_stmt|;
name|int
name|session
decl_stmt|,
name|list_only
decl_stmt|;
name|struct
name|iso_directory_record
modifier|*
name|dirp
decl_stmt|;
name|session
operator|=
literal|0
expr_stmt|;
name|fname
operator|=
name|name
expr_stmt|;
comment|/* 	 * We accept the following boot string: 	 * 	 * [@sessionstart] name 	 */
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
switch|switch
condition|(
operator|*
name|cp
condition|)
block|{
comment|/* we don't support filenames with spaces */
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
break|break;
case|case
literal|'@'
case|:
if|if
condition|(
name|session
condition|)
block|{
name|printf
argument_list|(
literal|"Syntax error\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|session
operator|++
expr_stmt|;
name|oldsession
operator|=
name|sessionstart
expr_stmt|;
name|sessionstart
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|session
operator|==
literal|1
condition|)
block|{
name|sessionstart
operator|*=
literal|10
expr_stmt|;
name|sessionstart
operator|+=
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|session
operator|==
literal|1
condition|)
block|{
name|session
operator|++
expr_stmt|;
name|fname
operator|=
name|cp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|session
operator|&&
name|devopen
argument_list|(
name|sessionstart
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|devopen
argument_list|(
name|oldsession
argument_list|)
expr_stmt|;
name|sessionstart
operator|=
name|oldsession
expr_stmt|;
block|}
if|if
condition|(
name|session
operator|==
literal|1
condition|)
comment|/* XXX no filename, only session arg */
return|return
operator|-
literal|1
return|;
name|list_only
operator|=
name|fname
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Calling find(%s, %d):\n"
operator|,
name|fname
operator|,
name|list_only
operator|)
argument_list|)
expr_stmt|;
name|dirp
operator|=
name|find
argument_list|(
name|fname
argument_list|,
name|list_only
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"find() returned 0x%x\n"
operator|,
operator|(
name|int
operator|)
name|dirp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_only
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|dirp
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|startblk
operator|=
name|isonum_733
argument_list|(
name|dirp
operator|->
name|extent
argument_list|)
expr_stmt|;
name|filesize
operator|=
name|isonum_733
argument_list|(
name|dirp
operator|->
name|size
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"startblk = %d, filesize = %d\n"
operator|,
name|startblk
operator|,
name|filesize
operator|)
argument_list|)
expr_stmt|;
name|curblk
operator|=
literal|0
expr_stmt|;
comment|/* force a re-read, 0 is impossible file start */
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

