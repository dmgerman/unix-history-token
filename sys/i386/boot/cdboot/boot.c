begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, [92/04/03  16:51:14  rvb]  * $FreeBSD$  */
end_comment

begin_comment
comment|/*   Copyright 1988, 1989, 1990, 1991, 1992    by Intel Corporation, Santa Clara, California.                  All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies and that both the copyright notice and this permission notice appear in supporting documentation, and that the name of Intel not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */
end_comment

begin_comment
comment|/*  * Extensions for El Torito CD-ROM booting:  *  * Copyright © 1997 Pluto Technologies International, Inc.  Boulder CO  * Copyright © 1997 interface business GmbH, Dresden.  *	All rights reserved.  *  * This code was written by Jörg Wunsch, Dresden.  * Direct comments to<joerg_wunsch@interface-business.de>.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<machine/bootinfo.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PROBE_KEYBOARD_LOCK
end_ifdef

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ouraddr
value|(BOOTSEG<< 4)
end_define

begin_comment
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|loadflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * By now, only "cd".  How do we learn from the BIOS we've been booted off  * an ATAPI CD-ROM?  Do the non-{cd,wcd} drivers implement El Torito booting  * at all?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maj
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|specpacket
name|spkt
init|=
block|{
literal|0x13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|namebuf
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bootinfo
name|bootinfo
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|getbootdev
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|howto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loadprog
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* NORETURN */
end_comment

begin_function
name|void
name|boot
parameter_list|(
name|int
name|drive
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|PROBE_KEYBOARD
if|if
condition|(
name|probe_keyboard
argument_list|()
condition|)
block|{
name|init_serial
argument_list|()
expr_stmt|;
name|loadflags
operator||=
name|RB_SERIAL
expr_stmt|;
name|printf
argument_list|(
literal|"\nNo keyboard found."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROBE_KEYBOARD_LOCK
if|if
condition|(
operator|!
operator|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|0x10
operator|)
condition|)
block|{
name|init_serial
argument_list|()
expr_stmt|;
name|loadflags
operator||=
name|RB_SERIAL
expr_stmt|;
name|printf
argument_list|(
literal|"\nKeyboard locked."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FORCE_COMCONSOLE
name|init_serial
argument_list|()
expr_stmt|;
name|loadflags
operator||=
name|RB_SERIAL
expr_stmt|;
name|printf
argument_list|(
literal|"\nSerial console forced."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Pick up the story from the Bios on geometry of disks */
comment|/* 	 * XXX 	 * Do we need to defer this until we can relinguish the 	 * BIOS emulation? 	 */
for|for
control|(
name|ret
operator|=
literal|0
init|;
name|ret
operator|<
name|N_BIOS_GEOM
condition|;
name|ret
operator|++
control|)
name|bootinfo
operator|.
name|bi_bios_geom
index|[
name|ret
index|]
operator|=
name|get_diskinfo
argument_list|(
name|ret
operator|+
literal|0x80
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_basemem
operator|=
name|memsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_extmem
operator|=
name|memsize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_memsizes_valid
operator|=
literal|1
expr_stmt|;
name|gateA20
argument_list|()
expr_stmt|;
name|ret
operator|=
name|getbootspec
argument_list|(
operator|&
name|spkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Your BIOS int 0x13 extensions seem to be disabled.\n"
literal|"It's impossible to boot a CD-ROM without them.\n"
literal|"(BIOS int 0x13 fn 0x4b01 yielded error %d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|devopen
argument_list|(
name|sessionstart
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Warning: cannot open default session.\n"
literal|"Maybe your BIOS int 0x13 extensions are disabled?\n"
literal|"You need them in order to boot a CD-ROM.\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * The El Torito specification stinks.  Not only this 		 * crappy idea of `emulation booting' (and at least 		 * earlier versions of the AHA-2940 BIOS didn't 		 * implement anything else than floppy emulation 		 * booting), but note also that there's absolutely no 		 * way via the BIOS to obtain the starting LBA of your 		 * session.  All you can get ahold of is the LBA of 		 * that funny emulated disk.  Since this one just 		 * happens to be a file hidden inside the ISO9660 		 * filesystem, it is located at a varying offset from 		 * the start of the session.  We therefore allow to 		 * specify the starting block of the session to use in 		 * the boot string, so the operator can specify the 		 * session to boot from.  However, (s)he needs to know 		 * the RBA for the session from the CD-ROM TOC. 		 */
name|DPRINTF
argument_list|(
operator|(
literal|"using session at sector %d\n"
operator|,
name|sessionstart
operator|)
argument_list|)
expr_stmt|;
name|name
operator|=
literal|"/kernel"
expr_stmt|;
name|printf
argument_list|(
literal|"\n>> FreeBSD CD-ROM BOOT\n"
literal|"Usage: [@%d]%s[-abcCdghrsv]\n"
literal|"Use ? for file list or press Enter for defaults\n"
literal|"\nBoot: "
argument_list|,
name|sessionstart
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|loadflags
operator|&=
name|RB_SERIAL
expr_stmt|;
comment|/* clear all, but leave serial console */
name|loadflags
operator||=
name|RB_CDROM
expr_stmt|;
comment|/* ...and default to CD-ROM root. */
name|getbootdev
argument_list|(
name|namebuf
argument_list|,
operator|&
name|loadflags
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Selected: name=`%s', loadflags=0x%x\n"
operator|,
name|name
operator|,
name|loadflags
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|openrd
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"openrd() = %d\n"
operator|,
name|ret
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"Can't find %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|loadprog
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|loadprog
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|exec
name|head
decl_stmt|;
name|u_int32_t
name|startaddr
decl_stmt|,
name|addr
decl_stmt|,
name|bootdev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|pad
decl_stmt|;
name|seek
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
name|head
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|N_BADMAG
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Invalid format!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We assume that the entry address is the same as the lowest text 	 * address and that the kernel startup code handles relocation by 	 * this address rounded down to a multiple of 16M. 	 */
name|startaddr
operator|=
name|head
operator|.
name|a_entry
operator|&
literal|0x00FFFFFF
expr_stmt|;
name|addr
operator|=
name|startaddr
expr_stmt|;
name|printf
argument_list|(
literal|"Booting CD-ROM [@%d]%s @ 0x%x\n"
argument_list|,
name|sessionstart
argument_list|,
name|name
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0x00100000
condition|)
block|{
comment|/* 		 * Bail out, instead of risking to damage the BIOS 		 * variables, the loader, or the adapter memory area. 		 * We don't support loading below 1 MB any more. 		 */
name|printf
argument_list|(
literal|"Start address too low\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"text=0x%x "
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
expr_stmt|;
comment|/* load the text segment */
name|seek
argument_list|(
name|N_TXTOFF
argument_list|(
name|head
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_text
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|addr
operator|+=
name|head
operator|.
name|a_text
expr_stmt|;
comment|/* Pad to a page boundary. */
name|pad
operator|=
operator|(
name|unsigned
operator|)
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|PAGE_SIZE
operator|-
name|pad
expr_stmt|;
name|pbzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|pad
expr_stmt|;
block|}
comment|/* load the initialised data after the text */
name|printf
argument_list|(
literal|"data=0x%x "
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_data
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|addr
operator|+=
name|head
operator|.
name|a_data
expr_stmt|;
comment|/* Skip over the uninitialised data (but clear it) */
name|printf
argument_list|(
literal|"bss=0x%x "
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
comment|/*  * XXX however, we should be checking that we don't load ... into  * nonexistent memory.  A full symbol table is unlikely to fit on 4MB  * machines.  */
name|pbzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_bss
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|head
operator|.
name|a_bss
expr_stmt|;
comment|/* Pad to a page boundary. */
name|pad
operator|=
operator|(
name|unsigned
operator|)
name|addr
operator|&
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|pad
operator|!=
literal|0
condition|)
block|{
name|pad
operator|=
name|PAGE_SIZE
operator|-
name|pad
expr_stmt|;
name|addr
operator|+=
name|pad
expr_stmt|;
block|}
name|bootinfo
operator|.
name|bi_symtab
operator|=
name|addr
expr_stmt|;
comment|/* Copy the symbol table size */
name|pcpy
argument_list|(
operator|&
name|head
operator|.
name|a_syms
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
comment|/* Load the symbol table */
name|printf
argument_list|(
literal|"symbols=[+0x%x+0x%x+0x%x"
argument_list|,
name|pad
argument_list|,
sizeof|sizeof
argument_list|(
name|head
operator|.
name|a_syms
argument_list|)
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
expr_stmt|;
if|if
condition|(
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|head
operator|.
name|a_syms
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|addr
operator|+=
name|head
operator|.
name|a_syms
expr_stmt|;
comment|/* Load the string table size */
if|if
condition|(
name|read
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|pcpy
argument_list|(
operator|&
name|i
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|-=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Load the string table */
name|printf
argument_list|(
literal|"+0x%x+0x%x]\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|xread
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|i
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|addr
operator|+=
name|i
expr_stmt|;
name|bootinfo
operator|.
name|bi_esymtab
operator|=
name|addr
expr_stmt|;
comment|/* XXX what else can we say about a CD-ROM? */
name|bootdev
operator|=
name|MAKEBOOTDEV
argument_list|(
name|maj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_version
operator|=
name|BOOTINFO_VERSION
expr_stmt|;
name|bootinfo
operator|.
name|bi_kernelname
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|name
operator|+
name|ouraddr
argument_list|)
expr_stmt|;
name|bootinfo
operator|.
name|bi_nfs_diskless
operator|=
literal|0
expr_stmt|;
name|bootinfo
operator|.
name|bi_size
operator|=
sizeof|sizeof
argument_list|(
name|bootinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total=0x%x entry point=0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|addr
argument_list|,
operator|(
name|int
operator|)
name|startaddr
argument_list|)
expr_stmt|;
name|startprog
argument_list|(
operator|(
name|int
operator|)
name|startaddr
argument_list|,
name|loadflags
operator||
name|RB_BOOTINFO
argument_list|,
name|bootdev
argument_list|,
operator|(
name|int
operator|)
operator|&
name|bootinfo
operator|+
name|ouraddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getbootdev
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|howto
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
comment|/* 	 * Be paranoid and make doubly sure that the input buffer is empty. 	 */
if|if
condition|(
operator|*
name|howto
operator|&
name|RB_SERIAL
condition|)
name|init_serial
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|gets
argument_list|(
name|ptr
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|ptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|nextarg
label|:
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
operator|*
operator|++
name|ptr
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|ptr
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
condition|)
goto|goto
name|nextarg
goto|;
if|if
condition|(
name|c
operator|==
literal|'C'
condition|)
operator|*
name|howto
operator|&=
operator|~
name|RB_CDROM
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'a'
condition|)
operator|*
name|howto
operator||=
name|RB_ASKNAME
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'b'
condition|)
operator|*
name|howto
operator||=
name|RB_HALT
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
operator|*
name|howto
operator||=
name|RB_CONFIG
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'d'
condition|)
operator|*
name|howto
operator||=
name|RB_KDB
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'h'
condition|)
block|{
operator|*
name|howto
operator|^=
name|RB_SERIAL
expr_stmt|;
if|if
condition|(
operator|*
name|howto
operator|&
name|RB_SERIAL
condition|)
name|init_serial
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|'g'
condition|)
operator|*
name|howto
operator||=
name|RB_GDB
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'r'
condition|)
operator|*
name|howto
operator||=
name|RB_DFLTROOT
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
operator|*
name|howto
operator||=
name|RB_SINGLE
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'v'
condition|)
operator|*
name|howto
operator||=
name|RB_VERBOSE
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
return|return;
name|name
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|ptr
operator|==
literal|' '
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

end_unit

