begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/************************************************************************** NETBOOT -  BOOTP/TFTP Bootstrap Program  Author: Martin Renters.   Date: Mar 22 1995   This code is based heavily on David Greenman's if_ed.c driver and   Andres Vega Garcia's if_ep.c driver.   Copyright (C) 1993-1994, David Greenman, Martin Renters.  Copyright (C) 1993-1995, Andres Vega Garcia.   Copyright (C) 1995, Serge Babkin.   This software may be used, modified, copied, distributed, and sold, in   both source and binary form provided that the above copyright and these   terms are retained. Under no circumstances are the authors responsible for   the proper functioning of this software, nor do the authors assume any   responsibility for damages incurred with its use.  3c503 support added by Bill Paul (wpaul@ctr.columbia.edu) on 11/15/94 SMC8416 support added by Bill Paul (wpaul@ctr.columbia.edu) on 12/25/94 3c509 support added by Serge Babkin (babkin@hq.icb.chel.su) on 03/22/95  ***************************************************************************/
end_comment

begin_comment
comment|/* #define EDEBUG */
end_comment

begin_include
include|#
directive|include
file|"netboot.h"
end_include

begin_include
include|#
directive|include
file|"ether.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_3C509
end_ifdef

begin_include
include|#
directive|include
file|"if_epreg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|short
name|aui
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|bnc
init|=
literal|0
decl_stmt|,
name|utp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for 3C509 */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|eth_nic_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|eth_asic_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|eth_base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_tx_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_laar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_vendor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|eth_memsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_bmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_rmem
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|eth_node_addr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_3C509
end_ifdef

begin_expr_stmt
specifier|static
name|send_ID_sequence
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|get_eeprom_data
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|get_e
argument_list|()
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************** The following two variables are used externally ***************************************************************************/
end_comment

begin_decl_stmt
name|char
name|packet
index|[
name|ETH_MAX_PACKET
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|packetlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************* ETH_FILLNAME - Fill name of adapter in NFS structure **************************************************************************/
end_comment

begin_macro
name|eth_fillname
argument_list|(
argument|where
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|where
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|eth_vendor
condition|)
block|{
case|case
name|VENDOR_3C509
case|:
name|where
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|'p'
expr_stmt|;
name|where
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|where
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VENDOR_WD
case|:
case|case
name|VENDOR_NOVELL
case|:
case|case
name|VENDOR_3COM
case|:
name|where
index|[
literal|0
index|]
operator|=
literal|'e'
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|'d'
expr_stmt|;
name|where
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|where
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|where
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
literal|'?'
expr_stmt|;
name|where
index|[
literal|2
index|]
operator|=
literal|'?'
expr_stmt|;
name|where
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_PROBE - Look for an adapter ***************************************************************************/
end_comment

begin_macro
name|eth_probe
argument_list|()
end_macro

begin_block
block|{
comment|/* common variables */
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_3C509
comment|/* variables for 3C509 */
name|int
name|data
decl_stmt|,
name|j
decl_stmt|,
name|io_base
decl_stmt|,
name|id_port
init|=
name|EP_ID_PORT
decl_stmt|;
name|int
name|nisa
init|=
literal|0
decl_stmt|,
name|neisa
init|=
literal|0
decl_stmt|;
name|u_short
name|k
decl_stmt|;
name|int
name|ep_current_tag
init|=
name|EP_LAST_TAG
operator|+
literal|1
decl_stmt|;
name|short
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
comment|/* varaibles for 8390 */
name|struct
name|wd_board
modifier|*
name|brd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|short
name|chksum
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
endif|#
directive|endif
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_3C509
comment|/********************************************************* 			Search for 3Com 509 card 	***********************************************************/
comment|/* Look for the EISA boards, leave them activated */
comment|/* search for the first card, ignore all others */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|16
operator|&&
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|;
name|j
operator|++
control|)
block|{
name|io_base
operator|=
operator|(
name|j
operator|*
name|EP_EISA_START
operator|)
operator||
name|EP_EISA_W0
expr_stmt|;
if|if
condition|(
name|inw
argument_list|(
name|io_base
operator|+
name|EP_W0_MFG_ID
argument_list|)
operator|!=
name|MFG_ID
condition|)
continue|continue;
comment|/* we must found 0x1f if the board is EISA configurated */
if|if
condition|(
operator|(
name|inw
argument_list|(
name|io_base
operator|+
name|EP_W0_ADDRESS_CFG
argument_list|)
operator|&
literal|0x1f
operator|)
operator|!=
literal|0x1f
condition|)
continue|continue;
comment|/* Reset and Enable the card */
name|outb
argument_list|(
name|io_base
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|W0_P4_CMD_RESET_ADAPTER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* we must wait at least 1 ms */
name|outb
argument_list|(
name|io_base
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|W0_P4_CMD_ENABLE_ADAPTER
argument_list|)
expr_stmt|;
comment|/* 			 * Once activated, all the registers are mapped in the range 			 * x000 - x00F, where x is the slot number. 			 */
name|eth_base
operator|=
name|j
operator|*
name|EP_EISA_START
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_3C509
expr_stmt|;
block|}
name|ep_current_tag
operator|--
expr_stmt|;
comment|/* Look for the ISA boards. Init and leave them actived */
comment|/* search for the first card, ignore all others */
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0xc0
argument_list|)
expr_stmt|;
comment|/* Global reset */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EP_MAX_BOARDS
operator|&&
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|;
name|i
operator|++
control|)
block|{
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_ID_sequence
argument_list|(
name|id_port
argument_list|)
expr_stmt|;
name|data
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_MFG_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|MFG_ID
condition|)
break|break;
comment|/* resolve contention using the Ethernet address */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|3
condition|;
name|j
operator|++
control|)
name|data
operator|=
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|eth_base
operator|=
operator|(
name|get_eeprom_data
argument_list|(
name|id_port
argument_list|,
name|EEPROM_ADDR_CFG
argument_list|)
operator|&
literal|0x1f
operator|)
operator|*
literal|0x10
operator|+
literal|0x200
expr_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
name|ep_current_tag
argument_list|)
expr_stmt|;
comment|/* tags board */
name|outb
argument_list|(
name|id_port
argument_list|,
name|ACTIVATE_ADAPTER_TO_CONFIG
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_3C509
expr_stmt|;
name|ep_current_tag
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
comment|/* 	* The iobase was found and MFG_ID was 0x6d50. PROD_ID should be 	* 0x9[0-f]50 	*/
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|get_e
argument_list|(
name|EEPROM_PROD_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|&
literal|0xf0ff
operator|)
operator|!=
operator|(
name|PROD_ID
operator|&
literal|0xf0ff
operator|)
condition|)
goto|goto
name|no3c509
goto|;
if|if
condition|(
name|eth_base
operator|>=
name|EP_EISA_START
condition|)
block|{
name|printf
argument_list|(
literal|"3C5x9 board on EISA at 0x%x - "
argument_list|,
name|eth_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"3C5x9 board on ISA at 0x%x - "
argument_list|,
name|eth_base
argument_list|)
expr_stmt|;
block|}
comment|/* test for presence of connectors */
name|i
operator|=
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|)
expr_stmt|;
name|j
operator|=
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_ADDRESS_CFG
argument_list|)
operator|>>
literal|14
expr_stmt|;
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|i
operator|&
name|IS_UTP
condition|)
block|{
name|printf
argument_list|(
literal|"10baseT\r\n"
argument_list|)
expr_stmt|;
name|utp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"10baseT not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|i
operator|&
name|IS_AUI
condition|)
name|printf
argument_list|(
literal|"10base5\r\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"10base5 not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|i
operator|&
name|IS_BNC
condition|)
block|{
name|printf
argument_list|(
literal|"10base2\r\n"
argument_list|)
expr_stmt|;
name|bnc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"10base2 not present\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown connector\r\n"
argument_list|)
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
goto|goto
name|no3c509
goto|;
block|}
comment|/* 	* Read the station address from the eeprom 	*/
name|p
operator|=
operator|(
name|u_short
operator|*
operator|)
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|get_e
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
operator|(
name|i
operator|*
literal|2
operator|)
argument_list|,
name|ntohs
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"Ethernet address: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%b:"
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%b\n"
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|eth_node_addr
operator|=
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
expr_stmt|;
name|eth_reset
argument_list|()
expr_stmt|;
return|return
name|eth_vendor
return|;
name|no3c509
label|:
name|eth_vendor
operator|=
name|VENDOR_NONE
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
ifdef|#
directive|ifdef
name|INCLUDE_WD
comment|/****************************************************************** 		Search for WD/SMC cards 	*******************************************************************/
for|for
control|(
name|eth_asic_base
operator|=
name|WD_LOW_BASE
init|;
name|eth_asic_base
operator|<=
name|WD_HIGH_BASE
condition|;
name|eth_asic_base
operator|+=
literal|0x20
control|)
block|{
name|chksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|8
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|chksum
operator|+=
name|inb
argument_list|(
name|i
operator|+
name|eth_asic_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chksum
operator|&
literal|0x00FF
operator|)
operator|==
literal|0x00FF
condition|)
break|break;
block|}
if|if
condition|(
name|eth_asic_base
operator|<=
name|WD_HIGH_BASE
condition|)
block|{
comment|/* We've found a board */
name|eth_vendor
operator|=
name|VENDOR_WD
expr_stmt|;
name|eth_nic_base
operator|=
name|eth_asic_base
operator|+
name|WD_NIC_ADDR
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|WD_BID
argument_list|)
expr_stmt|;
comment|/* Get board id */
for|for
control|(
name|brd
operator|=
name|wd_boards
init|;
name|brd
operator|->
name|name
condition|;
name|brd
operator|++
control|)
if|if
condition|(
name|brd
operator|->
name|id
operator|==
name|c
condition|)
break|break;
if|if
condition|(
operator|!
name|brd
operator|->
name|name
condition|)
block|{
name|printf
argument_list|(
literal|"\r\nUnknown Ethernet type %x\r\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Unknown type */
block|}
name|eth_flags
operator|=
name|brd
operator|->
name|flags
expr_stmt|;
name|eth_memsize
operator|=
name|brd
operator|->
name|memsize
expr_stmt|;
name|eth_tx_start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|TYPE_WD8013EP
operator|)
operator|&&
operator|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|WD_ICR
argument_list|)
operator|&
name|WD_ICR_16BIT
operator|)
condition|)
block|{
name|eth_flags
operator|=
name|FLAG_16BIT
expr_stmt|;
name|eth_memsize
operator|=
name|MEM_16384
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|&
name|WD_SOFTCONFIG
operator|)
operator|&&
operator|(
operator|!
operator|(
name|eth_flags
operator|&
name|FLAG_790
operator|)
operator|)
condition|)
block|{
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
literal|0x80000
operator||
operator|(
operator|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|)
operator|&
literal|0x3F
operator|)
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
block|}
else|else
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
name|WD_DEFAULT_MEM
expr_stmt|;
if|if
condition|(
name|brd
operator|->
name|id
operator|==
name|TYPE_SMC8216T
operator|||
name|brd
operator|->
name|id
operator|==
name|TYPE_SMC8216C
condition|)
block|{
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
name|eth_bmem
operator|+
literal|8192
operator|)
operator|=
operator|(
name|unsigned
name|int
operator|)
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
name|int
operator|)
operator|*
operator|(
name|eth_bmem
operator|+
literal|8192
operator|)
condition|)
block|{
name|brd
operator|+=
literal|2
expr_stmt|;
name|eth_memsize
operator|=
name|brd
operator|->
name|memsize
expr_stmt|;
block|}
block|}
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
comment|/* Reset */
name|printf
argument_list|(
literal|"\r\n%s base 0x%x, memory 0x%X, addr "
argument_list|,
name|brd
operator|->
name|name
argument_list|,
name|eth_asic_base
argument_list|,
name|eth_bmem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%b"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|i
operator|+
name|eth_asic_base
operator|+
name|WD_LAR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
name|WD_MSR_MENB
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
literal|0x04
argument_list|,
operator|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
literal|0x04
argument_list|)
operator||
literal|0x80
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
literal|0x0B
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|eth_bmem
operator|>>
literal|13
operator|)
operator|&
literal|0x0F
operator|)
operator||
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|eth_bmem
operator|>>
literal|11
operator|)
operator|&
literal|0x40
operator|)
operator||
operator|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
literal|0x0B
argument_list|)
operator|&
literal|0xB0
operator|)
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
literal|0x04
argument_list|,
operator|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
literal|0x04
argument_list|)
operator|&
operator|~
literal|0x80
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
operator|)
name|eth_bmem
operator|>>
literal|13
operator|)
operator|&
literal|0x3F
operator|)
operator||
literal|0x40
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|eth_laar
operator|=
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
name|WD_LAAR_M16EN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
operator|(
name|eth_laar
operator|=
name|WD_LAAR_M16EN
operator||
name|WD_LAAR_L16EN
operator||
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_3COM
comment|/****************************************************************** 	        Search for 3Com 3c503 if no WD/SMC cards         *******************************************************************/
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|)
block|{
name|eth_asic_base
operator|=
name|_3COM_BASE
operator|+
name|_3COM_ASIC_OFFSET
expr_stmt|;
name|eth_nic_base
operator|=
name|_3COM_BASE
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_3COM
expr_stmt|;
comment|/* 		 * Note that we use the same settings for both 8 and 16 bit cards: 		 * both have an 8K bank of memory at page 1 while only the 16 bit 		 * cards have a bank at page 0. 		 */
name|eth_memsize
operator|=
name|MEM_16384
expr_stmt|;
name|eth_tx_start
operator|=
literal|32
expr_stmt|;
comment|/* Check our base address */
switch|switch
condition|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_BCFR
argument_list|)
condition|)
block|{
case|case
name|_3COM_BCFR_300
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x300
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_310
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x310
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_330
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x330
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_350
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x350
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_250
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x250
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_280
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x280
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_2A0
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x2a0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|_3COM_BCFR_2E0
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|eth_nic_base
operator|!=
literal|0x2e0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now get the shared memory address */
switch|switch
condition|(
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_PCFR
argument_list|)
condition|)
block|{
case|case
name|_3COM_PCFR_DC000
case|:
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
literal|0xdc000
expr_stmt|;
break|break;
case|case
name|_3COM_PCFR_D8000
case|:
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
literal|0xd8000
expr_stmt|;
break|break;
case|case
name|_3COM_PCFR_CC000
case|:
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
literal|0xcc000
expr_stmt|;
break|break;
case|case
name|_3COM_PCFR_C8000
case|:
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
literal|0xc8000
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Need this to make eth_poll() happy. */
name|eth_rmem
operator|=
name|eth_bmem
operator|-
literal|0x2000
expr_stmt|;
comment|/* Reset NIC and ASIC */
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
name|_3COM_CR_RST
operator||
name|_3COM_CR_XSEL
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
name|_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* Get our ethernet address */
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
name|_3COM_CR_EALO
operator||
name|_3COM_CR_XSEL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n3Com 3c503 base 0x%x, memory 0x%X addr "
argument_list|,
name|eth_nic_base
argument_list|,
name|eth_bmem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%b"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
operator|=
name|inb
argument_list|(
name|eth_nic_base
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
name|_3COM_CR_XSEL
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize GA configuration register. Set bank and enable shared 		 * mem. We always use bank 1. 		 */
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_GACFR
argument_list|,
name|_3COM_GACFR_RSEL
operator||
name|_3COM_GACFR_MBS0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_VPTR2
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_VPTR1
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_VPTR0
argument_list|,
literal|0x00
argument_list|)
expr_stmt|;
comment|/* 		 * Clear memory and verify that it worked (we use only 8K) 		 */
name|bzero
argument_list|(
name|eth_bmem
argument_list|,
literal|0x2000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|0x2000
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|*
operator|(
operator|(
name|eth_bmem
operator|)
operator|+
name|i
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Failed to clear 3c503 shared mem.\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Initialize GA page/start/stop registers. 		 */
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_PSTR
argument_list|,
name|eth_tx_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_PSPR
argument_list|,
name|eth_memsize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_NE
comment|/****************************************************************** 		Search for NE1000/2000 if no WD/SMC or 3com cards 	*******************************************************************/
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|)
block|{
name|char
name|romdata
index|[
literal|16
index|]
decl_stmt|,
name|testbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|test
index|[]
init|=
literal|"NE1000/2000 memory"
decl_stmt|;
name|eth_bmem
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* No shared memory */
name|eth_asic_base
operator|=
name|NE_BASE
operator|+
name|NE_ASIC_OFFSET
expr_stmt|;
name|eth_nic_base
operator|=
name|NE_BASE
expr_stmt|;
name|eth_vendor
operator|=
name|VENDOR_NOVELL
expr_stmt|;
name|eth_flags
operator|=
name|FLAG_PIO
expr_stmt|;
name|eth_memsize
operator|=
name|MEM_16384
expr_stmt|;
name|eth_tx_start
operator|=
literal|32
expr_stmt|;
name|c
operator|=
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|NE_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|NE_RESET
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_STP
operator||
name|D8390_COMMAND_RD2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RCR
argument_list|,
name|D8390_RCR_MON
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_DCR
argument_list|,
name|D8390_DCR_FT1
operator||
name|D8390_DCR_LS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTART
argument_list|,
name|MEM_8192
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTOP
argument_list|,
name|MEM_16384
argument_list|)
expr_stmt|;
name|eth_pio_write
argument_list|(
name|test
argument_list|,
literal|8192
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
name|eth_pio_read
argument_list|(
literal|8192
argument_list|,
name|testbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcompare
argument_list|(
name|test
argument_list|,
name|testbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
condition|)
block|{
name|eth_flags
operator||=
name|FLAG_16BIT
expr_stmt|;
name|eth_memsize
operator|=
name|MEM_32768
expr_stmt|;
name|eth_tx_start
operator|=
literal|64
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_DCR
argument_list|,
name|D8390_DCR_WTS
operator||
name|D8390_DCR_FT1
operator||
name|D8390_DCR_LS
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTART
argument_list|,
name|MEM_16384
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTOP
argument_list|,
name|MEM_32768
argument_list|)
expr_stmt|;
name|eth_pio_write
argument_list|(
name|test
argument_list|,
literal|16384
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
name|eth_pio_read
argument_list|(
literal|16384
argument_list|,
name|testbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bcompare
argument_list|(
name|testbuf
argument_list|,
name|test
argument_list|,
sizeof|sizeof
argument_list|(
name|test
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eth_pio_read
argument_list|(
literal|0
argument_list|,
name|romdata
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\nNE1000/NE2000 base 0x%x, addr "
argument_list|,
name|eth_nic_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%b"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
operator|=
name|romdata
index|[
name|i
operator|+
operator|(
operator|(
name|eth_flags
operator|&
name|FLAG_16BIT
operator|)
condition|?
name|i
else|:
literal|0
operator|)
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_NONE
condition|)
goto|goto
name|no8390
goto|;
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3COM
condition|)
name|eth_rmem
operator|=
name|eth_bmem
expr_stmt|;
name|eth_node_addr
operator|=
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
expr_stmt|;
name|eth_reset
argument_list|()
expr_stmt|;
return|return
operator|(
name|eth_vendor
operator|)
return|;
endif|#
directive|endif
comment|/* NE */
name|no8390
label|:
endif|#
directive|endif
comment|/*8390 */
return|return
name|VENDOR_NONE
return|;
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_RESET - Reset adapter ***************************************************************************/
end_comment

begin_macro
name|eth_reset
argument_list|()
end_macro

begin_block
block|{
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_3C509
comment|/*********************************************************** 			Reset 3Com 509 card 	*************************************************************/
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
comment|/* stop card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_DISABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|STOP_TRANSCEIVER
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
argument_list|)
expr_stmt|;
comment|/*  	/* initialize card  	*/
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|GO_WINDOW
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Configure IRQ to none */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_RESOURCE_CFG
argument_list|,
name|SET_IRQ
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable the card */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W0_CONFIG_CTRL
argument_list|,
name|ENABLE_DRQ_IRQ
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* Reload the ether_addr. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W2_ADDR_0
operator|+
name|i
argument_list|,
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
comment|/* Window 1 is operating window */
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
expr_stmt|;
comment|/* get rid of stray intr's */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
literal|0xff
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RD_0_MASK
operator||
name|S_5_INTS
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_INTR_MASK
operator||
name|S_5_INTS
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_FILTER
operator||
name|FIL_INDIVIDUAL
operator||
name|FIL_BRDCST
argument_list|)
expr_stmt|;
comment|/* configure BNC */
if|if
condition|(
name|bnc
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|START_TRANSCEIVER
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* configure UTP */
if|if
condition|(
name|utp
condition|)
block|{
name|GO_WINDOW
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W4_MEDIA_TYPE
argument_list|,
name|ENABLE_UTP
argument_list|)
expr_stmt|;
name|GO_WINDOW
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* start tranciever and receiver */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_ENABLE
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
comment|/* set early threshold for minimal packet length */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_RX_EARLY_THRESH
operator||
literal|64
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|SET_TX_START_THRESH
operator||
literal|16
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
name|no3c509
label|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
comment|/************************************************************** 			Reset cards based on 8390 chip 	****************************************************************/
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_WD
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_NOVELL
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_3COM
condition|)
goto|goto
name|no8390
goto|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_STP
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STP
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_DCR
argument_list|,
literal|0x49
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_DCR
argument_list|,
literal|0x48
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RCR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* allow broadcast frames */
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TCR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TPSR
argument_list|,
name|eth_tx_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTART
argument_list|,
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
literal|0x09
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_PSTOP
argument_list|,
name|eth_memsize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_BOUND
argument_list|,
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_ISR
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_IMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS1
operator||
name|D8390_COMMAND_STP
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS1
operator||
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P1_PAR0
operator|+
name|i
argument_list|,
name|eth_node_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P1_MAR0
operator|+
name|i
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P1_CURR
argument_list|,
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_ISR
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TCR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_3COM
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_3COM
condition|)
block|{
comment|/* 		         * No way to tell whether or not we're supposed to use 		         * the 3Com's transceiver unless the user tells us. 		         * 'aui' should have some compile time default value 		         * which can be changed from the command menu. 		         */
if|if
condition|(
name|aui
condition|)
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|_3COM_CR
argument_list|,
name|_3COM_CR_XSEL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
name|no8390
label|:
endif|#
directive|endif
comment|/* 8390 */
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_TRANSMIT - Transmit a frame ***************************************************************************/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|padmap
index|[]
init|=
block|{
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|eth_transmit
argument_list|(
argument|d
argument_list|,
argument|t
argument_list|,
argument|s
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|d
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Destination */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|t
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type */
end_comment

begin_decl_stmt
name|unsigned
name|short
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size */
end_comment

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Packet */
end_comment

begin_block
block|{
specifier|register
name|u_int
name|len
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_3C509
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"{l=%d,t=%x}"
argument_list|,
name|s
operator|+
literal|14
argument_list|,
name|t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* swap bytes of type */
name|t
operator|=
operator|(
operator|(
name|t
operator|&
literal|0xFF
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|t
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
operator|)
expr_stmt|;
name|len
operator|=
name|s
operator|+
literal|14
expr_stmt|;
comment|/* actual length of packet */
name|pad
operator|=
name|padmap
index|[
name|len
operator|&
literal|3
index|]
expr_stmt|;
comment|/* 	* The 3c509 automatically pads short packets to minimum ethernet length, 	* but we drop packets that are too large. Perhaps we should truncate 	* them instead? 	*/
if|if
condition|(
name|len
operator|+
name|pad
operator|>
name|ETHER_MAX_LEN
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* drop acknowledgements */
while|while
condition|(
operator|(
name|status
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|)
operator|)
operator|&
name|TXS_COMPLETE
condition|)
block|{
if|if
condition|(
name|status
operator|&
operator|(
name|TXS_UNDERRUN
operator||
name|TXS_MAX_COLLISION
operator||
name|TXS_STATUS_OVERFLOW
operator|)
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_RESET
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|TX_ENABLE
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_STATUS
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_FREE_TX
argument_list|)
operator|<
name|len
operator|+
name|pad
operator|+
literal|4
condition|)
block|{
comment|/* no room in FIFO */
block|}
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* Second dword meaningless */
comment|/* write packet */
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|d
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|eth_node_addr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|outsw
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
name|p
argument_list|,
name|s
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&
literal|1
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
operator|*
operator|(
name|p
operator|+
name|s
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|pad
operator|--
condition|)
name|outb
argument_list|(
name|BASE
operator|+
name|EP_W1_TX_PIO_WR_1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Padding */
comment|/* timeout after sending */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|no3c509
label|:
endif|#
directive|endif
comment|/* 3C509 */
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_WD
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_NOVELL
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_3COM
condition|)
goto|goto
name|no8390
goto|;
ifdef|#
directive|ifdef
name|INCLUDE_3COM
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_3COM
condition|)
block|{
name|bcopy
argument_list|(
name|d
argument_list|,
name|eth_bmem
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* dst */
name|bcopy
argument_list|(
name|eth_node_addr
argument_list|,
name|eth_bmem
operator|+
literal|6
argument_list|,
name|ETHER_ADDR_SIZE
argument_list|)
expr_stmt|;
comment|/* src */
operator|*
operator|(
name|eth_bmem
operator|+
literal|12
operator|)
operator|=
name|t
operator|>>
literal|8
expr_stmt|;
comment|/* type */
operator|*
operator|(
name|eth_bmem
operator|+
literal|13
operator|)
operator|=
name|t
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|eth_bmem
operator|+
literal|14
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|ETH_MIN_PACKET
condition|)
operator|*
operator|(
name|eth_bmem
operator|+
operator|(
name|s
operator|++
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_WD
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_WD
condition|)
block|{
comment|/* Memory interface */
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
name|eth_laar
operator||
name|WD_LAAR_M16EN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
name|WD_MSR_MENB
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|d
argument_list|,
name|eth_bmem
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* dst */
name|bcopy
argument_list|(
name|eth_node_addr
argument_list|,
name|eth_bmem
operator|+
literal|6
argument_list|,
name|ETHER_ADDR_SIZE
argument_list|)
expr_stmt|;
comment|/* src */
operator|*
operator|(
name|eth_bmem
operator|+
literal|12
operator|)
operator|=
name|t
operator|>>
literal|8
expr_stmt|;
comment|/* type */
operator|*
operator|(
name|eth_bmem
operator|+
literal|13
operator|)
operator|=
name|t
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|eth_bmem
operator|+
literal|14
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|14
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|ETH_MIN_PACKET
condition|)
operator|*
operator|(
name|eth_bmem
operator|+
operator|(
name|s
operator|++
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
name|eth_laar
operator|&
operator|~
name|WD_LAAR_M16EN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_NE
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_NOVELL
condition|)
block|{
comment|/* Programmed I/O */
name|unsigned
name|short
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|t
operator|>>
literal|8
operator|)
operator||
operator|(
name|t
operator|<<
literal|8
operator|)
expr_stmt|;
name|eth_pio_write
argument_list|(
name|d
argument_list|,
name|eth_tx_start
operator|<<
literal|8
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|eth_pio_write
argument_list|(
name|eth_node_addr
argument_list|,
operator|(
name|eth_tx_start
operator|<<
literal|8
operator|)
operator|+
literal|6
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|eth_pio_write
argument_list|(
operator|&
name|type
argument_list|,
operator|(
name|eth_tx_start
operator|<<
literal|8
operator|)
operator|+
literal|12
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|eth_pio_write
argument_list|(
name|p
argument_list|,
operator|(
name|eth_tx_start
operator|<<
literal|8
operator|)
operator|+
literal|14
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|14
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|ETH_MIN_PACKET
condition|)
name|s
operator|=
name|ETH_MIN_PACKET
expr_stmt|;
block|}
endif|#
directive|endif
name|twiddle
argument_list|()
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TPSR
argument_list|,
name|eth_tx_start
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TBCR0
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_TBCR1
argument_list|,
name|s
operator|>>
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_TXP
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
operator||
name|D8390_COMMAND_TXP
operator||
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|no8390
label|:
endif|#
directive|endif
comment|/* 8390 */
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_POLL - Wait for a frame ***************************************************************************/
end_comment

begin_macro
name|eth_poll
argument_list|()
end_macro

begin_block
block|{
comment|/* common variables */
name|unsigned
name|short
name|type
init|=
literal|0
decl_stmt|;
name|unsigned
name|short
name|len
decl_stmt|;
comment|/* variables for 3C509 */
ifdef|#
directive|ifdef
name|INCLUDE_3C509
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|lenthisone
decl_stmt|;
name|short
name|rx_fifo2
decl_stmt|,
name|status
decl_stmt|,
name|cst
decl_stmt|;
specifier|register
name|short
name|rx_fifo
decl_stmt|;
endif|#
directive|endif
comment|/* variables for 8390 */
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|bound
decl_stmt|,
name|curr
decl_stmt|,
name|rstat
decl_stmt|;
name|unsigned
name|short
name|pktoff
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|ringbuffer
name|pkthdr
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INCLUDE_3C509
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_3C509
condition|)
goto|goto
name|no3c509
goto|;
name|cst
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
if|if
condition|(
name|cst
operator|&
literal|0x1FFF
condition|)
name|printf
argument_list|(
literal|"-%x-"
argument_list|,
name|cst
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|cst
operator|&
operator|(
name|S_RX_COMPLETE
operator||
name|S_RX_EARLY
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* acknowledge  everything */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|ACK_INTR
operator||
operator|(
name|cst
operator|&
name|S_5_INTS
operator|)
argument_list|)
expr_stmt|;
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|C_INTR_LATCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"*%x*"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|&
name|ERR_RX
condition|)
block|{
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|rx_fifo
operator|=
name|status
operator|&
name|RX_BYTES_MASK
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* read packet */
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"[l=%d"
argument_list|,
name|rx_fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|packet
argument_list|,
name|rx_fifo
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|&
literal|1
condition|)
name|packet
index|[
name|rx_fifo
operator|-
literal|1
index|]
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
name|packetlen
operator|=
name|rx_fifo
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|inw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_STATUS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"*%x*"
argument_list|,
name|status
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rx_fifo
operator|=
name|status
operator|&
name|RX_BYTES_MASK
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|>
literal|0
condition|)
block|{
name|insw
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|,
name|packet
operator|+
name|packetlen
argument_list|,
name|rx_fifo
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rx_fifo
operator|&
literal|1
condition|)
name|packet
index|[
name|packetlen
operator|+
name|rx_fifo
operator|-
literal|1
index|]
operator|=
name|inb
argument_list|(
name|BASE
operator|+
name|EP_W1_RX_PIO_RD_1
argument_list|)
expr_stmt|;
name|packetlen
operator|+=
name|rx_fifo
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"+%d"
argument_list|,
name|rx_fifo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|status
operator|&
name|RX_INCOMPLETE
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"=%d"
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* acknowledge reception of packet */
name|outw
argument_list|(
name|BASE
operator|+
name|EP_COMMAND
argument_list|,
name|RX_DISCARD_TOP_PACK
argument_list|)
expr_stmt|;
while|while
condition|(
name|inw
argument_list|(
name|BASE
operator|+
name|EP_STATUS
argument_list|)
operator|&
name|S_COMMAND_IN_PROGRESS
condition|)
empty_stmt|;
name|type
operator|=
operator|(
name|packet
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
name|packet
index|[
literal|13
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
if|if
condition|(
name|packet
index|[
literal|0
index|]
operator|+
name|packet
index|[
literal|1
index|]
operator|+
name|packet
index|[
literal|2
index|]
operator|+
name|packet
index|[
literal|3
index|]
operator|+
name|packet
index|[
literal|4
index|]
operator|+
name|packet
index|[
literal|5
index|]
operator|==
literal|0xFF
operator|*
literal|6
condition|)
name|printf
argument_list|(
literal|",t=0x%x,b]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|",t=0x%x]"
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|ARP
condition|)
block|{
name|struct
name|arprequest
modifier|*
name|arpreq
decl_stmt|;
name|unsigned
name|long
name|reqip
decl_stmt|;
name|arpreq
operator|=
operator|(
expr|struct
name|arprequest
operator|*
operator|)
operator|&
name|packet
index|[
name|ETHER_HDR_SIZE
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"(ARP %I->%I)"
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arpreq
operator|->
name|sipaddr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arpreq
operator|->
name|tipaddr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|convert_ipaddr
argument_list|(
operator|&
name|reqip
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|arpreq
operator|->
name|opcode
argument_list|)
operator|==
name|ARP_REQUEST
operator|)
operator|&&
operator|(
name|reqip
operator|==
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|ipaddr
operator|)
condition|)
block|{
name|arpreq
operator|->
name|opcode
operator|=
name|htons
argument_list|(
name|ARP_REPLY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|shwaddr
argument_list|,
name|arpreq
operator|->
name|thwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
argument_list|,
name|arpreq
operator|->
name|shwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|convert_ipaddr
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
operator|&
name|reqip
argument_list|)
expr_stmt|;
name|eth_transmit
argument_list|(
name|arpreq
operator|->
name|thwaddr
argument_list|,
name|ARP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arprequest
argument_list|)
argument_list|,
name|arpreq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|IP
condition|)
block|{
name|struct
name|iphdr
modifier|*
name|iph
decl_stmt|;
name|iph
operator|=
operator|(
expr|struct
name|iphdr
operator|*
operator|)
operator|&
name|packet
index|[
name|ETHER_HDR_SIZE
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|EDEBUG
name|printf
argument_list|(
literal|"(IP %I-%d->%I)"
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|iph
operator|->
name|src
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|iph
operator|->
name|protocol
argument_list|)
argument_list|,
name|ntohl
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|iph
operator|->
name|dest
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
literal|1
return|;
name|no3c509
label|:
endif|#
directive|endif
comment|/* 3C509 */
if|#
directive|if
name|defined
argument_list|(
name|INCLUDE_3COM
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_WD
argument_list|)
operator|||
name|defined
argument_list|(
name|INCLUDE_NE
argument_list|)
if|if
condition|(
name|eth_vendor
operator|!=
name|VENDOR_WD
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_NOVELL
operator|&&
name|eth_vendor
operator|!=
name|VENDOR_3COM
condition|)
goto|goto
name|no8390
goto|;
name|rstat
operator|=
name|inb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RSR
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstat
operator|&
name|D8390_RSTAT_OVER
condition|)
block|{
name|eth_reset
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|rstat
operator|&
name|D8390_RSTAT_PRX
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bound
operator|=
name|inb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_BOUND
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bound
operator|==
name|eth_memsize
condition|)
name|bound
operator|=
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS1
argument_list|)
expr_stmt|;
name|curr
operator|=
name|inb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P1_CURR
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_PS0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|eth_memsize
condition|)
name|curr
operator|=
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
expr_stmt|;
if|if
condition|(
name|curr
operator|==
name|bound
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_WD
condition|)
block|{
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
name|eth_laar
operator||
name|WD_LAAR_M16EN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
name|WD_MSR_MENB
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|pktoff
operator|=
operator|(
name|bound
operator|<<
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_PIO
condition|)
name|eth_pio_read
argument_list|(
name|pktoff
argument_list|,
operator|&
name|pkthdr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|eth_rmem
operator|+
name|pktoff
argument_list|,
operator|&
name|pkthdr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
name|pkthdr
operator|.
name|len
operator|-
literal|4
expr_stmt|;
comment|/* sub CRC */
name|pktoff
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1514
condition|)
name|len
operator|=
literal|1514
expr_stmt|;
name|bound
operator|=
name|pkthdr
operator|.
name|bound
expr_stmt|;
comment|/* New bound ptr */
if|if
condition|(
operator|(
name|pkthdr
operator|.
name|status
operator|&
name|D8390_RSTAT_PRX
operator|)
operator|&&
operator|(
name|len
operator|>
literal|14
operator|)
operator|&&
operator|(
name|len
operator|<
literal|1518
operator|)
condition|)
block|{
name|p
operator|=
name|packet
expr_stmt|;
name|packetlen
operator|=
name|len
expr_stmt|;
name|len
operator|=
operator|(
name|eth_memsize
operator|<<
literal|8
operator|)
operator|-
name|pktoff
expr_stmt|;
if|if
condition|(
name|packetlen
operator|>
name|len
condition|)
block|{
comment|/* We have a wrap-around */
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_PIO
condition|)
name|eth_pio_read
argument_list|(
name|pktoff
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|eth_rmem
operator|+
name|pktoff
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pktoff
operator|=
operator|(
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
operator|)
operator|<<
literal|8
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|packetlen
operator|-=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_PIO
condition|)
name|eth_pio_read
argument_list|(
name|pktoff
argument_list|,
name|p
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|eth_rmem
operator|+
name|pktoff
argument_list|,
name|p
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
name|type
operator|=
operator|(
name|packet
index|[
literal|12
index|]
operator|<<
literal|8
operator|)
operator||
name|packet
index|[
literal|13
index|]
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|eth_vendor
operator|==
name|VENDOR_WD
condition|)
block|{
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_790
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_MSR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|WD_LAAR
argument_list|,
name|eth_laar
operator|&
operator|~
name|WD_LAAR_M16EN
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bound
operator|==
operator|(
name|eth_tx_start
operator|+
name|D8390_TXBUF_SIZE
operator|)
condition|)
name|bound
operator|=
name|eth_memsize
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_BOUND
argument_list|,
name|bound
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
operator|(
name|type
operator|==
name|ARP
operator|)
condition|)
block|{
name|struct
name|arprequest
modifier|*
name|arpreq
decl_stmt|;
name|unsigned
name|long
name|reqip
decl_stmt|;
name|arpreq
operator|=
operator|(
expr|struct
name|arprequest
operator|*
operator|)
operator|&
name|packet
index|[
name|ETHER_HDR_SIZE
index|]
expr_stmt|;
name|convert_ipaddr
argument_list|(
operator|&
name|reqip
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|arpreq
operator|->
name|opcode
argument_list|)
operator|==
name|ARP_REQUEST
operator|)
operator|&&
operator|(
name|reqip
operator|==
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|ipaddr
operator|)
condition|)
block|{
name|arpreq
operator|->
name|opcode
operator|=
name|htons
argument_list|(
name|ARP_REPLY
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
name|arpreq
operator|->
name|tipaddr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arpreq
operator|->
name|shwaddr
argument_list|,
name|arpreq
operator|->
name|thwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|arptable
index|[
name|ARP_CLIENT
index|]
operator|.
name|node
argument_list|,
name|arpreq
operator|->
name|shwaddr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|convert_ipaddr
argument_list|(
name|arpreq
operator|->
name|sipaddr
argument_list|,
operator|&
name|reqip
argument_list|)
expr_stmt|;
name|eth_transmit
argument_list|(
name|arpreq
operator|->
name|thwaddr
argument_list|,
name|ARP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|arprequest
argument_list|)
argument_list|,
name|arpreq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|no8390
label|:
endif|#
directive|endif
comment|/* 8390 */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_NE
end_ifdef

begin_comment
comment|/************************************************************************** NE1000/NE2000 Support Routines ***************************************************************************/
end_comment

begin_comment
comment|/* inw and outw are not needed more - standard version of them is used */
end_comment

begin_comment
comment|/************************************************************************** ETH_PIO_READ - Read a frame via Programmed I/O ***************************************************************************/
end_comment

begin_macro
name|eth_pio_read
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|,
argument|cnt
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|short
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|cnt
operator|&
literal|1
condition|)
name|cnt
operator|++
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR0
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR1
argument_list|,
name|cnt
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RSAR0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RSAR1
argument_list|,
name|src
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_RD0
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
while|while
condition|(
name|cnt
condition|)
block|{
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|dst
operator|)
operator|=
name|inw
argument_list|(
name|eth_asic_base
operator|+
name|NE_DATA
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
name|cnt
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
operator|*
operator|(
name|dst
operator|++
operator|)
operator|=
name|inb
argument_list|(
name|eth_asic_base
operator|+
name|NE_DATA
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/************************************************************************** ETH_PIO_WRITE - Write a frame via Programmed I/O ***************************************************************************/
end_comment

begin_macro
name|eth_pio_write
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|,
argument|cnt
argument_list|,
argument|init
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|dst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|short
name|cnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|init
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_RD2
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_ISR
argument_list|,
name|D8390_ISR_RDC
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR0
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RBCR1
argument_list|,
name|cnt
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RSAR0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_RSAR1
argument_list|,
name|dst
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_COMMAND
argument_list|,
name|D8390_COMMAND_RD1
operator||
name|D8390_COMMAND_STA
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth_flags
operator|&
name|FLAG_16BIT
condition|)
block|{
if|if
condition|(
name|cnt
operator|&
literal|1
condition|)
name|cnt
operator|++
expr_stmt|;
comment|/* Round up */
while|while
condition|(
name|cnt
condition|)
block|{
name|outw
argument_list|(
name|eth_asic_base
operator|+
name|NE_DATA
argument_list|,
operator|*
operator|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|src
operator|)
argument_list|)
expr_stmt|;
name|src
operator|+=
literal|2
expr_stmt|;
name|cnt
operator|-=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|cnt
operator|--
condition|)
name|outb
argument_list|(
name|eth_asic_base
operator|+
name|NE_DATA
argument_list|,
operator|*
operator|(
name|src
operator|++
operator|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|inb
argument_list|(
name|eth_nic_base
operator|+
name|D8390_P0_ISR
argument_list|)
operator|&
name|D8390_ISR_RDC
operator|)
operator|!=
name|D8390_ISR_RDC
condition|)
empty_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/************************************************************************** ETH_PIO_READ - Dummy routine when NE2000 not compiled in ***************************************************************************/
end_comment

begin_macro
name|eth_pio_read
argument_list|()
end_macro

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_3C509
end_ifdef

begin_comment
comment|/************************************************************************* 	3Com 509 - specific routines **************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|eeprom_rdy
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|is_eeprom_busy
argument_list|(
name|IS_BASE
argument_list|)
operator|&&
name|i
operator|<
name|MAX_EEPROMBUSY
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
name|MAX_EEPROMBUSY
condition|)
block|{
name|printf
argument_list|(
literal|"3c509: eeprom failed to come ready.\r\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get_e: gets a 16 bits word from the EEPROM. we must have set the window  * before  */
end_comment

begin_function
specifier|static
name|int
name|get_e
parameter_list|(
name|offset
parameter_list|)
name|int
name|offset
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|eeprom_rdy
argument_list|()
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
name|outw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_EEPROM_COMMAND
argument_list|,
name|EEPROM_CMD_RD
operator||
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eeprom_rdy
argument_list|()
condition|)
return|return
operator|(
literal|0xffff
operator|)
return|;
return|return
operator|(
name|inw
argument_list|(
name|IS_BASE
operator|+
name|EP_W0_EEPROM_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_ID_sequence
parameter_list|(
name|port
parameter_list|)
name|int
name|port
decl_stmt|;
block|{
name|int
name|cx
decl_stmt|,
name|al
decl_stmt|;
for|for
control|(
name|al
operator|=
literal|0xff
operator|,
name|cx
operator|=
literal|0
init|;
name|cx
operator|<
literal|255
condition|;
name|cx
operator|++
control|)
block|{
name|outb
argument_list|(
name|port
argument_list|,
name|al
argument_list|)
expr_stmt|;
name|al
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|al
operator|&
literal|0x100
condition|)
name|al
operator|^=
literal|0xcf
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We get eeprom data from the id_port given an offset into the eeprom.  * Basically; after the ID_sequence is sent to all of the cards; they enter  * the ID_CMD state where they will accept command requests. 0x80-0xbf loads  * the eeprom data.  We then read the port 16 times and with every read; the  * cards check for contention (ie: if one card writes a 0 bit and another  * writes a 1 bit then the host sees a 0. At the end of the cycle; each card  * compares the data on the bus; if there is a difference then that card goes  * into ID_WAIT state again). In the meantime; one bit of data is returned in  * the AX register which is conveniently returned to us by inb().  Hence; we  * read 16 times getting one bit of data with each read.  */
end_comment

begin_function
specifier|static
name|int
name|get_eeprom_data
parameter_list|(
name|id_port
parameter_list|,
name|offset
parameter_list|)
name|int
name|id_port
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|data
init|=
literal|0
decl_stmt|;
name|outb
argument_list|(
name|id_port
argument_list|,
literal|0x80
operator|+
name|offset
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|data
operator|=
operator|(
name|data
operator|<<
literal|1
operator|)
operator||
operator|(
name|inw
argument_list|(
name|id_port
argument_list|)
operator|&
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/* a surrogate */
end_comment

begin_macro
name|DELAY
argument_list|(
argument|val
argument_list|)
end_macro

begin_block
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|val
condition|;
name|c
operator|+=
literal|20
control|)
block|{
name|twiddle
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

