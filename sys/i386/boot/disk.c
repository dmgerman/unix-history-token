begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1992, 1991 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie Mellon  * the rights to redistribute these changes.  *  *	from: Mach, Revision 2.2  92/04/04  11:35:49  rpd  *	$Id: disk.c,v 1.3 1993/10/16 19:11:34 rgrimes Exp $  */
end_comment

begin_include
include|#
directive|include
file|"boot.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_endif
endif|#
directive|endif
endif|DO_BAD144
end_endif

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_define
define|#
directive|define
name|BIOS_DEV_FLOPPY
value|0x0
end_define

begin_define
define|#
directive|define
name|BIOS_DEV_WIN
value|0x80
end_define

begin_define
define|#
directive|define
name|BPS
value|512
end_define

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|((((di)>>8)&0xff)+1)
end_define

begin_decl_stmt
name|char
modifier|*
name|devs
index|[]
init|=
block|{
literal|"wd"
block|,
literal|"hd"
block|,
literal|"fd"
block|,
literal|"wt"
block|,
literal|"sd"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DO_BAD144
end_ifdef

begin_decl_stmt
name|struct
name|dkbad
name|dkb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_bad144
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsize
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|DO_BAD144
end_endif

begin_decl_stmt
name|int
name|spt
decl_stmt|,
name|spc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|iodest
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inode
name|inode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dosdev
decl_stmt|,
name|unit
decl_stmt|,
name|part
decl_stmt|,
name|maj
decl_stmt|,
name|boff
decl_stmt|,
name|poff
decl_stmt|,
name|bnum
decl_stmt|,
name|cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*#define EMBEDDED_DISKLABEL 1*/
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|disklabel
name|disklabel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*struct	disklabel disklabel;*/
end_comment

begin_macro
name|devopen
argument_list|()
end_macro

begin_block
block|{
name|struct
name|dos_partition
modifier|*
name|dptr
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
name|int
name|dosdev
init|=
name|inode
operator|.
name|i_dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sector
decl_stmt|,
name|di
decl_stmt|;
name|di
operator|=
name|get_diskinfo
argument_list|(
name|dosdev
argument_list|)
expr_stmt|;
name|spc
operator|=
operator|(
name|spt
operator|=
name|SPT
argument_list|(
name|di
argument_list|)
operator|)
operator|*
name|HEADS
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosdev
operator|==
literal|2
condition|)
block|{
name|boff
operator|=
literal|0
expr_stmt|;
name|part
operator|=
operator|(
name|spt
operator|==
literal|15
condition|?
literal|3
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|EMBEDDED_DISKLABEL
name|dl
operator|=
operator|&
name|disklabel
expr_stmt|;
else|#
directive|else
else|EMBEDDED_DISKLABEL
name|Bread
argument_list|(
name|dosdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dptr
operator|=
operator|(
expr|struct
name|dos_partition
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
operator|+
name|DOSPARTOFF
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDOSPART
condition|;
name|i
operator|++
operator|,
name|dptr
operator|++
control|)
if|if
condition|(
name|dptr
operator|->
name|dp_typ
operator|==
name|DOSPTYP_386BSD
condition|)
break|break;
name|sector
operator|=
name|dptr
operator|->
name|dp_start
operator|+
name|LABELSECTOR
expr_stmt|;
name|Bread
argument_list|(
name|dosdev
argument_list|,
name|sector
operator|++
argument_list|)
expr_stmt|;
name|dl
operator|=
operator|(
operator|(
expr|struct
name|disklabel
operator|*
operator|)
literal|0
operator|)
expr_stmt|;
name|disklabel
operator|=
operator|*
name|dl
expr_stmt|;
comment|/* structure copy (maybe useful later)*/
endif|#
directive|endif
endif|EMBEDDED_DISKLABEL
if|if
condition|(
name|dl
operator|->
name|d_magic
operator|!=
name|DISKMAGIC
condition|)
block|{
name|printf
argument_list|(
literal|"bad disklabel"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|maj
operator|==
literal|4
operator|)
operator|||
operator|(
name|maj
operator|==
literal|0
operator|)
operator|||
operator|(
name|maj
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dl
operator|->
name|d_type
operator|==
name|DTYPE_SCSI
condition|)
block|{
name|maj
operator|=
literal|4
expr_stmt|;
comment|/* use scsi as boot dev */
block|}
else|else
block|{
name|maj
operator|=
literal|0
expr_stmt|;
comment|/* must be ESDI/IDE */
block|}
block|}
name|boff
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|DO_BAD144
name|bsize
operator|=
name|dl
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|do_bad144
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|d_flags
operator|&
name|D_BADSECT
condition|)
block|{
comment|/* this disk uses bad144 */
name|int
name|i
decl_stmt|;
name|int
name|dkbbnum
decl_stmt|;
name|struct
name|dkbad
modifier|*
name|dkbptr
decl_stmt|;
comment|/* find the first readable bad144 sector */
comment|/* some of this code is copied from ufs/disk_subr.c */
comment|/* read a bad sector table */
name|dkbbnum
operator|=
name|dl
operator|->
name|d_secperunit
operator|-
name|dl
operator|->
name|d_nsectors
expr_stmt|;
if|if
condition|(
name|dl
operator|->
name|d_secsize
operator|>
name|DEV_BSIZE
condition|)
name|dkbbnum
operator|*=
name|dl
operator|->
name|d_secsize
operator|/
name|DEV_BSIZE
expr_stmt|;
else|else
name|dkbbnum
operator|/=
name|DEV_BSIZE
operator|/
name|dl
operator|->
name|d_secsize
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|do_bad144
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* XXX: what if the "DOS sector"< 512 bytes ??? */
name|Bread
argument_list|(
name|dosdev
argument_list|,
name|dkbbnum
operator|+
name|i
argument_list|)
expr_stmt|;
name|dkbptr
operator|=
operator|(
expr|struct
name|dkbad
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* XXX why is this not in<sys/dkbad.h> ??? */
define|#
directive|define
name|DKBAD_MAGIC
value|0x4321
if|if
condition|(
name|dkbptr
operator|->
name|bt_mbz
operator|==
literal|0
operator|&&
name|dkbptr
operator|->
name|bt_flag
operator|==
name|DKBAD_MAGIC
condition|)
block|{
name|dkb
operator|=
operator|*
name|dkbptr
expr_stmt|;
comment|/* structure copy */
name|do_bad144
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|i
operator|+=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
literal|10
operator|&&
name|i
operator|<
name|dl
operator|->
name|d_nsectors
condition|)
do|;
if|if
condition|(
operator|!
name|do_bad144
condition|)
name|printf
argument_list|(
literal|"Bad badsect table\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Using bad144 bad sector at %d\n"
argument_list|,
name|dkbbnum
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DO_BAD144
block|}
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|devread
argument_list|()
end_macro

begin_block
block|{
name|int
name|offset
decl_stmt|,
name|sector
init|=
name|bnum
decl_stmt|;
name|int
name|dosdev
init|=
name|inode
operator|.
name|i_dev
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|cnt
condition|;
name|offset
operator|+=
name|BPS
control|)
block|{
name|Bread
argument_list|(
name|dosdev
argument_list|,
name|badsect
argument_list|(
name|dosdev
argument_list|,
name|sector
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
literal|0
argument_list|,
name|iodest
operator|+
name|offset
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|I_ADDR
value|((void *) 0)
end_define

begin_comment
comment|/* XXX where all reads go */
end_comment

begin_comment
comment|/* Read ahead buffer large enough for one track on a 1440K floppy.  For  * reading from floppies, the bootstrap has to be loaded on a 64K boundary  * to ensure that this buffer doesn't cross a 64K DMA boundary.  */
end_comment

begin_define
define|#
directive|define
name|RA_SECTORS
value|18
end_define

begin_decl_stmt
specifier|static
name|char
name|ra_buf
index|[
name|RA_SECTORS
operator|*
name|BPS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_first
decl_stmt|;
end_decl_stmt

begin_macro
name|Bread
argument_list|(
argument|dosdev
argument_list|,
argument|sector
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dosdev
decl_stmt|,
name|sector
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|dosdev
operator|!=
name|ra_dev
operator|||
name|sector
operator|<
name|ra_first
operator|||
name|sector
operator|>=
name|ra_end
condition|)
block|{
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|cyl
operator|=
name|sector
operator|/
name|spc
expr_stmt|;
name|head
operator|=
operator|(
name|sector
operator|%
name|spc
operator|)
operator|/
name|spt
expr_stmt|;
name|sec
operator|=
name|sector
operator|%
name|spt
expr_stmt|;
name|nsec
operator|=
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|RA_SECTORS
condition|)
name|nsec
operator|=
name|RA_SECTORS
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
if|if
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nsec
operator|=
literal|1
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
while|while
condition|(
name|biosread
argument_list|(
name|dosdev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|ra_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error: C:%d H:%d S:%d\n"
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|twiddle
argument_list|()
expr_stmt|;
block|}
block|}
name|ra_dev
operator|=
name|dosdev
expr_stmt|;
name|ra_first
operator|=
name|sector
expr_stmt|;
name|ra_end
operator|=
name|sector
operator|+
name|nsec
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|ra_buf
operator|+
operator|(
name|sector
operator|-
name|ra_first
operator|)
operator|*
name|BPS
argument_list|,
name|I_ADDR
argument_list|,
name|BPS
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|badsect
argument_list|(
argument|dosdev
argument_list|,
argument|sector
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dosdev
decl_stmt|,
name|sector
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DO_BAD144
if|if
condition|(
name|do_bad144
condition|)
block|{
name|u_short
name|cyl
decl_stmt|;
name|u_short
name|head
decl_stmt|;
name|u_short
name|sec
decl_stmt|;
name|int
name|newsec
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
init|=
operator|&
name|disklabel
decl_stmt|;
comment|/* XXX */
comment|/* from wd.c */
comment|/* bt_cyl = cylinder number in sorted order */
comment|/* bt_trksec is actually (head<< 8) + sec */
comment|/* only remap sectors in the partition */
if|if
condition|(
name|sector
operator|<
name|boff
operator|||
name|sector
operator|>=
name|boff
operator|+
name|bsize
condition|)
block|{
goto|goto
name|no_remap
goto|;
block|}
name|cyl
operator|=
name|sector
operator|/
name|dl
operator|->
name|d_secpercyl
expr_stmt|;
name|head
operator|=
operator|(
name|sector
operator|%
name|dl
operator|->
name|d_secpercyl
operator|)
operator|/
name|dl
operator|->
name|d_nsectors
expr_stmt|;
name|sec
operator|=
name|sector
operator|%
name|dl
operator|->
name|d_nsectors
expr_stmt|;
name|sec
operator|=
operator|(
name|head
operator|<<
literal|8
operator|)
operator|+
name|sec
expr_stmt|;
comment|/* now, look in the table for a possible bad sector */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|126
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|==
name|cyl
condition|)
block|{
comment|/* found same cylinder */
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_trksec
operator|==
name|sec
condition|)
block|{
comment|/* FOUND! */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|dkb
operator|.
name|bt_bad
index|[
name|i
index|]
operator|.
name|bt_cyl
operator|>
name|cyl
condition|)
block|{
name|i
operator|=
literal|126
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|126
condition|)
block|{
comment|/* didn't find bad sector */
goto|goto
name|no_remap
goto|;
block|}
comment|/* otherwise find replacement sector */
name|newsec
operator|=
name|dl
operator|->
name|d_secperunit
operator|-
name|dl
operator|->
name|d_nsectors
operator|-
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|newsec
return|;
block|}
endif|#
directive|endif
endif|DO_BAD144
name|no_remap
label|:
return|return
name|sector
return|;
block|}
end_block

end_unit

