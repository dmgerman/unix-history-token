begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * APM (Advanced Power Management) BIOS Device Driver  *  * Copyright (c) 1994 UKAI, Fumitoshi.  * Copyright (c) 1994-1995 by HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  * Copyright (c) 1996 Nate Williams<nate@FreeBSD.org>  * Copyright (c) 1997 Poul-Henning Kamp<phk@FreeBSD.org>  *  * This software may be used, modified, copied, and distributed, in  * both source and binary form provided that the above copyright and  * these terms are retained. Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with its  * use.  *  * Sep, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)  *  *	$Id: apm.c,v 1.65 1997/11/12 04:12:43 jdp Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<i386/apm/apm_setup.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|apm_display
name|__P
argument_list|(
operator|(
name|int
name|newstate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apm_int
name|__P
argument_list|(
operator|(
name|u_long
operator|*
name|eax
operator|,
name|u_long
operator|*
name|ebx
operator|,
name|u_long
operator|*
name|ecx
operator|,
name|u_long
operator|*
name|edx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|apm_resume
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static data */
end_comment

begin_struct
struct|struct
name|apm_softc
block|{
name|int
name|initialized
decl_stmt|,
name|active
decl_stmt|;
name|int
name|always_halt_cpu
decl_stmt|,
name|slow_idle_cpu
decl_stmt|;
name|int
name|disabled
decl_stmt|,
name|disengaged
decl_stmt|;
name|u_int
name|minorversion
decl_stmt|,
name|majorversion
decl_stmt|;
name|u_int
name|cs32_base
decl_stmt|,
name|cs16_base
decl_stmt|,
name|ds_base
decl_stmt|;
name|u_int
name|cs_limit
decl_stmt|,
name|ds_limit
decl_stmt|;
name|u_int
name|cs_entry
decl_stmt|;
name|u_int
name|intversion
decl_stmt|;
name|struct
name|apmhook
name|sc_suspend
decl_stmt|;
name|struct
name|apmhook
name|sc_resume
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|sc_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|apm_softc
name|apm_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|apmhook
modifier|*
name|hook
index|[
name|NAPM_HOOK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|is_enabled
parameter_list|(
name|foo
parameter_list|)
value|((foo) ? "enabled" : "disabled")
end_define

begin_comment
comment|/* Map version number to integer (keeps ordering of version numbers) */
end_comment

begin_define
define|#
directive|define
name|INTVERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major)*100 + (minor))
end_define

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|apm_timeout_ch
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|apm_timeout_ch
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|apm_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|apmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|apmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|apmioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|39
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|apm_cdevsw
init|=
block|{
name|apmopen
block|,
name|apmclose
block|,
name|noread
block|,
name|nowrite
block|,
comment|/*39*/
name|apmioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* APM */
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"apm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setup APM GDT discriptors */
end_comment

begin_function
specifier|static
name|void
name|setup_apm_gdt
parameter_list|(
name|u_int
name|code32_base
parameter_list|,
name|u_int
name|code16_base
parameter_list|,
name|u_int
name|data_base
parameter_list|,
name|u_int
name|code_limit
parameter_list|,
name|u_int
name|data_limit
parameter_list|)
block|{
comment|/* setup 32bit code segment */
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code32_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup 16bit code segment */
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code16_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code_limit
expr_stmt|;
comment|/* setup data segment */
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_base
operator|=
name|data_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|data_limit
expr_stmt|;
comment|/* reflect these changes on physical GDT */
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE32_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE16_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMDATA_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* 48bit far pointer */
end_comment

begin_struct
struct|struct
name|addr48
block|{
name|u_long
name|offset
decl_stmt|;
name|u_short
name|segment
decl_stmt|;
block|}
name|apm_addr
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|apm_errno
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_int
parameter_list|(
name|u_long
modifier|*
name|eax
parameter_list|,
name|u_long
modifier|*
name|ebx
parameter_list|,
name|u_long
modifier|*
name|ecx
parameter_list|,
name|u_long
modifier|*
name|edx
parameter_list|)
block|{
name|struct
name|apm_bios_arg
name|apa
decl_stmt|;
name|int
name|cf
decl_stmt|;
name|apa
operator|.
name|eax
operator|=
operator|*
name|eax
expr_stmt|;
name|apa
operator|.
name|ebx
operator|=
operator|*
name|ebx
expr_stmt|;
name|apa
operator|.
name|ecx
operator|=
operator|*
name|ecx
expr_stmt|;
name|apa
operator|.
name|edx
operator|=
operator|*
name|edx
expr_stmt|;
name|cf
operator|=
name|apm_bios_call
argument_list|(
operator|&
name|apa
argument_list|)
expr_stmt|;
operator|*
name|eax
operator|=
name|apa
operator|.
name|eax
expr_stmt|;
operator|*
name|ebx
operator|=
name|apa
operator|.
name|ebx
expr_stmt|;
operator|*
name|ecx
operator|=
name|apa
operator|.
name|ecx
expr_stmt|;
operator|*
name|edx
operator|=
name|apa
operator|.
name|edx
expr_stmt|;
name|apm_errno
operator|=
operator|(
operator|(
operator|*
name|eax
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
name|cf
return|;
block|}
end_function

begin_comment
comment|/* enable/disable power management */
end_comment

begin_function
specifier|static
name|int
name|apm_enable_disable_pm
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENABLEDISABLEPM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
else|else
name|ebx
operator|=
literal|0xffff
expr_stmt|;
comment|/* APM version 1.0 only */
name|ecx
operator|=
name|enable
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
return|return
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_driver_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
comment|/* First try APM 1.2 */
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_DRVVERSION
expr_stmt|;
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|ecx
operator|=
name|version
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
name|apm_version
operator|=
name|eax
operator|&
literal|0xffff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* engage/disengage power management (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_engage_disengage_pm
parameter_list|(
name|int
name|engage
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENGAGEDISENGAGEPM
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|engage
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get PM event */
end_comment

begin_function
specifier|static
name|u_int
name|apm_getevent
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPMEVENT
expr_stmt|;
name|ebx
operator|=
literal|0
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
return|return
name|PMEV_NOEVENT
return|;
return|return
name|ebx
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* suspend entire system */
end_comment

begin_function
specifier|static
name|int
name|apm_suspend_system
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_SUSPEND
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Entire system suspend failure: errcode = %ld\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display control */
end_comment

begin_comment
comment|/*  * Experimental implementation: My laptop machine can't handle this function  * If your laptop can control the display via APM, please inform me.  *                            HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  */
end_comment

begin_function
specifier|static
name|int
name|apm_display
parameter_list|(
name|int
name|newstate
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_DISP0
expr_stmt|;
name|ecx
operator|=
name|newstate
condition|?
name|PMST_APMENABLED
else|:
name|PMST_SUSPEND
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Display off failure: errcode = %ld\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Turn off the entire system.  */
end_comment

begin_function
name|void
name|apm_power_off
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
if|if
condition|(
operator|!
name|apm_softc
operator|.
name|active
condition|)
return|return;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_OFF
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM Battery low handler */
end_comment

begin_function
specifier|static
name|void
name|apm_battery_low
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\007\007 * * * BATTERY IS LOW * * * \007\007"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM hook manager */
end_comment

begin_function
specifier|static
name|struct
name|apmhook
modifier|*
name|apm_add_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Add hook \"%s\"\n"
argument_list|,
name|ah
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"illegal apm_hook!"
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|->
name|ah_order
operator|>
name|ah
operator|->
name|ah_order
condition|)
break|break;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|ah
operator|->
name|ah_next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|ah
expr_stmt|;
block|}
else|else
block|{
name|ah
operator|->
name|ah_next
operator|=
name|prev
operator|->
name|ah_next
expr_stmt|;
name|prev
operator|->
name|ah_next
operator|=
name|ah
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_del_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|==
name|ah
condition|)
goto|goto
name|deleteit
goto|;
name|panic
argument_list|(
literal|"Tried to delete unregistered apm_hook."
argument_list|)
expr_stmt|;
goto|goto
name|nosuchnode
goto|;
name|deleteit
label|:
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|ah_next
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
name|nosuchnode
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM driver calls some functions automatically */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Execute APM hook \"%s.\"\n"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|ah_fun
operator|)
operator|)
operator|(
name|p
operator|->
name|ah_arg
operator|)
condition|)
name|printf
argument_list|(
literal|"Warning: APM hook \"%s\" failed"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* establish an apm hook */
end_comment

begin_function
name|struct
name|apmhook
modifier|*
name|apm_hook_establish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return
name|NULL
return|;
return|return
name|apm_add_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* disestablish an apm hook */
end_comment

begin_function
name|void
name|apm_hook_disestablish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return;
name|apm_del_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|suspend_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|diff_time
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_default_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|u_int
name|second
decl_stmt|,
name|minute
decl_stmt|,
name|hour
decl_stmt|;
name|struct
name|timeval
name|resume_time
decl_stmt|,
name|tmp_time
decl_stmt|;
comment|/* modified for adjkerntz */
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
name|microtime
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
name|tmp_time
operator|=
name|time
expr_stmt|;
comment|/* because 'time' is volatile */
name|timevaladd
argument_list|(
operator|&
name|tmp_time
argument_list|,
operator|&
name|diff_time
argument_list|)
expr_stmt|;
name|time
operator|=
name|tmp_time
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
operator|-
name|suspend_time
operator|.
name|tv_sec
expr_stmt|;
name|hour
operator|=
name|second
operator|/
literal|3600
expr_stmt|;
name|second
operator|%=
literal|3600
expr_stmt|;
name|minute
operator|=
name|second
operator|/
literal|60
expr_stmt|;
name|second
operator|%=
literal|60
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resumed from suspended mode (slept %02d:%02d:%02d)\n"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_default_suspend
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|diff_time
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff_time
argument_list|,
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Public interface to the suspend/resume:  *  * Execute suspend and resume hook before and after sleep, respectively.  *  */
end_comment

begin_function
name|void
name|apm_suspend
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_SUSPEND
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_suspend_system
argument_list|()
operator|==
literal|0
condition|)
name|apm_processevent
argument_list|()
expr_stmt|;
else|else
comment|/* Failure, 'resume' the system again */
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|apm_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get APM information */
end_comment

begin_function
specifier|static
name|int
name|apm_get_info
parameter_list|(
name|apm_info_t
name|aip
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPWSTATUS
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
name|edx
operator|=
literal|0xffff
expr_stmt|;
comment|/* default to unknown battery time */
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
return|return
literal|1
return|;
name|aip
operator|->
name|ai_infoversion
operator|=
literal|0
expr_stmt|;
name|aip
operator|->
name|ai_acline
operator|=
operator|(
name|ebx
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_stat
operator|=
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_life
operator|=
name|ecx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_major
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|majorversion
expr_stmt|;
name|aip
operator|->
name|ai_minor
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|minorversion
expr_stmt|;
name|aip
operator|->
name|ai_status
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|active
expr_stmt|;
name|edx
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|edx
operator|==
literal|0xffff
condition|)
comment|/* Time is unknown */
name|aip
operator|->
name|ai_batt_time
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|edx
operator|&
literal|0x8000
condition|)
comment|/* Time is in minutes */
name|aip
operator|->
name|ai_batt_time
operator|=
operator|(
name|edx
operator|&
literal|0x7fff
operator|)
operator|*
literal|60
expr_stmt|;
else|else
comment|/* Time is in seconds */
name|aip
operator|->
name|ai_batt_time
operator|=
name|edx
expr_stmt|;
name|bzero
argument_list|(
name|aip
operator|->
name|ai_spare
argument_list|,
sizeof|sizeof
name|aip
operator|->
name|ai_spare
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is idle */
end_comment

begin_function
name|void
name|apm_cpu_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUIDLE
expr_stmt|;
name|edx
operator|=
name|ecx
operator|=
name|ebx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some APM implementation halts CPU in BIOS, whenever 	 * "CPU-idle" function are invoked, but swtch() of 	 * FreeBSD halts CPU, therefore, CPU is halted twice 	 * in the sched loop. It makes the interrupt latency 	 * terribly long and be able to cause a serious problem 	 * in interrupt processing. We prevent it by removing 	 * "hlt" operation from swtch() and managed it under 	 * APM driver. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|active
operator|||
name|sc
operator|->
name|always_halt_cpu
condition|)
asm|__asm("hlt");
comment|/* wait for interrupt */
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is busy */
end_comment

begin_function
name|void
name|apm_cpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
comment|/* 	 * The APM specification says this is only necessary if your BIOS 	 * slows down the processor in the idle task, otherwise it's not 	 * necessary. 	 */
if|if
condition|(
name|sc
operator|->
name|slow_idle_cpu
operator|&&
name|sc
operator|->
name|active
condition|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUBUSY
expr_stmt|;
name|edx
operator|=
name|ecx
operator|=
name|ebx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * APM timeout routine:  *  * This routine is automatically called by timer once per second.  */
end_comment

begin_function
specifier|static
name|void
name|apm_timeout
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|apm_processevent
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
operator|==
literal|1
condition|)
comment|/* Run slightly more oftan than 1 Hz */
name|apm_timeout_ch
operator|=
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* enable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_enable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|apm_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* disable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_disable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|untimeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|apm_timeout_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* don't halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_not_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* device driver definitions */
end_comment

begin_function_decl
specifier|static
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|isa_driver
name|apmdriver
init|=
block|{
name|apmprobe
block|,
name|apmattach
block|,
literal|"apm"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * probe APM (dummy):  *  * APM probing routine is placed on locore.s and apm_init.S because  * this process forces the CPU to turn to real mode or V86 mode.  * Current version uses real mode, but in a future version, we want  * to use V86 mode in APM initialization.  */
end_comment

begin_function
specifier|static
name|int
name|apmprobe
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|apm_softc
argument_list|,
sizeof|sizeof
argument_list|(
name|apm_softc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|id_unit
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"apm: Only one APM driver supported.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|apm_version
condition|)
block|{
case|case
name|APMINI_CANTFIND
case|:
comment|/* silent */
return|return
literal|0
return|;
case|case
name|APMINI_NOT32BIT
case|:
name|printf
argument_list|(
literal|"apm: 32bit connection is not supported.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|APMINI_CONNECTERR
case|:
name|printf
argument_list|(
literal|"apm: 32-bit connection error.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x20
condition|)
name|statclock_disable
operator|=
literal|1
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Process APM event */
end_comment

begin_function
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|apm_event
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: \ 	printf("Received APM Event: " #symbol "\n");
else|#
directive|else
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol:
endif|#
directive|endif
do|do
block|{
name|apm_event
operator|=
name|apm_getevent
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|apm_event
condition|)
block|{
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYREQ
argument_list|)
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_SUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITSUSPEND
argument_list|)
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NORMRESUME
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITRESUME
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYRESUME
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_BATTERYLOW
argument_list|)
expr_stmt|;
name|apm_battery_low
argument_list|()
expr_stmt|;
name|apm_suspend
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_POWERSTATECHANGE
argument_list|)
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_UPDATETIME
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
break|break;
case|case
name|PMEV_NOEVENT
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown Original APM Event 0x%x\n"
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|apm_event
operator|!=
name|PMEV_NOEVENT
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Attach APM:  *  * Initialize APM driver (APM BIOS itself has been initialized in locore.s)  */
end_comment

begin_function
specifier|static
name|int
name|apmattach
parameter_list|(
name|struct
name|isa_device
modifier|*
name|dvp
parameter_list|)
block|{
define|#
directive|define
name|APM_KERNBASE
value|KERNBASE
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
comment|/* Must be externally enabled */
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
comment|/* setup APM parameters */
name|sc
operator|->
name|cs16_base
operator|=
operator|(
name|apm_cs16_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|cs32_base
operator|=
operator|(
name|apm_cs32_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|ds_base
operator|=
operator|(
name|apm_ds_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|cs_limit
operator|=
name|apm_cs_limit
expr_stmt|;
name|sc
operator|->
name|ds_limit
operator|=
name|apm_ds_limit
expr_stmt|;
name|sc
operator|->
name|cs_entry
operator|=
name|apm_cs_entry
expr_stmt|;
comment|/* Always call HLT in idle loop */
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|slow_idle_cpu
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_CPUIDLE_SLOW
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disabled
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISABLED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disengaged
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISENGAGED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* print bootstrap messages */
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: APM BIOS version %04x\n"
argument_list|,
name|apm_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code32 0x%08x, Code16 0x%08x, Data 0x%08x\n"
argument_list|,
name|sc
operator|->
name|cs32_base
argument_list|,
name|sc
operator|->
name|cs16_base
argument_list|,
name|sc
operator|->
name|ds_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code entry 0x%08x, Idling CPU %s, Management %s\n"
argument_list|,
name|sc
operator|->
name|cs_entry
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disabled
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: CS_limit=0x%x, DS_limit=0x%x\n"
argument_list|,
name|sc
operator|->
name|cs_limit
argument_list|,
name|sc
operator|->
name|ds_limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_DEBUG */
if|#
directive|if
literal|0
comment|/* Workaround for some buggy APM BIOS implementations */
block|sc->cs_limit = 0xffff; 	sc->ds_limit = 0xffff;
endif|#
directive|endif
comment|/* setup GDT */
name|setup_apm_gdt
argument_list|(
name|sc
operator|->
name|cs32_base
argument_list|,
name|sc
operator|->
name|cs16_base
argument_list|,
name|sc
operator|->
name|ds_base
argument_list|,
name|sc
operator|->
name|cs_limit
argument_list|,
name|sc
operator|->
name|ds_limit
argument_list|)
expr_stmt|;
comment|/* setup entry point 48bit pointer */
name|apm_addr
operator|.
name|segment
operator|=
name|GSEL
argument_list|(
name|GAPMCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|apm_addr
operator|.
name|offset
operator|=
name|sc
operator|->
name|cs_entry
expr_stmt|;
if|if
condition|(
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0x10
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0xf
operator|)
operator|>=
literal|0x2
condition|)
block|{
name|apm_driver_version
argument_list|(
literal|0x102
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apm_version
operator|&&
operator|(
name|dvp
operator|->
name|id_flags
operator|&
literal|0xf
operator|)
operator|>=
literal|0x1
condition|)
block|{
name|apm_driver_version
argument_list|(
literal|0x101
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|apm_driver_version
argument_list|(
literal|0x102
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apm_version
condition|)
name|apm_driver_version
argument_list|(
literal|0x101
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apm_version
condition|)
name|apm_version
operator|=
literal|0x100
expr_stmt|;
name|sc
operator|->
name|minorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|majorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|intversion
operator|=
name|INTVERSION
argument_list|(
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"apm: Engaged control %s\n"
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disengaged
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"apm: found APM BIOS version %d.%d\n"
argument_list|,
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: Slow Idling CPU %s\n"
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enable power management */
if|if
condition|(
name|sc
operator|->
name|disabled
condition|)
block|{
if|if
condition|(
name|apm_enable_disable_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* enable function failed! [%x]\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* engage power managment (APM 1.1 or later) */
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|sc
operator|->
name|disengaged
condition|)
block|{
if|if
condition|(
name|apm_engage_disengage_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* engage function failed err=[%x]"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (Docked or using external power?).\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* default suspend hook */
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_fun
operator|=
name|apm_default_suspend
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_name
operator|=
literal|"default suspend"
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_order
operator|=
name|APM_MAX_ORDER
expr_stmt|;
comment|/* default resume hook */
name|sc
operator|->
name|sc_resume
operator|.
name|ah_fun
operator|=
name|apm_default_resume
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_name
operator|=
literal|"default resume"
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|sc_suspend
argument_list|)
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|sc_resume
argument_list|)
expr_stmt|;
name|apm_event_enable
argument_list|()
expr_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|sc_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|apm_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"apm"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|newstate
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"APM ioctl: cmd = 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_SUSPEND
case|:
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|apm_suspend
argument_list|()
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|APMIO_GETINFO_OLD
case|:
block|{
name|struct
name|apm_info
name|info
decl_stmt|;
name|apm_info_old_t
name|aiop
decl_stmt|;
if|if
condition|(
name|apm_get_info
argument_list|(
operator|&
name|info
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|aiop
operator|=
operator|(
name|apm_info_old_t
operator|)
name|addr
expr_stmt|;
name|aiop
operator|->
name|ai_major
operator|=
name|info
operator|.
name|ai_major
expr_stmt|;
name|aiop
operator|->
name|ai_minor
operator|=
name|info
operator|.
name|ai_minor
expr_stmt|;
name|aiop
operator|->
name|ai_acline
operator|=
name|info
operator|.
name|ai_acline
expr_stmt|;
name|aiop
operator|->
name|ai_batt_stat
operator|=
name|info
operator|.
name|ai_batt_stat
expr_stmt|;
name|aiop
operator|->
name|ai_batt_life
operator|=
name|info
operator|.
name|ai_batt_life
expr_stmt|;
name|aiop
operator|->
name|ai_status
operator|=
name|info
operator|.
name|ai_status
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_GETINFO
case|:
if|if
condition|(
name|apm_get_info
argument_list|(
operator|(
name|apm_info_t
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_ENABLE
case|:
name|apm_event_enable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISABLE
case|:
name|apm_event_disable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_HALTCPU
case|:
name|apm_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_NOTHALTCPU
case|:
name|apm_not_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISPLAY
case|:
name|newstate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|apm_display
argument_list|(
name|newstate
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_BIOS
case|:
if|if
condition|(
name|apm_bios_call
argument_list|(
operator|(
expr|struct
name|apm_bios_arg
operator|*
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|apm_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|apm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|apm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|apm_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|apm_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|apm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

