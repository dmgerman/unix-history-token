begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * APM (Advanced Power Management) BIOS Device Driver  *  * Copyright (c) 1994 UKAI, Fumitoshi.  * Copyright (c) 1994-1995 by HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  * Copyright (c) 1996 Nate Williams<nate@FreeBSD.org>  * Copyright (c) 1997 Poul-Henning Kamp<phk@FreeBSD.org>  *  * This software may be used, modified, copied, and distributed, in  * both source and binary form provided that the above copyright and  * these terms are retained. Under no circumstances is the author  * responsible for the proper functioning of this software, nor does  * the author assume any responsibility for damages incurred with its  * use.  *  * Sep, 1994	Implemented on FreeBSD 1.1.5.1R (Toshiba AVS001WD)  *  *	$Id: apm.c,v 1.91 1999/07/22 14:45:22 iwasaki Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/apm_bios.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<i386/apm/apm_setup.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|apm_display
name|__P
argument_list|(
operator|(
name|int
name|newstate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|apm_int
name|__P
argument_list|(
operator|(
name|u_long
operator|*
name|eax
operator|,
name|u_long
operator|*
name|ebx
operator|,
name|u_long
operator|*
name|ecx
operator|,
name|u_long
operator|*
name|edx
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|apm_resume
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|APM_NEVENTS
value|16
end_define

begin_define
define|#
directive|define
name|APM_NPMEV
value|13
end_define

begin_decl_stmt
name|int
name|apm_evindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static data */
end_comment

begin_struct
struct|struct
name|apm_softc
block|{
name|int
name|initialized
decl_stmt|,
name|active
decl_stmt|;
name|int
name|always_halt_cpu
decl_stmt|,
name|slow_idle_cpu
decl_stmt|;
name|int
name|disabled
decl_stmt|,
name|disengaged
decl_stmt|;
name|u_int
name|minorversion
decl_stmt|,
name|majorversion
decl_stmt|;
name|u_int
name|cs32_base
decl_stmt|,
name|cs16_base
decl_stmt|,
name|ds_base
decl_stmt|;
name|u_int
name|cs16_limit
decl_stmt|,
name|cs32_limit
decl_stmt|,
name|ds_limit
decl_stmt|;
name|u_int
name|cs_entry
decl_stmt|;
name|u_int
name|intversion
decl_stmt|;
name|struct
name|apmhook
name|sc_suspend
decl_stmt|;
name|struct
name|apmhook
name|sc_resume
decl_stmt|;
name|struct
name|selinfo
name|sc_rsel
decl_stmt|;
name|int
name|sc_flags
decl_stmt|;
name|int
name|event_count
decl_stmt|;
name|int
name|event_ptr
decl_stmt|;
name|struct
name|apm_event_info
name|event_list
index|[
name|APM_NEVENTS
index|]
decl_stmt|;
name|u_char
name|event_filter
index|[
name|APM_NPMEV
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|sc_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SCFLAG_ONORMAL
value|0x0000001
end_define

begin_define
define|#
directive|define
name|SCFLAG_OCTL
value|0x0000002
end_define

begin_define
define|#
directive|define
name|SCFLAG_OPEN
value|(SCFLAG_ONORMAL|SCFLAG_OCTL)
end_define

begin_define
define|#
directive|define
name|APMDEV
parameter_list|(
name|dev
parameter_list|)
value|(minor(dev)&0x0f)
end_define

begin_define
define|#
directive|define
name|APMDEV_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|APMDEV_CTL
value|8
end_define

begin_decl_stmt
specifier|static
name|struct
name|apm_softc
name|apm_softc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|apmhook
modifier|*
name|hook
index|[
name|NAPM_HOOK
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|is_enabled
parameter_list|(
name|foo
parameter_list|)
value|((foo) ? "enabled" : "disabled")
end_define

begin_comment
comment|/* Map version number to integer (keeps ordering of version numbers) */
end_comment

begin_define
define|#
directive|define
name|INTVERSION
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
value|((major)*100 + (minor))
end_define

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|apm_timeout_ch
init|=
name|CALLOUT_HANDLE_INITIALIZER
argument_list|(
operator|&
name|apm_timeout_ch
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|apm_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|apmopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|apmclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|apmwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|apmioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|apmpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|39
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|apm_cdevsw
init|=
block|{
comment|/* open */
name|apmopen
block|,
comment|/* close */
name|apmclose
block|,
comment|/* read */
name|noread
block|,
comment|/* write */
name|apmwrite
block|,
comment|/* ioctl */
name|apmioctl
block|,
comment|/* stop */
name|nostop
block|,
comment|/* reset */
name|noreset
block|,
comment|/* devtotty */
name|nodevtotty
block|,
comment|/* poll */
name|apmpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"apm"
block|,
comment|/* parms */
name|noparms
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* maxio */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* setup APM GDT discriptors */
end_comment

begin_function
specifier|static
name|void
name|setup_apm_gdt
parameter_list|(
name|u_int
name|code32_base
parameter_list|,
name|u_int
name|code16_base
parameter_list|,
name|u_int
name|data_base
parameter_list|,
name|u_int
name|code32_limit
parameter_list|,
name|u_int
name|code16_limit
parameter_list|,
name|u_int
name|data_limit
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|x
decl_stmt|;
endif|#
directive|endif
comment|/* setup 32bit code segment */
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code32_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code32_limit
expr_stmt|;
comment|/* setup 16bit code segment */
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_base
operator|=
name|code16_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|code16_limit
expr_stmt|;
comment|/* setup data segment */
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_base
operator|=
name|data_base
expr_stmt|;
name|gdt_segs
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|ssd_limit
operator|=
name|data_limit
expr_stmt|;
comment|/* reflect these changes on physical GDT */
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE32_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMCODE16_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
name|ssdtosd
argument_list|(
name|gdt_segs
operator|+
name|GAPMDATA_SEL
argument_list|,
operator|&
name|gdt
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<
name|NCPU
condition|;
name|x
operator|++
control|)
block|{
name|gdt
index|[
name|x
operator|*
name|NGDT
operator|+
name|GAPMCODE32_SEL
index|]
operator|.
name|sd
operator|=
name|gdt
index|[
name|GAPMCODE32_SEL
index|]
operator|.
name|sd
expr_stmt|;
name|gdt
index|[
name|x
operator|*
name|NGDT
operator|+
name|GAPMCODE16_SEL
index|]
operator|.
name|sd
operator|=
name|gdt
index|[
name|GAPMCODE16_SEL
index|]
operator|.
name|sd
expr_stmt|;
name|gdt
index|[
name|x
operator|*
name|NGDT
operator|+
name|GAPMDATA_SEL
index|]
operator|.
name|sd
operator|=
name|gdt
index|[
name|GAPMDATA_SEL
index|]
operator|.
name|sd
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* 48bit far pointer. Do not staticize - used from apm_setup.s */
end_comment

begin_struct
struct|struct
name|addr48
block|{
name|u_long
name|offset
decl_stmt|;
name|u_short
name|segment
decl_stmt|;
block|}
name|apm_addr
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|apm_errno
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_int
parameter_list|(
name|u_long
modifier|*
name|eax
parameter_list|,
name|u_long
modifier|*
name|ebx
parameter_list|,
name|u_long
modifier|*
name|ecx
parameter_list|,
name|u_long
modifier|*
name|edx
parameter_list|)
block|{
name|struct
name|apm_bios_arg
name|apa
decl_stmt|;
name|int
name|cf
decl_stmt|;
name|apa
operator|.
name|eax
operator|=
operator|*
name|eax
expr_stmt|;
name|apa
operator|.
name|ebx
operator|=
operator|*
name|ebx
expr_stmt|;
name|apa
operator|.
name|ecx
operator|=
operator|*
name|ecx
expr_stmt|;
name|apa
operator|.
name|edx
operator|=
operator|*
name|edx
expr_stmt|;
name|cf
operator|=
name|apm_bios_call
argument_list|(
operator|&
name|apa
argument_list|)
expr_stmt|;
operator|*
name|eax
operator|=
name|apa
operator|.
name|eax
expr_stmt|;
operator|*
name|ebx
operator|=
name|apa
operator|.
name|ebx
expr_stmt|;
operator|*
name|ecx
operator|=
name|apa
operator|.
name|ecx
expr_stmt|;
operator|*
name|edx
operator|=
name|apa
operator|.
name|edx
expr_stmt|;
name|apm_errno
operator|=
operator|(
operator|(
operator|*
name|eax
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
return|return
name|cf
return|;
block|}
end_function

begin_comment
comment|/* enable/disable power management */
end_comment

begin_function
specifier|static
name|int
name|apm_enable_disable_pm
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENABLEDISABLEPM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
else|else
name|ebx
operator|=
literal|0xffff
expr_stmt|;
comment|/* APM version 1.0 only */
name|ecx
operator|=
name|enable
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
return|return
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_driver_version
parameter_list|(
name|int
name|version
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
comment|/* First try APM 1.2 */
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_DRVVERSION
expr_stmt|;
name|ebx
operator|=
literal|0x0
expr_stmt|;
name|ecx
operator|=
name|version
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
name|apm_version
operator|=
name|eax
operator|&
literal|0xffff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* engage/disengage power management (APM 1.1 or later) */
end_comment

begin_function
specifier|static
name|int
name|apm_engage_disengage_pm
parameter_list|(
name|int
name|engage
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_ENGAGEDISENGAGEPM
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|engage
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get PM event */
end_comment

begin_function
specifier|static
name|u_int
name|apm_getevent
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPMEVENT
expr_stmt|;
name|ebx
operator|=
literal|0
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
return|return
name|PMEV_NOEVENT
return|;
return|return
name|ebx
operator|&
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/* suspend entire system */
end_comment

begin_function
specifier|static
name|int
name|apm_suspend_system
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|state
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Entire system suspend failure: errcode = %ld\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Display control */
end_comment

begin_comment
comment|/*  * Experimental implementation: My laptop machine can't handle this function  * If your laptop can control the display via APM, please inform me.  *                            HOSOKAWA, Tatsumi<hosokawa@jp.FreeBSD.org>  */
end_comment

begin_function
specifier|static
name|int
name|apm_display
parameter_list|(
name|int
name|newstate
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_DISP0
expr_stmt|;
name|ecx
operator|=
name|newstate
condition|?
name|PMST_APMENABLED
else|:
name|PMST_SUSPEND
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Display off failure: errcode = %ld\n"
argument_list|,
literal|0xff
operator|&
operator|(
name|eax
operator|>>
literal|8
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Turn off the entire system.  */
end_comment

begin_function
specifier|static
name|void
name|apm_power_off
parameter_list|(
name|int
name|howto
parameter_list|,
name|void
modifier|*
name|junk
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
comment|/* Not halting powering off, or not active */
if|if
condition|(
operator|!
operator|(
name|howto
operator|&
name|RB_POWEROFF
operator|)
operator|||
operator|!
name|apm_softc
operator|.
name|active
condition|)
return|return;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_OFF
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM Battery low handler */
end_comment

begin_function
specifier|static
name|void
name|apm_battery_low
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"\007\007 * * * BATTERY IS LOW * * * \007\007"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM hook manager */
end_comment

begin_function
specifier|static
name|struct
name|apmhook
modifier|*
name|apm_add_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Add hook \"%s\"\n"
argument_list|,
name|ah
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|ah
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"illegal apm_hook!"
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|->
name|ah_order
operator|>
name|ah
operator|->
name|ah_order
condition|)
break|break;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|ah
operator|->
name|ah_next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|ah
expr_stmt|;
block|}
else|else
block|{
name|ah
operator|->
name|ah_next
operator|=
name|prev
operator|->
name|ah_next
expr_stmt|;
name|prev
operator|->
name|ah_next
operator|=
name|ah
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ah
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|apm_del_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
modifier|*
name|list
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
if|if
condition|(
name|p
operator|==
name|ah
condition|)
goto|goto
name|deleteit
goto|;
name|panic
argument_list|(
literal|"Tried to delete unregistered apm_hook."
argument_list|)
expr_stmt|;
goto|goto
name|nosuchnode
goto|;
name|deleteit
label|:
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|ah_next
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
else|else
operator|*
name|list
operator|=
name|p
operator|->
name|ah_next
expr_stmt|;
name|nosuchnode
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* APM driver calls some functions automatically */
end_comment

begin_function
specifier|static
name|void
name|apm_execute_hook
parameter_list|(
name|struct
name|apmhook
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|apmhook
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|list
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|ah_next
control|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"Execute APM hook \"%s.\"\n"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
operator|(
name|p
operator|->
name|ah_fun
operator|)
operator|)
operator|(
name|p
operator|->
name|ah_arg
operator|)
condition|)
name|printf
argument_list|(
literal|"Warning: APM hook \"%s\" failed"
argument_list|,
name|p
operator|->
name|ah_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* establish an apm hook */
end_comment

begin_function
name|struct
name|apmhook
modifier|*
name|apm_hook_establish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return
name|NULL
return|;
return|return
name|apm_add_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* disestablish an apm hook */
end_comment

begin_function
name|void
name|apm_hook_disestablish
parameter_list|(
name|int
name|apmh
parameter_list|,
name|struct
name|apmhook
modifier|*
name|ah
parameter_list|)
block|{
if|if
condition|(
name|apmh
operator|<
literal|0
operator|||
name|apmh
operator|>=
name|NAPM_HOOK
condition|)
return|return;
name|apm_del_hook
argument_list|(
operator|&
name|hook
index|[
name|apmh
index|]
argument_list|,
name|ah
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|suspend_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|diff_time
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|apm_default_resume
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|u_int
name|second
decl_stmt|,
name|minute
decl_stmt|,
name|hour
decl_stmt|;
name|struct
name|timeval
name|resume_time
decl_stmt|,
name|tmp_time
decl_stmt|;
comment|/* modified for adjkerntz */
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
name|microtime
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tmp_time
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|tmp_time
argument_list|,
operator|&
name|diff_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXME
comment|/* XXX THIS DOESN'T WORK!!! */
name|time
operator|=
name|tmp_time
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|APM_FIXUP_CALLTODO
comment|/* Calculate the delta time suspended */
name|timevalsub
argument_list|(
operator|&
name|resume_time
argument_list|,
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
comment|/* Fixup the calltodo list with the delta time. */
name|adjust_timeout_calltodo
argument_list|(
operator|&
name|resume_time
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_FIXUP_CALLTODOK */
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|APM_FIXUP_CALLTODO
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
operator|-
name|suspend_time
operator|.
name|tv_sec
expr_stmt|;
else|#
directive|else
comment|/* APM_FIXUP_CALLTODO */
comment|/*  	 * We've already calculated resume_time to be the delta between  	 * the suspend and the resume.  	 */
name|second
operator|=
name|resume_time
operator|.
name|tv_sec
expr_stmt|;
endif|#
directive|endif
comment|/* APM_FIXUP_CALLTODO */
name|hour
operator|=
name|second
operator|/
literal|3600
expr_stmt|;
name|second
operator|%=
literal|3600
expr_stmt|;
name|minute
operator|=
name|second
operator|/
literal|60
expr_stmt|;
name|second
operator|%=
literal|60
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"resumed from suspended mode (slept %02d:%02d:%02d)\n"
argument_list|,
name|hour
argument_list|,
name|minute
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_default_suspend
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|pl
decl_stmt|;
name|pl
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|diff_time
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff_time
argument_list|,
operator|&
name|suspend_time
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|pl
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|apm_record_event
name|__P
argument_list|(
operator|(
expr|struct
name|apm_softc
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|u_int
name|apm_op_inprog
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|apm_lastreq_notify
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_LASTREQNOTIFY
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|apm_lastreq_rejected
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
return|return
literal|1
return|;
comment|/* no operation in progress */
block|}
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_SETPWSTATE
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
name|PMST_LASTREQREJECT
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm_lastreq_rejected: failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
name|apm_op_inprog
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Public interface to the suspend/resume:  *  * Execute suspend and resume hook before and after sleep, respectively.  *  */
end_comment

begin_function
name|void
name|apm_suspend
parameter_list|(
name|int
name|state
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
name|apm_op_inprog
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|error
operator|=
name|DEVICE_SUSPEND
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
comment|/* 		 * XXX Shouldn't ignore the error like this, but should 		 * instead fix the newbus code.  Until that happens, 		 * I'm doing this to get suspend working again. 		 */
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"DEVICE_SUSPEND error %d, ignored\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_SUSPEND
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_suspend_system
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
name|apm_processevent
argument_list|()
expr_stmt|;
else|else
comment|/* Failure, 'resume' the system again */
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|apm_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|DEVICE_RESUME
argument_list|(
name|root_bus
argument_list|)
expr_stmt|;
name|apm_execute_hook
argument_list|(
name|hook
index|[
name|APM_HOOK_RESUME
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* get APM information */
end_comment

begin_function
specifier|static
name|int
name|apm_get_info
parameter_list|(
name|apm_info_t
name|aip
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETPWSTATUS
expr_stmt|;
name|ebx
operator|=
name|PMDV_ALLDEV
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
name|edx
operator|=
literal|0xffff
expr_stmt|;
comment|/* default to unknown battery time */
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
return|return
literal|1
return|;
name|aip
operator|->
name|ai_infoversion
operator|=
literal|1
expr_stmt|;
name|aip
operator|->
name|ai_acline
operator|=
operator|(
name|ebx
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_stat
operator|=
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_batt_life
operator|=
name|ecx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_major
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|majorversion
expr_stmt|;
name|aip
operator|->
name|ai_minor
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|minorversion
expr_stmt|;
name|aip
operator|->
name|ai_status
operator|=
operator|(
name|u_int
operator|)
name|sc
operator|->
name|active
expr_stmt|;
name|edx
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|edx
operator|==
literal|0xffff
condition|)
comment|/* Time is unknown */
name|aip
operator|->
name|ai_batt_time
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|edx
operator|&
literal|0x8000
condition|)
comment|/* Time is in minutes */
name|aip
operator|->
name|ai_batt_time
operator|=
operator|(
name|edx
operator|&
literal|0x7fff
operator|)
operator|*
literal|60
expr_stmt|;
else|else
comment|/* Time is in seconds */
name|aip
operator|->
name|ai_batt_time
operator|=
name|edx
expr_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_GETCAPABILITIES
expr_stmt|;
name|ebx
operator|=
literal|0
expr_stmt|;
name|ecx
operator|=
literal|0
expr_stmt|;
name|edx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
condition|)
block|{
name|aip
operator|->
name|ai_batteries
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Unknown */
name|aip
operator|->
name|ai_capabilities
operator|=
literal|0xff00
expr_stmt|;
comment|/* Unknown, with no bits set */
block|}
else|else
block|{
name|aip
operator|->
name|ai_batteries
operator|=
name|ebx
operator|&
literal|0xff
expr_stmt|;
name|aip
operator|->
name|ai_capabilities
operator|=
name|ecx
operator|&
literal|0xf
expr_stmt|;
block|}
name|bzero
argument_list|(
name|aip
operator|->
name|ai_spare
argument_list|,
sizeof|sizeof
name|aip
operator|->
name|ai_spare
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is idle */
end_comment

begin_function
name|void
name|apm_cpu_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
condition|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUIDLE
expr_stmt|;
name|edx
operator|=
name|ecx
operator|=
name|ebx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some APM implementation halts CPU in BIOS, whenever 	 * "CPU-idle" function are invoked, but swtch() of 	 * FreeBSD halts CPU, therefore, CPU is halted twice 	 * in the sched loop. It makes the interrupt latency 	 * terribly long and be able to cause a serious problem 	 * in interrupt processing. We prevent it by removing 	 * "hlt" operation from swtch() and managed it under 	 * APM driver. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|active
operator|||
name|sc
operator|->
name|always_halt_cpu
condition|)
asm|__asm("hlt");
comment|/* wait for interrupt */
block|}
end_function

begin_comment
comment|/* inform APM BIOS that CPU is busy */
end_comment

begin_function
name|void
name|apm_cpu_busy
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
comment|/* 	 * The APM specification says this is only necessary if your BIOS 	 * slows down the processor in the idle task, otherwise it's not 	 * necessary. 	 */
if|if
condition|(
name|sc
operator|->
name|slow_idle_cpu
operator|&&
name|sc
operator|->
name|active
condition|)
block|{
name|u_long
name|eax
decl_stmt|,
name|ebx
decl_stmt|,
name|ecx
decl_stmt|,
name|edx
decl_stmt|;
name|eax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_CPUBUSY
expr_stmt|;
name|edx
operator|=
name|ecx
operator|=
name|ebx
operator|=
literal|0
expr_stmt|;
name|apm_int
argument_list|(
operator|&
name|eax
argument_list|,
operator|&
name|ebx
argument_list|,
operator|&
name|ecx
argument_list|,
operator|&
name|edx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * APM timeout routine:  *  * This routine is automatically called by timer once per second.  */
end_comment

begin_function
specifier|static
name|void
name|apm_timeout
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|apm_op_inprog
condition|)
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
name|apm_processevent
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|active
operator|==
literal|1
condition|)
comment|/* Run slightly more oftan than 1 Hz */
name|apm_timeout_ch
operator|=
name|timeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|hz
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* enable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_enable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|sc
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|apm_timeout
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* disable APM BIOS */
end_comment

begin_function
specifier|static
name|void
name|apm_event_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"called apm_event_disable()\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
block|{
name|untimeout
argument_list|(
name|apm_timeout
argument_list|,
name|NULL
argument_list|,
name|apm_timeout_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* don't halt CPU in scheduling loop */
end_comment

begin_function
specifier|static
name|void
name|apm_not_halt_cpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|initialized
condition|)
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* device driver definitions */
end_comment

begin_comment
comment|/*  * probe APM  */
end_comment

begin_function
specifier|static
name|int
name|apm_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|vm86frame
name|vmf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|disabled
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"disabled"
argument_list|,
operator|&
name|disabled
argument_list|)
operator|==
literal|0
operator|&&
name|disabled
operator|!=
literal|0
condition|)
return|return
name|ENXIO
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"APM BIOS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"apm: Only one APM driver supported.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vmf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vm86frame
argument_list|)
argument_list|)
expr_stmt|;
comment|/* safety */
name|vmf
operator|.
name|vmf_ax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_INSTCHECK
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|vm86_intcall
argument_list|(
name|SYSTEM_BIOS
argument_list|,
operator|&
name|vmf
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|vmf
operator|.
name|vmf_eflags
operator|&
name|PSL_C
operator|)
operator|&&
operator|(
name|vmf
operator|.
name|vmf_bx
operator|==
literal|0x504d
operator|)
condition|)
block|{
name|apm_version
operator|=
name|vmf
operator|.
name|vmf_ax
expr_stmt|;
name|apm_flags
operator|=
name|vmf
operator|.
name|vmf_cx
expr_stmt|;
name|vmf
operator|.
name|vmf_ax
operator|=
operator|(
name|APM_BIOS
operator|<<
literal|8
operator|)
operator||
name|APM_PROT32CONNECT
expr_stmt|;
name|vmf
operator|.
name|vmf_bx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|i
operator|=
name|vm86_intcall
argument_list|(
name|SYSTEM_BIOS
argument_list|,
operator|&
name|vmf
argument_list|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
name|vmf
operator|.
name|vmf_eflags
operator|&
name|PSL_C
operator|)
condition|)
block|{
name|apm_cs32_base
operator|=
name|vmf
operator|.
name|vmf_ax
expr_stmt|;
name|apm_cs_entry
operator|=
name|vmf
operator|.
name|vmf_ebx
expr_stmt|;
name|apm_cs16_base
operator|=
name|vmf
operator|.
name|vmf_cx
expr_stmt|;
name|apm_ds_base
operator|=
name|vmf
operator|.
name|vmf_dx
expr_stmt|;
name|apm_cs32_limit
operator|=
name|vmf
operator|.
name|vmf_si
expr_stmt|;
if|if
condition|(
name|apm_version
operator|>=
literal|0x0102
condition|)
name|apm_cs16_limit
operator|=
operator|(
name|vmf
operator|.
name|esi
operator|.
name|r_ex
operator|>>
literal|16
operator|)
expr_stmt|;
name|apm_ds_limit
operator|=
name|vmf
operator|.
name|vmf_di
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: BIOS probe/32-bit connect successful\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* XXX constant typo! */
if|if
condition|(
name|vmf
operator|.
name|vmf_ah
operator|==
name|APME_PROT32NOTDUPPORTED
condition|)
block|{
name|apm_version
operator|=
name|APMINI_NOT32BIT
expr_stmt|;
block|}
else|else
block|{
name|apm_version
operator|=
name|APMINI_CONNECTERR
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: BIOS 32-bit connect failed: error 0x%x  carry %d  ah 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|vmf
operator|.
name|vmf_eflags
operator|&
name|PSL_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|vmf
operator|.
name|vmf_ah
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|apm_version
operator|=
name|APMINI_CANTFIND
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: BIOS probe failed: error 0x%x  carry %d  bx 0x%x\n"
argument_list|,
name|i
argument_list|,
operator|(
name|vmf
operator|.
name|vmf_eflags
operator|&
name|PSL_C
operator|)
condition|?
literal|1
else|:
literal|0
argument_list|,
name|vmf
operator|.
name|vmf_bx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|bzero
argument_list|(
operator|&
name|apm_softc
argument_list|,
sizeof|sizeof
argument_list|(
name|apm_softc
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|apm_version
condition|)
block|{
case|case
name|APMINI_CANTFIND
case|:
comment|/* silent */
return|return
name|ENXIO
return|;
case|case
name|APMINI_NOT32BIT
case|:
name|printf
argument_list|(
literal|"apm: 32bit connection is not supported.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
case|case
name|APMINI_CONNECTERR
case|:
name|printf
argument_list|(
literal|"apm: 32-bit connection error.\n"
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|flags
operator|&
literal|0x20
condition|)
name|statclock_disable
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * return 0 if the user will notice and handle the event,  * return 1 if the kernel driver should do so.  */
end_comment

begin_function
specifier|static
name|int
name|apm_record_event
parameter_list|(
name|struct
name|apm_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|event_type
parameter_list|)
block|{
name|struct
name|apm_event_info
modifier|*
name|evp
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OPEN
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* no user waiting */
if|if
condition|(
name|sc
operator|->
name|event_count
operator|==
name|APM_NEVENTS
condition|)
return|return
literal|1
return|;
comment|/* overflow */
if|if
condition|(
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* not registered */
name|evp
operator|=
operator|&
name|sc
operator|->
name|event_list
index|[
name|sc
operator|->
name|event_ptr
index|]
expr_stmt|;
name|sc
operator|->
name|event_count
operator|++
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|++
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|%=
name|APM_NEVENTS
expr_stmt|;
name|evp
operator|->
name|type
operator|=
name|event_type
expr_stmt|;
name|evp
operator|->
name|index
operator|=
operator|++
name|apm_evindex
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OCTL
operator|)
condition|?
literal|0
else|:
literal|1
return|;
comment|/* user may handle */
block|}
end_function

begin_comment
comment|/* Process APM event */
end_comment

begin_function
specifier|static
name|void
name|apm_processevent
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|apm_event
decl_stmt|;
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol: \ 	printf("Received APM Event: " #symbol "\n");
else|#
directive|else
define|#
directive|define
name|OPMEV_DEBUGMESSAGE
parameter_list|(
name|symbol
parameter_list|)
value|case symbol:
endif|#
directive|endif
do|do
block|{
name|apm_event
operator|=
name|apm_getevent
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|apm_event
condition|)
block|{
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_SUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
comment|/* XXX skip the rest */
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_USERSUSPENDREQ
argument_list|)
expr_stmt|;
name|apm_lastreq_notify
argument_list|()
expr_stmt|;
if|if
condition|(
name|apm_op_inprog
operator|==
literal|0
condition|)
block|{
name|apm_op_inprog
operator|++
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
comment|/* XXX skip the rest */
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITSUSPEND
argument_list|)
expr_stmt|;
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_NORMRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_CRITRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_STANDBYRESUME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|apm_resume
argument_list|()
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_BATTERYLOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
condition|)
block|{
name|apm_battery_low
argument_list|()
expr_stmt|;
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
block|}
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_POWERSTATECHANGE
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
name|OPMEV_DEBUGMESSAGE
argument_list|(
name|PMEV_UPDATETIME
argument_list|)
expr_stmt|;
name|apm_record_event
argument_list|(
name|sc
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* adjust time to RTC */
break|break;
case|case
name|PMEV_NOEVENT
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown Original APM Event 0x%x\n"
argument_list|,
name|apm_event
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|apm_event
operator|!=
name|PMEV_NOEVENT
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Attach APM:  *  * Initialize APM driver  */
end_comment

begin_function
specifier|static
name|int
name|apm_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
define|#
directive|define
name|APM_KERNBASE
value|KERNBASE
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"apm"
argument_list|,
literal|0
argument_list|,
literal|"flags"
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|0
expr_stmt|;
comment|/* Must be externally enabled */
name|sc
operator|->
name|active
operator|=
literal|0
expr_stmt|;
comment|/* setup APM parameters */
name|sc
operator|->
name|cs16_base
operator|=
operator|(
name|apm_cs16_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|cs32_base
operator|=
operator|(
name|apm_cs32_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|ds_base
operator|=
operator|(
name|apm_ds_base
operator|<<
literal|4
operator|)
operator|+
name|APM_KERNBASE
expr_stmt|;
name|sc
operator|->
name|cs32_limit
operator|=
name|apm_cs32_limit
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|apm_cs16_limit
operator|==
literal|0
condition|)
name|apm_cs16_limit
operator|=
name|apm_cs32_limit
expr_stmt|;
name|sc
operator|->
name|cs16_limit
operator|=
name|apm_cs16_limit
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|ds_limit
operator|=
name|apm_ds_limit
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|cs_entry
operator|=
name|apm_cs_entry
expr_stmt|;
comment|/* Always call HLT in idle loop */
name|sc
operator|->
name|always_halt_cpu
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|slow_idle_cpu
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_CPUIDLE_SLOW
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disabled
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISABLED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|disengaged
operator|=
operator|(
operator|(
name|apm_flags
operator|&
name|APM_DISENGAGED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* print bootstrap messages */
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: APM BIOS version %04x\n"
argument_list|,
name|apm_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code32 0x%08x, Code16 0x%08x, Data 0x%08x\n"
argument_list|,
name|sc
operator|->
name|cs32_base
argument_list|,
name|sc
operator|->
name|cs16_base
argument_list|,
name|sc
operator|->
name|ds_base
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: Code entry 0x%08x, Idling CPU %s, Management %s\n"
argument_list|,
name|sc
operator|->
name|cs_entry
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disabled
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apm: CS32_limit=0x%x, CS16_limit=0x%x, DS_limit=0x%x\n"
argument_list|,
operator|(
name|u_short
operator|)
name|sc
operator|->
name|cs32_limit
argument_list|,
operator|(
name|u_short
operator|)
name|sc
operator|->
name|cs16_limit
argument_list|,
operator|(
name|u_short
operator|)
name|sc
operator|->
name|ds_limit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APM_DEBUG */
if|#
directive|if
literal|0
comment|/* Workaround for some buggy APM BIOS implementations */
block|sc->cs_limit = 0xffff; 	sc->ds_limit = 0xffff;
endif|#
directive|endif
comment|/* setup GDT */
name|setup_apm_gdt
argument_list|(
name|sc
operator|->
name|cs32_base
argument_list|,
name|sc
operator|->
name|cs16_base
argument_list|,
name|sc
operator|->
name|ds_base
argument_list|,
name|sc
operator|->
name|cs32_limit
argument_list|,
name|sc
operator|->
name|cs16_limit
argument_list|,
name|sc
operator|->
name|ds_limit
argument_list|)
expr_stmt|;
comment|/* setup entry point 48bit pointer */
name|apm_addr
operator|.
name|segment
operator|=
name|GSEL
argument_list|(
name|GAPMCODE32_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|apm_addr
operator|.
name|offset
operator|=
name|sc
operator|->
name|cs_entry
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
literal|0x10
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
literal|0xf
operator|)
operator|>=
literal|0x2
condition|)
block|{
name|apm_driver_version
argument_list|(
literal|0x102
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apm_version
operator|&&
operator|(
name|flags
operator|&
literal|0xf
operator|)
operator|>=
literal|0x1
condition|)
block|{
name|apm_driver_version
argument_list|(
literal|0x101
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|apm_driver_version
argument_list|(
literal|0x102
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|apm_version
condition|)
name|apm_driver_version
argument_list|(
literal|0x101
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apm_version
condition|)
name|apm_version
operator|=
literal|0x100
expr_stmt|;
name|sc
operator|->
name|minorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0x00f0
operator|)
operator|>>
literal|4
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x000f
operator|)
operator|>>
literal|0
operator|)
expr_stmt|;
name|sc
operator|->
name|majorversion
operator|=
operator|(
operator|(
name|apm_version
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
operator|)
operator|*
literal|10
operator|+
operator|(
operator|(
name|apm_version
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
operator|)
expr_stmt|;
name|sc
operator|->
name|intversion
operator|=
name|INTVERSION
argument_list|(
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"apm: Engaged control %s\n"
argument_list|,
name|is_enabled
argument_list|(
operator|!
name|sc
operator|->
name|disengaged
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"apm: found APM BIOS version %d.%d\n"
argument_list|,
name|sc
operator|->
name|majorversion
argument_list|,
name|sc
operator|->
name|minorversion
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: Slow Idling CPU %s\n"
argument_list|,
name|is_enabled
argument_list|(
name|sc
operator|->
name|slow_idle_cpu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enable power management */
if|if
condition|(
name|sc
operator|->
name|disabled
condition|)
block|{
if|if
condition|(
name|apm_enable_disable_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* enable function failed! [%x]\n"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* engage power managment (APM 1.1 or later) */
if|if
condition|(
name|sc
operator|->
name|intversion
operator|>=
name|INTVERSION
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
operator|&&
name|sc
operator|->
name|disengaged
condition|)
block|{
if|if
condition|(
name|apm_engage_disengage_pm
argument_list|(
literal|1
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apm: *Warning* engage function failed err=[%x]"
argument_list|,
name|apm_errno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" (Docked or using external power?).\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* default suspend hook */
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_fun
operator|=
name|apm_default_suspend
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_name
operator|=
literal|"default suspend"
expr_stmt|;
name|sc
operator|->
name|sc_suspend
operator|.
name|ah_order
operator|=
name|APM_MAX_ORDER
expr_stmt|;
comment|/* default resume hook */
name|sc
operator|->
name|sc_resume
operator|.
name|ah_fun
operator|=
name|apm_default_resume
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_arg
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_name
operator|=
literal|"default resume"
expr_stmt|;
name|sc
operator|->
name|sc_resume
operator|.
name|ah_order
operator|=
name|APM_MIN_ORDER
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_SUSPEND
argument_list|,
operator|&
name|sc
operator|->
name|sc_suspend
argument_list|)
expr_stmt|;
name|apm_hook_establish
argument_list|(
name|APM_HOOK_RESUME
argument_list|,
operator|&
name|sc
operator|->
name|sc_resume
argument_list|)
expr_stmt|;
name|apm_event_enable
argument_list|()
expr_stmt|;
comment|/* Power the system off using APM */
name|at_shutdown_pri
argument_list|(
name|apm_power_off
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_FINAL
argument_list|,
name|SHUTDOWN_PRI_LAST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|initialized
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|sc
operator|->
name|sc_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|apm_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"apm"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|ctl
init|=
name|APMDEV
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|APMDEV_CTL
case|:
if|if
condition|(
operator|!
operator|(
name|flag
operator|&
name|FWRITE
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OCTL
condition|)
return|return
name|EBUSY
return|;
name|sc
operator|->
name|sc_flags
operator||=
name|SCFLAG_OCTL
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|event_filter
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|event_filter
argument_list|)
expr_stmt|;
break|break;
case|case
name|APMDEV_NORMAL
case|:
name|sc
operator|->
name|sc_flags
operator||=
name|SCFLAG_ONORMAL
expr_stmt|;
break|break;
default|default:
return|return
name|ENXIO
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|ctl
init|=
name|APMDEV
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|ctl
condition|)
block|{
case|case
name|APMDEV_CTL
case|:
name|apm_lastreq_rejected
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SCFLAG_OCTL
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|event_filter
argument_list|,
sizeof|sizeof
name|sc
operator|->
name|event_filter
argument_list|)
expr_stmt|;
break|break;
case|case
name|APMDEV_NORMAL
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SCFLAG_ONORMAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SCFLAG_OPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|event_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|event_ptr
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|newstate
decl_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|initialized
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"APM ioctl: cmd = 0x%x\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_SUSPEND
case|:
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|apm_suspend
argument_list|(
name|PMST_SUSPEND
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|APMIO_STANDBY
case|:
if|if
condition|(
name|sc
operator|->
name|active
condition|)
name|apm_suspend
argument_list|(
name|PMST_STANDBY
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|APMIO_GETINFO_OLD
case|:
block|{
name|struct
name|apm_info
name|info
decl_stmt|;
name|apm_info_old_t
name|aiop
decl_stmt|;
if|if
condition|(
name|apm_get_info
argument_list|(
operator|&
name|info
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
name|aiop
operator|=
operator|(
name|apm_info_old_t
operator|)
name|addr
expr_stmt|;
name|aiop
operator|->
name|ai_major
operator|=
name|info
operator|.
name|ai_major
expr_stmt|;
name|aiop
operator|->
name|ai_minor
operator|=
name|info
operator|.
name|ai_minor
expr_stmt|;
name|aiop
operator|->
name|ai_acline
operator|=
name|info
operator|.
name|ai_acline
expr_stmt|;
name|aiop
operator|->
name|ai_batt_stat
operator|=
name|info
operator|.
name|ai_batt_stat
expr_stmt|;
name|aiop
operator|->
name|ai_batt_life
operator|=
name|info
operator|.
name|ai_batt_life
expr_stmt|;
name|aiop
operator|->
name|ai_status
operator|=
name|info
operator|.
name|ai_status
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_GETINFO
case|:
if|if
condition|(
name|apm_get_info
argument_list|(
operator|(
name|apm_info_t
operator|)
name|addr
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_ENABLE
case|:
name|apm_event_enable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISABLE
case|:
name|apm_event_disable
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_HALTCPU
case|:
name|apm_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_NOTHALTCPU
case|:
name|apm_not_halt_cpu
argument_list|()
expr_stmt|;
break|break;
case|case
name|APMIO_DISPLAY
case|:
name|newstate
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|apm_display
argument_list|(
name|newstate
argument_list|)
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
case|case
name|APMIO_BIOS
case|:
if|if
condition|(
name|apm_bios_call
argument_list|(
operator|(
expr|struct
name|apm_bios_arg
operator|*
operator|)
name|addr
argument_list|)
operator|==
literal|0
condition|)
operator|(
operator|(
expr|struct
name|apm_bios_arg
operator|*
operator|)
name|addr
operator|)
operator|->
name|eax
operator|&=
literal|0xff
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* for /dev/apmctl */
if|if
condition|(
name|APMDEV
argument_list|(
name|dev
argument_list|)
operator|==
name|APMDEV_CTL
condition|)
block|{
name|struct
name|apm_event_info
modifier|*
name|evp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|APMIO_NEXTEVENT
case|:
if|if
condition|(
operator|!
name|sc
operator|->
name|event_count
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
else|else
block|{
name|evp
operator|=
operator|(
expr|struct
name|apm_event_info
operator|*
operator|)
name|addr
expr_stmt|;
name|i
operator|=
name|sc
operator|->
name|event_ptr
operator|+
name|APM_NEVENTS
operator|-
name|sc
operator|->
name|event_count
expr_stmt|;
name|i
operator|%=
name|APM_NEVENTS
expr_stmt|;
operator|*
name|evp
operator|=
name|sc
operator|->
name|event_list
index|[
name|i
index|]
expr_stmt|;
name|sc
operator|->
name|event_count
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|APMIO_REJECTLASTREQ
case|:
if|if
condition|(
name|apm_lastreq_rejected
argument_list|()
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmwrite
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|u_int
name|event_type
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
name|enabled
decl_stmt|;
if|if
condition|(
name|APMDEV
argument_list|(
name|dev
argument_list|)
operator|!=
name|APMDEV_CTL
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|event_type
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|uio
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|event_type
operator|<
literal|0
operator|||
name|event_type
operator|>=
name|APM_NPMEV
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|==
literal|0
condition|)
block|{
name|enabled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|enabled
operator|=
literal|0
expr_stmt|;
block|}
name|sc
operator|->
name|event_filter
index|[
name|event_type
index|]
operator|=
name|enabled
expr_stmt|;
ifdef|#
directive|ifdef
name|APM_DEBUG
name|printf
argument_list|(
literal|"apmwrite: event 0x%x %s\n"
argument_list|,
name|event_type
argument_list|,
name|is_enabled
argument_list|(
name|enabled
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|uio
operator|->
name|uio_resid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apmpoll
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|apm_softc
modifier|*
name|sc
init|=
operator|&
name|apm_softc
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|event_count
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|sc
operator|->
name|sc_rsel
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|apm_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|apm_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|apm_attach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|apm_driver
init|=
block|{
literal|"apm"
block|,
name|apm_methods
block|,
literal|1
block|,
comment|/* no softc (XXX) */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|apm_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEV_DRIVER_MODULE
argument_list|(
name|apm
argument_list|,
name|nexus
argument_list|,
name|apm_driver
argument_list|,
name|apm_devclass
argument_list|,
name|apm_cdevsw
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

