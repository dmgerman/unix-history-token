begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * linux/kernel/math/math_emulate.c  *  * (C) 1991 Linus Torvalds  *  * [expediant "port" of linux 8087 emulator to 386BSD, with apologies -wfj]  *  *	from: 386BSD 0.1  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Limited emulation 27.12.91 - mostly loads/stores, which gcc wants  * even for soft-float, unless you use bruce evans' patches. The patches  * are great, but they have to be re-applied for every version, and the  * library is different for soft-float and 80387. So emulation is more  * practical, even though it's slower.  *  * 28.12.91 - loads/stores work, even BCD. I'll have to start thinking  * about add/sub/mul/div. Urgel. I should find some good source, but I'll  * just fake up something.  *  * 30.12.91 - add/sub/mul/div/com seem to work mostly. I should really  * test every possible combination.  */
end_comment

begin_comment
comment|/*  * This file is full of ugly macros etc: one problem was that gcc simply  * didn't want to make the structures as they should be: it has to try to  * align them. Sickening code, but at least I've hidden the ugly things  * in this one file: the other files don't need to know about these things.  *  * The other files also don't care about ST(x) etc - they just get addresses  * to 80-bit temporary reals, and do with them as they please. I wanted to  * hide most of the 387-specific things here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_define
define|#
directive|define
name|__ALIGNED_TEMP_REAL
value|1
end_define

begin_include
include|#
directive|include
file|<i386/i386/math_emu.h>
end_include

begin_define
define|#
directive|define
name|bswapw
parameter_list|(
name|x
parameter_list|)
value|__asm__("xchgb %%al,%%ah":"=a" (x):"0" ((short)x))
end_define

begin_define
define|#
directive|define
name|ST
parameter_list|(
name|x
parameter_list|)
value|(*__st((x)))
end_define

begin_define
define|#
directive|define
name|PST
parameter_list|(
name|x
parameter_list|)
value|((const temp_real *) __st((x)))
end_define

begin_define
define|#
directive|define
name|math_abort
parameter_list|(
name|tfp
parameter_list|,
name|signo
parameter_list|)
value|tfp->tf_eip = oldeip; return (signo);
end_define

begin_comment
comment|/*  * We don't want these inlined - it gets too messy in the machine-code.  */
end_comment

begin_function_decl
specifier|static
name|void
name|fpop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fpush
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fxchg
parameter_list|(
name|temp_real_unaligned
modifier|*
name|a
parameter_list|,
name|temp_real_unaligned
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|temp_real_unaligned
modifier|*
name|__st
parameter_list|(
name|int
name|i
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|unsigned
name|char
name|get_fs_byte
parameter_list|(
name|char
modifier|*
name|adr
parameter_list|)
block|{
return|return
operator|(
name|fubyte
argument_list|(
name|adr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|short
name|get_fs_word
parameter_list|(
name|unsigned
name|short
modifier|*
name|adr
parameter_list|)
block|{
return|return
operator|(
name|fuword
argument_list|(
name|adr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|get_fs_long
parameter_list|(
name|u_int32_t
modifier|*
name|adr
parameter_list|)
block|{
return|return
operator|(
name|fuword
argument_list|(
name|adr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_fs_byte
parameter_list|(
name|unsigned
name|char
name|val
parameter_list|,
name|char
modifier|*
name|adr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|subyte
argument_list|(
name|adr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_fs_word
parameter_list|(
name|unsigned
name|short
name|val
parameter_list|,
name|short
modifier|*
name|adr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|susword
argument_list|(
name|adr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_fs_long
parameter_list|(
name|u_long
name|val
parameter_list|,
name|u_int32_t
modifier|*
name|adr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|suword
argument_list|(
name|adr
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|math_emulate
parameter_list|(
name|struct
name|trapframe
modifier|*
name|info
parameter_list|)
block|{
name|unsigned
name|short
name|code
decl_stmt|;
name|temp_real
name|tmp
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|;
name|u_int32_t
name|oldeip
decl_stmt|;
comment|/* ever used fp? */
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
operator|)
operator|->
name|pcb_flags
operator|&
name|FP_SOFTFP
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
operator|)
operator|->
name|pcb_flags
operator||=
name|FP_SOFTFP
expr_stmt|;
name|I387
operator|.
name|cwd
operator|=
literal|0x037f
expr_stmt|;
name|I387
operator|.
name|swd
operator|=
literal|0x0000
expr_stmt|;
name|I387
operator|.
name|twd
operator|=
literal|0x0000
expr_stmt|;
block|}
if|if
condition|(
name|I387
operator|.
name|cwd
operator|&
name|I387
operator|.
name|swd
operator|&
literal|0x3f
condition|)
name|I387
operator|.
name|swd
operator||=
literal|0x8000
expr_stmt|;
else|else
name|I387
operator|.
name|swd
operator|&=
literal|0x7fff
expr_stmt|;
name|oldeip
operator|=
name|info
operator|->
name|tf_eip
expr_stmt|;
comment|/* 0x001f means user code space */
if|if
condition|(
operator|(
name|u_short
operator|)
name|info
operator|->
name|tf_cs
operator|!=
literal|0x001F
condition|)
block|{
name|printf
argument_list|(
literal|"math_emulate: %04x:%08lx\n"
argument_list|,
operator|(
name|u_short
operator|)
name|info
operator|->
name|tf_cs
argument_list|,
operator|(
name|u_long
operator|)
name|oldeip
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"?Math emulation needed in kernel?"
argument_list|)
expr_stmt|;
block|}
comment|/* completely ignore an operand-size prefix */
if|if
condition|(
name|get_fs_byte
argument_list|(
operator|(
name|char
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
operator|==
literal|0x66
condition|)
name|info
operator|->
name|tf_eip
operator|++
expr_stmt|;
name|code
operator|=
name|get_fs_word
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|bswapw
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|code
operator|&=
literal|0x7ff
expr_stmt|;
name|I387
operator|.
name|fip
operator|=
name|oldeip
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|I387
operator|.
name|fcs
operator|=
operator|(
name|u_short
operator|)
name|info
operator|->
name|tf_cs
expr_stmt|;
operator|*
operator|(
literal|1
operator|+
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|I387
operator|.
name|fcs
operator|)
operator|=
name|code
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|+=
literal|2
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
literal|0x1d0
case|:
comment|/* fnop */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1d1
case|:
case|case
literal|0x1d2
case|:
case|case
literal|0x1d3
case|:
comment|/* fst to 32-bit mem */
case|case
literal|0x1d4
case|:
case|case
literal|0x1d5
case|:
case|case
literal|0x1d6
case|:
case|case
literal|0x1d7
case|:
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1e0
case|:
comment|/* fchs */
name|ST
argument_list|(
literal|0
argument_list|)
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1e1
case|:
comment|/* fabs */
name|ST
argument_list|(
literal|0
argument_list|)
operator|.
name|exponent
operator|&=
literal|0x7fff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1e2
case|:
case|case
literal|0x1e3
case|:
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1e4
case|:
comment|/* ftst */
name|ftst
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1e5
case|:
comment|/* fxam */
name|printf
argument_list|(
literal|"fxam not implemented\n"
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1e6
case|:
case|case
literal|0x1e7
case|:
comment|/* fldenv */
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1e8
case|:
comment|/* fld1 */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONST1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1e9
case|:
comment|/* fld2t */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTL2T
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1ea
case|:
comment|/* fld2e */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTL2E
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1eb
case|:
comment|/* fldpi */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTPI
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1ec
case|:
comment|/* fldlg2 */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTLG2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1ed
case|:
comment|/* fldln2 */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTLN2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1ee
case|:
comment|/* fldz */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|CONSTZ
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1ef
case|:
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1f0
case|:
comment|/* f2xm1 */
case|case
literal|0x1f1
case|:
comment|/* fyl2x */
case|case
literal|0x1f2
case|:
comment|/* fptan */
case|case
literal|0x1f3
case|:
comment|/* fpatan */
case|case
literal|0x1f4
case|:
comment|/* fxtract */
case|case
literal|0x1f5
case|:
comment|/* fprem1 */
case|case
literal|0x1f6
case|:
comment|/* fdecstp */
case|case
literal|0x1f7
case|:
comment|/* fincstp */
case|case
literal|0x1f8
case|:
comment|/* fprem */
case|case
literal|0x1f9
case|:
comment|/* fyl2xp1 */
case|case
literal|0x1fa
case|:
comment|/* fsqrt */
case|case
literal|0x1fb
case|:
comment|/* fsincos */
case|case
literal|0x1fe
case|:
comment|/* fsin */
case|case
literal|0x1ff
case|:
comment|/* fcos */
name|uprintf
argument_list|(
literal|"math_emulate: instruction %04x not implemented\n"
argument_list|,
name|code
operator|+
literal|0xd800
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0x1fc
case|:
comment|/* frndint */
name|frndint
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1fd
case|:
comment|/* fscale */
comment|/* incomplete and totally inadequate -wfj */
name|Fscale
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|1
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 19 Sep 92*/
case|case
literal|0x2e9
case|:
comment|/* ????? */
comment|/* if this should be a fucomp ST(0),ST(1) , it must be a 0x3e9  ATS */
name|fucom
argument_list|(
name|PST
argument_list|(
literal|1
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x3d0
case|:
case|case
literal|0x3d1
case|:
comment|/* fist ?? */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x3e2
case|:
comment|/* fclex */
name|I387
operator|.
name|swd
operator|&=
literal|0x7f00
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x3e3
case|:
comment|/* fninit */
name|I387
operator|.
name|cwd
operator|=
literal|0x037f
expr_stmt|;
name|I387
operator|.
name|swd
operator|=
literal|0x0000
expr_stmt|;
name|I387
operator|.
name|twd
operator|=
literal|0x0000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x3e4
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x6d9
case|:
comment|/* fcompp */
name|fcom
argument_list|(
name|PST
argument_list|(
literal|1
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x7e0
case|:
comment|/* fstsw ax */
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|info
operator|->
name|tf_eax
operator|=
name|I387
operator|.
name|swd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|code
operator|>>
literal|3
condition|)
block|{
case|case
literal|0x18
case|:
comment|/* fadd */
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x19
case|:
comment|/* fmul */
name|fmul
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1a
case|:
comment|/* fcom */
name|fcom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1b
case|:
comment|/* fcomp */
name|fcom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1c
case|:
comment|/* fsubr */
name|real_to_real
argument_list|(
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1d
case|:
comment|/* fsub */
name|ST
argument_list|(
literal|0
argument_list|)
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1e
case|:
comment|/* fdivr */
name|fdiv
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x1f
case|:
comment|/* fdiv */
name|fdiv
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x38
case|:
comment|/* fld */
name|fpush
argument_list|()
expr_stmt|;
name|ST
argument_list|(
literal|0
argument_list|)
operator|=
name|ST
argument_list|(
operator|(
name|code
operator|&
literal|7
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* why plus 1 ????? ATS */
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x39
case|:
comment|/* fxch */
name|fxchg
argument_list|(
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x3b
case|:
comment|/*  ??? ??? wrong ???? ATS */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|=
name|ST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x98
case|:
comment|/* fadd */
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x99
case|:
comment|/* fmul */
name|fmul
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9a
case|:
comment|/* ???? , my manual don't list a direction bit for fcom , ??? ATS */
name|fcom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9b
case|:
comment|/* same as above , ATS */
name|fcom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9c
case|:
comment|/* fsubr */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9d
case|:
comment|/* fsub */
name|real_to_real
argument_list|(
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9e
case|:
comment|/* fdivr */
name|fdiv
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x9f
case|:
comment|/* fdiv */
name|fdiv
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xb8
case|:
comment|/* ffree */
name|printf
argument_list|(
literal|"ffree not implemented\n"
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
case|case
literal|0xb9
case|:
comment|/* fstp ???? where is the pop ? ATS */
name|fxchg
argument_list|(
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xba
case|:
comment|/* fst */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|=
name|ST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xbb
case|:
comment|/* ????? encoding of fstp to mem ? ATS */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|=
name|ST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xbc
case|:
comment|/* fucom */
name|fucom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xbd
case|:
comment|/* fucomp */
name|fucom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xd8
case|:
comment|/* faddp */
name|fadd
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xd9
case|:
comment|/* fmulp */
name|fmul
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xda
case|:
comment|/* ??? encoding of ficom with 16 bit mem ? ATS */
name|fcom
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xdc
case|:
comment|/* fsubrp */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xdd
case|:
comment|/* fsubp */
name|real_to_real
argument_list|(
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xde
case|:
comment|/* fdivrp */
name|fdiv
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xdf
case|:
comment|/* fdivp */
name|fdiv
argument_list|(
name|PST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xf8
case|:
comment|/* fild 16-bit mem ???? ATS */
name|printf
argument_list|(
literal|"ffree not implemented\n"
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xf9
case|:
comment|/*  ????? ATS */
name|fxchg
argument_list|(
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xfa
case|:
comment|/* fist 16-bit mem ? ATS */
case|case
literal|0xfb
case|:
comment|/* fistp 16-bit mem ? ATS */
name|ST
argument_list|(
name|code
operator|&
literal|7
argument_list|)
operator|=
name|ST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
operator|(
name|code
operator|>>
literal|3
operator|)
operator|&
literal|0xe7
condition|)
block|{
case|case
literal|0x22
case|:
name|put_short_real
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x23
case|:
name|put_short_real
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x24
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|7
condition|;
name|code
operator|++
control|)
block|{
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|I387
operator|)
index|[
name|code
index|]
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x25
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|I387
operator|.
name|cwd
operator|=
name|get_fs_word
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x26
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(address,28);*/
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|7
condition|;
name|code
operator|++
control|)
block|{
name|put_fs_long
argument_list|(
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|I387
operator|)
index|[
name|code
index|]
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x27
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(address,2);*/
name|put_fs_word
argument_list|(
name|I387
operator|.
name|cwd
argument_list|,
operator|(
name|short
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x62
case|:
name|put_long_int
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x63
case|:
name|put_long_int
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x65
case|:
name|fpush
argument_list|()
expr_stmt|;
name|get_temp_real
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0x67
case|:
name|put_temp_real
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xa2
case|:
name|put_long_real
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xa3
case|:
name|put_long_real
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xa4
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|27
condition|;
name|code
operator|++
control|)
block|{
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|I387
operator|)
index|[
name|code
index|]
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
literal|4
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xa6
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(address,108);*/
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|27
condition|;
name|code
operator|++
control|)
block|{
name|put_fs_long
argument_list|(
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|I387
operator|)
index|[
name|code
index|]
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
name|address
operator|+=
literal|4
expr_stmt|;
block|}
name|I387
operator|.
name|cwd
operator|=
literal|0x037f
expr_stmt|;
name|I387
operator|.
name|swd
operator|=
literal|0x0000
expr_stmt|;
name|I387
operator|.
name|twd
operator|=
literal|0x0000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xa7
case|:
name|address
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(address,2);*/
name|put_fs_word
argument_list|(
name|I387
operator|.
name|swd
argument_list|,
operator|(
name|short
operator|*
operator|)
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe2
case|:
name|put_short_int
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe3
case|:
name|put_short_int
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe4
case|:
name|fpush
argument_list|()
expr_stmt|;
name|get_BCD
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe5
case|:
name|fpush
argument_list|()
expr_stmt|;
name|get_longlong_int
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe6
case|:
name|put_BCD
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|0xe7
case|:
name|put_longlong_int
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|code
operator|>>
literal|9
condition|)
block|{
case|case
literal|0
case|:
name|get_short_real
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|get_long_int
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|get_long_real
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|get_short_int
argument_list|(
operator|&
name|tmp
argument_list|,
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|code
operator|>>
literal|3
operator|)
operator|&
literal|0x27
condition|)
block|{
case|case
literal|0
case|:
name|fadd
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|1
case|:
name|fmul
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|2
case|:
name|fcom
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|3
case|:
name|fcom
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|fpop
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|4
case|:
name|tmp
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|5
case|:
name|ST
argument_list|(
literal|0
argument_list|)
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|6
case|:
name|fdiv
argument_list|(
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
literal|7
case|:
name|fdiv
argument_list|(
operator|&
name|tmp
argument_list|,
name|PST
argument_list|(
literal|0
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|code
operator|&
literal|0x138
operator|)
operator|==
literal|0x100
condition|)
block|{
name|fpush
argument_list|()
expr_stmt|;
name|real_to_real
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|ST
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Unknown math-insns: %04x:%08x %04x\n"
argument_list|,
operator|(
name|u_short
operator|)
name|info
operator|->
name|tf_cs
argument_list|,
name|info
operator|->
name|tf_eip
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|info
argument_list|,
name|SIGFPE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fpop
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|I387
operator|.
name|swd
operator|&
literal|0xffffc7ffUL
expr_stmt|;
name|I387
operator|.
name|swd
operator|+=
literal|0x00000800
expr_stmt|;
name|I387
operator|.
name|swd
operator|&=
literal|0x00003800
expr_stmt|;
name|I387
operator|.
name|swd
operator||=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fpush
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|I387
operator|.
name|swd
operator|&
literal|0xffffc7ffUL
expr_stmt|;
name|I387
operator|.
name|swd
operator|+=
literal|0x00003800
expr_stmt|;
name|I387
operator|.
name|swd
operator|&=
literal|0x00003800
expr_stmt|;
name|I387
operator|.
name|swd
operator||=
name|tmp
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fxchg
parameter_list|(
name|temp_real_unaligned
modifier|*
name|a
parameter_list|,
name|temp_real_unaligned
modifier|*
name|b
parameter_list|)
block|{
name|temp_real_unaligned
name|c
decl_stmt|;
name|c
operator|=
operator|*
name|a
expr_stmt|;
operator|*
name|a
operator|=
operator|*
name|b
expr_stmt|;
operator|*
name|b
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|temp_real_unaligned
modifier|*
name|__st
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|i
operator|+=
name|I387
operator|.
name|swd
operator|>>
literal|11
expr_stmt|;
name|i
operator|&=
literal|7
expr_stmt|;
return|return
operator|(
name|temp_real_unaligned
operator|*
operator|)
operator|(
name|i
operator|*
literal|10
operator|+
operator|(
name|char
operator|*
operator|)
operator|(
name|I387
operator|.
name|st_space
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/ea.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * Calculate the effective address.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|__regoffset
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG
parameter_list|(
name|x
parameter_list|)
value|(((int *)curproc->p_md.md_regs)[__regoffset[(x)]])
end_define

begin_function
specifier|static
name|char
modifier|*
name|sib
parameter_list|(
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|int
name|mod
parameter_list|)
block|{
name|unsigned
name|char
name|ss
decl_stmt|,
name|index
decl_stmt|,
name|base
decl_stmt|;
name|int32_t
name|offset
init|=
literal|0
decl_stmt|;
name|base
operator|=
name|get_fs_byte
argument_list|(
operator|(
name|char
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|++
expr_stmt|;
name|ss
operator|=
name|base
operator|>>
literal|6
expr_stmt|;
name|index
operator|=
operator|(
name|base
operator|>>
literal|3
operator|)
operator|&
literal|7
expr_stmt|;
name|base
operator|&=
literal|7
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|4
condition|)
name|offset
operator|=
literal|0
expr_stmt|;
else|else
name|offset
operator|=
name|REG
argument_list|(
name|index
argument_list|)
expr_stmt|;
name|offset
operator|<<=
name|ss
expr_stmt|;
if|if
condition|(
name|mod
operator|||
name|base
operator|!=
literal|5
condition|)
name|offset
operator|+=
name|REG
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|mod
operator|==
literal|1
condition|)
block|{
name|offset
operator|+=
operator|(
name|signed
name|char
operator|)
name|get_fs_byte
argument_list|(
operator|(
name|char
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mod
operator|==
literal|2
operator|||
name|base
operator|==
literal|5
condition|)
block|{
name|offset
operator|+=
operator|(
name|signed
operator|)
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|+=
literal|4
expr_stmt|;
block|}
name|I387
operator|.
name|foo
operator|=
name|offset
expr_stmt|;
name|I387
operator|.
name|fos
operator|=
literal|0x17
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|offset
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ea
parameter_list|(
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|unsigned
name|char
name|mod
decl_stmt|,
name|rm
decl_stmt|;
name|int32_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|mod
operator|=
operator|(
name|code
operator|>>
literal|6
operator|)
operator|&
literal|3
expr_stmt|;
name|rm
operator|=
name|code
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|rm
operator|==
literal|4
operator|&&
name|mod
operator|!=
literal|3
condition|)
return|return
name|sib
argument_list|(
name|info
argument_list|,
name|mod
argument_list|)
return|;
if|if
condition|(
name|rm
operator|==
literal|5
operator|&&
operator|!
name|mod
condition|)
block|{
name|offset
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|+=
literal|4
expr_stmt|;
name|I387
operator|.
name|foo
operator|=
name|offset
expr_stmt|;
name|I387
operator|.
name|fos
operator|=
literal|0x17
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|offset
return|;
block|}
name|tmp
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|REG
argument_list|(
name|rm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mod
condition|)
block|{
case|case
literal|0
case|:
name|offset
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|offset
operator|=
operator|(
name|signed
name|char
operator|)
name|get_fs_byte
argument_list|(
operator|(
name|char
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|offset
operator|=
operator|(
name|signed
operator|)
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|info
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
name|info
operator|->
name|tf_eip
operator|+=
literal|4
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
literal|3
case|:
name|math_abort
argument_list|(
name|info
argument_list|,
literal|1
operator|<<
operator|(
name|SIGILL
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|I387
operator|.
name|foo
operator|=
name|offset
expr_stmt|;
name|I387
operator|.
name|fos
operator|=
literal|0x17
expr_stmt|;
return|return
name|offset
operator|+
operator|(
name|char
operator|*
operator|)
operator|*
name|tmp
return|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/get_put.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * This file handles all accesses to user memory: getting and putting  * ints/reals/BCD etc. This is the only part that concerns itself with  * other than temporary real format. All other cals are strictly temp_real.  */
end_comment

begin_function
specifier|static
name|void
name|get_short_real
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|short_real
name|sr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|sr
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|short_to_temp
argument_list|(
operator|&
name|sr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_long_real
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|long_real
name|lr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|lr
operator|.
name|a
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|lr
operator|.
name|b
operator|=
name|get_fs_long
argument_list|(
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|long_to_temp
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_temp_real
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|a
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|b
operator|=
name|get_fs_long
argument_list|(
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|exponent
operator|=
name|get_fs_word
argument_list|(
literal|4
operator|+
operator|(
name|unsigned
name|short
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_short_int
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ti
operator|.
name|a
operator|=
operator|(
name|signed
name|short
operator|)
name|get_fs_word
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|ti
operator|.
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|.
name|sign
operator|=
operator|(
name|ti
operator|.
name|a
operator|<
literal|0
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ti
operator|.
name|a
operator|=
operator|-
name|ti
operator|.
name|a
expr_stmt|;
name|int_to_real
argument_list|(
operator|&
name|ti
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_long_int
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ti
operator|.
name|a
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|ti
operator|.
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|.
name|sign
operator|=
operator|(
name|ti
operator|.
name|a
operator|<
literal|0
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ti
operator|.
name|a
operator|=
operator|-
name|ti
operator|.
name|a
expr_stmt|;
name|int_to_real
argument_list|(
operator|&
name|ti
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_longlong_int
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ti
operator|.
name|a
operator|=
name|get_fs_long
argument_list|(
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|ti
operator|.
name|b
operator|=
name|get_fs_long
argument_list|(
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ti
operator|.
name|sign
operator|=
operator|(
name|ti
operator|.
name|b
operator|<
literal|0
operator|)
operator|)
operator|!=
literal|0
condition|)
asm|__asm__("notl %0 ; notl %1\n\t" 			"addl $1,%0 ; adcl $0,%1" 			:"=r" (ti.a),"=r" (ti.b) 			:"0" (ti.a),"1" (ti.b));
name|int_to_real
argument_list|(
operator|&
name|ti
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MUL10
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|)
define|\
value|__asm__("addl %0,%0 ; adcl %1,%1\n\t" \ "movl %0,%%ecx ; movl %1,%%ebx\n\t" \ "addl %0,%0 ; adcl %1,%1\n\t" \ "addl %0,%0 ; adcl %1,%1\n\t" \ "addl %%ecx,%0 ; adcl %%ebx,%1" \ :"=a" (low),"=d" (high) \ :"0" (low),"1" (high):"cx","bx")
end_define

begin_define
define|#
directive|define
name|ADD64
parameter_list|(
name|val
parameter_list|,
name|low
parameter_list|,
name|high
parameter_list|)
define|\
value|__asm__("addl %4,%0 ; adcl $0,%1":"=r" (low),"=r" (high) \ :"0" (low),"1" (high),"r" ((u_int32_t) (val)))
end_define

begin_function
specifier|static
name|void
name|get_BCD
parameter_list|(
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|i
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|9
expr_stmt|;
name|i
operator|.
name|sign
operator|=
literal|0x80
operator|&
name|get_fs_byte
argument_list|(
name|addr
operator|--
argument_list|)
expr_stmt|;
name|i
operator|.
name|a
operator|=
name|i
operator|.
name|b
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|9
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|get_fs_byte
argument_list|(
name|addr
operator|--
argument_list|)
expr_stmt|;
name|MUL10
argument_list|(
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|)
expr_stmt|;
name|ADD64
argument_list|(
operator|(
name|c
operator|>>
literal|4
operator|)
argument_list|,
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|)
expr_stmt|;
name|MUL10
argument_list|(
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|)
expr_stmt|;
name|ADD64
argument_list|(
operator|(
name|c
operator|&
literal|0xf
operator|)
argument_list|,
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
name|int_to_real
argument_list|(
operator|&
name|i
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_short_real
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|short_real
name|sr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,4);*/
name|temp_to_short
argument_list|(
name|tmp
argument_list|,
operator|&
name|sr
argument_list|)
expr_stmt|;
name|put_fs_long
argument_list|(
name|sr
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_long_real
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|long_real
name|lr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,8);*/
name|temp_to_long
argument_list|(
name|tmp
argument_list|,
operator|&
name|lr
argument_list|)
expr_stmt|;
name|put_fs_long
argument_list|(
name|lr
operator|.
name|a
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|put_fs_long
argument_list|(
name|lr
operator|.
name|b
argument_list|,
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_temp_real
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,10);*/
name|put_fs_long
argument_list|(
name|tmp
operator|->
name|a
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|put_fs_long
argument_list|(
name|tmp
operator|->
name|b
argument_list|,
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|put_fs_word
argument_list|(
name|tmp
operator|->
name|exponent
argument_list|,
literal|4
operator|+
operator|(
name|short
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_short_int
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_int
argument_list|(
name|tmp
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,2);*/
if|if
condition|(
name|ti
operator|.
name|sign
condition|)
name|ti
operator|.
name|a
operator|=
operator|-
name|ti
operator|.
name|a
expr_stmt|;
name|put_fs_word
argument_list|(
name|ti
operator|.
name|a
argument_list|,
operator|(
name|short
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_long_int
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_int
argument_list|(
name|tmp
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,4);*/
if|if
condition|(
name|ti
operator|.
name|sign
condition|)
name|ti
operator|.
name|a
operator|=
operator|-
name|ti
operator|.
name|a
expr_stmt|;
name|put_fs_long
argument_list|(
name|ti
operator|.
name|a
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_longlong_int
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|ti
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|real_to_int
argument_list|(
name|tmp
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,8);*/
if|if
condition|(
name|ti
operator|.
name|sign
condition|)
asm|__asm__("notl %0 ; notl %1\n\t" 			"addl $1,%0 ; adcl $0,%1" 			:"=r" (ti.a),"=r" (ti.b) 			:"0" (ti.a),"1" (ti.b));
name|put_fs_long
argument_list|(
name|ti
operator|.
name|a
argument_list|,
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|put_fs_long
argument_list|(
name|ti
operator|.
name|b
argument_list|,
literal|1
operator|+
operator|(
name|u_int32_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DIV10
parameter_list|(
name|low
parameter_list|,
name|high
parameter_list|,
name|rem
parameter_list|)
define|\
value|__asm__("divl %6 ; xchgl %1,%2 ; divl %6" \ 	:"=d" (rem),"=a" (low),"=r" (high) \ 	:"0" (0),"1" (high),"2" (low),"c" (10))
end_define

begin_function
specifier|static
name|void
name|put_BCD
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|tmp
parameter_list|,
name|struct
name|trapframe
modifier|*
name|info
parameter_list|,
name|unsigned
name|short
name|code
parameter_list|)
block|{
name|int
name|k
decl_stmt|,
name|rem
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|temp_int
name|i
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|addr
operator|=
name|ea
argument_list|(
name|info
argument_list|,
name|code
argument_list|)
expr_stmt|;
comment|/*verify_area(addr,10);*/
name|real_to_int
argument_list|(
name|tmp
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|sign
condition|)
name|put_fs_byte
argument_list|(
literal|0x80
argument_list|,
name|addr
operator|+
literal|9
argument_list|)
expr_stmt|;
else|else
name|put_fs_byte
argument_list|(
literal|0
argument_list|,
name|addr
operator|+
literal|9
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|9
condition|;
name|k
operator|++
control|)
block|{
name|DIV10
argument_list|(
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|c
operator|=
name|rem
expr_stmt|;
name|DIV10
argument_list|(
name|i
operator|.
name|a
argument_list|,
name|i
operator|.
name|b
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|c
operator|+=
name|rem
operator|<<
literal|4
expr_stmt|;
name|put_fs_byte
argument_list|(
name|c
argument_list|,
name|addr
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/mul.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * temporary real multiplication routine.  */
end_comment

begin_function
specifier|static
name|void
name|shift
parameter_list|(
name|int
modifier|*
name|c
parameter_list|)
block|{
asm|__asm__("movl (%0),%%eax ; addl %%eax,(%0)\n\t" 		"movl 4(%0),%%eax ; adcl %%eax,4(%0)\n\t" 		"movl 8(%0),%%eax ; adcl %%eax,8(%0)\n\t" 		"movl 12(%0),%%eax ; adcl %%eax,12(%0)" 		::"r" (c):"ax");
block|}
end_function

begin_function
specifier|static
name|void
name|mul64
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
asm|__asm__("movl (%0),%%eax\n\t" 		"mull (%1)\n\t" 		"movl %%eax,(%2)\n\t" 		"movl %%edx,4(%2)\n\t" 		"movl 4(%0),%%eax\n\t" 		"mull 4(%1)\n\t" 		"movl %%eax,8(%2)\n\t" 		"movl %%edx,12(%2)\n\t" 		"movl (%0),%%eax\n\t" 		"mull 4(%1)\n\t" 		"addl %%eax,4(%2)\n\t" 		"adcl %%edx,8(%2)\n\t" 		"adcl $0,12(%2)\n\t" 		"movl 4(%0),%%eax\n\t" 		"mull (%1)\n\t" 		"addl %%eax,4(%2)\n\t" 		"adcl %%edx,8(%2)\n\t" 		"adcl $0,12(%2)" 		::"S" (a),"c" (b),"D" (c) 		:"ax","dx");
block|}
end_function

begin_function
specifier|static
name|void
name|fmul
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|src1
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|src2
parameter_list|,
name|temp_real
modifier|*
name|result
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|;
name|int
name|tmp
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|sign
operator|=
operator|(
name|src1
operator|->
name|exponent
operator|^
name|src2
operator|->
name|exponent
operator|)
operator|&
literal|0x8000
expr_stmt|;
name|i
operator|=
operator|(
name|src1
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
operator|+
operator|(
name|src2
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
operator|-
literal|16383
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|result
operator|->
name|exponent
operator|=
name|sign
expr_stmt|;
name|result
operator|->
name|a
operator|=
name|result
operator|->
name|b
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|>
literal|0x7fff
condition|)
block|{
name|set_OE
argument_list|()
expr_stmt|;
return|return;
block|}
name|mul64
argument_list|(
name|src1
argument_list|,
name|src2
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|||
name|tmp
index|[
literal|1
index|]
operator|||
name|tmp
index|[
literal|2
index|]
operator|||
name|tmp
index|[
literal|3
index|]
condition|)
while|while
condition|(
name|i
operator|&&
name|tmp
index|[
literal|3
index|]
operator|>=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|shift
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|exponent
operator|=
name|i
operator||
name|sign
expr_stmt|;
name|result
operator|->
name|a
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|result
operator|->
name|b
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/div.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * temporary real division routine.  */
end_comment

begin_function
specifier|static
name|void
name|shift_left
parameter_list|(
name|int
modifier|*
name|c
parameter_list|)
block|{
asm|__asm__
specifier|__volatile__
asm|("movl (%0),%%eax ; addl %%eax,(%0)\n\t" 		"movl 4(%0),%%eax ; adcl %%eax,4(%0)\n\t" 		"movl 8(%0),%%eax ; adcl %%eax,8(%0)\n\t" 		"movl 12(%0),%%eax ; adcl %%eax,12(%0)" 		::"r" (c):"ax");
block|}
end_function

begin_function
specifier|static
name|void
name|shift_right
parameter_list|(
name|int
modifier|*
name|c
parameter_list|)
block|{
asm|__asm__("shrl $1,12(%0) ; rcrl $1,8(%0) ; rcrl $1,4(%0) ; rcrl $1,(%0)" 		::"r" (c));
block|}
end_function

begin_function
specifier|static
name|int
name|try_sub
parameter_list|(
name|int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|b
parameter_list|)
block|{
name|char
name|ok
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|("movl (%1),%%eax ; subl %%eax,(%2)\n\t" 		"movl 4(%1),%%eax ; sbbl %%eax,4(%2)\n\t" 		"movl 8(%1),%%eax ; sbbl %%eax,8(%2)\n\t" 		"movl 12(%1),%%eax ; sbbl %%eax,12(%2)\n\t" 		"setae %%al":"=a" (ok):"c" (a),"d" (b));
return|return
name|ok
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|div64
parameter_list|(
name|int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
block|{
name|int
name|tmp
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|mask
init|=
literal|0
decl_stmt|;
name|c
operator|+=
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|>>=
literal|1
operator|)
condition|)
block|{
name|c
operator|--
expr_stmt|;
name|mask
operator|=
literal|0x80000000UL
expr_stmt|;
block|}
name|tmp
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|0
index|]
expr_stmt|;
name|tmp
index|[
literal|1
index|]
operator|=
name|a
index|[
literal|1
index|]
expr_stmt|;
name|tmp
index|[
literal|2
index|]
operator|=
name|a
index|[
literal|2
index|]
expr_stmt|;
name|tmp
index|[
literal|3
index|]
operator|=
name|a
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|try_sub
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
condition|)
block|{
operator|*
name|c
operator||=
name|mask
expr_stmt|;
name|a
index|[
literal|0
index|]
operator|=
name|tmp
index|[
literal|0
index|]
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
name|tmp
index|[
literal|1
index|]
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|a
index|[
literal|3
index|]
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
block|}
name|shift_right
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fdiv
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|src1
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|src2
parameter_list|,
name|temp_real
modifier|*
name|result
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|sign
decl_stmt|;
name|int
name|a
index|[
literal|4
index|]
decl_stmt|,
name|b
index|[
literal|4
index|]
decl_stmt|,
name|tmp
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|sign
operator|=
operator|(
name|src1
operator|->
name|exponent
operator|^
name|src2
operator|->
name|exponent
operator|)
operator|&
literal|0x8000
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|src2
operator|->
name|a
operator|||
name|src2
operator|->
name|b
operator|)
condition|)
block|{
name|set_ZE
argument_list|()
expr_stmt|;
return|return;
block|}
name|i
operator|=
operator|(
name|src1
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
operator|-
operator|(
name|src2
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
operator|+
literal|16383
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|set_UE
argument_list|()
expr_stmt|;
name|result
operator|->
name|exponent
operator|=
name|sign
expr_stmt|;
name|result
operator|->
name|a
operator|=
name|result
operator|->
name|b
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|a
index|[
literal|0
index|]
operator|=
name|a
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|a
index|[
literal|2
index|]
operator|=
name|src1
operator|->
name|a
expr_stmt|;
name|a
index|[
literal|3
index|]
operator|=
name|src1
operator|->
name|b
expr_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
name|src2
operator|->
name|a
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
name|src2
operator|->
name|b
expr_stmt|;
while|while
condition|(
name|b
index|[
literal|3
index|]
operator|>=
literal|0
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|shift_left
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|div64
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|||
name|tmp
index|[
literal|1
index|]
operator|||
name|tmp
index|[
literal|2
index|]
operator|||
name|tmp
index|[
literal|3
index|]
condition|)
block|{
while|while
condition|(
name|i
operator|&&
name|tmp
index|[
literal|3
index|]
operator|>=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|shift_left
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
index|[
literal|3
index|]
operator|>=
literal|0
condition|)
name|set_DE
argument_list|()
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0x7fff
condition|)
block|{
name|set_OE
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tmp
index|[
literal|0
index|]
operator|||
name|tmp
index|[
literal|1
index|]
condition|)
name|set_PE
argument_list|()
expr_stmt|;
name|result
operator|->
name|exponent
operator|=
name|i
operator||
name|sign
expr_stmt|;
name|result
operator|->
name|a
operator|=
name|tmp
index|[
literal|2
index|]
expr_stmt|;
name|result
operator|->
name|b
operator|=
name|tmp
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/add.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * temporary real addition routine.  *  * NOTE! These aren't exact: they are only 62 bits wide, and don't do  * correct rounding. Fast hack. The reason is that we shift right the  * values by two, in order not to have overflow (1 bit), and to be able  * to move the sign into the mantissa (1 bit). Much simpler algorithms,  * and 62 bits (61 really - no rounding) accuracy is usually enough. The  * only time you should notice anything weird is when adding 64-bit  * integers together. When using doubles (52 bits accuracy), the  * 61-bit accuracy never shows at all.  */
end_comment

begin_define
define|#
directive|define
name|NEGINT
parameter_list|(
name|a
parameter_list|)
define|\
value|__asm__("notl %0 ; notl %1 ; addl $1,%0 ; adcl $0,%1" \ 	:"=r" (a->a),"=r" (a->b) \ 	:"0" (a->a),"1" (a->b))
end_define

begin_function
specifier|static
name|void
name|signify
parameter_list|(
name|temp_real
modifier|*
name|a
parameter_list|)
block|{
name|a
operator|->
name|exponent
operator|+=
literal|2
expr_stmt|;
asm|__asm__("shrdl $2,%1,%0 ; shrl $2,%1" 		:"=r" (a->a),"=r" (a->b) 		:"0" (a->a),"1" (a->b));
if|if
condition|(
name|a
operator|->
name|exponent
operator|<
literal|0
condition|)
name|NEGINT
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|exponent
operator|&=
literal|0x7fff
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unsignify
parameter_list|(
name|temp_real
modifier|*
name|a
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|a
operator|||
name|a
operator|->
name|b
operator|)
condition|)
block|{
name|a
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|a
operator|->
name|exponent
operator|&=
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|b
operator|<
literal|0
condition|)
block|{
name|NEGINT
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|exponent
operator||=
literal|0x8000
expr_stmt|;
block|}
while|while
condition|(
name|a
operator|->
name|b
operator|>=
literal|0
condition|)
block|{
name|a
operator|->
name|exponent
operator|--
expr_stmt|;
asm|__asm__("addl %0,%0 ; adcl %1,%1" 			:"=r" (a->a),"=r" (a->b) 			:"0" (a->a),"1" (a->b));
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fadd
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|src1
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|src2
parameter_list|,
name|temp_real
modifier|*
name|result
parameter_list|)
block|{
name|temp_real
name|a
decl_stmt|,
name|b
decl_stmt|;
name|int
name|x1
decl_stmt|,
name|x2
decl_stmt|,
name|shift
decl_stmt|;
name|x1
operator|=
name|src1
operator|->
name|exponent
operator|&
literal|0x7fff
expr_stmt|;
name|x2
operator|=
name|src2
operator|->
name|exponent
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|x1
operator|>
name|x2
condition|)
block|{
name|a
operator|=
operator|*
name|src1
expr_stmt|;
name|b
operator|=
operator|*
name|src2
expr_stmt|;
name|shift
operator|=
name|x1
operator|-
name|x2
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
operator|*
name|src2
expr_stmt|;
name|b
operator|=
operator|*
name|src1
expr_stmt|;
name|shift
operator|=
name|x2
operator|-
name|x1
expr_stmt|;
block|}
if|if
condition|(
name|shift
operator|>=
literal|64
condition|)
block|{
operator|*
name|result
operator|=
name|a
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
block|{
name|b
operator|.
name|a
operator|=
name|b
operator|.
name|b
expr_stmt|;
name|b
operator|.
name|b
operator|=
literal|0
expr_stmt|;
name|shift
operator|-=
literal|32
expr_stmt|;
block|}
asm|__asm__("shrdl %4,%1,%0 ; shrl %4,%1" 		:"=r" (b.a),"=r" (b.b) 		:"0" (b.a),"1" (b.b),"c" ((char) shift));
name|signify
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|signify
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
asm|__asm__("addl %4,%0 ; adcl %5,%1" 		:"=r" (a.a),"=r" (a.b) 		:"0" (a.a),"1" (a.b),"g" (b.a),"g" (b.b));
name|unsignify
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/compare.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * temporary real comparison routines  */
end_comment

begin_define
define|#
directive|define
name|clear_Cx
parameter_list|()
value|(I387.swd&= ~0x4500)
end_define

begin_function
specifier|static
name|void
name|normalize
parameter_list|(
name|temp_real
modifier|*
name|a
parameter_list|)
block|{
name|int
name|i
init|=
name|a
operator|->
name|exponent
operator|&
literal|0x7fff
decl_stmt|;
name|int
name|sign
init|=
name|a
operator|->
name|exponent
operator|&
literal|0x8000
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|a
operator|||
name|a
operator|->
name|b
operator|)
condition|)
block|{
name|a
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|i
operator|&&
name|a
operator|->
name|b
operator|>=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
asm|__asm__("addl %0,%0 ; adcl %1,%1" 			:"=r" (a->a),"=r" (a->b) 			:"0" (a->a),"1" (a->b));
block|}
name|a
operator|->
name|exponent
operator|=
name|i
operator||
name|sign
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ftst
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|)
block|{
name|temp_real
name|b
decl_stmt|;
name|clear_Cx
argument_list|()
expr_stmt|;
name|b
operator|=
operator|*
name|a
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|.
name|a
operator|||
name|b
operator|.
name|b
operator|||
name|b
operator|.
name|exponent
condition|)
block|{
if|if
condition|(
name|b
operator|.
name|exponent
operator|<
literal|0
condition|)
name|set_C0
argument_list|()
expr_stmt|;
block|}
else|else
name|set_C3
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fcom
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|src1
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|src2
parameter_list|)
block|{
name|temp_real
name|a
decl_stmt|;
name|a
operator|=
operator|*
name|src1
expr_stmt|;
name|a
operator|.
name|exponent
operator|^=
literal|0x8000
expr_stmt|;
name|fadd
argument_list|(
operator|&
name|a
argument_list|,
name|src2
argument_list|,
operator|&
name|a
argument_list|)
expr_stmt|;
name|ftst
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fucom
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|src1
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|src2
parameter_list|)
block|{
name|fcom
argument_list|(
name|src1
argument_list|,
name|src2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * linux/kernel/math/convert.c  *  * (C) 1991 Linus Torvalds  */
end_comment

begin_comment
comment|/*  * NOTE!!! There is some "non-obvious" optimisations in the temp_to_long  * and temp_to_short conversion routines: don't touch them if you don't  * know what's going on. They are the adding of one in the rounding: the  * overflow bit is also used for adding one into the exponent. Thus it  * looks like the overflow would be incorrectly handled, but due to the  * way the IEEE numbers work, things are correct.  *  * There is no checking for total overflow in the conversions, though (ie  * if the temp-real number simply won't fit in a short- or long-real.)  */
end_comment

begin_function
specifier|static
name|void
name|short_to_temp
parameter_list|(
specifier|const
name|short_real
modifier|*
name|a
parameter_list|,
name|temp_real
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|a
operator|&
literal|0x7fffffff
operator|)
condition|)
block|{
name|b
operator|->
name|a
operator|=
name|b
operator|->
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|a
condition|)
name|b
operator|->
name|exponent
operator|=
literal|0x8000
expr_stmt|;
else|else
name|b
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|exponent
operator|=
operator|(
operator|(
operator|*
name|a
operator|>>
literal|23
operator|)
operator|&
literal|0xff
operator|)
operator|-
literal|127
operator|+
literal|16383
expr_stmt|;
if|if
condition|(
operator|*
name|a
operator|<
literal|0
condition|)
name|b
operator|->
name|exponent
operator||=
literal|0x8000
expr_stmt|;
name|b
operator|->
name|b
operator|=
operator|(
operator|*
name|a
operator|<<
literal|8
operator|)
operator||
literal|0x80000000UL
expr_stmt|;
name|b
operator|->
name|a
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|long_to_temp
parameter_list|(
specifier|const
name|long_real
modifier|*
name|a
parameter_list|,
name|temp_real
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|a
operator|->
name|a
operator|&&
operator|!
operator|(
name|a
operator|->
name|b
operator|&
literal|0x7fffffff
operator|)
condition|)
block|{
name|b
operator|->
name|a
operator|=
name|b
operator|->
name|b
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|b
condition|)
name|b
operator|->
name|exponent
operator|=
literal|0x8000
expr_stmt|;
else|else
name|b
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|exponent
operator|=
operator|(
operator|(
name|a
operator|->
name|b
operator|>>
literal|20
operator|)
operator|&
literal|0x7ff
operator|)
operator|-
literal|1023
operator|+
literal|16383
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|b
operator|<
literal|0
condition|)
name|b
operator|->
name|exponent
operator||=
literal|0x8000
expr_stmt|;
name|b
operator|->
name|b
operator|=
literal|0x80000000UL
operator||
operator|(
name|a
operator|->
name|b
operator|<<
literal|11
operator|)
operator||
operator|(
operator|(
operator|(
name|u_int32_t
operator|)
name|a
operator|->
name|a
operator|)
operator|>>
literal|21
operator|)
expr_stmt|;
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|a
operator|<<
literal|11
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|temp_to_short
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
name|short_real
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
condition|)
block|{
operator|*
name|b
operator|=
operator|(
name|a
operator|->
name|exponent
operator|)
condition|?
literal|0x80000000UL
else|:
literal|0
expr_stmt|;
return|return;
block|}
operator|*
name|b
operator|=
operator|(
operator|(
operator|(
operator|(
name|int32_t
operator|)
name|a
operator|->
name|exponent
operator|)
operator|-
literal|16383
operator|+
literal|127
operator|)
operator|<<
literal|23
operator|)
operator|&
literal|0x7f800000
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|exponent
operator|<
literal|0
condition|)
operator|*
name|b
operator||=
literal|0x80000000UL
expr_stmt|;
operator|*
name|b
operator||=
operator|(
name|a
operator|->
name|b
operator|>>
literal|8
operator|)
operator|&
literal|0x007fffff
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ROUNDING
condition|)
block|{
case|case
name|ROUND_NEAREST
case|:
if|if
condition|(
operator|(
name|a
operator|->
name|b
operator|&
literal|0xff
operator|)
operator|>
literal|0x80
condition|)
operator|++
operator|*
name|b
expr_stmt|;
break|break;
case|case
name|ROUND_DOWN
case|:
if|if
condition|(
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x8000
operator|)
operator|&&
operator|(
name|a
operator|->
name|b
operator|&
literal|0xff
operator|)
condition|)
operator|++
operator|*
name|b
expr_stmt|;
break|break;
case|case
name|ROUND_UP
case|:
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x8000
operator|)
operator|&&
operator|(
name|a
operator|->
name|b
operator|&
literal|0xff
operator|)
condition|)
operator|++
operator|*
name|b
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|temp_to_long
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
name|long_real
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
condition|)
block|{
name|b
operator|->
name|a
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|b
operator|=
operator|(
name|a
operator|->
name|exponent
operator|)
condition|?
literal|0x80000000UL
else|:
literal|0
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|b
operator|=
operator|(
operator|(
operator|(
literal|0x7fff
operator|&
operator|(
name|int32_t
operator|)
name|a
operator|->
name|exponent
operator|)
operator|-
literal|16383
operator|+
literal|1023
operator|)
operator|<<
literal|20
operator|)
operator|&
literal|0x7ff00000
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|exponent
operator|<
literal|0
condition|)
name|b
operator|->
name|b
operator||=
literal|0x80000000UL
expr_stmt|;
name|b
operator|->
name|b
operator||=
operator|(
name|a
operator|->
name|b
operator|>>
literal|11
operator|)
operator|&
literal|0x000fffff
expr_stmt|;
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|b
operator|<<
literal|21
expr_stmt|;
name|b
operator|->
name|a
operator||=
operator|(
name|a
operator|->
name|a
operator|>>
literal|11
operator|)
operator|&
literal|0x001fffff
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|ROUNDING
condition|)
block|{
case|case
name|ROUND_NEAREST
case|:
if|if
condition|(
operator|(
name|a
operator|->
name|a
operator|&
literal|0x7ff
operator|)
operator|>
literal|0x400
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
case|case
name|ROUND_DOWN
case|:
if|if
condition|(
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x8000
operator|)
operator|&&
operator|(
name|a
operator|->
name|b
operator|&
literal|0xff
operator|)
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
case|case
name|ROUND_UP
case|:
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x8000
operator|)
operator|&&
operator|(
name|a
operator|->
name|b
operator|&
literal|0xff
operator|)
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|frndint
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
name|temp_real
modifier|*
name|b
parameter_list|)
block|{
name|int
name|shift
init|=
literal|16383
operator|+
literal|63
operator|-
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
decl_stmt|;
name|u_int32_t
name|underflow
decl_stmt|;
if|if
condition|(
operator|(
name|shift
operator|<
literal|0
operator|)
operator|||
operator|(
name|shift
operator|==
literal|16383
operator|+
literal|63
operator|)
condition|)
block|{
operator|*
name|b
operator|=
operator|*
name|a
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|a
operator|=
name|b
operator|->
name|b
operator|=
name|underflow
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|exponent
operator|=
name|a
operator|->
name|exponent
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
block|{
name|b
operator|->
name|b
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|64
condition|)
block|{
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|underflow
operator|=
name|a
operator|->
name|a
expr_stmt|;
name|shift
operator|-=
literal|32
expr_stmt|;
name|b
operator|->
name|exponent
operator|+=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|96
condition|)
block|{
name|underflow
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|shift
operator|-=
literal|64
expr_stmt|;
name|b
operator|->
name|exponent
operator|+=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|underflow
operator|=
literal|1
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
block|}
name|b
operator|->
name|exponent
operator|+=
name|shift
expr_stmt|;
asm|__asm__("shrdl %2,%1,%0" 		:"=r" (underflow),"=r" (b->a) 		:"c" ((char) shift),"0" (underflow),"1" (b->a));
asm|__asm__("shrdl %2,%1,%0" 		:"=r" (b->a),"=r" (b->b) 		:"c" ((char) shift),"0" (b->a),"1" (b->b));
asm|__asm__("shrl %1,%0" 		:"=r" (b->b) 		:"c" ((char) shift),"0" (b->b));
switch|switch
condition|(
operator|(
name|int
operator|)
name|ROUNDING
condition|)
block|{
case|case
name|ROUND_NEAREST
case|:
asm|__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1" 				:"=r" (b->a),"=r" (b->b) 				:"0" (b->a),"1" (b->b) 				,"r" (0x7fffffff + (b->a& 1)) 				,"m" (*&underflow));
break|break;
case|case
name|ROUND_UP
case|:
if|if
condition|(
operator|(
name|b
operator|->
name|exponent
operator|>=
literal|0
operator|)
operator|&&
name|underflow
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
case|case
name|ROUND_DOWN
case|:
if|if
condition|(
operator|(
name|b
operator|->
name|exponent
operator|<
literal|0
operator|)
operator|&&
name|underflow
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
block|}
if|if
condition|(
name|b
operator|->
name|a
operator|||
name|b
operator|->
name|b
condition|)
while|while
condition|(
name|b
operator|->
name|b
operator|>=
literal|0
condition|)
block|{
name|b
operator|->
name|exponent
operator|--
expr_stmt|;
asm|__asm__("addl %0,%0 ; adcl %1,%1" 				:"=r" (b->a),"=r" (b->b) 				:"0" (b->a),"1" (b->b));
block|}
else|else
name|b
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Fscale
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
specifier|const
name|temp_real
modifier|*
name|b
parameter_list|,
name|temp_real
modifier|*
name|c
parameter_list|)
block|{
name|temp_int
name|ti
decl_stmt|;
operator|*
name|c
operator|=
operator|*
name|a
expr_stmt|;
if|if
condition|(
operator|!
name|c
operator|->
name|a
operator|&&
operator|!
name|c
operator|->
name|b
condition|)
block|{
comment|/* 19 Sep 92*/
name|c
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|real_to_int
argument_list|(
name|b
argument_list|,
operator|&
name|ti
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|.
name|sign
condition|)
name|c
operator|->
name|exponent
operator|-=
name|ti
operator|.
name|a
expr_stmt|;
else|else
name|c
operator|->
name|exponent
operator|+=
name|ti
operator|.
name|a
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|real_to_int
parameter_list|(
specifier|const
name|temp_real
modifier|*
name|a
parameter_list|,
name|temp_int
modifier|*
name|b
parameter_list|)
block|{
name|int
name|shift
init|=
literal|16383
operator|+
literal|63
operator|-
operator|(
name|a
operator|->
name|exponent
operator|&
literal|0x7fff
operator|)
decl_stmt|;
name|u_int32_t
name|underflow
decl_stmt|;
name|b
operator|->
name|a
operator|=
name|b
operator|->
name|b
operator|=
name|underflow
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|sign
operator|=
operator|(
name|a
operator|->
name|exponent
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
block|{
name|set_OE
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|shift
operator|<
literal|32
condition|)
block|{
name|b
operator|->
name|b
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|a
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|64
condition|)
block|{
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|underflow
operator|=
name|a
operator|->
name|a
expr_stmt|;
name|shift
operator|-=
literal|32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shift
operator|<
literal|96
condition|)
block|{
name|underflow
operator|=
name|a
operator|->
name|b
expr_stmt|;
name|shift
operator|-=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|underflow
operator|=
literal|1
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
block|}
asm|__asm__("shrdl %2,%1,%0" 		:"=r" (underflow),"=r" (b->a) 		:"c" ((char) shift),"0" (underflow),"1" (b->a));
asm|__asm__("shrdl %2,%1,%0" 		:"=r" (b->a),"=r" (b->b) 		:"c" ((char) shift),"0" (b->a),"1" (b->b));
asm|__asm__("shrl %1,%0" 		:"=r" (b->b) 		:"c" ((char) shift),"0" (b->b));
switch|switch
condition|(
operator|(
name|int
operator|)
name|ROUNDING
condition|)
block|{
case|case
name|ROUND_NEAREST
case|:
asm|__asm__("addl %4,%5 ; adcl $0,%0 ; adcl $0,%1" 				:"=r" (b->a),"=r" (b->b) 				:"0" (b->a),"1" (b->b) 				,"r" (0x7fffffff + (b->a& 1)) 				,"m" (*&underflow));
break|break;
case|case
name|ROUND_UP
case|:
if|if
condition|(
operator|!
name|b
operator|->
name|sign
operator|&&
name|underflow
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
case|case
name|ROUND_DOWN
case|:
if|if
condition|(
name|b
operator|->
name|sign
operator|&&
name|underflow
condition|)
asm|__asm__("addl $1,%0 ; adcl $0,%1" 					:"=r" (b->a),"=r" (b->b) 					:"0" (b->a),"1" (b->b));
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|int_to_real
parameter_list|(
specifier|const
name|temp_int
modifier|*
name|a
parameter_list|,
name|temp_real
modifier|*
name|b
parameter_list|)
block|{
name|b
operator|->
name|a
operator|=
name|a
operator|->
name|a
expr_stmt|;
name|b
operator|->
name|b
operator|=
name|a
operator|->
name|b
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|a
operator|||
name|b
operator|->
name|b
condition|)
name|b
operator|->
name|exponent
operator|=
literal|16383
operator|+
literal|63
operator|+
operator|(
name|a
operator|->
name|sign
condition|?
literal|0x8000
else|:
literal|0
operator|)
expr_stmt|;
else|else
block|{
name|b
operator|->
name|exponent
operator|=
literal|0
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|b
operator|->
name|b
operator|>=
literal|0
condition|)
block|{
name|b
operator|->
name|exponent
operator|--
expr_stmt|;
asm|__asm__("addl %0,%0 ; adcl %1,%1" 			:"=r" (b->a),"=r" (b->b) 			:"0" (b->a),"1" (b->b));
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fpu_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|pmath_emulate
condition|)
block|{
name|printf
argument_list|(
literal|"Another Math emulator already present\n"
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|pmath_emulate
operator|=
name|math_emulate
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Math emulator present\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|pmath_emulate
operator|!=
name|math_emulate
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot unload another math emulator\n"
argument_list|)
expr_stmt|;
return|return
name|EACCES
return|;
block|}
name|pmath_emulate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Math emulator unloaded\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|fpumod
init|=
block|{
literal|"fpu"
block|,
name|fpu_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|fpu
argument_list|,
name|fpumod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

