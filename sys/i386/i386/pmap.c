begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  *	$Id: pmap.c,v 1.5 1993/10/12 13:53:25 rgrimes Exp $  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: pmap.c,v 1.5 1993/10/12 13:53:25 rgrimes Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Derived from hp300 version by Mike Hibler, this version by William  * Jolitz uses a recursive map [a pde points to the page directory] to  * map the page tables using the pagetables themselves. This is done to  * reduce the impact on kernel virtual memory for lots of sparse address  * space, and to reduce the cost of memory to each process.  *  *	Derived from: hp300/@(#)pmap.c	7.1 (Berkeley) 12/5/90  */
end_comment

begin_comment
comment|/*  *	Reno i386 version, from Mike Hibler's hp300 version.  */
end_comment

begin_comment
comment|/*  *	Manages physical address maps.  *  *	In addition to hardware address maps, this  *	module is called upon to provide software-use-only  *	maps which may or may not be stored in the same  *	form as hardware maps.  These pseudo-maps are  *	used to store intermediate results from copy  *	operations to and from address spaces.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_page.h"
end_include

begin_comment
comment|/*#include "vm/vm_pageout.h"*/
end_comment

begin_include
include|#
directive|include
file|"i386/isa/isa.h"
end_include

begin_comment
comment|/*  * Allocate various and sundry SYSMAPs used in the days of old VM  * and not yet converted.  XXX.  */
end_comment

begin_define
define|#
directive|define
name|BSDVM_COMPAT
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_struct
struct|struct
block|{
name|int
name|kernel
decl_stmt|;
comment|/* entering kernel mapping */
name|int
name|user
decl_stmt|;
comment|/* entering user mapping */
name|int
name|ptpneeded
decl_stmt|;
comment|/* needed to allocate a PT page */
name|int
name|pwchange
decl_stmt|;
comment|/* no mapping change, just wiring or protection */
name|int
name|wchange
decl_stmt|;
comment|/* no mapping change, just wiring */
name|int
name|mchange
decl_stmt|;
comment|/* was mapped but mapping to different page */
name|int
name|managed
decl_stmt|;
comment|/* a managed page */
name|int
name|firstpv
decl_stmt|;
comment|/* first mapping for this PA */
name|int
name|secondpv
decl_stmt|;
comment|/* second mapping for this PA */
name|int
name|ci
decl_stmt|;
comment|/* cache inhibited */
name|int
name|unmanaged
decl_stmt|;
comment|/* not a managed page */
name|int
name|flushes
decl_stmt|;
comment|/* cache flushes */
block|}
name|enter_stats
struct|;
end_struct

begin_struct
struct|struct
block|{
name|int
name|calls
decl_stmt|;
name|int
name|removes
decl_stmt|;
name|int
name|pvfirst
decl_stmt|;
name|int
name|pvsearch
decl_stmt|;
name|int
name|ptinvalid
decl_stmt|;
name|int
name|uflushes
decl_stmt|;
name|int
name|sflushes
decl_stmt|;
block|}
name|remove_stats
struct|;
end_struct

begin_decl_stmt
name|int
name|debugmap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmapdebug
init|=
literal|0
comment|/* 0xffff */
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PDB_FOLLOW
value|0x0001
end_define

begin_define
define|#
directive|define
name|PDB_INIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|PDB_ENTER
value|0x0004
end_define

begin_define
define|#
directive|define
name|PDB_REMOVE
value|0x0008
end_define

begin_define
define|#
directive|define
name|PDB_CREATE
value|0x0010
end_define

begin_define
define|#
directive|define
name|PDB_PTPAGE
value|0x0020
end_define

begin_define
define|#
directive|define
name|PDB_CACHE
value|0x0040
end_define

begin_define
define|#
directive|define
name|PDB_BITS
value|0x0080
end_define

begin_define
define|#
directive|define
name|PDB_COLLECT
value|0x0100
end_define

begin_define
define|#
directive|define
name|PDB_PROTECT
value|0x0200
end_define

begin_define
define|#
directive|define
name|PDB_PDRTAB
value|0x0400
end_define

begin_define
define|#
directive|define
name|PDB_PARANOIA
value|0x2000
end_define

begin_define
define|#
directive|define
name|PDB_WIRING
value|0x4000
end_define

begin_define
define|#
directive|define
name|PDB_PVDUMP
value|0x8000
end_define

begin_decl_stmt
name|int
name|pmapvacflush
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PVF_ENTER
value|0x01
end_define

begin_define
define|#
directive|define
name|PVF_REMOVE
value|0x02
end_define

begin_define
define|#
directive|define
name|PVF_PROTECT
value|0x04
end_define

begin_define
define|#
directive|define
name|PVF_TOTAL
value|0x80
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get PDEs and PTEs for user/kernel address space  */
end_comment

begin_define
define|#
directive|define
name|pmap_pde
parameter_list|(
name|m
parameter_list|,
name|v
parameter_list|)
value|(&((m)->pm_pdir[((vm_offset_t)(v)>> PD_SHIFT)&1023]))
end_define

begin_define
define|#
directive|define
name|pmap_pte_pa
parameter_list|(
name|pte
parameter_list|)
value|(*(int *)(pte)& PG_FRAME)
end_define

begin_define
define|#
directive|define
name|pmap_pde_v
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pd_v)
end_define

begin_define
define|#
directive|define
name|pmap_pte_w
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pg_w)
end_define

begin_comment
comment|/* #define pmap_pte_ci(pte)	((pte)->pg_ci) */
end_comment

begin_define
define|#
directive|define
name|pmap_pte_m
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pg_m)
end_define

begin_define
define|#
directive|define
name|pmap_pte_u
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pg_u)
end_define

begin_define
define|#
directive|define
name|pmap_pte_v
parameter_list|(
name|pte
parameter_list|)
value|((pte)->pg_v)
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_w
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((pte)->pg_w = (v))
end_define

begin_define
define|#
directive|define
name|pmap_pte_set_prot
parameter_list|(
name|pte
parameter_list|,
name|v
parameter_list|)
value|((pte)->pg_prot = (v))
end_define

begin_comment
comment|/*  * Given a map and a machine independent protection code,  * convert to a vax protection code.  */
end_comment

begin_define
define|#
directive|define
name|pte_prot
parameter_list|(
name|m
parameter_list|,
name|p
parameter_list|)
value|(protection_codes[p])
end_define

begin_decl_stmt
name|int
name|protection_codes
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|kernel_pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first available physical page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of last available physical page */
end_comment

begin_decl_stmt
name|vm_size_t
name|mem_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory size in bytes */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss)*/
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|vm_first_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA of first managed page */
end_comment

begin_decl_stmt
name|vm_offset_t
name|vm_last_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PA just past last managed page */
end_comment

begin_decl_stmt
name|int
name|i386pagesperpage
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PAGE_SIZE / NBPG */
end_comment

begin_decl_stmt
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Has pmap_init completed? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|pmap_attributes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reference and modify bits */
end_comment

begin_function_decl
name|boolean_t
name|pmap_testbit
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pmap_clear_modify
parameter_list|()
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|BSDVM_COMPAT
end_if

begin_include
include|#
directive|include
file|"msgbuf.h"
end_include

begin_comment
comment|/*  * All those kernel PT submaps that BSD is so fond of  */
end_comment

begin_decl_stmt
name|struct
name|pte
modifier|*
name|CMAP1
decl_stmt|,
modifier|*
name|CMAP2
decl_stmt|,
modifier|*
name|mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|CADDR1
decl_stmt|,
name|CADDR2
decl_stmt|,
name|vmmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pte
modifier|*
name|msgbufmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  *	Map the kernel's code and data, and allocate the system page table.  *  *	On the I386 this is called after mapping has already been enabled  *	and just syncs the pmap module with what has already been done.  *	[We can't call it easily with mapping off since the kernel is not  *	mapped with PA == VA, hence we would have to relocate every address  *	from the linked base (virtual) address KERNBASE to the actual  *	(physical) address starting relative to 0]  */
end_comment

begin_function_decl
name|struct
name|pte
modifier|*
name|pmap_pte
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|firstaddr
parameter_list|,
name|loadaddr
parameter_list|)
name|vm_offset_t
name|firstaddr
decl_stmt|;
name|vm_offset_t
name|loadaddr
decl_stmt|;
block|{
if|#
directive|if
name|BSDVM_COMPAT
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|pte
modifier|*
name|pte
decl_stmt|;
endif|#
directive|endif
specifier|extern
name|vm_offset_t
name|maxmem
decl_stmt|,
name|physmem
decl_stmt|;
specifier|extern
name|int
name|IdlePTD
decl_stmt|;
name|avail_start
operator|=
name|firstaddr
operator|+
literal|8
operator|*
name|NBPG
expr_stmt|;
name|avail_end
operator|=
name|maxmem
operator|<<
name|PG_SHIFT
expr_stmt|;
comment|/* XXX: allow for msgbuf */
name|avail_end
operator|-=
name|i386_round_page
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgbuf
argument_list|)
argument_list|)
expr_stmt|;
name|mem_size
operator|=
name|physmem
operator|<<
name|PG_SHIFT
expr_stmt|;
name|virtual_avail
operator|=
operator|(
name|vm_offset_t
operator|)
name|atdevbase
operator|+
literal|0x100000
operator|-
literal|0xa0000
operator|+
literal|10
operator|*
name|NBPG
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
name|i386pagesperpage
operator|=
name|PAGE_SIZE
operator|/
name|NBPG
expr_stmt|;
comment|/* 	 * Initialize protection array. 	 */
name|i386_protection_init
argument_list|()
expr_stmt|;
comment|/* 	 * The kernel's pmap is statically allocated so we don't 	 * have to use pmap_create, which is unlikely to work 	 * correctly at this part of the boot sequence. 	 */
name|kernel_pmap
operator|=
operator|&
name|kernel_pmap_store
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* 	 * Create Kernel page directory table and page maps. 	 * [ currently done in locore. i have wild and crazy ideas -wfj ] 	 * XXX IF THIS IS EVER USED, IT MUST BE MOVED TO THE TOP 	 *	OF THIS ROUTINE -- cgd 	 */
name|bzero
argument_list|(
name|firstaddr
argument_list|,
literal|4
operator|*
name|NBPG
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_pdir
operator|=
name|firstaddr
operator|+
name|VM_MIN_KERNEL_ADDRESS
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_ptab
operator|=
name|firstaddr
operator|+
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|NBPG
expr_stmt|;
name|firstaddr
operator|+=
name|NBPG
expr_stmt|;
for|for
control|(
name|x
operator|=
name|i386_btod
argument_list|(
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
init|;
name|x
operator|<
name|i386_btod
argument_list|(
name|VM_MIN_KERNEL_ADDRESS
argument_list|)
operator|+
literal|3
condition|;
name|x
operator|++
control|)
block|{
name|struct
name|pde
modifier|*
name|pde
decl_stmt|;
name|pde
operator|=
name|kernel_pmap
operator|->
name|pm_pdir
operator|+
name|x
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pde
operator|=
name|firstaddr
operator|+
name|x
operator|*
name|NBPG
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
block|}
else|#
directive|else
name|kernel_pmap
operator|->
name|pm_pdir
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|IdlePTD
operator|)
expr_stmt|;
endif|#
directive|endif
name|simple_lock_init
argument_list|(
operator|&
name|kernel_pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|kernel_pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|BSDVM_COMPAT
comment|/* 	 * Allocate all the submaps we need 	 */
define|#
directive|define
name|SYSMAP
parameter_list|(
name|c
parameter_list|,
name|p
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|v = (c)va; va += ((n)*NBPG); p = pte; pte += (n);
name|va
operator|=
name|virtual_avail
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|CMAP1
argument_list|,
argument|CADDR1
argument_list|,
literal|1
argument_list|)
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|CMAP2
argument_list|,
argument|CADDR2
argument_list|,
literal|1
argument_list|)
name|SYSMAP
argument_list|(
argument|caddr_t
argument_list|,
argument|mmap
argument_list|,
argument|vmmap
argument_list|,
literal|1
argument_list|)
name|SYSMAP
argument_list|(
argument|struct msgbuf *
argument_list|,
argument|msgbufmap
argument_list|,
argument|msgbufp
argument_list|,
literal|1
argument_list|)
name|virtual_avail
operator|=
name|va
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * reserve special hunk of memory for use by bus dma as a bounce 	 * buffer (contiguous virtual *and* physical memory). 	 * do it from firstaddr -> firstaddr+8 pages.  note that 	 * avail_start was bumped up 8 pages, above, to accomodate this. 	 */
block|{
specifier|extern
name|vm_offset_t
name|isaphysmem
decl_stmt|;
name|isaphysmem
operator|=
name|va
expr_stmt|;
name|virtual_avail
operator|=
name|pmap_map
argument_list|(
name|va
argument_list|,
name|firstaddr
argument_list|,
name|firstaddr
operator|+
literal|8
operator|*
name|NBPG
argument_list|,
name|VM_PROT_ALL
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
literal|0
expr_stmt|;
name|load_cr3
argument_list|(
name|rcr3
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|phys_start
parameter_list|,
name|phys_end
parameter_list|)
name|vm_offset_t
name|phys_start
decl_stmt|,
name|phys_end
decl_stmt|;
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|addr2
decl_stmt|;
name|vm_size_t
name|npg
decl_stmt|,
name|s
decl_stmt|;
name|int
name|rv
decl_stmt|;
specifier|extern
name|int
name|KPTphys
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_init(%x, %x)\n"
argument_list|,
name|phys_start
argument_list|,
name|phys_end
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now that kernel map has been allocated, we can mark as 	 * unavailable regions which we have mapped in locore. 	 */
name|addr
operator|=
name|atdevbase
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
operator|(
name|vm_offset_t
operator|)
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
operator|(
literal|0x100000
operator|-
literal|0xa0000
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|KERNBASE
operator|+
name|KPTphys
comment|/* *NBPG */
expr_stmt|;
name|vm_object_reference
argument_list|(
name|kernel_object
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|kernel_object
argument_list|,
name|addr
argument_list|,
operator|&
name|addr
argument_list|,
literal|2
operator|*
name|NBPG
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate memory for random pmap data structures.  Includes the 	 * pv_head_table and pmap_attributes. 	 */
name|npg
operator|=
name|atop
argument_list|(
name|phys_end
operator|-
name|phys_start
argument_list|)
expr_stmt|;
name|s
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|*
name|npg
operator|+
name|npg
argument_list|)
expr_stmt|;
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pv_table
operator|=
operator|(
name|pv_entry_t
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
operator|*
name|npg
expr_stmt|;
name|pmap_attributes
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_INIT
condition|)
name|printf
argument_list|(
literal|"pmap_init: %x bytes (%x pgs): tbl %x attr %x\n"
argument_list|,
name|s
argument_list|,
name|npg
argument_list|,
name|pv_table
argument_list|,
name|pmap_attributes
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Now it is safe to enable pv_table recording. 	 */
name|vm_first_phys
operator|=
name|phys_start
expr_stmt|;
name|vm_last_phys
operator|=
name|phys_end
expr_stmt|;
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	For now, VM is already on, we only need to map the  *	specified memory.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|virt
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|virt
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_offset_t
name|end
decl_stmt|;
name|int
name|prot
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_map(%x, %x, %x, %x)\n"
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
name|virt
argument_list|,
name|start
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|virt
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|start
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|virt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Create and return a physical map.  *  *	If the size specified for the map  *	is zero, the map is an actual physical  *	map, and may be referenced by the  *	hardware.  *  *	If the size specified is non-zero,  *	the map will be used in software only, and  *	is bounded by that size.  *  * [ just allocate a ptd and mark it uninitialize -- should we track  *   with a table which process has which ptd? -wfj ]  */
end_comment

begin_function
name|pmap_t
name|pmap_create
parameter_list|(
name|size
parameter_list|)
name|vm_size_t
name|size
decl_stmt|;
block|{
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_create(%x)\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Software use map does not need a pmap 	 */
if|if
condition|(
name|size
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX: is it ok to wait here? */
name|pmap
operator|=
operator|(
name|pmap_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notifwewait
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_create: cannot allocate a pmap"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
name|pmap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pmap
argument_list|)
argument_list|)
expr_stmt|;
name|pmap_pinit
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure,  * such as one in a vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_CREATE
operator|)
condition|)
name|pg
argument_list|(
literal|"pmap_pinit(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * No need to allocate page table space yet but we do need a 	 * valid page directory table. 	 */
name|pmap
operator|->
name|pm_pdir
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
comment|/* wire in kernel global address entries */
name|bcopy
argument_list|(
name|PTD
operator|+
name|KPTDI
argument_list|,
name|pmap
operator|->
name|pm_pdir
operator|+
name|KPTDI
argument_list|,
name|NKPDE
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* install self-referential address mapping entry */
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|pmap
operator|->
name|pm_pdir
operator|+
name|PTDPTDI
operator|)
operator|=
operator|(
name|int
operator|)
name|pmap_extract
argument_list|(
name|kernel_pmap
argument_list|,
name|pmap
operator|->
name|pm_pdir
argument_list|)
operator||
name|PG_V
operator||
name|PG_KW
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|simple_lock_init
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Retire the given physical map from service.  *	Should only be called if the map contains  *	no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_destroy(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|count
operator|=
operator|--
name|pmap
operator|->
name|pm_count
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|pmap_release
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|pmap
argument_list|,
name|M_VMPMAP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap
parameter_list|)
specifier|register
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|pg
argument_list|(
literal|"pmap_release(%x)\n"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notdef
comment|/* DIAGNOSTIC */
comment|/* count would be 0 from pmap_destroy... */
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_count
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_release count"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_pdir
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_reference(%x)"
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|NULL
condition|)
block|{
name|simple_lock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_count
operator|++
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|pmap
operator|->
name|pm_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|)
name|struct
name|pmap
modifier|*
name|pmap
decl_stmt|;
specifier|register
name|vm_offset_t
name|sva
decl_stmt|;
specifier|register
name|vm_offset_t
name|eva
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|ptp
decl_stmt|,
modifier|*
name|ptq
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|ix
decl_stmt|;
name|int
name|s
decl_stmt|,
name|bits
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|pt_entry_t
name|opte
decl_stmt|;
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|pg
argument_list|(
literal|"pmap_remove(%x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
comment|/* are we current address space or kernel? */
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|==
name|PTDpde
operator|.
name|pd_pfnum
operator|||
name|pmap
operator|==
name|kernel_pmap
condition|)
name|ptp
operator|=
name|PTmap
expr_stmt|;
comment|/* otherwise, we are alternate address space */
else|else
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|!=
name|APTDpde
operator|.
name|pd_pfnum
condition|)
block|{
name|APTDpde
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
expr_stmt|;
name|tlbflush
argument_list|()
expr_stmt|;
block|}
name|ptp
operator|=
name|APTmap
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|calls
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* this is essential since we must check the PDE(sva) for precense */
while|while
condition|(
name|sva
operator|<=
name|eva
operator|&&
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
argument_list|)
condition|)
name|sva
operator|=
operator|(
name|sva
operator|&
name|PD_MASK
operator|)
operator|+
operator|(
literal|1
operator|<<
name|PD_SHIFT
operator|)
expr_stmt|;
name|sva
operator|=
name|i386_btop
argument_list|(
name|sva
argument_list|)
expr_stmt|;
name|eva
operator|=
name|i386_btop
argument_list|(
name|eva
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|++
control|)
block|{
comment|/* 		 * Weed out invalid mappings. 		 * Note: we assume that the page directory table is 	 	 * always allocated, and in kernel virtual. 		 */
name|ptq
operator|=
name|ptp
operator|+
name|sva
expr_stmt|;
while|while
condition|(
operator|(
name|sva
operator|&
literal|0x3ff
operator|)
operator|&&
operator|!
name|pmap_pte_pa
argument_list|(
name|ptq
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|sva
operator|>=
name|eva
condition|)
return|return;
name|ptq
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sva
operator|&
literal|0x3ff
operator|)
condition|)
comment|/* Only check once in a while */
block|{
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|i386_ptob
argument_list|(
name|sva
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We can race ahead here, straight to next pde.. */
name|sva
operator|=
operator|(
name|sva
operator|&
literal|0xffc00
operator|)
operator|+
operator|(
literal|1
operator|<<
literal|10
operator|)
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|!
name|pmap_pte_pa
argument_list|(
name|ptp
operator|+
name|sva
argument_list|)
condition|)
continue|continue;
name|pte
operator|=
name|ptp
operator|+
name|sva
expr_stmt|;
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|va
operator|=
name|i386_ptob
argument_list|(
name|sva
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|opte
operator|=
operator|*
name|pte
expr_stmt|;
name|remove_stats
operator|.
name|removes
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Update statistics 		 */
if|if
condition|(
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
comment|/* 		 * Invalidate the PTEs. 		 * XXX: should cluster them up and invalidate as many 		 * as possible at once. 		 */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_REMOVE
condition|)
name|printf
argument_list|(
literal|"remove: inv %x ptes at %x(%x) "
argument_list|,
name|i386pagesperpage
argument_list|,
name|pte
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bits
operator|=
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|bits
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|&
operator|(
name|PG_U
operator||
name|PG_M
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|++
operator|=
literal|0
expr_stmt|;
comment|/*TBIS(va + ix * NBPG);*/
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
if|if
condition|(
name|curproc
operator|&&
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
condition|)
name|pmap_activate
argument_list|(
name|pmap
argument_list|,
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
argument_list|)
expr_stmt|;
comment|/* are we current address space or kernel? */
comment|/*if (pmap->pm_pdir[PTDPTDI].pd_pfnum == PTDpde.pd_pfnum 			|| pmap == kernel_pmap) 		load_cr3(curpcb->pcb_ptd);*/
name|tlbflush
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|needednotdone
name|reduce
name|wiring
name|count
name|on
name|page
name|table
name|pages
name|as
name|references
name|drop
endif|#
directive|endif
comment|/* 		 * Remove from the PV table (raise IPL since we 		 * may be called at interrupt time). 		 */
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
continue|continue;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 		 * If it is the first entry on the list, it is actually 		 * in the header and we must copy the following entry up 		 * to the header.  Otherwise we must search the list for 		 * the entry.  In either case we free the now unused entry. 		 */
if|if
condition|(
name|pmap
operator|==
name|pv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|npv
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
if|if
condition|(
name|npv
condition|)
block|{
operator|*
name|pv
operator|=
operator|*
name|npv
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
block|}
else|else
name|pv
operator|->
name|pv_pmap
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvfirst
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
for|for
control|(
name|npv
operator|=
name|pv
operator|->
name|pv_next
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|remove_stats
operator|.
name|pvsearch
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
break|break;
name|pv
operator|=
name|npv
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|npv
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_remove: PA not in pv_tab"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_next
operator|=
name|npv
operator|->
name|pv_next
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|npv
argument_list|,
name|M_VMPVENT
argument_list|)
expr_stmt|;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
index|[
name|tally
name|number
name|of
name|pagetable
name|pages
operator|,
expr|if
name|sharing
name|of
name|ptpages
name|adjust
name|here
expr|]
endif|#
directive|endif
comment|/* 		 * Update saved attributes for managed page 		 */
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator||=
name|bits
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
index|[
name|cache
name|and
name|tlb
name|flushing
operator|,
expr|if
name|needed
expr|]
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_REMOVE
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_remove_all(%x)"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/*pmap_pvdump(pa);*/
endif|#
directive|endif
comment|/* 	 * Not one of ours 	 */
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Do it the easy way for now 	 */
while|while
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
argument_list|)
operator|||
name|pmap_pte_pa
argument_list|(
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
argument_list|)
operator|!=
name|pa
condition|)
name|panic
argument_list|(
literal|"pmap_remove_all: bad mapping"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_remove
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_copy_on_write  *	Function:  *		Remove write privileges from all  *		physical maps for this physical page.  */
end_comment

begin_function
name|void
name|pmap_copy_on_write
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_copy_on_write(%x)"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_RO
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap
parameter_list|,
name|sva
parameter_list|,
name|eva
parameter_list|,
name|prot
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|int
name|ix
decl_stmt|;
name|int
name|i386prot
decl_stmt|;
name|boolean_t
name|firstpage
init|=
name|TRUE
decl_stmt|;
specifier|register
name|pt_entry_t
modifier|*
name|ptp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PROTECT
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_protect(%x, %x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
comment|/* are we current address space or kernel? */
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|==
name|PTDpde
operator|.
name|pd_pfnum
operator|||
name|pmap
operator|==
name|kernel_pmap
condition|)
name|ptp
operator|=
name|PTmap
expr_stmt|;
comment|/* otherwise, we are alternate address space */
else|else
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|!=
name|APTDpde
operator|.
name|pd_pfnum
condition|)
block|{
name|APTDpde
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
expr_stmt|;
name|tlbflush
argument_list|()
expr_stmt|;
block|}
name|ptp
operator|=
name|APTmap
expr_stmt|;
block|}
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
comment|/* 		 * Page table page is not allocated. 		 * Skip it, we don't want to force allocation 		 * of unnecessary PTE pages just to set the protection. 		 */
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
comment|/* XXX: avoid address wrap around */
if|if
condition|(
name|va
operator|>=
name|i386_trunc_pdr
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|-
literal|1
argument_list|)
condition|)
break|break;
name|va
operator|=
name|i386_round_pdr
argument_list|(
name|va
operator|+
name|PAGE_SIZE
argument_list|)
operator|-
name|PAGE_SIZE
expr_stmt|;
continue|continue;
block|}
name|pte
operator|=
name|ptp
operator|+
name|i386_btop
argument_list|(
name|va
argument_list|)
expr_stmt|;
comment|/* 		 * Page not valid.  Again, skip it. 		 * Should we do this?  Or set protection anyway? 		 */
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
continue|continue;
name|ix
operator|=
literal|0
expr_stmt|;
name|i386prot
operator|=
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|UPT_MAX_ADDRESS
condition|)
name|i386prot
operator||=
literal|2
comment|/*PG_u*/
expr_stmt|;
do|do
block|{
comment|/* clear VAC here if PG_RO? */
name|pmap_pte_set_prot
argument_list|(
name|pte
operator|++
argument_list|,
name|i386prot
argument_list|)
expr_stmt|;
comment|/*TBIS(va + ix * NBPG);*/
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
block|}
if|if
condition|(
name|curproc
operator|&&
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
condition|)
name|pmap_activate
argument_list|(
name|pmap
argument_list|,
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|pa
parameter_list|,
name|prot
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|npte
decl_stmt|,
name|ix
decl_stmt|;
name|vm_offset_t
name|opa
decl_stmt|;
name|boolean_t
name|cacheable
init|=
name|TRUE
decl_stmt|;
name|boolean_t
name|checkpv
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_ENTER
operator|)
condition|)
name|printf
argument_list|(
literal|"pmap_enter(%x, %x, %x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|va
operator|>
name|VM_MAX_KERNEL_ADDRESS
condition|)
name|panic
argument_list|(
literal|"pmap_enter: toobig"
argument_list|)
expr_stmt|;
comment|/* also, should not muck with PTD va! */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|enter_stats
operator|.
name|kernel
operator|++
expr_stmt|;
else|else
name|enter_stats
operator|.
name|user
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Page Directory table entry not valid, we need a new PT page 	 */
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ptdi %x\n"
argument_list|,
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Page Table Directory Invalid (ptdi)"
argument_list|)
expr_stmt|;
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|opa
operator|=
name|pmap_pte_pa
argument_list|(
name|pte
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: pte %x, *pte %x "
argument_list|,
name|pte
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Mapping has not changed, must be protection or wiring change. 	 */
if|if
condition|(
name|opa
operator|==
name|pa
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|pwchange
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Wiring change, just update stats. 		 * We don't worry about wiring PT pages as they remain 		 * resident as long as there are valid mappings in them. 		 * Hence, if a user page is wired, the PT page will be also. 		 */
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
operator|||
operator|!
name|wired
operator|&&
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|pg
argument_list|(
literal|"enter: wiring change -> %x "
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|wchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
goto|goto
name|validate
goto|;
block|}
comment|/* 	 * Mapping has changed, invalidate old range and fall through to 	 * handle validating new mapping. 	 */
if|if
condition|(
name|opa
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: removing old mapping %x pa %x "
argument_list|,
name|va
argument_list|,
name|opa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|mchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory 	 * Note that we raise IPL while manipulating pv_table 	 * since pmap_enter can be called at interrupt time. 	 */
if|if
condition|(
name|pa
operator|>=
name|vm_first_phys
operator|&&
name|pa
operator|<
name|vm_last_phys
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|,
name|npv
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|managed
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: pv at %x: %x/%x/%x "
argument_list|,
name|pv
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * No entries yet, use header as the first entry 		 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|firstpv
operator|++
expr_stmt|;
endif|#
directive|endif
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|NULL
expr_stmt|;
name|pv
operator|->
name|pv_flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * There is at least one other VA mapping this page. 		 * Place this entry after the header. 		 */
else|else
block|{
comment|/*printf("second time: ");*/
ifdef|#
directive|ifdef
name|DEBUG
for|for
control|(
name|npv
operator|=
name|pv
init|;
name|npv
condition|;
name|npv
operator|=
name|npv
operator|->
name|pv_next
control|)
if|if
condition|(
name|pmap
operator|==
name|npv
operator|->
name|pv_pmap
operator|&&
name|va
operator|==
name|npv
operator|->
name|pv_va
condition|)
name|panic
argument_list|(
literal|"pmap_enter: already in pv_tab"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npv
operator|=
operator|(
name|pv_entry_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|npv
argument_list|,
name|M_VMPVENT
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|npv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|npv
operator|->
name|pv_pmap
operator|=
name|pmap
expr_stmt|;
name|npv
operator|->
name|pv_next
operator|=
name|pv
operator|->
name|pv_next
expr_stmt|;
name|pv
operator|->
name|pv_next
operator|=
name|npv
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|npv
operator|->
name|pv_next
condition|)
name|enter_stats
operator|.
name|secondpv
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Assumption: if it is not part of our managed memory 	 * then it must be device memory which may be volitile. 	 */
if|if
condition|(
name|pmap_initialized
condition|)
block|{
name|checkpv
operator|=
name|cacheable
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|enter_stats
operator|.
name|unmanaged
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Increment counters 	 */
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|++
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|validate
label|:
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 * Assume uniform modified and referenced status for all 	 * I386 pages in a MACH page. 	 */
name|npte
operator|=
operator|(
name|pa
operator|&
name|PG_FRAME
operator|)
operator||
name|pte_prot
argument_list|(
name|pmap
argument_list|,
name|prot
argument_list|)
operator||
name|PG_V
expr_stmt|;
name|npte
operator||=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|&
operator|(
name|PG_M
operator||
name|PG_U
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|npte
operator||=
name|PG_W
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|UPT_MIN_ADDRESS
condition|)
name|npte
operator||=
name|PG_u
expr_stmt|;
elseif|else
if|if
condition|(
name|va
operator|<
name|UPT_MAX_ADDRESS
condition|)
name|npte
operator||=
name|PG_u
operator||
name|PG_RW
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_ENTER
condition|)
name|printf
argument_list|(
literal|"enter: new pte value %x "
argument_list|,
name|npte
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|pte
operator|++
operator|=
name|npte
expr_stmt|;
comment|/*TBIS(va);*/
name|npte
operator|+=
name|NBPG
expr_stmt|;
name|va
operator|+=
name|NBPG
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
name|pte
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGx
name|cache
operator|,
name|tlb
name|flushes
endif|#
directive|endif
comment|/*pads(pmap);*/
comment|/*load_cr3(((struct pcb *)curproc->p_addr)->pcb_ptd);*/
name|tlbflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *      pmap_page_protect:  *  *      Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|phys
parameter_list|,
name|prot
parameter_list|)
name|vm_offset_t
name|phys
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_READ
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
case|:
name|pmap_copy_on_write
argument_list|(
name|phys
argument_list|)
expr_stmt|;
break|break;
case|case
name|VM_PROT_ALL
case|:
break|break;
default|default:
name|pmap_remove_all
argument_list|(
name|phys
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_change_wiring  *	Function:	Change the wiring attribute for a map/virtual-address  *			pair.  *	In/out conditions:  *			The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|,
name|wired
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
block|{
specifier|register
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
specifier|register
name|int
name|ix
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_change_wiring(%x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|,
name|wired
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|==
name|NULL
condition|)
return|return;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * Page table page is not allocated. 	 * Should this ever happen?  Ignore it for now, 	 * we don't want to force allocation of unnecessary PTE pages. 	 */
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
condition|)
name|pg
argument_list|(
literal|"pmap_change_wiring: invalid PDE for %x "
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Page not valid.  Should this ever happen? 	 * Just continue and change wiring anyway. 	 */
if|if
condition|(
operator|!
name|pmap_pte_v
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PARANOIA
condition|)
name|pg
argument_list|(
literal|"pmap_change_wiring: invalid PTE for %x "
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|wired
operator|&&
operator|!
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
operator|||
operator|!
name|wired
operator|&&
name|pmap_pte_w
argument_list|(
name|pte
argument_list|)
condition|)
block|{
if|if
condition|(
name|wired
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
else|else
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
comment|/* 	 * Wiring is not a hardware characteristic so there is no need 	 * to invalidate TLB. 	 */
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|pmap_pte_set_w
argument_list|(
name|pte
operator|++
argument_list|,
name|wired
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_pte  *	Function:  *		Extract the page table entry associated  *		with the given map/virtual_address pair.  * [ what about induced faults -wfj]  */
end_comment

begin_function
name|struct
name|pte
modifier|*
name|pmap_pte
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUGx
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_pte(%x, %x) ->\n"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|&&
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
comment|/* are we current address space or kernel? */
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|==
name|PTDpde
operator|.
name|pd_pfnum
operator|||
name|pmap
operator|==
name|kernel_pmap
condition|)
return|return
operator|(
operator|(
expr|struct
name|pte
operator|*
operator|)
name|vtopte
argument_list|(
name|va
argument_list|)
operator|)
return|;
comment|/* otherwise, we are alternate address space */
else|else
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
operator|.
name|pd_pfnum
operator|!=
name|APTDpde
operator|.
name|pd_pfnum
condition|)
block|{
name|APTDpde
operator|=
name|pmap
operator|->
name|pm_pdir
index|[
name|PTDPTDI
index|]
expr_stmt|;
name|tlbflush
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|struct
name|pte
operator|*
operator|)
name|avtopte
argument_list|(
name|va
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap
parameter_list|,
name|va
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUGx
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|pg
argument_list|(
literal|"pmap_extract(%x, %x) -> "
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pmap
operator|&&
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
block|{
name|pa
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pa
condition|)
name|pa
operator|=
operator|(
name|pa
operator|&
name|PG_FRAME
operator|)
operator||
operator|(
name|va
operator|&
operator|~
name|PG_FRAME
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGx
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"%x\n"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|dst_pmap
parameter_list|,
name|src_pmap
parameter_list|,
name|dst_addr
parameter_list|,
name|len
parameter_list|,
name|src_addr
parameter_list|)
name|pmap_t
name|dst_pmap
decl_stmt|;
name|pmap_t
name|src_pmap
decl_stmt|;
name|vm_offset_t
name|dst_addr
decl_stmt|;
name|vm_size_t
name|len
decl_stmt|;
name|vm_offset_t
name|src_addr
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy(%x, %x, %x, %x, %x)"
argument_list|,
name|dst_pmap
argument_list|,
name|src_pmap
argument_list|,
name|dst_addr
argument_list|,
name|len
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	Require that all active physical maps contain no  *	incorrect entries NOW.  [This update includes  *	forcing updates of any address map caching.]  *  *	Generally used to insure that a thread about  *	to run will see a semantically correct world.  */
end_comment

begin_function
name|void
name|pmap_update
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_update()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tlbflush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_collect  *	Function:  *		Garbage collects the physical map system for  *		pages which are no longer used.  *		Success need not be guaranteed -- that is, there  *		may well be pages which are not referenced, but  *		others may be collected.  *	Usage:  *		Called by the pageout daemon when pages are scarce.  * [ needs to be written -wfj ]  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|pmap
parameter_list|)
name|pmap_t
name|pmap
decl_stmt|;
block|{
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|kpa
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|int
modifier|*
name|pde
decl_stmt|;
name|int
name|opmapdebug
decl_stmt|;
name|printf
argument_list|(
literal|"pmap_collect(%x) "
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pmap
operator|!=
name|kernel_pmap
condition|)
return|return;
block|}
end_function

begin_comment
comment|/* [ macro again?, should I force kstack into user map here? -wfj ] */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|pmap
parameter_list|,
name|pcbp
parameter_list|)
specifier|register
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|pcb
modifier|*
name|pcbp
decl_stmt|;
block|{
name|int
name|x
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PDRTAB
operator|)
condition|)
name|pg
argument_list|(
literal|"pmap_activate(%x, %x) "
argument_list|,
name|pmap
argument_list|,
name|pcbp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PMAP_ACTIVATE
argument_list|(
name|pmap
argument_list|,
name|pcbp
argument_list|)
expr_stmt|;
comment|/*printf("pde "); for(x=0x3f6; x< 0x3fA; x++) 	printf("%x ", pmap->pm_pdir[x]);*/
comment|/*pads(pmap);*/
comment|/*pg(" pcb_cr3 %x", pcbp->pcb_cr3);*/
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_kernel  *	Function:  *		Returns the physical map handle for the kernel.  */
end_comment

begin_function
name|pmap_t
name|pmap_kernel
parameter_list|()
block|{
return|return
operator|(
name|kernel_pmap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bzero to clear its contents, one machine dependent page  *	at a time.  */
end_comment

begin_expr_stmt
name|pmap_zero_page
argument_list|(
name|phys
argument_list|)
specifier|register
name|vm_offset_t
name|phys
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ix
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_zero_page(%x)"
argument_list|,
name|phys
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|phys
operator|>>=
name|PG_SHIFT
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|clearseg
argument_list|(
name|phys
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_expr_stmt
name|pmap_copy_page
argument_list|(
name|src
argument_list|,
name|dst
argument_list|)
specifier|register
name|vm_offset_t
name|src
operator|,
name|dst
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|ix
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_copy_page(%x, %x)"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|src
operator|>>=
name|PG_SHIFT
expr_stmt|;
name|dst
operator|>>=
name|PG_SHIFT
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|physcopyseg
argument_list|(
name|src
operator|++
argument_list|,
name|dst
operator|++
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
block|}
end_block

begin_comment
comment|/*  *	Routine:	pmap_pageable  *	Function:  *		Make the specified pages (by pmap, offset)  *		pageable (or not) as requested.  *  *		A page which is not pageable may not take  *		a fault; therefore, its page table entry  *		must remain valid for the duration.  *  *		This routine is merely advisory; pmap_enter  *		will specify that these pages are to be wired  *		down (or not) as appropriate.  */
end_comment

begin_macro
name|pmap_pageable
argument_list|(
argument|pmap
argument_list|,
argument|sva
argument_list|,
argument|eva
argument_list|,
argument|pageable
argument_list|)
end_macro

begin_decl_stmt
name|pmap_t
name|pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|sva
decl_stmt|,
name|eva
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|pageable
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we are making a PT page pageable then all valid 	 * mappings must be gone from that page.  Hence it should 	 * be all zeros and there is no need to clean it. 	 * Assumptions: 	 *	- we are called with only one page at a time 	 *	- PT pages have only one pv_table entry 	 */
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
operator|&&
name|pageable
operator|&&
name|sva
operator|+
name|PAGE_SIZE
operator|==
name|eva
condition|)
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|(
name|pmapdebug
operator|&
operator|(
name|PDB_FOLLOW
operator||
name|PDB_PTPAGE
operator|)
operator|)
operator|==
name|PDB_PTPAGE
condition|)
name|printf
argument_list|(
literal|"pmap_pageable(%x, %x, %x, %x)"
argument_list|,
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pageable
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*if (!pmap_pde_v(pmap_pde(pmap, sva))) 			return;*/
if|if
condition|(
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|pa
operator|=
name|pmap_pte_pa
argument_list|(
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/*if (!ispt(pv->pv_va)) 			return;*/
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|!=
name|sva
operator|||
name|pv
operator|->
name|pv_next
condition|)
block|{
name|pg
argument_list|(
literal|"pmap_pageable: bad PT page va %x next %x\n"
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_next
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 		 * Mark it unmodified to avoid pageout 		 */
name|pmap_clear_modify
argument_list|(
name|pa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|needsomethinglikethis
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_PTPAGE
condition|)
name|pg
argument_list|(
literal|"pmap_pageable: PT page %x(%x) unmodified\n"
argument_list|,
name|sva
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_WIRING
condition|)
name|pmap_check_wiring
argument_list|(
literal|"pageable"
argument_list|,
name|sva
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_block

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_modify(%x)"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_clear_reference:  *  *	Clear the reference bit on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
name|printf
argument_list|(
literal|"pmap_clear_reference(%x)"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page is referenced  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
block|{
name|boolean_t
name|rv
init|=
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pmap_is_referenced(%x) -> %c"
argument_list|,
name|pa
argument_list|,
literal|"FT"
index|[
name|rv
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_U
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page is modified  *	by any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|pa
parameter_list|)
name|vm_offset_t
name|pa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_FOLLOW
condition|)
block|{
name|boolean_t
name|rv
init|=
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"pmap_is_modified(%x) -> %c"
argument_list|,
name|pa
argument_list|,
literal|"FT"
index|[
name|rv
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|pmap_testbit
argument_list|(
name|pa
argument_list|,
name|PG_M
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|ppn
parameter_list|)
name|int
name|ppn
decl_stmt|;
block|{
return|return
operator|(
name|i386_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Miscellaneous support routines follow  */
end_comment

begin_macro
name|i386_protection_init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|kp
decl_stmt|,
name|prot
decl_stmt|;
name|kp
operator|=
name|protection_codes
expr_stmt|;
for|for
control|(
name|prot
operator|=
literal|0
init|;
name|prot
operator|<
literal|8
condition|;
name|prot
operator|++
control|)
block|{
switch|switch
condition|(
name|prot
condition|)
block|{
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
operator|*
name|kp
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_NONE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_RO
expr_stmt|;
break|break;
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_NONE
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_NONE
case|:
case|case
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator||
name|VM_PROT_EXECUTE
case|:
operator|*
name|kp
operator|++
operator|=
name|PG_RW
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function
name|boolean_t
name|pmap_testbit
parameter_list|(
name|pa
parameter_list|,
name|bit
parameter_list|)
specifier|register
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|,
name|ix
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Check saved info first 	 */
if|if
condition|(
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator|&
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* 	 * Not found, check current mappings returning 	 * immediately if found. 	 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|pte
operator|++
operator|&
name|bit
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|pmap_changebit
argument_list|(
name|pa
argument_list|,
name|bit
argument_list|,
name|setem
argument_list|)
specifier|register
name|vm_offset_t
name|pa
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|bit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|setem
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
specifier|register
name|int
modifier|*
name|pte
decl_stmt|,
name|npte
decl_stmt|,
name|ix
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|s
decl_stmt|;
name|boolean_t
name|firstpage
init|=
name|TRUE
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|pmapdebug
operator|&
name|PDB_BITS
condition|)
name|printf
argument_list|(
literal|"pmap_changebit(%x, %x, %s)"
argument_list|,
name|pa
argument_list|,
name|bit
argument_list|,
name|setem
condition|?
literal|"set"
else|:
literal|"clear"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pa
operator|<
name|vm_first_phys
operator|||
name|pa
operator|>=
name|vm_last_phys
condition|)
return|return;
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Clear saved attributes (modify, reference) 	 */
if|if
condition|(
operator|!
name|setem
condition|)
name|pmap_attributes
index|[
name|pa_index
argument_list|(
name|pa
argument_list|)
index|]
operator|&=
operator|~
name|bit
expr_stmt|;
comment|/* 	 * Loop over all current mappings setting/clearing as appropos 	 * If setting RO do we need to clear the VAC? 	 */
if|if
condition|(
name|pv
operator|->
name|pv_pmap
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|int
name|toflush
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|toflush
operator||=
operator|(
name|pv
operator|->
name|pv_pmap
operator|==
name|kernel_pmap
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
endif|#
directive|endif
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
comment|/*                          * XXX don't write protect pager mappings                          */
if|if
condition|(
name|bit
operator|==
name|PG_RO
condition|)
block|{
specifier|extern
name|vm_offset_t
name|pager_sva
decl_stmt|,
name|pager_eva
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|pager_sva
operator|&&
name|va
operator|<
name|pager_eva
condition|)
continue|continue;
block|}
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|pmap_pte
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|ix
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|setem
condition|)
name|npte
operator|=
operator|*
name|pte
operator||
name|bit
expr_stmt|;
else|else
name|npte
operator|=
operator|*
name|pte
operator|&
operator|~
name|bit
expr_stmt|;
if|if
condition|(
operator|*
name|pte
operator|!=
name|npte
condition|)
block|{
operator|*
name|pte
operator|=
name|npte
expr_stmt|;
comment|/*TBIS(va);*/
block|}
name|va
operator|+=
name|NBPG
expr_stmt|;
name|pte
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|ix
operator|!=
name|i386pagesperpage
condition|)
do|;
if|if
condition|(
name|curproc
operator|&&
name|pv
operator|->
name|pv_pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
condition|)
name|pmap_activate
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|somethinglikethis
if|if
condition|(
name|setem
operator|&&
name|bit
operator|==
name|PG_RO
operator|&&
operator|(
name|pmapvacflush
operator|&
name|PVF_PROTECT
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|pmapvacflush
operator|&
name|PVF_TOTAL
operator|)
operator|||
name|toflush
operator|==
literal|3
condition|)
name|DCIA
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|toflush
operator|==
literal|2
condition|)
name|DCIS
argument_list|()
expr_stmt|;
else|else
name|DCIU
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|pmap_pvdump
argument_list|(
argument|pa
argument_list|)
end_macro

begin_decl_stmt
name|vm_offset_t
name|pa
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|pv_entry_t
name|pv
decl_stmt|;
name|printf
argument_list|(
literal|"pa %x"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
init|;
name|pv
condition|;
name|pv
operator|=
name|pv
operator|->
name|pv_next
control|)
block|{
name|printf
argument_list|(
literal|" -> pmap %x, va %x, flags %x"
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pv
operator|->
name|pv_flags
argument_list|)
expr_stmt|;
name|pads
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_macro
name|pmap_check_wiring
argument_list|(
argument|str
argument_list|,
argument|va
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|va
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|vm_map_entry_t
name|entry
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmap_pde_v
argument_list|(
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
argument_list|)
operator|||
operator|!
name|pmap_pte_v
argument_list|(
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|vm_map_lookup_entry
argument_list|(
name|pt_map
argument_list|,
name|va
argument_list|,
operator|&
name|entry
argument_list|)
condition|)
block|{
name|pg
argument_list|(
literal|"wired_check: entry for %x not found\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pte
operator|=
operator|(
name|int
operator|*
operator|)
name|va
init|;
name|pte
operator|<
operator|(
name|int
operator|*
operator|)
operator|(
name|va
operator|+
name|PAGE_SIZE
operator|)
condition|;
name|pte
operator|++
control|)
if|if
condition|(
operator|*
name|pte
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|wired_count
operator|!=
name|count
condition|)
name|pg
argument_list|(
literal|"*%s*: %x: w%d/a%d\n"
argument_list|,
name|str
argument_list|,
name|va
argument_list|,
name|entry
operator|->
name|wired_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* print address space of pmap*/
end_comment

begin_macro
name|pads
argument_list|(
argument|pm
argument_list|)
end_macro

begin_decl_stmt
name|pmap_t
name|pm
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|va
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|pte
modifier|*
name|ptep
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1024
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pm
operator|->
name|pm_pdir
index|[
name|i
index|]
operator|.
name|pd_v
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|1024
condition|;
name|j
operator|++
control|)
block|{
name|va
operator|=
operator|(
name|i
operator|<<
literal|22
operator|)
operator|+
operator|(
name|j
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
operator|&&
name|va
operator|<
name|KERNBASE
condition|)
continue|continue;
if|if
condition|(
name|pm
operator|!=
name|kernel_pmap
operator|&&
name|va
operator|>
name|UPT_MAX_ADDRESS
condition|)
continue|continue;
name|ptep
operator|=
name|pmap_pte
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pte_v
argument_list|(
name|ptep
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%x:%x "
argument_list|,
name|va
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|ptep
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

