begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_user_ldt.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BETTER_CLOCK
end_ifdef

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cngetc() */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BETTER_CLOCK
end_ifdef

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/apic.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/mpapic.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_comment
comment|/** TEST_DEFAULT_CONFIG, TEST_TEST1 */
end_comment

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/globaldata.h>
end_include

begin_include
include|#
directive|include
file|<pci/pcivar.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_comment
comment|/* setidt() */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TEST_DEFAULT_CONFIG
argument_list|)
end_if

begin_define
define|#
directive|define
name|MPFPS_MPFB1
value|TEST_DEFAULT_CONFIG
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MPFPS_MPFB1
value|mpfps->mpfb1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST_DEFAULT_CONFIG */
end_comment

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xe8000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x18000)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xf0000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x10000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIOS_COUNT
value|(BIOS_SIZE/4)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_EN
value|0x01
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_BP
value|0x02
end_define

begin_define
define|#
directive|define
name|IOAPICENTRY_FLAG_EN
value|0x01
end_define

begin_comment
comment|/* MP Floating Pointer Structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPFPS
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|void
modifier|*
name|pap
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|mpfb1
decl_stmt|;
name|u_char
name|mpfb2
decl_stmt|;
name|u_char
name|mpfb3
decl_stmt|;
name|u_char
name|mpfb4
decl_stmt|;
name|u_char
name|mpfb5
decl_stmt|;
block|}
typedef|*
name|mpfps_t
typedef|;
end_typedef

begin_comment
comment|/* MP Configuration Table Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPCTH
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|u_short
name|base_table_length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|oem_id
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|product_id
index|[
literal|12
index|]
decl_stmt|;
name|void
modifier|*
name|oem_table_pointer
decl_stmt|;
name|u_short
name|oem_table_size
decl_stmt|;
name|u_short
name|entry_count
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
name|u_short
name|extended_table_length
decl_stmt|;
name|u_char
name|extended_table_checksum
decl_stmt|;
name|u_char
name|reserved
decl_stmt|;
block|}
typedef|*
name|mpcth_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|PROCENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|cpu_flags
decl_stmt|;
name|u_long
name|cpu_signature
decl_stmt|;
name|u_long
name|feature_flags
decl_stmt|;
name|u_long
name|reserved1
decl_stmt|;
name|u_long
name|reserved2
decl_stmt|;
block|}
typedef|*
name|proc_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|bus_id
decl_stmt|;
name|char
name|bus_type
index|[
literal|6
index|]
decl_stmt|;
block|}
typedef|*
name|bus_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|IOAPICENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|apic_flags
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
block|}
typedef|*
name|io_apic_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
block|}
typedef|*
name|int_entry_ptr
typedef|;
end_typedef

begin_comment
comment|/* descriptions of MP basetable entries */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BASETABLE_ENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
block|}
name|basetable_entry
typedef|;
end_typedef

begin_comment
comment|/*  * this code MUST be enabled here and in mpboot.s.  * it follows the very early stages of AP boot by placing values in CMOS ram.  * it NORMALLY will never be needed and thus the primitive method for enabling.  * #define CHECK_POINTS  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHECK_POINTS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|PC98
argument_list|)
end_if

begin_define
define|#
directive|define
name|CHECK_READ
parameter_list|(
name|A
parameter_list|)
value|(outb(CMOS_REG, (A)), inb(CMOS_DATA))
end_define

begin_define
define|#
directive|define
name|CHECK_WRITE
parameter_list|(
name|A
parameter_list|,
name|D
parameter_list|)
value|(outb(CMOS_REG, (A)), outb(CMOS_DATA, (D)))
end_define

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
value|;				\ 	CHECK_WRITE(0x34, (D));			\ 	CHECK_WRITE(0x35, (D));			\ 	CHECK_WRITE(0x36, (D));			\ 	CHECK_WRITE(0x37, (D));			\ 	CHECK_WRITE(0x38, (D));			\ 	CHECK_WRITE(0x39, (D));
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
value|;				\ 	printf("%s: %d, %d, %d, %d, %d, %d\n",	\ 	   (S),					\ 	   CHECK_READ(0x34),			\ 	   CHECK_READ(0x35),			\ 	   CHECK_READ(0x36),			\ 	   CHECK_READ(0x37),			\ 	   CHECK_READ(0x38),			\ 	   CHECK_READ(0x39));
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_comment
comment|/*  * Values to send to the POST hardware.  */
end_comment

begin_define
define|#
directive|define
name|MP_BOOTADDRESS_POST
value|0x10
end_define

begin_define
define|#
directive|define
name|MP_PROBE_POST
value|0x11
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS1_POST
value|0x12
end_define

begin_define
define|#
directive|define
name|MP_START_POST
value|0x13
end_define

begin_define
define|#
directive|define
name|MP_ENABLE_POST
value|0x14
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS2_POST
value|0x15
end_define

begin_define
define|#
directive|define
name|START_ALL_APS_POST
value|0x16
end_define

begin_define
define|#
directive|define
name|INSTALL_AP_TRAMP_POST
value|0x17
end_define

begin_define
define|#
directive|define
name|START_AP_POST
value|0x18
end_define

begin_define
define|#
directive|define
name|MP_ANNOUNCE_POST
value|0x19
end_define

begin_decl_stmt
specifier|static
name|int
name|need_hyperthreading_fixup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|logical_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|logical_cpus_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bit mask of logical cpu's */
end_comment

begin_comment
comment|/** XXX FIXME: where does this really belong, isa.h/isa.c perhaps? */
end_comment

begin_decl_stmt
name|int
name|current_postcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** XXX FIXME: what system files declare these??? */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|region_descriptor
name|r_gdt
decl_stmt|,
name|r_idt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bsp_apic_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flags useability of BSP apic */
end_comment

begin_decl_stmt
name|int
name|mp_ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of CPUs, including BSP */
end_comment

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|mp_nbusses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of busses */
end_comment

begin_decl_stmt
name|int
name|mp_napics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of IO APICs */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
name|vm_offset_t
name|cpu_apic_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|io_apic_address
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NAPICID is more than enough */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|nkpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|cpu_apic_versions
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
modifier|*
name|io_apic_versions
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_INTR_DIAGNOSTIC
end_ifdef

begin_decl_stmt
name|int
name|apic_itrace_enter
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_tryisrlock
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_gotisrlock
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_active
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_masked
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_noisrlock
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_masked2
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_unmask
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_noforward
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_leave
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_enter2
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_doreti
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_splz
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_eoi
index|[
literal|32
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_INTR_DIAGNOSTIC_IRQ
end_ifdef

begin_decl_stmt
name|unsigned
name|short
name|apic_itrace_debugbuffer
index|[
literal|32768
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_itrace_debugbuffer_idx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|simplelock
name|apic_itrace_debuglock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|APIC_INTR_REORDER
end_ifdef

begin_struct
struct|struct
block|{
specifier|volatile
name|int
modifier|*
name|location
decl_stmt|;
name|int
name|bit
decl_stmt|;
block|}
name|apic_isrbit_location
index|[
literal|32
index|]
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|apic_intmapinfo
name|int_to_apicintpin
index|[
name|APIC_INTMAPSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * APIC ID logical/physical mapping structures.  * We oversize these to simplify boot-time config.  */
end_comment

begin_decl_stmt
name|int
name|cpu_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|io_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_id_to_logical
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of all available CPUs */
end_comment

begin_decl_stmt
name|u_int
name|all_cpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AP uses this during bootstrap.  Do not staticize.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootSTK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bootAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hotwire a 0->4MB V==P mapping */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|KPTphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SMP page table page */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
modifier|*
name|SMPpt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|stoppcbs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|smp_started
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* has the system started? */
end_comment

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mp_capable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|boot_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|base_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|picmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: virtual wire mode, 1: PIC mode */
end_comment

begin_decl_stmt
specifier|static
name|mpfps_t
name|mpfps
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_hyperthread_fixup
parameter_list|(
name|u_int
name|id_mask
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fix_mp_table
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|setup_apic_irq_mapping
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logicalCpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|apic_int_is_bus_type
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|bus_type
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|hlt_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hlt_logical_cpus
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hyperthreading_cpus
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|hyperthreading_cpus_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hyperthreading_allowed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysctl_ctx_list
name|logical_cpu_clist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_BOOTADDRESS_POST
argument_list|)
expr_stmt|;
name|base_memory
operator|=
name|basemem
operator|*
literal|1024
expr_stmt|;
comment|/* convert to bytes */
name|boot_address
operator|=
name|base_memory
operator|&
operator|~
literal|0xfff
expr_stmt|;
comment|/* round down to 4k boundary */
if|if
condition|(
operator|(
name|base_memory
operator|-
name|boot_address
operator|)
operator|<
name|bootMP_size
condition|)
name|boot_address
operator|-=
literal|4096
expr_stmt|;
comment|/* not enough, lower by 4k */
return|return
name|boot_address
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an Intel MP spec table (ie, SMP capable hardware).  */
end_comment

begin_function
name|int
name|mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_long
name|segment
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_PROBE_POST
argument_list|)
expr_stmt|;
comment|/* see if EBDA exists */
if|if
condition|(
operator|(
name|segment
operator|=
operator|(
name|u_long
operator|)
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
literal|0x40e
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* search first 1K of EBDA */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|segment
operator|<<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
else|else
block|{
comment|/* last 1K of base memory, effective 'top of base' passed in */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|base_memory
operator|-
literal|0x400
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* search the BIOS */
name|target
operator|=
operator|(
name|u_int32_t
operator|)
name|BIOS_BASE
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
name|BIOS_COUNT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
comment|/* nothing found */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
literal|0
expr_stmt|;
name|mp_capable
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|found
label|:
comment|/* calculate needed resources */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
name|x
expr_stmt|;
name|mptable_pass1
argument_list|()
expr_stmt|;
comment|/* flag fact that we are running multiple processors */
name|mp_capable
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Startup the SMP processors.  */
end_comment

begin_function
name|void
name|mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_START_POST
argument_list|)
expr_stmt|;
comment|/* look for MP capable motherboard */
if|if
condition|(
name|mp_capable
condition|)
name|mp_enable
argument_list|(
name|boot_address
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"MP hardware not found!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_ANNOUNCE_POST
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FreeBSD/SMP: Multiprocessor motherboard: %d CPUs\n"
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cpu0 (BSP): apic id: %2d"
argument_list|,
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" cpu%d (AP):  apic id: %2d"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" io%d (APIC): apic id: %2d"
argument_list|,
name|x
argument_list|,
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|io_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|io_apic_address
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|" Warning: APIC I/O disabled\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
end_function

begin_comment
comment|/*  * AP cpu's call this to sync up protected mode.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|gsel_tss
decl_stmt|;
name|int
name|x
decl_stmt|,
name|myid
init|=
name|bootAP
decl_stmt|;
name|u_int
name|cr0
decl_stmt|;
name|gdt_segs
index|[
name|GPRIV_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
expr_stmt|;
name|gdt_segs
index|[
name|GPROC0_SEL
index|]
operator|.
name|ssd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
operator|.
name|globaldata
operator|.
name|gd_common_tss
expr_stmt|;
name|SMP_prvspace
index|[
name|myid
index|]
operator|.
name|globaldata
operator|.
name|gd_prvspace
operator|=
operator|&
name|SMP_prvspace
index|[
name|myid
index|]
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NGDT
condition|;
name|x
operator|++
control|)
block|{
name|ssdtosd
argument_list|(
operator|&
name|gdt_segs
index|[
name|x
index|]
argument_list|,
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|x
index|]
operator|.
name|sd
argument_list|)
expr_stmt|;
block|}
name|r_gdt
operator|.
name|rd_limit
operator|=
name|NGDT
operator|*
sizeof|sizeof
argument_list|(
name|gdt
index|[
literal|0
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|r_gdt
operator|.
name|rd_base
operator|=
operator|(
name|int
operator|)
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
index|]
expr_stmt|;
name|lgdt
argument_list|(
operator|&
name|r_gdt
argument_list|)
expr_stmt|;
comment|/* does magic intra-segment return */
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
name|lldt
argument_list|(
name|_default_ldt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USER_LDT
name|currentldt
operator|=
name|_default_ldt
expr_stmt|;
endif|#
directive|endif
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|GPROC0_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|GPROC0_SEL
index|]
operator|.
name|sd
operator|.
name|sd_type
operator|=
name|SDT_SYS386TSS
expr_stmt|;
name|common_tss
operator|.
name|tss_esp0
operator|=
literal|0
expr_stmt|;
comment|/* not used until after switch */
name|common_tss
operator|.
name|tss_ss0
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|common_tss
operator|.
name|tss_ioopt
operator|=
operator|(
sizeof|sizeof
name|common_tss
operator|)
operator|<<
literal|16
expr_stmt|;
name|tss_gdt
operator|=
operator|&
name|gdt
index|[
name|myid
operator|*
name|NGDT
operator|+
name|GPROC0_SEL
index|]
operator|.
name|sd
expr_stmt|;
name|common_tssd
operator|=
operator|*
name|tss_gdt
expr_stmt|;
name|ltr
argument_list|(
name|gsel_tss
argument_list|)
expr_stmt|;
comment|/* 	 * Set to a known state: 	 * Set by mpboot.s: CR0_PG, CR0_PE 	 * Set by cpu_setregs: CR0_NE, CR0_MP, CR0_TS, CR0_WP, CR0_AM 	 */
name|cr0
operator|=
name|rcr0
argument_list|()
expr_stmt|;
name|cr0
operator|&=
operator|~
operator|(
name|CR0_CD
operator||
name|CR0_NW
operator||
name|CR0_EM
operator|)
expr_stmt|;
name|load_cr0
argument_list|(
name|cr0
argument_list|)
expr_stmt|;
name|pmap_set_opt
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_comment
comment|/*  * Final configuration of the BSP's local APIC:  *  - disable 'pic mode'.  *  - disable 'virtual wire mode'.  *  - enable NMI.  */
end_comment

begin_function
name|void
name|bsp_apic_configure
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|byte
decl_stmt|;
name|u_int32_t
name|temp
decl_stmt|;
comment|/* leave 'pic mode' if necessary */
if|if
condition|(
name|picmode
condition|)
block|{
name|outb
argument_list|(
literal|0x22
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select IMCR */
name|byte
operator|=
name|inb
argument_list|(
literal|0x23
argument_list|)
expr_stmt|;
comment|/* current contents */
name|byte
operator||=
literal|0x01
expr_stmt|;
comment|/* mask external INTR */
name|outb
argument_list|(
literal|0x23
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disconnect 8259s/NMI */
block|}
comment|/* mask lint0 (the 8259 'virtual wire' connection) */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint0
expr_stmt|;
name|temp
operator||=
name|APIC_LVT_M
expr_stmt|;
comment|/* set the mask */
name|lapic
operator|.
name|lvt_lint0
operator|=
name|temp
expr_stmt|;
comment|/* setup lint1 to handle NMI */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint1
expr_stmt|;
name|temp
operator|&=
operator|~
name|APIC_LVT_M
expr_stmt|;
comment|/* clear the mask */
name|lapic
operator|.
name|lvt_lint1
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|apic_dump
argument_list|(
literal|"bsp_apic_configure()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|INTDATA
block|{
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
name|u_char
name|int_vector
decl_stmt|;
block|}
name|io_int
operator|,
name|local_int
typedef|;
end_typedef

begin_comment
comment|/* the IO INT data, one entry per possible APIC INTerrupt */
end_comment

begin_decl_stmt
specifier|static
name|io_int
modifier|*
name|io_apic_ints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nintrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * start the SMP system  */
end_comment

begin_function
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|int
name|apic
decl_stmt|;
name|u_int
name|ux
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
name|POSTCODE
argument_list|(
name|MP_ENABLE_POST
argument_list|)
expr_stmt|;
comment|/* turn on 4MB of V == P addressing so we can get to MP table */
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|KPTphys
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* examine the MP table for needed info, uses physical addresses */
name|x
operator|=
name|mptable_pass2
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
literal|0
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* can't process default configs till the CPU APIC is pmapped */
if|if
condition|(
name|x
condition|)
name|default_mp_table
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* initialize all SMP locks */
name|init_locks
argument_list|()
expr_stmt|;
comment|/* post scan cleanup */
name|fix_mp_table
argument_list|()
expr_stmt|;
name|setup_apic_irq_mapping
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* fill the LOGICAL io_apic_versions table */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
block|{
name|ux
operator|=
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
expr_stmt|;
name|io_apic_versions
index|[
name|apic
index|]
operator|=
name|ux
expr_stmt|;
if|if
condition|(
name|ux
operator|==
literal|0xffffffff
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nintrs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|io_apic_ints
index|[
name|i
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Missing IO APIC"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Skipping broken IO APIC #%d\n"
argument_list|,
name|apic
argument_list|)
expr_stmt|;
block|}
else|else
name|io_apic_set_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* program each IO APIC in the system */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
if|if
condition|(
name|io_apic_versions
index|[
name|apic
index|]
operator|!=
literal|0xffffffff
operator|&&
name|io_apic_setup
argument_list|(
name|apic
argument_list|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"IO APIC setup failure"
argument_list|)
expr_stmt|;
comment|/* install a 'Spurious INTerrupt' vector */
name|setidt
argument_list|(
name|XSPURIOUSINT_OFFSET
argument_list|,
name|Xspuriousint
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for TLB invalidation */
name|setidt
argument_list|(
name|XINVLTLB_OFFSET
argument_list|,
name|Xinvltlb
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BETTER_CLOCK
comment|/* install an inter-CPU IPI for reading processor state */
name|setidt
argument_list|(
name|XCPUCHECKSTATE_OFFSET
argument_list|,
name|Xcpucheckstate
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* install an inter-CPU IPI for all-CPU rendezvous */
name|setidt
argument_list|(
name|XRENDEZVOUS_OFFSET
argument_list|,
name|Xrendezvous
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for forcing an additional software trap */
name|setidt
argument_list|(
name|XCPUAST_OFFSET
argument_list|,
name|Xcpuast
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for interrupt forwarding */
name|setidt
argument_list|(
name|XFORWARD_IRQ_OFFSET
argument_list|,
name|Xforward_irq
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for CPU stop/restart */
name|setidt
argument_list|(
name|XCPUSTOP_OFFSET
argument_list|,
name|Xcpustop
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TEST1
argument_list|)
comment|/* install a "fake hardware INTerrupt" vector */
name|setidt
argument_list|(
name|XTEST1_OFFSET
argument_list|,
name|Xtest1
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/** TEST_TEST1 */
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* start each Application Processor */
name|start_all_aps
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * look for the MP spec signature  */
end_comment

begin_comment
comment|/* string defined by the Intel MP Spec as identifying the MP table */
end_comment

begin_define
define|#
directive|define
name|MP_SIG
value|0x5f504d5f
end_define

begin_comment
comment|/* _MP_ */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|X
parameter_list|)
value|((X) += 4)
end_define

begin_function
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_int32_t
modifier|*
name|addr
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|target
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|NEXT
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|addr
index|[
name|x
index|]
operator|==
name|MP_SIG
condition|)
comment|/* make array index a byte index */
return|return
operator|(
name|target
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|basetable_entry
name|basetable_entry_types
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|"Processor"
block|}
block|,
block|{
literal|1
block|,
literal|8
block|,
literal|"Bus"
block|}
block|,
block|{
literal|2
block|,
literal|8
block|,
literal|"I/O APIC"
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|"I/O INT"
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|"Local INT"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|BUSDATA
block|{
name|u_char
name|bus_id
decl_stmt|;
name|enum
name|busTypes
name|bus_type
decl_stmt|;
block|}
name|bus_datum
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSTYPENAME
block|{
name|u_char
name|type
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
block|}
name|bus_type_name
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bus_type_name
name|bus_type_table
index|[]
init|=
block|{
block|{
name|CBUS
block|,
literal|"CBUS"
block|}
block|,
block|{
name|CBUSII
block|,
literal|"CBUSII"
block|}
block|,
block|{
name|EISA
block|,
literal|"EISA"
block|}
block|,
block|{
name|MCA
block|,
literal|"MCA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|ISA
block|,
literal|"ISA"
block|}
block|,
block|{
name|MCA
block|,
literal|"MCA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|PCI
block|,
literal|"PCI"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|XPRESS
block|,
literal|"XPRESS"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from MP spec v1.4, table 5-1 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_data
index|[
literal|7
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*   nbus, id0, type0, id1, type1 */
block|{
literal|1
block|,
literal|0
block|,
name|ISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|MCA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|ISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|EISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|MCA
block|,
literal|1
block|,
name|PCI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the bus data */
end_comment

begin_decl_stmt
specifier|static
name|bus_datum
modifier|*
name|bus_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|processor_entry
name|__P
argument_list|(
operator|(
name|proc_entry_ptr
name|entry
operator|,
name|int
name|cpu
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bus_entry
name|__P
argument_list|(
operator|(
name|bus_entry_ptr
name|entry
operator|,
name|int
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|io_apic_entry
name|__P
argument_list|(
operator|(
name|io_apic_entry_ptr
name|entry
operator|,
name|int
name|apic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|int_entry
name|__P
argument_list|(
operator|(
name|int_entry_ptr
name|entry
operator|,
name|int
name|intr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_bus_type
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 1st pass on motherboard's Intel MP specification table.  *  * initializes:  *	mp_ncpus = 1  *  * determines:  *	cpu_apic_address (common to all CPUs)  *	io_apic_address[N]  *	mp_naps  *	mp_nbusses  *	mp_napics  *	nintrs  */
end_comment

begin_function
specifier|static
name|void
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|u_int
name|id_mask
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS1_POST
argument_list|)
expr_stmt|;
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|io_apic_address
index|[
name|x
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* IO APIC address table */
block|}
comment|/* init everything to empty */
name|mp_naps
operator|=
literal|0
expr_stmt|;
name|mp_nbusses
operator|=
literal|0
expr_stmt|;
name|mp_napics
operator|=
literal|0
expr_stmt|;
name|nintrs
operator|=
literal|0
expr_stmt|;
name|id_mask
operator|=
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|if
condition|(
name|MPFPS_MPFB1
operator|!=
literal|0
condition|)
block|{
comment|/* use default addresses */
name|cpu_apic_address
operator|=
name|DEFAULT_APIC_BASE
expr_stmt|;
name|io_apic_address
index|[
literal|0
index|]
operator|=
name|DEFAULT_IO_APIC_BASE
expr_stmt|;
comment|/* fill in with defaults */
name|mp_naps
operator|=
literal|2
expr_stmt|;
comment|/* includes BSP */
name|mp_nbusses
operator|=
name|default_data
index|[
name|MPFPS_MPFB1
operator|-
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|mp_napics
operator|=
literal|1
expr_stmt|;
name|nintrs
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
name|cpu_apic_address
operator|=
operator|(
name|vm_offset_t
operator|)
name|cth
operator|->
name|apic_address
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
comment|/* processor_entry */
if|if
condition|(
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
condition|)
block|{
operator|++
name|mp_naps
expr_stmt|;
name|id_mask
operator||=
literal|1
operator|<<
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_id
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* bus_entry */
operator|++
name|mp_nbusses
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* io_apic_entry */
if|if
condition|(
operator|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
condition|)
name|io_apic_address
index|[
name|mp_napics
operator|++
index|]
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
argument_list|)
operator|->
name|apic_address
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* int_entry */
operator|++
name|nintrs
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
comment|/* qualify the numbers */
if|if
condition|(
name|mp_naps
operator|>
name|MAXCPU
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: only using %d of %d available CPUs!\n"
argument_list|,
name|MAXCPU
argument_list|,
name|mp_naps
argument_list|)
expr_stmt|;
name|mp_naps
operator|=
name|MAXCPU
expr_stmt|;
block|}
comment|/* See if we need to fixup HT logical CPUs. */
name|mptable_hyperthread_fixup
argument_list|(
name|id_mask
argument_list|)
expr_stmt|;
comment|/* 	 * Count the BSP. 	 * This is also used as a counter while starting the APs. 	 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
operator|--
name|mp_naps
expr_stmt|;
comment|/* subtract the BSP */
block|}
end_function

begin_comment
comment|/*  * 2nd pass on motherboard's Intel MP specification table.  *  * sets:  *	boot_cpu_id  *	ID_TO_IO(N), phy APIC ID to log CPU/IO table  *	CPU_TO_ID(N), logical CPU to APIC ID table  *	IO_TO_ID(N), logical IO to APIC ID table  *	bus_data[N]  *	io_apic_ints[N]  */
end_comment

begin_function
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|PROCENTRY
name|proc
decl_stmt|;
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|apic
decl_stmt|,
name|bus
decl_stmt|,
name|cpu
decl_stmt|,
name|intr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pgeflag
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS2_POST
argument_list|)
expr_stmt|;
comment|/* Initialize fake proc entry for use with HT fixup. */
name|bzero
argument_list|(
operator|&
name|proc
argument_list|,
sizeof|sizeof
argument_list|(
name|proc
argument_list|)
argument_list|)
expr_stmt|;
name|proc
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|proc
operator|.
name|cpu_flags
operator|=
name|PROCENTRY_FLAG_EN
expr_stmt|;
name|pgeflag
operator|=
literal|0
expr_stmt|;
comment|/* XXX - Not used under SMP yet.  */
name|MALLOC
argument_list|(
name|io_apic_versions
argument_list|,
name|u_int32_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
name|mp_napics
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ioapic
argument_list|,
specifier|volatile
name|ioapic_t
operator|*
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|ioapic_t
operator|*
argument_list|)
operator|*
name|mp_napics
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|io_apic_ints
argument_list|,
name|io_int
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|io_int
argument_list|)
operator|*
operator|(
name|nintrs
operator|+
literal|1
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|bus_data
argument_list|,
name|bus_datum
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|bus_datum
argument_list|)
operator|*
name|mp_nbusses
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ioapic
argument_list|,
sizeof|sizeof
argument_list|(
name|ioapic_t
operator|*
argument_list|)
operator|*
name|mp_napics
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_napics
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mp_napics
condition|;
name|j
operator|++
control|)
block|{
comment|/* same page frame as a previous IO apic? */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PG_FRAME
operator|)
condition|)
block|{
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|SMP_prvspace
operator|+
operator|(
name|NPTEPG
operator|-
literal|2
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
operator|+
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
break|break;
block|}
comment|/* use this slot if available */
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|&
name|PG_FRAME
operator|)
operator|==
literal|0
condition|)
block|{
name|SMPpt
index|[
name|NPTEPG
operator|-
literal|2
operator|-
name|j
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|pgeflag
operator||
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
name|ioapic
index|[
name|i
index|]
operator|=
operator|(
name|ioapic_t
operator|*
operator|)
operator|(
operator|(
name|u_int
operator|)
name|SMP_prvspace
operator|+
operator|(
name|NPTEPG
operator|-
literal|2
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
operator|+
operator|(
name|io_apic_address
index|[
name|i
index|]
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|ID_TO_IO
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* phy APIC ID to log CPU/IO table */
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical CPU to APIC ID table */
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical IO to APIC ID table */
block|}
comment|/* clear bus data table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|=
literal|0xff
expr_stmt|;
comment|/* clear IO APIC INT table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|nintrs
operator|+
literal|1
operator|)
condition|;
operator|++
name|x
control|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
block|}
comment|/* setup the cpu/apic mapping arrays */
name|boot_cpu_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* record whether PIC or virtual-wire mode */
name|picmode
operator|=
operator|(
name|mpfps
operator|->
name|mpfb2
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|if
condition|(
name|MPFPS_MPFB1
operator|!=
literal|0
condition|)
return|return
name|MPFPS_MPFB1
return|;
comment|/* return default configuration type */
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
name|apic
operator|=
name|bus
operator|=
name|intr
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
literal|1
expr_stmt|;
comment|/* pre-count the BSP */
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|processor_entry
argument_list|(
name|position
argument_list|,
name|cpu
argument_list|)
condition|)
operator|++
name|cpu
expr_stmt|;
if|if
condition|(
name|need_hyperthreading_fixup
condition|)
block|{
comment|/* 				 * Create fake mptable processor entries 				 * and feed them to processor_entry() to 				 * enumerate the logical CPUs. 				 */
name|proc
operator|.
name|apic_id
operator|=
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|logical_cpus
condition|;
name|i
operator|++
control|)
block|{
name|proc
operator|.
name|apic_id
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|processor_entry
argument_list|(
operator|&
name|proc
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|logical_cpus_mask
operator||=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|proc
operator|.
name|apic_id
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
name|hyperthreading_cpus_mask
operator||=
operator|(
literal|1
operator|<<
name|cpu
operator|)
expr_stmt|;
name|cpu
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|logical_cpus
operator|!=
literal|0
condition|)
block|{
name|u_int
name|id
init|=
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_id
decl_stmt|;
comment|/* 				 * If this is an already-enumerated logical 				 * CPU, add it to the bitmap. 				 */
if|if
condition|(
name|id
operator|%
name|logical_cpus
operator|!=
literal|0
condition|)
name|logical_cpus_mask
operator||=
operator|(
literal|1
operator|<<
name|ID_TO_CPU
argument_list|(
name|id
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|hyperthreading_cpus
operator|>
literal|1
operator|&&
name|id
operator|%
name|hyperthreading_cpus
operator|!=
literal|0
condition|)
name|hyperthreading_cpus_mask
operator||=
operator|(
literal|1
operator|<<
name|ID_TO_CPU
argument_list|(
name|id
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|bus_entry
argument_list|(
name|position
argument_list|,
name|bus
argument_list|)
condition|)
operator|++
name|bus
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|io_apic_entry
argument_list|(
name|position
argument_list|,
name|apic
argument_list|)
condition|)
operator|++
name|apic
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|int_entry
argument_list|(
name|position
argument_list|,
name|intr
argument_list|)
condition|)
operator|++
name|intr
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry(position); */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"NO BSP found!"
argument_list|)
expr_stmt|;
comment|/* report fact that its NOT a default configuration */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if we should perform a hyperthreading "fix-up" to  * enumerate any logical CPU's that aren't already listed  * in the table.  *  * XXX: We assume that all of the physical CPUs in the  * system have the same number of logical CPUs.  *  * XXX: We assume that APIC ID's are allocated such that  * the APIC ID's for a physical processor are aligned  * with the number of logical CPU's in the processor.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_hyperthread_fixup
parameter_list|(
name|u_int
name|id_mask
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|id
decl_stmt|;
name|u_int
name|threads_per_cache
decl_stmt|,
name|p
index|[
literal|4
index|]
decl_stmt|;
comment|/* Nothing to do if there is no HTT support. */
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|==
literal|0
condition|)
return|return;
name|logical_cpus
operator|=
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|logical_cpus
operator|<=
literal|1
condition|)
return|return;
comment|/* 	 * Work out if hyperthreading is *really* enabled.  This 	 * is made really ugly by the fact that processors lie: Dual 	 * core processors claim to be hyperthreaded even when they're 	 * not, presumably because they want to be treated the same 	 * way as HTT with respect to per-cpu software licensing. 	 * At the time of writing (May 12, 2005) the only hyperthreaded 	 * cpus are from Intel, and Intel's dual-core processors can be 	 * identified via the "deterministic cache parameters" cpuid 	 * calls. 	 */
comment|/* 	 * First determine if this is an Intel processor which claims 	 * to have hyperthreading support. 	 */
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * If the "deterministic cache parameters" cpuid calls 		 * are available, use them. 		 */
if|if
condition|(
name|cpu_high
operator|>=
literal|4
condition|)
block|{
comment|/* Ask the processor about the L1 cache. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|cpuid_count
argument_list|(
literal|4
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|threads_per_cache
operator|=
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x3ffc000
operator|)
operator|>>
literal|14
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hyperthreading_cpus
operator|<
name|threads_per_cache
condition|)
name|hyperthreading_cpus
operator|=
name|threads_per_cache
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
comment|/* 		 * If the deterministic cache parameters are not 		 * available, or if no caches were reported to exist, 		 * just accept what the HTT flag indicated. 		 */
if|if
condition|(
name|hyperthreading_cpus
operator|==
literal|0
condition|)
name|hyperthreading_cpus
operator|=
name|logical_cpus
expr_stmt|;
block|}
comment|/* 	 * For each APIC ID of a CPU that is set in the mask, 	 * scan the other candidate APIC ID's for this 	 * physical processor.  If any of those ID's are 	 * already in the table, then kill the fixup. 	 */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<=
name|MAXCPU
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id_mask
operator|&
literal|1
operator|<<
name|id
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* First, make sure we are on a logical_cpus boundary. */
if|if
condition|(
name|id
operator|%
name|logical_cpus
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|id
operator|+
literal|1
init|;
name|i
operator|<
name|id
operator|+
name|logical_cpus
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|id_mask
operator|&
literal|1
operator|<<
name|i
operator|)
operator|!=
literal|0
condition|)
return|return;
block|}
comment|/* 	 * Ok, the ID's checked out, so enable the fixup.  We have to fixup 	 * mp_naps right now. 	 */
name|need_hyperthreading_fixup
operator|=
literal|1
expr_stmt|;
name|mp_naps
operator|*=
name|logical_cpus
expr_stmt|;
block|}
end_function

begin_function
name|void
name|assign_apic_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|intpin
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"assign_apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|=
name|apic
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
operator|=
name|intpin
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|apic_address
operator|=
name|ioapic
index|[
name|apic
index|]
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|redirindex
operator|=
name|IOAPIC_REDTBL
operator|+
literal|2
operator|*
name|intpin
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
operator|||
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
name|intpin
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
name|irq
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|revoke_apic_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|oldapic
decl_stmt|;
name|int
name|oldintpin
decl_stmt|;
if|if
condition|(
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"revoke_apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
name|oldapic
operator|=
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
expr_stmt|;
name|oldintpin
operator|=
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|=
operator|-
literal|1
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|int_pin
operator|=
literal|0
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|apic_address
operator|=
name|NULL
expr_stmt|;
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|redirindex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
operator|||
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|!=
literal|0xff
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
name|oldapic
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
name|oldintpin
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|allocate_apic_irq
parameter_list|(
name|int
name|intr
parameter_list|)
block|{
name|int
name|apic
decl_stmt|;
name|int
name|intpin
decl_stmt|;
name|int
name|irq
decl_stmt|;
if|if
condition|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_vector
operator|!=
literal|0xff
condition|)
return|return;
comment|/* Interrupt handler already assigned */
if|if
condition|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|!=
literal|0
operator|&&
operator|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|!=
literal|3
operator|||
operator|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
operator|==
literal|0
operator|)
operator|)
condition|)
return|return;
comment|/* Not INT or ExtInt on != (0, 0) */
name|irq
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|irq
operator|<
name|APIC_INTMAPSIZE
operator|&&
name|int_to_apicintpin
index|[
name|irq
index|]
operator|.
name|ioapic
operator|!=
operator|-
literal|1
condition|)
name|irq
operator|++
expr_stmt|;
if|if
condition|(
name|irq
operator|>=
name|APIC_INTMAPSIZE
condition|)
return|return;
comment|/* No free interrupt handlers */
name|apic
operator|=
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
argument_list|)
expr_stmt|;
name|intpin
operator|=
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
expr_stmt|;
name|assign_apic_irq
argument_list|(
name|apic
argument_list|,
name|intpin
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|io_apic_setup_intpin
argument_list|(
name|apic
argument_list|,
name|intpin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap_apic_id
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|oldid
parameter_list|,
name|int
name|newid
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|oapic
decl_stmt|;
if|if
condition|(
name|oldid
operator|==
name|newid
condition|)
return|return;
comment|/* Nothing to do */
name|printf
argument_list|(
literal|"Changing APIC ID for IO APIC #%d from %d to %d in MP table\n"
argument_list|,
name|apic
argument_list|,
name|oldid
argument_list|,
name|newid
argument_list|)
expr_stmt|;
comment|/* Swap physical APIC IDs in interrupt entries */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|oldid
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|=
name|newid
expr_stmt|;
elseif|else
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|newid
condition|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|=
name|oldid
expr_stmt|;
block|}
comment|/* Swap physical APIC IDs in IO_TO_ID mappings */
for|for
control|(
name|oapic
operator|=
literal|0
init|;
name|oapic
operator|<
name|mp_napics
condition|;
name|oapic
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|==
name|newid
condition|)
break|break;
if|if
condition|(
name|oapic
operator|<
name|mp_napics
condition|)
block|{
name|printf
argument_list|(
literal|"Changing APIC ID for IO APIC #%d from "
literal|"%d to %d in MP table\n"
argument_list|,
name|oapic
argument_list|,
name|newid
argument_list|,
name|oldid
argument_list|)
expr_stmt|;
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|=
name|oldid
expr_stmt|;
block|}
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|=
name|newid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fix_id_to_io_mapping
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
name|x
operator|++
control|)
name|ID_TO_IO
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|mp_naps
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|first_free_apic_id
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|freeid
decl_stmt|,
name|x
decl_stmt|;
for|for
control|(
name|freeid
operator|=
literal|0
init|;
name|freeid
operator|<
name|NAPICID
condition|;
name|freeid
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<=
name|mp_naps
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|==
name|freeid
condition|)
break|break;
if|if
condition|(
name|x
operator|<=
name|mp_naps
condition|)
continue|continue;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
name|x
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|==
name|freeid
condition|)
break|break;
if|if
condition|(
name|x
operator|<
name|mp_napics
condition|)
continue|continue;
return|return
name|freeid
return|;
block|}
return|return
name|freeid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|io_apic_id_acceptable
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
comment|/* Logical CPU number */
name|int
name|oapic
decl_stmt|;
comment|/* Logical IO APIC number for other IO APIC */
if|if
condition|(
name|id
operator|>=
name|NAPICID
condition|)
return|return
literal|0
return|;
comment|/* Out of range */
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<=
name|mp_naps
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_TO_ID
argument_list|(
name|cpu
argument_list|)
operator|==
name|id
condition|)
return|return
literal|0
return|;
comment|/* Conflict with CPU */
for|for
control|(
name|oapic
operator|=
literal|0
init|;
name|oapic
operator|<
name|mp_napics
operator|&&
name|oapic
operator|<
name|apic
condition|;
name|oapic
operator|++
control|)
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|oapic
argument_list|)
operator|==
name|id
condition|)
return|return
literal|0
return|;
comment|/* Conflict with other APIC */
return|return
literal|1
return|;
comment|/* ID is acceptable for IO APIC */
block|}
end_function

begin_comment
comment|/*  * parse an Intel MP specification table  */
end_comment

begin_function
specifier|static
name|void
name|fix_mp_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|bus_0
init|=
literal|0
decl_stmt|;
comment|/* Stop GCC warning */
name|int
name|bus_pci
init|=
literal|0
decl_stmt|;
comment|/* Stop GCC warning */
name|int
name|num_pci_bus
decl_stmt|;
name|int
name|apic
decl_stmt|;
comment|/* IO APIC unit number */
name|int
name|freeid
decl_stmt|;
comment|/* Free physical APIC ID */
name|int
name|physid
decl_stmt|;
comment|/* Current physical IO APIC ID */
comment|/* 	 * Fix mis-numbering of the PCI bus and its INT entries if the BIOS 	 * did it wrong.  The MP spec says that when more than 1 PCI bus 	 * exists the BIOS must begin with bus entries for the PCI bus and use 	 * actual PCI bus numbering.  This implies that when only 1 PCI bus 	 * exists the BIOS can choose to ignore this ordering, and indeed many 	 * MP motherboards do ignore it.  This causes a problem when the PCI 	 * sub-system makes requests of the MP sub-system based on PCI bus 	 * numbers.	So here we look for the situation and renumber the 	 * busses and associated INTs in an effort to "make it right". 	 */
comment|/* find bus 0, PCI bus, count the number of PCI busses */
for|for
control|(
name|num_pci_bus
operator|=
literal|0
operator|,
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
literal|0
condition|)
block|{
name|bus_0
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
operator|==
name|PCI
condition|)
block|{
operator|++
name|num_pci_bus
expr_stmt|;
name|bus_pci
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* 	 * bus_0 == slot of bus with ID of 0 	 * bus_pci == slot of last PCI bus encountered 	 */
comment|/* check the 1 PCI bus case for sanity */
comment|/* if it is number 0 all is well */
if|if
condition|(
name|num_pci_bus
operator|==
literal|1
operator|&&
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
operator|!=
literal|0
condition|)
block|{
comment|/* mis-numbered, swap with whichever bus uses slot 0 */
comment|/* swap the bus entry types */
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_type
operator|=
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
expr_stmt|;
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
operator|=
name|PCI
expr_stmt|;
comment|/* swap each relavant INTerrupt entry */
name|id
operator|=
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
name|id
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
literal|0
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
name|id
expr_stmt|;
block|}
block|}
block|}
comment|/* Assign IO APIC IDs. 	 *  	 * First try the existing ID. If a conflict is detected, try 	 * the ID in the MP table.  If a conflict is still detected, find 	 * a free id. 	 * 	 * We cannot use the ID_TO_IO table before all conflicts has been 	 * resolved and the table has been corrected. 	 */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
block|{
comment|/* For all IO APICs */
comment|/* First try to use the value set by the BIOS */
name|physid
operator|=
name|io_apic_get_id
argument_list|(
name|apic
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|physid
argument_list|)
condition|)
block|{
if|if
condition|(
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|!=
name|physid
condition|)
name|swap_apic_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|,
name|physid
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Then check if the value in the MP table is acceptable */
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* Last resort, find a free APIC ID and use it */
name|freeid
operator|=
name|first_free_apic_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|freeid
operator|>=
name|NAPICID
condition|)
name|panic
argument_list|(
literal|"No free physical APIC IDs found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|io_apic_id_acceptable
argument_list|(
name|apic
argument_list|,
name|freeid
argument_list|)
condition|)
block|{
name|swap_apic_id
argument_list|(
name|apic
argument_list|,
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
argument_list|,
name|freeid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|panic
argument_list|(
literal|"Free physical APIC ID not usable"
argument_list|)
expr_stmt|;
block|}
name|fix_id_to_io_mapping
argument_list|()
expr_stmt|;
comment|/* detect and fix broken Compaq MP table */
if|if
condition|(
name|apic_int_type
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"APIC_IO: MP table broken: 8259->APIC entry missing!\n"
argument_list|)
expr_stmt|;
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
comment|/* ExtInt */
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
comment|/* Unassigned */
comment|/* XXX fixme, set src bus id etc, but it doesn't seem to hurt */
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|dst_apic_id
operator|=
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|io_apic_ints
index|[
name|nintrs
index|]
operator|.
name|dst_apic_int
operator|=
literal|0
expr_stmt|;
comment|/* Pin 0 */
name|nintrs
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apic_int_type
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"APIC_IO: MP table broken: ExtINT entry corrupt!\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
literal|0
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
literal|0
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|=
literal|0xff
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Assign low level interrupt handlers */
end_comment

begin_function
specifier|static
name|void
name|setup_apic_irq_mapping
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|int_vector
decl_stmt|;
comment|/* Clear array */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|APIC_INTMAPSIZE
condition|;
name|x
operator|++
control|)
block|{
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|ioapic
operator|=
operator|-
literal|1
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|int_pin
operator|=
literal|0
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|apic_address
operator|=
name|NULL
expr_stmt|;
name|int_to_apicintpin
index|[
name|x
index|]
operator|.
name|redirindex
operator|=
literal|0
expr_stmt|;
block|}
comment|/* First assign ISA/EISA interrupts */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
name|int_vector
operator|=
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_irq
expr_stmt|;
if|if
condition|(
name|int_vector
operator|<
name|APIC_INTMAPSIZE
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|int_to_apicintpin
index|[
name|int_vector
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
operator|&&
operator|(
name|apic_int_is_bus_type
argument_list|(
name|x
argument_list|,
name|ISA
argument_list|)
operator|||
name|apic_int_is_bus_type
argument_list|(
name|x
argument_list|,
name|EISA
argument_list|)
operator|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|0
condition|)
block|{
name|assign_apic_irq
argument_list|(
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
argument_list|,
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
argument_list|,
name|int_vector
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Assign ExtInt entry if no ISA/EISA interrupt 0 entry */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|==
literal|0
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
operator|==
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
operator|==
literal|0xff
operator|&&
name|int_to_apicintpin
index|[
literal|0
index|]
operator|.
name|ioapic
operator|==
operator|-
literal|1
operator|&&
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|==
literal|3
condition|)
block|{
name|assign_apic_irq
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* PCI interrupt assignment is deferred */
block|}
end_function

begin_function
specifier|static
name|int
name|processor_entry
parameter_list|(
name|proc_entry_ptr
name|entry
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
comment|/* check for usability */
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|entry
operator|->
name|apic_id
operator|>=
name|NAPICID
condition|)
name|panic
argument_list|(
literal|"CPU APIC ID out of range (0..%d)"
argument_list|,
name|NAPICID
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* check for BSP flag */
if|if
condition|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_BP
condition|)
block|{
name|boot_cpu_id
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* its already been counted */
block|}
comment|/* add another AP to list, if less than max number of CPUs */
elseif|else
if|if
condition|(
name|cpu
operator|<
name|MAXCPU
condition|)
block|{
name|CPU_TO_ID
argument_list|(
name|cpu
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|cpu
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bus_entry
parameter_list|(
name|bus_entry_ptr
name|entry
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|char
name|c
decl_stmt|,
name|name
index|[
literal|8
index|]
decl_stmt|;
comment|/* encode the name into an index */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|6
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|entry
operator|->
name|bus_type
index|[
name|x
index|]
operator|)
operator|==
literal|' '
condition|)
break|break;
name|name
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
block|}
name|name
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|lookup_bus_type
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|UNKNOWN_BUSTYPE
condition|)
name|panic
argument_list|(
literal|"unknown bus type: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|=
name|entry
operator|->
name|bus_id
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|=
name|x
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|io_apic_entry
parameter_list|(
name|io_apic_entry_ptr
name|entry
parameter_list|,
name|int
name|apic
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|apic_id
operator|<
name|NAPICID
condition|)
name|ID_TO_IO
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|apic
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_bus_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAX_BUSTYPE
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bus_type_table
index|[
name|x
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bus_type_table
index|[
name|x
index|]
operator|.
name|type
return|;
return|return
name|UNKNOWN_BUSTYPE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|int_entry
parameter_list|(
name|int_entry_ptr
name|entry
parameter_list|,
name|int
name|intr
parameter_list|)
block|{
name|int
name|apic
decl_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|=
name|entry
operator|->
name|int_type
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_flags
operator|=
name|entry
operator|->
name|int_flags
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|=
name|entry
operator|->
name|src_bus_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_irq
operator|=
name|entry
operator|->
name|src_bus_irq
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|dst_apic_id
operator|==
literal|255
condition|)
block|{
comment|/* This signal goes to all IO APICS.  Select an IO APIC 		   with sufficient number of interrupt pins */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
name|apic
operator|++
control|)
block|{
if|if
condition|(
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
operator|==
literal|0xffffffff
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
operator|&
name|IOART_VER_MAXREDIR
operator|)
operator|>>
name|MAXREDIRSHIFT
operator|)
operator|>=
name|entry
operator|->
name|dst_apic_int
condition|)
break|break;
block|}
if|if
condition|(
name|apic
operator|<
name|mp_napics
condition|)
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
expr_stmt|;
else|else
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|entry
operator|->
name|dst_apic_id
expr_stmt|;
block|}
else|else
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|entry
operator|->
name|dst_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
operator|=
name|entry
operator|->
name|dst_apic_int
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apic_int_is_bus_type
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|bus_type
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|mp_nbusses
condition|;
operator|++
name|bus
control|)
if|if
condition|(
operator|(
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|==
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|==
name|bus_type
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a traditional ISA INT mask, return an APIC mask.  */
end_comment

begin_function
name|u_int
name|isa_apic_mask
parameter_list|(
name|u_int
name|isa_mask
parameter_list|)
block|{
name|int
name|isa_irq
decl_stmt|;
name|int
name|apic_pin
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SKIP_IRQ15_REDIRECT
argument_list|)
if|if
condition|(
name|isa_mask
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"skipping ISA IRQ15 redirect\n"
argument_list|)
expr_stmt|;
return|return
name|isa_mask
return|;
block|}
endif|#
directive|endif
comment|/* SKIP_IRQ15_REDIRECT */
name|isa_irq
operator|=
name|ffs
argument_list|(
name|isa_mask
argument_list|)
expr_stmt|;
comment|/* find its bit position */
if|if
condition|(
name|isa_irq
operator|==
literal|0
condition|)
comment|/* doesn't exist */
return|return
literal|0
return|;
operator|--
name|isa_irq
expr_stmt|;
comment|/* make it zero based */
name|apic_pin
operator|=
name|isa_apic_irq
argument_list|(
name|isa_irq
argument_list|)
expr_stmt|;
comment|/* look for APIC connection */
if|if
condition|(
name|apic_pin
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
literal|1
operator|<<
name|apic_pin
operator|)
return|;
comment|/* convert pin# to a mask */
block|}
end_function

begin_comment
comment|/*  * Determine which APIC pin an ISA/EISA INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|INTTYPE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].int_type)
end_define

begin_define
define|#
directive|define
name|INTPIN
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].dst_apic_int)
end_define

begin_define
define|#
directive|define
name|INTIRQ
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].int_vector)
end_define

begin_define
define|#
directive|define
name|INTAPIC
parameter_list|(
name|I
parameter_list|)
value|(ID_TO_IO(io_apic_ints[(I)].dst_apic_id))
end_define

begin_define
define|#
directive|define
name|SRCBUSIRQ
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq)
end_define

begin_function
name|int
name|isa_apic_irq
parameter_list|(
name|int
name|isa_irq
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
block|{
comment|/* check each record */
if|if
condition|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* standard INT */
if|if
condition|(
name|SRCBUSIRQ
argument_list|(
name|intr
argument_list|)
operator|==
name|isa_irq
condition|)
block|{
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|ISA
argument_list|)
operator|||
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|EISA
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
comment|/* unassigned */
return|return
name|INTIRQ
argument_list|(
name|intr
argument_list|)
return|;
comment|/* found */
block|}
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * Determine which APIC pin a PCI INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|SRCBUSID
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_id)
end_define

begin_define
define|#
directive|define
name|SRCBUSDEVICE
parameter_list|(
name|I
parameter_list|)
value|((io_apic_ints[(I)].src_bus_irq>> 2)& 0x1f)
end_define

begin_define
define|#
directive|define
name|SRCBUSLINE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq& 0x03)
end_define

begin_function
specifier|static
name|int
name|pci_apic_irq_raw
parameter_list|(
name|int
name|pciBus
parameter_list|,
name|int
name|pciDevice
parameter_list|,
name|int
name|pciInt
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
operator|--
name|pciInt
expr_stmt|;
comment|/* zero based */
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
comment|/* check each record */
if|if
condition|(
operator|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
operator|)
comment|/* standard INT */
operator|&&
operator|(
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
operator|==
name|pciBus
operator|)
operator|&&
operator|(
name|SRCBUSDEVICE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciDevice
operator|)
operator|&&
operator|(
name|SRCBUSLINE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciInt
operator|)
condition|)
comment|/* a candidate IRQ */
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|PCI
argument_list|)
condition|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
name|allocate_apic_irq
argument_list|(
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
comment|/* unassigned */
return|return
name|INTIRQ
argument_list|(
name|intr
argument_list|)
return|;
comment|/* exact match */
block|}
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_function
specifier|static
name|int
name|pci_apic_bus_present
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
if|if
condition|(
operator|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
operator|==
name|bus
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pci_apic_irq
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|device
parameter_list|,
name|int
name|pin
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|device_t
name|dev
decl_stmt|,
name|bus_dev
decl_stmt|,
name|pcib
decl_stmt|,
name|parent
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|parent
operator|=
operator|(
name|device_t
operator|)
name|arg
expr_stmt|;
name|pcib
operator|=
name|NULL
expr_stmt|;
name|loop
label|:
comment|/* See if there is an exact match first. */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"APIC_IO: trying to route %d:%d INT%c\n"
argument_list|,
name|bus
argument_list|,
name|device
argument_list|,
name|pin
operator|+
literal|'A'
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|irq
operator|=
name|pci_apic_irq_raw
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
name|pin
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|irq
operator|)
return|;
comment|/* If this bus has other entries but not this one, punt. */
if|if
condition|(
name|pci_apic_bus_present
argument_list|(
name|bus
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Safety net, don't try to walk past bus 0. */
if|if
condition|(
name|bus
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Try to find our parent bus and the bridge it hangs off of.  If 	 * we are recursing up the chain, we need to find the previous bridge's 	 * parent bus.  If we have a valid parent device, then that is our 	 * parent bus.  Otherwise, try to find ourself so that we can find 	 * our parent bus.  Every device has a function of 0 and we are 	 * really just trying to find our parent, so assume a function of 0 	 * to find either ourself or one of our siblings. 	 */
if|if
condition|(
name|pcib
operator|!=
name|NULL
condition|)
name|bus_dev
operator|=
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|bus_dev
operator|=
name|parent
expr_stmt|;
else|else
block|{
name|dev
operator|=
name|pci_find_bsf
argument_list|(
name|bus
argument_list|,
name|device
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bus_dev
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bus_dev
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcib
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Do the swizzle thing. 	 * 	 * XXX: no error checking for the bus number here 	 * (valid, does it exist, etc.). 	 */
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
name|pin
operator|=
operator|(
name|device
operator|+
operator|(
name|pin
operator|-
literal|1
operator|)
operator|)
operator|%
literal|4
operator|+
literal|1
expr_stmt|;
name|device
operator|=
name|pci_get_slot
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_function
name|int
name|next_apic_irq
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|int
name|intr
decl_stmt|,
name|ointr
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|bustype
decl_stmt|;
name|bus
operator|=
literal|0
expr_stmt|;
name|bustype
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
name|intr
operator|++
control|)
block|{
if|if
condition|(
name|INTIRQ
argument_list|(
name|intr
argument_list|)
operator|!=
name|irq
operator|||
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|bus
operator|=
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
expr_stmt|;
name|bustype
operator|=
name|apic_bus_type
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|bustype
operator|!=
name|ISA
operator|&&
name|bustype
operator|!=
name|EISA
operator|&&
name|bustype
operator|!=
name|PCI
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|intr
operator|>=
name|nintrs
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|ointr
operator|=
name|intr
operator|+
literal|1
init|;
name|ointr
operator|<
name|nintrs
condition|;
name|ointr
operator|++
control|)
block|{
if|if
condition|(
name|INTTYPE
argument_list|(
name|ointr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bus
operator|!=
name|SRCBUSID
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|bustype
operator|==
name|PCI
condition|)
block|{
if|if
condition|(
name|SRCBUSDEVICE
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSDEVICE
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|SRCBUSLINE
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSLINE
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|bustype
operator|==
name|ISA
operator|||
name|bustype
operator|==
name|EISA
condition|)
block|{
if|if
condition|(
name|SRCBUSIRQ
argument_list|(
name|intr
argument_list|)
operator|!=
name|SRCBUSIRQ
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|INTPIN
argument_list|(
name|intr
argument_list|)
operator|==
name|INTPIN
argument_list|(
name|ointr
argument_list|)
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ointr
operator|>=
name|nintrs
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
return|return
name|INTIRQ
argument_list|(
name|ointr
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRCBUSLINE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSDEVICE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSID
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSIRQ
end_undef

begin_undef
undef|#
directive|undef
name|INTPIN
end_undef

begin_undef
undef|#
directive|undef
name|INTIRQ
end_undef

begin_undef
undef|#
directive|undef
name|INTAPIC
end_undef

begin_undef
undef|#
directive|undef
name|INTTYPE
end_undef

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect an ISA INTerrupt.  *  * XXX FIXME:  *  Exactly what this means is unclear at this point.  It is a solution  *  for motherboards that redirect the MBIRQ0 pin.  Generically a motherboard  *  could route any of the ISA INTs to upper (>15) IRQ values.  But most would  *  NOT be redirected via MBIRQ0, thus "undirect()ing" them would NOT be an  *  option.  */
end_comment

begin_function
name|int
name|undirect_isa_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|???
return|;
else|#
directive|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect a PCI INTerrupt  */
end_comment

begin_function
name|int
name|undirect_pci_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|???
return|;
else|#
directive|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * given a bus ID, return:  *  the bus type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_bus_type
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
name|id
condition|)
return|return
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus ID if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_id
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus IRQ if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_irq
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated INTerrupt type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_int_type
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_function
name|int
name|apic_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|res
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
block|{
name|res
operator|=
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_vector
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0xff
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|apic
operator|!=
name|int_to_apicintpin
index|[
name|res
index|]
operator|.
name|ioapic
condition|)
name|panic
argument_list|(
literal|"apic_irq: inconsistent table"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pin
operator|!=
name|int_to_apicintpin
index|[
name|res
index|]
operator|.
name|int_pin
condition|)
name|panic
argument_list|(
literal|"apic_irq inconsistent table (2)"
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated trigger mode if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_trigger
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|>>
literal|2
operator|)
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated 'active' level if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_polarity
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * set data according to MP defaults  * FIXME: probably not complete yet...  */
end_comment

begin_function
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|int
name|ap_cpu_id
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|int
name|io_apic_id
decl_stmt|;
name|int
name|pin
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
if|#
directive|if
literal|0
block|printf("  MP default config type: %d\n", type); 	switch (type) { 	case 1: 		printf("   bus: ISA, APIC: 82489DX\n"); 		break; 	case 2: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 3: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 4: 		printf("   bus: MCA, APIC: 82489DX\n"); 		break; 	case 5: 		printf("   bus: ISA+PCI, APIC: Integrated\n"); 		break; 	case 6: 		printf("   bus: EISA+PCI, APIC: Integrated\n"); 		break; 	case 7: 		printf("   bus: MCA+PCI, APIC: Integrated\n"); 		break; 	default: 		printf("   future type\n"); 		break;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
comment|/* 0 */
name|boot_cpu_id
operator|=
operator|(
name|lapic
operator|.
name|id
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
name|ap_cpu_id
operator|=
operator|(
name|boot_cpu_id
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* BSP */
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|boot_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|boot_cpu_id
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* one and only AP */
name|CPU_TO_ID
argument_list|(
literal|1
argument_list|)
operator|=
name|ap_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|ap_cpu_id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* one and only IO APIC */
name|io_apic_id
operator|=
operator|(
name|io_apic_read
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|)
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
comment|/* 	 * sanity check, refer to MP spec section 3.6.6, last paragraph 	 * necessary as some hardware isn't properly setting up the IO APIC 	 */
if|#
directive|if
name|defined
argument_list|(
name|REALLY_ANAL_IOAPICID_VALUE
argument_list|)
if|if
condition|(
name|io_apic_id
operator|!=
literal|2
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|io_apic_id
operator|==
literal|0
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|1
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|15
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* REALLY_ANAL_IOAPICID_VALUE */
name|io_apic_set_id
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|io_apic_id
operator|=
literal|2
expr_stmt|;
block|}
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|io_apic_id
expr_stmt|;
name|ID_TO_IO
argument_list|(
name|io_apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* fill out bus entries */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|4
index|]
expr_stmt|;
break|break;
comment|/* case 4: case 7:		   MCA NOT supported */
default|default:
comment|/* illegal/reserved */
name|panic
argument_list|(
literal|"BAD default MP config: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* general cases from MP v1.4, table 5-2 */
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|16
condition|;
operator|++
name|pin
control|)
block|{
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_type
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_flags
operator|=
literal|0x05
expr_stmt|;
comment|/* edge/active-hi */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_irq
operator|=
name|pin
expr_stmt|;
comment|/* IRQ2 caught below */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_id
operator|=
name|io_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_int
operator|=
name|pin
expr_stmt|;
comment|/* 1-to-1 */
block|}
comment|/* special cases from MP v1.4, table 5-2 */
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
name|io_apic_ints
index|[
literal|13
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|APIC_MIXED_MODE
argument_list|)
comment|/** FIXME: ??? */
name|panic
argument_list|(
literal|"sorry, can't support type 2 default yet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_MIXED_MODE */
block|}
else|else
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|src_bus_irq
operator|=
literal|0
expr_stmt|;
comment|/* ISA IRQ0 is on APIC INT 2 */
if|if
condition|(
name|type
operator|==
literal|7
condition|)
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
else|else
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
comment|/* vectored 8259 */
endif|#
directive|endif
comment|/* APIC_IO */
block|}
comment|/*  * initialize all the SMP locks  */
comment|/* critical region around IO APIC, apic_imen */
name|struct
name|simplelock
name|imen_lock
decl_stmt|;
comment|/* critical region around splxx(), cpl, cml, cil, ipending */
name|struct
name|simplelock
name|cpl_lock
decl_stmt|;
comment|/* Make FAST_INTR() routines sequential */
name|struct
name|simplelock
name|fast_intr_lock
decl_stmt|;
comment|/* critical region around INTR() routines */
name|struct
name|simplelock
name|intr_lock
decl_stmt|;
comment|/* lock regions protected in UP kernel via cli/sti */
name|struct
name|simplelock
name|mpintr_lock
decl_stmt|;
comment|/* lock region used by kernel profiling */
name|struct
name|simplelock
name|mcount_lock
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_COMLOCK
comment|/* locks com (tty) data/hardware accesses: a FASTINTR() */
name|struct
name|simplelock
name|com_lock
decl_stmt|;
endif|#
directive|endif
comment|/* USE_COMLOCK */
ifdef|#
directive|ifdef
name|USE_CLOCKLOCK
comment|/* lock regions around the clock hardware */
name|struct
name|simplelock
name|clock_lock
decl_stmt|;
endif|#
directive|endif
comment|/* USE_CLOCKLOCK */
comment|/* lock around the MP rendezvous */
specifier|static
name|struct
name|simplelock
name|smp_rv_lock
decl_stmt|;
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Get the initial mp_lock with a count of 1 for the BSP. 	 * This uses a LOGICAL cpu ID, ie BSP == 0. 	 */
name|mp_lock
operator|=
literal|0x00000001
expr_stmt|;
if|#
directive|if
literal|0
comment|/* ISR uses its own "giant lock" */
block|isr_lock = FREE_LOCK;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|APIC_INTR_DIAGNOSTIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|APIC_INTR_DIAGNOSTIC_IRQ
argument_list|)
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|apic_itrace_debuglock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|mpintr_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|mcount_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|fast_intr_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|intr_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|imen_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|cpl_lock
argument_list|)
expr_stmt|;
name|s_lock_init
argument_list|(
operator|&
name|smp_rv_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_COMLOCK
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|com_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_COMLOCK */
ifdef|#
directive|ifdef
name|USE_CLOCKLOCK
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|clock_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_CLOCKLOCK */
block|}
comment|/* Wait for all APs to be fully initialized */
specifier|extern
name|int
name|wait_ap
argument_list|(
name|unsigned
name|int
argument_list|)
decl_stmt|;
comment|/*  * start each AP in our list  */
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|,
name|pg
decl_stmt|;
name|u_char
name|mpbiosreason
decl_stmt|;
name|u_long
name|mpbioswarmvec
decl_stmt|;
name|struct
name|globaldata
modifier|*
name|gd
decl_stmt|;
name|char
modifier|*
name|stack
decl_stmt|;
name|uintptr_t
name|kptbase
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_ALL_APS_POST
argument_list|)
expr_stmt|;
comment|/* initialize BSP's local APIC */
name|apic_initialize
argument_list|()
expr_stmt|;
name|bsp_apic_ready
operator|=
literal|1
expr_stmt|;
comment|/* install the AP 1st level boot code */
name|install_ap_tramp
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
comment|/* save the current value of the warm-start vector */
name|mpbioswarmvec
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|mpbiosreason
operator|=
name|inb
argument_list|(
name|CMOS_DATA
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* record BSP in CPU map */
name|all_cpus
operator|=
literal|1
expr_stmt|;
comment|/* set up temporary P==V mapping for AP boot */
comment|/* XXX this is a hack, we should boot the AP on its own stack/PTD */
name|kptbase
operator|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|KPTphys
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NKPT
condition|;
name|x
operator|++
control|)
name|PTD
index|[
name|x
index|]
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|kptbase
operator|+
name|x
operator|*
name|PAGE_SIZE
operator|)
operator|&
name|PG_FRAME
operator|)
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* start each AP */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
comment|/* This is a bit verbose, it will go away soon.  */
comment|/* first page of AP's private space */
name|pg
operator|=
name|x
operator|*
name|i386_btop
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|privatespace
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate a new private data page */
name|gd
operator|=
operator|(
expr|struct
name|globaldata
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* wire it into the private page table page */
name|SMPpt
index|[
name|pg
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|gd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate and set up an idle stack data page */
name|stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|UPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|SMPpt
index|[
name|pg
operator|+
literal|6
operator|+
name|i
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|PAGE_SIZE
operator|*
name|i
operator|+
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|SMPpt
index|[
name|pg
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* *prv_CMAP1 */
name|SMPpt
index|[
name|pg
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* *prv_CMAP2 */
name|SMPpt
index|[
name|pg
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* *prv_CMAP3 */
name|SMPpt
index|[
name|pg
operator|+
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* *prv_PMAP1 */
name|SMPpt
index|[
name|pg
operator|+
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* *prv_PMAP2 */
comment|/* prime data page for it to use */
name|gd
operator|->
name|gd_cpuid
operator|=
name|x
expr_stmt|;
name|gd
operator|->
name|gd_cpu_lockid
operator|=
name|x
operator|<<
literal|24
expr_stmt|;
name|gd
operator|->
name|gd_prv_CMAP1
operator|=
operator|&
name|SMPpt
index|[
name|pg
operator|+
literal|1
index|]
expr_stmt|;
name|gd
operator|->
name|gd_prv_CMAP2
operator|=
operator|&
name|SMPpt
index|[
name|pg
operator|+
literal|2
index|]
expr_stmt|;
name|gd
operator|->
name|gd_prv_CMAP3
operator|=
operator|&
name|SMPpt
index|[
name|pg
operator|+
literal|3
index|]
expr_stmt|;
name|gd
operator|->
name|gd_prv_PMAP1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|&
name|SMPpt
index|[
name|pg
operator|+
literal|4
index|]
expr_stmt|;
name|gd
operator|->
name|gd_prv_PMAP2
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
operator|&
name|SMPpt
index|[
name|pg
operator|+
literal|5
index|]
expr_stmt|;
name|gd
operator|->
name|gd_prv_CADDR1
operator|=
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|CPAGE1
expr_stmt|;
name|gd
operator|->
name|gd_prv_CADDR2
operator|=
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|CPAGE2
expr_stmt|;
name|gd
operator|->
name|gd_prv_CADDR3
operator|=
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|CPAGE3
expr_stmt|;
name|gd
operator|->
name|gd_prv_PADDR1
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|PPAGE1
expr_stmt|;
name|gd
operator|->
name|gd_prv_PADDR2
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|PPAGE2
expr_stmt|;
comment|/* setup a vector to our boot code */
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
operator|=
name|WARMBOOT_TARGET
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_SEG
operator|)
operator|=
operator|(
name|boot_addr
operator|>>
literal|4
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|BIOS_WARM
argument_list|)
expr_stmt|;
comment|/* 'warm-start' */
endif|#
directive|endif
name|bootSTK
operator|=
operator|&
name|SMP_prvspace
index|[
name|x
index|]
operator|.
name|idlestack
index|[
name|UPAGES
operator|*
name|PAGE_SIZE
index|]
expr_stmt|;
name|bootAP
operator|=
name|x
expr_stmt|;
comment|/* attempt to start the Application Processor */
name|CHECK_INIT
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|/* setup checkpoints */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|x
argument_list|,
name|boot_addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AP #%d (PHY# %d) failed!\n"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* better panic as the AP may be running loose */
name|printf
argument_list|(
literal|"panic y/n? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cngetc
argument_list|()
operator|!=
literal|'n'
condition|)
name|panic
argument_list|(
literal|"bye-bye"
argument_list|)
expr_stmt|;
block|}
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* record its version info */
name|cpu_apic_versions
index|[
name|x
index|]
operator|=
name|cpu_apic_versions
index|[
literal|0
index|]
expr_stmt|;
name|all_cpus
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* build our map of 'other' CPUs */
name|other_cpus
operator|=
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|cpuid
operator|)
expr_stmt|;
comment|/* fill in our (BSP) APIC version */
name|cpu_apic_versions
index|[
literal|0
index|]
operator|=
name|lapic
operator|.
name|version
expr_stmt|;
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
ifndef|#
directive|ifndef
name|PC98
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|mpbiosreason
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up the idle context for the BSP.  Similar to above except 	 * that some was done by locore, some by pmap.c and some is implicit 	 * because the BSP is cpu#0 and the page is initially zero, and also 	 * because we can refer to variables by name on the BSP.. 	 */
comment|/* Allocate and setup BSP idle stack */
name|stack
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|UPAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UPAGES
condition|;
name|i
operator|++
control|)
name|SMPpt
index|[
literal|6
operator|+
name|i
index|]
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|PAGE_SIZE
operator|*
name|i
operator|+
name|stack
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NKPT
condition|;
name|x
operator|++
control|)
name|PTD
index|[
name|x
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_set_opt
argument_list|()
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_ncpus
operator|-
literal|1
return|;
block|}
comment|/*  * load the 1st level AP boot code into base memory.  */
comment|/* targets for relocation */
specifier|extern
name|void
name|bigJump
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootCodeSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootDataSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|MPentry
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|u_int
name|MP_GDT
decl_stmt|;
specifier|extern
name|u_int
name|mp_gdtbase
decl_stmt|;
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|size
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
operator|&
name|bootMP_size
operator|)
decl_stmt|;
name|u_char
modifier|*
name|src
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|bootMP
operator|)
decl_stmt|;
name|u_char
modifier|*
name|dst
init|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
decl_stmt|;
name|u_int
name|boot_base
init|=
operator|(
name|u_int
operator|)
name|bootMP
decl_stmt|;
name|u_int8_t
modifier|*
name|dst8
decl_stmt|;
name|u_int16_t
modifier|*
name|dst16
decl_stmt|;
name|u_int32_t
modifier|*
name|dst32
decl_stmt|;
name|POSTCODE
argument_list|(
name|INSTALL_AP_TRAMP_POST
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|size
condition|;
operator|++
name|x
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* 	 * modify addresses in code we just moved to basemem. unfortunately we 	 * need fairly detailed info about mpboot.s for this to work.  changes 	 * to mpboot.s might require changes here. 	 */
comment|/* boot code is located in KERNEL space */
name|dst
operator|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
expr_stmt|;
comment|/* modify the lgdt arg */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|mp_gdtbase
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
name|boot_addr
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|MP_GDT
operator|-
name|boot_base
operator|)
expr_stmt|;
comment|/* modify the ljmp target for MPentry() */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bigJump
operator|-
name|boot_base
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
operator|(
operator|(
name|u_int
operator|)
name|MPentry
operator|-
name|KERNBASE
operator|)
expr_stmt|;
comment|/* modify the target for boot code segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootCodeSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* modify the target for boot data segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootDataSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*  * this function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It ain't pretty,  * but it seems to work.  */
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logical_cpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|physical_cpu
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|int
name|cpus
decl_stmt|;
name|u_long
name|icr_lo
decl_stmt|,
name|icr_hi
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_AP_POST
argument_list|)
expr_stmt|;
comment|/* get the PHYSICAL APIC ID# */
name|physical_cpu
operator|=
name|CPU_TO_ID
argument_list|(
name|logical_cpu
argument_list|)
expr_stmt|;
comment|/* calculate the vector */
name|vector
operator|=
operator|(
name|boot_addr
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* 	 * first we do an INIT/RESET IPI this INIT IPI might be run, reseting 	 * and running the target CPU. OR this INIT IPI might be latched (P5 	 * bug), CPU waiting for STARTUP IPI. OR this INIT IPI might be 	 * ignored. 	 */
comment|/* setup the address for the target AP */
name|icr_hi
operator|=
name|lapic
operator|.
name|icr_hi
operator|&
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|icr_hi
operator||=
operator|(
name|physical_cpu
operator|<<
literal|24
operator|)
expr_stmt|;
name|lapic
operator|.
name|icr_hi
operator|=
name|icr_hi
expr_stmt|;
comment|/* do an INIT IPI: assert RESET */
name|icr_lo
operator|=
name|lapic
operator|.
name|icr_lo
operator|&
literal|0xfff00000
expr_stmt|;
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x0000c500
expr_stmt|;
comment|/* wait for pending status end */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* do an INIT IPI: deassert RESET */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00008500
expr_stmt|;
comment|/* wait for pending status end */
name|u_sleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait ~10mS */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* 	 * next we do a STARTUP IPI: the previous INIT IPI might still be 	 * latched, (P5 bug) this 1st STARTUP would then terminate 	 * immediately, and the previously started INIT IPI would continue. OR 	 * the previous INIT IPI has already run. and this STARTUP IPI will 	 * run. OR the previous INIT IPI was ignored. and this STARTUP IPI 	 * will run. 	 */
comment|/* do a STARTUP IPI */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* 	 * finally we do a 2nd STARTUP IPI: this 2nd STARTUP IPI should run IF 	 * the previous STARTUP IPI was cancelled by a latched INIT IPI. OR 	 * this STARTUP IPI will be ignored, as only ONE STARTUP IPI is 	 * recognized after hardware RESET or INIT IPI. 	 */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* wait for it to start */
name|set_apic_timer
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* == 5 seconds */
while|while
condition|(
name|read_apic_timer
argument_list|()
condition|)
if|if
condition|(
name|mp_ncpus
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
comment|/*  * Flush the TLB on all other CPU's  *  * XXX: Needs to handshake and wait for completion before proceding.  */
name|void
name|smp_invltlb
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
if|if
condition|(
name|smp_started
operator|&&
name|invltlb_ok
condition|)
name|all_but_self_ipi
argument_list|(
name|XINVLTLB_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
name|void
name|invlpg
parameter_list|(
name|u_int
name|addr
parameter_list|)
block|{
asm|__asm   __volatile("invlpg (%0)"::"r"(addr):"memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
name|void
name|invltlb
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|temp
decl_stmt|;
comment|/* 	 * This should be implemented as load_cr3(rcr3()) when load_cr3() is 	 * inlined. 	 */
asm|__asm __volatile("movl %%cr3, %0; movl %0, %%cr3":"=r"(temp) :: "memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
comment|/*  * When called the executing CPU will send an IPI to all other CPUs  *  requesting that they halt execution.  *  * Usually (but not necessarily) called with 'other_cpus' as its arg.  *  *  - Signals all CPUs in map to stop.  *  - Waits for each to stop.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  *  * XXX FIXME: this is not MP-safe, needs a lock to prevent multiple CPUs  *            from executing at same time.  */
name|int
name|stop_cpus
parameter_list|(
name|u_int
name|map
parameter_list|)
block|{
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
literal|0
return|;
comment|/* send the Xcpustop IPI to all CPUs in map */
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUSTOP_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|stopped_cpus
operator|&
name|map
operator|)
operator|!=
name|map
condition|)
comment|/* spin */
empty_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * Called by a CPU to restart stopped CPUs.   *  * Usually (but not necessarily) called with 'stopped_cpus' as its arg.  *  *  - Signals all CPUs in map to restart.  *  - Waits for each to restart.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  */
name|int
name|restart_cpus
parameter_list|(
name|u_int
name|map
parameter_list|)
block|{
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
literal|0
return|;
name|started_cpus
operator|=
name|map
expr_stmt|;
comment|/* signal other cpus to restart */
while|while
condition|(
operator|(
name|stopped_cpus
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
comment|/* wait for each to clear its bit */
comment|/* spin */
empty_stmt|;
return|return
literal|1
return|;
block|}
name|int
name|smp_active
init|=
literal|0
decl_stmt|;
comment|/* are the APs allowed to run? */
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|smp_active
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|smp_active
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* XXX maybe should be hw.ncpu */
specifier|static
name|int
name|smp_cpus
init|=
literal|1
decl_stmt|;
comment|/* how many cpu's running */
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|smp_cpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|smp_cpus
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|int
name|invltlb_ok
init|=
literal|0
decl_stmt|;
comment|/* throttle smp_invltlb() till safe */
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|invltlb_ok
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|invltlb_ok
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Warning: Do not staticize.  Used from swtch.s */
name|int
name|do_page_zero_idle
init|=
literal|1
decl_stmt|;
comment|/* bzero pages for fun and profit in idleloop */
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|do_page_zero_idle
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|do_page_zero_idle
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Is forwarding of a interrupt to the CPU holding the ISR lock enabled ? */
name|int
name|forward_irq_enabled
init|=
literal|1
decl_stmt|;
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|forward_irq_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_irq_enabled
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Enable forwarding of a signal to a process running on a different CPU */
specifier|static
name|int
name|forward_signal_enabled
init|=
literal|1
decl_stmt|;
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|forward_signal_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_signal_enabled
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Enable forwarding of roundrobin to all other cpus */
specifier|static
name|int
name|forward_roundrobin_enabled
init|=
literal|1
decl_stmt|;
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|forward_roundrobin_enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_roundrobin_enabled
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/*  * This is called once the rest of the system is up and running and we're  * ready to let the AP's out of the pen.  */
name|void
name|ap_init
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|void
name|ap_init
parameter_list|()
block|{
name|u_int
name|apic_id
decl_stmt|;
comment|/* BSP may have changed PTD while we're waiting for the lock */
name|cpu_invltlb
argument_list|()
expr_stmt|;
name|smp_cpus
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Build our map of 'other' CPUs. */
name|other_cpus
operator|=
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|cpuid
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d Launched!\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
comment|/* set up CPU registers and state */
name|cpu_setregs
argument_list|()
expr_stmt|;
comment|/* set up FPU state on the AP */
name|npxinit
argument_list|(
name|__INITIAL_NPXCW__
argument_list|)
expr_stmt|;
comment|/* set up SSE registers */
name|enable_sse
argument_list|()
expr_stmt|;
comment|/* A quick check from sanity claus */
name|apic_id
operator|=
operator|(
name|apic_id_to_logical
index|[
operator|(
name|lapic
operator|.
name|id
operator|&
literal|0x0f000000
operator|)
operator|>>
literal|24
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|cpuid
operator|!=
name|apic_id
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: cpuid = %d\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: apic_id = %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"PTD[MPPTDI] = %llx\n"
argument_list|,
operator|(
name|u_int64_t
operator|)
name|PTD
index|[
name|MPPTDI
index|]
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cpuid mismatch! boom!!"
argument_list|)
expr_stmt|;
block|}
comment|/* Init local apic for irq's */
name|apic_initialize
argument_list|()
expr_stmt|;
comment|/* Set memory range attributes for this CPU to match the BSP */
name|mem_range_AP_init
argument_list|()
expr_stmt|;
comment|/* 	 * Activate smp_invltlb, although strictly speaking, this isn't 	 * quite correct yet.  We should have a bitfield for cpus willing 	 * to accept TLB flush IPI's or something and sync them. 	 */
if|if
condition|(
name|smp_cpus
operator|==
name|mp_ncpus
condition|)
block|{
name|invltlb_ok
operator|=
literal|1
expr_stmt|;
name|smp_started
operator|=
literal|1
expr_stmt|;
comment|/* enable IPI's, tlb shootdown, freezes etc */
name|smp_active
operator|=
literal|1
expr_stmt|;
comment|/* historic */
block|}
block|}
ifdef|#
directive|ifdef
name|BETTER_CLOCK
define|#
directive|define
name|CHECKSTATE_USER
value|0
define|#
directive|define
name|CHECKSTATE_SYS
value|1
define|#
directive|define
name|CHECKSTATE_INTR
value|2
comment|/* Do not staticize.  Used from apic_vector.s */
name|struct
name|proc
modifier|*
name|checkstate_curproc
index|[
name|MAXCPU
index|]
decl_stmt|;
name|int
name|checkstate_cpustate
index|[
name|MAXCPU
index|]
decl_stmt|;
name|u_long
name|checkstate_pc
index|[
name|MAXCPU
index|]
decl_stmt|;
define|#
directive|define
name|PC_TO_INDEX
parameter_list|(
name|pc
parameter_list|,
name|prof
parameter_list|)
define|\
value|((int)(((u_quad_t)((pc) - (prof)->pr_off) *	\             (u_quad_t)((prof)->pr_scale))>> 16)& ~1)
specifier|static
name|void
name|addupc_intr_forwarded
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|id
parameter_list|,
name|int
modifier|*
name|astmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|uprof
modifier|*
name|prof
decl_stmt|;
name|u_long
name|pc
decl_stmt|;
name|pc
operator|=
name|checkstate_pc
index|[
name|id
index|]
expr_stmt|;
name|prof
operator|=
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_prof
expr_stmt|;
if|if
condition|(
name|pc
operator|>=
name|prof
operator|->
name|pr_off
operator|&&
operator|(
name|i
operator|=
name|PC_TO_INDEX
argument_list|(
name|pc
argument_list|,
name|prof
argument_list|)
operator|)
operator|<
name|prof
operator|->
name|pr_size
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_OWEUPC
operator|)
operator|==
literal|0
condition|)
block|{
name|prof
operator|->
name|pr_addr
operator|=
name|pc
expr_stmt|;
name|prof
operator|->
name|pr_ticks
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_OWEUPC
expr_stmt|;
block|}
operator|*
name|astmap
operator||=
operator|(
literal|1
operator|<<
name|id
operator|)
expr_stmt|;
block|}
block|}
specifier|static
name|void
name|forwarded_statclock
parameter_list|(
name|int
name|id
parameter_list|,
name|int
name|pscnt
parameter_list|,
name|int
modifier|*
name|astmap
parameter_list|)
block|{
name|struct
name|pstats
modifier|*
name|pstats
decl_stmt|;
name|long
name|rss
decl_stmt|;
name|struct
name|rusage
modifier|*
name|ru
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|int
name|cpustate
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|GPROF
specifier|register
name|struct
name|gmonparam
modifier|*
name|g
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|p
operator|=
name|checkstate_curproc
index|[
name|id
index|]
expr_stmt|;
name|cpustate
operator|=
name|checkstate_cpustate
index|[
name|id
index|]
expr_stmt|;
switch|switch
condition|(
name|cpustate
condition|)
block|{
case|case
name|CHECKSTATE_USER
case|:
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PROFIL
condition|)
name|addupc_intr_forwarded
argument_list|(
name|p
argument_list|,
name|id
argument_list|,
name|astmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|pscnt
operator|>
literal|1
condition|)
return|return;
name|p
operator|->
name|p_uticks
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_nice
operator|>
name|NZERO
condition|)
name|cp_time
index|[
name|CP_NICE
index|]
operator|++
expr_stmt|;
else|else
name|cp_time
index|[
name|CP_USER
index|]
operator|++
expr_stmt|;
break|break;
case|case
name|CHECKSTATE_SYS
case|:
ifdef|#
directive|ifdef
name|GPROF
comment|/* 		 * Kernel statistics are just like addupc_intr, only easier. 		 */
name|g
operator|=
operator|&
name|_gmonparam
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|state
operator|==
name|GMON_PROF_ON
condition|)
block|{
name|i
operator|=
name|checkstate_pc
index|[
name|id
index|]
operator|-
name|g
operator|->
name|lowpc
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|g
operator|->
name|textsize
condition|)
block|{
name|i
operator|/=
name|HISTFRACTION
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|g
operator|->
name|kcount
argument_list|)
expr_stmt|;
name|g
operator|->
name|kcount
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|pscnt
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
operator|!
name|p
condition|)
name|cp_time
index|[
name|CP_IDLE
index|]
operator|++
expr_stmt|;
else|else
block|{
name|p
operator|->
name|p_sticks
operator|++
expr_stmt|;
name|cp_time
index|[
name|CP_SYS
index|]
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|CHECKSTATE_INTR
case|:
default|default:
ifdef|#
directive|ifdef
name|GPROF
comment|/* 		 * Kernel statistics are just like addupc_intr, only easier. 		 */
name|g
operator|=
operator|&
name|_gmonparam
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|state
operator|==
name|GMON_PROF_ON
condition|)
block|{
name|i
operator|=
name|checkstate_pc
index|[
name|id
index|]
operator|-
name|g
operator|->
name|lowpc
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|g
operator|->
name|textsize
condition|)
block|{
name|i
operator|/=
name|HISTFRACTION
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|g
operator|->
name|kcount
argument_list|)
expr_stmt|;
name|g
operator|->
name|kcount
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|pscnt
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|p_iticks
operator|++
expr_stmt|;
name|cp_time
index|[
name|CP_INTR
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|schedclock
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Update resource usage integrals and maximums. */
if|if
condition|(
operator|(
name|pstats
operator|=
name|p
operator|->
name|p_stats
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|ru
operator|=
operator|&
name|pstats
operator|->
name|p_ru
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|vm
operator|=
name|p
operator|->
name|p_vmspace
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ru
operator|->
name|ru_ixrss
operator|+=
name|pgtok
argument_list|(
name|vm
operator|->
name|vm_tsize
argument_list|)
expr_stmt|;
name|ru
operator|->
name|ru_idrss
operator|+=
name|pgtok
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|ru
operator|->
name|ru_isrss
operator|+=
name|pgtok
argument_list|(
name|vm
operator|->
name|vm_ssize
argument_list|)
expr_stmt|;
name|rss
operator|=
name|pgtok
argument_list|(
name|vmspace_resident_count
argument_list|(
name|vm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ru
operator|->
name|ru_maxrss
operator|<
name|rss
condition|)
name|ru
operator|->
name|ru_maxrss
operator|=
name|rss
expr_stmt|;
block|}
block|}
block|}
name|void
name|forward_statclock
parameter_list|(
name|int
name|pscnt
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Kludge. We don't yet have separate locks for the interrupts 	 * and the kernel. This means that we cannot let the other processors 	 * handle complex interrupts while inhibiting them from entering 	 * the kernel in a non-interrupt context. 	 * 	 * What we can do, without changing the locking mechanisms yet, 	 * is letting the other processors handle a very simple interrupt 	 * (wich determines the processor states), and do the main 	 * work ourself. 	 */
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
comment|/* Step 1: Probe state   (user, cpu, interrupt, spinlock, idle ) */
name|map
operator|=
name|other_cpus
operator|&
operator|~
operator|(
name|stopped_cpus
operator||
name|hlt_cpus_mask
operator|)
expr_stmt|;
name|checkstate_probed_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUCHECKSTATE_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|checkstate_probed_cpus
operator|!=
name|map
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|100000
condition|)
block|{
ifdef|#
directive|ifdef
name|BETTER_CLOCK_DIAGNOSTIC
name|printf
argument_list|(
literal|"forward_statclock: checkstate %x\n"
argument_list|,
name|checkstate_probed_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 	 * Step 2: walk through other processors processes, update ticks and  	 * profiling info. 	 */
name|map
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|mp_ncpus
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|cpuid
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|id
operator|)
operator|&
name|checkstate_probed_cpus
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|forwarded_statclock
argument_list|(
name|id
argument_list|,
name|pscnt
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
block|{
name|checkstate_need_ast
operator||=
name|map
expr_stmt|;
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUAST_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|checkstate_need_ast
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|100000
condition|)
block|{
ifdef|#
directive|ifdef
name|BETTER_CLOCK_DIAGNOSTIC
name|printf
argument_list|(
literal|"forward_statclock: dropped ast 0x%x\n"
argument_list|,
name|checkstate_need_ast
operator|&
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
block|}
name|void
name|forward_hardclock
parameter_list|(
name|int
name|pscnt
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|int
name|id
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pstats
modifier|*
name|pstats
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Kludge. We don't yet have separate locks for the interrupts 	 * and the kernel. This means that we cannot let the other processors 	 * handle complex interrupts while inhibiting them from entering 	 * the kernel in a non-interrupt context. 	 * 	 * What we can do, without changing the locking mechanisms yet, 	 * is letting the other processors handle a very simple interrupt 	 * (wich determines the processor states), and do the main 	 * work ourself. 	 */
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
comment|/* Step 1: Probe state   (user, cpu, interrupt, spinlock, idle) */
name|map
operator|=
name|other_cpus
operator|&
operator|~
operator|(
name|stopped_cpus
operator||
name|hlt_cpus_mask
operator|)
expr_stmt|;
name|checkstate_probed_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUCHECKSTATE_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|checkstate_probed_cpus
operator|!=
name|map
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|100000
condition|)
block|{
ifdef|#
directive|ifdef
name|BETTER_CLOCK_DIAGNOSTIC
name|printf
argument_list|(
literal|"forward_hardclock: checkstate %x\n"
argument_list|,
name|checkstate_probed_cpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 	 * Step 2: walk through other processors processes, update virtual  	 * timer and profiling timer. If stathz == 0, also update ticks and  	 * profiling info. 	 */
name|map
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|mp_ncpus
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|==
name|cpuid
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|id
operator|)
operator|&
name|checkstate_probed_cpus
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|p
operator|=
name|checkstate_curproc
index|[
name|id
index|]
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|pstats
operator|=
name|p
operator|->
name|p_stats
expr_stmt|;
if|if
condition|(
name|checkstate_cpustate
index|[
name|id
index|]
operator|==
name|CHECKSTATE_USER
operator|&&
name|timevalisset
argument_list|(
operator|&
name|pstats
operator|->
name|p_timer
index|[
name|ITIMER_VIRTUAL
index|]
operator|.
name|it_value
argument_list|)
operator|&&
name|itimerdecr
argument_list|(
operator|&
name|pstats
operator|->
name|p_timer
index|[
name|ITIMER_VIRTUAL
index|]
argument_list|,
name|tick
argument_list|)
operator|==
literal|0
condition|)
block|{
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGVTALRM
argument_list|)
expr_stmt|;
name|map
operator||=
operator|(
literal|1
operator|<<
name|id
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|pstats
operator|->
name|p_timer
index|[
name|ITIMER_PROF
index|]
operator|.
name|it_value
argument_list|)
operator|&&
name|itimerdecr
argument_list|(
operator|&
name|pstats
operator|->
name|p_timer
index|[
name|ITIMER_PROF
index|]
argument_list|,
name|tick
argument_list|)
operator|==
literal|0
condition|)
block|{
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGPROF
argument_list|)
expr_stmt|;
name|map
operator||=
operator|(
literal|1
operator|<<
name|id
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stathz
operator|==
literal|0
condition|)
block|{
name|forwarded_statclock
argument_list|(
name|id
argument_list|,
name|pscnt
argument_list|,
operator|&
name|map
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map
operator|!=
literal|0
condition|)
block|{
name|checkstate_need_ast
operator||=
name|map
expr_stmt|;
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUAST_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|checkstate_need_ast
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|100000
condition|)
block|{
ifdef|#
directive|ifdef
name|BETTER_CLOCK_DIAGNOSTIC
name|printf
argument_list|(
literal|"forward_hardclock: dropped ast 0x%x\n"
argument_list|,
name|checkstate_need_ast
operator|&
name|map
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
block|}
block|}
endif|#
directive|endif
comment|/* BETTER_CLOCK */
name|void
name|forward_signal
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|map
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Kludge. We don't yet have separate locks for the interrupts 	 * and the kernel. This means that we cannot let the other processors 	 * handle complex interrupts while inhibiting them from entering 	 * the kernel in a non-interrupt context. 	 * 	 * What we can do, without changing the locking mechanisms yet, 	 * is letting the other processors handle a very simple interrupt 	 * (wich determines the processor states), and do the main 	 * work ourself. 	 */
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
if|if
condition|(
operator|!
name|forward_signal_enabled
condition|)
return|return;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_stat
operator|!=
name|SRUN
condition|)
return|return;
name|id
operator|=
name|p
operator|->
name|p_oncpu
expr_stmt|;
if|if
condition|(
name|id
operator|==
literal|0xff
condition|)
return|return;
name|map
operator|=
operator|(
literal|1
operator|<<
name|id
operator|)
expr_stmt|;
name|checkstate_need_ast
operator||=
name|map
expr_stmt|;
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUAST_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|checkstate_need_ast
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|100000
condition|)
block|{
if|#
directive|if
literal|0
block|printf("forward_signal: dropped ast 0x%x\n", 				       checkstate_need_ast& map);
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|id
operator|==
name|p
operator|->
name|p_oncpu
condition|)
return|return;
block|}
block|}
name|void
name|forward_roundrobin
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|map
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|smp_started
operator|||
operator|!
name|invltlb_ok
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return;
if|if
condition|(
operator|!
name|forward_roundrobin_enabled
condition|)
return|return;
name|resched_cpus
operator||=
name|other_cpus
expr_stmt|;
name|map
operator|=
name|other_cpus
operator|&
operator|~
operator|(
name|stopped_cpus
operator||
name|hlt_cpus_mask
operator|)
expr_stmt|;
if|#
directive|if
literal|1
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUAST_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|all_but_self_ipi
argument_list|(
name|XCPUAST_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|checkstate_need_ast
operator|&
name|map
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* spin */
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|100000
condition|)
block|{
if|#
directive|if
literal|0
block|printf("forward_roundrobin: dropped ast 0x%x\n", 			       checkstate_need_ast& map);
endif|#
directive|endif
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|APIC_INTR_REORDER
comment|/*  *	Maintain mapping from softintr vector to isr bit in local apic.  */
name|void
name|set_lapic_isrloc
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
if|if
condition|(
name|intr
operator|<
literal|0
operator|||
name|intr
operator|>
literal|32
condition|)
name|panic
argument_list|(
literal|"set_apic_isrloc: bad intr argument: %d"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|<
name|ICU_OFFSET
operator|||
name|vector
operator|>
literal|255
condition|)
name|panic
argument_list|(
literal|"set_apic_isrloc: bad vector argument: %d"
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|apic_isrbit_location
index|[
name|intr
index|]
operator|.
name|location
operator|=
operator|&
name|lapic
operator|.
name|isr0
operator|+
operator|(
operator|(
name|vector
operator|>>
literal|5
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|apic_isrbit_location
index|[
name|intr
index|]
operator|.
name|bit
operator|=
operator|(
literal|1
operator|<<
operator|(
name|vector
operator|&
literal|31
operator|)
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  * All-CPU rendezvous.  CPUs are signalled, all execute the setup function   * (if specified), rendezvous, execute the action function (if specified),  * rendezvous again, execute the teardown function (if specified), and then  * resume.  *  * Note that the supplied external functions _must_ be reentrant and aware  * that they are running in parallel and in an unknown lock context.  */
specifier|static
name|void
function_decl|(
modifier|*
name|smp_rv_setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
specifier|static
name|void
function_decl|(
modifier|*
name|smp_rv_action_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
specifier|static
name|void
function_decl|(
modifier|*
name|smp_rv_teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
specifier|static
name|void
modifier|*
name|smp_rv_func_arg
decl_stmt|;
specifier|static
specifier|volatile
name|int
name|smp_rv_waiters
index|[
literal|2
index|]
decl_stmt|;
name|void
name|smp_rendezvous_action
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* setup function */
if|if
condition|(
name|smp_rv_setup_func
operator|!=
name|NULL
condition|)
name|smp_rv_setup_func
argument_list|(
name|smp_rv_func_arg
argument_list|)
expr_stmt|;
comment|/* spin on entry rendezvous */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|0
index|]
operator|<
name|mp_ncpus
condition|)
empty_stmt|;
comment|/* action function */
if|if
condition|(
name|smp_rv_action_func
operator|!=
name|NULL
condition|)
name|smp_rv_action_func
argument_list|(
name|smp_rv_func_arg
argument_list|)
expr_stmt|;
comment|/* spin on exit rendezvous */
name|atomic_add_int
argument_list|(
operator|&
name|smp_rv_waiters
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_rv_waiters
index|[
literal|1
index|]
operator|<
name|mp_ncpus
condition|)
empty_stmt|;
comment|/* teardown function */
if|if
condition|(
name|smp_rv_teardown_func
operator|!=
name|NULL
condition|)
name|smp_rv_teardown_func
argument_list|(
name|smp_rv_func_arg
argument_list|)
expr_stmt|;
block|}
name|void
name|smp_rendezvous
parameter_list|(
name|void
function_decl|(
modifier|*
name|setup_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|action_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|teardown_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int
name|efl
decl_stmt|;
comment|/* obtain rendezvous lock */
name|s_lock
argument_list|(
operator|&
name|smp_rv_lock
argument_list|)
expr_stmt|;
comment|/* XXX sleep here? NOWAIT flag? */
comment|/* set static function pointers */
name|smp_rv_setup_func
operator|=
name|setup_func
expr_stmt|;
name|smp_rv_action_func
operator|=
name|action_func
expr_stmt|;
name|smp_rv_teardown_func
operator|=
name|teardown_func
expr_stmt|;
name|smp_rv_func_arg
operator|=
name|arg
expr_stmt|;
name|smp_rv_waiters
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|smp_rv_waiters
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* disable interrupts on this CPU, save interrupt status */
name|efl
operator|=
name|read_eflags
argument_list|()
expr_stmt|;
name|write_eflags
argument_list|(
name|efl
operator|&
operator|~
name|PSL_I
argument_list|)
expr_stmt|;
comment|/* signal other processors, which will enter the IPI with interrupts off */
name|all_but_self_ipi
argument_list|(
name|XRENDEZVOUS_OFFSET
argument_list|)
expr_stmt|;
comment|/* call executor function */
name|smp_rendezvous_action
argument_list|()
expr_stmt|;
comment|/* restore interrupt flag */
name|write_eflags
argument_list|(
name|efl
argument_list|)
expr_stmt|;
comment|/* release lock */
name|s_unlock
argument_list|(
operator|&
name|smp_rv_lock
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|sysctl_htl_cpus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mask
operator|=
name|hlt_cpus_mask
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|mask
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
operator|&&
operator|(
name|mask
operator|&
name|logical_cpus_mask
operator|)
operator|==
name|logical_cpus_mask
condition|)
name|hlt_logical_cpus
operator|=
literal|1
expr_stmt|;
else|else
name|hlt_logical_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hlt_cpus_mask
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|hlt_cpus
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_htl_cpus
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
specifier|static
name|int
name|sysctl_hlt_logical_cpus
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|disable
decl_stmt|,
name|error
decl_stmt|;
name|disable
operator|=
name|hlt_logical_cpus
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|disable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|disable
condition|)
name|hlt_cpus_mask
operator||=
name|logical_cpus_mask
expr_stmt|;
else|else
name|hlt_cpus_mask
operator|&=
operator|~
name|logical_cpus_mask
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
operator|(
name|hlt_cpus_mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hlt_logical_cpus
operator|=
name|disable
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|int
name|sysctl_hyperthreading_allowed
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|allowed
decl_stmt|,
name|error
decl_stmt|;
name|allowed
operator|=
name|hyperthreading_allowed
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|allowed
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|allowed
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
name|hyperthreading_cpus_mask
expr_stmt|;
else|else
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
operator|&&
operator|(
name|hlt_cpus_mask
operator|&
name|logical_cpus_mask
operator|)
operator|==
name|logical_cpus_mask
condition|)
name|hlt_logical_cpus
operator|=
literal|1
expr_stmt|;
else|else
name|hlt_logical_cpus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hlt_cpus_mask
operator|&
name|all_cpus
operator|)
operator|==
name|all_cpus
condition|)
name|hlt_cpus_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
literal|0
operator|)
expr_stmt|;
name|hyperthreading_allowed
operator|=
name|allowed
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
specifier|static
name|void
name|cpu_hlt_setup
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|logical_cpus_mask
operator|!=
literal|0
condition|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"machdep.hlt_logical_cpus"
argument_list|,
operator|&
name|hlt_logical_cpus
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hlt_logical_cpus"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hlt_logical_cpus
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"logical_cpus_mask"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|logical_cpus_mask
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|hlt_logical_cpus
condition|)
name|hlt_cpus_mask
operator||=
name|logical_cpus_mask
expr_stmt|;
comment|/* 		 * If necessary for security purposes, force 		 * hyperthreading off, regardless of the value 		 * of hlt_logical_cpus. 		 */
if|if
condition|(
name|hyperthreading_cpus_mask
condition|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"machdep.hyperthreading_allowed"
argument_list|,
operator|&
name|hyperthreading_allowed
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|logical_cpu_clist
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_machdep
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hyperthreading_allowed"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_hyperthreading_allowed
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hyperthreading_allowed
condition|)
name|hlt_cpus_mask
operator||=
name|hyperthreading_cpus_mask
expr_stmt|;
block|}
block|}
block|}
name|SYSINIT
argument_list|(
name|cpu_hlt
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|cpu_hlt_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|int
name|mp_grab_cpu_hlt
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|mask
init|=
literal|1
operator|<<
name|cpuid
decl_stmt|;
name|u_int
name|temp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|mask
operator|&
name|hlt_cpus_mask
expr_stmt|;
while|while
condition|(
name|mask
operator|&
name|hlt_cpus_mask
condition|)
block|{
name|temp
operator|=
name|lapic
operator|.
name|tpr
expr_stmt|;
name|lapic
operator|.
name|tpr
operator|=
name|LOPRIO_LEVEL
expr_stmt|;
asm|__asm __volatile("sti; hlt" : : : "memory");
name|lapic
operator|.
name|tpr
operator|=
name|temp
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

end_unit

