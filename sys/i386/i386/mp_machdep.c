begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: mp_machdep.c,v 1.23 1997/07/30 22:51:11 smp Exp smp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_comment
comment|/* for KERNBASE */
end_comment

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_comment
comment|/* for KERNBASE */
end_comment

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_comment
comment|/* for KERNBASE */
end_comment

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_comment
comment|/* for KERNBASE */
end_comment

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/apic.h>
end_include

begin_include
include|#
directive|include
file|<machine/mpapic.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/smptests.h>
end_include

begin_comment
comment|/** TEST_DEFAULT_CONFIG, TEST_TEST1 */
end_comment

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<i386/i386/cons.h>
end_include

begin_comment
comment|/* cngetc() */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_comment
comment|/* setidt() */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/icu.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_include
include|#
directive|include
file|<i386/isa/intr_machdep.h>
end_include

begin_comment
comment|/* IPIs */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xf0000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x10000)
end_define

begin_define
define|#
directive|define
name|BIOS_COUNT
value|(BIOS_SIZE/4)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_EN
value|0x01
end_define

begin_define
define|#
directive|define
name|PROCENTRY_FLAG_BP
value|0x02
end_define

begin_define
define|#
directive|define
name|IOAPICENTRY_FLAG_EN
value|0x01
end_define

begin_comment
comment|/* MP Floating Pointer Structure */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPFPS
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|void
modifier|*
name|pap
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|mpfb1
decl_stmt|;
name|u_char
name|mpfb2
decl_stmt|;
name|u_char
name|mpfb3
decl_stmt|;
name|u_char
name|mpfb4
decl_stmt|;
name|u_char
name|mpfb5
decl_stmt|;
block|}
typedef|*
name|mpfps_t
typedef|;
end_typedef

begin_comment
comment|/* MP Configuration Table Header */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|MPCTH
block|{
name|char
name|signature
index|[
literal|4
index|]
decl_stmt|;
name|u_short
name|base_table_length
decl_stmt|;
name|u_char
name|spec_rev
decl_stmt|;
name|u_char
name|checksum
decl_stmt|;
name|u_char
name|oem_id
index|[
literal|8
index|]
decl_stmt|;
name|u_char
name|product_id
index|[
literal|12
index|]
decl_stmt|;
name|void
modifier|*
name|oem_table_pointer
decl_stmt|;
name|u_short
name|oem_table_size
decl_stmt|;
name|u_short
name|entry_count
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
name|u_short
name|extended_table_length
decl_stmt|;
name|u_char
name|extended_table_checksum
decl_stmt|;
name|u_char
name|reserved
decl_stmt|;
block|}
typedef|*
name|mpcth_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|PROCENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|cpu_flags
decl_stmt|;
name|u_long
name|cpu_signature
decl_stmt|;
name|u_long
name|feature_flags
decl_stmt|;
name|u_long
name|reserved1
decl_stmt|;
name|u_long
name|reserved2
decl_stmt|;
block|}
typedef|*
name|proc_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|bus_id
decl_stmt|;
name|char
name|bus_type
index|[
literal|6
index|]
decl_stmt|;
block|}
typedef|*
name|bus_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|IOAPICENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|apic_id
decl_stmt|;
name|u_char
name|apic_version
decl_stmt|;
name|u_char
name|apic_flags
decl_stmt|;
name|void
modifier|*
name|apic_address
decl_stmt|;
block|}
typedef|*
name|io_apic_entry_ptr
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
block|}
typedef|*
name|int_entry_ptr
typedef|;
end_typedef

begin_comment
comment|/* descriptions of MP basetable entries */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|BASETABLE_ENTRY
block|{
name|u_char
name|type
decl_stmt|;
name|u_char
name|length
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
block|}
name|basetable_entry
typedef|;
end_typedef

begin_comment
comment|/*  * this code MUST be enabled here and in mpboot.s.  * it follows the very early stages of AP boot by placing values in CMOS ram.  * it NORMALLY will never be needed and thus the primitive method for enabling.  * #define CHECK_POINTS  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CHECK_POINTS
argument_list|)
end_if

begin_define
define|#
directive|define
name|CHECK_READ
parameter_list|(
name|A
parameter_list|)
value|(outb(CMOS_REG, (A)), inb(CMOS_DATA))
end_define

begin_define
define|#
directive|define
name|CHECK_WRITE
parameter_list|(
name|A
parameter_list|,
name|D
parameter_list|)
value|(outb(CMOS_REG, (A)), outb(CMOS_DATA, (D)))
end_define

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
value|;				\ 	CHECK_WRITE(0x34, (D));			\ 	CHECK_WRITE(0x35, (D));			\ 	CHECK_WRITE(0x36, (D));			\ 	CHECK_WRITE(0x37, (D));			\ 	CHECK_WRITE(0x38, (D));			\ 	CHECK_WRITE(0x39, (D));
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
value|;				\ 	printf("%s: %d, %d, %d, %d, %d, %d\n",	\ 	   (S),					\ 	   CHECK_READ(0x34),			\ 	   CHECK_READ(0x35),			\ 	   CHECK_READ(0x36),			\ 	   CHECK_READ(0x37),			\ 	   CHECK_READ(0x38),			\ 	   CHECK_READ(0x39));
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_define
define|#
directive|define
name|CHECK_INIT
parameter_list|(
name|D
parameter_list|)
end_define

begin_define
define|#
directive|define
name|CHECK_PRINT
parameter_list|(
name|S
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CHECK_POINTS */
end_comment

begin_comment
comment|/*  * Values to send to the POST hardware.  */
end_comment

begin_define
define|#
directive|define
name|MP_BOOTADDRESS_POST
value|0x10
end_define

begin_define
define|#
directive|define
name|MP_PROBE_POST
value|0x11
end_define

begin_define
define|#
directive|define
name|MP_START_POST
value|0x12
end_define

begin_define
define|#
directive|define
name|MP_ANNOUNCE_POST
value|0x13
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS1_POST
value|0x14
end_define

begin_define
define|#
directive|define
name|MPTABLE_PASS2_POST
value|0x15
end_define

begin_define
define|#
directive|define
name|MP_ENABLE_POST
value|0x16
end_define

begin_define
define|#
directive|define
name|START_ALL_APS_POST
value|0x17
end_define

begin_define
define|#
directive|define
name|INSTALL_AP_TRAMP_POST
value|0x18
end_define

begin_define
define|#
directive|define
name|START_AP_POST
value|0x19
end_define

begin_comment
comment|/** XXX FIXME: where does this really belong, isa.h/isa.c perhaps? */
end_comment

begin_decl_stmt
name|int
name|current_postcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/** XXX FIXME: what system files declare these??? */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|region_descriptor
name|r_gdt
decl_stmt|,
name|r_idt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mp_ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of CPUs, including BSP */
end_comment

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|mp_nbusses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of busses */
end_comment

begin_decl_stmt
name|int
name|mp_napics
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of IO APICs */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
name|vm_offset_t
name|cpu_apic_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|io_apic_address
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NAPICID is more than enough */
end_comment

begin_decl_stmt
name|u_int32_t
name|cpu_apic_versions
index|[
name|NCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|io_apic_versions
index|[
name|NAPIC
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * APIC ID logical/physical mapping structures.  * We oversize these to simplify boot-time config.  */
end_comment

begin_decl_stmt
name|int
name|cpu_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|io_num_to_apic_id
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_id_to_logical
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bitmap of all available CPUs */
end_comment

begin_decl_stmt
name|u_int
name|all_cpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Boot of AP uses this PTD */
end_comment

begin_decl_stmt
name|u_int
modifier|*
name|bootPTD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hotwire a 0->4MB V==P mapping */
end_comment

begin_decl_stmt
specifier|extern
name|pt_entry_t
name|KPTphys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Virtual address of per-cpu common_tss */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|i386tss
name|common_tss
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mp_capable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|boot_address
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|base_memory
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|picmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0: virtual wire mode, 1: PIC mode */
end_comment

begin_decl_stmt
specifier|static
name|mpfps_t
name|mpfps
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logicalCpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Calculate usable address in base memory for AP trampoline code.  */
end_comment

begin_function
name|u_int
name|mp_bootaddress
parameter_list|(
name|u_int
name|basemem
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_BOOTADDRESS_POST
argument_list|)
expr_stmt|;
name|base_memory
operator|=
name|basemem
operator|*
literal|1024
expr_stmt|;
comment|/* convert to bytes */
name|boot_address
operator|=
name|base_memory
operator|&
operator|~
literal|0xfff
expr_stmt|;
comment|/* round down to 4k boundary */
if|if
condition|(
operator|(
name|base_memory
operator|-
name|boot_address
operator|)
operator|<
name|bootMP_size
condition|)
name|boot_address
operator|-=
literal|4096
expr_stmt|;
comment|/* not enough, lower by 4k */
return|return
name|boot_address
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an Intel MP spec table (ie, SMP capable hardware).  */
end_comment

begin_function
name|int
name|mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_long
name|segment
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_PROBE_POST
argument_list|)
expr_stmt|;
comment|/* see if EBDA exists */
if|if
condition|(
name|segment
operator|=
operator|(
name|u_long
operator|)
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
literal|0x40e
operator|)
condition|)
block|{
comment|/* search first 1K of EBDA */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|segment
operator|<<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
else|else
block|{
comment|/* last 1K of base memory, effective 'top of base' passed in */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|base_memory
operator|-
literal|0x400
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* search the BIOS */
name|target
operator|=
operator|(
name|u_int32_t
operator|)
name|BIOS_BASE
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
name|BIOS_COUNT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
comment|/* nothing found */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
literal|0
expr_stmt|;
name|mp_capable
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
name|found
label|:
comment|/* calculate needed resources */
name|mpfps
operator|=
operator|(
name|mpfps_t
operator|)
name|x
expr_stmt|;
if|if
condition|(
name|mptable_pass1
argument_list|()
condition|)
name|panic
argument_list|(
literal|"you must reconfigure your kernel"
argument_list|)
expr_stmt|;
comment|/* flag fact that we are running multiple processors */
name|mp_capable
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Startup the SMP processors.  */
end_comment

begin_function
name|void
name|mp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|POSTCODE
argument_list|(
name|MP_START_POST
argument_list|)
expr_stmt|;
comment|/* look for MP capable motherboard */
if|if
condition|(
name|mp_capable
condition|)
name|mp_enable
argument_list|(
name|boot_address
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"MP hardware not found!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|POSTCODE
argument_list|(
name|MP_ANNOUNCE_POST
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"FreeBSD/SMP: Multiprocessor motherboard\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cpu0 (BSP): apic id: %2d"
argument_list|,
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" cpu%d (AP):  apic id: %2d"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|cpu_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|cpu_apic_address
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_napics
condition|;
operator|++
name|x
control|)
block|{
name|printf
argument_list|(
literal|" io%d (APIC): apic id: %2d"
argument_list|,
name|x
argument_list|,
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", version: 0x%08x"
argument_list|,
name|io_apic_versions
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", at 0x%08x\n"
argument_list|,
name|io_apic_address
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|printf
argument_list|(
literal|" Warning: APIC I/O disabled\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
end_function

begin_comment
comment|/*  * AP cpu's call this to sync up protected mode.  */
end_comment

begin_function
name|void
name|init_secondary
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|gsel_tss
decl_stmt|,
name|slot
decl_stmt|;
name|r_gdt
operator|.
name|rd_limit
operator|=
sizeof|sizeof
argument_list|(
name|gdt
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|NGDT
operator|+
name|NCPU
operator|)
operator|-
literal|1
expr_stmt|;
name|r_gdt
operator|.
name|rd_base
operator|=
operator|(
name|int
operator|)
name|gdt
expr_stmt|;
name|lgdt
argument_list|(
operator|&
name|r_gdt
argument_list|)
expr_stmt|;
comment|/* does magic intra-segment return */
name|lidt
argument_list|(
operator|&
name|r_idt
argument_list|)
expr_stmt|;
name|lldt
argument_list|(
name|_default_ldt
argument_list|)
expr_stmt|;
name|slot
operator|=
name|NGDT
operator|+
name|cpuid
expr_stmt|;
name|gsel_tss
operator|=
name|GSEL
argument_list|(
name|slot
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|gdt
index|[
name|slot
index|]
operator|.
name|sd
operator|.
name|sd_type
operator|=
name|SDT_SYS386TSS
expr_stmt|;
name|common_tss
operator|.
name|tss_esp0
operator|=
literal|0
expr_stmt|;
comment|/* not used until after switch */
name|common_tss
operator|.
name|tss_ss0
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|common_tss
operator|.
name|tss_ioopt
operator|=
operator|(
sizeof|sizeof
name|common_tss
operator|)
operator|<<
literal|16
expr_stmt|;
name|ltr
argument_list|(
name|gsel_tss
argument_list|)
expr_stmt|;
name|load_cr0
argument_list|(
literal|0x8005003b
argument_list|)
expr_stmt|;
comment|/* XXX! */
name|PTD
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_set_opt
argument_list|(
operator|(
name|unsigned
operator|*
operator|)
name|PTD
argument_list|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
end_if

begin_comment
comment|/*  * Final configuration of the BSP's local APIC:  *  - disable 'pic mode'.  *  - disable 'virtual wire mode'.  *  - enable NMI.  */
end_comment

begin_function
name|void
name|bsp_apic_configure
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
name|byte
decl_stmt|;
name|u_int32_t
name|temp
decl_stmt|;
comment|/* leave 'pic mode' if necessary */
if|if
condition|(
name|picmode
condition|)
block|{
name|outb
argument_list|(
literal|0x22
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select IMCR */
name|byte
operator|=
name|inb
argument_list|(
literal|0x23
argument_list|)
expr_stmt|;
comment|/* current contents */
name|byte
operator||=
literal|0x01
expr_stmt|;
comment|/* mask external INTR */
name|outb
argument_list|(
literal|0x23
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disconnect 8259s/NMI */
block|}
comment|/* mask lint0 (the 8259 'virtual wire' connection) */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint0
expr_stmt|;
name|temp
operator||=
name|APIC_LVT_M
expr_stmt|;
comment|/* set the mask */
name|lapic
operator|.
name|lvt_lint0
operator|=
name|temp
expr_stmt|;
comment|/* setup lint1 to handle NMI */
name|temp
operator|=
name|lapic
operator|.
name|lvt_lint1
expr_stmt|;
name|temp
operator|&=
operator|~
name|APIC_LVT_M
expr_stmt|;
comment|/* clear the mask */
name|lapic
operator|.
name|lvt_lint1
operator|=
name|temp
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|apic_dump
argument_list|(
literal|"bsp_apic_configure()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APIC_IO */
end_comment

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * start the SMP system  */
end_comment

begin_function
specifier|static
name|void
name|mp_enable
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|int
name|apic
decl_stmt|;
name|u_int
name|ux
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
name|POSTCODE
argument_list|(
name|MP_ENABLE_POST
argument_list|)
expr_stmt|;
comment|/* turn on 4MB of V == P addressing so we can get to MP table */
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|u_long
operator|)
name|KPTphys
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* examine the MP table for needed info, uses physical addresses */
name|x
operator|=
name|mptable_pass2
argument_list|()
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|PTD
operator|=
literal|0
expr_stmt|;
name|invltlb
argument_list|()
expr_stmt|;
comment|/* can't process default configs till the CPU APIC is pmapped */
if|if
condition|(
name|x
condition|)
name|default_mp_table
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* fill the LOGICAL io_apic_versions table */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
block|{
name|ux
operator|=
name|io_apic_read
argument_list|(
name|apic
argument_list|,
name|IOAPIC_VER
argument_list|)
expr_stmt|;
name|io_apic_versions
index|[
name|apic
index|]
operator|=
name|ux
expr_stmt|;
block|}
comment|/* program each IO APIC in the system */
for|for
control|(
name|apic
operator|=
literal|0
init|;
name|apic
operator|<
name|mp_napics
condition|;
operator|++
name|apic
control|)
if|if
condition|(
name|io_apic_setup
argument_list|(
name|apic
argument_list|)
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"IO APIC setup failure"
argument_list|)
expr_stmt|;
comment|/* install a 'Spurious INTerrupt' vector */
name|setidt
argument_list|(
name|XSPURIOUSINT_OFFSET
argument_list|,
name|Xspuriousint
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for TLB invalidation */
name|setidt
argument_list|(
name|XINVLTLB_OFFSET
argument_list|,
name|Xinvltlb
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* install an inter-CPU IPI for CPU stop/restart */
name|setidt
argument_list|(
name|XCPUSTOP_OFFSET
argument_list|,
name|Xcpustop
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TEST_TEST1
argument_list|)
comment|/* install a "fake hardware INTerrupt" vector */
name|setidt
argument_list|(
name|XTEST1_OFFSET
argument_list|,
name|Xtest1
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/** TEST_TEST1 */
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* initialize all SMP locks */
name|init_locks
argument_list|()
expr_stmt|;
comment|/* start each Application Processor */
name|start_all_aps
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
comment|/*  	 * The init process might be started on a different CPU now, 	 * and the boot CPU might not call prepare_usermode to get 	 * cr0 correctly configured. Thus we initialize cr0 here. 	 */
name|load_cr0
argument_list|(
name|rcr0
argument_list|()
operator||
name|CR0_WP
operator||
name|CR0_AM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * look for the MP spec signature  */
end_comment

begin_comment
comment|/* string defined by the Intel MP Spec as identifying the MP table */
end_comment

begin_define
define|#
directive|define
name|MP_SIG
value|0x5f504d5f
end_define

begin_comment
comment|/* _MP_ */
end_comment

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|X
parameter_list|)
value|((X) += 4)
end_define

begin_function
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_int32_t
modifier|*
name|addr
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|target
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|NEXT
argument_list|(
name|x
argument_list|)
control|)
if|if
condition|(
name|addr
index|[
name|x
index|]
operator|==
name|MP_SIG
condition|)
comment|/* make array index a byte index */
return|return
operator|(
name|target
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|)
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|basetable_entry
name|basetable_entry_types
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|"Processor"
block|}
block|,
block|{
literal|1
block|,
literal|8
block|,
literal|"Bus"
block|}
block|,
block|{
literal|2
block|,
literal|8
block|,
literal|"I/O APIC"
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|"I/O INT"
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|"Local INT"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|BUSDATA
block|{
name|u_char
name|bus_id
decl_stmt|;
name|enum
name|busTypes
name|bus_type
decl_stmt|;
block|}
name|bus_datum
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTDATA
block|{
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
block|}
name|io_int
operator|,
name|local_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSTYPENAME
block|{
name|u_char
name|type
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
block|}
name|bus_type_name
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bus_type_name
name|bus_type_table
index|[]
init|=
block|{
block|{
name|CBUS
block|,
literal|"CBUS"
block|}
block|,
block|{
name|CBUSII
block|,
literal|"CBUSII"
block|}
block|,
block|{
name|EISA
block|,
literal|"EISA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|ISA
block|,
literal|"ISA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|PCI
block|,
literal|"PCI"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|,
block|{
name|XPRESS
block|,
literal|"XPRESS"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"---"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from MP spec v1.4, table 5-1 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_data
index|[
literal|7
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*   nbus, id0, type0, id1, type1 */
block|{
literal|1
block|,
literal|0
block|,
name|ISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
literal|255
block|}
block|,
block|{
literal|0
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
block|,
comment|/* MCA not supported */
block|{
literal|2
block|,
literal|0
block|,
name|ISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|EISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|0
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|,
literal|255
block|}
comment|/* MCA not supported */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the bus data */
end_comment

begin_decl_stmt
name|bus_datum
name|bus_data
index|[
name|NBUS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the IO INT data, one entry per possible APIC INTerrupt */
end_comment

begin_decl_stmt
name|io_int
name|io_apic_ints
index|[
name|NINTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nintrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|fix_mp_table
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|processor_entry
name|__P
argument_list|(
operator|(
name|proc_entry_ptr
name|entry
operator|,
name|int
name|cpu
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bus_entry
name|__P
argument_list|(
operator|(
name|bus_entry_ptr
name|entry
operator|,
name|int
name|bus
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|io_apic_entry
name|__P
argument_list|(
operator|(
name|io_apic_entry_ptr
name|entry
operator|,
name|int
name|apic
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|int_entry
name|__P
argument_list|(
operator|(
name|int_entry_ptr
name|entry
operator|,
name|int
name|intr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lookup_bus_type
name|__P
argument_list|(
operator|(
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 1st pass on motherboard's Intel MP specification table.  *  * initializes:  *	mp_ncpus = 1  *  * determines:  *	cpu_apic_address (common to all CPUs)  *	io_apic_address[N]  *	mp_naps  *	mp_nbusses  *	mp_napics  *	nintrs  */
end_comment

begin_function
specifier|static
name|int
name|mptable_pass1
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|mustpanic
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS1_POST
argument_list|)
expr_stmt|;
name|mustpanic
operator|=
literal|0
expr_stmt|;
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|io_apic_address
index|[
name|x
index|]
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* IO APIC address table */
block|}
comment|/* init everything to empty */
name|mp_naps
operator|=
literal|0
expr_stmt|;
name|mp_nbusses
operator|=
literal|0
expr_stmt|;
name|mp_napics
operator|=
literal|0
expr_stmt|;
name|nintrs
operator|=
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|if
condition|(
name|mpfps
operator|->
name|mpfb1
operator|!=
literal|0
condition|)
block|{
comment|/* use default addresses */
name|cpu_apic_address
operator|=
name|DEFAULT_APIC_BASE
expr_stmt|;
name|io_apic_address
index|[
literal|0
index|]
operator|=
name|DEFAULT_IO_APIC_BASE
expr_stmt|;
comment|/* fill in with defaults */
name|mp_naps
operator|=
literal|2
expr_stmt|;
comment|/* includes BSP */
name|mp_nbusses
operator|=
name|default_data
index|[
name|mpfps
operator|->
name|mpfb1
operator|-
literal|1
index|]
index|[
literal|0
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|mp_napics
operator|=
literal|1
expr_stmt|;
name|nintrs
operator|=
literal|16
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
name|cpu_apic_address
operator|=
operator|(
name|vm_offset_t
operator|)
name|cth
operator|->
name|apic_address
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
comment|/* processor_entry */
if|if
condition|(
operator|(
operator|(
name|proc_entry_ptr
operator|)
name|position
operator|)
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
condition|)
operator|++
name|mp_naps
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bus_entry */
operator|++
name|mp_nbusses
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* io_apic_entry */
if|if
condition|(
operator|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
operator|)
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
condition|)
name|io_apic_address
index|[
name|mp_napics
operator|++
index|]
operator|=
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|io_apic_entry_ptr
operator|)
name|position
argument_list|)
operator|->
name|apic_address
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* int_entry */
operator|++
name|nintrs
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
comment|/* qualify the numbers */
if|if
condition|(
name|mp_naps
operator|>
name|NCPU
condition|)
name|printf
argument_list|(
literal|"Warning: only using %d of %d available CPUs!\n"
argument_list|,
name|NCPU
argument_list|,
name|mp_naps
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/** XXX we consider this legal now (but should we?) */
block|mustpanic = 1;
endif|#
directive|endif
if|if
condition|(
name|mp_nbusses
operator|>
name|NBUS
condition|)
block|{
name|printf
argument_list|(
literal|"found %d busses, increase NBUS\n"
argument_list|,
name|mp_nbusses
argument_list|)
expr_stmt|;
name|mustpanic
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mp_napics
operator|>
name|NAPIC
condition|)
block|{
name|printf
argument_list|(
literal|"found %d apics, increase NAPIC\n"
argument_list|,
name|mp_napics
argument_list|)
expr_stmt|;
name|mustpanic
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|nintrs
operator|>
name|NINTR
condition|)
block|{
name|printf
argument_list|(
literal|"found %d intrs, increase NINTR\n"
argument_list|,
name|nintrs
argument_list|)
expr_stmt|;
name|mustpanic
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Count the BSP. 	 * This is also used as a counter while starting the APs. 	 */
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
operator|--
name|mp_naps
expr_stmt|;
comment|/* subtract the BSP */
return|return
name|mustpanic
return|;
block|}
end_function

begin_comment
comment|/*  * 2nd pass on motherboard's Intel MP specification table.  *  * sets:  *	boot_cpu_id  *	ID_TO_IO(N), phy APIC ID to log CPU/IO table  *	CPU_TO_ID(N), logical CPU to APIC ID table  *	IO_TO_ID(N), logical IO to APIC ID table  *	bus_data[N]  *	io_apic_ints[N]  */
end_comment

begin_function
specifier|static
name|int
name|mptable_pass2
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|mpcth_t
name|cth
decl_stmt|;
name|int
name|totalSize
decl_stmt|;
name|void
modifier|*
name|position
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|apic
decl_stmt|,
name|bus
decl_stmt|,
name|cpu
decl_stmt|,
name|intr
decl_stmt|;
name|POSTCODE
argument_list|(
name|MPTABLE_PASS2_POST
argument_list|)
expr_stmt|;
comment|/* clear various tables */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NAPICID
condition|;
operator|++
name|x
control|)
block|{
name|ID_TO_IO
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* phy APIC ID to log CPU/IO table */
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical CPU to APIC ID table */
name|IO_TO_ID
argument_list|(
name|x
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* logical IO to APIC ID table */
block|}
comment|/* clear bus data table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NBUS
condition|;
operator|++
name|x
control|)
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|=
literal|0xff
expr_stmt|;
comment|/* clear IO APIC INT table */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|NINTR
condition|;
operator|++
name|x
control|)
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* setup the cpu/apic mapping arrays */
name|boot_cpu_id
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* record whether PIC or virtual-wire mode */
name|picmode
operator|=
operator|(
name|mpfps
operator|->
name|mpfb2
operator|&
literal|0x80
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* check for use of 'default' configuration */
if|#
directive|if
name|defined
argument_list|(
name|TEST_DEFAULT_CONFIG
argument_list|)
return|return
name|TEST_DEFAULT_CONFIG
return|;
else|#
directive|else
if|if
condition|(
name|mpfps
operator|->
name|mpfb1
operator|!=
literal|0
condition|)
return|return
name|mpfps
operator|->
name|mpfb1
return|;
comment|/* return default configuration type */
endif|#
directive|endif
comment|/* TEST_DEFAULT_CONFIG */
if|if
condition|(
operator|(
name|cth
operator|=
name|mpfps
operator|->
name|pap
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"MP Configuration Table Header MISSING!"
argument_list|)
expr_stmt|;
comment|/* walk the table, recording info of interest */
name|totalSize
operator|=
name|cth
operator|->
name|base_table_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|position
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cth
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|MPCTH
argument_list|)
expr_stmt|;
name|count
operator|=
name|cth
operator|->
name|entry_count
expr_stmt|;
name|apic
operator|=
name|bus
operator|=
name|intr
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
literal|1
expr_stmt|;
comment|/* pre-count the BSP */
while|while
condition|(
name|count
operator|--
condition|)
block|{
switch|switch
condition|(
name|type
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|position
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|processor_entry
argument_list|(
name|position
argument_list|,
name|cpu
argument_list|)
condition|)
operator|++
name|cpu
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|bus_entry
argument_list|(
name|position
argument_list|,
name|bus
argument_list|)
condition|)
operator|++
name|bus
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|io_apic_entry
argument_list|(
name|position
argument_list|,
name|apic
argument_list|)
condition|)
operator|++
name|apic
expr_stmt|;
break|break;
case|case
literal|3
case|:
if|if
condition|(
name|int_entry
argument_list|(
name|position
argument_list|,
name|intr
argument_list|)
condition|)
operator|++
name|intr
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* int_entry(position); */
break|break;
default|default:
name|panic
argument_list|(
literal|"mpfps Base Table HOSED!"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|totalSize
operator|-=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
operator|(
name|u_char
operator|*
operator|)
name|position
operator|+=
name|basetable_entry_types
index|[
name|type
index|]
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|boot_cpu_id
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"NO BSP found!"
argument_list|)
expr_stmt|;
comment|/* post scan cleanup */
name|fix_mp_table
argument_list|()
expr_stmt|;
comment|/* report fact that its NOT a default configuration */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * parse an Intel MP specification table  */
end_comment

begin_function
specifier|static
name|void
name|fix_mp_table
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|bus_0
decl_stmt|;
name|int
name|bus_pci
decl_stmt|;
name|int
name|num_pci_bus
decl_stmt|;
comment|/* 	 * Fix mis-numbering of the PCI bus and its INT entries if the BIOS 	 * did it wrong.  The MP spec says that when more than 1 PCI bus 	 * exists the BIOS must begin with bus entries for the PCI bus and use 	 * actual PCI bus numbering.  This implies that when only 1 PCI bus 	 * exists the BIOS can choose to ignore this ordering, and indeed many 	 * MP motherboards do ignore it.  This causes a problem when the PCI 	 * sub-system makes requests of the MP sub-system based on PCI bus 	 * numbers.	So here we look for the situation and renumber the 	 * busses and associated INTs in an effort to "make it right". 	 */
comment|/* find bus 0, PCI bus, count the number of PCI busses */
for|for
control|(
name|num_pci_bus
operator|=
literal|0
operator|,
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
literal|0
condition|)
block|{
name|bus_0
operator|=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
operator|==
name|PCI
condition|)
block|{
operator|++
name|num_pci_bus
expr_stmt|;
name|bus_pci
operator|=
name|x
expr_stmt|;
block|}
block|}
comment|/* 	 * bus_0 == slot of bus with ID of 0 	 * bus_pci == slot of last PCI bus encountered 	 */
comment|/* check the 1 PCI bus case for sanity */
if|if
condition|(
name|num_pci_bus
operator|==
literal|1
condition|)
block|{
comment|/* if it is number 0 all is well */
if|if
condition|(
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
operator|==
literal|0
condition|)
return|return;
comment|/* mis-numbered, swap with whichever bus uses slot 0 */
comment|/* swap the bus entry types */
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_type
operator|=
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
expr_stmt|;
name|bus_data
index|[
name|bus_0
index|]
operator|.
name|bus_type
operator|=
name|PCI
expr_stmt|;
comment|/* swap each relavant INTerrupt entry */
name|id
operator|=
name|bus_data
index|[
name|bus_pci
index|]
operator|.
name|bus_id
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
name|id
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|==
literal|0
condition|)
block|{
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|=
name|id
expr_stmt|;
block|}
block|}
block|}
comment|/* sanity check if more than 1 PCI bus */
elseif|else
if|if
condition|(
name|num_pci_bus
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
operator|!=
name|PCI
condition|)
continue|continue;
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|>=
name|num_pci_bus
condition|)
name|panic
argument_list|(
literal|"bad PCI bus numbering"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|processor_entry
parameter_list|(
name|proc_entry_ptr
name|entry
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
comment|/* check for usability */
if|if
condition|(
operator|(
name|cpu
operator|>=
name|NCPU
operator|)
operator|||
operator|!
operator|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
comment|/* check for BSP flag */
if|if
condition|(
name|entry
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_BP
condition|)
block|{
name|boot_cpu_id
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* its already been counted */
block|}
comment|/* add another AP to list, if less than max number of CPUs */
else|else
block|{
name|CPU_TO_ID
argument_list|(
name|cpu
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|cpu
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bus_entry
parameter_list|(
name|bus_entry_ptr
name|entry
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|char
name|c
decl_stmt|,
name|name
index|[
literal|8
index|]
decl_stmt|;
comment|/* encode the name into an index */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
literal|6
condition|;
operator|++
name|x
control|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|entry
operator|->
name|bus_type
index|[
name|x
index|]
operator|)
operator|==
literal|' '
condition|)
break|break;
name|name
index|[
name|x
index|]
operator|=
name|c
expr_stmt|;
block|}
name|name
index|[
name|x
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|lookup_bus_type
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|UNKNOWN_BUSTYPE
condition|)
name|panic
argument_list|(
literal|"unknown bus type: '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|=
name|entry
operator|->
name|bus_id
expr_stmt|;
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|=
name|x
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|io_apic_entry
parameter_list|(
name|io_apic_entry_ptr
name|entry
parameter_list|,
name|int
name|apic
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|entry
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
operator|)
condition|)
return|return
literal|0
return|;
name|IO_TO_ID
argument_list|(
name|apic
argument_list|)
operator|=
name|entry
operator|->
name|apic_id
expr_stmt|;
name|ID_TO_IO
argument_list|(
name|entry
operator|->
name|apic_id
argument_list|)
operator|=
name|apic
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_bus_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAX_BUSTYPE
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|bus_type_table
index|[
name|x
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bus_type_table
index|[
name|x
index|]
operator|.
name|type
return|;
return|return
name|UNKNOWN_BUSTYPE
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|int_entry
parameter_list|(
name|int_entry_ptr
name|entry
parameter_list|,
name|int
name|intr
parameter_list|)
block|{
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_type
operator|=
name|entry
operator|->
name|int_type
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|int_flags
operator|=
name|entry
operator|->
name|int_flags
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|=
name|entry
operator|->
name|src_bus_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_irq
operator|=
name|entry
operator|->
name|src_bus_irq
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_id
operator|=
name|entry
operator|->
name|dst_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|dst_apic_int
operator|=
name|entry
operator|->
name|dst_apic_int
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|apic_int_is_bus_type
parameter_list|(
name|int
name|intr
parameter_list|,
name|int
name|bus_type
parameter_list|)
block|{
name|int
name|bus
decl_stmt|;
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|mp_nbusses
condition|;
operator|++
name|bus
control|)
if|if
condition|(
operator|(
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_id
operator|==
name|io_apic_ints
index|[
name|intr
index|]
operator|.
name|src_bus_id
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|bus_data
index|[
name|bus
index|]
operator|.
name|bus_type
operator|==
name|bus_type
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Given a traditional ISA INT mask, return an APIC mask.  */
end_comment

begin_function
name|u_int
name|isa_apic_mask
parameter_list|(
name|u_int
name|isa_mask
parameter_list|)
block|{
name|int
name|isa_irq
decl_stmt|;
name|int
name|apic_pin
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SKIP_IRQ15_REDIRECT
argument_list|)
if|if
condition|(
name|isa_mask
operator|==
operator|(
literal|1
operator|<<
literal|15
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"skipping ISA IRQ15 redirect\n"
argument_list|)
expr_stmt|;
return|return
name|isa_mask
return|;
block|}
endif|#
directive|endif
comment|/* SKIP_IRQ15_REDIRECT */
name|isa_irq
operator|=
name|ffs
argument_list|(
name|isa_mask
argument_list|)
expr_stmt|;
comment|/* find its bit position */
if|if
condition|(
name|isa_irq
operator|==
literal|0
condition|)
comment|/* doesn't exist */
return|return
literal|0
return|;
operator|--
name|isa_irq
expr_stmt|;
comment|/* make it zero based */
name|apic_pin
operator|=
name|isa_apic_pin
argument_list|(
name|isa_irq
argument_list|)
expr_stmt|;
comment|/* look for APIC connection */
if|if
condition|(
name|apic_pin
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
return|return
operator|(
literal|1
operator|<<
name|apic_pin
operator|)
return|;
comment|/* convert pin# to a mask */
block|}
end_function

begin_comment
comment|/*  * Determine which APIC pin an ISA/EISA INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|INTTYPE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].int_type)
end_define

begin_define
define|#
directive|define
name|INTPIN
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].dst_apic_int)
end_define

begin_define
define|#
directive|define
name|SRCBUSIRQ
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq)
end_define

begin_function
name|int
name|isa_apic_pin
parameter_list|(
name|int
name|isa_irq
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
block|{
comment|/* check each record */
if|if
condition|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* standard INT */
if|if
condition|(
name|SRCBUSIRQ
argument_list|(
name|intr
argument_list|)
operator|==
name|isa_irq
condition|)
block|{
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|ISA
argument_list|)
operator|||
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|EISA
argument_list|)
condition|)
return|return
name|INTPIN
argument_list|(
name|intr
argument_list|)
return|;
comment|/* found */
block|}
block|}
block|}
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRCBUSIRQ
end_undef

begin_comment
comment|/*  * Determine which APIC pin a PCI INT is attached to.  */
end_comment

begin_define
define|#
directive|define
name|SRCBUSID
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_id)
end_define

begin_define
define|#
directive|define
name|SRCBUSDEVICE
parameter_list|(
name|I
parameter_list|)
value|((io_apic_ints[(I)].src_bus_irq>> 2)& 0x1f)
end_define

begin_define
define|#
directive|define
name|SRCBUSLINE
parameter_list|(
name|I
parameter_list|)
value|(io_apic_ints[(I)].src_bus_irq& 0x03)
end_define

begin_function
name|int
name|pci_apic_pin
parameter_list|(
name|int
name|pciBus
parameter_list|,
name|int
name|pciDevice
parameter_list|,
name|int
name|pciInt
parameter_list|)
block|{
name|int
name|intr
decl_stmt|;
operator|--
name|pciInt
expr_stmt|;
comment|/* zero based */
for|for
control|(
name|intr
operator|=
literal|0
init|;
name|intr
operator|<
name|nintrs
condition|;
operator|++
name|intr
control|)
comment|/* check each record */
if|if
condition|(
operator|(
name|INTTYPE
argument_list|(
name|intr
argument_list|)
operator|==
literal|0
operator|)
comment|/* standard INT */
operator|&&
operator|(
name|SRCBUSID
argument_list|(
name|intr
argument_list|)
operator|==
name|pciBus
operator|)
operator|&&
operator|(
name|SRCBUSDEVICE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciDevice
operator|)
operator|&&
operator|(
name|SRCBUSLINE
argument_list|(
name|intr
argument_list|)
operator|==
name|pciInt
operator|)
condition|)
comment|/* a candidate IRQ */
if|if
condition|(
name|apic_int_is_bus_type
argument_list|(
name|intr
argument_list|,
name|PCI
argument_list|)
condition|)
return|return
name|INTPIN
argument_list|(
name|intr
argument_list|)
return|;
comment|/* exact match */
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_undef
undef|#
directive|undef
name|SRCBUSLINE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSDEVICE
end_undef

begin_undef
undef|#
directive|undef
name|SRCBUSID
end_undef

begin_undef
undef|#
directive|undef
name|INTPIN
end_undef

begin_undef
undef|#
directive|undef
name|INTTYPE
end_undef

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect an ISA INTerrupt.  *  * XXX FIXME:  *  Exactly what this means is unclear at this point.  It is a solution  *  for motherboards that redirect the MBIRQ0 pin.  Generically a motherboard  *  could route any of the ISA INTs to upper (>15) IRQ values.  But most would  *  NOT be redirected via MBIRQ0, thus "undirect()ing" them would NOT be an  *  option.  */
end_comment

begin_function
name|int
name|undirect_isa_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
name|printf
argument_list|(
literal|"Freeing redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|???
return|;
else|#
directive|else
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected ISA irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * Reprogram the MB chipset to NOT redirect a PCI INTerrupt  */
end_comment

begin_function
name|int
name|undirect_pci_irq
parameter_list|(
name|int
name|rirq
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|READY
argument_list|)
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
comment|/** FIXME: tickle the MB redirector chip */
return|return
operator|???
return|;
else|#
directive|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Freeing (NOT implemented) redirected PCI irq %d.\n"
argument_list|,
name|rirq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* READY */
block|}
end_function

begin_comment
comment|/*  * given a bus ID, return:  *  the bus type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_bus_type
parameter_list|(
name|int
name|id
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|mp_nbusses
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_id
operator|==
name|id
condition|)
return|return
name|bus_data
index|[
name|x
index|]
operator|.
name|bus_type
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus ID if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_id
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_id
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated src bus IRQ if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_src_bus_irq
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
name|x
operator|++
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|src_bus_irq
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated INTerrupt type if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_int_type
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_type
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated trigger mode if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_trigger
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|>>
literal|2
operator|)
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * given a LOGICAL APIC# and pin#, return:  *  the associated 'active' level if found  *  -1 if NOT found  */
end_comment

begin_function
name|int
name|apic_polarity
parameter_list|(
name|int
name|apic
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
comment|/* search each of the possible INTerrupt sources */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|nintrs
condition|;
operator|++
name|x
control|)
if|if
condition|(
operator|(
name|apic
operator|==
name|ID_TO_IO
argument_list|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_id
argument_list|)
operator|)
operator|&&
operator|(
name|pin
operator|==
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|dst_apic_int
operator|)
condition|)
return|return
operator|(
name|io_apic_ints
index|[
name|x
index|]
operator|.
name|int_flags
operator|&
literal|0x03
operator|)
return|;
return|return
operator|-
literal|1
return|;
comment|/* NOT found */
block|}
end_function

begin_comment
comment|/*  * set data according to MP defaults  * FIXME: probably not complete yet...  */
end_comment

begin_function
specifier|static
name|void
name|default_mp_table
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|int
name|ap_cpu_id
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
name|u_int32_t
name|ux
decl_stmt|;
name|int
name|io_apic_id
decl_stmt|;
name|int
name|pin
decl_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
if|#
directive|if
literal|0
block|printf("  MP default config type: %d\n", type); 	switch (type) { 	case 1: 		printf("   bus: ISA, APIC: 82489DX\n"); 		break; 	case 2: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 3: 		printf("   bus: EISA, APIC: 82489DX\n"); 		break; 	case 4: 		printf("   bus: MCA, APIC: 82489DX\n"); 		break; 	case 5: 		printf("   bus: ISA+PCI, APIC: Integrated\n"); 		break; 	case 6: 		printf("   bus: EISA+PCI, APIC: Integrated\n"); 		break; 	case 7: 		printf("   bus: MCA+PCI, APIC: Integrated\n"); 		break; 	default: 		printf("   future type\n"); 		break;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
comment|/* 0 */
name|boot_cpu_id
operator|=
operator|(
name|lapic
operator|.
name|id
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
name|ap_cpu_id
operator|=
operator|(
name|boot_cpu_id
operator|==
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* BSP */
name|CPU_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|boot_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|boot_cpu_id
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* one and only AP */
name|CPU_TO_ID
argument_list|(
literal|1
argument_list|)
operator|=
name|ap_cpu_id
expr_stmt|;
name|ID_TO_CPU
argument_list|(
name|ap_cpu_id
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* one and only IO APIC */
name|io_apic_id
operator|=
operator|(
name|io_apic_read
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|)
operator|&
name|APIC_ID_MASK
operator|)
operator|>>
literal|24
expr_stmt|;
comment|/* 	 * sanity check, refer to MP spec section 3.6.6, last paragraph 	 * necessary as some hardware isn't properly setting up the IO APIC 	 */
if|#
directive|if
name|defined
argument_list|(
name|REALLY_ANAL_IOAPICID_VALUE
argument_list|)
if|if
condition|(
name|io_apic_id
operator|!=
literal|2
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|io_apic_id
operator|==
literal|0
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|1
operator|)
operator|||
operator|(
name|io_apic_id
operator|==
literal|15
operator|)
condition|)
block|{
endif|#
directive|endif
comment|/* REALLY_ANAL_IOAPICID_VALUE */
name|ux
operator|=
name|io_apic_read
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|)
expr_stmt|;
comment|/* get current contents */
name|ux
operator|&=
operator|~
name|APIC_ID_MASK
expr_stmt|;
comment|/* clear the ID field */
name|ux
operator||=
literal|0x02000000
expr_stmt|;
comment|/* set it to '2' */
name|io_apic_write
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|,
name|ux
argument_list|)
expr_stmt|;
comment|/* write new value */
name|ux
operator|=
name|io_apic_read
argument_list|(
literal|0
argument_list|,
name|IOAPIC_ID
argument_list|)
expr_stmt|;
comment|/* re-read&& test */
if|if
condition|(
operator|(
name|ux
operator|&
name|APIC_ID_MASK
operator|)
operator|!=
literal|0x02000000
condition|)
name|panic
argument_list|(
literal|"can't control IO APIC ID, reg: 0x%08x"
argument_list|,
name|ux
argument_list|)
expr_stmt|;
name|io_apic_id
operator|=
literal|2
expr_stmt|;
block|}
name|IO_TO_ID
argument_list|(
literal|0
argument_list|)
operator|=
name|io_apic_id
expr_stmt|;
name|ID_TO_IO
argument_list|(
name|io_apic_id
argument_list|)
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
comment|/* fill out bus entries */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|1
index|]
expr_stmt|;
name|bus_data
index|[
literal|0
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_id
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|3
index|]
expr_stmt|;
name|bus_data
index|[
literal|1
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|type
operator|-
literal|1
index|]
index|[
literal|4
index|]
expr_stmt|;
break|break;
comment|/* case 4: case 7:		   MCA NOT supported */
default|default:
comment|/* illegal/reserved */
name|panic
argument_list|(
literal|"BAD default MP config: %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
comment|/* general cases from MP v1.4, table 5-2 */
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|16
condition|;
operator|++
name|pin
control|)
block|{
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_type
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|int_flags
operator|=
literal|0x05
expr_stmt|;
comment|/* edge/active-hi */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|src_bus_irq
operator|=
name|pin
expr_stmt|;
comment|/* IRQ2 caught below */
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_id
operator|=
name|io_apic_id
expr_stmt|;
name|io_apic_ints
index|[
name|pin
index|]
operator|.
name|dst_apic_int
operator|=
name|pin
expr_stmt|;
comment|/* 1-to-1 */
block|}
comment|/* special cases from MP v1.4, table 5-2 */
if|if
condition|(
name|type
operator|==
literal|2
condition|)
block|{
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
name|io_apic_ints
index|[
literal|13
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|APIC_MIXED_MODE
argument_list|)
comment|/** FIXME: ??? */
name|panic
argument_list|(
literal|"sorry, can't support type 2 default yet"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_MIXED_MODE */
block|}
else|else
name|io_apic_ints
index|[
literal|2
index|]
operator|.
name|src_bus_irq
operator|=
literal|0
expr_stmt|;
comment|/* ISA IRQ0 is on APIC INT 2 */
if|if
condition|(
name|type
operator|==
literal|7
condition|)
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|0xff
expr_stmt|;
comment|/* N/C */
else|else
name|io_apic_ints
index|[
literal|0
index|]
operator|.
name|int_type
operator|=
literal|3
expr_stmt|;
comment|/* vectored 8259 */
endif|#
directive|endif
comment|/* APIC_IO */
block|}
comment|/*  * initialize all the SMP locks  */
specifier|static
name|void
name|init_locks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Get the initial mp_lock with a count of 1 for the BSP. 	 * This uses a LOGICAL cpu ID, ie BSP == 0. 	 */
name|mp_lock
operator|=
literal|0x00000001
expr_stmt|;
comment|/* locks the IO APIC and apic_imen accesses */
name|s_lock_init
argument_list|(
operator|(
expr|struct
name|simplelock
operator|*
operator|)
operator|&
name|imen_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * start each AP in our list  */
specifier|static
name|int
name|start_all_aps
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|i
decl_stmt|;
name|u_char
name|mpbiosreason
decl_stmt|;
name|u_long
name|mpbioswarmvec
decl_stmt|;
name|pd_entry_t
name|newptd
decl_stmt|;
name|pt_entry_t
name|newpt
decl_stmt|;
name|int
modifier|*
name|newpp
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_ALL_APS_POST
argument_list|)
expr_stmt|;
comment|/* initialize BSP's local APIC */
name|apic_initialize
argument_list|()
expr_stmt|;
comment|/* install the AP 1st level boot code */
name|install_ap_tramp
argument_list|(
name|boot_addr
argument_list|)
expr_stmt|;
comment|/* save the current value of the warm-start vector */
name|mpbioswarmvec
operator|=
operator|*
operator|(
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|mpbiosreason
operator|=
name|inb
argument_list|(
name|CMOS_DATA
argument_list|)
expr_stmt|;
comment|/* record BSP in CPU map */
name|all_cpus
operator|=
literal|1
expr_stmt|;
comment|/* start each AP */
for|for
control|(
name|x
operator|=
literal|1
init|;
name|x
operator|<=
name|mp_naps
condition|;
operator|++
name|x
control|)
block|{
comment|/* HACK HACK HACK !!! */
comment|/* alloc new page table directory */
name|newptd
operator|=
call|(
name|pd_entry_t
call|)
argument_list|(
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clone currently active one (ie: IdlePTD) */
name|bcopy
argument_list|(
name|PTD
argument_list|,
name|newptd
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* inc prv page pde */
comment|/* set up 0 -> 4MB P==V mapping for AP boot */
name|newptd
index|[
literal|0
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
operator|(
operator|(
name|u_long
operator|)
name|KPTphys
operator|&
name|PG_FRAME
operator|)
expr_stmt|;
comment|/* store PTD for this AP */
name|bootPTD
operator|=
operator|(
name|pd_entry_t
operator|)
name|vtophys
argument_list|(
name|newptd
argument_list|)
expr_stmt|;
comment|/* alloc new page table page */
name|newpt
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the new PTD's private page to point there */
name|newptd
index|[
name|MPPTDI
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|newpt
argument_list|)
expr_stmt|;
comment|/* install self referential entry */
name|newptd
index|[
name|PTDPTDI
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|newptd
argument_list|)
expr_stmt|;
comment|/* get a new private data page */
name|newpp
operator|=
operator|(
name|int
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* wire it into the private page table page */
name|newpt
index|[
literal|0
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
comment|/* wire the ptp into itself for access */
name|newpt
index|[
literal|1
index|]
operator|=
name|PG_V
operator||
name|PG_RW
operator||
name|vtophys
argument_list|(
name|newpt
argument_list|)
expr_stmt|;
comment|/* and the local apic */
name|newpt
index|[
literal|2
index|]
operator|=
name|SMP_prvpt
index|[
literal|2
index|]
expr_stmt|;
comment|/* and the IO apic mapping[s] */
for|for
control|(
name|i
operator|=
literal|16
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
name|newpt
index|[
name|i
index|]
operator|=
name|SMP_prvpt
index|[
name|i
index|]
expr_stmt|;
comment|/* prime data page for it to use */
name|newpp
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
comment|/* cpuid */
name|newpp
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* curproc */
name|newpp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* curpcb */
name|newpp
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* npxproc */
name|newpp
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
comment|/* runtime.tv_sec */
name|newpp
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
comment|/* runtime.tv_usec */
name|newpp
index|[
literal|6
index|]
operator|=
name|x
operator|<<
literal|24
expr_stmt|;
comment|/* cpu_lockid */
comment|/* XXX NOTE: ABANDON bootPTD for now!!!! */
comment|/* END REVOLTING HACKERY */
comment|/* setup a vector to our boot code */
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_OFF
operator|)
operator|=
name|WARMBOOT_TARGET
expr_stmt|;
operator|*
operator|(
operator|(
specifier|volatile
name|u_short
operator|*
operator|)
name|WARMBOOT_SEG
operator|)
operator|=
operator|(
name|boot_addr
operator|>>
literal|4
operator|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|BIOS_WARM
argument_list|)
expr_stmt|;
comment|/* 'warm-start' */
comment|/* attempt to start the Application Processor */
name|CHECK_INIT
argument_list|(
literal|99
argument_list|)
expr_stmt|;
comment|/* setup checkpoints */
if|if
condition|(
operator|!
name|start_ap
argument_list|(
name|x
argument_list|,
name|boot_addr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"AP #%d (PHY# %d) failed!\n"
argument_list|,
name|x
argument_list|,
name|CPU_TO_ID
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* better panic as the AP may be running loose */
name|printf
argument_list|(
literal|"panic y/n? [y] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|cngetc
argument_list|()
operator|!=
literal|'n'
condition|)
name|panic
argument_list|(
literal|"bye-bye"
argument_list|)
expr_stmt|;
block|}
name|CHECK_PRINT
argument_list|(
literal|"trace"
argument_list|)
expr_stmt|;
comment|/* show checkpoints */
comment|/* record its version info */
name|cpu_apic_versions
index|[
name|x
index|]
operator|=
name|cpu_apic_versions
index|[
literal|0
index|]
expr_stmt|;
name|all_cpus
operator||=
operator|(
literal|1
operator|<<
name|x
operator|)
expr_stmt|;
comment|/* record AP in CPU map */
block|}
comment|/* build our map of 'other' CPUs */
name|other_cpus
operator|=
name|all_cpus
operator|&
operator|~
operator|(
literal|1
operator|<<
name|cpuid
operator|)
expr_stmt|;
comment|/* fill in our (BSP) APIC version */
name|cpu_apic_versions
index|[
literal|0
index|]
operator|=
name|lapic
operator|.
name|version
expr_stmt|;
comment|/* restore the warmstart vector */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|WARMBOOT_OFF
operator|=
name|mpbioswarmvec
expr_stmt|;
name|outb
argument_list|(
name|CMOS_REG
argument_list|,
name|BIOS_RESET
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|CMOS_DATA
argument_list|,
name|mpbiosreason
argument_list|)
expr_stmt|;
name|pmap_set_opt_bsp
argument_list|()
expr_stmt|;
comment|/* number of APs actually started */
return|return
name|mp_ncpus
operator|-
literal|1
return|;
block|}
comment|/*  * load the 1st level AP boot code into base memory.  */
comment|/* targets for relocation */
specifier|extern
name|void
name|bigJump
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootCodeSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|bootDataSeg
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|MPentry
argument_list|(
name|void
argument_list|)
decl_stmt|;
specifier|extern
name|u_int
name|MP_GDT
decl_stmt|;
specifier|extern
name|u_int
name|mp_gdtbase
decl_stmt|;
specifier|static
name|void
name|install_ap_tramp
parameter_list|(
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|int
name|size
init|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
operator|&
name|bootMP_size
operator|)
decl_stmt|;
name|u_char
modifier|*
name|src
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|u_long
operator|)
name|bootMP
operator|)
decl_stmt|;
name|u_char
modifier|*
name|dst
init|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
decl_stmt|;
name|u_int
name|boot_base
init|=
operator|(
name|u_int
operator|)
name|bootMP
decl_stmt|;
name|u_int8_t
modifier|*
name|dst8
decl_stmt|;
name|u_int16_t
modifier|*
name|dst16
decl_stmt|;
name|u_int32_t
modifier|*
name|dst32
decl_stmt|;
name|POSTCODE
argument_list|(
name|INSTALL_AP_TRAMP_POST
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|size
condition|;
operator|++
name|x
control|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
comment|/* 	 * modify addresses in code we just moved to basemem. unfortunately we 	 * need fairly detailed info about mpboot.s for this to work.  changes 	 * to mpboot.s might require changes here. 	 */
comment|/* boot code is located in KERNEL space */
name|dst
operator|=
operator|(
name|u_char
operator|*
operator|)
name|boot_addr
operator|+
name|KERNBASE
expr_stmt|;
comment|/* modify the lgdt arg */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|mp_gdtbase
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
name|boot_addr
operator|+
operator|(
operator|(
name|u_int
operator|)
operator|&
name|MP_GDT
operator|-
name|boot_base
operator|)
expr_stmt|;
comment|/* modify the ljmp target for MPentry() */
name|dst32
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bigJump
operator|-
name|boot_base
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst32
operator|=
operator|(
operator|(
name|u_int
operator|)
name|MPentry
operator|-
name|KERNBASE
operator|)
expr_stmt|;
comment|/* modify the target for boot code segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootCodeSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* modify the target for boot data segment */
name|dst16
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|dst
operator|+
operator|(
operator|(
name|u_int
operator|)
name|bootDataSeg
operator|-
name|boot_base
operator|)
operator|)
expr_stmt|;
name|dst8
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|dst16
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst16
operator|=
operator|(
name|u_int
operator|)
name|boot_addr
operator|&
literal|0xffff
expr_stmt|;
operator|*
name|dst8
operator|=
operator|(
operator|(
name|u_int
operator|)
name|boot_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/*  * this function starts the AP (application processor) identified  * by the APIC ID 'physicalCpu'.  It does quite a "song and dance"  * to accomplish this.  This is necessary because of the nuances  * of the different hardware we might encounter.  It ain't pretty,  * but it seems to work.  */
specifier|static
name|int
name|start_ap
parameter_list|(
name|int
name|logical_cpu
parameter_list|,
name|u_int
name|boot_addr
parameter_list|)
block|{
name|int
name|physical_cpu
decl_stmt|;
name|int
name|vector
decl_stmt|;
name|int
name|cpus
decl_stmt|;
name|u_long
name|icr_lo
decl_stmt|,
name|icr_hi
decl_stmt|;
name|POSTCODE
argument_list|(
name|START_AP_POST
argument_list|)
expr_stmt|;
comment|/* get the PHYSICAL APIC ID# */
name|physical_cpu
operator|=
name|CPU_TO_ID
argument_list|(
name|logical_cpu
argument_list|)
expr_stmt|;
comment|/* calculate the vector */
name|vector
operator|=
operator|(
name|boot_addr
operator|>>
literal|12
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* used as a watchpoint to signal AP startup */
name|cpus
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* 	 * first we do an INIT/RESET IPI this INIT IPI might be run, reseting 	 * and running the target CPU. OR this INIT IPI might be latched (P5 	 * bug), CPU waiting for STARTUP IPI. OR this INIT IPI might be 	 * ignored. 	 */
comment|/* setup the address for the target AP */
name|icr_hi
operator|=
name|lapic
operator|.
name|icr_hi
operator|&
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|icr_hi
operator||=
operator|(
name|physical_cpu
operator|<<
literal|24
operator|)
expr_stmt|;
name|lapic
operator|.
name|icr_hi
operator|=
name|icr_hi
expr_stmt|;
comment|/* do an INIT IPI: assert RESET */
name|icr_lo
operator|=
name|lapic
operator|.
name|icr_lo
operator|&
literal|0xfff00000
expr_stmt|;
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x0000c500
expr_stmt|;
comment|/* wait for pending status end */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* do an INIT IPI: deassert RESET */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00008500
expr_stmt|;
comment|/* wait for pending status end */
name|u_sleep
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait ~10mS */
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
comment|/* 	 * next we do a STARTUP IPI: the previous INIT IPI might still be 	 * latched, (P5 bug) this 1st STARTUP would then terminate 	 * immediately, and the previously started INIT IPI would continue. OR 	 * the previous INIT IPI has already run. and this STARTUP IPI will 	 * run. OR the previous INIT IPI was ignored. and this STARTUP IPI 	 * will run. 	 */
comment|/* do a STARTUP IPI */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* 	 * finally we do a 2nd STARTUP IPI: this 2nd STARTUP IPI should run IF 	 * the previous STARTUP IPI was cancelled by a latched INIT IPI. OR 	 * this STARTUP IPI will be ignored, as only ONE STARTUP IPI is 	 * recognized after hardware RESET or INIT IPI. 	 */
name|lapic
operator|.
name|icr_lo
operator|=
name|icr_lo
operator||
literal|0x00000600
operator||
name|vector
expr_stmt|;
while|while
condition|(
name|lapic
operator|.
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
condition|)
comment|/* spin */
empty_stmt|;
name|u_sleep
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* wait for it to start */
name|set_apic_timer
argument_list|(
literal|5000000
argument_list|)
expr_stmt|;
comment|/* == 5 seconds */
while|while
condition|(
name|read_apic_timer
argument_list|()
condition|)
if|if
condition|(
name|mp_ncpus
operator|>
name|cpus
condition|)
return|return
literal|1
return|;
comment|/* return SUCCESS */
return|return
literal|0
return|;
comment|/* return FAILURE */
block|}
comment|/*  * Flush the TLB on all other CPU's  *  * XXX: Needs to handshake and wait for completion before proceding.  */
name|void
name|smp_invltlb
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|APIC_IO
argument_list|)
if|if
condition|(
name|smp_active
operator|&&
name|invltlb_ok
condition|)
name|all_but_self_ipi
argument_list|(
name|XINVLTLB_OFFSET
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APIC_IO */
block|}
name|void
name|invlpg
parameter_list|(
name|u_int
name|addr
parameter_list|)
block|{
asm|__asm   __volatile("invlpg (%0)"::"r"(addr):"memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
name|void
name|invltlb
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|temp
decl_stmt|;
comment|/* 	 * This should be implemented as load_cr3(rcr3()) when load_cr3() is 	 * inlined. 	 */
asm|__asm __volatile("movl %%cr3, %0; movl %0, %%cr3":"=r"(temp) :: "memory");
comment|/* send a message to the other CPUs */
name|smp_invltlb
argument_list|()
expr_stmt|;
block|}
comment|/*  * When called the executing CPU will send an IPI to all other CPUs  *  requesting that they halt execution.  *  * Usually (but not necessarily) called with 'other_cpus' as its arg.  *  *  - Signals all CPUs in map to stop.  *  - Waits for each to stop.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  *  * XXX FIXME: this is not MP-safe, needs a lock to prevent multiple CPUs  *            from executing at same time.  */
name|int
name|stop_cpus
parameter_list|(
name|u_int
name|map
parameter_list|)
block|{
if|if
condition|(
operator|!
name|smp_active
condition|)
return|return
literal|0
return|;
comment|/* send IPI to all CPUs in map */
name|stopped_cpus
operator|=
literal|0
expr_stmt|;
comment|/* send the Xcpustop IPI to all CPUs in map */
name|selected_apic_ipi
argument_list|(
name|map
argument_list|,
name|XCPUSTOP_OFFSET
argument_list|,
name|APIC_DELMODE_FIXED
argument_list|)
expr_stmt|;
while|while
condition|(
name|stopped_cpus
operator|!=
name|map
condition|)
comment|/* spin */
empty_stmt|;
return|return
literal|1
return|;
block|}
comment|/*  * Called by a CPU to restart stopped CPUs.   *  * Usually (but not necessarily) called with 'stopped_cpus' as its arg.  *  *  - Signals all CPUs in map to restart.  *  - Waits for each to restart.  *  * Returns:  *  -1: error  *   0: NA  *   1: ok  */
name|int
name|restart_cpus
parameter_list|(
name|u_int
name|map
parameter_list|)
block|{
if|if
condition|(
operator|!
name|smp_active
condition|)
return|return
literal|0
return|;
name|started_cpus
operator|=
name|map
expr_stmt|;
comment|/* signal other cpus to restart */
while|while
condition|(
name|started_cpus
condition|)
comment|/* wait for each to clear its bit */
comment|/* spin */
empty_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

