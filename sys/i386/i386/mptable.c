begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 John Baldwin<jhb@FreeBSD.org>  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mptable_force_htt.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mptable.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_comment
comment|/* string defined by the Intel MP Spec as identifying the MP table */
end_comment

begin_define
define|#
directive|define
name|MP_SIG
value|0x5f504d5f
end_define

begin_comment
comment|/* _MP_ */
end_comment

begin_define
define|#
directive|define
name|NAPICID
value|32
end_define

begin_comment
comment|/* Max number of APIC's */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xe8000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x18000)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BIOS_BASE
value|(0xf0000)
end_define

begin_define
define|#
directive|define
name|BIOS_SIZE
value|(0x10000)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BIOS_COUNT
value|(BIOS_SIZE/4)
end_define

begin_typedef
typedef|typedef
name|void
name|mptable_entry_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|basetable_entry
name|basetable_entry_types
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|20
block|,
literal|"Processor"
block|}
block|,
block|{
literal|1
block|,
literal|8
block|,
literal|"Bus"
block|}
block|,
block|{
literal|2
block|,
literal|8
block|,
literal|"I/O APIC"
block|}
block|,
block|{
literal|3
block|,
literal|8
block|,
literal|"I/O INT"
block|}
block|,
block|{
literal|4
block|,
literal|8
block|,
literal|"Local INT"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|BUSDATA
block|{
name|u_char
name|bus_id
decl_stmt|;
name|enum
name|busTypes
name|bus_type
decl_stmt|;
block|}
name|bus_datum
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|INTDATA
block|{
name|u_char
name|int_type
decl_stmt|;
name|u_short
name|int_flags
decl_stmt|;
name|u_char
name|src_bus_id
decl_stmt|;
name|u_char
name|src_bus_irq
decl_stmt|;
name|u_char
name|dst_apic_id
decl_stmt|;
name|u_char
name|dst_apic_int
decl_stmt|;
name|u_char
name|int_vector
decl_stmt|;
block|}
name|io_int
operator|,
name|local_int
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|BUSTYPENAME
block|{
name|u_char
name|type
decl_stmt|;
name|char
name|name
index|[
literal|7
index|]
decl_stmt|;
block|}
name|bus_type_name
typedef|;
end_typedef

begin_comment
comment|/* From MP spec v1.4, table 4-8. */
end_comment

begin_decl_stmt
specifier|static
name|bus_type_name
name|bus_type_table
index|[]
init|=
block|{
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"CBUS  "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"CBUSII"
block|}
block|,
block|{
name|EISA
block|,
literal|"EISA  "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"FUTURE"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"INTERN"
block|}
block|,
block|{
name|ISA
block|,
literal|"ISA   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"MBI   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"MBII  "
block|}
block|,
block|{
name|MCA
block|,
literal|"MCA   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"MPI   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"MPSA  "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"NUBUS "
block|}
block|,
block|{
name|PCI
block|,
literal|"PCI   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"PCMCIA"
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"TC    "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"VL    "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"VME   "
block|}
block|,
block|{
name|UNKNOWN_BUSTYPE
block|,
literal|"XPRESS"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From MP spec v1.4, table 5-1. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_data
index|[
literal|7
index|]
index|[
literal|5
index|]
init|=
block|{
comment|/*   nbus, id0, type0, id1, type1 */
block|{
literal|1
block|,
literal|0
block|,
name|ISA
block|,
literal|255
block|,
name|NOBUS
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
name|NOBUS
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|EISA
block|,
literal|255
block|,
name|NOBUS
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
name|MCA
block|,
literal|255
block|,
name|NOBUS
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|ISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|EISA
block|,
literal|1
block|,
name|PCI
block|}
block|,
block|{
literal|2
block|,
literal|0
block|,
name|MCA
block|,
literal|1
block|,
name|PCI
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pci_probe_table_args
block|{
name|u_char
name|bus
decl_stmt|;
name|u_char
name|found
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|pci_route_interrupt_args
block|{
name|u_char
name|bus
decl_stmt|;
comment|/* Source bus. */
name|u_char
name|irq
decl_stmt|;
comment|/* Source slot:pin. */
name|int
name|vector
decl_stmt|;
comment|/* Return value. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|mpfps_t
name|mpfps
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mpcth_t
name|mpct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|ioapics
index|[
name|NAPICID
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_datum
modifier|*
name|busses
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mptable_nioapics
decl_stmt|,
name|mptable_nbusses
decl_stmt|,
name|mptable_maxbusid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pci0
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MPTABLE
argument_list|,
literal|"MP Table"
argument_list|,
literal|"MP Table Items"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|enum
name|intr_polarity
name|conforming_polarity
parameter_list|(
name|u_char
name|src_bus
parameter_list|,
name|u_char
name|src_bus_irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|intr_trigger
name|conforming_trigger
parameter_list|(
name|u_char
name|src_bus
parameter_list|,
name|u_char
name|src_bus_irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|intr_polarity
name|intentry_polarity
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|intr_trigger
name|intentry_trigger
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lookup_bus_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_count_items
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_count_items_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MPTABLE_FORCE_HTT
end_ifdef

begin_function_decl
specifier|static
name|void
name|mptable_hyperthread_fixup
parameter_list|(
name|u_int
name|id_mask
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|mptable_parse_apics_and_busses
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_apics_and_busses_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_default_config_ints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_ints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_ints_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_io_int
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_parse_local_int
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_pci_probe_table_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_pci_route_interrupt_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_pci_setup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_probe
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_probe_cpus
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_probe_cpus_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_register
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_setup_local
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mptable_setup_io
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mptable_walk_table
parameter_list|(
name|mptable_entry_handler
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|apic_enumerator
name|mptable_enumerator
init|=
block|{
literal|"MPTable"
block|,
name|mptable_probe
block|,
name|mptable_probe_cpus
block|,
name|mptable_setup_local
block|,
name|mptable_setup_io
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * look for the MP spec signature  */
end_comment

begin_function
specifier|static
name|int
name|search_for_sig
parameter_list|(
name|u_int32_t
name|target
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_int32_t
modifier|*
name|addr
init|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
name|target
operator|)
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|count
condition|;
name|x
operator|+=
literal|4
control|)
if|if
condition|(
name|addr
index|[
name|x
index|]
operator|==
name|MP_SIG
condition|)
comment|/* make array index a byte index */
return|return
operator|(
name|target
operator|+
operator|(
name|x
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lookup_bus_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|MAX_BUSTYPE
condition|;
operator|++
name|x
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|bus_type_table
index|[
name|x
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bus_type_table
index|[
name|x
index|]
operator|.
name|type
operator|)
return|;
return|return
operator|(
name|UNKNOWN_BUSTYPE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for an Intel MP spec table (ie, SMP capable hardware).  */
end_comment

begin_function
specifier|static
name|int
name|mptable_probe
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|u_long
name|segment
decl_stmt|;
name|u_int32_t
name|target
decl_stmt|;
comment|/* see if EBDA exists */
if|if
condition|(
operator|(
name|segment
operator|=
operator|(
name|u_long
operator|)
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|KERNBASE
operator|+
literal|0x40e
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* search first 1K of EBDA */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|segment
operator|<<
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
else|else
block|{
comment|/* last 1K of base memory, effective 'top of base' passed in */
name|target
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|basemem
operator|*
literal|1024
operator|)
operator|-
literal|0x400
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
literal|1024
operator|/
literal|4
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* search the BIOS */
name|target
operator|=
operator|(
name|u_int32_t
operator|)
name|BIOS_BASE
expr_stmt|;
if|if
condition|(
operator|(
name|x
operator|=
name|search_for_sig
argument_list|(
name|target
argument_list|,
name|BIOS_COUNT
argument_list|)
operator|)
operator|>=
literal|0
condition|)
goto|goto
name|found
goto|;
comment|/* nothing found */
return|return
operator|(
name|ENXIO
operator|)
return|;
name|found
label|:
name|mpfps
operator|=
call|(
name|mpfps_t
call|)
argument_list|(
name|KERNBASE
operator|+
name|x
argument_list|)
expr_stmt|;
comment|/* Map in the configuration table if it exists. */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MP Table version 1.%d found using Default Configuration %d\n"
argument_list|,
name|mpfps
operator|->
name|spec_rev
argument_list|,
name|mpfps
operator|->
name|config_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|5
operator|&&
name|mpfps
operator|->
name|config_type
operator|!=
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"MP Table Default Configuration %d is unsupported\n"
argument_list|,
name|mpfps
operator|->
name|config_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mpct
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|mpfps
operator|->
name|pap
operator|>=
literal|1024
operator|*
literal|1024
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to map MP Configuration Table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mpct
operator|=
call|(
name|mpcth_t
call|)
argument_list|(
name|KERNBASE
operator|+
operator|(
name|uintptr_t
operator|)
name|mpfps
operator|->
name|pap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpct
operator|->
name|base_table_length
operator|+
operator|(
name|uintptr_t
operator|)
name|mpfps
operator|->
name|pap
operator|>=
literal|1024
operator|*
literal|1024
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Unable to map end of MP Config Table\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|mpct
operator|->
name|signature
index|[
literal|0
index|]
operator|!=
literal|'P'
operator|||
name|mpct
operator|->
name|signature
index|[
literal|1
index|]
operator|!=
literal|'C'
operator|||
name|mpct
operator|->
name|signature
index|[
literal|2
index|]
operator|!=
literal|'M'
operator|||
name|mpct
operator|->
name|signature
index|[
literal|3
index|]
operator|!=
literal|'P'
condition|)
block|{
name|printf
argument_list|(
literal|"%s: MP Config Table has bad signature: %c%c%c%c\n"
argument_list|,
name|__func__
argument_list|,
name|mpct
operator|->
name|signature
index|[
literal|0
index|]
argument_list|,
name|mpct
operator|->
name|signature
index|[
literal|1
index|]
argument_list|,
name|mpct
operator|->
name|signature
index|[
literal|2
index|]
argument_list|,
name|mpct
operator|->
name|signature
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MP Configuration Table version 1.%d found at %p\n"
argument_list|,
name|mpct
operator|->
name|spec_rev
argument_list|,
name|mpct
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|100
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run through the MP table enumerating CPUs.  */
end_comment

begin_function
specifier|static
name|int
name|mptable_probe_cpus
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpu_mask
decl_stmt|;
comment|/* Is this a pre-defined config? */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
name|lapic_create
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lapic_create
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cpu_mask
operator|=
literal|0
expr_stmt|;
name|mptable_walk_table
argument_list|(
name|mptable_probe_cpus_handler
argument_list|,
operator|&
name|cpu_mask
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MPTABLE_FORCE_HTT
name|mptable_hyperthread_fixup
argument_list|(
name|cpu_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the local APIC on the BSP.  */
end_comment

begin_function
specifier|static
name|int
name|mptable_setup_local
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Is this a pre-defined config? */
name|printf
argument_list|(
literal|"MPTable:<"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
name|lapic_init
argument_list|(
name|DEFAULT_APIC_BASE
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Default Configuration %d"
argument_list|,
name|mpfps
operator|->
name|config_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lapic_init
argument_list|(
operator|(
name|uintptr_t
operator|)
name|mpct
operator|->
name|apic_address
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%.*s %.*s"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|mpct
operator|->
name|oem_id
argument_list|)
argument_list|,
name|mpct
operator|->
name|oem_id
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|mpct
operator|->
name|product_id
argument_list|)
argument_list|,
name|mpct
operator|->
name|product_id
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|">\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run through the MP table enumerating I/O APICs.  */
end_comment

begin_function
specifier|static
name|int
name|mptable_setup_io
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u_char
name|byte
decl_stmt|;
comment|/* First, we count individual items and allocate arrays. */
name|mptable_count_items
argument_list|()
expr_stmt|;
name|busses
operator|=
name|malloc
argument_list|(
operator|(
name|mptable_maxbusid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|bus_datum
argument_list|)
argument_list|,
name|M_MPTABLE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mptable_maxbusid
condition|;
name|i
operator|++
control|)
name|busses
index|[
name|i
index|]
operator|.
name|bus_type
operator|=
name|NOBUS
expr_stmt|;
comment|/* Second, we run through adding I/O APIC's and busses. */
name|ioapic_enable_mixed_mode
argument_list|()
expr_stmt|;
name|mptable_parse_apics_and_busses
argument_list|()
expr_stmt|;
comment|/* Third, we run through the table tweaking interrupt sources. */
name|mptable_parse_ints
argument_list|()
expr_stmt|;
comment|/* Fourth, we register all the I/O APIC's. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NAPICID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ioapics
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|ioapic_register
argument_list|(
name|ioapics
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Fifth, we setup data structures to handle PCI interrupt routing. */
name|mptable_pci_setup
argument_list|()
expr_stmt|;
comment|/* Finally, we throw the switch to enable the I/O APIC's. */
if|if
condition|(
name|mpfps
operator|->
name|mpfb2
operator|&
name|MPFB2_IMCR_PRESENT
condition|)
block|{
name|outb
argument_list|(
literal|0x22
argument_list|,
literal|0x70
argument_list|)
expr_stmt|;
comment|/* select IMCR */
name|byte
operator|=
name|inb
argument_list|(
literal|0x23
argument_list|)
expr_stmt|;
comment|/* current contents */
name|byte
operator||=
literal|0x01
expr_stmt|;
comment|/* mask external INTR */
name|outb
argument_list|(
literal|0x23
argument_list|,
name|byte
argument_list|)
expr_stmt|;
comment|/* disconnect 8259s/NMI */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mptable_register
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|apic_register_enumerator
argument_list|(
operator|&
name|mptable_enumerator
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|mptable_register
argument_list|,
argument|SI_SUB_CPU -
literal|1
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|mptable_register
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Call the handler routine for each entry in the MP config table.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_walk_table
parameter_list|(
name|mptable_entry_handler
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_char
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|mpct
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mpct
operator|->
name|entry_count
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|entry
condition|)
block|{
case|case
name|MPCT_ENTRY_PROCESSOR
case|:
case|case
name|MPCT_ENTRY_IOAPIC
case|:
case|case
name|MPCT_ENTRY_BUS
case|:
case|case
name|MPCT_ENTRY_INT
case|:
case|case
name|MPCT_ENTRY_LOCAL_INT
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Unknown MP Config Entry %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
operator|*
name|entry
argument_list|)
expr_stmt|;
block|}
name|handler
argument_list|(
name|entry
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|entry
operator|+=
name|basetable_entry_types
index|[
operator|*
name|entry
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mptable_probe_cpus_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|proc_entry_ptr
name|proc
decl_stmt|;
name|u_int
modifier|*
name|cpu_mask
decl_stmt|;
switch|switch
condition|(
operator|*
name|entry
condition|)
block|{
case|case
name|MPCT_ENTRY_PROCESSOR
case|:
name|proc
operator|=
operator|(
name|proc_entry_ptr
operator|)
name|entry
expr_stmt|;
if|if
condition|(
name|proc
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_EN
condition|)
block|{
name|lapic_create
argument_list|(
name|proc
operator|->
name|apic_id
argument_list|,
name|proc
operator|->
name|cpu_flags
operator|&
name|PROCENTRY_FLAG_BP
argument_list|)
expr_stmt|;
name|cpu_mask
operator|=
operator|(
name|u_int
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|cpu_mask
operator||=
operator|(
literal|1
operator|<<
name|proc
operator|->
name|apic_id
operator|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mptable_count_items_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|io_apic_entry_ptr
name|apic
decl_stmt|;
name|bus_entry_ptr
name|bus
decl_stmt|;
switch|switch
condition|(
operator|*
name|entry
condition|)
block|{
case|case
name|MPCT_ENTRY_BUS
case|:
name|bus
operator|=
operator|(
name|bus_entry_ptr
operator|)
name|entry
expr_stmt|;
name|mptable_nbusses
operator|++
expr_stmt|;
if|if
condition|(
name|bus
operator|->
name|bus_id
operator|>
name|mptable_maxbusid
condition|)
name|mptable_maxbusid
operator|=
name|bus
operator|->
name|bus_id
expr_stmt|;
break|break;
case|case
name|MPCT_ENTRY_IOAPIC
case|:
name|apic
operator|=
operator|(
name|io_apic_entry_ptr
operator|)
name|entry
expr_stmt|;
if|if
condition|(
name|apic
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
condition|)
name|mptable_nioapics
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Count items in the table.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_count_items
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Is this a pre-defined config? */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
name|mptable_nioapics
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|mpfps
operator|->
name|config_type
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
name|mptable_nbusses
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
name|mptable_nbusses
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown pre-defined MP Table config type %d"
argument_list|,
name|mpfps
operator|->
name|config_type
argument_list|)
expr_stmt|;
block|}
name|mptable_maxbusid
operator|=
name|mptable_nbusses
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|mptable_walk_table
argument_list|(
name|mptable_count_items_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a bus or I/O APIC from an entry in the table.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_apics_and_busses_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|io_apic_entry_ptr
name|apic
decl_stmt|;
name|bus_entry_ptr
name|bus
decl_stmt|;
name|enum
name|busTypes
name|bus_type
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
operator|*
name|entry
condition|)
block|{
case|case
name|MPCT_ENTRY_BUS
case|:
name|bus
operator|=
operator|(
name|bus_entry_ptr
operator|)
name|entry
expr_stmt|;
name|bus_type
operator|=
name|lookup_bus_type
argument_list|(
name|bus
operator|->
name|bus_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_type
operator|==
name|UNKNOWN_BUSTYPE
condition|)
block|{
name|printf
argument_list|(
literal|"MPTable: Unknown bus %d type \""
argument_list|,
name|bus
operator|->
name|bus_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|bus
operator|->
name|bus_type
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
name|busses
index|[
name|bus
operator|->
name|bus_id
index|]
operator|.
name|bus_id
operator|=
name|bus
operator|->
name|bus_id
expr_stmt|;
name|busses
index|[
name|bus
operator|->
name|bus_id
index|]
operator|.
name|bus_type
operator|=
name|bus_type
expr_stmt|;
break|break;
case|case
name|MPCT_ENTRY_IOAPIC
case|:
name|apic
operator|=
operator|(
name|io_apic_entry_ptr
operator|)
name|entry
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|apic
operator|->
name|apic_flags
operator|&
name|IOAPICENTRY_FLAG_EN
operator|)
condition|)
break|break;
if|if
condition|(
name|apic
operator|->
name|apic_id
operator|>=
name|NAPICID
condition|)
name|panic
argument_list|(
literal|"%s: I/O APIC ID %d too high"
argument_list|,
name|__func__
argument_list|,
name|apic
operator|->
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioapics
index|[
name|apic
operator|->
name|apic_id
index|]
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: Double APIC ID %d"
argument_list|,
name|__func__
argument_list|,
name|apic
operator|->
name|apic_id
argument_list|)
expr_stmt|;
name|ioapics
index|[
name|apic
operator|->
name|apic_id
index|]
operator|=
name|ioapic_create
argument_list|(
operator|(
name|uintptr_t
operator|)
name|apic
operator|->
name|apic_address
argument_list|,
name|apic
operator|->
name|apic_id
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Enumerate I/O APIC's and busses.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_apics_and_busses
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Is this a pre-defined config? */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
name|ioapics
index|[
literal|2
index|]
operator|=
name|ioapic_create
argument_list|(
name|DEFAULT_IO_APIC_BASE
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|busses
index|[
literal|0
index|]
operator|.
name|bus_id
operator|=
literal|0
expr_stmt|;
name|busses
index|[
literal|0
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|mpfps
operator|->
name|config_type
operator|-
literal|1
index|]
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|mptable_nbusses
operator|>
literal|1
condition|)
block|{
name|busses
index|[
literal|1
index|]
operator|.
name|bus_id
operator|=
literal|1
expr_stmt|;
name|busses
index|[
literal|1
index|]
operator|.
name|bus_type
operator|=
name|default_data
index|[
name|mpfps
operator|->
name|config_type
operator|-
literal|1
index|]
index|[
literal|4
index|]
expr_stmt|;
block|}
block|}
else|else
name|mptable_walk_table
argument_list|(
name|mptable_parse_apics_and_busses_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine conforming polarity for a given bus type.  */
end_comment

begin_function
specifier|static
name|enum
name|intr_polarity
name|conforming_polarity
parameter_list|(
name|u_char
name|src_bus
parameter_list|,
name|u_char
name|src_bus_irq
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|src_bus
operator|<=
name|mptable_maxbusid
argument_list|,
operator|(
literal|"bus id %d too large"
operator|,
name|src_bus
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|busses
index|[
name|src_bus
index|]
operator|.
name|bus_type
condition|)
block|{
case|case
name|ISA
case|:
case|case
name|EISA
case|:
return|return
operator|(
name|INTR_POLARITY_HIGH
operator|)
return|;
case|case
name|PCI
case|:
return|return
operator|(
name|INTR_POLARITY_LOW
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unknown bus type %d"
argument_list|,
name|__func__
argument_list|,
name|busses
index|[
name|src_bus
index|]
operator|.
name|bus_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine conforming trigger for a given bus type.  */
end_comment

begin_function
specifier|static
name|enum
name|intr_trigger
name|conforming_trigger
parameter_list|(
name|u_char
name|src_bus
parameter_list|,
name|u_char
name|src_bus_irq
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|src_bus
operator|<=
name|mptable_maxbusid
argument_list|,
operator|(
literal|"bus id %d too large"
operator|,
name|src_bus
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|busses
index|[
name|src_bus
index|]
operator|.
name|bus_type
condition|)
block|{
case|case
name|ISA
case|:
ifndef|#
directive|ifndef
name|PC98
if|if
condition|(
name|elcr_found
condition|)
return|return
operator|(
name|elcr_read_trigger
argument_list|(
name|src_bus_irq
argument_list|)
operator|)
return|;
else|else
endif|#
directive|endif
return|return
operator|(
name|INTR_TRIGGER_EDGE
operator|)
return|;
case|case
name|PCI
case|:
return|return
operator|(
name|INTR_TRIGGER_LEVEL
operator|)
return|;
ifndef|#
directive|ifndef
name|PC98
case|case
name|EISA
case|:
name|KASSERT
argument_list|(
name|src_bus_irq
operator|<
literal|16
argument_list|,
operator|(
literal|"Invalid EISA IRQ %d"
operator|,
name|src_bus_irq
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|elcr_found
argument_list|,
operator|(
literal|"Missing ELCR"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|elcr_read_trigger
argument_list|(
name|src_bus_irq
argument_list|)
operator|)
return|;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: unknown bus type %d"
argument_list|,
name|__func__
argument_list|,
name|busses
index|[
name|src_bus
index|]
operator|.
name|bus_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|intr_polarity
name|intentry_polarity
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
block|{
switch|switch
condition|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_POLARITY
condition|)
block|{
case|case
name|INTENTRY_FLAGS_POLARITY_CONFORM
case|:
return|return
operator|(
name|conforming_polarity
argument_list|(
name|intr
operator|->
name|src_bus_id
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
operator|)
return|;
case|case
name|INTENTRY_FLAGS_POLARITY_ACTIVEHI
case|:
return|return
operator|(
name|INTR_POLARITY_HIGH
operator|)
return|;
case|case
name|INTENTRY_FLAGS_POLARITY_ACTIVELO
case|:
return|return
operator|(
name|INTR_POLARITY_LOW
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"Bogus interrupt flags"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|intr_trigger
name|intentry_trigger
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
block|{
switch|switch
condition|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_TRIGGER
condition|)
block|{
case|case
name|INTENTRY_FLAGS_TRIGGER_CONFORM
case|:
return|return
operator|(
name|conforming_trigger
argument_list|(
name|intr
operator|->
name|src_bus_id
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
operator|)
return|;
case|case
name|INTENTRY_FLAGS_TRIGGER_EDGE
case|:
return|return
operator|(
name|INTR_TRIGGER_EDGE
operator|)
return|;
case|case
name|INTENTRY_FLAGS_TRIGGER_LEVEL
case|:
return|return
operator|(
name|INTR_TRIGGER_LEVEL
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"Bogus interrupt flags"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse an interrupt entry for an I/O interrupt routed to a pin on an I/O APIC.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_io_int
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
block|{
name|void
modifier|*
name|ioapic
decl_stmt|;
name|u_int
name|pin
decl_stmt|,
name|apic_id
decl_stmt|;
name|apic_id
operator|=
name|intr
operator|->
name|dst_apic_id
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|dst_apic_id
operator|==
literal|0xff
condition|)
block|{
comment|/* 		 * An APIC ID of 0xff means that the interrupt is connected 		 * to the specified pin on all I/O APICs in the system.  If 		 * there is only one I/O APIC, then use that APIC to route 		 * the interrupts.  If there is more than one I/O APIC, then 		 * punt. 		 */
if|if
condition|(
name|mptable_nioapics
operator|==
literal|1
condition|)
block|{
name|apic_id
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ioapics
index|[
name|apic_id
index|]
operator|==
name|NULL
condition|)
name|apic_id
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"MPTable: Ignoring global interrupt entry for pin %d\n"
argument_list|,
name|intr
operator|->
name|dst_apic_int
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|apic_id
operator|>=
name|NAPICID
condition|)
block|{
name|printf
argument_list|(
literal|"MPTable: Ignoring interrupt entry for ioapic%d\n"
argument_list|,
name|intr
operator|->
name|dst_apic_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|ioapic
operator|=
name|ioapics
index|[
name|apic_id
index|]
expr_stmt|;
if|if
condition|(
name|ioapic
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"MPTable: Ignoring interrupt entry for missing ioapic%d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|pin
operator|=
name|intr
operator|->
name|dst_apic_int
expr_stmt|;
switch|switch
condition|(
name|intr
operator|->
name|int_type
condition|)
block|{
case|case
name|INTENTRY_TYPE_INT
case|:
switch|switch
condition|(
name|busses
index|[
name|intr
operator|->
name|src_bus_id
index|]
operator|.
name|bus_type
condition|)
block|{
case|case
name|NOBUS
case|:
name|panic
argument_list|(
literal|"interrupt from missing bus"
argument_list|)
expr_stmt|;
case|case
name|ISA
case|:
case|case
name|EISA
case|:
if|if
condition|(
name|busses
index|[
name|intr
operator|->
name|src_bus_id
index|]
operator|.
name|bus_type
operator|==
name|ISA
condition|)
name|ioapic_set_bus
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|APIC_BUS_ISA
argument_list|)
expr_stmt|;
else|else
name|ioapic_set_bus
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|APIC_BUS_EISA
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|src_bus_irq
operator|==
name|pin
condition|)
break|break;
name|ioapic_remap_vector
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioapic_get_vector
argument_list|(
name|ioapic
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
operator|==
name|intr
operator|->
name|src_bus_irq
condition|)
name|ioapic_disable_pin
argument_list|(
name|ioapic
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
expr_stmt|;
break|break;
case|case
name|PCI
case|:
name|ioapic_set_bus
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|APIC_BUS_PCI
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ioapic_set_bus
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|APIC_BUS_UNKNOWN
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|INTENTRY_TYPE_NMI
case|:
name|ioapic_set_nmi
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTENTRY_TYPE_SMI
case|:
name|ioapic_set_smi
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTENTRY_TYPE_EXTINT
case|:
name|ioapic_set_extint
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: invalid interrupt entry type %d\n"
argument_list|,
name|__func__
argument_list|,
name|intr
operator|->
name|int_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|intr
operator|->
name|int_type
operator|==
name|INTENTRY_TYPE_INT
operator|||
operator|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_TRIGGER
operator|)
operator|!=
name|INTENTRY_FLAGS_TRIGGER_CONFORM
condition|)
name|ioapic_set_triggermode
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|intentry_trigger
argument_list|(
name|intr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|int_type
operator|==
name|INTENTRY_TYPE_INT
operator|||
operator|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_POLARITY
operator|)
operator|!=
name|INTENTRY_FLAGS_POLARITY_CONFORM
condition|)
name|ioapic_set_polarity
argument_list|(
name|ioapic
argument_list|,
name|pin
argument_list|,
name|intentry_polarity
argument_list|(
name|intr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an interrupt entry for a local APIC LVT pin.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_local_int
parameter_list|(
name|int_entry_ptr
name|intr
parameter_list|)
block|{
name|u_int
name|apic_id
decl_stmt|,
name|pin
decl_stmt|;
if|if
condition|(
name|intr
operator|->
name|dst_apic_id
operator|==
literal|0xff
condition|)
name|apic_id
operator|=
name|APIC_ID_ALL
expr_stmt|;
else|else
name|apic_id
operator|=
name|intr
operator|->
name|dst_apic_id
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|dst_apic_int
operator|==
literal|0
condition|)
name|pin
operator|=
name|LVT_LINT0
expr_stmt|;
else|else
name|pin
operator|=
name|LVT_LINT1
expr_stmt|;
switch|switch
condition|(
name|intr
operator|->
name|int_type
condition|)
block|{
case|case
name|INTENTRY_TYPE_INT
case|:
if|#
directive|if
literal|1
name|printf
argument_list|(
literal|"MPTable: Ignoring vectored local interrupt for LINTIN%d vector %d\n"
argument_list|,
name|intr
operator|->
name|dst_apic_int
argument_list|,
name|intr
operator|->
name|src_bus_irq
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|lapic_set_lvt_mode
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|APIC_LVT_DM_FIXED
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|INTENTRY_TYPE_NMI
case|:
name|lapic_set_lvt_mode
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|APIC_LVT_DM_NMI
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTENTRY_TYPE_SMI
case|:
name|lapic_set_lvt_mode
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|APIC_LVT_DM_SMI
argument_list|)
expr_stmt|;
break|break;
case|case
name|INTENTRY_TYPE_EXTINT
case|:
name|lapic_set_lvt_mode
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|APIC_LVT_DM_EXTINT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: invalid interrupt entry type %d\n"
argument_list|,
name|__func__
argument_list|,
name|intr
operator|->
name|int_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_TRIGGER
operator|)
operator|!=
name|INTENTRY_FLAGS_TRIGGER_CONFORM
condition|)
name|lapic_set_lvt_triggermode
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|intentry_trigger
argument_list|(
name|intr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intr
operator|->
name|int_flags
operator|&
name|INTENTRY_FLAGS_POLARITY
operator|)
operator|!=
name|INTENTRY_FLAGS_POLARITY_CONFORM
condition|)
name|lapic_set_lvt_polarity
argument_list|(
name|apic_id
argument_list|,
name|pin
argument_list|,
name|intentry_polarity
argument_list|(
name|intr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse interrupt entries.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_ints_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int_entry_ptr
name|intr
decl_stmt|;
name|intr
operator|=
operator|(
name|int_entry_ptr
operator|)
name|entry
expr_stmt|;
switch|switch
condition|(
operator|*
name|entry
condition|)
block|{
case|case
name|MPCT_ENTRY_INT
case|:
name|mptable_parse_io_int
argument_list|(
name|intr
argument_list|)
expr_stmt|;
break|break;
case|case
name|MPCT_ENTRY_LOCAL_INT
case|:
name|mptable_parse_local_int
argument_list|(
name|intr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure interrupt pins for a default configuration.  For details see  * Table 5-2 in Section 5 of the MP Table specification.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_default_config_ints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|INTENTRY
name|entry
decl_stmt|;
name|int
name|pin
decl_stmt|;
comment|/* 	 * All default configs route IRQs from bus 0 to the first 16 pins 	 * of the first I/O APIC with an APIC ID of 2. 	 */
name|entry
operator|.
name|type
operator|=
name|MPCT_ENTRY_INT
expr_stmt|;
name|entry
operator|.
name|int_flags
operator|=
name|INTENTRY_FLAGS_POLARITY_CONFORM
operator||
name|INTENTRY_FLAGS_TRIGGER_CONFORM
expr_stmt|;
name|entry
operator|.
name|src_bus_id
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|dst_apic_id
operator|=
literal|2
expr_stmt|;
comment|/* Run through all 16 pins. */
for|for
control|(
name|pin
operator|=
literal|0
init|;
name|pin
operator|<
literal|16
condition|;
name|pin
operator|++
control|)
block|{
name|entry
operator|.
name|dst_apic_int
operator|=
name|pin
expr_stmt|;
switch|switch
condition|(
name|pin
condition|)
block|{
case|case
literal|0
case|:
comment|/* Pin 0 is an ExtINT pin. */
name|entry
operator|.
name|int_type
operator|=
name|INTENTRY_TYPE_EXTINT
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* IRQ 0 is routed to pin 2. */
name|entry
operator|.
name|int_type
operator|=
name|INTENTRY_TYPE_INT
expr_stmt|;
name|entry
operator|.
name|src_bus_irq
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* All other pins are identity mapped. */
name|entry
operator|.
name|int_type
operator|=
name|INTENTRY_TYPE_INT
expr_stmt|;
name|entry
operator|.
name|src_bus_irq
operator|=
name|pin
expr_stmt|;
break|break;
block|}
name|mptable_parse_io_int
argument_list|(
operator|&
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* Certain configs disable certain pins. */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|==
literal|7
condition|)
name|ioapic_disable_pin
argument_list|(
name|ioapics
index|[
literal|2
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|==
literal|2
condition|)
block|{
name|ioapic_disable_pin
argument_list|(
name|ioapics
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ioapic_disable_pin
argument_list|(
name|ioapics
index|[
literal|2
index|]
argument_list|,
literal|13
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure the interrupt pins  */
end_comment

begin_function
specifier|static
name|void
name|mptable_parse_ints
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Is this a pre-defined config? */
if|if
condition|(
name|mpfps
operator|->
name|config_type
operator|!=
literal|0
condition|)
block|{
comment|/* Configure LINT pins. */
name|lapic_set_lvt_mode
argument_list|(
name|APIC_ID_ALL
argument_list|,
name|LVT_LINT0
argument_list|,
name|APIC_LVT_DM_EXTINT
argument_list|)
expr_stmt|;
name|lapic_set_lvt_mode
argument_list|(
name|APIC_ID_ALL
argument_list|,
name|LVT_LINT1
argument_list|,
name|APIC_LVT_DM_NMI
argument_list|)
expr_stmt|;
comment|/* Configure I/O APIC pins. */
name|mptable_parse_default_config_ints
argument_list|()
expr_stmt|;
block|}
else|else
name|mptable_walk_table
argument_list|(
name|mptable_parse_ints_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MPTABLE_FORCE_HTT
end_ifdef

begin_comment
comment|/*  * Perform a hyperthreading "fix-up" to enumerate any logical CPU's  * that aren't already listed in the table.  *  * XXX: We assume that all of the physical CPUs in the  * system have the same number of logical CPUs.  *  * XXX: We assume that APIC ID's are allocated such that  * the APIC ID's for a physical processor are aligned  * with the number of logical CPU's in the processor.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_hyperthread_fixup
parameter_list|(
name|u_int
name|id_mask
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|id
decl_stmt|,
name|logical_cpus
decl_stmt|;
comment|/* Nothing to do if there is no HTT support. */
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|==
literal|0
condition|)
return|return;
name|logical_cpus
operator|=
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|logical_cpus
operator|<=
literal|1
condition|)
return|return;
comment|/* 	 * For each APIC ID of a CPU that is set in the mask, 	 * scan the other candidate APIC ID's for this 	 * physical processor.  If any of those ID's are 	 * already in the table, then kill the fixup. 	 */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|NAPICID
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id_mask
operator|&
literal|1
operator|<<
name|id
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* First, make sure we are on a logical_cpus boundary. */
if|if
condition|(
name|id
operator|%
name|logical_cpus
operator|!=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|id
operator|+
literal|1
init|;
name|i
operator|<
name|id
operator|+
name|logical_cpus
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|id_mask
operator|&
literal|1
operator|<<
name|i
operator|)
operator|!=
literal|0
condition|)
return|return;
block|}
comment|/* 	 * Ok, the ID's checked out, so perform the fixup by 	 * adding the logical CPUs. 	 */
while|while
condition|(
operator|(
name|id
operator|=
name|ffs
argument_list|(
name|id_mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|id
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
name|id
operator|+
literal|1
init|;
name|i
operator|<
name|id
operator|+
name|logical_cpus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MPTable: Adding logical CPU %d from main CPU %d\n"
argument_list|,
name|i
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|lapic_create
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|id_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|id
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MPTABLE_FORCE_HTT */
end_comment

begin_comment
comment|/*  * Support code for routing PCI interrupts using the MP Table.  */
end_comment

begin_function
specifier|static
name|void
name|mptable_pci_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * Find the first pci bus and call it 0.  Panic if pci0 is not 	 * bus zero and there are multiple PCI busses. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mptable_maxbusid
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|busses
index|[
name|i
index|]
operator|.
name|bus_type
operator|==
name|PCI
condition|)
block|{
if|if
condition|(
name|pci0
operator|==
operator|-
literal|1
condition|)
name|pci0
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|pci0
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"MPTable contains multiple PCI busses but no PCI bus 0"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mptable_pci_probe_table_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_probe_table_args
modifier|*
name|args
decl_stmt|;
name|int_entry_ptr
name|intr
decl_stmt|;
if|if
condition|(
operator|*
name|entry
operator|!=
name|MPCT_ENTRY_INT
condition|)
return|return;
name|intr
operator|=
operator|(
name|int_entry_ptr
operator|)
name|entry
expr_stmt|;
name|args
operator|=
operator|(
expr|struct
name|pci_probe_table_args
operator|*
operator|)
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|args
operator|->
name|bus
operator|<=
name|mptable_maxbusid
argument_list|,
operator|(
literal|"bus %d is too big"
operator|,
name|args
operator|->
name|bus
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|busses
index|[
name|args
operator|->
name|bus
index|]
operator|.
name|bus_type
operator|==
name|PCI
argument_list|,
operator|(
literal|"probing for non-PCI bus"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|src_bus_id
operator|==
name|args
operator|->
name|bus
condition|)
name|args
operator|->
name|found
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mptable_pci_probe_table
parameter_list|(
name|int
name|bus
parameter_list|)
block|{
name|struct
name|pci_probe_table_args
name|args
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mpct
operator|==
name|NULL
operator|||
name|pci0
operator|==
operator|-
literal|1
operator|||
name|pci0
operator|+
name|bus
operator|>
name|mptable_maxbusid
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|busses
index|[
name|pci0
operator|+
name|bus
index|]
operator|.
name|bus_type
operator|!=
name|PCI
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|args
operator|.
name|bus
operator|=
name|pci0
operator|+
name|bus
expr_stmt|;
name|args
operator|.
name|found
operator|=
literal|0
expr_stmt|;
name|mptable_walk_table
argument_list|(
name|mptable_pci_probe_table_handler
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|found
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mptable_pci_route_interrupt_handler
parameter_list|(
name|u_char
modifier|*
name|entry
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pci_route_interrupt_args
modifier|*
name|args
decl_stmt|;
name|int_entry_ptr
name|intr
decl_stmt|;
name|int
name|vector
decl_stmt|;
if|if
condition|(
operator|*
name|entry
operator|!=
name|MPCT_ENTRY_INT
condition|)
return|return;
name|intr
operator|=
operator|(
name|int_entry_ptr
operator|)
name|entry
expr_stmt|;
name|args
operator|=
operator|(
expr|struct
name|pci_route_interrupt_args
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|src_bus_id
operator|!=
name|args
operator|->
name|bus
operator|||
name|intr
operator|->
name|src_bus_irq
operator|!=
name|args
operator|->
name|irq
condition|)
return|return;
comment|/* Make sure the APIC maps to a known APIC. */
name|KASSERT
argument_list|(
name|ioapics
index|[
name|intr
operator|->
name|dst_apic_id
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No I/O APIC %d to route interrupt to"
operator|,
name|intr
operator|->
name|dst_apic_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the vector for this APIC / pin combination.  If we 	 * have previously matched an entry for this PCI IRQ but it 	 * has the same vector as this entry, just return.  Otherwise, 	 * we use the vector for this APIC / pin combination. 	 */
name|vector
operator|=
name|ioapic_get_vector
argument_list|(
name|ioapics
index|[
name|intr
operator|->
name|dst_apic_id
index|]
argument_list|,
name|intr
operator|->
name|dst_apic_int
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|vector
operator|==
name|vector
condition|)
return|return;
name|KASSERT
argument_list|(
name|args
operator|->
name|vector
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"Multiple IRQs for PCI interrupt %d.%d.INT%c: %d and %d\n"
operator|,
name|args
operator|->
name|bus
operator|,
name|args
operator|->
name|irq
operator|>>
literal|2
operator|,
literal|'A'
operator|+
operator|(
name|args
operator|->
name|irq
operator|&
literal|0x3
operator|)
operator|,
name|args
operator|->
name|vector
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|vector
operator|=
name|vector
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mptable_pci_route_interrupt
parameter_list|(
name|device_t
name|pcib
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|struct
name|pci_route_interrupt_args
name|args
decl_stmt|;
name|int
name|slot
decl_stmt|;
comment|/* Like ACPI, pin numbers are 0-3, not 1-4. */
name|pin
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|pci0
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"do not know how to route PCI interrupts"
operator|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|+
name|pci0
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * PCI interrupt entries in the MP Table encode both the slot and 	 * pin into the IRQ with the pin being the two least significant 	 * bits, the slot being the next five bits, and the most significant 	 * bit being reserved. 	 */
name|args
operator|.
name|irq
operator|=
name|slot
operator|<<
literal|2
operator||
name|pin
expr_stmt|;
name|args
operator|.
name|vector
operator|=
operator|-
literal|1
expr_stmt|;
name|mptable_walk_table
argument_list|(
name|mptable_pci_route_interrupt_handler
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|vector
operator|<
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"unable to route slot %d INT%c\n"
argument_list|,
name|slot
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|pcib
argument_list|,
literal|"slot %d INT%c routed to irq %d\n"
argument_list|,
name|slot
argument_list|,
literal|'A'
operator|+
name|pin
argument_list|,
name|args
operator|.
name|vector
argument_list|)
expr_stmt|;
return|return
operator|(
name|args
operator|.
name|vector
operator|)
return|;
block|}
end_function

end_unit

