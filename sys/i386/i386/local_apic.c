begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 John Baldwin<jhb@FreeBSD.org>  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Local APIC support on Pentium and later processors.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Sanity checks on IDT vectors. */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
operator|==
name|APIC_TIMER_INT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_TIMER_INT
operator|<
name|APIC_LOCAL_INTS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_LOCAL_INTS
operator|==
literal|240
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|IPI_STOP
operator|<
name|APIC_SPURIOUS_INT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LAPIC_TIMER_HZ_DIVIDER
value|2
end_define

begin_define
define|#
directive|define
name|LAPIC_TIMER_STATHZ_DIVIDER
value|15
end_define

begin_define
define|#
directive|define
name|LAPIC_TIMER_PROFHZ_DIVIDER
value|3
end_define

begin_comment
comment|/* Magic IRQ values for the timer and syscalls. */
end_comment

begin_define
define|#
directive|define
name|IRQ_TIMER
value|(NUM_IO_INTS + 1)
end_define

begin_define
define|#
directive|define
name|IRQ_SYSCALL
value|(NUM_IO_INTS + 2)
end_define

begin_comment
comment|/*  * Support for local APICs.  Local APICs manage interrupts on each  * individual processor as opposed to I/O APICs which receive interrupts  * from I/O devices and then forward them on to the local APICs.  *  * Local APICs can also send interrupts to each other thus providing the  * mechanism for IPIs.  */
end_comment

begin_struct
struct|struct
name|lvt
block|{
name|u_int
name|lvt_edgetrigger
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_activehi
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_masked
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_active
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_mode
range|:
literal|16
decl_stmt|;
name|u_int
name|lvt_vector
range|:
literal|8
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lapic
block|{
name|struct
name|lvt
name|la_lvts
index|[
name|LVT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|la_id
range|:
literal|8
decl_stmt|;
name|u_int
name|la_cluster
range|:
literal|4
decl_stmt|;
name|u_int
name|la_cluster_id
range|:
literal|2
decl_stmt|;
name|u_int
name|la_present
range|:
literal|1
decl_stmt|;
name|u_long
modifier|*
name|la_timer_count
decl_stmt|;
name|u_long
name|la_hard_ticks
decl_stmt|;
name|u_long
name|la_stat_ticks
decl_stmt|;
name|u_long
name|la_prof_ticks
decl_stmt|;
block|}
decl|static
name|lapics
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/* XXX: should thermal be an NMI? */
end_comment

begin_comment
comment|/* Global defaults for local APIC LVT entries. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lvt
name|lvts
index|[
name|LVT_MAX
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_EXTINT
block|,
literal|0
block|}
block|,
comment|/* LINT0: masked ExtINT */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|APIC_LVT_DM_NMI
block|,
literal|0
block|}
block|,
comment|/* LINT1: NMI */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_TIMER_INT
block|}
block|,
comment|/* Timer */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_ERROR_INT
block|}
block|,
comment|/* Error */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|APIC_LVT_DM_NMI
block|,
literal|0
block|}
block|,
comment|/* PMC */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_THERMAL_INT
block|}
block|,
comment|/* Thermal */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inthand_t
modifier|*
name|ioint_handlers
index|[]
init|=
block|{
name|NULL
block|,
comment|/* 0 - 31 */
name|IDTVEC
argument_list|(
name|apic_isr1
argument_list|)
block|,
comment|/* 32 - 63 */
name|IDTVEC
argument_list|(
name|apic_isr2
argument_list|)
block|,
comment|/* 64 - 95 */
name|IDTVEC
argument_list|(
name|apic_isr3
argument_list|)
block|,
comment|/* 96 - 127 */
name|IDTVEC
argument_list|(
name|apic_isr4
argument_list|)
block|,
comment|/* 128 - 159 */
name|IDTVEC
argument_list|(
name|apic_isr5
argument_list|)
block|,
comment|/* 160 - 191 */
name|IDTVEC
argument_list|(
name|apic_isr6
argument_list|)
block|,
comment|/* 192 - 223 */
name|IDTVEC
argument_list|(
name|apic_isr7
argument_list|)
block|,
comment|/* 224 - 255 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Include IDT_SYSCALL to make indexing easier. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|ioint_irqs
index|[
name|APIC_NUM_IOINTS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|lapic_timer_divisors
index|[]
init|=
block|{
name|APIC_TDCR_1
block|,
name|APIC_TDCR_2
block|,
name|APIC_TDCR_4
block|,
name|APIC_TDCR_8
block|,
name|APIC_TDCR_16
block|,
name|APIC_TDCR_32
block|,
name|APIC_TDCR_64
block|,
name|APIC_TDCR_128
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|inthand_t
name|IDTVEC
parameter_list|(
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|volatile
name|lapic_t
modifier|*
name|lapic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|lapic_paddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|lapic_timer_divisor
decl_stmt|,
name|lapic_timer_period
decl_stmt|,
name|lapic_timer_hz
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|lapic_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_enable_intr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_oneshot
parameter_list|(
name|u_int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_periodic
parameter_list|(
name|u_int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_set_divisor
parameter_list|(
name|u_int
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|lvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pic
name|lapic_pic
init|=
block|{
operator|.
name|pic_resume
operator|=
name|lapic_resume
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|lvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|<=
name|LVT_MAX
argument_list|,
operator|(
literal|"%s: pin %u out of range"
operator|,
name|__func__
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
condition|)
name|lvt
operator|=
operator|&
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
else|else
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_LVT_M
operator||
name|APIC_LVT_TM
operator||
name|APIC_LVT_IIPP
operator||
name|APIC_LVT_DM
operator||
name|APIC_LVT_VECTOR
operator|)
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_edgetrigger
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_TM
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_activehi
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_IIPP_INTALO
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_masked
condition|)
name|value
operator||=
name|APIC_LVT_M
expr_stmt|;
name|value
operator||=
name|lvt
operator|->
name|lvt_mode
expr_stmt|;
switch|switch
condition|(
name|lvt
operator|->
name|lvt_mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
if|if
condition|(
operator|!
name|lvt
operator|->
name|lvt_edgetrigger
condition|)
block|{
name|printf
argument_list|(
literal|"lapic%u: Forcing LINT%u to edge trigger\n"
argument_list|,
name|la
operator|->
name|la_id
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|value
operator||=
name|APIC_LVT_TM
expr_stmt|;
block|}
comment|/* Use a vector of 0. */
break|break;
case|case
name|APIC_LVT_DM_FIXED
case|:
name|value
operator||=
name|lvt
operator|->
name|lvt_vector
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad APIC LVT delivery mode: %#x\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the local APIC and setup necessary interrupt vectors.  */
end_comment

begin_function
name|void
name|lapic_init
parameter_list|(
name|vm_paddr_t
name|addr
parameter_list|)
block|{
comment|/* Map the local APIC and setup the spurious interrupt handler. */
name|KASSERT
argument_list|(
name|trunc_page
argument_list|(
name|addr
argument_list|)
operator|==
name|addr
argument_list|,
operator|(
literal|"local APIC not aligned on a page boundary"
operator|)
argument_list|)
expr_stmt|;
name|lapic
operator|=
name|pmap_mapdev
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|lapic_t
argument_list|)
argument_list|)
expr_stmt|;
name|lapic_paddr
operator|=
name|addr
expr_stmt|;
name|setidt
argument_list|(
name|APIC_SPURIOUS_INT
argument_list|,
name|IDTVEC
argument_list|(
name|spuriousint
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Perform basic initialization of the BSP's local APIC. */
name|lapic_enable
argument_list|()
expr_stmt|;
name|ioint_irqs
index|[
name|IDT_SYSCALL
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_SYSCALL
expr_stmt|;
comment|/* Set BSP's per-CPU local APIC ID. */
name|PCPU_SET
argument_list|(
name|apic_id
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Local APIC timer interrupt. */
name|setidt
argument_list|(
name|APIC_TIMER_INT
argument_list|,
name|IDTVEC
argument_list|(
name|timerint
argument_list|)
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|ioint_irqs
index|[
name|APIC_TIMER_INT
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_TIMER
expr_stmt|;
comment|/* XXX: error/thermal interrupts */
block|}
end_function

begin_comment
comment|/*  * Create a local APIC instance.  */
end_comment

begin_function
name|void
name|lapic_create
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|int
name|boot_cpu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|apic_id
operator|>
name|MAX_APIC_ID
condition|)
block|{
name|printf
argument_list|(
literal|"APIC: Ignoring local APIC with ID %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
name|panic
argument_list|(
literal|"Can't ignore BSP"
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|!
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"duplicate local APIC %u"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Assume no local LVT overrides and a cluster of 0 and 	 * intra-cluster ID of 0. 	 */
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_id
operator|=
name|apic_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LVT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|=
name|lvts
index|[
name|i
index|]
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|.
name|lvt_active
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMP
name|cpu_add
argument_list|(
name|apic_id
argument_list|,
name|boot_cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Dump contents of local APIC registers  */
end_comment

begin_function
name|void
name|lapic_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|printf
argument_list|(
literal|"cpu%d %s:\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     ID: 0x%08x   VER: 0x%08x LDR: 0x%08x DFR: 0x%08x\n"
argument_list|,
name|lapic
operator|->
name|id
argument_list|,
name|lapic
operator|->
name|version
argument_list|,
name|lapic
operator|->
name|ldr
argument_list|,
name|lapic
operator|->
name|dfr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  lint0: 0x%08x lint1: 0x%08x TPR: 0x%08x SVR: 0x%08x\n"
argument_list|,
name|lapic
operator|->
name|lvt_lint0
argument_list|,
name|lapic
operator|->
name|lvt_lint1
argument_list|,
name|lapic
operator|->
name|tpr
argument_list|,
name|lapic
operator|->
name|svr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  timer: 0x%08x therm: 0x%08x err: 0x%08x pcm: 0x%08x\n"
argument_list|,
name|lapic
operator|->
name|lvt_timer
argument_list|,
name|lapic
operator|->
name|lvt_thermal
argument_list|,
name|lapic
operator|->
name|lvt_error
argument_list|,
name|lapic
operator|->
name|lvt_pcint
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_setup
parameter_list|(
name|int
name|boot
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|u_int32_t
name|maxlvt
decl_stmt|;
name|register_t
name|eflags
decl_stmt|;
name|char
name|buf
index|[
name|MAXCOMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|lapic_id
argument_list|()
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|la
operator|->
name|la_present
argument_list|,
operator|(
literal|"missing APIC structure"
operator|)
argument_list|)
expr_stmt|;
name|eflags
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|maxlvt
operator|=
operator|(
name|lapic
operator|->
name|version
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
comment|/* Initialize the TPR to allow all interrupts. */
name|lapic_set_tpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup spurious vector and enable the local APIC. */
name|lapic_enable
argument_list|()
expr_stmt|;
comment|/* Program LINT[01] LVT entries. */
name|lapic
operator|->
name|lvt_lint0
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_LINT0
argument_list|,
name|lapic
operator|->
name|lvt_lint0
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|lvt_lint1
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_LINT1
argument_list|,
name|lapic
operator|->
name|lvt_lint1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
comment|/* Program the PMC LVT entry if present. */
if|if
condition|(
name|maxlvt
operator|>=
name|LVT_PMC
condition|)
name|lapic
operator|->
name|lvt_pcint
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_PMC
argument_list|,
name|lapic
operator|->
name|lvt_pcint
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Program timer LVT and setup handler. */
name|lapic
operator|->
name|lvt_timer
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|LVT_TIMER
argument_list|,
name|lapic
operator|->
name|lvt_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d: timer"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|la
operator|->
name|la_timer_count
argument_list|)
expr_stmt|;
block|}
comment|/* We don't setup the timer during boot on the BSP until later. */
if|if
condition|(
operator|!
operator|(
name|boot
operator|&&
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|lapic_timer_period
operator|!=
literal|0
argument_list|,
operator|(
literal|"lapic%u: zero divisor"
operator|,
name|lapic_id
argument_list|()
operator|)
argument_list|)
expr_stmt|;
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|lapic_timer_periodic
argument_list|(
name|lapic_timer_period
argument_list|)
expr_stmt|;
name|lapic_timer_enable_intr
argument_list|()
expr_stmt|;
block|}
comment|/* XXX: Error and thermal LVTs */
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"AuthenticAMD"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Detect the presence of C1E capability mostly on latest 		 * dual-cores (or future) k8 family.  This feature renders 		 * the local APIC timer dead, so we disable it by reading 		 * the Interrupt Pending Message register and clearing both 		 * C1eOnCmpHalt (bit 28) and SmiOnCmpHalt (bit 27). 		 *  		 * Reference: 		 *   "BIOS and Kernel Developer's Guide for AMD NPT 		 *    Family 0Fh Processors" 		 *   #32559 revision 3.00 		 */
if|if
condition|(
operator|(
name|cpu_id
operator|&
literal|0x00000f00
operator|)
operator|==
literal|0x00000f00
operator|&&
operator|(
name|cpu_id
operator|&
literal|0x0fff0000
operator|)
operator|>=
literal|0x00040000
condition|)
block|{
name|uint64_t
name|msr
decl_stmt|;
name|msr
operator|=
name|rdmsr
argument_list|(
literal|0xc0010055
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|&
literal|0x18000000
condition|)
name|wrmsr
argument_list|(
literal|0xc0010055
argument_list|,
name|msr
operator|&
operator|~
literal|0x18000000ULL
argument_list|)
expr_stmt|;
block|}
block|}
name|intr_restore
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called by cpu_initclocks() on the BSP to setup the local APIC timer so  * that it can drive hardclock, statclock, and profclock.  This function  * returns true if it is able to use the local APIC timer to drive the  * clocks and false if it is not able.  */
end_comment

begin_function
name|int
name|lapic_setup_clock
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|value
decl_stmt|;
comment|/* Can't drive the timer without a local APIC. */
if|if
condition|(
name|lapic
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Start off with a divisor of 2 (power on reset default). */
name|lapic_timer_divisor
operator|=
literal|2
expr_stmt|;
comment|/* Try to calibrate the local APIC timer. */
do|do
block|{
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|lapic_timer_oneshot
argument_list|(
name|APIC_TIMER_MAX_COUNT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|2000000
argument_list|)
expr_stmt|;
name|value
operator|=
name|APIC_TIMER_MAX_COUNT
operator|-
name|lapic
operator|->
name|ccr_timer
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|APIC_TIMER_MAX_COUNT
condition|)
break|break;
name|lapic_timer_divisor
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lapic_timer_divisor
operator|<=
literal|128
condition|)
do|;
if|if
condition|(
name|lapic_timer_divisor
operator|>
literal|128
condition|)
name|panic
argument_list|(
literal|"lapic: Divisor too big"
argument_list|)
expr_stmt|;
name|value
operator|/=
literal|2
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic: Divisor %lu, Frequency %lu hz\n"
argument_list|,
name|lapic_timer_divisor
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* 	 * We will drive the timer at a small multiple of hz and drive 	 * both of the other timers with similarly small but relatively 	 * prime divisors. 	 */
name|lapic_timer_hz
operator|=
name|hz
operator|*
name|LAPIC_TIMER_HZ_DIVIDER
expr_stmt|;
name|stathz
operator|=
name|lapic_timer_hz
operator|/
name|LAPIC_TIMER_STATHZ_DIVIDER
expr_stmt|;
name|profhz
operator|=
name|lapic_timer_hz
operator|/
name|LAPIC_TIMER_PROFHZ_DIVIDER
expr_stmt|;
name|lapic_timer_period
operator|=
name|value
operator|/
name|lapic_timer_hz
expr_stmt|;
comment|/* 	 * Start up the timer on the BSP.  The APs will kick off their 	 * timer during lapic_setup(). 	 */
name|lapic_timer_periodic
argument_list|(
name|lapic_timer_period
argument_list|)
expr_stmt|;
name|lapic_timer_enable_intr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
comment|/* Software disable the local APIC. */
name|value
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_SVR_SWEN
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
comment|/* Program the spurious vector to enable the local APIC. */
name|value
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_SVR_VECTOR
operator||
name|APIC_SVR_FOCUS
operator|)
expr_stmt|;
name|value
operator||=
operator|(
name|APIC_SVR_FEN
operator||
name|APIC_SVR_SWEN
operator||
name|APIC_SPURIOUS_INT
operator|)
expr_stmt|;
name|lapic
operator|->
name|svr
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the local APIC on the BSP during resume. */
end_comment

begin_function
specifier|static
name|void
name|lapic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|)
block|{
name|lapic_setup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lapic_id
parameter_list|(
name|void
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|lapic
operator|!=
name|NULL
argument_list|,
operator|(
literal|"local APIC is not mapped"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lapic
operator|->
name|id
operator|>>
name|APIC_ID_SHIFT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_intr_pending
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
specifier|volatile
name|u_int32_t
modifier|*
name|irr
decl_stmt|;
comment|/* 	 * The IRR registers are an array of 128-bit registers each of 	 * which only describes 32 interrupts in the low 32 bits..  Thus, 	 * we divide the vector by 32 to get the 128-bit index.  We then 	 * multiply that index by 4 to get the equivalent index from 	 * treating the IRR as an array of 32-bit registers.  Finally, we 	 * modulus the vector by 32 to determine the individual bit to 	 * test. 	 */
name|irr
operator|=
operator|&
name|lapic
operator|->
name|irr0
expr_stmt|;
return|return
operator|(
name|irr
index|[
operator|(
name|vector
operator|/
literal|32
operator|)
operator|*
literal|4
index|]
operator|&
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_set_logical_id
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|cluster
parameter_list|,
name|u_int
name|cluster_id
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: APIC %u doesn't exist"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster
operator|<=
name|APIC_MAX_CLUSTER
argument_list|,
operator|(
literal|"%s: cluster %u too big"
operator|,
name|__func__
operator|,
name|cluster
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster_id
operator|<=
name|APIC_MAX_INTRACLUSTER_ID
argument_list|,
operator|(
literal|"%s: intra cluster id %u too big"
operator|,
name|__func__
operator|,
name|cluster_id
operator|)
argument_list|)
expr_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
expr_stmt|;
name|la
operator|->
name|la_cluster
operator|=
name|cluster
expr_stmt|;
name|la
operator|->
name|la_cluster_id
operator|=
name|cluster_id
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_mask
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_char
name|masked
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u %s\n"
argument_list|,
name|pin
argument_list|,
name|masked
condition|?
literal|"masked"
else|:
literal|"unmasked"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_mode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lvt
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
name|lvt
operator|->
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
name|lvt
operator|->
name|lvt_mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|lvt
operator|->
name|lvt_edgetrigger
operator|=
literal|1
expr_stmt|;
name|lvt
operator|->
name|lvt_activehi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_LVT_DM_EXTINT
condition|)
name|lvt
operator|->
name|lvt_masked
operator|=
literal|1
expr_stmt|;
else|else
name|lvt
operator|->
name|lvt_masked
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unsupported delivery mode: 0x%x\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" Routing "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
name|printf
argument_list|(
literal|"NMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_SMI
case|:
name|printf
argument_list|(
literal|"SMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_INIT
case|:
name|printf
argument_list|(
literal|"INIT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|printf
argument_list|(
literal|"ExtINT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" -> LINT%u\n"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_polarity
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
operator|||
name|pol
operator|==
name|INTR_POLARITY_CONFORM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
operator|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
operator|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u polarity: %s\n"
argument_list|,
name|pin
argument_list|,
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|?
literal|"high"
else|:
literal|"low"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lapic_set_lvt_triggermode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|enum
name|intr_trigger
name|trigger
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|LVT_MAX
operator|||
name|trigger
operator|==
name|INTR_TRIGGER_CONFORM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
operator|(
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
operator|(
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
operator|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u trigger: %s\n"
argument_list|,
name|pin
argument_list|,
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
condition|?
literal|"edge"
else|:
literal|"level"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust the TPR of the current CPU so that it blocks all interrupts below  * the passed in vector.  */
end_comment

begin_function
name|void
name|lapic_set_tpr
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHEAP_TPR
name|lapic
operator|->
name|tpr
operator|=
name|vector
expr_stmt|;
else|#
directive|else
name|u_int32_t
name|tpr
decl_stmt|;
name|tpr
operator|=
name|lapic
operator|->
name|tpr
operator|&
operator|~
name|APIC_TPR_PRIO
expr_stmt|;
name|tpr
operator||=
name|vector
expr_stmt|;
name|lapic
operator|->
name|tpr
operator|=
name|tpr
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|lapic_eoi
parameter_list|(
name|void
parameter_list|)
block|{
name|lapic
operator|->
name|eoi
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_handle_intr
parameter_list|(
name|int
name|vector
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
if|if
condition|(
name|vector
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"Couldn't get vector from ISR!"
argument_list|)
expr_stmt|;
name|isrc
operator|=
name|intr_lookup_source
argument_list|(
name|apic_idt_to_irq
argument_list|(
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|intr_execute_handlers
argument_list|(
name|isrc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_handle_timer
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
comment|/* Send EOI first thing. */
name|lapic_eoi
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCHED_ULE
argument_list|)
comment|/* 	 * Don't do any accounting for the disabled HTT cores, since it 	 * will provide misleading numbers for the userland. 	 * 	 * No locking is necessary here, since even if we loose the race 	 * when hlt_cpus_mask changes it is not a big deal, really. 	 * 	 * Don't do that for ULE, since ULE doesn't consider hlt_cpus_mask 	 * and unlike other schedulers it actually schedules threads to 	 * those CPUs. 	 */
if|if
condition|(
operator|(
name|hlt_cpus_mask
operator|&
operator|(
literal|1
operator|<<
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return;
endif|#
directive|endif
comment|/* Look up our local APIC structure for the tick counters. */
name|la
operator|=
operator|&
name|lapics
index|[
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
index|]
expr_stmt|;
operator|(
operator|*
name|la
operator|->
name|la_timer_count
operator|)
operator|++
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Fire hardclock at hz. */
name|la
operator|->
name|la_hard_ticks
operator|+=
name|hz
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_hard_ticks
operator|>=
name|lapic_timer_hz
condition|)
block|{
name|la
operator|->
name|la_hard_ticks
operator|-=
name|lapic_timer_hz
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
literal|0
condition|)
name|hardclock
argument_list|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
argument_list|,
name|TRAPF_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hardclock_cpu
argument_list|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fire statclock at stathz. */
name|la
operator|->
name|la_stat_ticks
operator|+=
name|stathz
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_stat_ticks
operator|>=
name|lapic_timer_hz
condition|)
block|{
name|la
operator|->
name|la_stat_ticks
operator|-=
name|lapic_timer_hz
expr_stmt|;
name|statclock
argument_list|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fire profclock at profhz, but only when needed. */
name|la
operator|->
name|la_prof_ticks
operator|+=
name|profhz
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_prof_ticks
operator|>=
name|lapic_timer_hz
condition|)
block|{
name|la
operator|->
name|la_prof_ticks
operator|-=
name|lapic_timer_hz
expr_stmt|;
if|if
condition|(
name|profprocs
operator|!=
literal|0
condition|)
name|profclock
argument_list|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
argument_list|,
name|TRAPF_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_set_divisor
parameter_list|(
name|u_int
name|divisor
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|divisor
argument_list|)
argument_list|,
operator|(
literal|"lapic: invalid divisor %u"
operator|,
name|divisor
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ffs
argument_list|(
name|divisor
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|lapic_timer_divisors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
operator|(
literal|"lapic: invalid divisor %u"
operator|,
name|divisor
operator|)
argument_list|)
expr_stmt|;
name|lapic
operator|->
name|dcr_timer
operator|=
name|lapic_timer_divisors
index|[
name|ffs
argument_list|(
name|divisor
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_oneshot
parameter_list|(
name|u_int
name|count
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|value
operator|=
name|lapic
operator|->
name|lvt_timer
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVTT_TM
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_ONE_SHOT
expr_stmt|;
name|lapic
operator|->
name|lvt_timer
operator|=
name|value
expr_stmt|;
name|lapic
operator|->
name|icr_timer
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_periodic
parameter_list|(
name|u_int
name|count
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|value
operator|=
name|lapic
operator|->
name|lvt_timer
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVTT_TM
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_PERIODIC
expr_stmt|;
name|lapic
operator|->
name|lvt_timer
operator|=
name|value
expr_stmt|;
name|lapic
operator|->
name|icr_timer
operator|=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_enable_intr
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int32_t
name|value
decl_stmt|;
name|value
operator|=
name|lapic
operator|->
name|lvt_timer
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVT_M
expr_stmt|;
name|lapic
operator|->
name|lvt_timer
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Request a free IDT vector to be used by the specified IRQ. */
end_comment

begin_function
name|u_int
name|apic_alloc_vector
parameter_list|(
name|u_int
name|irq
parameter_list|)
block|{
name|u_int
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|irq
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search for a free vector.  Currently we just use a very simple 	 * algorithm to find the first free vector. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|APIC_NUM_IOINTS
condition|;
name|vector
operator|++
control|)
block|{
if|if
condition|(
name|ioint_irqs
index|[
name|vector
index|]
operator|!=
literal|0
condition|)
continue|continue;
name|ioint_irqs
index|[
name|vector
index|]
operator|=
name|irq
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|vector
operator|+
name|APIC_IO_INTS
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Couldn't find an APIC vector for IRQ %u"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Request 'count' free contiguous IDT vectors to be used by 'count'  * IRQs.  'count' must be a power of two and the vectors will be  * aligned on a boundary of 'align'.  If the request cannot be  * satisfied, 0 is returned.  */
end_comment

begin_function
name|u_int
name|apic_alloc_vectors
parameter_list|(
name|u_int
modifier|*
name|irqs
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|align
parameter_list|)
block|{
name|u_int
name|first
decl_stmt|,
name|run
decl_stmt|,
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|count
argument_list|)
argument_list|,
operator|(
literal|"bad count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|align
argument_list|)
argument_list|,
operator|(
literal|"bad align"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|align
operator|>=
name|count
argument_list|,
operator|(
literal|"align< count"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|run
operator|=
literal|0
init|;
name|run
operator|<
name|count
condition|;
name|run
operator|++
control|)
name|KASSERT
argument_list|(
name|irqs
index|[
name|run
index|]
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u at index %u"
operator|,
name|irqs
index|[
name|run
index|]
operator|,
name|run
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Search for 'count' free vectors.  As with apic_alloc_vector(), 	 * this just uses a simple first fit algorithm. 	 */
name|run
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|APIC_NUM_IOINTS
condition|;
name|vector
operator|++
control|)
block|{
comment|/* Vector is in use, end run. */
if|if
condition|(
name|ioint_irqs
index|[
name|vector
index|]
operator|!=
literal|0
condition|)
block|{
name|run
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Start a new run if run == 0 and vector is aligned. */
if|if
condition|(
name|run
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vector
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|first
operator|=
name|vector
expr_stmt|;
block|}
name|run
operator|++
expr_stmt|;
comment|/* Keep looping if the run isn't long enough yet. */
if|if
condition|(
name|run
operator|<
name|count
condition|)
continue|continue;
comment|/* Found a run, assign IRQs and return the first vector. */
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|count
condition|;
name|vector
operator|++
control|)
name|ioint_irqs
index|[
name|first
operator|+
name|vector
index|]
operator|=
name|irqs
index|[
name|vector
index|]
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|+
name|APIC_IO_INTS
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"APIC: Couldn't find APIC vectors for %u IRQs\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|apic_enable_vector
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_SYSCALL
argument_list|,
operator|(
literal|"Attempt to overwrite syscall entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No ISR handler for vector %u"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|vector
argument_list|,
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
argument_list|,
name|SDT_SYS386IGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|apic_disable_vector
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_SYSCALL
argument_list|,
operator|(
literal|"Attempt to overwrite syscall entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No ISR handler for vector %u"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|vector
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release an APIC vector when it's no longer in use. */
end_comment

begin_function
name|void
name|apic_free_vector
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|>=
name|APIC_IO_INTS
operator|&&
name|vector
operator|!=
name|IDT_SYSCALL
operator|&&
name|vector
operator|<=
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
argument_list|,
operator|(
literal|"Vector %u does not map to an IRQ line"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|irq
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
operator|==
name|irq
argument_list|,
operator|(
literal|"IRQ mismatch"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
operator|=
literal|0
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Map an IDT vector (APIC) to an IRQ (interrupt source). */
end_comment

begin_function
name|u_int
name|apic_idt_to_irq
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|>=
name|APIC_IO_INTS
operator|&&
name|vector
operator|!=
name|IDT_SYSCALL
operator|&&
name|vector
operator|<=
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
argument_list|,
operator|(
literal|"Vector %u does not map to an IRQ line"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * Dump data about APIC IDT vector mappings.  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|apic
argument_list|,
argument|db_show_apic
argument_list|)
end_macro

begin_block
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|verbose
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|modif
argument_list|,
literal|"vv"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|modif
argument_list|,
literal|"v"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
else|else
name|verbose
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|APIC_NUM_IOINTS
operator|+
literal|1
operator|&&
operator|!
name|db_pager_quit
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
name|ioint_irqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|!=
literal|0
operator|&&
name|irq
operator|!=
name|IRQ_SYSCALL
condition|)
block|{
name|db_printf
argument_list|(
literal|"vec 0x%2x -> "
argument_list|,
name|i
operator|+
name|APIC_IO_INTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|IRQ_TIMER
condition|)
name|db_printf
argument_list|(
literal|"lapic timer\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|irq
operator|<
name|NUM_IO_INTS
condition|)
block|{
name|isrc
operator|=
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
name|NULL
operator|||
name|verbose
operator|==
literal|0
condition|)
name|db_printf
argument_list|(
literal|"IRQ %u\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|db_dump_intr_event
argument_list|(
name|isrc
operator|->
name|is_event
argument_list|,
name|verbose
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"IRQ %u ???\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|dump_mask
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|uint32_t
name|v
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s:"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" %02x"
argument_list|,
name|base
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show info from the lapic regs for this CPU. */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|lapic
argument_list|,
argument|db_show_lapic
argument_list|)
end_macro

begin_block
block|{
name|uint32_t
name|v
decl_stmt|;
name|db_printf
argument_list|(
literal|"lapic ID = %d\n"
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|lapic
operator|->
name|version
expr_stmt|;
name|db_printf
argument_list|(
literal|"version  = %d.%d\n"
argument_list|,
operator|(
name|v
operator|&
name|APIC_VER_VERSION
operator|)
operator|>>
literal|4
argument_list|,
name|v
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"max LVT  = %d\n"
argument_list|,
operator|(
name|v
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
argument_list|)
expr_stmt|;
name|v
operator|=
name|lapic
operator|->
name|svr
expr_stmt|;
name|db_printf
argument_list|(
literal|"SVR      = %02x (%s)\n"
argument_list|,
name|v
operator|&
name|APIC_SVR_VECTOR
argument_list|,
name|v
operator|&
name|APIC_SVR_ENABLE
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"TPR      = %02x\n"
argument_list|,
name|lapic
operator|->
name|tpr
argument_list|)
expr_stmt|;
define|#
directive|define
name|dump_field
parameter_list|(
name|prefix
parameter_list|,
name|index
parameter_list|)
define|\
value|dump_mask(__XSTRING(prefix ## index), lapic->prefix ## index,	\ 	    index * 32)
name|db_printf
argument_list|(
literal|"In-service Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"TMR Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"IRR Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dump_field
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * APIC probing support code.  This includes code to manage enumerators.  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|apic_enumerator
argument_list|)
name|enumerators
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|enumerators
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|apic_enumerator
modifier|*
name|best_enum
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|apic_register_enumerator
parameter_list|(
name|struct
name|apic_enumerator
modifier|*
name|enumerator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|apic_enumerator
modifier|*
name|apic_enum
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|apic_enum
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
if|if
condition|(
name|apic_enum
operator|==
name|enumerator
condition|)
name|panic
argument_list|(
literal|"%s: Duplicate register of %s"
argument_list|,
name|__func__
argument_list|,
name|enumerator
operator|->
name|apic_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|enumerators
argument_list|,
name|enumerator
argument_list|,
name|apic_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe the APIC enumerators, enumerate CPUs, and initialize the  * local APIC.  */
end_comment

begin_function
specifier|static
name|void
name|apic_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|apic_enumerator
modifier|*
name|enumerator
decl_stmt|;
name|uint64_t
name|apic_base
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|best
decl_stmt|;
comment|/* We only support built in local APICs. */
if|if
condition|(
operator|!
operator|(
name|cpu_feature
operator|&
name|CPUID_APIC
operator|)
condition|)
return|return;
comment|/* Don't probe if APIC mode is disabled. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"apic"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* First, probe all the enumerators to find the best match. */
name|best_enum
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|enumerator
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
name|retval
operator|=
name|enumerator
operator|->
name|apic_probe
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|best_enum
operator|==
name|NULL
operator|||
name|best
operator|<
name|retval
condition|)
block|{
name|best_enum
operator|=
name|enumerator
expr_stmt|;
name|best
operator|=
name|retval
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Could not find any APICs.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Using the %s enumerator.\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|)
expr_stmt|;
comment|/* 	 * To work around an errata, we disable the local APIC on some 	 * CPUs during early startup.  We need to turn the local APIC back 	 * on on such CPUs now. 	 */
if|if
condition|(
name|cpu
operator|==
name|CPU_686
operator|&&
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|cpu_id
operator|&
literal|0xff0
operator|)
operator|==
literal|0x610
condition|)
block|{
name|apic_base
operator|=
name|rdmsr
argument_list|(
name|MSR_APICBASE
argument_list|)
expr_stmt|;
name|apic_base
operator||=
name|APICBASE_ENABLED
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_APICBASE
argument_list|,
name|apic_base
argument_list|)
expr_stmt|;
block|}
comment|/* Second, probe the CPU's in the system. */
name|retval
operator|=
name|best_enum
operator|->
name|apic_probe_cpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to probe CPUs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* Third, initialize the local APIC. */
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_local
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup the local APIC: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apic_init
argument_list|,
argument|SI_SUB_CPU
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|apic_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Setup the I/O APICs.  */
end_comment

begin_function
specifier|static
name|void
name|apic_setup_io
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
return|return;
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup I/O APICs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* 	 * Finish setting up the local APIC on the BSP once we know how to 	 * properly program the LINT pins. 	 */
name|lapic_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|intr_register_pic
argument_list|(
operator|&
name|lapic_pic
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|lapic_dump
argument_list|(
literal|"BSP"
argument_list|)
expr_stmt|;
comment|/* Enable the MSI "pic". */
name|msi_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|apic_setup_io
argument_list|,
argument|SI_SUB_INTR
argument_list|,
argument|SI_ORDER_SECOND
argument_list|,
argument|apic_setup_io
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * Inter Processor Interrupt functions.  The lapic_ipi_*() functions are  * private to the sys/i386 code.  The public interface for the rest of the  * kernel is defined in mp_machdep.c.  */
end_comment

begin_function
name|int
name|lapic_ipi_wait
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
name|int
name|x
decl_stmt|,
name|incr
decl_stmt|;
comment|/* 	 * Wait delay loops for IPI to be sent.  This is highly bogus 	 * since this is sensitive to CPU clock speed.  If delay is 	 * -1, we wait forever. 	 */
if|if
condition|(
name|delay
operator|==
operator|-
literal|1
condition|)
block|{
name|incr
operator|=
literal|0
expr_stmt|;
name|delay
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|incr
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|delay
condition|;
name|x
operator|+=
name|incr
control|)
block|{
if|if
condition|(
operator|(
name|lapic
operator|->
name|icr_lo
operator|&
name|APIC_DELSTAT_MASK
operator|)
operator|==
name|APIC_DELSTAT_IDLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_ipi_raw
parameter_list|(
name|register_t
name|icrlo
parameter_list|,
name|u_int
name|dest
parameter_list|)
block|{
name|register_t
name|value
decl_stmt|,
name|eflags
decl_stmt|;
comment|/* XXX: Need more sanity checking of icrlo? */
name|KASSERT
argument_list|(
name|lapic
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s called too early"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid dest field"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|icrlo
operator|&
name|APIC_ICRLO_RESV_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: reserved bits set in ICR LO register"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Set destination in ICR HI register if it is being used. */
name|eflags
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|icrlo
operator|&
name|APIC_DEST_MASK
operator|)
operator|==
name|APIC_DEST_DESTFLD
condition|)
block|{
name|value
operator|=
name|lapic
operator|->
name|icr_hi
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|value
operator||=
name|dest
operator|<<
name|APIC_ID_SHIFT
expr_stmt|;
name|lapic
operator|->
name|icr_hi
operator|=
name|value
expr_stmt|;
block|}
comment|/* Program the contents of the IPI and dispatch it. */
name|value
operator|=
name|lapic
operator|->
name|icr_lo
expr_stmt|;
name|value
operator|&=
name|APIC_ICRLO_RESV_MASK
expr_stmt|;
name|value
operator||=
name|icrlo
expr_stmt|;
name|lapic
operator|->
name|icr_lo
operator|=
name|value
expr_stmt|;
name|intr_restore
argument_list|(
name|eflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BEFORE_SPIN
value|1000000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
end_ifdef

begin_define
define|#
directive|define
name|AFTER_SPIN
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|lapic_ipi_vectored
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|register_t
name|icrlo
decl_stmt|,
name|destfield
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vector
operator|&
operator|~
name|APIC_VECTOR_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|icrlo
operator|=
name|vector
operator||
name|APIC_DELMODE_FIXED
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_TRIGMOD_EDGE
expr_stmt|;
name|destfield
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dest
condition|)
block|{
case|case
name|APIC_IPI_DEST_SELF
case|:
name|icrlo
operator||=
name|APIC_DEST_SELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_ALL
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLISELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_OTHERS
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLESELF
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid destination 0x%x"
operator|,
name|__func__
operator|,
name|dest
operator|)
argument_list|)
expr_stmt|;
name|destfield
operator|=
name|dest
expr_stmt|;
block|}
comment|/* Wait for an earlier IPI to finish. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|BEFORE_SPIN
argument_list|)
condition|)
block|{
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
else|else
name|panic
argument_list|(
literal|"APIC: Previous IPI is stuck"
argument_list|)
expr_stmt|;
block|}
name|lapic_ipi_raw
argument_list|(
name|icrlo
argument_list|,
name|destfield
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
comment|/* Wait for IPI to be delivered. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|AFTER_SPIN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|needsattention
comment|/* 		 * XXX FIXME: 		 * 		 * The above function waits for the message to actually be 		 * delivered.  It breaks out after an arbitrary timeout 		 * since the message should eventually be delivered (at 		 * least in theory) and that if it wasn't we would catch 		 * the failure with the check above when the next IPI is 		 * sent. 		 * 		 * We could skip this wait entirely, EXCEPT it probably 		 * protects us from other routines that assume that the 		 * message was delivered and acted upon when this function 		 * returns. 		 */
name|printf
argument_list|(
literal|"APIC: IPI might be stuck\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !needsattention */
comment|/* Wait until mesage is sent without a timeout. */
while|while
condition|(
name|lapic
operator|->
name|icr_lo
operator|&
name|APIC_DELSTAT_PEND
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* needsattention */
block|}
endif|#
directive|endif
comment|/* DETECT_DEADLOCK */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

end_unit

