begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 1994, David Greenman  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the University of Utah, and William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)trap.c	7.4 (Berkeley) 5/13/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * 386 Trap and System call handling  */
end_comment

begin_include
include|#
directive|include
file|"opt_clock.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|"opt_stack.h"
end_include

begin_include
include|#
directive|include
file|"opt_trap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_expr_stmt
name|PMC_SOFT_DEFINE
argument_list|( , ,
name|page_fault
argument_list|,
name|all
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMC_SOFT_DEFINE
argument_list|( , ,
name|page_fault
argument_list|,
name|read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMC_SOFT_DEFINE
argument_list|( , ,
name|page_fault
argument_list|,
name|write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<x86/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/stack.h>
end_include

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_include
include|#
directive|include
file|<machine/vm86.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
end_ifdef

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|int
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|struct
name|trapframe
modifier|*
parameter_list|,
name|vm_offset_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dblfault_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|inthand_t
name|IDTVEC
parameter_list|(
name|lcall_syscall
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_TRAP_MSG
value|32
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|trap_msg
index|[]
init|=
block|{
literal|""
block|,
comment|/*  0 unused */
literal|"privileged instruction fault"
block|,
comment|/*  1 T_PRIVINFLT */
literal|""
block|,
comment|/*  2 unused */
literal|"breakpoint instruction fault"
block|,
comment|/*  3 T_BPTFLT */
literal|""
block|,
comment|/*  4 unused */
literal|""
block|,
comment|/*  5 unused */
literal|"arithmetic trap"
block|,
comment|/*  6 T_ARITHTRAP */
literal|""
block|,
comment|/*  7 unused */
literal|""
block|,
comment|/*  8 unused */
literal|"general protection fault"
block|,
comment|/*  9 T_PROTFLT */
literal|"trace trap"
block|,
comment|/* 10 T_TRCTRAP */
literal|""
block|,
comment|/* 11 unused */
literal|"page fault"
block|,
comment|/* 12 T_PAGEFLT */
literal|""
block|,
comment|/* 13 unused */
literal|"alignment fault"
block|,
comment|/* 14 T_ALIGNFLT */
literal|""
block|,
comment|/* 15 unused */
literal|""
block|,
comment|/* 16 unused */
literal|""
block|,
comment|/* 17 unused */
literal|"integer divide fault"
block|,
comment|/* 18 T_DIVIDE */
literal|"non-maskable interrupt trap"
block|,
comment|/* 19 T_NMI */
literal|"overflow trap"
block|,
comment|/* 20 T_OFLOW */
literal|"FPU bounds check fault"
block|,
comment|/* 21 T_BOUND */
literal|"FPU device not available"
block|,
comment|/* 22 T_DNA */
literal|"double fault"
block|,
comment|/* 23 T_DOUBLEFLT */
literal|"FPU operand fetch fault"
block|,
comment|/* 24 T_FPOPFLT */
literal|"invalid TSS fault"
block|,
comment|/* 25 T_TSSFLT */
literal|"segment not present fault"
block|,
comment|/* 26 T_SEGNPFLT */
literal|"stack fault"
block|,
comment|/* 27 T_STKFLT */
literal|"machine check trap"
block|,
comment|/* 28 T_MCHK */
literal|"SIMD floating-point exception"
block|,
comment|/* 29 T_XMMFLT */
literal|"reserved (unknown) fault"
block|,
comment|/* 30 T_RESERVED */
literal|""
block|,
comment|/* 31 unused (reserved) */
literal|"DTrace pid return trap"
block|,
comment|/* 32 T_DTRACE_RET */
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
end_if

begin_decl_stmt
name|int
name|has_f00f_bug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialized so that it can be patched. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|prot_fault_translation
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|prot_fault_translation
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|prot_fault_translation
argument_list|,
literal|0
argument_list|,
literal|"Select signal to deliver on protection fault"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|uprintf_signal
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|uprintf_signal
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|uprintf_signal
argument_list|,
literal|0
argument_list|,
literal|"Print debugging information on trap signal to ctty"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Exception, fault, and trap interface to the FreeBSD kernel.  * This common code is called from assembly language IDT gate entry  * routines that prepare a suitable stack frame, and restore this  * frame after the exception has been processed.  */
end_comment

begin_function
name|void
name|trap
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|struct
name|reg
name|regs
decl_stmt|;
endif|#
directive|endif
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|register_t
name|dr6
decl_stmt|;
endif|#
directive|endif
name|int
name|i
init|=
literal|0
decl_stmt|,
name|ucode
init|=
literal|0
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|register_t
name|addr
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
specifier|static
name|int
name|lastalert
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|VM_CNT_INC
argument_list|(
name|v_trap
argument_list|)
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* Handler for NMI IPIs used for stopping CPUs. */
if|if
condition|(
name|type
operator|==
name|T_NMI
condition|)
block|{
if|if
condition|(
name|ipi_nmi_handler
argument_list|()
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/* SMP */
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdb_active
condition|)
block|{
name|kdb_reenter
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_RESERVED
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_NMI
condition|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
comment|/* 		 * CPU PMCs interrupt using an NMI so we check for that first. 		 * If the HWPMC module is active, 'pmc_hook' will point to 		 * the function to be called.  A non-zero return value from the 		 * hook means that the NMI was consumed by it and that we can 		 * return immediately. 		 */
if|if
condition|(
name|pmc_intr
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|pmc_intr
call|)
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|frame
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|STACK
if|if
condition|(
name|stack_nmi_handler
argument_list|(
name|frame
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
block|}
if|if
condition|(
name|type
operator|==
name|T_MCHK
condition|)
block|{
name|mca_intr
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
comment|/* 	 * A trap can occur while DTrace executes a probe. Before 	 * executing the probe, DTrace blocks re-scheduling and sets 	 * a flag in its per-cpu flags to indicate that it doesn't 	 * want to fault. On returning from the probe, the no-fault 	 * flag is cleared and finally re-scheduling is enabled. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|T_PROTFLT
operator|||
name|type
operator|==
name|T_PAGEFLT
operator|)
operator|&&
name|dtrace_trap_func
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|dtrace_trap_func
call|)
argument_list|(
name|frame
argument_list|,
name|type
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_I
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Buggy application or kernel code has disabled 		 * interrupts and then trapped.  Enabling interrupts 		 * now is wrong, but it is better than running with 		 * interrupts disabled until they are accidentally 		 * enabled later. 		 */
if|if
condition|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
operator|&&
operator|(
name|curpcb
operator|->
name|pcb_flags
operator|&
name|PCB_VM86CALL
operator|)
operator|==
literal|0
condition|)
name|uprintf
argument_list|(
literal|"pid %ld (%s): trap %d with interrupts disabled\n"
argument_list|,
operator|(
name|long
operator|)
name|curproc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_name
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_NMI
operator|&&
name|type
operator|!=
name|T_BPTFLT
operator|&&
name|type
operator|!=
name|T_TRCTRAP
operator|&&
name|frame
operator|->
name|tf_eip
operator|!=
operator|(
name|int
operator|)
name|cpu_switch_load_gs
condition|)
block|{
comment|/* 			 * XXX not quite right, since this may be for a 			 * multiple fault in user mode. 			 */
name|printf
argument_list|(
literal|"kernel trap %d with interrupts disabled\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * Page faults need interrupts disabled until later, 			 * and we shouldn't enable interrupts while holding 			 * a spin lock. 			 */
if|if
condition|(
name|type
operator|!=
name|T_PAGEFLT
operator|&&
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|0
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
block|}
block|}
name|eva
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
comment|/* 		 * For some Cyrix CPUs, %cr2 is clobbered by 		 * interrupts.  This problem is worked around by using 		 * an interrupt gate for the pagefault handler.  We 		 * are finally ready to read %cr2 and conditionally 		 * reenable interrupts.  If we hold a spin lock, then 		 * we must not reenable interrupts.  This might be a 		 * spurious page fault. 		 */
name|eva
operator|=
name|rcr2
argument_list|()
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_spinlock_count
operator|==
literal|0
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
operator|&&
operator|(
name|curpcb
operator|->
name|pcb_flags
operator|&
name|PCB_VM86CALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* user trap */
name|td
operator|->
name|td_pticks
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|frame
expr_stmt|;
name|addr
operator|=
name|frame
operator|->
name|tf_eip
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_cowgen
operator|!=
name|p
operator|->
name|p_cowgen
condition|)
name|thread_cow_update
argument_list|(
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PRIVINFLT
case|:
comment|/* privileged instruction fault */
name|i
operator|=
name|SIGILL
expr_stmt|;
name|ucode
operator|=
name|ILL_PRVOPC
expr_stmt|;
break|break;
case|case
name|T_BPTFLT
case|:
comment|/* bpt instruction fault */
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|enable_intr
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|type
operator|==
name|T_BPTFLT
condition|)
block|{
name|fill_frame_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_pid_probe_ptr
operator|!=
name|NULL
operator|&&
name|dtrace_pid_probe_ptr
argument_list|(
operator|&
name|regs
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|user_trctrap_out
label|:
name|frame
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|i
operator|=
name|SIGTRAP
expr_stmt|;
name|ucode
operator|=
operator|(
name|type
operator|==
name|T_TRCTRAP
condition|?
name|TRAP_TRACE
else|:
name|TRAP_BRKPT
operator|)
expr_stmt|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
name|ucode
operator|=
name|npxtrap_x87
argument_list|()
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
comment|/* 			 * The following two traps can happen in 			 * vm86 mode, and, if so, we want to handle 			 * them specially. 			 */
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SIGTRAP
condition|)
block|{
name|type
operator|=
name|T_TRCTRAP
expr_stmt|;
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator||
literal|0x4000
argument_list|)
expr_stmt|;
goto|goto
name|user_trctrap_out
goto|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
break|break;
block|}
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
operator|(
name|type
operator|==
name|T_PROTFLT
operator|)
condition|?
name|BUS_OBJERR
else|:
name|BUS_ADRERR
expr_stmt|;
break|break;
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_ADRERR
expr_stmt|;
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* invalid TSS fault */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_OBJERR
expr_stmt|;
break|break;
case|case
name|T_ALIGNFLT
case|:
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_ADRALN
expr_stmt|;
break|break;
case|case
name|T_DOUBLEFLT
case|:
comment|/* double fault */
default|default:
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_OBJERR
expr_stmt|;
break|break;
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
name|i
operator|=
name|trap_pfault
argument_list|(
name|frame
argument_list|,
name|TRUE
argument_list|,
name|eva
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* 				 * The f00f hack workaround has triggered, so 				 * treat the fault as an illegal instruction  				 * (T_PRIVINFLT) instead of a page fault. 				 */
name|type
operator|=
name|frame
operator|->
name|tf_trapno
operator|=
name|T_PRIVINFLT
expr_stmt|;
comment|/* Proceed as in that case. */
name|ucode
operator|=
name|ILL_PRVOPC
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
goto|goto
name|user
goto|;
if|if
condition|(
name|i
operator|==
name|SIGSEGV
condition|)
name|ucode
operator|=
name|SEGV_MAPERR
expr_stmt|;
else|else
block|{
if|if
condition|(
name|prot_fault_translation
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Autodetect. 					 * This check also covers the images 					 * without the ABI-tag ELF note. 					 */
if|if
condition|(
name|SV_CURPROC_ABI
argument_list|()
operator|==
name|SV_ABI_FREEBSD
operator|&&
name|p
operator|->
name|p_osrel
operator|>=
name|P_OSREL_SIGSEGV
condition|)
block|{
name|i
operator|=
name|SIGSEGV
expr_stmt|;
name|ucode
operator|=
name|SEGV_ACCERR
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_PAGE_FAULT
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|prot_fault_translation
operator|==
literal|1
condition|)
block|{
comment|/* 					 * Always compat mode. 					 */
name|i
operator|=
name|SIGBUS
expr_stmt|;
name|ucode
operator|=
name|BUS_PAGE_FAULT
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Always SIGSEGV mode. 					 */
name|i
operator|=
name|SIGSEGV
expr_stmt|;
name|ucode
operator|=
name|SEGV_ACCERR
expr_stmt|;
block|}
block|}
name|addr
operator|=
name|eva
expr_stmt|;
break|break;
case|case
name|T_DIVIDE
case|:
comment|/* integer divide fault */
name|ucode
operator|=
name|FPE_INTDIV
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
ifndef|#
directive|ifndef
name|TIMER_FREQ
define|#
directive|define
name|TIMER_FREQ
value|1193182
endif|#
directive|endif
if|if
condition|(
name|time_second
operator|-
name|lastalert
operator|>
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NMI: power fail\n"
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
literal|880
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lastalert
operator|=
name|time_second
expr_stmt|;
block|}
goto|goto
name|userout
goto|;
else|#
directive|else
comment|/* !POWERFAIL_NMI */
name|nmi_handle_intr
argument_list|(
name|type
argument_list|,
name|frame
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* DEV_ISA */
case|case
name|T_OFLOW
case|:
comment|/* integer overflow fault */
name|ucode
operator|=
name|FPE_INTOVF
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_BOUND
case|:
comment|/* bounds check fault */
name|ucode
operator|=
name|FPE_FLTSUB
expr_stmt|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
case|case
name|T_DNA
case|:
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"kernel FPU ctx has leaked"
operator|)
argument_list|)
expr_stmt|;
comment|/* transparent fault (due to context switch "late") */
if|if
condition|(
name|npxdna
argument_list|()
condition|)
goto|goto
name|userout
goto|;
name|uprintf
argument_list|(
literal|"pid %d killed due to lack of floating point\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|i
operator|=
name|SIGKILL
expr_stmt|;
name|ucode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
name|ucode
operator|=
name|ILL_COPROC
expr_stmt|;
name|i
operator|=
name|SIGILL
expr_stmt|;
break|break;
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
name|ucode
operator|=
name|npxtrap_sse
argument_list|()
expr_stmt|;
if|if
condition|(
name|ucode
operator|==
operator|-
literal|1
condition|)
goto|goto
name|userout
goto|;
name|i
operator|=
name|SIGFPE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
case|case
name|T_DTRACE_RET
case|:
name|enable_intr
argument_list|()
expr_stmt|;
name|fill_frame_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_return_probe_ptr
operator|!=
name|NULL
operator|&&
name|dtrace_return_probe_ptr
argument_list|(
operator|&
name|regs
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
break|break;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* kernel trap */
name|KASSERT
argument_list|(
name|cold
operator|||
name|td
operator|->
name|td_ucred
operator|!=
name|NULL
argument_list|,
operator|(
literal|"kernel trap doesn't have ucred"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PAGEFLT
case|:
comment|/* page fault */
operator|(
name|void
operator|)
name|trap_pfault
argument_list|(
name|frame
argument_list|,
name|FALSE
argument_list|,
name|eva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|T_DNA
case|:
if|if
condition|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Unregistered use of FPU in kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
name|npxdna
argument_list|()
condition|)
goto|goto
name|out
goto|;
break|break;
case|case
name|T_ARITHTRAP
case|:
comment|/* arithmetic trap */
case|case
name|T_XMMFLT
case|:
comment|/* SIMD floating-point exception */
case|case
name|T_FPOPFLT
case|:
comment|/* FPU operand fetch fault */
comment|/* 			 * XXXKIB for now disable any FPU traps in kernel 			 * handler registration seems to be overkill 			 */
name|trap_fatal
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* 			 * The following two traps can happen in 			 * vm86 mode, and, if so, we want to handle 			 * them specially. 			 */
case|case
name|T_PROTFLT
case|:
comment|/* general protection fault */
case|case
name|T_STKFLT
case|:
comment|/* stack fault */
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
block|{
name|i
operator|=
name|vm86_emulate
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SIGTRAP
condition|)
block|{
name|type
operator|=
name|T_TRCTRAP
expr_stmt|;
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator||
literal|0x4000
argument_list|)
expr_stmt|;
goto|goto
name|kernel_trctrap
goto|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
comment|/* 					 * returns to original process 					 */
name|vm86_trap
argument_list|(
operator|(
expr|struct
name|vm86frame
operator|*
operator|)
name|frame
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_STKFLT
condition|)
break|break;
comment|/* FALL THROUGH */
case|case
name|T_SEGNPFLT
case|:
comment|/* segment not present fault */
if|if
condition|(
name|curpcb
operator|->
name|pcb_flags
operator|&
name|PCB_VM86CALL
condition|)
break|break;
comment|/* 			 * Invalid %fs's and %gs's can be created using 			 * procfs or PT_SETREGS or by invalidating the 			 * underlying LDT entry.  This causes a fault 			 * in kernel mode when the kernel attempts to 			 * switch contexts.  Lose the bad context 			 * (XXX) so that we can continue, and generate 			 * a signal. 			 */
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|cpu_switch_load_gs
condition|)
block|{
name|curpcb
operator|->
name|pcb_gs
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|PROC_LOCK(p); 				kern_psignal(p, SIGBUS); 				PROC_UNLOCK(p);
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|!=
literal|0
condition|)
break|break;
comment|/* 			 * Invalid segment selectors and out of bounds 			 * %eip's and %esp's can be set up in user mode. 			 * This causes a fault in kernel mode when the 			 * kernel tries to return to user mode.  We want 			 * to get this fault so that we can fix the 			 * problem here and not have to check all the 			 * selectors and pointers when the user changes 			 * them. 			 */
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_iret
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_iret_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_ds
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_ds_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_es
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_es_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|doreti_popl_fs
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|doreti_popl_fs_fault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|curpcb
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|curpcb
operator|->
name|pcb_onfault
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TSSFLT
case|:
comment|/* 			 * PSL_NT can be set in user mode and isn't cleared 			 * automatically when the kernel is entered.  This 			 * causes a TSS fault when the kernel attempts to 			 * `iret' because the TSS link is uninitialized.  We 			 * want to get this fault so that we can fix the 			 * problem here and not every time the kernel is 			 * entered. 			 */
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_NT
condition|)
block|{
name|frame
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_NT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|T_TRCTRAP
case|:
comment|/* trace trap */
name|kernel_trctrap
label|:
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|lcall_syscall
argument_list|)
condition|)
block|{
comment|/* 				 * We've just entered system mode via the 				 * syscall lcall.  Continue single stepping 				 * silently until the syscall handler has 				 * saved the flags. 				 */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|frame
operator|->
name|tf_eip
operator|==
operator|(
name|int
operator|)
name|IDTVEC
argument_list|(
name|lcall_syscall
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* 				 * The syscall handler has now saved the 				 * flags.  Stop single stepping it. 				 */
name|frame
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Ignore debug register trace traps due to 			 * accesses in the user's address space, which 			 * can happen under several conditions such as 			 * if a user sets a watchpoint on a buffer and 			 * then passes that buffer to a system call. 			 * We still want to get TRCTRAPS for addresses 			 * in kernel space because that is useful when 			 * debugging the kernel. 			 */
if|if
condition|(
name|user_dbreg_trap
argument_list|()
operator|&&
operator|!
operator|(
name|curpcb
operator|->
name|pcb_flags
operator|&
name|PCB_VM86CALL
operator|)
condition|)
block|{
comment|/* 				 * Reset breakpoint bits because the 				 * processor doesn't 				 */
name|load_dr6
argument_list|(
name|rdr6
argument_list|()
operator|&
operator|~
literal|0xf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * FALLTHROUGH (TRCTRAP kernel mode, kernel address) 			 */
case|case
name|T_BPTFLT
case|:
comment|/* 			 * If KDB is enabled, let it handle the debugger trap. 			 * Otherwise, debugger traps "can't happen". 			 */
ifdef|#
directive|ifdef
name|KDB
comment|/* XXX %dr6 is not quite reentrant. */
name|dr6
operator|=
name|rdr6
argument_list|()
expr_stmt|;
name|load_dr6
argument_list|(
name|dr6
operator|&
operator|~
literal|0x4000
argument_list|)
expr_stmt|;
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
name|dr6
argument_list|,
name|frame
argument_list|)
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|DEV_ISA
case|case
name|T_NMI
case|:
ifdef|#
directive|ifdef
name|POWERFAIL_NMI
if|if
condition|(
name|time_second
operator|-
name|lastalert
operator|>
literal|10
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"NMI: power fail\n"
argument_list|)
expr_stmt|;
name|sysbeep
argument_list|(
literal|880
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|lastalert
operator|=
name|time_second
expr_stmt|;
block|}
goto|goto
name|out
goto|;
else|#
directive|else
comment|/* !POWERFAIL_NMI */
name|nmi_handle_intr
argument_list|(
name|type
argument_list|,
name|frame
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
endif|#
directive|endif
comment|/* POWERFAIL_NMI */
endif|#
directive|endif
comment|/* DEV_ISA */
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Translate fault for emulators (e.g. Linux) */
if|if
condition|(
operator|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
condition|)
name|i
operator|=
call|(
modifier|*
name|p
operator|->
name|p_sysent
operator|->
name|sv_transtrap
call|)
argument_list|(
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|i
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|ucode
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
name|ksi
operator|.
name|ksi_trapno
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|uprintf_signal
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d comm %s: signal %d err %x code %d type %d "
literal|"addr 0x%x esp 0x%08x eip 0x%08x "
literal|"<%02x %02x %02x %02x %02x %02x %02x %02x>\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|i
argument_list|,
name|frame
operator|->
name|tf_err
argument_list|,
name|ucode
argument_list|,
name|type
argument_list|,
name|addr
argument_list|,
name|frame
operator|->
name|tf_esp
argument_list|,
name|frame
operator|->
name|tf_eip
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|0
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|2
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|3
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|4
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|5
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|6
operator|)
argument_list|)
argument_list|,
name|fubyte
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|frame
operator|->
name|tf_eip
operator|+
literal|7
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|read_eflags
argument_list|()
operator|&
name|PSL_I
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"interrupts disabled"
operator|)
argument_list|)
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
block|{
name|uprintf
argument_list|(
literal|"fatal process exception: %s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|T_PAGEFLT
operator|)
operator|||
operator|(
name|type
operator|==
name|T_PROTFLT
operator|)
condition|)
name|uprintf
argument_list|(
literal|", fault VA = 0x%lx"
argument_list|,
operator|(
name|u_long
operator|)
name|eva
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|user
label|:
name|userret
argument_list|(
name|td
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"Return from trap with kernel FPU ctx leaked"
operator|)
argument_list|)
expr_stmt|;
name|userout
label|:
name|out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|trap_pfault
parameter_list|(
name|frame
parameter_list|,
name|usermode
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|int
name|usermode
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
name|vm_prot_t
name|ftype
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_NOFAULTING
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Due to both processor errata and lazy TLB invalidation when 		 * access restrictions are removed from virtual pages, memory 		 * accesses that are allowed by the physical mapping layer may 		 * nonetheless cause one spurious page fault per virtual page.  		 * When the thread is executing a "no faulting" section that 		 * is bracketed by vm_fault_{disable,enable}_pagefaults(), 		 * every page fault is treated as a spurious page fault, 		 * unless it accesses the same virtual address as the most 		 * recent page fault within the same "no faulting" section. 		 */
if|if
condition|(
name|td
operator|->
name|td_md
operator|.
name|md_spurflt_addr
operator|!=
name|eva
operator|||
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_RESETSPUR
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Do nothing to the TLB.  A stale TLB entry is 			 * flushed automatically by a page fault. 			 */
name|td
operator|->
name|td_md
operator|.
name|md_spurflt_addr
operator|=
name|eva
expr_stmt|;
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_RESETSPUR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * If we get a page fault while in a critical section, then 		 * it is most likely a fatal kernel page fault.  The kernel 		 * is already going to panic trying to get a sleep lock to 		 * do the VM lookup, so just consider it a fatal trap so the 		 * kernel can print out a useful trap message and even get 		 * to the debugger. 		 * 		 * If we get a page fault while holding a non-sleepable 		 * lock, then it is most likely a fatal kernel page fault. 		 * If WITNESS is enabled, then it's going to whine about 		 * bogus LORs with various VM locks, so just skip to the 		 * fatal trap handling directly. 		 */
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|!=
literal|0
operator|||
name|WITNESS_CHECK
argument_list|(
name|WARN_SLEEPOK
operator||
name|WARN_GIANTOK
argument_list|,
name|NULL
argument_list|,
literal|"Kernel page fault"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|va
operator|=
name|trunc_page
argument_list|(
name|eva
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|>=
name|KERNBASE
condition|)
block|{
comment|/* 		 * Don't allow user-mode faults in kernel address space. 		 * An exception:  if the faulting address is the invalid 		 * instruction entry in the IDT, then the Intel Pentium 		 * F00F bug workaround was triggered, and we need to 		 * treat it is as an illegal instruction, and not a page 		 * fault. 		 */
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
if|if
condition|(
operator|(
name|eva
operator|==
operator|(
name|unsigned
name|int
operator|)
operator|&
name|idt
index|[
literal|6
index|]
operator|)
operator|&&
name|has_f00f_bug
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|usermode
condition|)
goto|goto
name|nogo
goto|;
name|map
operator|=
name|kernel_map
expr_stmt|;
block|}
else|else
block|{
name|map
operator|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
comment|/* 		 * When accessing a user-space address, kernel must be 		 * ready to accept the page fault, and provide a 		 * handling routine.  Since accessing the address 		 * without the handler is a bug, do not try to handle 		 * it normally, and panic immediately. 		 */
if|if
condition|(
operator|!
name|usermode
operator|&&
operator|(
name|td
operator|->
name|td_intr_nesting_level
operator|!=
literal|0
operator|||
name|curpcb
operator|->
name|pcb_onfault
operator|==
name|NULL
operator|)
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * If the trap was caused by errant bits in the PTE then panic. 	 */
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_RSV
condition|)
block|{
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * PGEX_I is defined only if the execute disable bit capability is 	 * supported and enabled. 	 */
if|if
condition|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_W
condition|)
name|ftype
operator|=
name|VM_PROT_WRITE
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|PAE
argument_list|)
operator|||
name|defined
argument_list|(
name|PAE_TABLES
argument_list|)
elseif|else
if|if
condition|(
operator|(
name|frame
operator|->
name|tf_err
operator|&
name|PGEX_I
operator|)
operator|&&
name|pg_nx
operator|!=
literal|0
condition|)
name|ftype
operator|=
name|VM_PROT_EXECUTE
expr_stmt|;
endif|#
directive|endif
else|else
name|ftype
operator|=
name|VM_PROT_READ
expr_stmt|;
comment|/* Fault in the page. */
name|rv
operator|=
name|vm_fault
argument_list|(
name|map
argument_list|,
name|va
argument_list|,
name|ftype
argument_list|,
name|VM_FAULT_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|KERN_SUCCESS
condition|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
if|if
condition|(
name|ftype
operator|==
name|VM_PROT_READ
operator|||
name|ftype
operator|==
name|VM_PROT_WRITE
condition|)
block|{
name|PMC_SOFT_CALL_TF
argument_list|( , ,
name|page_fault
argument_list|,
name|all
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftype
operator|==
name|VM_PROT_READ
condition|)
name|PMC_SOFT_CALL_TF
argument_list|( , ,
name|page_fault
argument_list|,
name|read
argument_list|,
name|frame
argument_list|)
expr_stmt|;
else|else
name|PMC_SOFT_CALL_TF
argument_list|( , ,
name|page_fault
argument_list|,
name|write
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nogo
label|:
if|if
condition|(
operator|!
name|usermode
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_intr_nesting_level
operator|==
literal|0
operator|&&
name|curpcb
operator|->
name|pcb_onfault
operator|!=
name|NULL
condition|)
block|{
name|frame
operator|->
name|tf_eip
operator|=
operator|(
name|int
operator|)
name|curpcb
operator|->
name|pcb_onfault
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|trap_fatal
argument_list|(
name|frame
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|rv
operator|==
name|KERN_PROTECTION_FAILURE
operator|)
condition|?
name|SIGBUS
else|:
name|SIGSEGV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trap_fatal
parameter_list|(
name|frame
parameter_list|,
name|eva
parameter_list|)
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|vm_offset_t
name|eva
decl_stmt|;
block|{
name|int
name|code
decl_stmt|,
name|ss
decl_stmt|,
name|esp
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|struct
name|soft_segment_descriptor
name|softseg
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|code
operator|=
name|frame
operator|->
name|tf_err
expr_stmt|;
name|type
operator|=
name|frame
operator|->
name|tf_trapno
expr_stmt|;
name|sdtossd
argument_list|(
operator|&
name|gdt
index|[
name|IDXSEL
argument_list|(
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|)
index|]
operator|.
name|sd
argument_list|,
operator|&
name|softseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|msg
operator|=
name|trap_msg
index|[
name|type
index|]
expr_stmt|;
else|else
name|msg
operator|=
literal|"UNKNOWN"
expr_stmt|;
name|printf
argument_list|(
literal|"\n\nFatal trap %d: %s while in %s mode\n"
argument_list|,
name|type
argument_list|,
name|msg
argument_list|,
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|?
literal|"vm86"
else|:
name|ISPL
argument_list|(
name|frame
operator|->
name|tf_cs
argument_list|)
operator|==
name|SEL_UPL
condition|?
literal|"user"
else|:
literal|"kernel"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|type
operator|==
name|T_PAGEFLT
condition|)
block|{
name|printf
argument_list|(
literal|"fault virtual address	= 0x%x\n"
argument_list|,
name|eva
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"fault code		= %s %s%s, %s\n"
argument_list|,
name|code
operator|&
name|PGEX_U
condition|?
literal|"user"
else|:
literal|"supervisor"
argument_list|,
name|code
operator|&
name|PGEX_W
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|PAE
argument_list|)
operator|||
name|defined
argument_list|(
name|PAE_TABLES
argument_list|)
name|pg_nx
operator|!=
literal|0
condition|?
operator|(
name|code
operator|&
name|PGEX_I
condition|?
literal|" instruction"
else|:
literal|" data"
operator|)
else|:
endif|#
directive|endif
literal|""
argument_list|,
name|code
operator|&
name|PGEX_RSV
condition|?
literal|"reserved bits in PTE"
else|:
name|code
operator|&
name|PGEX_P
condition|?
literal|"protection violation"
else|:
literal|"page not present"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"instruction pointer	= 0x%x:0x%x\n"
argument_list|,
name|frame
operator|->
name|tf_cs
operator|&
literal|0xffff
argument_list|,
name|frame
operator|->
name|tf_eip
argument_list|)
expr_stmt|;
if|if
condition|(
name|TF_HAS_STACKREGS
argument_list|(
name|frame
argument_list|)
condition|)
block|{
name|ss
operator|=
name|frame
operator|->
name|tf_ss
operator|&
literal|0xffff
expr_stmt|;
name|esp
operator|=
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
else|else
block|{
name|ss
operator|=
name|GSEL
argument_list|(
name|GDATA_SEL
argument_list|,
name|SEL_KPL
argument_list|)
expr_stmt|;
name|esp
operator|=
operator|(
name|int
operator|)
operator|&
name|frame
operator|->
name|tf_esp
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"stack pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|esp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"frame pointer	        = 0x%x:0x%x\n"
argument_list|,
name|ss
argument_list|,
name|frame
operator|->
name|tf_ebp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"code segment		= base 0x%x, limit 0x%x, type 0x%x\n"
argument_list|,
name|softseg
operator|.
name|ssd_base
argument_list|,
name|softseg
operator|.
name|ssd_limit
argument_list|,
name|softseg
operator|.
name|ssd_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"			= DPL %d, pres %d, def32 %d, gran %d\n"
argument_list|,
name|softseg
operator|.
name|ssd_dpl
argument_list|,
name|softseg
operator|.
name|ssd_p
argument_list|,
name|softseg
operator|.
name|ssd_def32
argument_list|,
name|softseg
operator|.
name|ssd_gran
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"processor eflags	= "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_T
condition|)
name|printf
argument_list|(
literal|"trace trap, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_I
condition|)
name|printf
argument_list|(
literal|"interrupt enabled, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_NT
condition|)
name|printf
argument_list|(
literal|"nested task, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_RF
condition|)
name|printf
argument_list|(
literal|"resume, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_VM
condition|)
name|printf
argument_list|(
literal|"vm86, "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"IOPL = %d\n"
argument_list|,
operator|(
name|frame
operator|->
name|tf_eflags
operator|&
name|PSL_IOPL
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"current process		= %d (%s)\n"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curthread
operator|->
name|td_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|debugger_on_panic
operator|||
name|kdb_active
condition|)
block|{
name|frame
operator|->
name|tf_err
operator|=
name|eva
expr_stmt|;
comment|/* smuggle fault address to ddb */
if|if
condition|(
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
condition|)
block|{
name|frame
operator|->
name|tf_err
operator|=
name|code
expr_stmt|;
comment|/* restore error code */
return|return;
block|}
name|frame
operator|->
name|tf_err
operator|=
name|code
expr_stmt|;
comment|/* restore error code */
block|}
endif|#
directive|endif
name|printf
argument_list|(
literal|"trap number		= %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<=
name|MAX_TRAP_MSG
condition|)
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|trap_msg
index|[
name|type
index|]
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"unknown/reserved trap"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Double fault handler. Called when a fault occurs while writing  * a frame for a trap/exception onto the stack. This usually occurs  * when the stack overflows (such is the case with infinite recursion,  * for example).  *  * XXX Note that the current PTD gets replaced by IdlePTD when the  * task switch occurs. This means that the stack that was active at  * the time of the double fault is not available at<kstack> unless  * the machine was idle when the double fault occurred. The downside  * of this is that "trace<ebp>" in ddb won't work.  */
end_comment

begin_function
name|void
name|dblfault_handler
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|dtrace_doubletrap_func
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|dtrace_doubletrap_func
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"\nFatal double fault:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"eip = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"esp = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_esp
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ebp = 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|common_tss
operator|.
name|tss_ebp
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* two separate prints in case of a trap on an unmapped page */
name|printf
argument_list|(
literal|"cpuid = %d; "
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"apic id = %02x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"double fault"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_fetch_syscall_args
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|frame
decl_stmt|;
name|struct
name|syscall_args
modifier|*
name|sa
decl_stmt|;
name|caddr_t
name|params
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|frame
operator|=
name|td
operator|->
name|td_frame
expr_stmt|;
name|sa
operator|=
operator|&
name|td
operator|->
name|td_sa
expr_stmt|;
name|params
operator|=
operator|(
name|caddr_t
operator|)
name|frame
operator|->
name|tf_esp
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|sa
operator|->
name|code
operator|=
name|frame
operator|->
name|tf_eax
expr_stmt|;
comment|/* 	 * Need to check if this is a 32 bit or 64 bit syscall. 	 */
if|if
condition|(
name|sa
operator|->
name|code
operator|==
name|SYS_syscall
condition|)
block|{
comment|/* 		 * Code is first argument, followed by actual args. 		 */
name|error
operator|=
name|fueword
argument_list|(
name|params
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|sa
operator|->
name|code
operator|=
name|tmp
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|code
operator|==
name|SYS___syscall
condition|)
block|{
comment|/* 		 * Like syscall, but code is a quad, so as to maintain 		 * quad alignment for the rest of the arguments. 		 */
name|error
operator|=
name|fueword
argument_list|(
name|params
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|sa
operator|->
name|code
operator|=
name|tmp
expr_stmt|;
name|params
operator|+=
sizeof|sizeof
argument_list|(
name|quad_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
condition|)
name|sa
operator|->
name|code
operator|&=
name|p
operator|->
name|p_sysent
operator|->
name|sv_mask
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|code
operator|>=
name|p
operator|->
name|p_sysent
operator|->
name|sv_size
condition|)
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
literal|0
index|]
expr_stmt|;
else|else
name|sa
operator|->
name|callp
operator|=
operator|&
name|p
operator|->
name|p_sysent
operator|->
name|sv_table
index|[
name|sa
operator|->
name|code
index|]
expr_stmt|;
name|sa
operator|->
name|narg
operator|=
name|sa
operator|->
name|callp
operator|->
name|sy_narg
expr_stmt|;
if|if
condition|(
name|params
operator|!=
name|NULL
operator|&&
name|sa
operator|->
name|narg
operator|!=
literal|0
condition|)
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|args
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|sa
operator|->
name|narg
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|frame
operator|->
name|tf_edx
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"../../kern/subr_syscall.c"
end_include

begin_comment
comment|/*  * syscall - system call request C handler.  A system call is  * essentially treated as a trap by reusing the frame layout.  */
end_comment

begin_function
name|void
name|syscall
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|register_t
name|orig_tf_eflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|TRAPF_USERMODE
argument_list|(
name|frame
argument_list|)
operator|&&
operator|(
name|curpcb
operator|->
name|pcb_flags
operator|&
name|PCB_VM86CALL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"syscall"
argument_list|)
expr_stmt|;
comment|/* NOT REACHED */
block|}
endif|#
directive|endif
name|orig_tf_eflags
operator|=
name|frame
operator|->
name|tf_eflags
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_frame
operator|=
name|frame
expr_stmt|;
name|error
operator|=
name|syscallenter
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Traced syscall. 	 */
if|if
condition|(
operator|(
name|orig_tf_eflags
operator|&
name|PSL_T
operator|)
operator|&&
operator|!
operator|(
name|orig_tf_eflags
operator|&
name|PSL_VM
operator|)
condition|)
block|{
name|frame
operator|->
name|tf_eflags
operator|&=
operator|~
name|PSL_T
expr_stmt|;
name|ksiginfo_init_trap
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|SIGTRAP
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|TRAP_TRACE
expr_stmt|;
name|ksi
operator|.
name|ksi_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|frame
operator|->
name|tf_eip
expr_stmt|;
name|trapsignal
argument_list|(
name|td
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|PCB_USER_FPU
argument_list|(
name|td
operator|->
name|td_pcb
argument_list|)
argument_list|,
operator|(
literal|"System call %s returning with kernel FPU ctx leaked"
operator|,
name|syscallname
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|td
operator|->
name|td_sa
operator|.
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_pcb
operator|->
name|pcb_save
operator|==
name|get_pcb_user_save_td
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"System call %s returning with mangled pcb_save"
operator|,
name|syscallname
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|td
operator|->
name|td_sa
operator|.
name|code
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|syscallret
argument_list|(
name|td
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

