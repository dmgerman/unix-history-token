begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: msdosfs_vnops.c,v 1.50 1997/10/17 12:36:17 phk Exp $ */
end_comment

begin_comment
comment|/*	$NetBSD: msdosfs_vnops.c,v 1.20 1994/08/21 18:44:13 ws Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1994 Wolfgang Solfrank.  * Copyright (C) 1994 TooLs GmbH.  * All rights reserved.  * Original code by Paul Popelka (paulp@uts.amdahl.com) (see below).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Written by Paul Popelka (paulp@uts.amdahl.com)  *  * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *  * This software is provided "as is".  *  * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *  * October 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_comment
comment|/* defines plimit structure in proc struct */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* defines v_rdev */
end_comment

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/fat.h>
end_include

begin_comment
comment|/*  * Prototypes for MSDOSFS vnode operations  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msdosfs_create
name|__P
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_mknod
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mknod_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_close
name|__P
argument_list|(
operator|(
expr|struct
name|vop_close_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_access
name|__P
argument_list|(
operator|(
expr|struct
name|vop_access_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_getattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_getattr_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_setattr
name|__P
argument_list|(
operator|(
expr|struct
name|vop_setattr_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_read
name|__P
argument_list|(
operator|(
expr|struct
name|vop_read_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_write
name|__P
argument_list|(
operator|(
expr|struct
name|vop_write_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_fsync
name|__P
argument_list|(
operator|(
expr|struct
name|vop_fsync_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_remove
name|__P
argument_list|(
operator|(
expr|struct
name|vop_remove_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_link
name|__P
argument_list|(
operator|(
expr|struct
name|vop_link_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_rename
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rename_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_mkdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_mkdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_rmdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_rmdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_symlink
name|__P
argument_list|(
operator|(
expr|struct
name|vop_symlink_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_readdir
name|__P
argument_list|(
operator|(
expr|struct
name|vop_readdir_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_abortop
name|__P
argument_list|(
operator|(
expr|struct
name|vop_abortop_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_bmap
name|__P
argument_list|(
operator|(
expr|struct
name|vop_bmap_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_strategy
name|__P
argument_list|(
operator|(
expr|struct
name|vop_strategy_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_print
name|__P
argument_list|(
operator|(
expr|struct
name|vop_print_args
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msdosfs_pathconf
name|__P
argument_list|(
operator|(
expr|struct
name|vop_pathconf_args
operator|*
name|ap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some general notes:  *  * In the ufs filesystem the inodes, superblocks, and indirect blocks are  * read/written using the vnode for the filesystem. Blocks that represent  * the contents of a file are read/written using the vnode for the file  * (including directories when they are read/written as files). This  * presents problems for the dos filesystem because data that should be in  * an inode (if dos had them) resides in the directory itself.  Since we  * must update directory entries without the benefit of having the vnode  * for the directory we must use the vnode for the filesystem.  This means  * that when a directory is actually read/written (via read, write, or  * readdir, or seek) we must use the vnode for the filesystem instead of  * the vnode for the directory as would happen in ufs. This is to insure we  * retreive the correct block from the buffer cache since the hash value is  * based upon the vnode address and the desired block number.  */
end_comment

begin_comment
comment|/*  * Create a regular file. On entry the directory to contain the file being  * created is locked.  We must release before we return. We must also free  * the pathname buffer pointed at by cnp->cn_pnbuf, always on error, or  * only if the SAVESTART bit in cn_flags is clear on success.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_create(cnp %08x, vap %08x\n"
argument_list|,
name|cnp
argument_list|,
name|ap
operator|->
name|a_vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Create a directory entry for the file, then call createde() to 	 * have it installed. NOTE: DOS files are always executable.  We 	 * use the absence of the owner write bit to make the file 	 * readonly. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_create: no name"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|ndirent
argument_list|,
sizeof|sizeof
argument_list|(
name|ndirent
argument_list|)
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ndirent
operator|.
name|de_Date
argument_list|,
operator|&
name|ndirent
operator|.
name|de_Time
argument_list|)
expr_stmt|;
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|ndirent
operator|.
name|de_Name
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|ndirent
operator|.
name|de_Attributes
operator|=
operator|(
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
operator|&
name|VWRITE
operator|)
condition|?
name|ATTR_ARCHIVE
else|:
name|ATTR_ARCHIVE
operator||
name|ATTR_READONLY
expr_stmt|;
name|ndirent
operator|.
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_FileSize
operator|=
literal|0
expr_stmt|;
name|ndirent
operator|.
name|de_dev
operator|=
name|pdep
operator|->
name|de_dev
expr_stmt|;
name|ndirent
operator|.
name|de_devvp
operator|=
name|pdep
operator|->
name|de_devvp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|createde
argument_list|(
operator|&
name|ndirent
argument_list|,
name|pdep
argument_list|,
operator|&
name|dep
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|DETOV
argument_list|(
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
block|}
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
comment|/* release parent dir */
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_mknod
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mknod_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_vap
operator|->
name|va_type
condition|)
block|{
case|case
name|VDIR
case|:
name|error
operator|=
name|msdosfs_mkdir
argument_list|(
operator|(
expr|struct
name|vop_mkdir_args
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
break|break;
case|case
name|VREG
case|:
name|error
operator|=
name|msdosfs_create
argument_list|(
operator|(
expr|struct
name|vop_create_args
operator|*
operator|)
name|ap
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int a_fflag; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|simple_lock
argument_list|(
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|>
literal|1
condition|)
name|DE_TIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|simple_unlock
argument_list|(
operator|&
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|mode_t
name|mask
decl_stmt|,
name|file_mode
decl_stmt|,
name|mode
init|=
name|ap
operator|->
name|a_mode
decl_stmt|;
specifier|register
name|gid_t
modifier|*
name|gp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|file_mode
operator|=
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator||
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator||
operator|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_READONLY
operator|)
condition|?
literal|0
else|:
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
expr_stmt|;
name|file_mode
operator|&=
name|pmp
operator|->
name|pm_mask
expr_stmt|;
comment|/* 	 * Disallow write attempts on read-only file systems; 	 * unless the file is a socket, fifo, or a block or 	 * character device resident on the file system. 	 */
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
block|{
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
block|}
block|}
comment|/* User id 0 always gets access. */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|mask
operator|=
literal|0
expr_stmt|;
comment|/* Otherwise, check the owner. */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
name|pmp
operator|->
name|pm_uid
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWUSR
expr_stmt|;
return|return
operator|(
name|file_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
comment|/* Otherwise, check the groups. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|gp
operator|=
name|cred
operator|->
name|cr_groups
init|;
name|i
operator|<
name|cred
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
operator|,
name|gp
operator|++
control|)
if|if
condition|(
name|pmp
operator|->
name|pm_gid
operator|==
operator|*
name|gp
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWGRP
expr_stmt|;
return|return
operator|(
name|file_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
comment|/* Otherwise, check everyone else. */
if|if
condition|(
name|mode
operator|&
name|VEXEC
condition|)
name|mask
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VREAD
condition|)
name|mask
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
name|mask
operator||=
name|S_IWOTH
expr_stmt|;
return|return
operator|(
name|file_mode
operator|&
name|mask
operator|)
operator|==
name|mask
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|u_int
name|cn
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|DE_TIMES
argument_list|(
name|dep
argument_list|,
operator|&
name|time
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|dep
operator|->
name|de_dev
expr_stmt|;
comment|/* 	 * The following computation of the fileid must be the same as that 	 * used in msdosfs_readdir() to compute d_fileno. If not, pwd 	 * doesn't work. 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|(
name|cn
operator|=
name|dep
operator|->
name|de_StartCluster
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|cn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cn
operator|=
name|dep
operator|->
name|de_dirclust
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|cn
operator|=
literal|1
expr_stmt|;
name|cn
operator|=
operator|(
name|cn
operator|<<
literal|16
operator|)
operator||
operator|(
name|dep
operator|->
name|de_diroffset
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
name|vap
operator|->
name|va_fileid
operator|=
name|cn
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator||
operator|(
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
operator|)
operator||
operator|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_READONLY
operator|)
condition|?
literal|0
else|:
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|&=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_mask
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
name|vap
operator|->
name|va_mode
operator||=
name|S_IFDIR
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_gid
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|dos2unixtime
argument_list|(
name|dep
operator|->
name|de_Date
argument_list|,
name|dep
operator|->
name|de_Time
argument_list|,
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|vap
operator|->
name|va_atime
expr_stmt|;
if|#
directive|if
literal|0
ifndef|#
directive|ifndef
name|MSDOSFS_NODIRMOD
block|if (vap->va_mode& S_IFDIR) 		TIMEVAL_TO_TIMESPEC(&time,&vap->va_mtime);
endif|#
directive|endif
endif|#
directive|endif
name|vap
operator|->
name|va_ctime
operator|=
name|vap
operator|->
name|va_atime
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_ARCHIVE
operator|)
condition|?
literal|0
else|:
name|SF_ARCHIVED
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
operator|(
name|dep
operator|->
name|de_FileSize
operator|+
name|dep
operator|->
name|de_pmp
operator|->
name|pm_crbomask
operator|)
operator|&
operator|~
operator|(
name|dep
operator|->
name|de_pmp
operator|->
name|pm_crbomask
operator|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|ap
operator|->
name|a_vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
name|dep
operator|->
name|de_modrev
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Check for unsettable attributes. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|ap
operator|->
name|a_p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * We are very inconsistent about handling unsupported 		 * attributes.  We ignored the the access time and the 		 * read and execute bits.  We were strict for the other 		 * attributes. 		 * 		 * Here we are strict, stricter than ufs in not allowing 		 * users to attempt to set SF_SETTABLE bits or anyone to 		 * set unsupported bits.  However, we ignore attempts to 		 * set ATTR_ARCHIVE for directories `cp -pr' from a more 		 * sensible file system attempts it a lot. 		 */
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|SF_SETTABLE
condition|)
return|return
name|EPERM
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
operator|~
name|SF_ARCHIVED
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|&
name|SF_ARCHIVED
condition|)
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_ARCHIVE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
condition|)
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_ARCHIVE
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_MODIFIED
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
operator|||
name|vap
operator|->
name|va_gid
operator|!=
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
operator|(
name|cred
operator|->
name|cr_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|||
name|vap
operator|->
name|va_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|||
operator|(
name|vap
operator|->
name|va_gid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|,
name|cred
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|ap
operator|->
name|a_p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|||
name|vap
operator|->
name|va_gid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_gid
condition|)
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|!=
name|VNOVAL
condition|)
block|{
comment|/* 		 * Disallow write attempts on read-only file systems; 		 * unless the file is a socket, fifo, or a block or 		 * character device resident on the file system. 		 */
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VDIR
case|:
return|return
operator|(
name|EISDIR
operator|)
return|;
case|case
name|VLNK
case|:
case|case
name|VREG
case|:
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
break|break;
block|}
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|ap
operator|->
name|a_p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|ap
operator|->
name|a_p
argument_list|)
operator|)
operator|)
condition|)
return|return
name|error
return|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * DOS files only have the ability to have their writability 	 * attribute set, so we use the owner write bit to set the readonly 	 * attribute. 	 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|u_short
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
name|dep
operator|->
name|de_pmp
operator|->
name|pm_uid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
operator|&
name|ap
operator|->
name|a_p
operator|->
name|p_acflag
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
comment|/* We ignore the read and execute bits */
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|&
name|VWRITE
condition|)
name|dep
operator|->
name|de_Attributes
operator|&=
operator|~
name|ATTR_READONLY
expr_stmt|;
else|else
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_READONLY
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_MODIFIED
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|int
name|isadir
decl_stmt|;
name|long
name|n
decl_stmt|;
name|long
name|on
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|daddr_t
name|rablock
decl_stmt|;
name|int
name|rasize
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
comment|/* 	 * If they didn't ask for any data, then we are done. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|isadir
operator|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
expr_stmt|;
do|do
block|{
name|lbn
operator|=
name|uio
operator|->
name|uio_offset
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|on
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
name|uio
operator|->
name|uio_offset
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* convert cluster # to block # if a directory */
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|lbn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
comment|/* 		 * If we are operating on a directory file then be sure to 		 * do i/o with the vnode for the filesystem instead of the 		 * vnode for the directory. 		 */
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rablock
operator|=
name|lbn
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
comment|/* 			 * 1024byte/sector support 			 */
if|if
condition|(
name|pmp
operator|->
name|pm_BytesPerSec
operator|==
literal|1024
condition|)
name|vp
operator|->
name|v_flag
operator||=
literal|0x10000
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_lastr
operator|+
literal|1
operator|==
name|lbn
operator|&&
name|rablock
operator|*
name|pmp
operator|->
name|pm_bpcluster
operator|<
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|rasize
operator|=
name|pmp
operator|->
name|pm_bpcluster
expr_stmt|;
name|error
operator|=
name|breadn
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
operator|&
name|rablock
argument_list|,
operator|&
name|rasize
argument_list|,
literal|1
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|bread
argument_list|(
name|vp
argument_list|,
name|lbn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_lastr
operator|=
name|lbn
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|on
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 		 * If we have read everything from this block or have read 		 * to end of file then we are done with this block.  Mark 		 * it to say the buffer can be reused if need be. 		 */
if|#
directive|if
literal|0
block|if (n + on == pmp->pm_bpcluster || 		    uio->uio_offset == dep->de_FileSize) 			bp->b_flags |= B_AGE;
endif|#
directive|endif
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|n
operator|!=
literal|0
condition|)
do|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Write data to a file or directory.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|isadir
decl_stmt|;
name|int
name|croffset
decl_stmt|;
name|int
name|resid
decl_stmt|;
name|int
name|osize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|,
name|lastcn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|ioflag
init|=
name|ap
operator|->
name|a_ioflag
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|uio
operator|->
name|uio_procp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|thisvp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_write(vp %08x, uio %08x, ioflag %08x, cred %08x\n"
argument_list|,
name|vp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cred
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"msdosfs_write(): diroff %d, dirclust %d, startcluster %d\n"
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|vp
operator|->
name|v_type
condition|)
block|{
case|case
name|VREG
case|:
if|if
condition|(
name|ioflag
operator|&
name|IO_APPEND
condition|)
name|uio
operator|->
name|uio_offset
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
name|isadir
operator|=
literal|0
expr_stmt|;
name|thisvp
operator|=
name|vp
expr_stmt|;
break|break;
case|case
name|VDIR
case|:
if|if
condition|(
operator|(
name|ioflag
operator|&
name|IO_SYNC
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_write(): non-sync directory update"
argument_list|)
expr_stmt|;
name|isadir
operator|=
literal|1
expr_stmt|;
name|thisvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"msdosfs_write(): bad file type"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * If they've exceeded their filesize limit, tell them about it. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
name|p
operator|&&
operator|(
operator|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|)
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|)
condition|)
block|{
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGXFSZ
argument_list|)
expr_stmt|;
return|return
name|EFBIG
return|;
block|}
comment|/* 	 * If attempting to write beyond the end of the root directory we 	 * stop that here because the root directory can not grow. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|&&
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
operator|(
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|)
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
return|return
name|ENOSPC
return|;
comment|/* 	 * If the offset we are starting the write at is beyond the end of 	 * the file, then they've done a seek.  Unix filesystems allow 	 * files with holes in them, DOS doesn't so we must fill the hole 	 * with zeroed blocks. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|error
operator|=
name|deextend
argument_list|(
name|dep
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|,
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
comment|/* 	 * Remember some values in case the write fails. 	 */
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|osize
operator|=
name|dep
operator|->
name|de_FileSize
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
comment|/* 	 * 1024byte/sector support 	 */
if|if
condition|(
name|pmp
operator|->
name|pm_BytesPerSec
operator|==
literal|1024
condition|)
name|thisvp
operator|->
name|v_flag
operator||=
literal|0x10000
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we write beyond the end of the file, extend it to its ultimate 	 * size ahead of the time to hopefully get a contiguous area. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|resid
operator|>
name|osize
condition|)
block|{
name|count
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|resid
argument_list|)
operator|-
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|osize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|error
operator|!=
name|ENOSPC
operator|||
operator|(
name|ioflag
operator|&
name|IO_UNIT
operator|)
operator|)
condition|)
goto|goto
name|errexit
goto|;
name|lastcn
operator|=
name|dep
operator|->
name|de_fc
index|[
name|FC_LASTFC
index|]
operator|.
name|fc_frcn
expr_stmt|;
block|}
else|else
name|lastcn
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|osize
argument_list|)
operator|-
literal|1
expr_stmt|;
do|do
block|{
name|bn
operator|=
name|de_blk
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|isadir
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bn
argument_list|,
operator|&
name|bn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|bn
operator|>
name|lastcn
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
break|break;
block|}
name|croffset
operator|=
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|croffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|+
name|n
operator|>
name|dep
operator|->
name|de_FileSize
condition|)
block|{
name|dep
operator|->
name|de_FileSize
operator|=
name|uio
operator|->
name|uio_offset
operator|+
name|n
expr_stmt|;
comment|/* The object size needs to be set before buffer is allocated */
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_offset
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|==
literal|0
operator|&&
operator|(
name|de_blk
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
argument_list|)
operator|>
name|de_blk
argument_list|(
name|pmp
argument_list|,
name|uio
operator|->
name|uio_offset
argument_list|)
operator|||
name|uio
operator|->
name|uio_offset
operator|+
name|uio
operator|->
name|uio_resid
operator|>=
name|dep
operator|->
name|de_FileSize
operator|)
condition|)
block|{
comment|/* 			 * If either the whole cluster gets written, 			 * or we write the cluster from its start beyond EOF, 			 * then no need to read data from disk. 			 */
name|bp
operator|=
name|getblk
argument_list|(
name|thisvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 			 * Do the bmap now, since pcbmap needs buffers 			 * for the fat table. (see msdosfs_strategy) 			 */
if|if
condition|(
operator|!
name|isadir
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bp
operator|->
name|b_blkno
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
comment|/* XXX */
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * The block we need to write into exists, so read it in. 			 */
name|error
operator|=
name|bread
argument_list|(
name|thisvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|cred
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
comment|/* 		 * Should these vnode_pager_* functions be done on dir 		 * files? 		 */
comment|/* 		 * Copy the data from user space into the buf header. 		 */
name|error
operator|=
name|uiomove
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|croffset
argument_list|,
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 		 * If they want this synchronous then write it and wait for 		 * it.  Otherwise, if on a cluster boundary write it 		 * asynchronously so we can move on to the next block 		 * without delay.  Otherwise do a delayed write because we 		 * may want to write somemore into the block later. 		 */
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|+
name|croffset
operator|==
name|pmp
operator|->
name|pm_bpcluster
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
literal|0
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
do|;
comment|/* 	 * If the write failed and they want us to, truncate the file back 	 * to the size it was before the write was attempted. 	 */
name|errexit
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|ioflag
operator|&
name|IO_UNIT
condition|)
block|{
name|detrunc
argument_list|(
name|dep
argument_list|,
name|osize
argument_list|,
name|ioflag
operator|&
name|IO_SYNC
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|resid
expr_stmt|;
block|}
else|else
block|{
name|detrunc
argument_list|(
name|dep
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
name|ioflag
operator|&
name|IO_SYNC
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|resid
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ioflag
operator|&
name|IO_SYNC
condition|)
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|error
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the blocks of a file to disk.  *  * This function is worthless for vnodes that represent directories. Maybe we  * could just do a sync if they try an fsync on a directory file.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		struct ucred *a_cred; 		int a_waitfor; 		struct proc *a_p; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
specifier|register
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|wait
init|=
name|ap
operator|->
name|a_waitfor
operator|==
name|MNT_WAIT
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|buf
modifier|*
name|nbp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Flush all dirty buffers associated with a vnode. 	 */
name|loop
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
init|;
name|bp
condition|;
name|bp
operator|=
name|nbp
control|)
block|{
name|nbp
operator|=
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_fsync: not dirty"
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
while|while
condition|(
name|vp
operator|->
name|v_numoutput
condition|)
block|{
name|vp
operator|->
name|v_flag
operator||=
name|VBWAIT
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vp
operator|->
name|v_numoutput
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"msdosfsn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|vp
operator|->
name|v_dirtyblkhd
operator|.
name|lh_first
condition|)
block|{
name|vprint
argument_list|(
literal|"msdosfs_fsync: dirty"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
return|return
name|deupdat
argument_list|(
name|VTODE
argument_list|(
name|vp
argument_list|)
argument_list|,
operator|&
name|ts
argument_list|,
name|wait
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|denode
modifier|*
name|ddep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|error
operator|=
name|removede
argument_list|(
name|ddep
argument_list|,
name|dep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_remove(), dep %08x, v_usecount %d\n"
argument_list|,
name|dep
argument_list|,
name|ap
operator|->
name|a_vp
operator|->
name|v_usecount
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ddep
operator|==
name|dep
condition|)
name|vrele
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
comment|/* causes msdosfs_inactive() to be called 				 * via vrele() */
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what links are. But since we already called  * msdosfs_lookup() with create and lockparent, the parent is locked so we  * have to free it before we return the error.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|VOP_ABORTOP
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
name|ap
operator|->
name|a_cnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_comment
comment|/*  * Renames on files require moving the denode to a new hash queue since the  * denode's location is used to compute which hash queue to put the file  * in. Unless it is a rename in place.  For example "mv a b".  *  * What follows is the basic algorithm:  *  * if (file move) {  *	if (dest file exists) {  *		remove dest file  *	}  *	if (dest and src in same directory) {  *		rewrite name in existing directory slot  *	} else {  *		write new entry in dest directory  *		update offset and dirclust in denode  *		move denode to new hash chain  *		clear old directory entry  *	}  * } else {  *	directory move  *	if (dest directory exists) {  *		if (dest is not empty) {  *			return ENOTEMPTY  *		}  *		remove dest directory  *	}  *	if (dest and src in same directory) {  *		rewrite name in existing entry  *	} else {  *		be sure dest is not a child of src directory  *		write entry in dest directory  *		update "." and ".." in moved directory  *		clear old directory entry for moved directory  *	}  * }  *  * On entry:  *	source's parent directory is unlocked  *	source file or directory is unlocked  *	destination's parent directory is locked  *	destination file or directory is locked if it exists  *  * On exit:  *	all denodes should be released  *  * Notes:  * I'm not sure how the memory containing the pathnames pointed at by the  * componentname structures is freed, there may be some memory bleeding  * for each rename done.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|u_char
name|toname
index|[
literal|11
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|newparent
init|=
literal|0
decl_stmt|;
name|int
name|sourceisadirectory
init|=
literal|0
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|struct
name|vnode
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|struct
name|componentname
modifier|*
name|fcnp
init|=
name|ap
operator|->
name|a_fcnp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|fcnp
operator|->
name|cn_proc
decl_stmt|;
name|struct
name|denode
modifier|*
name|fddep
decl_stmt|;
comment|/* from file's parent directory	 */
name|struct
name|denode
modifier|*
name|fdep
decl_stmt|;
comment|/* from file or directory	 */
name|struct
name|denode
modifier|*
name|tddep
decl_stmt|;
comment|/* to file's parent directory	 */
name|struct
name|denode
modifier|*
name|tdep
decl_stmt|;
comment|/* to file or directory		 */
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dotdotp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|ep
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|fddep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
name|fdep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
name|tddep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|tvp
condition|?
name|VTODE
argument_list|(
name|tvp
argument_list|)
else|:
name|NULL
expr_stmt|;
name|pmp
operator|=
name|fddep
operator|->
name|de_pmp
expr_stmt|;
comment|/* Check for cross-device rename */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_fvp
operator|->
name|v_mount
operator|!=
name|ap
operator|->
name|a_tdvp
operator|->
name|v_mount
operator|)
operator|||
operator|(
name|tvp
operator|&&
operator|(
name|ap
operator|->
name|a_fvp
operator|->
name|v_mount
operator|!=
name|tvp
operator|->
name|v_mount
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Convert the filename in tcnp into a dos filename. We copy this 	 * into the denode and directory entry for the destination 	 * file/directory. 	 */
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_nameptr
argument_list|,
name|toname
argument_list|,
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
comment|/* 	 * At this point this is the lock state of the denodes: 	 *	fddep referenced 	 *	fdep  referenced 	 *	tddep locked 	 *	tdep  locked if it exists 	 */
comment|/* 	 * Be sure we are not renaming ".", "..", or an alias of ".". This 	 * leads to a crippled directory tree.  It's pretty tough to do a 	 * "ls" or "pwd" with the "." directory entry missing, and "cd .." 	 * doesn't work if the ".." entry is missing. 	 */
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
name|fddep
operator|==
name|fdep
operator|||
operator|(
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_flags
operator||
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_flags
operator|)
operator|&
name|ISDOTDOT
condition|)
block|{
name|VOP_ABORTOP
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|vput
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|VOP_ABORTOP
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|sourceisadirectory
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we are renaming a directory, and the directory is being moved 	 * to another directory, then we must be sure the destination 	 * directory is not in the subtree of the source directory.  This 	 * could orphan everything under the source directory. 	 * doscheckpath() unlocks the destination's parent directory so we 	 * must look it up again to relock it. 	 */
if|if
condition|(
name|fddep
operator|->
name|de_StartCluster
operator|!=
name|tddep
operator|->
name|de_StartCluster
condition|)
name|newparent
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sourceisadirectory
operator|&&
name|newparent
condition|)
block|{
if|if
condition|(
name|tdep
condition|)
block|{
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* doscheckpath() vput()'s tddep */
name|error
operator|=
name|doscheckpath
argument_list|(
name|fdep
argument_list|,
name|tddep
argument_list|)
expr_stmt|;
name|tddep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_flags
operator|&
name|SAVESTART
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"msdosfs_rename(): lost to startdir"
argument_list|)
expr_stmt|;
name|error
operator|=
name|relookup
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
operator|&
name|tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|tddep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|tvp
condition|?
name|VTODE
argument_list|(
name|tvp
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the destination exists, then be sure its type (file or dir) 	 * matches that of the source.  And, if it is a directory make sure 	 * it is empty.  Then delete the destination. 	 */
if|if
condition|(
name|tdep
condition|)
block|{
if|if
condition|(
name|tdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
if|if
condition|(
operator|!
name|sourceisadirectory
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|dosdirempty
argument_list|(
name|tdep
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cache_purge
argument_list|(
name|DETOV
argument_list|(
name|tddep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* destination is file */
if|if
condition|(
name|sourceisadirectory
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|error
operator|=
name|removede
argument_list|(
name|tddep
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|vput
argument_list|(
name|ap
operator|->
name|a_tvp
argument_list|)
expr_stmt|;
name|tdep
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If the source and destination are in the same directory then 	 * just read in the directory entry, change the name in the 	 * directory entry and write it back to disk. 	 */
if|if
condition|(
name|newparent
operator|==
literal|0
condition|)
block|{
comment|/* tddep and fddep point to the same denode here */
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* ap->a_fdvp is already locked */
name|error
operator|=
name|readep
argument_list|(
name|fddep
operator|->
name|de_pmp
argument_list|,
name|fdep
operator|->
name|de_dirclust
argument_list|,
name|fdep
operator|->
name|de_diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
name|toname
argument_list|,
name|ep
operator|->
name|deName
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
name|toname
argument_list|,
name|fdep
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* update denode */
comment|/* 		 * fdep locked fddep and tddep point to the same denode 		 * which is locked tdep is NULL 		 */
block|}
else|else
block|{
name|u_long
name|dirsize
init|=
literal|0L
decl_stmt|;
comment|/* 		 * If the source and destination are in different 		 * directories, then mark the entry in the source directory 		 * as deleted and write a new entry in the destination 		 * directory.  Then move the denode to the correct hash 		 * chain for its new location in the filesystem.  And, if 		 * we moved a directory, then update its .. entry to point 		 * to the new parent directory. If we moved a directory 		 * will also insure that the directory entry on disk has a 		 * filesize of zero. 		 */
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|toname
argument_list|,
name|fdep
operator|->
name|de_Name
argument_list|,
literal|11
argument_list|)
expr_stmt|;
comment|/* update denode */
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|dirsize
operator|=
name|fdep
operator|->
name|de_FileSize
expr_stmt|;
name|fdep
operator|->
name|de_FileSize
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|createde
argument_list|(
name|fdep
argument_list|,
name|tddep
argument_list|,
operator|(
expr|struct
name|denode
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|fdep
operator|->
name|de_FileSize
operator|=
name|dirsize
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* should put back filename */
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|vn_lock
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|readep
argument_list|(
name|fddep
operator|->
name|de_pmp
argument_list|,
name|fddep
operator|->
name|de_fndclust
argument_list|,
name|fddep
operator|->
name|de_fndoffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ep
operator|->
name|deName
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|sourceisadirectory
condition|)
block|{
name|fdep
operator|->
name|de_dirclust
operator|=
name|tddep
operator|->
name|de_fndclust
expr_stmt|;
name|fdep
operator|->
name|de_diroffset
operator|=
name|tddep
operator|->
name|de_fndoffset
expr_stmt|;
name|reinsert
argument_list|(
name|fdep
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fdvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* fdep is still locked here */
comment|/* 	 * If we moved a directory to a new parent directory, then we must 	 * fixup the ".." entry in the moved directory. 	 */
if|if
condition|(
name|sourceisadirectory
operator|&&
name|newparent
condition|)
block|{
name|cn
operator|=
name|fdep
operator|->
name|de_StartCluster
expr_stmt|;
if|if
condition|(
name|cn
operator|==
name|MSDOSFSROOT
condition|)
block|{
comment|/* this should never happen */
name|panic
argument_list|(
literal|"msdosfs_rename(): updating .. in root directory?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|cn
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* should really panic here, fs is corrupt */
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dotdotp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|+
literal|1
expr_stmt|;
name|putushort
argument_list|(
name|dotdotp
operator|->
name|deStartCluster
argument_list|,
name|tddep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* should really panic here, fs is corrupt */
goto|goto
name|bad
goto|;
block|}
block|}
else|else
name|VOP_UNLOCK
argument_list|(
name|ap
operator|->
name|a_fvp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bad
label|:
empty_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|fdep
argument_list|)
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|DETOV
argument_list|(
name|fddep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
condition|)
name|vput
argument_list|(
name|DETOV
argument_list|(
name|tdep
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tddep
condition|)
name|vput
argument_list|(
name|DETOV
argument_list|(
name|tddep
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|direntry
name|dot
decl_stmt|;
name|struct
name|direntry
name|dotdot
decl_stmt|;
block|}
name|dosdirtemplate
init|=
block|{
block|{
literal|".       "
block|,
literal|"   "
block|,
comment|/* the . entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* resevered */
block|{
literal|210
block|,
literal|4
block|}
block|,
block|{
literal|210
block|,
literal|4
block|}
block|,
comment|/* time and date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* startcluster */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* filesize */
block|}
block|,
block|{
literal|"..      "
block|,
literal|"   "
block|,
comment|/* the .. entry */
name|ATTR_DIRECTORY
block|,
comment|/* file attribute */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* resevered */
block|{
literal|210
block|,
literal|4
block|}
block|,
block|{
literal|210
block|,
literal|4
block|}
block|,
comment|/* time and date */
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* startcluster */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* filesize */
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|msdosfs_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struvt vnode **a_vpp; 		struvt componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|bn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_long
name|newcluster
decl_stmt|;
name|struct
name|denode
modifier|*
name|pdep
decl_stmt|;
name|struct
name|denode
modifier|*
name|ndep
decl_stmt|;
name|struct
name|direntry
modifier|*
name|denp
decl_stmt|;
name|struct
name|denode
name|ndirent
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|u_short
name|dDate
decl_stmt|,
name|dTime
decl_stmt|;
name|pdep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the root directory and there is no space left we 	 * can't do anything.  This is because the root directory can not 	 * change size. 	 */
if|if
condition|(
name|pdep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
operator|&&
name|pdep
operator|->
name|de_fndclust
operator|==
operator|(
name|u_long
operator|)
operator|-
literal|1
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|ENOSPC
return|;
block|}
name|pmp
operator|=
name|pdep
operator|->
name|de_pmp
expr_stmt|;
comment|/* 	 * Allocate a cluster to hold the about to be created directory. 	 */
name|error
operator|=
name|clusteralloc
argument_list|(
name|pmp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|CLUST_EOFE
argument_list|,
operator|&
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Now fill the cluster with the "." and ".." entries. And write 	 * the cluster to disk.  This way it is there for the parent 	 * directory to be pointing at if there were a crash. 	 */
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|)
expr_stmt|;
comment|/* always succeeds */
name|bp
operator|=
name|getblk
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dosdirtemplate
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
sizeof|sizeof
name|dosdirtemplate
argument_list|)
expr_stmt|;
name|denp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_data
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deStartCluster
argument_list|,
name|newcluster
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|dDate
argument_list|,
operator|&
name|dTime
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deDate
argument_list|,
name|dDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deTime
argument_list|,
name|dTime
argument_list|)
expr_stmt|;
name|denp
operator|++
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deStartCluster
argument_list|,
name|pdep
operator|->
name|de_StartCluster
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deDate
argument_list|,
name|dDate
argument_list|)
expr_stmt|;
name|putushort
argument_list|(
name|denp
operator|->
name|deTime
argument_list|,
name|dTime
argument_list|)
expr_stmt|;
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 	 * Now build up a directory entry pointing to the newly allocated 	 * cluster.  This will be written to an empty slot in the parent 	 * directory. 	 */
name|ndep
operator|=
operator|&
name|ndirent
expr_stmt|;
name|bzero
argument_list|(
name|ndep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndep
argument_list|)
argument_list|)
expr_stmt|;
name|unix2dosfn
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|ndep
operator|->
name|de_Name
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_namelen
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|unix2dostime
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|ndep
operator|->
name|de_Date
argument_list|,
operator|&
name|ndep
operator|->
name|de_Time
argument_list|)
expr_stmt|;
name|ndep
operator|->
name|de_StartCluster
operator|=
name|newcluster
expr_stmt|;
name|ndep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|error
operator|=
name|createde
argument_list|(
name|ndep
argument_list|,
name|pdep
argument_list|,
operator|&
name|ndep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|clusterfree
argument_list|(
name|pmp
argument_list|,
name|newcluster
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|DETOV
argument_list|(
name|ndep
argument_list|)
expr_stmt|;
block|}
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_mkdir(): vput(%08x)\n"
argument_list|,
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|ddep
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ddep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
comment|/* parent dir of dir to delete	 */
name|dep
operator|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
comment|/* directory to delete	 */
comment|/* 	 * Be sure the directory being deleted is empty. 	 */
if|if
condition|(
name|dosdirempty
argument_list|(
name|dep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTEMPTY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Delete the entry from the directory.  For dos filesystems this 	 * gets rid of the directory entry on disk, the in memory copy 	 * still exists but the de_refcnt is<= 0.  This prevents it from 	 * being found by deget().  When the vput() on dep is done we give 	 * up access and eventually msdosfs_reclaim() will be called which 	 * will remove it from the denode cache. 	 */
name|error
operator|=
name|removede
argument_list|(
name|ddep
argument_list|,
name|dep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * This is where we decrement the link count in the parent 	 * directory.  Since dos filesystems don't do this we just purge 	 * the name cache and let go of the parent directory denode. 	 */
name|cache_purge
argument_list|(
name|DETOV
argument_list|(
name|ddep
argument_list|)
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_dvp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Truncate the directory that is being deleted. 	 */
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
name|IO_SYNC
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
empty_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_dvp
condition|)
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * DOS filesystems don't know what symlinks are.  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy dirents to simulate the "." and ".." entries of the root directory  * in a dos filesystem.  Dos doesn't provide these. Note that each entry  * must be the same size as a dos directory entry (32 bytes).  */
end_comment

begin_struct
specifier|static
struct|struct
name|dos_dirent
block|{
name|u_long
name|d_fileno
decl_stmt|;
name|u_short
name|d_reclen
decl_stmt|;
name|u_char
name|d_type
decl_stmt|;
name|u_char
name|d_namlen
decl_stmt|;
name|u_char
name|d_name
index|[
literal|24
index|]
decl_stmt|;
block|}
name|rootdots
index|[
literal|2
index|]
init|=
block|{
block|{
literal|1
block|,
comment|/* d_fileno			 */
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
block|,
comment|/* d_reclen			 */
name|DT_DIR
block|,
comment|/* d_type			 */
literal|1
block|,
comment|/* d_namlen			 */
literal|"."
comment|/* d_name			 */
block|}
block|,
block|{
literal|1
block|,
comment|/* d_fileno			 */
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
block|,
comment|/* d_reclen			 */
name|DT_DIR
block|,
comment|/* d_type			 */
literal|2
block|,
comment|/* d_namlen			 */
literal|".."
comment|/* d_name			 */
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|msdosfs_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|char
name|pushout
decl_stmt|;
name|long
name|n
decl_stmt|;
name|long
name|on
decl_stmt|;
name|long
name|lost
decl_stmt|;
name|long
name|count
decl_stmt|;
name|u_long
name|cn
decl_stmt|;
name|u_long
name|fileno
decl_stmt|;
name|long
name|bias
init|=
literal|0
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dentp
decl_stmt|;
name|struct
name|dirent
modifier|*
name|prev
decl_stmt|;
name|struct
name|dirent
modifier|*
name|crnt
decl_stmt|;
name|u_char
name|dirbuf
index|[
literal|512
index|]
decl_stmt|;
comment|/* holds converted dos directories */
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_readdir(): vp %08x, uio %08x, cred %08x, eofflagp %08x\n"
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * msdosfs_readdir() won't operate properly on regular files since 	 * it does i/o only with the the filesystem vnode, and hence can 	 * retrieve the wrong block from the buffer cache for a plain file. 	 * So, fail attempts to readdir() on a plain file. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOTDIR
return|;
comment|/* 	 * If the user buffer is smaller than the size of one dos directory 	 * entry or the file offset is not a multiple of the size of a 	 * directory entry, then we fail the read. 	 */
name|count
operator|=
name|uio
operator|->
name|uio_resid
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|lost
operator|=
name|uio
operator|->
name|uio_resid
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|||
operator|(
name|uio
operator|->
name|uio_offset
operator|&
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
name|uio
operator|->
name|uio_resid
operator|=
name|count
expr_stmt|;
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|=
name|count
expr_stmt|;
name|off
operator|=
name|uio
operator|->
name|uio_offset
expr_stmt|;
comment|/* 	 * If they are reading from the root directory then, we simulate 	 * the . and .. entries since these don't exist in the root 	 * directory.  We also set the offset bias to make up for having to 	 * simulate these entries. By this I mean that at file offset 64 we 	 * read the first entry in the root directory that lives on disk. 	 */
if|if
condition|(
name|dep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
condition|)
block|{
comment|/* 		 * printf("msdosfs_readdir(): going after . or .. in root dir, offset %d\n", 		 *	  uio->uio_offset); 		 */
name|bias
operator|=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|&&
name|uio
operator|->
name|uio_offset
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|uio
operator|->
name|uio_offset
condition|)
block|{
name|n
operator|=
literal|2
expr_stmt|;
name|ncookies
operator|++
expr_stmt|;
block|}
name|ncookies
operator|++
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|rootdots
operator|+
name|uio
operator|->
name|uio_offset
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|error
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|lbn
operator|=
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|on
operator|=
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
operator|&
name|pmp
operator|->
name|pm_crbomask
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|on
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|diff
operator|=
name|dep
operator|->
name|de_FileSize
operator|-
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
name|diff
operator|<
name|n
condition|)
name|n
operator|=
name|diff
expr_stmt|;
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|lbn
argument_list|,
operator|&
name|bn
argument_list|,
operator|&
name|cn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|n
operator|=
name|min
argument_list|(
name|n
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|bp
operator|->
name|b_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* 		 * code to convert from dos directory entries to ufs 		 * directory entries 		 */
name|pushout
operator|=
literal|0
expr_stmt|;
name|dentp
operator|=
operator|(
expr|struct
name|direntry
operator|*
operator|)
operator|(
name|bp
operator|->
name|b_data
operator|+
name|on
operator|)
expr_stmt|;
name|prev
operator|=
literal|0
expr_stmt|;
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|dirbuf
expr_stmt|;
while|while
condition|(
operator|(
name|char
operator|*
operator|)
name|dentp
operator|<
name|bp
operator|->
name|b_data
operator|+
name|on
operator|+
name|n
condition|)
block|{
comment|/* 			 * printf("rd: dentp %08x prev %08x crnt %08x deName %02x attr %02x\n", 			 *	  dentp, prev, crnt, dentp->deName[0], dentp->deAttributes); 			 */
comment|/* 			 * If we have an empty entry or a slot from a 			 * deleted file, or a volume label entry just 			 * concatenate its space onto the end of the 			 * previous entry or, manufacture an empty entry if 			 * there is no previous entry. 			 */
if|if
condition|(
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_EMPTY
operator|||
name|dentp
operator|->
name|deName
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
operator|||
operator|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_VOLUME
operator|)
condition|)
block|{
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|d_reclen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|=
name|crnt
expr_stmt|;
name|prev
operator|->
name|d_fileno
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|prev
operator|->
name|d_type
operator|=
name|DT_UNKNOWN
expr_stmt|;
name|prev
operator|->
name|d_namlen
operator|=
literal|0
expr_stmt|;
name|prev
operator|->
name|d_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ncookies
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * this computation of d_fileno must match 				 * the computation of va_fileid in 				 * msdosfs_getattr 				 */
if|if
condition|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* if this is the root directory */
name|fileno
operator|=
name|getushort
argument_list|(
name|dentp
operator|->
name|deStartCluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|fileno
operator|==
name|MSDOSFSROOT
condition|)
name|fileno
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * if the file's dirent lives in 					 * root dir 					 */
if|if
condition|(
operator|(
name|fileno
operator|=
name|cn
operator|)
operator|==
name|MSDOSFSROOT
condition|)
name|fileno
operator|=
literal|1
expr_stmt|;
name|fileno
operator|=
operator|(
name|fileno
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
name|dentp
operator|-
operator|(
expr|struct
name|direntry
operator|*
operator|)
name|bp
operator|->
name|b_data
operator|)
operator|&
literal|0xffff
operator|)
expr_stmt|;
block|}
name|crnt
operator|->
name|d_fileno
operator|=
name|fileno
expr_stmt|;
name|crnt
operator|->
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
expr_stmt|;
name|crnt
operator|->
name|d_type
operator|=
operator|(
name|dentp
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
operator|)
condition|?
name|DT_DIR
else|:
name|DT_REG
expr_stmt|;
name|crnt
operator|->
name|d_namlen
operator|=
name|dos2unixfn
argument_list|(
name|dentp
operator|->
name|deName
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|crnt
operator|->
name|d_name
argument_list|)
expr_stmt|;
comment|/* 				 * printf("readdir: file %s, fileno %08x, attr %02x, start %08x\n", 				 *	  crnt->d_name, crnt->d_fileno, dentp->deAttributes, 				 *	  dentp->deStartCluster); 				 */
name|prev
operator|=
name|crnt
expr_stmt|;
name|ncookies
operator|++
expr_stmt|;
block|}
name|dentp
operator|++
expr_stmt|;
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|crnt
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|direntry
argument_list|)
operator|)
expr_stmt|;
name|pushout
operator|=
literal|1
expr_stmt|;
comment|/* 			 * If our intermediate buffer is full then copy its 			 * contents to user space.  I would just use the 			 * buffer the buf header points to but, I'm afraid 			 * that when we brelse() it someone else might find 			 * it in the cache and think its contents are 			 * valid.  Maybe there is a way to invalidate the 			 * buffer before brelse()'ing it. 			 */
if|if
condition|(
operator|(
name|u_char
operator|*
operator|)
name|crnt
operator|>=
operator|&
name|dirbuf
index|[
sizeof|sizeof
name|dirbuf
index|]
condition|)
block|{
name|pushout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|prev
operator|=
literal|0
expr_stmt|;
name|crnt
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|dirbuf
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pushout
condition|)
block|{
name|pushout
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|dirbuf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|crnt
operator|-
operator|(
name|char
operator|*
operator|)
name|dirbuf
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* 		 * If we have read everything from this block or have read 		 * to end of file then we are done with this block.  Mark 		 * it to say the buffer can be reused if need be. 		 */
block|if (n + on == pmp->pm_bpcluster || 		    (uio->uio_offset - bias) == dep->de_FileSize) 			bp->b_flags |= B_AGE;
endif|#
directive|endif
comment|/* if 0 */
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
block|}
name|out
label|:
empty_stmt|;
name|uio
operator|->
name|uio_resid
operator|+=
name|lost
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dirent
modifier|*
name|dpStart
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dpEnd
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|u_long
modifier|*
name|cookies
decl_stmt|;
name|u_long
modifier|*
name|cookiep
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"msdosfs_readdir: unexpected uio from NFS server"
argument_list|)
expr_stmt|;
name|dpStart
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
operator|-
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|off
operator|)
operator|)
expr_stmt|;
name|dpEnd
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|uio
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
name|cookies
operator|=
name|malloc
argument_list|(
name|ncookies
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cookies
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|dpStart
operator|,
name|cookiep
operator|=
name|cookies
init|;
name|dp
operator|<
name|dpEnd
condition|;
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|dp
operator|+
name|dp
operator|->
name|d_reclen
operator|)
control|)
block|{
name|off
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
operator|*
name|cookiep
operator|++
operator|=
operator|(
name|u_long
operator|)
name|off
expr_stmt|;
block|}
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
name|ncookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_cookies
operator|=
name|cookies
expr_stmt|;
block|}
comment|/* 	 * Set the eofflag (NFS uses it) 	 */
if|if
condition|(
name|ap
operator|->
name|a_eofflag
condition|)
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|-
operator|(
name|uio
operator|->
name|uio_offset
operator|-
name|bias
operator|)
operator|<=
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|1
expr_stmt|;
else|else
operator|*
name|ap
operator|->
name|a_eofflag
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_abortop
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_abortop_args
comment|/* { 		struct vnode *a_dvp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
operator|(
name|HASBUF
operator||
name|SAVESTART
operator|)
operator|)
operator|==
name|HASBUF
condition|)
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * vp  - address of vnode file the file  * bn  - which cluster we are interested in mapping to a filesystem block number.  * vpp - returns the vnode for the block special file holding the filesystem  *	 containing the file of interest  * bnp - address of where to return the filesystem relative block number  */
end_comment

begin_function
specifier|static
name|int
name|msdosfs_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t a_bn; 		struct vnode **a_vpp; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vpp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|dep
operator|->
name|de_devvp
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ap
operator|->
name|a_runp
condition|)
block|{
comment|/* 		 * Sequential clusters should be counted here. 		 */
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_runb
condition|)
block|{
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|ap
operator|->
name|a_bn
argument_list|,
name|ap
operator|->
name|a_bnp
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_strategy
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_strategy_args
comment|/* { 		struct buf *a_bp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
init|=
name|ap
operator|->
name|a_bp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|panic
argument_list|(
literal|"msdosfs_strategy: spec"
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't already know the filesystem relative block number 	 * then get it using pcbmap().  If pcbmap() returns the block 	 * number as -1 then we've got a hole in the file.  DOS filesystems 	 * don't allow files with holes, so we shouldn't ever see this. 	 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
name|bp
operator|->
name|b_lblkno
condition|)
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|bp
operator|->
name|b_blkno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|==
operator|-
literal|1
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
endif|#
directive|endif
comment|/* 	 * Read/write the block from/to the disk that contains the desired 	 * file block. 	 */
name|vp
operator|=
name|dep
operator|->
name|de_devvp
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
name|VOCALL
argument_list|(
name|vp
operator|->
name|v_op
argument_list|,
name|VOFFSET
argument_list|(
name|vop_strategy
argument_list|)
argument_list|,
name|ap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_print
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_print_args
comment|/* { 		struct vnode *vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"tag VT_MSDOSFS, startcluster %d, dircluster %ld, diroffset %ld "
argument_list|,
name|dep
operator|->
name|de_StartCluster
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dev %d, %d"
argument_list|,
name|major
argument_list|(
name|dep
operator|->
name|de_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|dep
operator|->
name|de_dev
argument_list|)
argument_list|)
expr_stmt|;
name|lockmgr_printinfo
argument_list|(
operator|&
name|dep
operator|->
name|de_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msdosfs_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		int *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|_PC_NAME_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|12
expr_stmt|;
return|return
literal|0
return|;
case|case
name|_PC_PATH_MAX
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|PATH_MAX
expr_stmt|;
comment|/* 255? */
return|return
literal|0
return|;
case|case
name|_PC_CHOWN_RESTRICTED
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|_PC_NO_TRUNC
case|:
operator|*
name|ap
operator|->
name|a_retval
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_comment
comment|/* Global vfs data structures for msdosfs */
end_comment

begin_decl_stmt
name|vop_t
modifier|*
modifier|*
name|msdosfs_vnodeop_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_entry_desc
name|msdosfs_vnodeop_entries
index|[]
init|=
block|{
block|{
operator|&
name|vop_default_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_defaultop
block|}
block|,
block|{
operator|&
name|vop_abortop_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_abortop
block|}
block|,
block|{
operator|&
name|vop_access_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_access
block|}
block|,
block|{
operator|&
name|vop_bmap_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_bmap
block|}
block|,
block|{
operator|&
name|vop_cachedlookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_lookup
block|}
block|,
block|{
operator|&
name|vop_close_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_close
block|}
block|,
block|{
operator|&
name|vop_create_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_create
block|}
block|,
block|{
operator|&
name|vop_fsync_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_fsync
block|}
block|,
block|{
operator|&
name|vop_getattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_getattr
block|}
block|,
block|{
operator|&
name|vop_inactive_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_inactive
block|}
block|,
block|{
operator|&
name|vop_islocked_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdislocked
block|}
block|,
block|{
operator|&
name|vop_link_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_link
block|}
block|,
block|{
operator|&
name|vop_lock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdlock
block|}
block|,
block|{
operator|&
name|vop_lookup_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vfs_cache_lookup
block|}
block|,
block|{
operator|&
name|vop_mkdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_mkdir
block|}
block|,
block|{
operator|&
name|vop_mknod_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_mknod
block|}
block|,
block|{
operator|&
name|vop_pathconf_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_pathconf
block|}
block|,
block|{
operator|&
name|vop_print_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_print
block|}
block|,
block|{
operator|&
name|vop_read_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_read
block|}
block|,
block|{
operator|&
name|vop_readdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_readdir
block|}
block|,
block|{
operator|&
name|vop_reclaim_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_reclaim
block|}
block|,
block|{
operator|&
name|vop_remove_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_remove
block|}
block|,
block|{
operator|&
name|vop_rename_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_rename
block|}
block|,
block|{
operator|&
name|vop_rmdir_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_rmdir
block|}
block|,
block|{
operator|&
name|vop_setattr_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_setattr
block|}
block|,
block|{
operator|&
name|vop_strategy_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_strategy
block|}
block|,
block|{
operator|&
name|vop_symlink_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_symlink
block|}
block|,
block|{
operator|&
name|vop_unlock_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|vop_stdunlock
block|}
block|,
block|{
operator|&
name|vop_write_desc
block|,
operator|(
name|vop_t
operator|*
operator|)
name|msdosfs_write
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vnodeopv_desc
name|msdosfs_vnodeop_opv_desc
init|=
block|{
operator|&
name|msdosfs_vnodeop_p
block|,
name|msdosfs_vnodeop_entries
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNODEOP_SET
argument_list|(
name|msdosfs_vnodeop_opv_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

