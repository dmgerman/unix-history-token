begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: msdosfs_denode.c,v 1.9 1995/03/16 18:14:18 bde Exp $ */
end_comment

begin_comment
comment|/*	$NetBSD: msdosfs_denode.c,v 1.9 1994/08/21 18:44:00 ws Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (C) 1994 Wolfgang Solfrank.  * Copyright (C) 1994 TooLs GmbH.  * All rights reserved.  * Original code by Paul Popelka (paulp@uts.amdahl.com) (see below).  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by TooLs GmbH.  * 4. The name of TooLs GmbH may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY TOOLS GMBH ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL TOOLS GMBH BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;  * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR  * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF  * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Written by Paul Popelka (paulp@uts.amdahl.com)  *   * You can do anything you want with this software, just don't say you wrote  * it, and don't remove this notice.  *   * This software is provided "as is".  *   * The author supplies this software to be publicly redistributed on the  * understanding that the author is not responsible for the correct  * functioning of this software in any circumstances and is not liable for  * any damages caused by this software.  *   * October 1992  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_comment
comment|/* defines "time" */
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/bpb.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/msdosfsmount.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/direntry.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/denode.h>
end_include

begin_include
include|#
directive|include
file|<msdosfs/fat.h>
end_include

begin_decl_stmt
name|struct
name|denode
modifier|*
modifier|*
name|dehashtbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|dehash
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of hash table - 1 */
end_comment

begin_define
define|#
directive|define
name|DEHASH
parameter_list|(
name|dev
parameter_list|,
name|deno
parameter_list|)
value|(((dev) + (deno))& dehash)
end_define

begin_function
name|int
name|msdosfs_init
parameter_list|()
block|{
name|dehashtbl
operator|=
name|hashinit
argument_list|(
name|desiredvnodes
operator|/
literal|2
argument_list|,
name|M_MSDOSFSMNT
argument_list|,
operator|&
name|dehash
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|denode
modifier|*
name|msdosfs_hashget
parameter_list|(
name|dev
parameter_list|,
name|dirclust
parameter_list|,
name|diroff
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|dirclust
decl_stmt|;
name|u_long
name|diroff
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
for|for
control|(
name|dep
operator|=
name|dehashtbl
index|[
name|DEHASH
argument_list|(
name|dev
argument_list|,
name|dirclust
operator|+
name|diroff
argument_list|)
index|]
init|;
condition|;
name|dep
operator|=
name|dep
operator|->
name|de_next
control|)
block|{
if|if
condition|(
name|dep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|dirclust
operator|!=
name|dep
operator|->
name|de_dirclust
operator|||
name|diroff
operator|!=
name|dep
operator|->
name|de_diroffset
operator|||
name|dev
operator|!=
name|dep
operator|->
name|de_dev
operator|||
name|dep
operator|->
name|de_refcnt
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_LOCKED
condition|)
block|{
name|dep
operator|->
name|de_flag
operator||=
name|DE_WANTED
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|dep
argument_list|,
name|PINOD
argument_list|,
literal|"msdhgt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|vget
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
name|dep
return|;
break|break;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
specifier|static
name|void
name|msdosfs_hashins
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
modifier|*
name|depp
decl_stmt|,
modifier|*
name|deq
decl_stmt|;
name|depp
operator|=
operator|&
name|dehashtbl
index|[
name|DEHASH
argument_list|(
name|dep
operator|->
name|de_dev
argument_list|,
name|dep
operator|->
name|de_dirclust
operator|+
name|dep
operator|->
name|de_diroffset
argument_list|)
index|]
expr_stmt|;
name|deq
operator|=
operator|*
name|depp
expr_stmt|;
if|if
condition|(
name|deq
condition|)
name|deq
operator|->
name|de_prev
operator|=
operator|&
name|dep
operator|->
name|de_next
expr_stmt|;
name|dep
operator|->
name|de_next
operator|=
name|deq
expr_stmt|;
name|dep
operator|->
name|de_prev
operator|=
name|depp
expr_stmt|;
operator|*
name|depp
operator|=
name|dep
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_LOCKED
condition|)
name|panic
argument_list|(
literal|"msdosfs_hashins: already locked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
condition|)
name|dep
operator|->
name|de_lockholder
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
else|else
name|dep
operator|->
name|de_lockholder
operator|=
operator|-
literal|1
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_LOCKED
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msdosfs_hashrem
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
name|struct
name|denode
modifier|*
name|deq
decl_stmt|;
name|deq
operator|=
name|dep
operator|->
name|de_next
expr_stmt|;
if|if
condition|(
name|deq
condition|)
name|deq
operator|->
name|de_prev
operator|=
name|dep
operator|->
name|de_prev
expr_stmt|;
operator|*
name|dep
operator|->
name|de_prev
operator|=
name|deq
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|dep
operator|->
name|de_next
operator|=
name|NULL
expr_stmt|;
name|dep
operator|->
name|de_prev
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * If deget() succeeds it returns with the gotten denode locked().   *  * pmp	     - address of msdosfsmount structure of the filesystem containing  *	       the denode of interest.  The pm_dev field and the address of  *	       the msdosfsmount structure are used.   * dirclust  - which cluster bp contains, if dirclust is 0 (root directory)  *	       diroffset is relative to the beginning of the root directory,  *	       otherwise it is cluster relative.   * diroffset - offset past begin of cluster of denode we want   * direntptr - address of the direntry structure of interest. If direntptr is  *	       NULL, the block is read if necessary.   * depp	     - returns the address of the gotten denode.  */
end_comment

begin_function
name|int
name|deget
parameter_list|(
name|pmp
parameter_list|,
name|dirclust
parameter_list|,
name|diroffset
parameter_list|,
name|direntptr
parameter_list|,
name|depp
parameter_list|)
name|struct
name|msdosfsmount
modifier|*
name|pmp
decl_stmt|;
comment|/* so we know the maj/min number */
name|u_long
name|dirclust
decl_stmt|;
comment|/* cluster this dir entry came from */
name|u_long
name|diroffset
decl_stmt|;
comment|/* index of entry within the cluster */
name|struct
name|direntry
modifier|*
name|direntptr
decl_stmt|;
name|struct
name|denode
modifier|*
modifier|*
name|depp
decl_stmt|;
comment|/* returns the addr of the gotten denode */
block|{
name|int
name|error
decl_stmt|;
name|dev_t
name|dev
init|=
name|pmp
operator|->
name|pm_dev
decl_stmt|;
name|struct
name|mount
modifier|*
name|mntp
init|=
name|pmp
operator|->
name|pm_mountp
decl_stmt|;
name|struct
name|denode
modifier|*
name|ldep
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"deget(pmp %p, dirclust %ld, diroffset %x, direntptr %p, depp %p)\n"
argument_list|,
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
name|direntptr
argument_list|,
name|depp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If dir entry is given and refers to a directory, convert to 	 * canonical form 	 */
if|if
condition|(
name|direntptr
operator|&&
operator|(
name|direntptr
operator|->
name|deAttributes
operator|&
name|ATTR_DIRECTORY
operator|)
condition|)
block|{
name|dirclust
operator|=
name|getushort
argument_list|(
name|direntptr
operator|->
name|deStartCluster
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirclust
operator|==
name|MSDOSFSROOT
condition|)
name|diroffset
operator|=
name|MSDOSFSROOT_OFS
expr_stmt|;
else|else
name|diroffset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * See if the denode is in the denode cache. Use the location of 	 * the directory entry to compute the hash value. For subdir use 	 * address of "." entry. for root dir use cluster MSDOSFSROOT, 	 * offset MSDOSFSROOT_OFS 	 *  	 * NOTE: The check for de_refcnt> 0 below insures the denode being 	 * examined does not represent an unlinked but still open file. 	 * These files are not to be accessible even when the directory 	 * entry that represented the file happens to be reused while the 	 * deleted file is still open. 	 */
name|ldep
operator|=
name|msdosfs_hashget
argument_list|(
name|dev
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldep
condition|)
block|{
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Directory entry was not in cache, have to create a vnode and 	 * copy it from the passed disk buffer. 	 */
comment|/* getnewvnode() does a VREF() on the vnode */
name|error
operator|=
name|getnewvnode
argument_list|(
name|VT_MSDOSFS
argument_list|,
name|mntp
argument_list|,
name|msdosfs_vnodeop_p
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|depp
operator|=
literal|0
expr_stmt|;
return|return
name|error
return|;
block|}
name|MALLOC
argument_list|(
name|ldep
argument_list|,
expr|struct
name|denode
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|denode
argument_list|)
argument_list|,
name|M_MSDOSFSNODE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ldep
argument_list|,
sizeof|sizeof
expr|*
name|ldep
argument_list|)
expr_stmt|;
name|nvp
operator|->
name|v_data
operator|=
name|ldep
expr_stmt|;
name|ldep
operator|->
name|de_vnode
operator|=
name|nvp
expr_stmt|;
name|ldep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_lockf
operator|=
literal|0
expr_stmt|;
name|ldep
operator|->
name|de_dev
operator|=
name|dev
expr_stmt|;
name|ldep
operator|->
name|de_dirclust
operator|=
name|dirclust
expr_stmt|;
name|ldep
operator|->
name|de_diroffset
operator|=
name|diroffset
expr_stmt|;
name|fc_purge
argument_list|(
name|ldep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* init the fat cache for this denode */
comment|/* 	 * Insert the denode into the hash queue and lock the denode so it 	 * can't be accessed until we've read it in and have done what we 	 * need to it. 	 */
name|msdosfs_hashins
argument_list|(
name|ldep
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the directory entry into the denode area of the vnode. 	 */
if|if
condition|(
name|dirclust
operator|==
name|MSDOSFSROOT
operator|&&
name|diroffset
operator|==
name|MSDOSFSROOT_OFS
condition|)
block|{
comment|/* 		 * Directory entry for the root directory. There isn't one, 		 * so we manufacture one. We should probably rummage 		 * through the root directory and find a label entry (if it 		 * exists), and then use the time and date from that entry 		 * as the time and date for the root denode. 		 */
name|ldep
operator|->
name|de_Attributes
operator|=
name|ATTR_DIRECTORY
expr_stmt|;
name|ldep
operator|->
name|de_StartCluster
operator|=
name|MSDOSFSROOT
expr_stmt|;
name|ldep
operator|->
name|de_FileSize
operator|=
name|pmp
operator|->
name|pm_rootdirsize
operator|*
name|pmp
operator|->
name|pm_BytesPerSec
expr_stmt|;
comment|/* 		 * fill in time and date so that dos2unixtime() doesn't 		 * spit up when called from msdosfs_getattr() with root 		 * denode 		 */
name|ldep
operator|->
name|de_Time
operator|=
literal|0x0000
expr_stmt|;
comment|/* 00:00:00	 */
name|ldep
operator|->
name|de_Date
operator|=
operator|(
literal|0
operator|<<
name|DD_YEAR_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_MONTH_SHIFT
operator|)
operator||
operator|(
literal|1
operator|<<
name|DD_DAY_SHIFT
operator|)
expr_stmt|;
comment|/* Jan 1, 1980	 */
comment|/* leave the other fields as garbage */
block|}
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|direntptr
condition|)
block|{
name|error
operator|=
name|readep
argument_list|(
name|pmp
argument_list|,
name|dirclust
argument_list|,
name|diroffset
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|DE_INTERNALIZE
argument_list|(
name|ldep
argument_list|,
name|direntptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in a few fields of the vnode and finish filling in the 	 * denode.  Then return the address of the found denode. 	 */
name|ldep
operator|->
name|de_pmp
operator|=
name|pmp
expr_stmt|;
name|ldep
operator|->
name|de_devvp
operator|=
name|pmp
operator|->
name|pm_devvp
expr_stmt|;
name|ldep
operator|->
name|de_refcnt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
comment|/* 		 * Since DOS directory entries that describe directories 		 * have 0 in the filesize field, we take this opportunity 		 * to find out the length of the directory and plug it into 		 * the denode structure. 		 */
name|u_long
name|size
decl_stmt|;
name|nvp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
if|if
condition|(
name|ldep
operator|->
name|de_StartCluster
operator|==
name|MSDOSFSROOT
condition|)
name|nvp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|ldep
argument_list|,
literal|0xffff
argument_list|,
literal|0
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E2BIG
condition|)
block|{
name|ldep
operator|->
name|de_FileSize
operator|=
name|size
operator|<<
name|pmp
operator|->
name|pm_cnshift
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"deget(): pcbmap returned %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|nvp
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
name|VREF
argument_list|(
name|ldep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
operator|*
name|depp
operator|=
name|ldep
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|deupdat
parameter_list|(
name|dep
parameter_list|,
name|tp
parameter_list|,
name|waitfor
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|struct
name|timespec
modifier|*
name|tp
decl_stmt|;
name|int
name|waitfor
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|direntry
modifier|*
name|dirp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|DETOV
argument_list|(
name|dep
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"deupdat(): dep %p\n"
argument_list|,
name|dep
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the denode-modified and update-mtime bits are off, 	 * or this denode is from a readonly filesystem, 	 * or this denode is for a directory, 	 * or the denode represents an open but unlinked file, 	 * then don't do anything.  DOS directory 	 * entries that describe a directory do not ever get 	 * updated.  This is the way DOS treats them. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_flag
operator|&
operator|(
name|DE_MODIFIED
operator||
name|DE_UPDATE
operator|)
operator|)
operator|==
literal|0
operator|||
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|||
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|||
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* 	 * Read in the cluster containing the directory entry we want to 	 * update. 	 */
name|error
operator|=
name|readde
argument_list|(
name|dep
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|dirp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * If the mtime is to be updated, put the passed in time into the 	 * directory entry. 	 */
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
name|DE_UPDATE
condition|)
block|{
name|dep
operator|->
name|de_Attributes
operator||=
name|ATTR_ARCHIVE
expr_stmt|;
name|unix2dostime
argument_list|(
name|tp
argument_list|,
operator|&
name|dep
operator|->
name|de_Date
argument_list|,
operator|&
name|dep
operator|->
name|de_Time
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The mtime is now up to date.  The denode will be unmodifed soon. 	 */
name|dep
operator|->
name|de_flag
operator|&=
operator|~
operator|(
name|DE_MODIFIED
operator||
name|DE_UPDATE
operator|)
expr_stmt|;
comment|/* 	 * Copy the directory entry out of the denode into the cluster it 	 * came from. 	 */
name|DE_EXTERNALIZE
argument_list|(
name|dirp
argument_list|,
name|dep
argument_list|)
expr_stmt|;
comment|/* 	 * Write the cluster back to disk.  If they asked for us to wait 	 * for the write to complete, then use bwrite() otherwise use 	 * bdwrite(). 	 */
name|error
operator|=
literal|0
expr_stmt|;
comment|/* note that error is 0 from above, but ... */
if|if
condition|(
name|waitfor
condition|)
name|error
operator|=
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Truncate the file described by dep to the length specified by length.  */
end_comment

begin_function
name|int
name|detrunc
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|flags
parameter_list|,
name|cred
parameter_list|,
name|p
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|u_long
name|length
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|allerror
decl_stmt|;
name|int
name|vflags
decl_stmt|;
name|u_long
name|eofentry
decl_stmt|;
name|u_long
name|chaintofree
decl_stmt|;
name|daddr_t
name|bn
decl_stmt|;
name|int
name|boff
decl_stmt|;
name|int
name|isadir
init|=
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): file %s, length %d, flags %d\n"
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Disallow attempts to truncate the root directory since it is of 	 * fixed size.  That's just the way dos filesystems are.  We use 	 * the VROOT bit in the vnode because checking for the directory 	 * bit and a startcluster of 0 in the denode is not adequate to 	 * recognize the root directory at this point in a file or 	 * directory's life. 	 */
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
name|printf
argument_list|(
literal|"detrunc(): can't truncate root directory, clust %ld, offset %ld\n"
argument_list|,
name|dep
operator|->
name|de_dirclust
argument_list|,
name|dep
operator|->
name|de_diroffset
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|vnode_pager_setsize
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_FileSize
operator|<
name|length
condition|)
return|return
name|deextend
argument_list|(
name|dep
argument_list|,
name|length
argument_list|,
name|cred
argument_list|)
return|;
comment|/* 	 * If the desired length is 0 then remember the starting cluster of 	 * the file and set the StartCluster field in the directory entry 	 * to 0.  If the desired length is not zero, then get the number of 	 * the last cluster in the shortened file.  Then get the number of 	 * the first cluster in the part of the file that is to be freed. 	 * Then set the next cluster pointer in the last cluster of the 	 * file to CLUST_EOFE. 	 */
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|chaintofree
operator|=
name|dep
operator|->
name|de_StartCluster
expr_stmt|;
name|dep
operator|->
name|de_StartCluster
operator|=
literal|0
expr_stmt|;
name|eofentry
operator|=
operator|~
literal|0
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|pcbmap
argument_list|(
name|dep
argument_list|,
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|eofentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): pcbmap fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
block|}
name|fc_purge
argument_list|(
name|dep
argument_list|,
operator|(
name|length
operator|+
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|)
expr_stmt|;
comment|/* 	 * If the new length is not a multiple of the cluster size then we 	 * must zero the tail end of the new last cluster in case it 	 * becomes part of the file again because of a seek. 	 */
if|if
condition|(
operator|(
name|boff
operator|=
name|length
operator|&
name|pmp
operator|->
name|pm_crbomask
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * should read from file vnode or filesystem vnode 		 * depending on if file or dir 		 */
if|if
condition|(
name|isadir
condition|)
block|{
name|bn
operator|=
name|cntobn
argument_list|(
name|pmp
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|pmp
operator|->
name|pm_devvp
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bn
operator|=
name|de_blk
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|bread
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|bn
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): bread fails %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
comment|/* 		 * is this the right place for it? 		 */
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|boff
argument_list|,
name|pmp
operator|->
name|pm_bpcluster
operator|-
name|boff
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IO_SYNC
condition|)
name|bwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bdwrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Write out the updated directory entry.  Even if the update fails 	 * we free the trailing clusters. 	 */
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
name|vflags
operator|=
operator|(
name|length
operator|>
literal|0
condition|?
name|V_SAVE
else|:
literal|0
operator|)
operator||
name|V_SAVEMETA
expr_stmt|;
name|vinvalbuf
argument_list|(
name|DETOV
argument_list|(
name|dep
argument_list|)
argument_list|,
name|vflags
argument_list|,
name|cred
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|allerror
operator|=
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): allerror %d, eofentry %d\n"
argument_list|,
name|allerror
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we need to break the cluster chain for the file then do it 	 * now. 	 */
if|if
condition|(
name|eofentry
operator|!=
operator|~
literal|0
condition|)
block|{
name|error
operator|=
name|fatentry
argument_list|(
name|FAT_GET_AND_SET
argument_list|,
name|pmp
argument_list|,
name|eofentry
argument_list|,
operator|&
name|chaintofree
argument_list|,
name|CLUST_EOFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"detrunc(): fatentry errors %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
name|fc_setcache
argument_list|(
name|dep
argument_list|,
name|FC_LASTFC
argument_list|,
operator|(
name|length
operator|-
literal|1
operator|)
operator|>>
name|pmp
operator|->
name|pm_cnshift
argument_list|,
name|eofentry
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now free the clusters removed from the file because of the 	 * truncation. 	 */
if|if
condition|(
name|chaintofree
operator|!=
literal|0
operator|&&
operator|!
name|MSDOSFSEOF
argument_list|(
name|chaintofree
argument_list|)
condition|)
name|freeclusterchain
argument_list|(
name|pmp
argument_list|,
name|chaintofree
argument_list|)
expr_stmt|;
return|return
name|allerror
return|;
block|}
end_function

begin_comment
comment|/*  * Extend the file described by dep to length specified by length.  */
end_comment

begin_function
name|int
name|deextend
parameter_list|(
name|dep
parameter_list|,
name|length
parameter_list|,
name|cred
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
name|off_t
name|length
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
name|struct
name|msdosfsmount
modifier|*
name|pmp
init|=
name|dep
operator|->
name|de_pmp
decl_stmt|;
name|u_long
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* 	 * The root of a DOS filesystem cannot be extended. 	 */
if|if
condition|(
name|DETOV
argument_list|(
name|dep
argument_list|)
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Directories can only be extended by the superuser. 	 * Is this really important? 	 */
if|if
condition|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
condition|)
block|{
name|error
operator|=
name|suser
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|length
operator|<=
name|dep
operator|->
name|de_FileSize
condition|)
name|panic
argument_list|(
literal|"deextend: file too large"
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the number of clusters to allocate. 	 */
name|count
operator|=
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|length
argument_list|)
operator|-
name|de_clcount
argument_list|(
name|pmp
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|>
name|pmp
operator|->
name|pm_freeclustercount
condition|)
return|return
name|ENOSPC
return|;
name|error
operator|=
name|extendfile
argument_list|(
name|dep
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DE_CLEAR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* truncate the added clusters away again */
operator|(
name|void
operator|)
name|detrunc
argument_list|(
name|dep
argument_list|,
name|dep
operator|->
name|de_FileSize
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
name|dep
operator|->
name|de_FileSize
operator|=
name|length
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
return|return
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move a denode to its correct hash queue after the file it represents has  * been moved to a new directory.  */
end_comment

begin_function
name|int
name|reinsert
parameter_list|(
name|dep
parameter_list|)
name|struct
name|denode
modifier|*
name|dep
decl_stmt|;
block|{
comment|/* 	 * Fix up the denode cache.  If the denode is for a directory, 	 * there is nothing to do since the hash is based on the starting 	 * cluster of the directory file and that hasn't changed.  If for a 	 * file the hash is based on the location of the directory entry, 	 * so we must remove it from the cache and re-enter it with the 	 * hash based on the new location of the directory entry. 	 */
if|if
condition|(
operator|(
name|dep
operator|->
name|de_Attributes
operator|&
name|ATTR_DIRECTORY
operator|)
operator|==
literal|0
condition|)
block|{
name|msdosfs_hashrem
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|msdosfs_hashins
argument_list|(
name|dep
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_reclaim(): dep %p, file %s, refcnt %ld\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_reclaim(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the denode from the denode hash chain we are in. 	 */
name|msdosfs_hashrem
argument_list|(
name|dep
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Indicate that one less file on the filesystem is open. 	 */
if|if
condition|(
name|dep
operator|->
name|de_devvp
condition|)
block|{
name|vrele
argument_list|(
name|dep
operator|->
name|de_devvp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_devvp
operator|=
literal|0
expr_stmt|;
block|}
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|dep
argument_list|,
name|M_MSDOSFSNODE
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|msdosfs_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|denode
modifier|*
name|dep
init|=
name|VTODE
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %p, de_Name[0] %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|prtactive
operator|&&
name|vp
operator|->
name|v_usecount
operator|!=
literal|0
condition|)
name|vprint
argument_list|(
literal|"msdosfs_inactive(): pushing active"
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of denodes related to stale file handles. Hmmm, what 	 * does this really do? 	 */
if|if
condition|(
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VXLOCK
operator|)
operator|==
literal|0
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If the file has been deleted and it is on a read/write 	 * filesystem, then truncate the file, and mark the directory slot 	 * as empty.  (This may not be necessary for the dos filesystem.) 	 */
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): dep %p, refcnt %ld, mntflag %x, MNT_RDONLY %x\n"
argument_list|,
name|dep
argument_list|,
name|dep
operator|->
name|de_refcnt
argument_list|,
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
argument_list|,
name|MNT_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|VOP_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dep
operator|->
name|de_refcnt
operator|<=
literal|0
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|detrunc
argument_list|(
name|dep
argument_list|,
operator|(
name|u_long
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator||=
name|DE_UPDATE
expr_stmt|;
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|=
name|SLOT_DELETED
expr_stmt|;
block|}
if|if
condition|(
name|dep
operator|->
name|de_flag
operator|&
operator|(
name|DE_MODIFIED
operator||
name|DE_UPDATE
operator|)
condition|)
block|{
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|deupdat
argument_list|(
name|dep
argument_list|,
operator|&
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|dep
operator|->
name|de_flag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we are done with the denode, then reclaim it so that it can 	 * be reused now. 	 */
ifdef|#
directive|ifdef
name|MSDOSFS_DEBUG
name|printf
argument_list|(
literal|"msdosfs_inactive(): v_usecount %d, de_Name[0] %x\n"
argument_list|,
name|vp
operator|->
name|v_usecount
argument_list|,
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
operator|&&
name|dep
operator|->
name|de_Name
index|[
literal|0
index|]
operator|==
name|SLOT_DELETED
condition|)
name|vgone
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

