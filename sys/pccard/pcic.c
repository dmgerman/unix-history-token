begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Intel PCIC or compatible Controller driver  *-------------------------------------------------------------------------  *  * Copyright (c) 2001 M. Warner Losh.  All rights reserved.  * Copyright (c) 1995 Andrew McRae.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<pccard/i82365.h>
end_include

begin_include
include|#
directive|include
file|<pccard/pcic_pci.h>
end_include

begin_include
include|#
directive|include
file|<pccard/cardinfo.h>
end_include

begin_include
include|#
directive|include
file|<pccard/slot.h>
end_include

begin_include
include|#
directive|include
file|<pccard/pcicvar.h>
end_include

begin_comment
comment|/* Get pnp IDs */
end_comment

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pcic/i82365reg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_comment
comment|/*  *	Prototypes for interrupt handler.  */
end_comment

begin_function_decl
specifier|static
name|int
name|pcic_ioctl
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcic_power
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_mapirq
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timeout_t
name|pcic_reset
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pcic_resume
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pcic_disable
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcic_memory
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pcic_io
parameter_list|(
name|struct
name|slot
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|devclass_t
name|pcic_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|slot_ctrl
name|pcic_cinfo
init|=
block|{
name|pcic_mapirq
block|,
name|pcic_memory
block|,
name|pcic_io
block|,
name|pcic_reset
block|,
name|pcic_disable
block|,
name|pcic_power
block|,
name|pcic_ioctl
block|,
name|pcic_resume
block|,
name|PCIC_MEM_WIN
block|,
name|PCIC_IO_WIN
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysctl vars */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|pcic
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"PCIC parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pcic_override_irq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"machdep.pccard.pcic_irq"
argument_list|,
operator|&
name|pcic_override_irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pcic.irq"
argument_list|,
operator|&
name|pcic_override_irq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pcic
argument_list|,
name|OID_AUTO
argument_list|,
name|irq
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pcic_override_irq
argument_list|,
literal|0
argument_list|,
literal|"Override the IRQ configured by the config system for all pcic devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|pcic_boot_deactivated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pcic.boot_deactivated"
argument_list|,
operator|&
name|pcic_boot_deactivated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pcic
argument_list|,
name|OID_AUTO
argument_list|,
name|boot_deactivated
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pcic_boot_deactivated
argument_list|,
literal|0
argument_list|,
literal|"Override the automatic powering up of pccards at boot.  This works\n\ around what turns out to be an old bug in the code that has since been\n\ corrected.  It is now deprecated and will be removed completely before\n\ FreeBSD 4.8."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * CL-PD6722's VSENSE method  *     0: NO VSENSE (assume a 5.0V card)  *     1: 6710's method (default)  *     2: 6729's method  */
end_comment

begin_decl_stmt
name|int
name|pcic_pd6722_vsense
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"hw.pcic.pd6722_vsense"
argument_list|,
operator|&
name|pcic_pd6722_vsense
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_pcic
argument_list|,
name|OID_AUTO
argument_list|,
name|pd6722_vsense
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pcic_pd6722_vsense
argument_list|,
literal|1
argument_list|,
literal|"Select CL-PD6722's VSENSE method.  VSENSE is used to determine the\n\ volatage of inserted cards.  The CL-PD6722 has two methods to determine the\n\ voltage of the card.  0 means assume a 5.0V card and do not check.  1 means\n\ use the same method that the CL-PD6710 uses (default).  2 means use the\n\ same method as the CL-PD6729.  2 is documented in the datasheet as being\n\ the correct way, but 1 seems to give better results on more laptops."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Read a register from the PCIC.  */
end_comment

begin_function
name|unsigned
name|char
name|pcic_getb_io
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|PCIC_INDEX
argument_list|,
name|sp
operator|->
name|offset
operator|+
name|reg
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|PCIC_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a register on the PCIC  */
end_comment

begin_function
name|void
name|pcic_putb_io
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|char
name|val
parameter_list|)
block|{
comment|/* 	 * Many datasheets recommend using outw rather than outb to save  	 * a microsecond.  Maybe we should do this, but we'd likely only 	 * save 20-30us on card activation. 	 */
name|bus_space_write_1
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|PCIC_INDEX
argument_list|,
name|sp
operator|->
name|offset
operator|+
name|reg
argument_list|)
expr_stmt|;
name|bus_space_write_1
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|PCIC_DATA
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear bit(s) of a register.  */
end_comment

begin_function
name|__inline
name|void
name|pcic_clrb
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|char
name|mask
parameter_list|)
block|{
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|)
operator|&
operator|~
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set bit(s) of a register  */
end_comment

begin_function
name|__inline
name|void
name|pcic_setb
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|char
name|mask
parameter_list|)
block|{
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|)
operator||
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a 16 bit value to 2 adjacent PCIC registers  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pcic_putw
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|reg
parameter_list|,
name|unsigned
name|short
name|word
parameter_list|)
block|{
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
name|word
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
operator|(
name|word
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * pc98 cbus cards introduce a slight wrinkle here.  They route the irq7 pin  * from the pcic chip to INT 2 on the cbus.  INT 2 is normally mapped to  * irq 6 on the pc98 architecture, so if we get a request for irq 6  * lie to the hardware and say it is 7.  All the other usual mappings for  * cbus INT into irq space are the same as the rest of the system.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|host_irq_to_pcic
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|irq
operator|==
literal|6
condition|)
name|irq
operator|=
literal|7
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free up resources allocated so far.  */
end_comment

begin_function
name|void
name|pcic_dealloc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|slot_poll
condition|)
name|untimeout
argument_list|(
name|sc
operator|->
name|slot_poll
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|iores
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|sc
operator|->
name|iorid
argument_list|,
name|sc
operator|->
name|iores
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|memres
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|sc
operator|->
name|memrid
argument_list|,
name|sc
operator|->
name|memres
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ih
condition|)
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|irqres
argument_list|,
name|sc
operator|->
name|ih
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|irqres
condition|)
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|irqrid
argument_list|,
name|sc
operator|->
name|irqres
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	entry point from main code to map/unmap memory context.  */
end_comment

begin_function
specifier|static
name|int
name|pcic_memory
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|,
name|int
name|win
parameter_list|)
block|{
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|slt
operator|->
name|mem
index|[
name|win
index|]
decl_stmt|;
name|int
name|reg
init|=
name|win
operator|*
name|PCIC_MEMSIZE
operator|+
name|PCIC_MEMBASE
decl_stmt|;
if|if
condition|(
name|win
operator|<
literal|0
operator|||
name|win
operator|>=
name|slt
operator|->
name|ctrl
operator|->
name|maxmem
condition|)
block|{
name|printf
argument_list|(
literal|"Illegal PCIC MEMORY window request %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_ACTIVE
condition|)
block|{
name|unsigned
name|long
name|sys_addr
init|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|mp
operator|->
name|start
operator|>>
literal|12
decl_stmt|;
if|if
condition|(
operator|(
name|sys_addr
operator|>>
literal|12
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|sp
operator|->
name|sc
operator|->
name|flags
operator|&
name|PCIC_YENTA_HIGH_MEMORY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"This pcic does not support mapping> 24M\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 		 * Write the addresses, card offsets and length. 		 * The values are all stored as the upper 12 bits of the 		 * 24 bit address i.e everything is allocated as 4 Kb chunks. 		 * Memory mapped cardbus bridges extend this slightly to allow 		 * one to set the upper 8 bits of the 32bit address as well. 		 * If the chip supports it, then go ahead and write those 		 * upper 8 bits. 		 */
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
name|sys_addr
operator|&
literal|0xFFF
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|2
argument_list|,
operator|(
name|sys_addr
operator|+
operator|(
name|mp
operator|->
name|size
operator|>>
literal|12
operator|)
operator|-
literal|1
operator|)
operator|&
literal|0xFFF
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
operator|(
operator|(
name|mp
operator|->
name|card
operator|>>
literal|12
operator|)
operator|-
name|sys_addr
operator|)
operator|&
literal|0x3FFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sc
operator|->
name|flags
operator|&
name|PCIC_YENTA_HIGH_MEMORY
condition|)
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_MEMORY_HIGH0
operator|+
name|win
argument_list|,
name|sys_addr
operator|>>
literal|12
argument_list|)
expr_stmt|;
comment|/* 		 *	Each 16 bit register has some flags in the upper bits. 		 */
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_16BITS
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|PCIC_DATA16
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_ZEROWS
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|PCIC_ZEROWS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_WS0
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|3
argument_list|,
name|PCIC_MW0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_WS1
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|3
argument_list|,
name|PCIC_MW1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_ATTR
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|5
argument_list|,
name|PCIC_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|flags
operator|&
name|MDF_WP
condition|)
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|5
argument_list|,
name|PCIC_WP
argument_list|)
expr_stmt|;
comment|/* 		 * Enable the memory window. By experiment, we need a delay. 		 */
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
operator|(
literal|1
operator|<<
name|win
operator|)
operator||
name|PCIC_MEMCS16
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|50
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
literal|1
operator|<<
name|win
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pcic_io - map or unmap I/O context  */
end_comment

begin_function
specifier|static
name|int
name|pcic_io
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|,
name|int
name|win
parameter_list|)
block|{
name|int
name|mask
decl_stmt|,
name|reg
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|struct
name|io_desc
modifier|*
name|ip
init|=
operator|&
name|slt
operator|->
name|io
index|[
name|win
index|]
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"pcic: I/O win %d flags %x %x-%x\n"
argument_list|,
name|win
argument_list|,
name|ip
operator|->
name|flags
argument_list|,
name|ip
operator|->
name|start
argument_list|,
name|ip
operator|->
name|start
operator|+
name|ip
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|win
condition|)
block|{
case|case
literal|0
case|:
name|mask
operator|=
name|PCIC_IO0_EN
expr_stmt|;
name|reg
operator|=
name|PCIC_IO0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|mask
operator|=
name|PCIC_IO1_EN
expr_stmt|;
name|reg
operator|=
name|PCIC_IO1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Illegal PCIC I/O window request %d\n"
argument_list|,
name|win
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|IODF_ACTIVE
condition|)
block|{
name|unsigned
name|char
name|x
decl_stmt|,
name|ioctlv
decl_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
name|ip
operator|->
name|start
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|2
argument_list|,
name|ip
operator|->
name|start
operator|+
name|ip
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|IODF_ZEROWS
condition|)
name|x
operator||=
name|PCIC_IO_0WS
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|IODF_WS
condition|)
name|x
operator||=
name|PCIC_IO_WS
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|IODF_CS16
condition|)
name|x
operator||=
name|PCIC_IO_CS16
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|flags
operator|&
name|IODF_16BIT
condition|)
name|x
operator||=
name|PCIC_IO_16BIT
expr_stmt|;
comment|/* 		 * Extract the current flags and merge with new flags. 		 * Flags for window 0 in lower nybble, and in upper nybble 		 * for window 1. 		 */
name|ioctlv
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_IOCTL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|win
condition|)
block|{
case|case
literal|0
case|:
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_IOCTL
argument_list|,
name|x
operator||
operator|(
name|ioctlv
operator|&
literal|0xf0
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_IOCTL
argument_list|,
operator|(
name|x
operator|<<
literal|4
operator|)
operator||
operator|(
name|ioctlv
operator|&
literal|0xf
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_ADDRWINE
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pcic_putw
argument_list|(
name|sp
argument_list|,
name|reg
operator|+
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pcic_do_mgt_irq
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|u_int32_t
name|reg
decl_stmt|;
if|if
condition|(
name|sp
operator|->
name|sc
operator|->
name|csc_route
operator|==
name|pcic_iw_pci
condition|)
block|{
comment|/* Do the PCI side of things: Enable the Card Change int */
name|reg
operator|=
name|CB_SM_CD
expr_stmt|;
name|bus_space_write_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_MASK
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* 		 * TI Chips need us to set the following.  We tell the 		 * controller to route things via PCI interrupts.  Also 		 * we clear the interrupt number in the STAT_INT register 		 * as well.  The TI-12xx and newer chips require one or the 		 * other of these to happen, depending on what is set in the 		 * diagnostic register.  I do both on the theory that other 		 * chips might need one or the other and that no harm will 		 * come from it.  If there is harm, then I'll make it a bit 		 * in the tables. 		 */
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|PCIC_INTR_ENA
argument_list|)
expr_stmt|;
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_STAT_INT
argument_list|,
name|PCIC_CSCSELECT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Management IRQ changes */
comment|/* 		 * The PCIC_INTR_ENA bit means either "tie the function 		 * and csc interrupts together" or "Route csc interrupts 		 * via PCI" or "Reserved".  In any case, we want to clear 		 * it since we're using ISA interrupts. 		 */
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|PCIC_INTR_ENA
argument_list|)
expr_stmt|;
name|irq
operator|=
name|host_irq_to_pcic
argument_list|(
name|irq
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_STAT_INT
argument_list|,
operator|(
name|irq
operator|<<
name|PCIC_SI_IRQ_SHIFT
operator|)
operator||
name|PCIC_CDEN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|pcic_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|device_t
name|kid
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|slot
modifier|*
name|slt
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|sc
operator|->
name|slots
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_CARD_SLOTS
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|sp
operator|->
name|slt
condition|)
continue|continue;
name|sp
operator|->
name|slt
operator|=
literal|0
expr_stmt|;
name|kid
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't add pccard bus slot %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|device_probe_and_attach
argument_list|(
name|kid
argument_list|)
expr_stmt|;
name|slt
operator|=
name|pccard_init_slot
argument_list|(
name|kid
argument_list|,
operator|&
name|pcic_cinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slt
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't get pccard info slot %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|slotmask
operator||=
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|slt
operator|->
name|cdata
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|slt
operator|=
name|slt
expr_stmt|;
name|sp
operator|->
name|sc
operator|=
name|sc
expr_stmt|;
block|}
name|sp
operator|=
operator|&
name|sc
operator|->
name|slots
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PCIC_CARD_SLOTS
condition|;
name|i
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|slt
operator|==
name|NULL
condition|)
continue|continue;
name|pcic_do_mgt_irq
argument_list|(
name|sp
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|sp
operator|->
name|slt
operator|->
name|irq
operator|=
name|sc
operator|->
name|irq
expr_stmt|;
comment|/* Check for changes */
name|sp
operator|->
name|slt
operator|->
name|laststate
operator|=
name|sp
operator|->
name|slt
operator|->
name|state
operator|=
name|empty
expr_stmt|;
if|if
condition|(
name|pcic_boot_deactivated
condition|)
block|{
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_CD
operator|)
operator|==
name|PCIC_CD
condition|)
block|{
name|sp
operator|->
name|slt
operator|->
name|state
operator|=
name|inactive
expr_stmt|;
name|pccard_event
argument_list|(
name|sp
operator|->
name|slt
argument_list|,
name|card_deactivated
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pcic_do_stat_delta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pcic_sresource
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|pccard_resource
modifier|*
name|pr
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|device_t
name|bridgedev
init|=
name|slt
operator|->
name|dev
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|pr
operator|=
operator|(
expr|struct
name|pccard_resource
operator|*
operator|)
name|data
expr_stmt|;
name|pr
operator|->
name|resource_addr
operator|=
operator|~
literal|0ul
expr_stmt|;
comment|/* 	 * If we're using PCI interrupt routing, then force the IRQ to 	 * use and to heck with what the user requested.  If they want 	 * to be able to request IRQs, they must use ISA interrupt 	 * routing.  If we don't give them an irq, and it is the 	 * pccardd 0,0 case, then just return (giving the "bad resource" 	 * return in pr->resource_addr). 	 */
if|if
condition|(
name|pr
operator|->
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|sc
operator|->
name|func_route
operator|>=
name|pcic_iw_pci
condition|)
block|{
name|pr
operator|->
name|resource_addr
operator|=
name|sp
operator|->
name|sc
operator|->
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pr
operator|->
name|min
operator|==
literal|0
operator|&&
name|pr
operator|->
name|max
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Make sure we grok this type. 	 */
switch|switch
condition|(
name|pr
operator|->
name|type
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
case|case
name|SYS_RES_IRQ
case|:
case|case
name|SYS_RES_IOPORT
case|:
break|break;
block|}
comment|/* 	 * Allocate the resource, and align it to the most natural 	 * size.  If we get it, then tell userland what we actually got 	 * in the range they requested. 	 */
name|flags
operator|=
name|rman_make_alignment_flags
argument_list|(
name|pr
operator|->
name|size
argument_list|)
expr_stmt|;
name|r
operator|=
name|bus_alloc_resource
argument_list|(
name|bridgedev
argument_list|,
name|pr
operator|->
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|pr
operator|->
name|min
argument_list|,
name|pr
operator|->
name|max
argument_list|,
name|pr
operator|->
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|NULL
condition|)
block|{
name|pr
operator|->
name|resource_addr
operator|=
operator|(
name|u_long
operator|)
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|bridgedev
argument_list|,
name|pr
operator|->
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	ioctl calls - Controller specific ioctls  */
end_comment

begin_function
specifier|static
name|int
name|pcic_ioctl
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|struct
name|pcic_reg
modifier|*
name|preg
init|=
operator|(
expr|struct
name|pcic_reg
operator|*
operator|)
name|data
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
return|return
operator|(
name|ENOTTY
operator|)
return|;
case|case
name|PIOCGREG
case|:
comment|/* Get pcic register */
name|preg
operator|->
name|value
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|preg
operator|->
name|reg
argument_list|)
expr_stmt|;
break|break;
comment|/* Set pcic register */
case|case
name|PIOCSREG
case|:
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|preg
operator|->
name|reg
argument_list|,
name|preg
operator|->
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|PIOCSRESOURCE
case|:
comment|/* Can I use this resource? */
name|pcic_sresource
argument_list|(
name|slt
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pcic_cardbus_power  *  *	Power the card up, as specified, using the cardbus power  *	registers to control power.  Microsoft recommends that cardbus  *	vendors support powering the card via cardbus registers because  *	there is no standard for 3.3V cards.  Since at least a few of the  *	cardbus bridges have minor issues with power via the ExCA registers,  *	go ahead and do it all via cardbus registers.  *  *	An expamination of the code will show the relative ease that we do  *	Vpp in comparison to the ExCA case (which may be partially broken).  */
end_comment

begin_function
specifier|static
name|int
name|pcic_cardbus_power
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|struct
name|slot
modifier|*
name|slt
parameter_list|)
block|{
name|uint32_t
name|power
decl_stmt|;
name|uint32_t
name|state
decl_stmt|;
comment|/*  	 * If we're doing an auto-detect, and we're in a badvcc state, then  	 * we need to force the socket to rescan the card.  We don't do this  	 * all the time because the socket can take up to 200ms to do the deed,  	 * and that's too long to busy wait.  Since this is a relatively rare  	 * event (some BIOSes, and earlier versions of OLDCARD caused it), we  	 * test for it special.  	 */
name|state
operator|=
name|bus_space_read_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|==
operator|-
literal|1
operator|&&
operator|(
name|state
operator|&
name|CB_SS_BADVCC
operator|)
condition|)
block|{
comment|/*  	 	 * Force the bridge to scan the card for the proper voltages  		 * that it supports.  		 */
name|bus_space_write_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_FORCE
argument_list|,
name|CB_SF_INTCVS
argument_list|)
expr_stmt|;
name|state
operator|=
name|bus_space_read_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_STATE
argument_list|)
expr_stmt|;
comment|/* This while loop can take 100-150ms */
while|while
condition|(
operator|(
name|state
operator|&
name|CB_SS_CARD_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|DELAY
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|state
operator|=
name|bus_space_read_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_STATE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  	 * Preserve the clock stop bit of the socket power register.  Not  	 * sure that we want to do that, but maybe we should set it based  	 * on the power state.   	 */
name|power
operator|=
name|bus_space_read_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_POWER
argument_list|)
expr_stmt|;
name|power
operator|=
literal|0
expr_stmt|;
comment|/* 	 * vcc == -1 means automatically detect the voltage of the card. 	 * Do so and apply the right amount of power. 	 */
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|state
operator|&
name|CB_SS_5VCARD
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|&
name|CB_SS_3VCARD
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|&
name|CB_SS_XVCARD
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|22
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|&
name|CB_SS_YVCARD
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|11
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|&&
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|!=
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|sp
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"Autodetected %d.%dV card\n"
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|/
literal|10
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0
case|:
name|power
operator||=
name|CB_SP_VCC_0V
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|power
operator||=
name|CB_SP_VCC_YV
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|power
operator||=
name|CB_SP_VCC_XV
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|power
operator||=
name|CB_SP_VCC_3V
expr_stmt|;
break|break;
case|case
literal|50
case|:
name|power
operator||=
name|CB_SP_VCC_5V
expr_stmt|;
break|break;
block|}
comment|/* 	 * vpp == -1 means use vcc voltage. 	 */
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|==
operator|-
literal|1
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|=
name|slt
operator|->
name|pwr
operator|.
name|vcc
expr_stmt|;
switch|switch
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vpp
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0
case|:
name|power
operator||=
name|CB_SP_VPP_0V
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|power
operator||=
name|CB_SP_VPP_YV
expr_stmt|;
break|break;
case|case
literal|22
case|:
name|power
operator||=
name|CB_SP_VPP_XV
expr_stmt|;
break|break;
case|case
literal|33
case|:
name|power
operator||=
name|CB_SP_VPP_3V
expr_stmt|;
break|break;
case|case
literal|50
case|:
name|power
operator||=
name|CB_SP_VPP_5V
expr_stmt|;
break|break;
case|case
literal|120
case|:
name|power
operator||=
name|CB_SP_VPP_12V
expr_stmt|;
break|break;
block|}
name|bus_space_write_4
argument_list|(
name|sp
operator|->
name|bst
argument_list|,
name|sp
operator|->
name|bsh
argument_list|,
name|CB_SOCKET_POWER
argument_list|,
name|power
argument_list|)
expr_stmt|;
comment|/*  	 * OK.  We need to bring the card out of reset.  Let the power  	 * stabilize for 300ms (why 300?) and then enable the outputs  	 * and then wait 100ms (why 100?) for it to stabilize.  These numbers  	 * were stolen from the dim, dark past of OLDCARD and I have no clue  	 * how they were derived.  I also use the bit setting routines here  	 * as a measure of conservatism.  	 */
if|if
condition|(
name|power
condition|)
block|{
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
name|PCIC_DISRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
name|PCIC_DISRST
operator||
name|PCIC_OUTENA
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
name|PCIC_DISRST
operator||
name|PCIC_OUTENA
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pcic_power - Enable the power of the slot according to  *	the parameters in the power structure(s).  */
end_comment

begin_function
specifier|static
name|int
name|pcic_power
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
name|reg
init|=
name|PCIC_DISRST
operator||
name|PCIC_PCPWRE
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp2
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|sp
operator|->
name|sc
decl_stmt|;
name|int
name|dodefault
init|=
literal|0
decl_stmt|;
name|char
name|controller
decl_stmt|;
comment|/* 	 * Cardbus power registers are completely different. 	 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_CARDBUS_POWER
condition|)
return|return
operator|(
name|pcic_cardbus_power
argument_list|(
name|sp
argument_list|,
name|slt
argument_list|)
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Power: Vcc=%d Vpp=%d\n"
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vcc
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vpp
argument_list|)
expr_stmt|;
comment|/* 	 * If we're automatically detecting what voltage to use, then we need 	 * to ask the bridge what type (voltage-wise) the card is. 	 */
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_DF_POWER
condition|)
block|{
comment|/*  			 * Look at the VS[12]# bits on the card.  If VS1 is 			 * clear then the card needs 3.3V instead of 5.0V. 			 */
name|c
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_CDGC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|PCIC_VS1STAT
operator|)
operator|==
literal|0
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
else|else
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_PD_POWER
condition|)
block|{
comment|/* 			 * The 6710 does it one way, and the '22 and '29 do it 			 * another.  The '22 can also do it the same way as a 			 * '10 does it, despite what the datasheets say.  Some 			 * laptops with '22 don't seem to have the signals 			 * wired right for the '29 method to work.  The 			 * laptops that don't work hang solid when the pccard 			 * memory is accessed. 			 * 			 * To allow for both types of laptops, 			 * hw.pcic.pd6722_vsense will select which one to use. 			 * 0 - none, 1 - the '10 way and 2 - the '29 way. 			 */
name|controller
operator|=
name|sp
operator|->
name|controller
expr_stmt|;
if|if
condition|(
name|controller
operator|==
name|PCIC_PD6722
condition|)
block|{
switch|switch
condition|(
name|pcic_pd6722_vsense
condition|)
block|{
case|case
literal|1
case|:
name|controller
operator|=
name|PCIC_PD6710
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|controller
operator|=
name|PCIC_PD6729
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|controller
condition|)
block|{
case|case
name|PCIC_PD6710
case|:
name|c
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_MISC1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|PCIC_MISC1_5V_DETECT
operator|)
operator|==
literal|0
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
else|else
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
break|break;
case|case
name|PCIC_PD6722
case|:
comment|/* see above for why we do */
break|break;
comment|/* none here */
case|case
name|PCIC_PD6729
case|:
comment|/* 				 * VS[12] signals are in slot1's 				 * extended reg 0xa for both slots. 				 */
name|sp2
operator|=
operator|&
name|sc
operator|->
name|slots
index|[
literal|1
index|]
expr_stmt|;
name|sp2
operator|->
name|putb
argument_list|(
name|sp2
argument_list|,
name|PCIC_EXT_IND
argument_list|,
name|PCIC_EXT_DATA
argument_list|)
expr_stmt|;
name|c
operator|=
name|sp2
operator|->
name|getb
argument_list|(
name|sp2
argument_list|,
name|PCIC_EXTENDED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|sp2
condition|)
comment|/* slot 1 */
name|c
operator|>>=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|PCIC_VS1A
operator|)
operator|==
literal|0
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
else|else
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
break|break;
default|default:
comment|/* I have no idea how to do this for others */
break|break;
block|}
comment|/* 			 * Regardless of the above, setting the Auto Power 			 * Switch Enable appears to help. 			 */
name|reg
operator||=
name|PCIC_APSENA
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_RICOH_POWER
condition|)
block|{
switch|switch
condition|(
name|sp
operator|->
name|controller
condition|)
block|{
case|case
name|PCIC_RF5C396
case|:
case|case
name|PCIC_RF5C296
case|:
comment|/* 				 * The ISA bridge have the 5V/3.3V in register 				 * 1, bit 7. 				 */
name|c
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
name|PCIC_RICOH_5VCARD
operator|)
operator|==
literal|0
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
else|else
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
break|break;
block|}
block|}
comment|/* Other bridges here */
if|if
condition|(
name|bootverbose
operator|&&
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|!=
operator|-
literal|1
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Autodetected %d.%dV card\n"
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|/
literal|10
argument_list|,
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Couldn't autodetect voltage, assuming 5.0V\n"
argument_list|)
expr_stmt|;
name|dodefault
operator|=
literal|1
expr_stmt|;
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|50
expr_stmt|;
block|}
comment|/* 	 * XXX Note: The Vpp controls varies quit a bit between bridge chips 	 * and the following might not be right in all cases.  The Linux 	 * code and wildboar code bases are more complex.  However, most 	 * applications want vpp == vcc and the following code does appear 	 * to do that for all bridge sets. 	 */
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|==
operator|-
literal|1
condition|)
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|=
name|slt
operator|->
name|pwr
operator|.
name|vcc
expr_stmt|;
switch|switch
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vpp
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0
case|:
break|break;
case|case
literal|50
case|:
case|case
literal|33
case|:
name|reg
operator||=
name|PCIC_VPP_5V
expr_stmt|;
break|break;
case|case
literal|120
case|:
name|reg
operator||=
name|PCIC_VPP_12V
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
condition|)
name|reg
operator||=
name|PCIC_VCC_ON
expr_stmt|;
comment|/* Turn on Vcc */
switch|switch
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
condition|)
block|{
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0
case|:
break|break;
case|case
literal|33
case|:
comment|/* 		 * The wildboar code has comments that state that 		 * the IBM KING controller doesn't support 3.3V 		 * on the "IBM Smart PC card drive".  The code 		 * intemates that's the only place they have seen 		 * it used and that there's a boatload of issues 		 * with it.  I'm not even sure this is right because 		 * the only docs I've been able to find say this is for 		 * 5V power.  Of course, this "doc" is just code comments 		 * so who knows for sure. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_KING_POWER
condition|)
block|{
name|reg
operator||=
name|PCIC_VCC_5V_KING
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_VG_POWER
condition|)
block|{
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_CVSR
argument_list|,
name|PCIC_CVSR_VS
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_PD_POWER
condition|)
block|{
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_MISC1
argument_list|,
name|PCIC_MISC1_VCC_33
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_RICOH_POWER
condition|)
block|{
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_RICOH_MCR2
argument_list|,
name|PCIC_MCR2_VCC_33
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_DF_POWER
condition|)
name|reg
operator||=
name|PCIC_VCC_3V
expr_stmt|;
break|break;
case|case
literal|50
case|:
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_KING_POWER
condition|)
name|reg
operator||=
name|PCIC_VCC_5V_KING
expr_stmt|;
comment|/* 		 * For all of the variant power schemes for 3.3V go 		 * ahead and turn off the 3.3V enable bit.  For all 		 * bridges, the setting the Vcc on bit does the rest. 		 * Note that we don't have to turn off the 3.3V bit 		 * for the '365 step D since with the reg assigments 		 * to this point it doesn't get turned on. 		 */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_VG_POWER
condition|)
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_CVSR
argument_list|,
name|PCIC_CVSR_VS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_PD_POWER
condition|)
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_MISC1
argument_list|,
name|PCIC_MISC1_VCC_33
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|PCIC_RICOH_POWER
condition|)
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_RICOH_MCR2
argument_list|,
name|PCIC_MCR2_VCC_33
argument_list|)
expr_stmt|;
break|break;
block|}
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Power applied\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|300
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|slt
operator|->
name|pwr
operator|.
name|vcc
condition|)
block|{
name|reg
operator||=
name|PCIC_OUTENA
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_POWER
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Output enabled\n"
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|100
operator|*
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Settling complete\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Some chipsets will attempt to preclude us from supplying 	 * 5.0V to cards that only handle 3.3V.  We seem to need to 	 * try 3.3V to paper over some power handling issues in other 	 * parts of the system.  Maybe the proper detection of 3.3V cards 	 * now obviates the need for this hack, so put a printf in to 	 * warn the world about it. 	 */
if|if
condition|(
operator|!
operator|(
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_POW
operator|)
operator|&&
name|dodefault
condition|)
block|{
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
literal|33
expr_stmt|;
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|=
literal|0
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Failed at 5.0V.  Trying 3.3V.  Please report message to mobile@freebsd.org\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcic_power
argument_list|(
name|slt
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Power complete.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tell the PCIC which irq we want to use.  only the following are legal:  * 3, 4, 5, 7, 9, 10, 11, 12, 14, 15.  We require the callers of this  * routine to do the check for legality.  */
end_comment

begin_function
specifier|static
name|void
name|pcic_mapirq
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|sp
operator|->
name|sc
operator|->
name|chip
operator|->
name|map_irq
argument_list|(
name|sp
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pcic_reset - Reset the card and enable initial power.  This may  *	need to be interrupt driven in the future.  We should likely turn  *	the reset on, DELAY for a period of time< 250ms, turn it off and  *	tsleep for a while and check it when we're woken up.  I think that  *	we're running afoul of the card status interrupt glitching, causing  *	an interrupt storm because the card doesn't seem to be able to  *	clear this pin while in reset.  */
end_comment

begin_function
specifier|static
name|void
name|pcic_reset
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|slot
modifier|*
name|slt
init|=
name|chan
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|sp
operator|->
name|sc
operator|->
name|dev
argument_list|,
literal|"reset %d "
argument_list|,
name|slt
operator|->
name|insert_seq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|slt
operator|->
name|insert_seq
condition|)
block|{
case|case
literal|0
case|:
comment|/* Something funny happended on the way to the pub... */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|1
case|:
comment|/* Assert reset */
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|PCIC_CARDRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"int is %x stat is %x\n"
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|)
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slt
operator|->
name|insert_seq
operator|=
literal|2
expr_stmt|;
name|timeout
argument_list|(
name|pcic_reset
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slt
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|2
case|:
comment|/* Deassert it again */
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|PCIC_CARDRESET
operator||
name|PCIC_IOCARD
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"int is %x stat is %x\n"
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|)
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
argument_list|)
expr_stmt|;
name|slt
operator|->
name|insert_seq
operator|=
literal|3
expr_stmt|;
name|timeout
argument_list|(
name|pcic_reset
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slt
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
return|return;
case|case
literal|3
case|:
comment|/* Wait if card needs more time */
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"int is %x stat is %x\n"
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|)
argument_list|,
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_READY
condition|)
block|{
name|timeout
argument_list|(
name|pcic_reset
argument_list|,
operator|(
name|void
operator|*
operator|)
name|slt
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|slt
operator|->
name|insert_seq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|controller
operator|==
name|PCIC_PD6722
operator|||
name|sp
operator|->
name|controller
operator|==
name|PCIC_PD6710
condition|)
block|{
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_SETUP0
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_CMD0
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_RECOV0
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_SETUP1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_CMD1
argument_list|,
literal|0xf
argument_list|)
expr_stmt|;
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_TIME_RECOV1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|selwakeup
argument_list|(
operator|&
name|slt
operator|->
name|selp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pcic_disable - Disable the slot.  I wonder if these operations can  *	cause an interrupt we need to acknowledge? XXX  */
end_comment

begin_function
specifier|static
name|void
name|pcic_disable
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|)
block|{
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
name|PCIC_CARDTYPE
operator||
name|PCIC_CARDRESET
argument_list|)
expr_stmt|;
name|pcic_mapirq
argument_list|(
name|slt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|slt
operator|->
name|pwr
operator|.
name|vcc
operator|=
name|slt
operator|->
name|pwr
operator|.
name|vpp
operator|=
literal|0
expr_stmt|;
name|pcic_power
argument_list|(
name|slt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pcic_resume - Suspend/resume support for PCIC  */
end_comment

begin_function
specifier|static
name|void
name|pcic_resume
parameter_list|(
name|struct
name|slot
modifier|*
name|slt
parameter_list|)
block|{
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
name|slt
operator|->
name|cdata
decl_stmt|;
name|pcic_do_mgt_irq
argument_list|(
name|sp
argument_list|,
name|slt
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|controller
operator|==
name|PCIC_PD6722
condition|)
block|{
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_MISC1
argument_list|,
name|PCIC_MISC1_SPEAKER
argument_list|)
expr_stmt|;
name|pcic_setb
argument_list|(
name|sp
argument_list|,
name|PCIC_MISC2
argument_list|,
name|PCIC_LPDM_EN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|slt
operator|->
name|state
operator|!=
name|inactive
condition|)
name|pcic_do_stat_delta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pcic_activate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|!=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|)
operator|||
name|devi
operator|==
name|NULL
condition|)
return|return
operator|(
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
block|{
name|struct
name|io_desc
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|io
index|[
name|rid
index|]
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rid
operator|==
literal|0
condition|)
name|ip
operator|->
name|flags
operator|=
name|IODF_WS
operator||
name|IODF_16BIT
operator||
name|IODF_CS16
expr_stmt|;
else|else
name|ip
operator|->
name|flags
operator|=
name|devi
operator|->
name|slt
operator|->
name|io
index|[
literal|0
index|]
operator|.
name|flags
expr_stmt|;
block|}
name|ip
operator|->
name|flags
operator||=
name|IODF_ACTIVE
expr_stmt|;
name|ip
operator|->
name|start
operator|=
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|ip
operator|->
name|size
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
name|err
operator|=
name|pcic_io
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
break|break;
block|}
case|case
name|SYS_RES_IRQ
case|:
comment|/* 		 * We actually defer the activation of the IRQ resource 		 * until the interrupt is registered to avoid stray 		 * interrupt messages. 		 */
break|break;
case|case
name|SYS_RES_MEMORY
case|:
block|{
name|struct
name|mem_desc
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|rid
operator|>=
name|NUM_MEM_WINDOWS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mp
operator|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
expr_stmt|;
name|mp
operator|->
name|flags
operator||=
name|MDF_ACTIVE
expr_stmt|;
name|mp
operator|->
name|start
operator|=
operator|(
name|caddr_t
operator|)
name|rman_get_start
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|mp
operator|->
name|size
operator|=
name|rman_get_end
argument_list|(
name|r
argument_list|)
operator|-
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|+
literal|1
expr_stmt|;
name|err
operator|=
name|pcic_memory
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
break|break;
block|}
default|default:
break|break;
block|}
name|err
operator|=
name|bus_generic_activate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_deactivate_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|dev
operator|!=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|child
argument_list|)
argument_list|)
operator|||
name|devi
operator|==
name|NULL
condition|)
return|return
operator|(
name|bus_generic_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
block|{
name|struct
name|io_desc
modifier|*
name|ip
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|io
index|[
name|rid
index|]
decl_stmt|;
name|ip
operator|->
name|flags
operator|&=
operator|~
name|IODF_ACTIVE
expr_stmt|;
name|err
operator|=
name|pcic_io
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
break|break;
block|}
case|case
name|SYS_RES_IRQ
case|:
break|break;
case|case
name|SYS_RES_MEMORY
case|:
block|{
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
decl_stmt|;
name|mp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|MDF_ACTIVE
operator||
name|MDF_ATTR
operator|)
expr_stmt|;
name|err
operator|=
name|pcic_memory
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
break|break;
block|}
default|default:
break|break;
block|}
name|err
operator|=
name|bus_generic_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|rman_get_start
argument_list|(
name|irq
argument_list|)
operator|)
operator|&
name|PCIC_INT_MASK_ALLOWED
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Hardware does not support irq %ld.\n"
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|flags
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|pcic_mapirq
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Error %d irq %ld\n"
argument_list|,
name|err
argument_list|,
name|rman_get_start
argument_list|(
name|irq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|irq
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|pcic_mapirq
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|irq
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_set_res_flags
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|restype
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
name|value
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
block|{
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
decl_stmt|;
switch|switch
condition|(
name|value
condition|)
block|{
case|case
name|PCCARD_A_MEM_COM
case|:
name|mp
operator|->
name|flags
operator|&=
operator|~
name|MDF_ATTR
expr_stmt|;
break|break;
case|case
name|PCCARD_A_MEM_ATTR
case|:
name|mp
operator|->
name|flags
operator||=
name|MDF_ATTR
expr_stmt|;
break|break;
case|case
name|PCCARD_A_MEM_8BIT
case|:
name|mp
operator|->
name|flags
operator|&=
operator|~
name|MDF_16BITS
expr_stmt|;
break|break;
case|case
name|PCCARD_A_MEM_16BIT
case|:
name|mp
operator|->
name|flags
operator||=
name|MDF_16BITS
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|pcic_memory
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_get_res_flags
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|restype
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_long
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|restype
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
block|{
name|struct
name|io_desc
modifier|*
name|ip
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|io
index|[
name|rid
index|]
decl_stmt|;
operator|*
name|value
operator|=
name|ip
operator|->
name|flags
expr_stmt|;
break|break;
block|}
case|case
name|SYS_RES_MEMORY
case|:
block|{
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
decl_stmt|;
operator|*
name|value
operator|=
name|mp
operator|->
name|flags
expr_stmt|;
break|break;
block|}
default|default:
name|err
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_set_memory_offset
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_int32_t
name|offset
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
parameter_list|,
name|u_int32_t
modifier|*
name|deltap
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
decl_stmt|;
name|mp
operator|->
name|card
operator|=
name|offset
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|500000
if|if
condition|(
name|deltap
condition|)
operator|*
name|deltap
operator|=
literal|0
expr_stmt|;
comment|/* XXX BAD XXX */
endif|#
directive|endif
return|return
operator|(
name|pcic_memory
argument_list|(
name|devi
operator|->
name|slt
argument_list|,
name|rid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_get_memory_offset
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|rid
parameter_list|,
name|u_int32_t
modifier|*
name|offset
parameter_list|)
block|{
name|struct
name|pccard_devinfo
modifier|*
name|devi
init|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
decl_stmt|;
name|struct
name|mem_desc
modifier|*
name|mp
init|=
operator|&
name|devi
operator|->
name|slt
operator|->
name|mem
index|[
name|rid
index|]
decl_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
name|offset
operator|=
name|mp
operator|->
name|card
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|resource
modifier|*
name|pcic_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* 	 * If we're routing via pci, we can share. 	 */
if|if
condition|(
name|sc
operator|->
name|func_route
operator|==
name|pcic_iw_pci
operator|&&
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|child
argument_list|,
literal|"Forcing IRQ to %d\n"
argument_list|,
name|sc
operator|->
name|irq
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|=
name|sc
operator|->
name|irq
expr_stmt|;
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
block|}
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pcic_do_stat_delta
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STATUS
argument_list|)
operator|&
name|PCIC_CD
operator|)
operator|!=
name|PCIC_CD
condition|)
name|pccard_event
argument_list|(
name|sp
operator|->
name|slt
argument_list|,
name|card_removed
argument_list|)
expr_stmt|;
else|else
name|pccard_event
argument_list|(
name|sp
operator|->
name|slt
argument_list|,
name|card_inserted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wrapper function for pcicintr so that signatures match.  */
end_comment

begin_function
name|void
name|pcic_isa_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|pcic_isa_intr1
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	PCIC timer.  If the controller doesn't have a free IRQ to use  *	or if interrupt steering doesn't work, poll the controller for  *	insertion/removal events.  */
end_comment

begin_function
name|void
name|pcic_timeout
parameter_list|(
name|void
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|chan
decl_stmt|;
if|if
condition|(
name|pcic_isa_intr1
argument_list|(
name|chan
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Static bug detected, ignoring hardware."
argument_list|)
expr_stmt|;
name|sc
operator|->
name|slot_poll
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|timeout_ch
operator|=
name|timeout
argument_list|(
name|sc
operator|->
name|slot_poll
argument_list|,
name|chan
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	PCIC Interrupt handler.  *	Check each slot in turn, and read the card status change  *	register. If this is non-zero, then a change has occurred  *	on this card, so send an event to the main code.  */
end_comment

begin_function
name|int
name|pcic_isa_intr1
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|slot
decl_stmt|,
name|s
decl_stmt|;
name|u_int8_t
name|chg
decl_stmt|;
name|struct
name|pcic_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|pcic_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|pcic_slot
modifier|*
name|sp
init|=
operator|&
name|sc
operator|->
name|slots
index|[
literal|0
index|]
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
for|for
control|(
name|slot
operator|=
literal|0
init|;
name|slot
operator|<
name|PCIC_CARD_SLOTS
condition|;
name|slot
operator|++
operator|,
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|sp
operator|->
name|slt
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|chg
operator|=
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_STAT_CHG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * if chg is 0xff, then we know that we've hit 			 * the famous "static bug" for some desktop 			 * pcmcia cards.  This is caused by static 			 * discharge frying the poor card's mind and 			 * it starts return 0xff forever.  We return 			 * an error and stop polling the card.  When 			 * we're interrupt based, we never see this. 			 * The card just goes away silently. 			 */
if|if
condition|(
name|chg
operator|==
literal|0xff
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|chg
operator|&
name|PCIC_CDTCH
condition|)
name|pcic_do_stat_delta
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pcic_isa_mapirq
parameter_list|(
name|struct
name|pcic_slot
modifier|*
name|sp
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|irq
operator|=
name|host_irq_to_pcic
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
literal|0
condition|)
name|pcic_clrb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
literal|0xF
argument_list|)
expr_stmt|;
else|else
name|sp
operator|->
name|putb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|,
operator|(
name|sp
operator|->
name|getb
argument_list|(
name|sp
argument_list|,
name|PCIC_INT_GEN
argument_list|)
operator|&
literal|0xF0
operator|)
operator||
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

