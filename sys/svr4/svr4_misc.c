begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Mark Newton  * Copyright (c) 1994 Christos Zoulas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   * $Id: svr4_misc.c,v 1.4 1999/07/30 12:45:16 newton Exp $  */
end_comment

begin_comment
comment|/*  * SVR4 compatibility module.  *  * SVR4 system calls that are implemented differently in BSD are  * handled here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_types.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_signal.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_proto.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_util.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_sysconfig.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_dirent.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_acl.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_time.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_ulimit.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_statvfs.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_hrt.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_mman.h>
end_include

begin_include
include|#
directive|include
file|<svr4/svr4_wait.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NetBSD
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<uvm/uvm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BSD_DIRENT
parameter_list|(
name|cp
parameter_list|)
value|((struct dirent *)(cp))
end_define

begin_decl_stmt
specifier|extern
name|int
name|bsd_to_svr4_sig
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svr4_mknod
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|register_t
operator|*
operator|,
name|char
operator|*
operator|,
name|svr4_mode_t
operator|,
name|svr4_dev_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|__inline
name|clock_t
name|timeval_to_clock_t
name|__P
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|svr4_setinfo
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|int
operator|,
name|svr4_siginfo_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|svr4_hrtcntl_args
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|int
name|svr4_hrtcntl
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
expr|struct
name|svr4_hrtcntl_args
operator|*
operator|,
name|register_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|statfs
operator|*
operator|,
expr|struct
name|svr4_statvfs
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs64
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|statfs
operator|*
operator|,
expr|struct
name|svr4_statvfs64
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|svr4_pfind
name|__P
argument_list|(
operator|(
name|pid_t
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* BOGUS noop */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BOGUS
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_setitimer
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_setitimer_args
modifier|*
name|uap
decl_stmt|;
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|svr4_sys_wait
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_wait_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|wait_args
name|w4
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|,
name|st
decl_stmt|,
name|sig
decl_stmt|;
name|size_t
name|sz
init|=
sizeof|sizeof
argument_list|(
operator|*
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|status
argument_list|)
argument_list|)
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|rusage
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|options
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|status
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|status
argument_list|)
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|status
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|pid
argument_list|)
operator|=
name|WAIT_ANY
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait4
argument_list|(
name|p
argument_list|,
operator|&
name|w4
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
operator|&
name|w4
argument_list|,
name|status
argument_list|)
argument_list|,
operator|&
name|st
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WTERMSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|st
operator|=
operator|(
name|st
operator|&
operator|~
literal|0177
operator|)
operator||
name|bsd_to_svr4_sig
index|[
name|sig
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WSTOPSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|st
operator|=
operator|(
name|st
operator|&
operator|~
literal|0xff00
operator|)
operator||
operator|(
name|bsd_to_svr4_sig
index|[
name|sig
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
comment|/* 	 * It looks like wait(2) on svr4/solaris/2.4 returns 	 * the status in retval[1], and the pid on retval[0]. 	 */
name|retval
index|[
literal|1
index|]
operator|=
name|st
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|status
argument_list|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|st
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|status
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_execv
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_execv_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|execve_args
name|ap
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|fname
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|argv
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|envv
argument_list|)
operator|=
name|NULL
expr_stmt|;
return|return
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_execve
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_execve_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|execve_args
name|ap
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|fname
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|argv
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|envv
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|envp
argument_list|)
expr_stmt|;
return|return
name|execve
argument_list|(
name|p
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_time
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_time_args
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|svr4_sys_time_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|t
argument_list|)
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|t
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Read SVR4-style directory entries.  We suck them into kernel space so  * that they can be massaged before being copied out to user code.  Like  * SunOS, we squish out `empty' entries.  *  * This is quite ugly, but what do you expect from compatibility code?  */
end_comment

begin_function
name|int
name|svr4_sys_getdents64
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_getdents64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|bdp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
name|caddr_t
name|outp
decl_stmt|;
comment|/* SVR4-format */
name|int
name|resid
decl_stmt|,
name|svr4_reclen
decl_stmt|;
comment|/* SVR4-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|svr4_dirent64
name|idb
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|;
name|u_long
modifier|*
name|cookiebuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookie
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|,
name|offcnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|buflen
operator|=
name|min
argument_list|(
name|MAXBSIZE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"buflen = %d, spec = %d\n"
operator|,
name|buflen
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|">>> off = %d\n"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
comment|/*          * First we read into the malloc'ed buffer, then          * we massage it into user space, one record at a time.          */
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookiebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|resid
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
goto|goto
name|eof
goto|;
for|for
control|(
name|cookie
operator|=
name|cookiebuf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
name|bdp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
expr_stmt|;
name|reclen
operator|=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
name|panic
argument_list|(
literal|"svr4_getdents64: bad reclen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bdp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
if|#
directive|if
literal|0
block|off = *cookie++;
else|#
directive|else
name|off
operator|+=
name|reclen
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"+++ off = %d\n"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|svr4_reclen
operator|=
name|SVR4_RECLEN
argument_list|(
operator|&
name|idb
argument_list|,
operator|(
name|bdp
operator|->
name|d_namlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|svr4_reclen
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"+++ off = %d\n"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|off = *cookie++;
comment|/* each entry points to the next */
else|#
directive|else
name|off
operator|+=
name|reclen
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"+++ off = %d\n"
operator|,
name|off
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Massage in place to make a SVR4-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 */
name|idb
operator|.
name|d_ino
operator|=
operator|(
name|svr4_ino64_t
operator|)
name|bdp
operator|->
name|d_fileno
expr_stmt|;
name|idb
operator|.
name|d_off
operator|=
operator|(
name|svr4_off64_t
operator|)
name|off
expr_stmt|;
name|idb
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|svr4_reclen
expr_stmt|;
name|strcpy
argument_list|(
name|idb
operator|.
name|d_name
argument_list|,
name|bdp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|idb
argument_list|,
name|outp
argument_list|,
name|svr4_reclen
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|DPRINTF
argument_list|(
operator|(
literal|"d_ino = %d\nd_off = %d\nd_reclen = %d\n"
operator|,
name|idb
operator|.
name|d_ino
operator|,
name|idb
operator|.
name|d_off
operator|,
operator|(
name|u_short
operator|)
name|idb
operator|.
name|d_reclen
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"d_name = %s\n"
operator|,
name|idb
operator|.
name|d_name
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"(bdp->d_type = %d, reclen = %d, bdp->d_namelen = %d)\n"
operator|,
name|bdp
operator|->
name|d_type
operator|,
name|svr4_reclen
operator|,
name|bdp
operator|->
name|d_namlen
operator|)
argument_list|)
expr_stmt|;
comment|/* advance past this real entry */
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past SVR4-shaped entry */
name|outp
operator|+=
name|svr4_reclen
expr_stmt|;
name|resid
operator|-=
name|svr4_reclen
expr_stmt|;
name|offcnt
operator|+=
name|svr4_reclen
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"block finished\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* if we squished out the whole block, try again */
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
if|if
condition|(
name|outp
operator|==
operator|(
name|caddr_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|dp
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|eof
label|:
name|retval
operator|=
name|offcnt
expr_stmt|;
comment|/* SCARG(uap, nbytes) - resid;*/
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiebuf
condition|)
name|free
argument_list|(
name|cookiebuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"\t\treturning %d\n"
operator|,
name|retval
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|retval
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_getdents
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_getdents_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|bdp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
name|caddr_t
name|outp
decl_stmt|;
comment|/* SVR4-format */
name|int
name|resid
decl_stmt|,
name|svr4_reclen
decl_stmt|;
comment|/* SVR4-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|svr4_dirent
name|idb
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|;
name|u_long
modifier|*
name|cookiebuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookie
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|,
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|p
operator|->
name|p_fd
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|buflen
operator|=
name|min
argument_list|(
name|MAXBSIZE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_procp
operator|=
name|p
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
comment|/*          * First we read into the malloc'ed buffer, then          * we massage it into user space, one record at a time.          */
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookiebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|resid
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
goto|goto
name|eof
goto|;
for|for
control|(
name|cookie
operator|=
name|cookiebuf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
name|bdp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
expr_stmt|;
name|reclen
operator|=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
name|panic
argument_list|(
literal|"svr4_getdents: bad reclen"
argument_list|)
expr_stmt|;
name|off
operator|=
operator|*
name|cookie
operator|++
expr_stmt|;
comment|/* each entry points to the next */
if|if
condition|(
operator|(
name|off
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"svr4_getdents: dir offset too large for emulated program"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bdp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
continue|continue;
block|}
name|svr4_reclen
operator|=
name|SVR4_RECLEN
argument_list|(
operator|&
name|idb
argument_list|,
name|bdp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|svr4_reclen
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Massage in place to make a SVR4-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 */
name|idb
operator|.
name|d_ino
operator|=
operator|(
name|svr4_ino_t
operator|)
name|bdp
operator|->
name|d_fileno
expr_stmt|;
name|idb
operator|.
name|d_off
operator|=
operator|(
name|svr4_off_t
operator|)
name|off
expr_stmt|;
name|idb
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|svr4_reclen
expr_stmt|;
name|strcpy
argument_list|(
name|idb
operator|.
name|d_name
argument_list|,
name|bdp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|idb
argument_list|,
name|outp
argument_list|,
name|svr4_reclen
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past SVR4-shaped entry */
name|outp
operator|+=
name|svr4_reclen
expr_stmt|;
name|resid
operator|-=
name|svr4_reclen
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
operator|*
name|retval
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbytes
argument_list|)
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiebuf
condition|)
name|free
argument_list|(
name|cookiebuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_mmap
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_mmap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
name|mm
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|p
operator|->
name|p_retval
expr_stmt|;
define|#
directive|define
name|_MAP_NEW
value|0x80000000
comment|/*          * Verify the arguments.          */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
operator|&
operator|~
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX still needed? */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|prot
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|flags
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
operator|~
name|_MAP_NEW
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|addr
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|pos
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pos
argument_list|)
expr_stmt|;
return|return
name|mmap
argument_list|(
name|p
argument_list|,
operator|&
name|mm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_mmap64
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_mmap64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
name|mm
decl_stmt|;
name|void
modifier|*
name|rp
decl_stmt|;
define|#
directive|define
name|_MAP_NEW
value|0x80000000
comment|/*          * Verify the arguments.          */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
operator|&
operator|~
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX still needed? */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|prot
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|flags
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
operator|&
operator|~
name|_MAP_NEW
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|addr
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|pos
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|rp
operator|=
operator|(
name|void
operator|*
operator|)
name|round_page
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|flags
argument_list|)
operator|&
name|MAP_FIXED
operator|)
operator|==
literal|0
operator|&&
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|addr
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|void
operator|*
operator|)
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|addr
argument_list|)
operator|<
name|rp
condition|)
name|SCARG
argument_list|(
operator|&
name|mm
argument_list|,
name|addr
argument_list|)
operator|=
name|rp
expr_stmt|;
return|return
name|mmap
argument_list|(
name|p
argument_list|,
operator|&
name|mm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fchroot
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_fchroot_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|fdp
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|error
operator|=
name|ENOTDIR
expr_stmt|;
else|else
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_rdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|fdp
operator|->
name|fd_rdir
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_rdir
operator|=
name|vp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svr4_mknod
parameter_list|(
name|p
parameter_list|,
name|retval
parameter_list|,
name|path
parameter_list|,
name|mode
parameter_list|,
name|dev
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|svr4_mode_t
name|mode
decl_stmt|;
name|svr4_dev_t
name|dev
decl_stmt|;
block|{
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|struct
name|mkfifo_args
name|ap
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|path
argument_list|)
operator|=
name|path
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|mode
argument_list|)
operator|=
name|mode
expr_stmt|;
return|return
name|mkfifo
argument_list|(
name|p
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|mknod_args
name|ap
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|path
argument_list|)
operator|=
name|path
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|mode
argument_list|)
operator|=
name|mode
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|dev
argument_list|)
operator|=
name|dev
expr_stmt|;
return|return
name|mknod
argument_list|(
name|p
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_mknod
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_mknod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
return|return
name|svr4_mknod
argument_list|(
name|p
argument_list|,
name|retval
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mode
argument_list|)
argument_list|,
operator|(
name|svr4_dev_t
operator|)
name|svr4_to_bsd_odev_t
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|dev
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_xmknod
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_xmknod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
return|return
name|svr4_mknod
argument_list|(
name|p
argument_list|,
name|retval
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mode
argument_list|)
argument_list|,
operator|(
name|svr4_dev_t
operator|)
name|svr4_to_bsd_dev_t
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|dev
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_vhangup
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_vhangup_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_sysconfig
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_sysconfig_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
operator|&
operator|(
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|name
argument_list|)
condition|)
block|{
case|case
name|SVR4_CONFIG_UNUSED
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_NGROUPS
case|:
operator|*
name|retval
operator|=
name|NGROUPS_MAX
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_CHILD_MAX
case|:
operator|*
name|retval
operator|=
name|maxproc
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_OPEN_FILES
case|:
operator|*
name|retval
operator|=
name|maxfiles
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_POSIX_VER
case|:
operator|*
name|retval
operator|=
literal|198808
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_PAGESIZE
case|:
operator|*
name|retval
operator|=
name|PAGE_SIZE
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_CLK_TCK
case|:
operator|*
name|retval
operator|=
literal|60
expr_stmt|;
comment|/* should this be `hz', ie. 100? */
break|break;
case|case
name|SVR4_CONFIG_XOPEN_VER
case|:
operator|*
name|retval
operator|=
literal|2
expr_stmt|;
comment|/* XXX: What should that be? */
break|break;
case|case
name|SVR4_CONFIG_PROF_TCK
case|:
operator|*
name|retval
operator|=
literal|60
expr_stmt|;
comment|/* XXX: What should that be? */
break|break;
case|case
name|SVR4_CONFIG_NPROC_CONF
case|:
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* Only one processor for now */
break|break;
case|case
name|SVR4_CONFIG_NPROC_ONLN
case|:
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* And it better be online */
break|break;
case|case
name|SVR4_CONFIG_AIO_LISTIO_MAX
case|:
case|case
name|SVR4_CONFIG_AIO_MAX
case|:
case|case
name|SVR4_CONFIG_AIO_PRIO_DELTA_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No aio support */
break|break;
case|case
name|SVR4_CONFIG_DELAYTIMER_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No delaytimer support */
break|break;
case|case
name|SVR4_CONFIG_MQ_OPEN_MAX
case|:
operator|*
name|retval
operator|=
name|msginfo
operator|.
name|msgmni
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_MQ_PRIO_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Don't know */
break|break;
case|case
name|SVR4_CONFIG_RTSIG_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SEM_NSEMS_MAX
case|:
operator|*
name|retval
operator|=
name|seminfo
operator|.
name|semmni
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SEM_VALUE_MAX
case|:
operator|*
name|retval
operator|=
name|seminfo
operator|.
name|semvmx
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SIGQUEUE_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Don't know */
break|break;
case|case
name|SVR4_CONFIG_SIGRT_MIN
case|:
case|case
name|SVR4_CONFIG_SIGRT_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No real time signals */
break|break;
case|case
name|SVR4_CONFIG_TIMER_MAX
case|:
operator|*
name|retval
operator|=
literal|3
expr_stmt|;
comment|/* XXX: real, virtual, profiling */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
case|case
name|SVR4_CONFIG_PHYS_PAGES
case|:
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
operator|*
name|retval
operator|=
name|uvmexp
operator|.
name|free
expr_stmt|;
comment|/* XXX: free instead of total */
else|#
directive|else
operator|*
name|retval
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
comment|/* XXX: free instead of total */
endif|#
directive|endif
break|break;
case|case
name|SVR4_CONFIG_AVPHYS_PAGES
case|:
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
operator|*
name|retval
operator|=
name|uvmexp
operator|.
name|active
expr_stmt|;
comment|/* XXX: active instead of avg */
else|#
directive|else
operator|*
name|retval
operator|=
name|cnt
operator|.
name|v_active_count
expr_stmt|;
comment|/* XXX: active instead of avg */
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* NOTYET */
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|swap_pager_full
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|svr4_sys_break
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_break_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|,
name|base
decl_stmt|,
name|ns
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|base
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
argument_list|)
expr_stmt|;
name|ns
operator|=
operator|(
name|vm_offset_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
name|new
operator|=
name|round_page
argument_list|(
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|base
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|-
name|base
operator|)
operator|>
operator|(
name|unsigned
operator|)
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
block|{
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|new
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|new
operator|<
name|base
condition|)
block|{
comment|/* 		 * This is simply an invalid value.  If someone wants to 		 * do fancy address space manipulations, mmap and munmap 		 * can do most of what the user would want. 		 */
return|return
name|EINVAL
return|;
block|}
name|old
operator|=
name|base
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|old
condition|)
block|{
name|vm_size_t
name|diff
decl_stmt|;
if|if
condition|(
name|swap_pager_full
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|diff
operator|=
name|new
operator|-
name|old
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|old
argument_list|,
name|diff
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|vm
operator|->
name|vm_dsize
operator|+=
name|btoc
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new
operator|<
name|old
condition|)
block|{
name|rv
operator|=
name|vm_map_remove
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|vm
operator|->
name|vm_dsize
operator|-=
name|btoc
argument_list|(
name|old
operator|-
name|new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|clock_t
name|timeval_to_clock_t
parameter_list|(
name|tv
parameter_list|)
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|{
return|return
name|tv
operator|->
name|tv_sec
operator|*
name|hz
operator|+
name|tv
operator|->
name|tv_usec
operator|/
operator|(
literal|1000000
operator|/
name|hz
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_times
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_times_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
name|struct
name|tms
name|tms
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|struct
name|rusage
modifier|*
name|ru
decl_stmt|;
name|struct
name|rusage
name|r
decl_stmt|;
name|struct
name|getrusage_args
name|ga
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|ru
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ga
argument_list|,
name|who
argument_list|)
operator|=
name|RUSAGE_SELF
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ga
argument_list|,
name|rusage
argument_list|)
operator|=
name|ru
expr_stmt|;
name|error
operator|=
name|getrusage
argument_list|(
name|p
argument_list|,
operator|&
name|ga
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ru
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
name|r
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tms
operator|.
name|tms_utime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ga
argument_list|,
name|who
argument_list|)
operator|=
name|RUSAGE_CHILDREN
expr_stmt|;
name|error
operator|=
name|getrusage
argument_list|(
name|p
argument_list|,
operator|&
name|ga
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ru
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
name|r
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tms
operator|.
name|tms_cutime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|tp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tms
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_ulimit
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_ulimit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|SVR4_GFILLIM
case|:
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
operator|/
literal|512
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SVR4_SFILLIM
case|:
block|{
name|int
name|error
decl_stmt|;
name|struct
name|__setrlimit_args
name|srl
decl_stmt|;
name|struct
name|rlimit
name|krl
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|rlimit
modifier|*
name|url
init|=
operator|(
expr|struct
name|rlimit
operator|*
operator|)
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
expr|*
name|url
argument_list|)
decl_stmt|;
name|krl
operator|.
name|rlim_cur
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|newlimit
argument_list|)
operator|*
literal|512
expr_stmt|;
name|krl
operator|.
name|rlim_max
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_max
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|krl
argument_list|,
name|url
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|url
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|SCARG
argument_list|(
operator|&
name|srl
argument_list|,
name|which
argument_list|)
operator|=
name|RLIMIT_FSIZE
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|srl
argument_list|,
name|rlp
argument_list|)
operator|=
operator|(
expr|struct
name|orlimit
operator|*
operator|)
name|url
expr_stmt|;
name|error
operator|=
name|setrlimit
argument_list|(
name|p
argument_list|,
operator|&
name|srl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_FSIZE
index|]
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|SVR4_GMEMLIM
case|:
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|register_t
name|r
init|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
decl_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|r
operator|=
literal|0x7fffffff
expr_stmt|;
name|r
operator|+=
operator|(
name|long
operator|)
name|vm
operator|->
name|vm_daddr
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|r
operator|=
literal|0x7fffffff
expr_stmt|;
operator|*
name|retval
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|SVR4_GDESLIM
case|:
operator|*
name|retval
operator|=
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_NOFILE
index|]
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|proc
modifier|*
name|svr4_pfind
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* look in the live processes */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
name|p
return|;
comment|/* look in the zombies */
for|for
control|(
name|p
operator|=
name|zombproc
operator|.
name|lh_first
init|;
name|p
operator|!=
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|p_list
operator|.
name|le_next
control|)
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
return|return
name|p
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_pgrpsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_pgrpsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
comment|/* setpgrp() */
comment|/* 		 * SVR4 setpgrp() (which takes no arguments) has the 		 * semantics that the session ID is also created anew, so 		 * in almost every sense, setpgrp() is identical to 		 * setsid() for SVR4.  (Under BSD, the difference is that 		 * a setpgid(0,0) will not create a new session.) 		 */
name|setsid
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|0
case|:
comment|/* getpgrp() */
operator|*
name|retval
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|2
case|:
comment|/* getsid(pid) */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|=
name|svr4_pfind
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
comment|/* 		 * This has already been initialized to the pid of 		 * the session leader. 		 */
operator|*
name|retval
operator|=
operator|(
name|register_t
operator|)
name|p
operator|->
name|p_session
operator|->
name|s_leader
operator|->
name|p_pid
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|3
case|:
comment|/* setsid() */
return|return
name|setsid
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|4
case|:
comment|/* getpgid(pid) */
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|=
name|svr4_pfind
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
operator|*
name|retval
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|5
case|:
comment|/* setpgid(pid, pgid); */
block|{
name|struct
name|setpgid_args
name|sa
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|pid
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|pgid
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|pgid
argument_list|)
expr_stmt|;
return|return
name|setpgid
argument_list|(
name|p
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|syscallarg
parameter_list|(
name|x
parameter_list|)
value|union { x datum; register_t pad; }
end_define

begin_struct
struct|struct
name|svr4_hrtcntl_args
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|fun
decl_stmt|;
name|int
name|clk
decl_stmt|;
name|svr4_hrt_interval_t
modifier|*
name|iv
decl_stmt|;
name|svr4_hrt_time_t
modifier|*
name|ti
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|svr4_hrtcntl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_hrtcntl_args
modifier|*
name|uap
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
block|{
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fun
argument_list|)
condition|)
block|{
case|case
name|SVR4_HRT_CNTL_RES
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(RES)\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|SVR4_HRT_USEC
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SVR4_HRT_CNTL_TOFD
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(TOFD)\n"
operator|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|svr4_hrt_time_t
name|t
decl_stmt|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|clk
argument_list|)
operator|!=
name|SVR4_HRT_CLK_STD
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"clk == %d\n"
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|clk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|ti
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ti NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|t
operator|.
name|h_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|t
operator|.
name|h_rem
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|t
operator|.
name|h_res
operator|=
name|SVR4_HRT_USEC
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|t
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|ti
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|SVR4_HRT_CNTL_START
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(START)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_CNTL_GET
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(GET)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"Bad htrcntl command %d\n"
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fun
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_hrtsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_hrtsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|SVR4_HRT_CNTL
case|:
return|return
name|svr4_hrtcntl
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|svr4_hrtcntl_args
operator|*
operator|)
name|uap
argument_list|,
name|retval
argument_list|)
return|;
case|case
name|SVR4_HRT_ALRM
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtalarm\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_SLP
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtsleep\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_CAN
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtcancel\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"Bad hrtsys command %d\n"
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|svr4_setinfo
parameter_list|(
name|p
parameter_list|,
name|st
parameter_list|,
name|s
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|st
decl_stmt|;
name|svr4_siginfo_t
modifier|*
name|s
decl_stmt|;
block|{
name|svr4_siginfo_t
name|i
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|si_signo
operator|=
name|SVR4_SIGCHLD
expr_stmt|;
name|i
operator|.
name|si_errno
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
if|if
condition|(
name|p
condition|)
block|{
name|i
operator|.
name|si_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SZOMB
condition|)
block|{
name|i
operator|.
name|si_stime
operator|=
name|p
operator|->
name|p_ru
operator|->
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|i
operator|.
name|si_utime
operator|=
name|p
operator|->
name|p_ru
operator|->
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|si_stime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|i
operator|.
name|si_utime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
block|}
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|i
operator|.
name|si_status
operator|=
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_EXITED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WSTOPSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|i
operator|.
name|si_status
operator|=
name|bsd_to_svr4_sig
index|[
name|sig
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|si_status
operator|==
name|SVR4_SIGCONT
condition|)
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_CONTINUED
expr_stmt|;
else|else
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_STOPPED
expr_stmt|;
block|}
else|else
block|{
name|sig
operator|=
name|WTERMSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|i
operator|.
name|si_status
operator|=
name|bsd_to_svr4_sig
index|[
name|sig
index|]
expr_stmt|;
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|st
argument_list|)
condition|)
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_DUMPED
expr_stmt|;
else|else
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_KILLED
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"siginfo [pid %ld signo %d code %d errno %d status %d]\n"
operator|,
name|i
operator|.
name|si_pid
operator|,
name|i
operator|.
name|si_signo
operator|,
name|i
operator|.
name|si_code
operator|,
name|i
operator|.
name|si_errno
operator|,
name|i
operator|.
name|si_status
operator|)
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_waitsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_waitsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|nfound
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
name|struct
name|proc
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|grp
argument_list|)
condition|)
block|{
case|case
name|SVR4_P_PID
case|:
break|break;
case|case
name|SVR4_P_PGID
case|:
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|=
operator|-
name|p
operator|->
name|p_pgid
expr_stmt|;
break|break;
case|case
name|SVR4_P_ALL
case|:
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|=
name|WAIT_ANY
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"waitsys(%d, %d, %p, %x)\n"
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|grp
argument_list|)
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|info
argument_list|)
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|loop
label|:
name|nfound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|p_children
operator|.
name|lh_first
init|;
name|q
operator|!=
literal|0
condition|;
name|q
operator|=
name|q
operator|->
name|p_sibling
operator|.
name|le_next
control|)
block|{
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|!=
name|WAIT_ANY
operator|&&
name|q
operator|->
name|p_pid
operator|!=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|&&
name|q
operator|->
name|p_pgid
operator|!=
operator|-
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"pid %d pgid %d != %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|,
name|q
operator|->
name|p_pgid
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|id
argument_list|)
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nfound
operator|++
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|p_stat
operator|==
name|SZOMB
operator|&&
operator|(
operator|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|&
operator|(
name|SVR4_WEXITED
operator||
name|SVR4_WTRAPPED
operator|)
operator|)
operator|)
condition|)
block|{
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"found %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|svr4_setinfo
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|p_xstat
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|info
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|&
name|SVR4_WNOWAIT
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Don't wait\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * If we got the child via ptrace(2) or procfs, and 			 * the parent is different (meaning the process was 			 * attached, rather than run as a child), then we need 			 * to give it back to the ol dparent, and send the 			 * parent a SIGCHLD.  The rest of the cleanup will be 			 * done when the old parent waits on the child. 			 */
if|if
condition|(
operator|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|&&
name|q
operator|->
name|p_oppid
operator|!=
name|q
operator|->
name|p_pptr
operator|->
name|p_pid
condition|)
block|{
name|t
operator|=
name|pfind
argument_list|(
name|q
operator|->
name|p_oppid
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|q
argument_list|,
name|t
condition|?
name|t
else|:
name|initproc
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_oppid
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_WAITED
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|q
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|q
operator|->
name|p_xstat
operator|=
literal|0
expr_stmt|;
name|ruadd
argument_list|(
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_cru
argument_list|,
name|q
operator|->
name|p_ru
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|q
operator|->
name|p_ru
argument_list|,
name|M_ZOMBIE
argument_list|)
expr_stmt|;
comment|/* 			 * Finally finished with old proc entry. 			 * Unlink it from its process group and free it. 			 */
name|leavepgrp
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
comment|/* off zombproc */
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
comment|/* 			 * Decrement the count of procs running with this uid. 			 */
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|q
operator|->
name|p_cred
operator|->
name|p_ruid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Free up credentials. 			 */
if|if
condition|(
operator|--
name|q
operator|->
name|p_cred
operator|->
name|p_refcnt
operator|==
literal|0
condition|)
block|{
name|crfree
argument_list|(
name|q
operator|->
name|p_cred
operator|->
name|pc_ucred
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|q
operator|->
name|p_cred
argument_list|,
name|M_SUBPROC
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Release reference to text vnode 			 */
if|if
condition|(
name|q
operator|->
name|p_textvp
condition|)
name|vrele
argument_list|(
name|q
operator|->
name|p_textvp
argument_list|)
expr_stmt|;
comment|/* 			 * Give machine-dependent layer a chance 			 * to free anything that cpu_exit couldn't 			 * release while still running in process context. 			 */
name|cpu_wait
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|pool_put
argument_list|(
operator|&
name|proc_pool
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nprocs
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|q
operator|->
name|p_stat
operator|==
name|SSTOP
operator|&&
operator|(
name|q
operator|->
name|p_flag
operator|&
name|P_WAITED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|||
operator|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|&
operator|(
name|SVR4_WSTOPPED
operator||
name|SVR4_WCONTINUED
operator|)
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"jobcontrol %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|&
name|SVR4_WNOWAIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|q
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
return|return
name|svr4_setinfo
argument_list|(
name|q
argument_list|,
name|W_STOPCODE
argument_list|(
name|q
operator|->
name|p_xstat
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|info
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
return|return
name|ECHILD
return|;
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|options
argument_list|)
operator|&
name|SVR4_WNOHANG
condition|)
block|{
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|svr4_setinfo
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|info
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"svr4_wait"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs
parameter_list|(
name|bfs
parameter_list|,
name|sfs
parameter_list|)
specifier|const
name|struct
name|statfs
modifier|*
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
modifier|*
name|sfs
decl_stmt|;
block|{
name|sfs
operator|->
name|f_bsize
operator|=
name|bfs
operator|->
name|f_iosize
expr_stmt|;
comment|/* XXX */
name|sfs
operator|->
name|f_frsize
operator|=
name|bfs
operator|->
name|f_bsize
expr_stmt|;
name|sfs
operator|->
name|f_blocks
operator|=
name|bfs
operator|->
name|f_blocks
expr_stmt|;
name|sfs
operator|->
name|f_bfree
operator|=
name|bfs
operator|->
name|f_bfree
expr_stmt|;
name|sfs
operator|->
name|f_bavail
operator|=
name|bfs
operator|->
name|f_bavail
expr_stmt|;
name|sfs
operator|->
name|f_files
operator|=
name|bfs
operator|->
name|f_files
expr_stmt|;
name|sfs
operator|->
name|f_ffree
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_favail
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_fsid
operator|=
name|bfs
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|)
argument_list|)
expr_stmt|;
name|sfs
operator|->
name|f_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_RDONLY
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_NOSUID
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_NOSUID
expr_stmt|;
name|sfs
operator|->
name|f_namemax
operator|=
name|MAXNAMLEN
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|memset
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs64
parameter_list|(
name|bfs
parameter_list|,
name|sfs
parameter_list|)
specifier|const
name|struct
name|statfs
modifier|*
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
modifier|*
name|sfs
decl_stmt|;
block|{
name|sfs
operator|->
name|f_bsize
operator|=
name|bfs
operator|->
name|f_iosize
expr_stmt|;
comment|/* XXX */
name|sfs
operator|->
name|f_frsize
operator|=
name|bfs
operator|->
name|f_bsize
expr_stmt|;
name|sfs
operator|->
name|f_blocks
operator|=
name|bfs
operator|->
name|f_blocks
expr_stmt|;
name|sfs
operator|->
name|f_bfree
operator|=
name|bfs
operator|->
name|f_bfree
expr_stmt|;
name|sfs
operator|->
name|f_bavail
operator|=
name|bfs
operator|->
name|f_bavail
expr_stmt|;
name|sfs
operator|->
name|f_files
operator|=
name|bfs
operator|->
name|f_files
expr_stmt|;
name|sfs
operator|->
name|f_ffree
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_favail
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_fsid
operator|=
name|bfs
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|)
argument_list|)
expr_stmt|;
name|sfs
operator|->
name|f_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_RDONLY
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_NOSUID
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_NOSUID
expr_stmt|;
name|sfs
operator|->
name|f_namemax
operator|=
name|MAXNAMLEN
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|memset
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|svr4_sys_statvfs
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_statvfs_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|statfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|buf
argument_list|)
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|statfs
argument_list|(
name|p
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fstatvfs
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_fstatvfs_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|fstatfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|buf
argument_list|)
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fstatfs
argument_list|(
name|p
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_statvfs64
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_statvfs64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|statfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|p
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|buf
argument_list|)
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|statfs
argument_list|(
name|p
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs64
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fstatvfs64
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_fstatvfs64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|fstatfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fs_args
argument_list|,
name|buf
argument_list|)
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fstatfs
argument_list|(
name|p
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs64
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fs
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_alarm
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_alarm_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|itimerval
modifier|*
name|itp
decl_stmt|,
modifier|*
name|oitp
decl_stmt|;
name|struct
name|setitimer_args
name|sa
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|itp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|itp
argument_list|)
argument_list|)
expr_stmt|;
name|oitp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oitp
argument_list|)
argument_list|)
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|itp
operator|->
name|it_interval
argument_list|)
expr_stmt|;
name|itp
operator|->
name|it_value
operator|.
name|tv_sec
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|itp
operator|->
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|which
argument_list|)
operator|=
name|ITIMER_REAL
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|itv
argument_list|)
operator|=
name|itp
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|sa
argument_list|,
name|oitv
argument_list|)
operator|=
name|oitp
expr_stmt|;
name|error
operator|=
name|setitimer
argument_list|(
name|p
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|oitp
operator|->
name|it_value
operator|.
name|tv_usec
condition|)
name|oitp
operator|->
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|oitp
operator|->
name|it_value
operator|.
name|tv_sec
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_gettimeofday
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_gettimeofday_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|struct
name|timeval
name|atv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|atv
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|tp
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|atv
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_facl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_facl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|p
operator|->
name|p_retval
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|SVR4_SYS_SETACL
case|:
comment|/* We don't support acls on any filesystem */
return|return
name|ENOSYS
return|;
case|case
name|SVR4_SYS_GETACL
case|:
return|return
name|copyout
argument_list|(
name|retval
argument_list|,
operator|&
name|SCARG
argument_list|(
name|uap
argument_list|,
name|num
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|num
argument_list|)
argument_list|)
argument_list|)
return|;
case|case
name|SVR4_SYS_GETACLCNT
case|:
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_acl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_acl_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* XXX: for now the same */
return|return
name|svr4_sys_facl
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|svr4_sys_facl_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_auditsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_auditsys_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* 	 * XXX: Big brother is *not* watching. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_memcntl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_memcntl_args
modifier|*
name|uap
decl_stmt|;
block|{
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|SVR4_MC_SYNC
case|:
block|{
name|struct
name|msync_args
name|msa
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|msa
argument_list|,
name|addr
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|msa
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|msa
argument_list|,
name|flags
argument_list|)
operator|=
operator|(
name|int
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|msync
argument_list|(
name|p
argument_list|,
operator|&
name|msa
argument_list|)
return|;
block|}
case|case
name|SVR4_MC_ADVISE
case|:
block|{
name|struct
name|madvise_args
name|maa
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|maa
argument_list|,
name|addr
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|maa
argument_list|,
name|len
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|maa
argument_list|,
name|behav
argument_list|)
operator|=
operator|(
name|int
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|madvise
argument_list|(
name|p
argument_list|,
operator|&
name|maa
argument_list|)
return|;
block|}
case|case
name|SVR4_MC_LOCK
case|:
case|case
name|SVR4_MC_UNLOCK
case|:
case|case
name|SVR4_MC_LOCKAS
case|:
case|case
name|SVR4_MC_UNLOCKAS
case|:
return|return
name|EOPNOTSUPP
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_nice
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_nice_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|setpriority_args
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|which
argument_list|)
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|who
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|prio
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|prio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|setpriority
argument_list|(
name|p
argument_list|,
operator|&
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* the cast is stupid, but the structures are the same */
if|if
condition|(
operator|(
name|error
operator|=
name|getpriority
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|getpriority_args
operator|*
operator|)
operator|&
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_resolvepath
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|svr4_sys_resolvepath_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|p
operator|->
name|p_retval
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|SAVENAME
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|bufsiz
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
operator|*
name|retval
operator|=
name|strlen
argument_list|(
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
operator|<
name|SCARG
argument_list|(
name|uap
argument_list|,
name|bufsiz
argument_list|)
condition|?
name|strlen
argument_list|(
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
operator|+
literal|1
else|:
name|SCARG
argument_list|(
name|uap
argument_list|,
name|bufsiz
argument_list|)
expr_stmt|;
name|bad
label|:
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|namei_zone
argument_list|,
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

