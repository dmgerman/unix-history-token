begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)clnp_raw.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 				Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/clnp_raw.c,v $ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_user.h>
end_include

begin_comment
comment|/* XXX -- defines SOL_NETWORK */
end_comment

begin_decl_stmt
name|struct
name|sockproto
name|rclnp_proto
init|=
block|{
name|PF_ISO
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * FUNCTION:		rclnp_input  *  * PURPOSE:			Setup generic address an protocol structures for  *					raw input routine, then pass them along with the  *					mbuf chain.  *  * RETURNS:			none  *  * SIDE EFFECTS:  *  * NOTES:			The protocol field of rclnp_proto is set to zero indicating  *					no protocol.  */
end_comment

begin_macro
name|rclnp_input
argument_list|(
argument|m
argument_list|,
argument|src
argument_list|,
argument|dst
argument_list|,
argument|hdrlen
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to packet */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|src
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to src address */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to dest address */
end_comment

begin_decl_stmt
name|int
name|hdrlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length (in bytes) of clnp header */
end_comment

begin_block
block|{
ifdef|#
directive|ifdef
name|TROLL
if|if
condition|(
name|trollctl
operator|.
name|tr_ops
operator|&
name|TR_CHUCK
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* TROLL */
name|raw_input
argument_list|(
name|m
argument_list|,
operator|&
name|rclnp_proto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		rclnp_output  *  * PURPOSE:			Prepare to send a raw clnp packet. Setup src and dest  *					addresses, count the number of bytes to send, and  *					call clnp_output.  *  * RETURNS:			success - 0  *					failure - an appropriate error code  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|rclnp_output
argument_list|(
argument|m0
argument_list|,
argument|so
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* packet to send */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket to send from */
end_comment

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* used to scan a chain */
name|int
name|len
init|=
literal|0
decl_stmt|;
comment|/* store length of chain here */
name|struct
name|rawisopcb
modifier|*
name|rp
init|=
name|sotorawisopcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* ptr to raw cb */
name|int
name|error
decl_stmt|;
comment|/* return value of function */
name|int
name|flags
decl_stmt|;
comment|/* flags for clnp_output */
if|if
condition|(
literal|0
operator|==
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 *	Set up src address. If user has bound socket to an address, use it. 	 *	Otherwise, do not specify src (clnp_output will fill it in). 	 */
if|if
condition|(
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_laddr
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sladdr
operator|.
name|siso_family
operator|!=
name|AF_ISO
condition|)
block|{
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
comment|/* set up dest address */
if|if
condition|(
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_faddr
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sfaddr
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_faddr
expr_stmt|;
name|rp
operator|->
name|risop_isop
operator|.
name|isop_faddr
operator|=
operator|&
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sfaddr
expr_stmt|;
comment|/* get flags and ship it off */
name|flags
operator|=
name|rp
operator|->
name|risop_flags
operator|&
name|CLNP_VFLAGS
expr_stmt|;
name|error
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|rp
operator|->
name|risop_isop
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|flags
operator||
name|CLNP_NOCACHE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		rclnp_ctloutput  *  * PURPOSE:			Raw clnp socket option processing  *					All options are stored inside an mbuf.  *  * RETURNS:			success - 0  *					failure - unix error code  *  * SIDE EFFECTS:	If the options mbuf does not exist, it the mbuf passed  *					is used.  *  * NOTES:  */
end_comment

begin_macro
name|rclnp_ctloutput
argument_list|(
argument|op
argument_list|,
argument|so
argument_list|,
argument|level
argument_list|,
argument|optname
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|int
name|op
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of operation */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to socket */
end_comment

begin_decl_stmt
name|int
name|level
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* level of option */
end_comment

begin_decl_stmt
name|int
name|optname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of option */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to ptr to option data */
end_comment

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|rawisopcb
modifier|*
name|rp
init|=
name|sotorawisopcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* raw cb ptr */
name|IFDEBUG
argument_list|(
argument|D_CTLOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"rclnp_ctloutput: op = x%x, level = x%x, name = x%x\n"
argument_list|,
name|op
argument_list|,
name|level
argument_list|,
name|optname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|m
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rclnp_ctloutput: %d bytes of mbuf data\n"
argument_list|,
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
operator|(
operator|*
name|m
operator|)
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
ifdef|#
directive|ifdef
name|SOL_NETWORK
if|if
condition|(
name|level
operator|!=
name|SOL_NETWORK
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
switch|switch
condition|(
name|op
condition|)
block|{
else|#
directive|else
switch|switch
condition|(
name|op
condition|)
block|{
endif|#
directive|endif
comment|/* SOL_NETWORK */
case|case
name|PRCO_SETOPT
case|:
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|CLNPOPT_FLAGS
case|:
block|{
name|u_short
name|usr_flags
decl_stmt|;
comment|/* 					 *	Insure that the data passed has exactly one short in it 					 */
if|if
condition|(
operator|(
operator|*
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
operator|*
name|m
operator|)
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 					 *	Don't allow invalid flags to be set 					 */
name|usr_flags
operator|=
operator|(
operator|*
name|mtod
argument_list|(
operator|(
operator|*
name|m
operator|)
argument_list|,
name|short
operator|*
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|usr_flags
operator|&
operator|(
name|CLNP_VFLAGS
operator|)
operator|)
operator|!=
name|usr_flags
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
name|rp
operator|->
name|risop_flags
operator||=
name|usr_flags
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOPT_OPTS
case|:
if|if
condition|(
name|error
operator|=
name|clnp_set_opts
argument_list|(
operator|&
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
argument_list|,
name|m
argument_list|)
condition|)
break|break;
name|rp
operator|->
name|risop_isop
operator|.
name|isop_optindex
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|clnp_opt_sanity
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
argument_list|,
name|mtod
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_optindex
argument_list|,
expr|struct
name|clnp_optidx
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|PRCO_GETOPT
case|:
ifdef|#
directive|ifdef
name|notdef
comment|/* commented out to keep hi C quiet */
switch|switch
condition|(
name|optname
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* notdef */
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|==
name|PRCO_SETOPT
condition|)
block|{
comment|/* note: m_freem does not barf is *m is NULL */
name|m_freem
argument_list|(
operator|*
name|m
argument_list|)
expr_stmt|;
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
comment|/*ARGSUSED*/
name|clnp_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|control
argument_list|)
specifier|register
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
name|int
name|req
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|control
decl_stmt|;
block|{
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|rawisopcb
modifier|*
name|rp
init|=
name|sotorawisopcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|rp
operator|=
name|sotorawisopcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|rp
condition|)
name|panic
argument_list|(
literal|"rip_attach"
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rp
argument_list|,
expr|struct
name|rawisopcb
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|rp
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
sizeof|sizeof
expr|*
name|rp
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|rp
expr_stmt|;
break|break;
case|case
name|PRU_DETACH
case|:
if|if
condition|(
name|rp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"rip_detach"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
condition|)
name|m_freem
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_options
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_route
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_laddr
condition|)
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_laddr
operator|=
literal|0
expr_stmt|;
comment|/* free clnp cached hdr if necessary */
if|if
condition|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_clnpcache
operator|!=
name|NULL
condition|)
block|{
name|struct
name|clnp_cache
modifier|*
name|clcp
init|=
name|mtod
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_clnpcache
argument_list|,
expr|struct
name|clnp_cache
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|clcp
operator|->
name|clc_hdr
operator|!=
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|clcp
operator|->
name|clc_hdr
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_clnpcache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_optindex
operator|!=
name|NULL
condition|)
name|m_free
argument_list|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_optindex
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
block|{
name|struct
name|sockaddr_iso
modifier|*
name|addr
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|nam
operator|->
name|m_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ifnet
operator|==
literal|0
operator|)
operator|||
operator|(
name|addr
operator|->
name|siso_family
operator|!=
name|AF_ISO
operator|)
operator|||
operator|(
name|addr
operator|->
name|siso_addr
operator|.
name|isoa_len
operator|&&
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sladdr
operator|=
operator|*
name|addr
expr_stmt|;
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_laddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_laddr
operator|=
operator|&
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sladdr
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|PRU_CONNECT
case|:
block|{
name|struct
name|sockaddr_iso
modifier|*
name|addr
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|nam
operator|->
name|m_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
operator|)
operator|||
operator|(
name|addr
operator|->
name|siso_len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifnet
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
if|if
condition|(
name|addr
operator|->
name|siso_family
operator|!=
name|AF_ISO
condition|)
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sfaddr
operator|=
operator|*
name|addr
expr_stmt|;
name|rp
operator|->
name|risop_rcb
operator|.
name|rcb_faddr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|rp
operator|->
name|risop_isop
operator|.
name|isop_faddr
operator|=
operator|&
name|rp
operator|->
name|risop_isop
operator|.
name|isop_sfaddr
operator|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|error
operator|=
name|raw_usrreq
argument_list|(
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|req
operator|==
name|PRU_ATTACH
operator|&&
name|so
operator|->
name|so_pcb
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

end_unit

