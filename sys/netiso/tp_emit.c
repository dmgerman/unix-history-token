begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_emit.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  *  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_emit.c,v $  *  * This file contains tp_emit() and tp_error_emit(), which  * form TPDUs and hand them to ip.  * They take data in the form of mbuf chain, allocate mbufs as  * necessary for headers, and set the fields as appropriate from  * information found in the tpcb and net-level pcb.  *  * The worst thing about this code is adding the variable-length  * options on a machine that requires alignment for any memory access  * that isn't of size 1.  See the macro ADDOPTION() below.  *  * We don't do any concatenation. (There's a kludge to test the  * basic mechanism of separation under the 'w' tpdebug option, that's all.)  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_meas.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRUE
end_ifdef

begin_undef
undef|#
directive|undef
name|FALSE
end_undef

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_function_decl
name|void
name|iso_gen_csum
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Here is a mighty kludge.  The token ring misorders packets if you  * fire them at it too fast, and TP sans checksum is "too fast", so  * we have introduced a delay when checksumming isn't used.  */
end_comment

begin_decl_stmt
name|char
name|tp_delay
init|=
literal|0x00
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay to keep token ring from blowing it */
end_comment

begin_comment
comment|/*  * NAME:	tp_emit()  *  * CALLED FROM: tp.trans and from tp_sbsend()  *  * FUNCTION and ARGUMENTS:  * 	Emits one tpdu of the type (dutype), of the format appropriate  * 	to the connection described by the pcb (tpcb), with sequence  * 	number (seq) (where appropriate), end-of-tsdu bit (eot) where  * 	appropriate, and with the data in the mbuf chain (data).  * 	For DR and ER tpdus, the argument (eot) is  * 	the reason for issuing the tpdu rather than an end-of-tsdu indicator.  *  * RETURNS:  * 	0  OK  * 	ENOBUFS  * 	E* returned from net layer output rtn  *  * SIDE EFFECTS:  *  * NOTES:  *  * 	WE ASSUME that the tp header + all options will fit in ONE mbuf.  *	If mbufs are 256 this will most likely be true, but if they are 128 it's  *	possible that they won't.  *	If you used every option on the CR + max. user data you'd overrun  *	112 but unless you used> 115 bytes for the security  *	parameter, it would fit in a 256-byte mbuf (240 bytes for the header)  *	We don't support the security parameter, so this isn't a problem.  *	If security is added, we ought to remove this assumption.  *  *  We do not implement the flow control confirmation "element of procedure".  *  A) it should not affect interoperability,  *  B) it should not be necessary - the protocol will eventually  *   	straighten things out w/o FCC, as long as we don't have severely  *		mismatched keepalive and inactivity timers, and  *	C) it appears not to be REQUIRED, and  *  D) it's incredibly grotesque, and no doubt will lengthen a few  *   	critical paths.  *  HOWEVER, we're thinking about putting it in anyway, for  *  completeness, just like we did with ack subsequencing.  */
end_comment

begin_function
name|int
name|tp_emit
parameter_list|(
name|dutype
parameter_list|,
name|tpcb
parameter_list|,
name|seq
parameter_list|,
name|eot
parameter_list|,
name|data
parameter_list|)
name|int
name|dutype
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
name|u_int
name|eot
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|tpdu
modifier|*
name|hdr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|csum_offset
init|=
literal|0
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|SeqNum
name|olduwe
decl_stmt|;
name|int
name|acking_ooo
decl_stmt|;
comment|/* NOTE: 	 * here we treat tpdu_li as if it DID include the li field, up until 	 * the end, at which time we subtract 1 	 * THis is because if we subtract 1 right away, we end up adding 	 * one every time we add an option. 	 */
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_emit dutype 0x%x, tpcb 0x%x, eot 0x%x, seq 0x%x, data 0x%x"
argument_list|,
name|dutype
argument_list|,
name|tpcb
argument_list|,
name|eot
argument_list|,
name|seq
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|dutype
operator|==
name|CR_TPDU
operator|||
name|dutype
operator|==
name|CC_TPDU
condition|)
block|{
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|u_long
operator|)
literal|256
argument_list|,
name|M_MBUF
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|m
operator|->
name|m_type
operator|=
name|TPMT_TPHDR
expr_stmt|;
name|mbstat
operator|.
name|m_mtypes
index|[
name|TPMT_TPHDR
index|]
operator|++
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|MNULL
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|MNULL
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_pktdat
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|M_PKTHDR
expr_stmt|;
block|}
block|}
else|else
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|TPMT_TPHDR
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_data
operator|+=
name|max_hdr
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|data
operator|!=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
name|m_freem
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpdu
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tpdu
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
name|tp_headersize
parameter_list|()
function_decl|;
name|hdr
operator|->
name|tpdu_type
operator|=
name|dutype
expr_stmt|;
name|hdr
operator|->
name|tpdu_li
operator|=
name|tp_headersize
argument_list|(
name|dutype
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
comment|/* 		 * class 0 doesn't use this for DT 		 * it'll just get overwritten below 		 */
name|hdr
operator|->
name|tpdu_dref
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
operator|||
operator|(
name|dutype
operator|==
name|CR_TPDU_type
operator|&&
operator|(
name|tpcb
operator|->
name|tp_class
operator|&
name|TP_CLASS_4
operator|)
operator|)
condition|)
block|{
name|csum_offset
operator|=
name|hdr
operator|->
name|tpdu_li
operator|+
literal|2
expr_stmt|;
comment|/* DOESN'T include csum */
name|ADDOPTION
argument_list|(
name|TPP_checksum
argument_list|,
name|hdr
argument_list|,
literal|2
argument_list|,
name|eot
comment|/* dummy arg */
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"tp_emit: csum_offset 0x%x, hdr->tpdu_li 0x%x\n"
argument_list|,
name|csum_offset
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
comment|/* 		 * VARIABLE PARTS... 		 */
switch|switch
condition|(
name|dutype
condition|)
block|{
case|case
name|CR_TPDU_type
case|:
name|hdr
operator|->
name|tpdu_CRdref_0
operator|=
literal|0
expr_stmt|;
comment|/* must be zero */
case|case
name|CC_TPDU_type
case|:
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_cebit_off
condition|)
block|{
name|tpcb
operator|->
name|tp_win_recv
operator|=
name|tp_start_win
operator|<<
literal|8
expr_stmt|;
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|CONG_INIT_SAMPLE
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
else|else
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
comment|/* Case CC_TPDU_type used to be here */
block|{
name|u_char
name|x
decl_stmt|;
name|hdr
operator|->
name|tpdu_CCsref
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
comment|/* same as CRsref */
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|>
name|TP_CLASS_1
condition|)
block|{
name|tpcb
operator|->
name|tp_sent_uwe
operator|=
name|tpcb
operator|->
name|tp_lcredit
operator|-
literal|1
expr_stmt|;
name|tpcb
operator|->
name|tp_sent_rcvnxt
operator|=
literal|1
expr_stmt|;
name|tpcb
operator|->
name|tp_sent_lcdt
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
name|hdr
operator|->
name|tpdu_cdt
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|TPCONS
if|if
condition|(
name|tpcb
operator|->
name|tp_netservice
operator|==
name|ISO_CONS
condition|)
block|{
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
name|struct
name|pklcd
modifier|*
name|lcp
init|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
operator|(
name|isop
operator|->
name|isop_chan
operator|)
decl_stmt|;
name|lcp
operator|->
name|lcd_flags
operator|&=
operator|~
name|X25_DG_CIRCUIT
expr_stmt|;
block|}
endif|#
directive|endif
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|tpdu_CCclass
operator|=
name|tp_mask_to_num
argument_list|(
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_CCoptions
operator|=
operator|(
name|tpcb
operator|->
name|tp_xtd_format
condition|?
name|TPO_XTD_FMT
else|:
literal|0
operator|)
operator||
operator|(
name|tpcb
operator|->
name|tp_use_efc
condition|?
name|TPO_USE_EFC
else|:
literal|0
operator|)
expr_stmt|;
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|u_char
name|perf_meas
init|=
name|tpcb
operator|->
name|tp_perf_on
decl_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_perf_meas
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|perf_meas
argument_list|)
argument_list|,
name|perf_meas
argument_list|)
expr_stmt|;
name|ENDPERF
if|if
condition|(
name|dutype
operator|==
name|CR_TPDU_type
condition|)
block|{
name|IncStat
argument_list|(
name|ts_CR_sent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_fsuffixlen
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_calling_sufx
argument_list|,
name|hdr
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_called_sufx
argument_list|,
name|hdr
argument_list|,
name|tpcb
operator|->
name|tp_fsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_fsuffix
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IncStat
argument_list|(
name|ts_CC_sent
argument_list|)
expr_stmt|;
block|}
name|ADDOPTION
argument_list|(
name|TPP_tpdu_size
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_tpdusize
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_tpdusize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
condition|)
block|{
name|short
name|millisec
init|=
literal|500
operator|*
operator|(
name|tpcb
operator|->
name|tp_sendack_ticks
operator|)
decl_stmt|;
name|millisec
operator|=
name|htons
argument_list|(
name|millisec
argument_list|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_acktime
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|,
name|millisec
argument_list|)
expr_stmt|;
name|x
operator|=
operator|(
name|tpcb
operator|->
name|tp_use_nxpd
condition|?
name|TPAO_USE_NXPD
else|:
literal|0
operator|)
operator||
operator|(
name|tpcb
operator|->
name|tp_use_rcc
condition|?
name|TPAO_USE_RCC
else|:
literal|0
operator|)
operator||
operator|(
name|tpcb
operator|->
name|tp_use_checksum
condition|?
literal|0
else|:
name|TPAO_NO_CSUM
operator|)
operator||
operator|(
name|tpcb
operator|->
name|tp_xpd_service
condition|?
name|TPAO_USE_TXPD
else|:
literal|0
operator|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_addl_opt
argument_list|,
name|hdr
argument_list|,
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_l_tpdusize
operator|^
operator|(
literal|1
operator|<<
name|tpcb
operator|->
name|tp_tpdusize
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_short
name|size_s
init|=
name|tpcb
operator|->
name|tp_l_tpdusize
operator|>>
literal|7
decl_stmt|;
name|u_char
name|size_c
init|=
name|size_s
decl_stmt|;
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_l_tpdusize
operator|<
literal|65536
operator|*
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|dutype
operator|==
name|CR_TPDU_type
condition|)
name|tpcb
operator|->
name|tp_ptpdusize
operator|=
name|size_s
expr_stmt|;
if|if
condition|(
name|size_s
operator|<
literal|256
condition|)
block|{
name|ADDOPTION
argument_list|(
name|TPP_ptpdu_size
argument_list|,
name|hdr
argument_list|,
literal|1
argument_list|,
name|size_c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_s
operator|=
name|htons
argument_list|(
name|size_s
argument_list|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_ptpdu_size
argument_list|,
name|hdr
argument_list|,
literal|2
argument_list|,
name|size_s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|dutype
operator|==
name|CR_TPDU_type
operator|)
operator|&&
operator|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_vers
argument_list|)
argument_list|)
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_vers
argument_list|,
name|hdr
argument_list|,
literal|1
argument_list|,
name|tpcb
operator|->
name|tp_vers
argument_list|)
expr_stmt|;
comment|/* for each alt protocol class x, 					 * 	x = x<<4; 					 *  option = concat(option, x); 					 * Well, for now we only have TP0 for an 					 * alternative so... this is easy. 					 * 					 * HOWEVER... There should be NO alt protocol 					 * class over CLNS.  Need to see if the route suggests 					 * CONS, and iff so add alt class. 					 */
name|x
operator|=
literal|0
expr_stmt|;
name|ADDOPTION
argument_list|(
name|TPP_alt_class
argument_list|,
name|hdr
argument_list|,
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|->
name|tpdu_li
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"tp_emit CR/CC"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DR_TPDU_type
case|:
if|if
condition|(
name|hdr
operator|->
name|tpdu_DRdref
operator|==
literal|0
condition|)
block|{
comment|/* don't issue the DR */
goto|goto
name|done
goto|;
block|}
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|tpdu_DRsref
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_DRreason
operator|=
operator|(
name|u_char
operator|)
name|eot
expr_stmt|;
comment|/* WHICH BYTE OF THIS??? */
comment|/* forget the add'l information variable part */
name|IncStat
argument_list|(
name|ts_DR_sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_TPDU_type
case|:
comment|/* not used in class 0 */
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_DCsref
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|IncStat
argument_list|(
name|ts_DC_sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAK_TPDU_type
case|:
comment|/* xak not used in class 0 */
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
argument_list|)
expr_stmt|;
comment|/* fall through */
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTXack
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|data
init|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seq
operator|=
name|seq
expr_stmt|;
name|seqeotX
operator|.
name|s_eot
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|tpdu_seqeotX
operator|=
name|htonl
argument_list|(
name|seqeotX
operator|.
name|s_seqeot
argument_list|)
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|tpdu_XAKseqX
operator|=
name|seq
expr_stmt|;
endif|#
directive|endif
comment|/* BYTE_ORDER */
block|}
else|else
block|{
name|hdr
operator|->
name|tpdu_XAKseq
operator|=
name|seq
expr_stmt|;
block|}
name|IncStat
argument_list|(
name|ts_XAK_sent
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_XAK_sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPD_TPDU_type
case|:
comment|/* xpd not used in class 0 */
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
argument_list|)
expr_stmt|;
comment|/* fall through */
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seq
operator|=
name|seq
expr_stmt|;
name|seqeotX
operator|.
name|s_eot
operator|=
literal|1
expr_stmt|;
name|hdr
operator|->
name|tpdu_seqeotX
operator|=
name|htonl
argument_list|(
name|seqeotX
operator|.
name|s_seqeot
argument_list|)
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|tpdu_XPDseqX
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_XPDeotX
operator|=
literal|1
expr_stmt|;
comment|/* always 1 for XPD tpdu */
endif|#
directive|endif
comment|/* BYTE_ORDER */
block|}
else|else
block|{
name|hdr
operator|->
name|tpdu_XPDseq
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_XPDeot
operator|=
literal|1
expr_stmt|;
comment|/* always 1 for XPD tpdu */
block|}
name|IncStat
argument_list|(
name|ts_XPD_sent
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_XPD_sent
argument_list|)
expr_stmt|;
comment|/* kludge to test the input size checking */
name|IFDEBUG
argument_list|(
argument|D_SIZE_CHECK
argument_list|)
comment|/*if(data->m_len<= 16&& data->m_off< (MLEN-18) ) { 					printf("Sending too much data on XPD: 18 bytes\n"); 					data->m_len = 18; 				}*/
name|ENDDEBUG
break|break;
case|case
name|DT_TPDU_type
case|:
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"emit DT: eot seq tpdu_li"
argument_list|,
name|eot
argument_list|,
name|seq
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seq
operator|=
name|seq
expr_stmt|;
name|seqeotX
operator|.
name|s_eot
operator|=
name|eot
expr_stmt|;
name|hdr
operator|->
name|tpdu_seqeotX
operator|=
name|htonl
argument_list|(
name|seqeotX
operator|.
name|s_seqeot
argument_list|)
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|tpdu_DTseqX
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_DTeotX
operator|=
name|eot
expr_stmt|;
endif|#
directive|endif
comment|/* BYTE_ORDER */
block|}
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"DT tpdu: class 0 m 0x%x hdr 0x%x\n"
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
operator|(
expr|struct
name|tp0du
operator|*
operator|)
name|hdr
argument_list|)
operator|->
name|tp0du_eot
operator|=
name|eot
expr_stmt|;
operator|(
operator|(
expr|struct
name|tp0du
operator|*
operator|)
name|hdr
operator|)
operator|->
name|tp0du_mbz
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"DT 2 tpdu: class 0 m 0x%x hdr 0x%x\n"
argument_list|,
name|m
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
name|hdr
operator|->
name|tpdu_DTseq
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_DTeot
operator|=
name|eot
expr_stmt|;
block|}
if|if
condition|(
name|eot
condition|)
block|{
name|IncStat
argument_list|(
name|ts_EOT_sent
argument_list|)
expr_stmt|;
block|}
name|IncStat
argument_list|(
name|ts_DT_sent
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_DT_sent
argument_list|)
expr_stmt|;
break|break;
case|case
name|AK_TPDU_type
case|:
comment|/* ak not used in class 0 */
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|olduwe
operator|=
name|tpcb
operator|->
name|tp_sent_uwe
expr_stmt|;
if|if
condition|(
name|seq
operator|!=
name|tpcb
operator|->
name|tp_sent_rcvnxt
operator|||
name|tpcb
operator|->
name|tp_rsycnt
operator|==
literal|0
condition|)
block|{
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_sent_uwe
operator|=
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
operator|+
name|tpcb
operator|->
name|tp_lcredit
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_sent_lcdt
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
name|acking_ooo
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|acking_ooo
operator|=
literal|1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_RENEG
argument_list|)
comment|/* occasionally fake a reneging so 					you can test subsequencing */
if|if
condition|(
name|olduwe
operator|&
literal|0x1
condition|)
block|{
name|tpcb
operator|->
name|tp_reneged
operator|=
literal|1
expr_stmt|;
name|IncStat
argument_list|(
name|ts_ldebug
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
comment|/* Are we about to reneg on credit? 			 * When might we do so? 			 *	a) when using optimistic credit (which we no longer do). 			 *  b) when drain() gets implemented (not in the plans). 			 *  c) when D_RENEG is on. 			 *  d) when DEC BIT response is implemented. 			 *	(not- when we do this, we'll need to implement flow control 			 *	confirmation) 			 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sent_uwe
argument_list|,
name|olduwe
argument_list|)
condition|)
block|{
name|tpcb
operator|->
name|tp_reneged
operator|=
literal|1
expr_stmt|;
name|IncStat
argument_list|(
name|ts_lcdt_reduced
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CREDIT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"RENEG: olduwe newuwe lcredit rcvnxt"
argument_list|,
name|olduwe
argument_list|,
name|tpcb
operator|->
name|tp_sent_uwe
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
expr_stmt|;
name|ENDTRACE
block|}
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
comment|/* new lwe is less than old uwe means we're 				 * acking before we received a whole window full 				 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|,
name|olduwe
argument_list|)
condition|)
block|{
comment|/* tmp1 = number of pkts fewer than the full window */
specifier|register
name|int
name|tmp1
init|=
operator|(
name|int
operator|)
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|olduwe
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp1
operator|>
name|TP_PM_MAX
condition|)
name|tmp1
operator|=
name|TP_PM_MAX
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_ack_early
index|[
name|tmp1
index|]
argument_list|)
expr_stmt|;
comment|/* tmp1 = amt of new cdt we're advertising */
name|tmp1
operator|=
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_sent_rcvnxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|>
name|TP_PM_MAX
condition|)
name|tmp1
operator|=
name|TP_PM_MAX
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_cdt_acked
index|[
name|tmp1
index|]
index|[
operator|(
operator|(
name|tpcb
operator|->
name|tp_lcredit
operator|>
name|TP_PM_MAX
operator|)
condition|?
name|TP_PM_MAX
else|:
name|tpcb
operator|->
name|tp_lcredit
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
name|ENDPERF
name|IFTRACE
argument_list|(
name|D_ACKSEND
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTack
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_sent_uwe
argument_list|,
name|tpcb
operator|->
name|tp_r_subseq
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seq
operator|=
name|seq
expr_stmt|;
name|seqeotX
operator|.
name|s_eot
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|tpdu_seqeotX
operator|=
name|htonl
argument_list|(
name|seqeotX
operator|.
name|s_seqeot
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_AKcdtX
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_lcredit
argument_list|)
expr_stmt|;
else|#
directive|else
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|tpdu_AKseqX
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_AKcdtX
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
endif|#
directive|endif
comment|/* BYTE_ORDER */
block|}
else|else
block|{
name|hdr
operator|->
name|tpdu_AKseq
operator|=
name|seq
expr_stmt|;
name|hdr
operator|->
name|tpdu_AKcdt
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
operator|)
operator|&&
operator|(
name|tpcb
operator|->
name|tp_reneged
operator|||
name|acking_ooo
operator|)
condition|)
block|{
comment|/* 				 * Ack subsequence parameter req'd if WE reneged on 				 * credit offered.  (ISO 8073, 12.2.3.8.2, p. 74) 				 */
name|IFDEBUG
argument_list|(
argument|D_RENEG
argument_list|)
name|printf
argument_list|(
literal|"Adding subseq 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_s_subseq
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_s_subseq
operator|++
expr_stmt|;
comment|/* 				 * add tmp subseq and do a htons on it. 				 */
name|ADDOPTION
argument_list|(
name|TPP_subseq
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_s_subseq
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_s_subseq
argument_list|)
expr_stmt|;
block|}
else|else
name|tpcb
operator|->
name|tp_s_subseq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_sendfcc
operator|||
name|eot
condition|)
comment|/* overloaded to mean SEND FCC */
block|{
comment|/* 				 * Rules for sending FCC ("should" send when) : 				 * %a) received an ack from peer with NO NEWS whatsoever, 				 *  	and it did not contain an FCC 				 * 	b) received an ack from peer that opens its closed window. 				 * 	c) received an ack from peer after it reneged on its 				 *		offered credit, AND this ack raises UWE but LWE is same 				 *		and below UWE at time of reneging (reduction) 				 * Now, ISO 8073 12.2.3.8.3 says 				 * that a retransmitted AK shall not contain the FCC 				 * parameter.  Now, how the hell you tell the difference 				 * between a retransmitted ack and an ack that's sent in 				 * response to a received ack, I don't know, because without 				 * any local activity, and w/o any received DTs, they 				 * will contain exactly the same credit/seq# information. 				 * Anyway, given that the "retransmission of acks" 				 * procedure (ISO 8073 12.2.3.8.3) is optional, and we 				 * don't do it (although the peer can't tell that), we 				 * ignore this last rule. 				 * 				 * We send FCC for reasons a) and b) only. 				 * To add reason c) would require a ridiculous amount of state. 				 * 				 */
name|u_short
name|bogus
index|[
literal|4
index|]
decl_stmt|;
comment|/* lwe(32), subseq(16), cdt(16) */
name|SeqNum
name|lwe
decl_stmt|;
name|u_short
name|subseq
decl_stmt|,
name|fcredit
decl_stmt|;
name|tpcb
operator|->
name|tp_sendfcc
operator|=
literal|0
expr_stmt|;
name|lwe
operator|=
operator|(
name|SeqNum
operator|)
name|htonl
argument_list|(
name|tpcb
operator|->
name|tp_snduna
argument_list|)
expr_stmt|;
name|subseq
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_r_subseq
argument_list|)
expr_stmt|;
name|fcredit
operator|=
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_fcredit
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lwe
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bogus
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|SeqNum
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|subseq
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bogus
index|[
literal|2
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|fcredit
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bogus
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_ACKSEND
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"emit w/FCC: snduna r_subseq fcredit"
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_r_subseq
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_ACKSEND
argument_list|)
name|printf
argument_list|(
literal|"Calling ADDOPTION 0x%x, 0x%x, 0x%x,0x%x\n"
argument_list|,
name|TPP_flow_cntl_conf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bogus
argument_list|)
argument_list|,
name|bogus
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ENDDEBUG
name|ADDOPTION
argument_list|(
name|TPP_flow_cntl_conf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|bogus
argument_list|)
argument_list|,
name|bogus
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKSEND
argument_list|)
name|printf
argument_list|(
literal|"after ADDOPTION hdr 0x%x hdr->tpdu_li 0x%x\n"
argument_list|,
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"after ADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n"
argument_list|,
name|csum_offset
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|tpcb
operator|->
name|tp_reneged
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_sent_rcvnxt
operator|=
name|seq
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_fcredit
operator|==
literal|0
condition|)
block|{
name|int
name|timo
init|=
name|tpcb
operator|->
name|tp_keepalive_ticks
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rxtshift
operator|<
name|TP_MAXRXTSHIFT
condition|)
name|tpcb
operator|->
name|tp_rxtshift
operator|++
expr_stmt|;
name|timo
operator|=
name|min
argument_list|(
name|timo
argument_list|,
operator|(
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_dt_ticks
operator|)
operator|<<
name|tpcb
operator|->
name|tp_rxtshift
argument_list|)
expr_stmt|;
name|tp_ctimeout
argument_list|(
name|tpcb
argument_list|,
name|TM_sendack
argument_list|,
name|timo
argument_list|)
expr_stmt|;
block|}
else|else
name|tp_ctimeout
argument_list|(
name|tpcb
argument_list|,
name|TM_sendack
argument_list|,
name|tpcb
operator|->
name|tp_keepalive_ticks
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_AK_sent
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_AK_sent
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKSEND
argument_list|)
name|printf
argument_list|(
literal|"2 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n"
argument_list|,
name|csum_offset
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
case|case
name|ER_TPDU_type
case|:
name|hdr
operator|->
name|tpdu_ERreason
operator|=
name|eot
expr_stmt|;
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
comment|/* no user data */
name|data
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
name|IncStat
argument_list|(
name|ts_ER_sent
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|ASSERT
argument_list|(
operator|(
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
operator|<
name|MLEN
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|hdr
operator|->
name|tpdu_li
operator|<
name|MLEN
argument_list|)
expr_stmt|;
comment|/* leave this in */
name|ASSERT
argument_list|(
name|hdr
operator|->
name|tpdu_li
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* leave this in */
name|m
operator|->
name|m_len
operator|=
name|hdr
operator|->
name|tpdu_li
expr_stmt|;
name|hdr
operator|->
name|tpdu_li
operator|--
expr_stmt|;
comment|/* doesn't include the li field */
name|datalen
operator|=
name|m_datalen
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* total len */
name|ASSERT
argument_list|(
name|datalen
operator|<=
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|)
expr_stmt|;
comment|/* may become a problem 				when CLNP is used; leave in here for the time being */
name|IFDEBUG
argument_list|(
argument|D_ACKSEND
argument_list|)
name|printf
argument_list|(
literal|"4 after rADDOPTION csum_offset 0x%x, hdr->tpdu_li 0x%x\n"
argument_list|,
name|csum_offset
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|datalen
operator|>
name|tpcb
operator|->
name|tp_l_tpdusize
condition|)
block|{
name|printf
argument_list|(
literal|"data len 0x%x tpcb->tp_l_tpdusize 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_emit before gen_csum m_len 0x%x, csum_offset 0x%x, datalen 0x%x\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|csum_offset
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
operator|||
operator|(
name|dutype
operator|==
name|CR_TPDU_type
operator|&&
operator|(
name|tpcb
operator|->
name|tp_class
operator|&
name|TP_CLASS_4
operator|)
operator|)
condition|)
block|{
name|iso_gen_csum
argument_list|(
name|m
argument_list|,
name|csum_offset
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_emit before tpxxx_output tpcb 0x%x, dutype 0x%x, datalen 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|dutype
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
decl|if
argument_list|(
name|dutype
operator|==
name|DT_TPDU_type
argument_list|)
block|{
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_to_ll
argument_list|)
operator|+=
operator|(
name|datalen
operator|-
name|m
operator|->
name|m_len
operator|)
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_to_ll
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|,
name|seq
argument_list|,
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_to_ll
argument_list|)
argument_list|,
operator|(
name|datalen
operator|-
name|m
operator|->
name|m_len
operator|)
argument_list|)
expr_stmt|;
block|}
name|ENDPERF
name|IFTRACE
argument_list|(
name|D_EMIT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTtpduout
argument_list|,
name|dutype
argument_list|,
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"OUTPUT: tpcb 0x%x, isop 0x%x, so 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|)
decl_stmt|;
name|ENDDEBUG
block|{
specifier|extern
name|char
name|tp_delay
decl_stmt|;
if|if
condition|(
name|tp_delay
condition|)
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
operator|==
literal|0
condition|)
block|{
specifier|register
name|u_int
name|i
init|=
name|tp_delay
decl_stmt|;
for|for
control|(
init|;
name|i
operator|!=
literal|0
condition|;
name|i
operator|--
control|)
operator|(
name|void
operator|)
name|iso_check_csum
argument_list|(
name|m
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_output
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|m
argument_list|,
name|datalen
argument_list|,
operator|!
name|tpcb
operator|->
name|tp_use_checksum
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"OUTPUT: returned 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_EMIT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_emit nlproto->output netservice returns datalen"
argument_list|,
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_output
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|,
name|error
argument_list|,
name|datalen
argument_list|)
decl_stmt|;
name|ENDTRACE
name|done
range|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|dutype
operator|==
name|AK_TPDU_type
condition|)
name|tp_ctimeout
argument_list|(
name|tpcb
argument_list|,
name|TM_sendack
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|E_CO_QFULL
condition|)
block|{
name|tp_quench
argument_list|(
name|tpcb
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:		tp_error_emit()  * CALLED FROM:	tp_input() when a DR or ER is to be issued in  * 		response to an input error.  * FUNCTION and ARGUMENTS:  * 		The error type is the first argument.  * 		The argument (sref) is the source reference on the bad incoming tpdu,  * 		and is used for a destination reference on the outgoing packet.  * 		(faddr) and (laddr) are the foreign and local addresses for this  *		connection.  * 		(erdata) is a ptr to the errant incoming tpdu, and is copied into the  * 		outgoing ER, if an ER is to be issued.  * 		(erlen)  is the number of octets of the errant tpdu that we should  * 		try to copy.  * 		(tpcb) is the pcb that describes the connection for which the bad tpdu  * 		arrived.  * RETURN VALUES:  * 		0 OK  *  	ENOBUFS  *  	E* from net layer datagram output routine  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_decl_stmt
name|int
name|tp_error_emit
argument_list|(
name|error
argument_list|,
name|sref
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|erdata
argument_list|,
name|erlen
argument_list|,
name|tpcb
argument_list|,
name|cons_channel
argument_list|,
name|dgout_routine
argument_list|)
name|int
name|error
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|sref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|faddr
decl_stmt|,
modifier|*
name|laddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|erdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|erlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|cons_channel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|dgout_routine
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|dutype
decl_stmt|;
name|int
name|datalen
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|tpdu
modifier|*
name|hdr
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|csum_offset
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_error_emit error sref tpcb erlen"
argument_list|,
name|error
argument_list|,
name|sref
argument_list|,
name|tpcb
argument_list|,
name|erlen
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_ERROR_EMIT
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"tp_error_emit error 0x%x sref 0x%x tpcb 0x%x erlen 0x%x chan 0x%x\n"
operator|,
function_decl|error
operator|,
function_decl|sref
operator|,
function_decl|tpcb
operator|,
function_decl|erlen
operator|,
function_decl|cons_channel
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDDEBUG
name|MGET
parameter_list|(
name|m
parameter_list|,
name|M_DONTWAIT
parameter_list|,
name|TPMT_TPHDR
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
end_if

begin_expr_stmt
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tpdu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"[error 0x%x] [error&0xff  0x%x] [(char)error 0x%x]\n"
argument_list|,
name|error
argument_list|,
name|error
operator|&
literal|0xff
argument_list|,
operator|(
name|char
operator|)
name|error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|error
operator|&
name|TP_ERROR_SNDC
condition|)
name|dutype
operator|=
name|DC_TPDU_type
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|&
literal|0x40
condition|)
block|{
name|error
operator|&=
operator|~
literal|0x40
expr_stmt|;
name|dutype
operator|=
name|ER_TPDU_type
expr_stmt|;
block|}
else|else
name|dutype
operator|=
name|DR_TPDU_type
expr_stmt|;
end_if

begin_expr_stmt
name|error
operator|&=
literal|0xff
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hdr
operator|->
name|tpdu_type
operator|=
name|dutype
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hdr
operator|->
name|tpdu_cdt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|dutype
condition|)
block|{
case|case
name|DC_TPDU_type
case|:
name|IncStat
argument_list|(
name|ts_DC_sent
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_li
operator|=
literal|6
expr_stmt|;
name|hdr
operator|->
name|tpdu_DCdref
operator|=
name|htons
argument_list|(
name|sref
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_DCsref
operator|=
name|tpcb
condition|?
name|htons
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|)
else|:
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"DC case:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|hdr
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* forget the add'l information variable part */
break|break;
case|case
name|DR_TPDU_type
case|:
name|IncStat
argument_list|(
name|ts_DR_sent
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_li
operator|=
literal|7
expr_stmt|;
name|hdr
operator|->
name|tpdu_DRdref
operator|=
name|htons
argument_list|(
name|sref
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_DRsref
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|tpdu_DRreason
operator|=
operator|(
name|char
operator|)
name|error
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"DR case:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|hdr
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* forget the add'l information variable part */
break|break;
case|case
name|ER_TPDU_type
case|:
name|IncStat
argument_list|(
name|ts_ER_sent
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|tpdu_li
operator|=
literal|5
expr_stmt|;
name|hdr
operator|->
name|tpdu_ERreason
operator|=
operator|(
name|char
operator|)
name|error
expr_stmt|;
name|hdr
operator|->
name|tpdu_ERdref
operator|=
name|htons
argument_list|(
name|sref
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"TP PANIC: bad dutype 0x%x\n"
argument_list|,
name|dutype
argument_list|)
expr_stmt|;
block|}
end_switch

begin_if
if|if
condition|(
name|tpcb
condition|)
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
condition|)
block|{
name|ADDOPTION
argument_list|(
name|TPP_checksum
argument_list|,
name|hdr
argument_list|,
literal|2
argument_list|,
name|csum_offset
comment|/* dummy argument */
argument_list|)
expr_stmt|;
name|csum_offset
operator|=
name|hdr
operator|->
name|tpdu_li
operator|-
literal|2
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|ASSERT
argument_list|(
name|hdr
operator|->
name|tpdu_li
operator|<
name|MLEN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|dutype
operator|==
name|ER_TPDU_type
condition|)
block|{
comment|/* copy the errant tpdu into another 'variable part' */
specifier|register
name|caddr_t
name|P
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"error_emit ER len tpduli"
argument_list|,
name|erlen
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_ERROR_EMIT
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"error_emit ER len 0x%x tpduli 0x%x\n"
operator|,
function_decl|erlen
operator|,
function_decl|hdr->tpdu_li
block|)
empty_stmt|;
end_if

begin_macro
name|ENDDEBUG
end_macro

begin_comment
comment|/* copy at most as many octets for which you have room */
end_comment

begin_if
if|if
condition|(
name|erlen
operator|+
name|hdr
operator|->
name|tpdu_li
operator|+
literal|2
operator|>
name|TP_MAX_HEADER_LEN
condition|)
name|erlen
operator|=
name|TP_MAX_HEADER_LEN
operator|-
name|hdr
operator|->
name|tpdu_li
operator|-
literal|2
expr_stmt|;
end_if

begin_comment
comment|/* add the "invalid tpdu" parameter : required in class 0 */
end_comment

begin_expr_stmt
name|P
operator|=
operator|(
name|caddr_t
operator|)
name|hdr
operator|+
call|(
name|int
call|)
argument_list|(
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_code
operator|=
name|TPP_invalid_tpdu
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* parameter code */
end_comment

begin_expr_stmt
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_len
operator|=
name|erlen
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* parameter length */
end_comment

begin_expr_stmt
name|m
operator|->
name|m_len
operator|=
name|hdr
operator|->
name|tpdu_li
operator|+
literal|2
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 1 for code, 1 for length */
end_comment

begin_comment
comment|/* tp_input very likely handed us an mbuf chain w/ nothing in 		 * the first mbuf and the data following the empty mbuf 		 */
end_comment

begin_if
if|if
condition|(
name|erdata
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|erdata
operator|=
name|m_free
argument_list|(
name|erdata
argument_list|)
expr_stmt|;
comment|/* returns the next mbuf on the chain */
block|}
end_if

begin_comment
comment|/* 		 * copy only up to the bad octet 		 * (or max that will fit in a header 		 */
end_comment

begin_expr_stmt
name|m
operator|->
name|m_next
operator|=
name|m_copy
argument_list|(
name|erdata
argument_list|,
literal|0
argument_list|,
name|erlen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|hdr
operator|->
name|tpdu_li
operator|+=
name|erlen
operator|+
literal|2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m_freem
argument_list|(
name|erdata
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
unit|} else
block|{
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"error_emit DR error tpduli 0x%x\n"
argument_list|,
name|error
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m
operator|->
name|m_len
init|=
name|hdr
operator|->
name|tpdu_li
decl_stmt|;
name|m_freem
argument_list|(
name|erdata
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|hdr
operator|->
name|tpdu_li
operator|--
expr_stmt|;
end_expr_stmt

begin_macro
name|IFTRACE
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
end_macro

begin_expr_stmt
name|tptrace
argument_list|(
name|TPPTtpduout
argument_list|,
literal|2
argument_list|,
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDTRACE
name|datalen
init|=
name|m_datalen
argument_list|(
name|m
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|tpcb
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
condition|)
block|{
name|IFTRACE
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"before gen csum datalen"
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_ERROR_EMIT
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"before gen csum datalen 0x%x, csum_offset 0x%x\n"
operator|,
function_decl|datalen
operator|,
function_decl|csum_offset
block|)
empty_stmt|;
name|ENDDEBUG
name|iso_gen_csum
parameter_list|(
name|m
parameter_list|,
name|csum_offset
parameter_list|,
name|datalen
parameter_list|)
function_decl|;
block|}
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"OUTPUT: tpcb 0x%x, isop 0x%x, so 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDDEBUG
end_expr_stmt

begin_expr_stmt
unit|} 	if
operator|(
name|cons_channel
operator|)
block|{
ifdef|#
directive|ifdef
name|TPCONS
block|struct
name|pklcd
operator|*
name|lcp
operator|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|cons_channel
block|; 		struct
name|isopcb
operator|*
name|isop
operator|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|lcp
operator|->
name|lcd_upnext
block|;
name|tpcons_dg_output
argument_list|(
name|cons_channel
argument_list|,
name|m
argument_list|,
name|datalen
argument_list|)
block|;
comment|/* was if (tpcb == 0) iso_pcbdetach(isop); */
comment|/* but other side may want to try again over same VC, 		   so, we'll depend on him closing it, but in case it gets forgotten 		   we'll mark it for garbage collection */
name|lcp
operator|->
name|lcd_flags
operator||=
name|X25_DG_CIRCUIT
block|;
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"OUTPUT: dutype 0x%x channel 0x%x\n"
argument_list|,
name|dutype
argument_list|,
name|cons_channel
argument_list|)
block|;
name|ENDDEBUG
else|#
directive|else
name|printf
argument_list|(
literal|"TP panic! cons channel 0x%x but not cons configured\n"
argument_list|,
name|cons_channel
argument_list|)
block|;
endif|#
directive|endif
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|tpcb
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_error_emit 1 sending DG: Laddr\n"
argument_list|)
expr_stmt|;
name|dump_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Faddr\n"
argument_list|)
expr_stmt|;
name|dump_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_dgoutput
call|)
argument_list|(
operator|&
name|laddr
operator|->
name|siso_addr
argument_list|,
operator|&
name|faddr
operator|->
name|siso_addr
argument_list|,
name|m
argument_list|,
name|datalen
argument_list|,
comment|/* no route */
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|!
name|tpcb
operator|->
name|tp_use_checksum
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|dgout_routine
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_error_emit sending DG: Laddr\n"
argument_list|)
expr_stmt|;
name|dump_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Faddr\n"
argument_list|)
expr_stmt|;
name|dump_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
call|(
modifier|*
name|dgout_routine
call|)
argument_list|(
operator|&
name|laddr
operator|->
name|siso_addr
argument_list|,
operator|&
name|faddr
operator|->
name|siso_addr
argument_list|,
name|m
argument_list|,
name|datalen
argument_list|,
comment|/* no route */
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
comment|/* nochecksum==false */
literal|0
argument_list|)
return|;
block|}
end_elseif

begin_else
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tp_error_emit DROPPING \n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
parameter_list|(
name|ts_send_drop
parameter_list|)
function_decl|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_else

unit|}
end_unit

