begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_usrreq.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 				Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  *  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_usrreq.c,v $  *  * tp_usrreq(), the fellow that gets called from most of the socket code.  * Pretty straighforward.  * THe only really awful stuff here is the OOB processing, which is done  * wholly here.  * tp_rcvoob() and tp_sendoob() are contained here and called by tp_usrreq().  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_ip.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_meas.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_errno.h>
end_include

begin_decl_stmt
name|int
name|tp_attach
argument_list|()
decl_stmt|,
name|tp_driver
argument_list|()
decl_stmt|,
name|tp_pcbbind
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TNew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TPNagle1
decl_stmt|,
name|TPNagle2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tp_listeners
decl_stmt|,
modifier|*
name|tp_intercepts
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_comment
comment|/*  * CALLED FROM:  *  anywhere you want to debug...  * FUNCTION and ARGUMENTS:  *  print (str) followed by the control info in the mbufs of an mbuf chain (n)  */
end_comment

begin_function
name|void
name|dump_mbuf
parameter_list|(
name|n
parameter_list|,
name|str
parameter_list|)
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|printf
argument_list|(
literal|"dump %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|MNULL
condition|)
block|{
name|printf
argument_list|(
literal|"EMPTY:\n"
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|n
condition|)
block|{
name|nextrecord
operator|=
name|n
operator|->
name|m_act
expr_stmt|;
name|printf
argument_list|(
literal|"RECORD:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"%x : Len %x Data %x A %x Nx %x Tp %x\n"
argument_list|,
name|n
argument_list|,
name|n
operator|->
name|m_len
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|n
operator|->
name|m_act
argument_list|,
name|n
operator|->
name|m_next
argument_list|,
name|n
operator|->
name|m_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|n
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"data: "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|->
name|m_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"0x%x "
argument_list|,
operator|*
operator|(
name|p
operator|+
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notdef */
if|if
condition|(
name|n
operator|->
name|m_next
operator|==
name|n
condition|)
block|{
name|printf
argument_list|(
literal|"LOOP!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|n
operator|=
name|nextrecord
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGO_DEBUG */
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq(), PRU_RCVOOB  * FUNCTION and ARGUMENTS:  * 	Copy data from the expedited data socket buffer into  * 	the pre-allocated mbuf m.  * 	There is an isomorphism between XPD TPDUs and expedited data TSDUs.  * 	XPD tpdus are limited to 16 bytes of data so they fit in one mbuf.  * RETURN VALUE:  *  EINVAL if debugging is on and a disaster has occurred  *  ENOTCONN if the socket isn't connected  *  EWOULDBLOCK if the socket is in non-blocking mode and there's no  *		xpd data in the buffer  *  E* whatever is returned from the fsm.  */
end_comment

begin_macro
name|tp_rcvoob
argument_list|(
argument|tpcb
argument_list|,
argument|so
argument_list|,
argument|m
argument_list|,
argument|outflags
argument_list|,
argument|inflags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|outflags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inflags
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|nn
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"PRU_RCVOOB, sostate 0x%x\n"
argument_list|,
name|so
operator|->
name|so_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* if you use soreceive */
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
name|ENOBUFS
return|;
name|restart
label|:
if|if
condition|(
operator|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
block|{
return|return
name|ENOTCONN
return|;
block|}
comment|/* Take the first mbuf off the chain. 	 * Each XPD TPDU gives you a complete TSDU so the chains don't get 	 * coalesced, but one TSDU may span several mbufs. 	 * Nevertheless, since n should have a most 16 bytes, it 	 * will fit into m.  (size was checked in tp_input() ) 	 */
comment|/* 	 * Code for excision of OOB data should be added to 	 * uipc_socket2.c (like sbappend). 	 */
name|sblock
argument_list|(
name|sb
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|nn
operator|=
operator|&
name|sb
operator|->
name|sb_mb
init|;
name|n
operator|=
operator|*
name|nn
condition|;
name|nn
operator|=
operator|&
name|n
operator|->
name|m_act
control|)
if|if
condition|(
name|n
operator|->
name|m_type
operator|==
name|MT_OOBDATA
condition|)
break|break;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"RCVOOB: empty queue!\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sbunlock
parameter_list|(
name|sb
parameter_list|)
function_decl|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* Assuming at most one xpd tpdu is in the buffer at once */
while|while
condition|(
name|n
operator|!=
name|MNULL
condition|)
block|{
name|m
operator|->
name|m_len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
name|unsigned
operator|)
name|n
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
comment|/* so mtod() in bcopy() above gives right addr */
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|->
name|m_data
operator|=
name|m
operator|->
name|m_dat
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_rcvoob: xpdlen 0x%x\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"RCVOOB: Rcv socketbuf"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"RCVOOB: Xrcv socketbuf"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|inflags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|*
name|nn
expr_stmt|;
operator|*
name|nn
operator|=
name|n
operator|->
name|m_act
expr_stmt|;
for|for
control|(
init|;
name|n
condition|;
name|n
operator|=
name|m_free
argument_list|(
name|n
argument_list|)
control|)
name|sbfree
argument_list|(
name|sb
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
name|release
label|:
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_RCVOOB @ release sb_cc m_len"
argument_list|,
name|tpcb
operator|->
name|tp_Xrcv
operator|.
name|sb_cc
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_Xrcvd
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq(), PRU_SENDOOB  * FUNCTION and ARGUMENTS:  * 	Send what's in the mbuf chain (m) as an XPD TPDU.  * 	The mbuf may not contain more then 16 bytes of data.  * 	XPD TSDUs aren't segmented, so they translate into  * 	exactly one XPD TPDU, with EOT bit set.  * RETURN VALUE:  *  EWOULDBLOCK if socket is in non-blocking mode and the previous  *   xpd data haven't been acked yet.  *  EMSGSIZE if trying to send> max-xpd bytes (16)  *  ENOBUFS if ran out of mbufs  */
end_comment

begin_macro
name|tp_sendoob
argument_list|(
argument|tpcb
argument_list|,
argument|so
argument_list|,
argument|xdata
argument_list|,
argument|outflags
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|xdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|outflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_block
block|{
comment|/* 	 * Each mbuf chain represents a sequence # in the XPD seq space. 	 * The first one in the queue has sequence # tp_Xuna. 	 * When we add to the XPD queue, we stuff a zero-length 	 * mbuf (mark) into the DATA queue, with its sequence number in m_next 	 * to be assigned to this XPD tpdu, so data xfer can stop 	 * when it reaches the zero-length mbuf if this XPD TPDU hasn't 	 * yet been acknowledged. 	 */
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|tpcb
operator|->
name|tp_Xsnd
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|xmark
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|xdata
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* DO NOT LOCK the Xsnd buffer!!!! You can have at MOST one 	 * socket buf locked at any time!!! (otherwise you might 	 * sleep() in sblock() w/ a signal pending and cause the 	 * system call to be aborted w/ a locked socketbuf, which 	 * is a problem.  So the so_snd buffer lock 	 * (done in sosend()) serves as the lock for Xpd. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
condition|)
block|{
comment|/* Anything already in eXpedited data sockbuf? */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
block|{
return|return
name|EWOULDBLOCK
return|;
block|}
while|while
condition|(
name|sb
operator|->
name|sb_mb
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* already locked by sosend */
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* sosend will unlock on return */
block|}
block|}
if|if
condition|(
name|xdata
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* empty xpd packet */
name|MGETHDR
argument_list|(
name|xdata
argument_list|,
name|M_WAIT
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
name|xdata
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|xdata
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob 1:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|xdata
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|xmark
init|=
name|xdata
decl_stmt|;
comment|/* temporary use of variable xmark */
while|while
condition|(
name|xmark
condition|)
block|{
name|len
operator|+=
name|xmark
operator|->
name|m_len
expr_stmt|;
name|xmark
operator|=
name|xmark
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|TP_MAX_XPD_DATA
condition|)
block|{
return|return
name|EMSGSIZE
return|;
block|}
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|printf
argument_list|(
literal|"tp_sendoob 2:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdata
condition|)
name|printf
argument_list|(
literal|"xdata len 0x%x\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_XPD
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"XPD mark m_next "
operator|,
function_decl|xdata->m_next
operator|,
function_decl|0
operator|,
function_decl|0
operator|,
function_decl|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|sbappendrecord
parameter_list|(
name|sb
parameter_list|,
name|xdata
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_sendoob len 0x%x\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"XPD request Regular sndbuf:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
argument_list|,
literal|"XPD request Xsndbuf:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_return
return|return
name|DoEvent
argument_list|(
name|T_XPD_req
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/*  * CALLED FROM:  *  the socket routines  * FUNCTION and ARGUMENTS:  * 	Handles all "user requests" except the [gs]ockopts() requests.  * 	The argument (req) is the request type (PRU*),  * 	(m) is an mbuf chain, generally used for send and  * 	receive type requests only.  * 	(nam) is used for addresses usually, in particular for the bind request.  *  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
unit|ProtoHook
name|tp_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|controlp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|req
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|nam
decl_stmt|,
modifier|*
name|controlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|flags
decl_stmt|,
modifier|*
name|outflags
init|=
operator|&
name|flags
decl_stmt|;
name|u_long
name|eotsdu
init|=
literal|0
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"usrreq(0x%x,%d,0x%x,0x%x,0x%x)\n"
argument_list|,
name|so
argument_list|,
name|req
argument_list|,
name|m
argument_list|,
name|nam
argument_list|,
name|outflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|printf
argument_list|(
literal|"WARNING!!! so->so_error is 0x%x\n"
argument_list|,
name|so
operator|->
name|so_error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTusrreq
parameter_list|,
function_decl|"req so m state ["
operator|,
function_decl|req
operator|,
function_decl|so
operator|,
function_decl|m
operator|,
function_decl|tpcb?tpcb->tp_state:0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
operator|(
name|u_int
operator|)
name|tpcb
operator|==
literal|0
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|IFTRACE
argument_list|(
argument|D_REQUEST
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTusrreq
argument_list|,
literal|"req failed NO TPCB["
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
name|ENOTCONN
return|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|tpcb
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|tp_attach
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tpcb
operator|=
name|sototpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
comment|/* called from close() */
comment|/* called for each incoming connect queued on the 		 *	parent (accepting) socket 		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_OPEN
operator|||
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
block|{
name|E
operator|.
name|ATTR
argument_list|(
name|T_DISC_req
argument_list|)
operator|.
name|e_reason
operator|=
name|E_TP_NO_SESSION
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DISC_req
argument_list|)
expr_stmt|;
comment|/* pretend it was a close() */
break|break;
block|}
comment|/* else DROP THROUGH */
case|case
name|PRU_DETACH
case|:
comment|/* called from close() */
comment|/* called only after disconnect was called */
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DETACH
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_notdetached
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"PRU_DETACH: not detached\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_detach
parameter_list|(
name|tpcb
parameter_list|)
function_decl|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|tpcb
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|PRU_SHUTDOWN
case|:
comment|/* recv end may have been released; local credit might be zero  */
case|case
name|PRU_DISCONNECT
case|:
name|E
operator|.
name|ATTR
argument_list|(
name|T_DISC_req
argument_list|)
operator|.
name|e_reason
operator|=
name|E_TP_NORMAL_DISC
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DISC_req
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_BIND
case|:
name|error
operator|=
name|tp_pcbbind
argument_list|(
name|tpcb
argument_list|,
name|nam
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_LISTEN
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_CLOSED
operator|||
name|tpcb
operator|->
name|tp_lsuffixlen
operator|==
literal|0
operator|||
name|tpcb
operator|->
name|tp_next
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
modifier|*
name|tt
decl_stmt|;
name|remque
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_next
operator|=
name|tpcb
operator|->
name|tp_prev
operator|=
name|tpcb
expr_stmt|;
for|for
control|(
name|tt
operator|=
operator|&
name|tp_listeners
init|;
operator|*
name|tt
condition|;
name|tt
operator|=
operator|&
operator|(
operator|(
operator|*
name|tt
operator|)
operator|->
name|tp_nextlisten
operator|)
control|)
if|if
condition|(
operator|(
operator|*
name|tt
operator|)
operator|->
name|tp_lsuffixlen
condition|)
break|break;
name|tpcb
operator|->
name|tp_nextlisten
operator|=
operator|*
name|tt
expr_stmt|;
operator|*
name|tt
operator|=
name|tpcb
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_LISTEN_req
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PRU_CONNECT2
case|:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
comment|/* for unix domain sockets */
break|break;
case|case
name|PRU_CONNECT
case|:
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_CONNECT: so 0x%x *SHORT_LSUFXP(tpcb) 0x%x lsuflen 0x%x, class 0x%x"
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
operator|*
name|SHORT_LSUFXP
argument_list|(
name|tpcb
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_CONN
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"PRU_CONNECT: so *SHORT_LSUFXP(tpcb) 0x%x lsuflen 0x%x, class 0x%x"
operator|,
function_decl|tpcb->tp_sock
operator|,
function_decl|*SHORT_LSUFXP
parameter_list|(
name|tpcb
parameter_list|)
operator|,
function_decl|tpcb->tp_lsuffixlen
operator|,
function_decl|tpcb->tp_class
block|)
empty_stmt|;
end_switch

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|tp_pcbbind
argument_list|(
name|tpcb
argument_list|,
name|MNULL
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"pcbbind returns error 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
block|}
block|}
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"isop 0x%x isop->isop_socket offset 12 :\n"
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|error
operator|=
name|tp_route_to
argument_list|(
name|nam
argument_list|,
name|tpcb
argument_list|,
comment|/* channel */
literal|0
argument_list|)
condition|)
break|break;
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_CONNECT after tpcb 0x%x so 0x%x npcb 0x%x flags 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|so
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"isop 0x%x isop->isop_socket offset 12 :\n"
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
literal|16
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_fsuffixlen
operator|==
literal|0
condition|)
block|{
comment|/* didn't set peer extended suffix */
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getsufx
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_fsuffixlen
argument_list|,
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
block|{
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|T_CONN_req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbdisc
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
end_if

begin_macro
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
end_macro

begin_decl_stmt
name|u_int
name|lsufx
decl_stmt|,
name|fsufx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lsufx
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fsufx
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_open
operator||
operator|(
name|tpcb
operator|->
name|tp_xtd_format
operator|<<
literal|4
operator|)
argument_list|,
operator|&
name|time
argument_list|,
name|lsufx
argument_list|,
name|fsufx
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDPERF
end_macro

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_ACCEPT
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|nam
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"ACCEPT PEERADDDR:"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|nam
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|nam
operator|->
name|m_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDDEBUG
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|u_int
name|lsufx
decl_stmt|,
name|fsufx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|lsufx
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fsufx
operator|=
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_open
argument_list|,
operator|&
name|time
argument_list|,
name|lsufx
argument_list|,
name|fsufx
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDPERF
end_macro

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_RCVD
case|:
end_case

begin_if
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
name|error
operator|=
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_macro
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
end_macro

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"RCVD BF: lcredit sent_lcdt cc hiwat \n"
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_sent_lcdt
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PRU_RCVD AF sbspace lcredit hiwat cc"
argument_list|,
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDTRACE
name|IFDEBUG
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"RCVD: cc %d space %d hiwat %d\n"
operator|,
function_decl|so->so_rcv.sb_cc
operator|,
function_decl|sbspace
parameter_list|(
function_decl|&so->so_rcv
end_function_decl

begin_operator
unit|)
operator|,
end_operator

begin_expr_stmt
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|nam
operator|)
operator|&
name|MSG_OOB
condition|)
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_Xrcvd
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|DoEvent
argument_list|(
name|T_USR_rcvd
argument_list|)
expr_stmt|;
end_if

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_RCVOOB
case|:
end_case

begin_if
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xpd_service
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
end_if

begin_comment
comment|/* kludge - nam is really flags here */
end_comment

begin_expr_stmt
name|error
operator|=
name|tp_rcvoob
argument_list|(
name|tpcb
argument_list|,
name|so
argument_list|,
name|m
argument_list|,
name|outflags
argument_list|,
operator|(
name|int
operator|)
name|nam
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_SEND
case|:
end_case

begin_case
case|case
name|PRU_SENDOOB
case|:
end_case

begin_if
if|if
condition|(
name|controlp
condition|)
block|{
name|error
operator|=
name|tp_snd_control
argument_list|(
name|controlp
argument_list|,
name|so
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|controlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
end_if

begin_if
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|&&
operator|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
operator|)
operator|&&
operator|(
name|error
operator|=
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
operator|)
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|req
operator|==
name|PRU_SENDOOB
condition|)
block|{
name|error
operator|=
operator|(
name|tpcb
operator|->
name|tp_xpd_service
operator|==
literal|0
operator|)
condition|?
name|EOPNOTSUPP
else|:
name|tp_sendoob
argument_list|(
name|tpcb
argument_list|,
name|so
argument_list|,
name|m
argument_list|,
name|outflags
argument_list|)
expr_stmt|;
break|break;
block|}
end_if

begin_if
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
block|{
name|eotsdu
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_EOR
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|eotsdu
operator|==
literal|0
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
break|break;
end_if

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_AKWAIT
operator|&&
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_OPEN
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
end_if

begin_comment
comment|/* 		 * The protocol machine copies mbuf chains, 		 * prepends headers, assigns seq numbers, and 		 * puts the packets on the device. 		 * When they are acked they are removed from the socket buf. 		 * 		 * sosend calls this up until sbspace goes negative. 		 * Sbspace may be made negative by appending this mbuf chain, 		 * possibly by a whole cluster. 		 */
end_comment

begin_block
block|{
comment|/* 			 * Could have eotsdu and no data.(presently MUST have 			 * an mbuf though, even if its length == 0) 			 */
name|int
name|totlen
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_sess
argument_list|)
operator|+=
name|totlen
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_session
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_sess
argument_list|)
argument_list|,
name|totlen
argument_list|)
expr_stmt|;
name|ENDPERF
name|IFDEBUG
parameter_list|(
name|D_SYSCALL
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"PRU_SEND: eot %d before sbappend 0x%x len 0x%x to sb @ 0x%x\n"
operator|,
function_decl|eotsdu
operator|,
function_decl|m
operator|,
function_decl|totlen
operator|,
function_decl|sb
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"m : to be added"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|tp_packetize
parameter_list|(
name|tpcb
parameter_list|,
name|m
parameter_list|,
name|eotsdu
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|IFDEBUG
argument_list|(
argument|D_SYSCALL
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_SEND: eot %d after sbappend 0x%x\n"
argument_list|,
name|eotsdu
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|ENDDEBUG
end_macro

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_OPEN
condition|)
name|error
operator|=
name|DoEvent
argument_list|(
name|T_DATA_req
argument_list|)
expr_stmt|;
end_if

begin_macro
name|IFDEBUG
argument_list|(
argument|D_SYSCALL
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"PRU_SEND: after driver error 0x%x \n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"so_snd 0x%x cc 0t%d mbcnt 0t%d\n"
argument_list|,
name|sb
argument_list|,
name|sb
operator|->
name|sb_cc
argument_list|,
name|sb
operator|->
name|sb_mbcnt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"so_snd.sb_mb after driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDDEBUG
end_expr_stmt

begin_empty_stmt
unit|} 		break
empty_stmt|;
end_empty_stmt

begin_case
case|case
name|PRU_SOCKADDR
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|nam
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_PEERADDR
case|:
end_case

begin_expr_stmt
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_getnetaddr
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|nam
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_CONTROL
case|:
end_case

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_case
case|case
name|PRU_PROTOSEND
case|:
end_case

begin_case
case|case
name|PRU_PROTORCV
case|:
end_case

begin_case
case|case
name|PRU_SENSE
case|:
end_case

begin_case
case|case
name|PRU_SLOWTIMO
case|:
end_case

begin_case
case|case
name|PRU_FASTTIMO
case|:
end_case

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_usrreq UNKNOWN PRU %d\n"
argument_list|,
name|req
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGO_DEBUG */
end_comment

begin_expr_stmt
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  	IFDEBUG
operator|(
name|D_REQUEST
operator|)
name|printf
argument_list|(
literal|"%s, so 0x%x, tpcb 0x%x, error %d, state %d\n"
argument_list|,
literal|"returning from tp_usrreq"
argument_list|,
name|so
argument_list|,
name|tpcb
argument_list|,
name|error
argument_list|,
name|tpcb
condition|?
name|tpcb
operator|->
name|tp_state
else|:
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_REQUEST
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTusrreq
parameter_list|,
function_decl|"END req so m state ["
operator|,
function_decl|req
operator|,
function_decl|so
operator|,
function_decl|m
operator|,
function_decl|tpcb ? tpcb->tp_state : 0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
name|controlp
condition|)
block|{
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"control data unexpectedly retained in tp_usrreq()"
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|error
return|;
end_return

begin_expr_stmt
unit|} tp_ltrace
operator|(
name|so
operator|,
name|uio
operator|)
expr|struct
name|socket
operator|*
name|so
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IFTRACE
argument_list|(
name|D_DATA
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
operator|=
name|sototpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
condition|)
block|{
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"sosend so resid iovcnt"
argument_list|,
name|so
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_iovcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ENDTRACE
block|}
end_block

begin_expr_stmt
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|tp_event
name|E
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CONFIRMING
condition|)
return|return
name|DoEvent
argument_list|(
name|T_ACPT_req
argument_list|)
return|;
name|printf
argument_list|(
literal|"Tp confirm called when not confirming; tpcb 0x%x, state 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Process control data sent with sendmsg()  */
end_comment

begin_macro
name|tp_snd_control
argument_list|(
argument|m
argument_list|,
argument|so
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmsghdr
modifier|*
name|ch
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|&&
name|m
operator|->
name|m_len
condition|)
block|{
name|ch
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|error
operator|=
name|tp_ctloutput
argument_list|(
name|PRCO_SETOPT
argument_list|,
name|so
argument_list|,
name|ch
operator|->
name|cmsg_level
argument_list|,
name|ch
operator|->
name|cmsg_type
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|cmsg_type
operator|==
name|TPOPT_DISC_DATA
condition|)
block|{
if|if
condition|(
name|data
operator|&&
operator|*
name|data
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|data
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|tp_usrreq
argument_list|(
name|so
argument_list|,
name|PRU_DISCONNECT
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

end_unit

