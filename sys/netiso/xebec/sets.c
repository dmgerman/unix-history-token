begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/xebec/Attic/sets.c,v $ */
end_comment

begin_comment
comment|/*  * This code is such a kludge that I don't want to put my name on it.  * It was a ridiculously fast hack and needs rewriting.  * However it does work...  */
end_comment

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"sets.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_decl_stmt
name|struct
name|Object
modifier|*
name|CurrentEvent
init|=
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Object
modifier|*
name|Objtree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Object
name|dummy
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * define a set w/ type and name  * return a set number  */
end_comment

begin_undef
undef|#
directive|undef
name|NULL
end_undef

begin_define
define|#
directive|define
name|NULL
value|(struct Object *)0
end_define

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|Sfile
decl_stmt|,
modifier|*
name|Efile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|astringfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Noname
init|=
literal|"Unnamed set\0"
decl_stmt|;
end_decl_stmt

begin_macro
name|initsets
argument_list|(
argument|f
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|char
name|errorstring
index|[
literal|20
index|]
decl_stmt|;
specifier|extern
name|struct
name|Object
modifier|*
name|SameState
decl_stmt|;
name|Efile
operator|=
name|f
expr_stmt|;
name|Sfile
operator|=
name|s
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"char *%s_sstring[] = {\n"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sprintf
argument_list|(
name|errorstring
argument_list|,
literal|"%sERROR\0"
argument_list|,
name|ST_PREFIX
argument_list|)
decl_stmt|;
name|defineitem
argument_list|(
name|STATESET
argument_list|,
name|errorstring
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* state 0 */
name|SameState
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|SameState
operator|->
name|obj_kind
operator|=
name|OBJ_ITEM
expr_stmt|;
name|SameState
operator|->
name|obj_type
operator|=
name|STATESET
expr_stmt|;
name|SameState
operator|->
name|obj_name
operator|=
literal|"SAME"
expr_stmt|;
name|SameState
operator|->
name|obj_struc
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|SameState
operator|->
name|obj_number
operator|=
literal|0
expr_stmt|;
name|SameState
operator|->
name|obj_members
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
expr_stmt|;
name|SameState
operator|->
name|obj_left
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
expr_stmt|;
name|SameState
operator|->
name|obj_right
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
expr_stmt|;
name|SameState
operator|->
name|obj_parent
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * get a set based on its type and name  * returns address of an Object, may be set or item  */
end_comment

begin_function
name|struct
name|Object
modifier|*
name|lookup
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|unsigned
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|Object
modifier|*
name|p
init|=
name|Objtree
decl_stmt|;
name|int
name|val
init|=
literal|1
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lookup 0x%x,%s \n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|p
operator|&&
name|val
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"lookup strcmp 0x%x,%s, 0x%x,%s\n"
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|OBJ_NAME
argument_list|(
name|p
argument_list|)
argument_list|,
name|OBJ_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|p
operator|->
name|obj_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unnamed set in table!\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|int
operator|)
name|strcmp
argument_list|(
name|name
argument_list|,
name|OBJ_NAME
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
comment|/* left */
name|p
operator|=
name|p
operator|->
name|obj_left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
literal|0
condition|)
block|{
comment|/* right */
name|p
operator|=
name|p
operator|->
name|obj_right
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|->
name|obj_type
operator|!=
name|type
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lookup(0x%x,%s) found wrong obj type 0x%x\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|p
operator|->
name|obj_type
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lookup 0x%x,%s returning 0x%x\n"
argument_list|,
name|type
argument_list|,
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|states_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|end_states
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|unsigned
name|n
init|=
name|Nstates
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|extern
name|char
name|Eventshiftstring
index|[]
decl_stmt|;
name|states_done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|>>=
literal|1
operator|)
operator|<=
literal|0
condition|)
break|break;
block|}
name|Eventshift
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|d
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"Eventshift=%d\n"
argument_list|,
name|Eventshift
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|sprintf
argument_list|(
name|Eventshiftstring
argument_list|,
literal|"%d\0"
argument_list|,
name|Eventshift
argument_list|)
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"struct %s_event {\n\tint ev_number;\n"
argument_list|,
operator|&
name|protocol
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
comment|/* finish sstring[]& start estring[] */
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"};\n\nchar *%s_estring[] = {\n"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_decl_stmt
name|int
name|FirstEventAttribute
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|insert
argument_list|(
argument|o
argument_list|)
expr|struct
name|Object
operator|*
name|o
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|Object
modifier|*
name|p
init|=
name|Objtree
decl_stmt|;
name|struct
name|Object
modifier|*
modifier|*
name|q
init|=
operator|&
name|Objtree
decl_stmt|;
name|int
name|val
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|o
operator|->
name|obj_name
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal Error: inserting unnamed object\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|obj_type
operator|==
name|STATESET
condition|)
block|{
if|if
condition|(
name|states_done
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No states may be defined after *TRANSITIONS\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|obj_number
operator|=
name|Nstates
operator|++
expr_stmt|;
if|if
condition|(
name|Nstates
operator|>
name|MAXSTATES
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many states\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|Sfile
argument_list|,
literal|"#define %s 0x%x\n"
argument_list|,
name|o
operator|->
name|obj_name
argument_list|,
name|o
operator|->
name|obj_number
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"\"%s(0x%x)\",\n"
argument_list|,
name|o
operator|->
name|obj_name
argument_list|,
name|o
operator|->
name|obj_number
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
block|{
comment|/* EVENTSET */
if|if
condition|(
operator|!
name|states_done
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"states must precede events\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|o
operator|->
name|obj_number
operator|=
name|Nevents
operator|++
expr_stmt|;
if|if
condition|(
name|Nevents
operator|>
name|MAXEVENTS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many events\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|obj_struc
condition|)
block|{
if|if
condition|(
name|FirstEventAttribute
condition|)
block|{
name|fprintf
argument_list|(
name|Efile
argument_list|,
literal|"\n\tunion{\n"
argument_list|)
expr_stmt|;
comment|/*} */
name|FirstEventAttribute
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|Efile
argument_list|,
literal|"struct %s %s%s;\n\n"
argument_list|,
name|o
operator|->
name|obj_struc
argument_list|,
name|EV_PREFIX
argument_list|,
name|o
operator|->
name|obj_name
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|Efile
argument_list|,
literal|"#define %s 0x%x\n"
argument_list|,
name|o
operator|->
name|obj_name
argument_list|,
name|o
operator|->
name|obj_number
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"\"%s(0x%x)\",\n"
argument_list|,
name|o
operator|->
name|obj_name
argument_list|,
name|o
operator|->
name|obj_number
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"insert(%s)\n"
argument_list|,
name|OBJ_NAME
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|->
name|obj_right
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"insert: unclean Object right\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|obj_left
operator|!=
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"insert: unclean Object left\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|OUT
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|val
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
operator|*
name|q
operator|=
name|o
expr_stmt|;
name|o
operator|->
name|obj_parent
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
name|q
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|=
name|strcmp
argument_list|(
name|o
operator|->
name|obj_name
argument_list|,
name|p
operator|->
name|obj_name
argument_list|)
operator|)
condition|)
block|{
comment|/* equal */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"re-inserting %s\n"
argument_list|,
name|o
operator|->
name|obj_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
comment|/* left */
name|q
operator|=
operator|&
name|p
operator|->
name|obj_left
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|obj_left
expr_stmt|;
block|}
else|else
block|{
comment|/* right */
name|q
operator|=
operator|&
name|p
operator|->
name|obj_right
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|obj_right
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|dumptree
argument_list|(
name|Objtree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_macro
name|delete
argument_list|(
argument|o
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Object
modifier|*
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Object
modifier|*
name|p
init|=
name|o
operator|->
name|obj_right
decl_stmt|;
specifier|register
name|struct
name|Object
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|Object
modifier|*
name|newparent
decl_stmt|;
specifier|register
name|struct
name|Object
modifier|*
modifier|*
name|np_childlink
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|T
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"delete(0x%x)\n"
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|Objtree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* q<== lowest valued node of the right subtree */
while|while
condition|(
name|p
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|obj_left
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|->
name|obj_parent
operator|==
operator|(
expr|struct
name|Object
operator|*
operator|)
operator|&
name|Objtree
condition|)
block|{
name|newparent
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
operator|&
name|Objtree
expr_stmt|;
name|np_childlink
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|*
operator|)
operator|&
name|Objtree
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|->
name|obj_parent
operator|->
name|obj_left
operator|==
name|o
condition|)
block|{
name|newparent
operator|=
name|o
operator|->
name|obj_parent
expr_stmt|;
name|np_childlink
operator|=
operator|&
operator|(
name|o
operator|->
name|obj_parent
operator|->
name|obj_left
operator|)
expr_stmt|;
block|}
else|else
block|{
name|newparent
operator|=
name|o
operator|->
name|obj_parent
expr_stmt|;
name|np_childlink
operator|=
operator|&
operator|(
name|o
operator|->
name|obj_parent
operator|->
name|obj_right
operator|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|T
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"newparent=0x%x\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|q
condition|)
block|{
comment|/* q gets the left, parent gets the right */
name|IFDEBUG
argument_list|(
argument|T
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"delete: q null\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|q
operator|->
name|obj_left
init|=
name|p
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|obj_parent
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|o
operator|->
name|obj_right
expr_stmt|;
block|}
else|else
block|{
comment|/* parent(instead of q) gets the left ; there is no right  */
name|IFDEBUG
argument_list|(
argument|T
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"delete: q not null\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|p
init|=
name|o
operator|->
name|obj_left
decl_stmt|;
block|}
operator|*
name|np_childlink
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|->
name|obj_parent
operator|=
name|newparent
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|T
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"After deleting 0x%x\n"
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|Objtree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_function
name|struct
name|Object
modifier|*
name|defineset
parameter_list|(
name|type
parameter_list|,
name|adr
parameter_list|,
name|keep
parameter_list|)
name|unsigned
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|adr
decl_stmt|;
name|int
name|keep
decl_stmt|;
block|{
name|struct
name|Object
modifier|*
name|onew
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|printf
argument_list|(
literal|"defineset(0x%x,%s, %s)\n"
argument_list|,
name|type
argument_list|,
name|adr
argument_list|,
name|keep
condition|?
literal|"KEEP"
else|:
literal|"NO_KEEP"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|onew
init|=
operator|(
expr|struct
name|Object
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|onew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_name
operator|=
name|adr
expr_stmt|;
name|onew
operator|->
name|obj_kind
operator|=
name|OBJ_SET
expr_stmt|;
name|onew
operator|->
name|obj_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|keep
condition|)
name|insert
argument_list|(
name|onew
argument_list|)
expr_stmt|;
comment|/* address already stashed before calling defineset */
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|printf
argument_list|(
literal|"defineset(0x%x,%s) returning 0x%x\n"
argument_list|,
name|type
argument_list|,
name|adr
argument_list|,
name|onew
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|Objtree
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|onew
operator|)
return|;
block|}
end_function

begin_macro
name|dumpit
argument_list|(
argument|o
argument_list|,
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|o
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"object 0x%x, %s\n"
argument_list|,
name|o
argument_list|,
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"0x%x: 0x%x 0x%x 0x%x 0x%x\n"
argument_list|,
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|o
operator|)
argument_list|,
operator|*
name|o
argument_list|,
operator|*
operator|(
name|o
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|o
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|o
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
block|}
end_block

begin_macro
name|defineitem
argument_list|(
argument|type
argument_list|,
argument|adr
argument_list|,
argument|struc
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|adr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|struc
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Object
modifier|*
name|onew
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|printf
argument_list|(
literal|"defineitem(0x%x, %s at 0x%x, %s)\n"
argument_list|,
name|type
argument_list|,
name|adr
argument_list|,
name|adr
argument_list|,
name|struc
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|onew
operator|=
name|lookup
argument_list|(
name|type
argument_list|,
name|adr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Internal error at defineitem: trying to redefine obj type 0x%x, adr %s\n"
argument_list|,
name|type
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|onew
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|onew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_name
operator|=
name|stash
argument_list|(
name|adr
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_kind
operator|=
name|OBJ_ITEM
expr_stmt|;
name|onew
operator|->
name|obj_type
operator|=
name|type
expr_stmt|;
name|onew
operator|->
name|obj_struc
operator|=
name|struc
condition|?
name|stash
argument_list|(
name|struc
argument_list|)
else|:
name|struc
expr_stmt|;
name|insert
argument_list|(
name|onew
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"defineitem(0x%x, %s) returning 0x%x\n"
argument_list|,
name|type
argument_list|,
name|adr
argument_list|,
name|onew
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_macro
name|member
argument_list|(
argument|o
argument_list|,
argument|adr
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Object
modifier|*
name|o
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|adr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Object
modifier|*
name|onew
decl_stmt|,
modifier|*
name|oold
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|o
argument_list|)
name|printf
argument_list|(
literal|"member(0x%x, %s)\n"
argument_list|,
name|o
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|oold
init|=
name|lookup
argument_list|(
name|o
operator|->
name|obj_type
argument_list|,
name|adr
argument_list|)
decl_stmt|;
name|onew
operator|=
operator|(
expr|struct
name|Object
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oold
operator|==
name|NULL
condition|)
block|{
specifier|extern
name|int
name|lineno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning at line %d: set definition of %s causes definition of\n"
argument_list|,
name|lineno
argument_list|,
name|OBJ_NAME
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t (previously undefined) member %s\n"
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|onew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_name
operator|=
name|stash
argument_list|(
name|adr
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_kind
operator|=
name|OBJ_ITEM
expr_stmt|;
name|onew
operator|->
name|obj_type
operator|=
name|o
operator|->
name|obj_type
expr_stmt|;
name|onew
operator|->
name|obj_members
operator|=
name|NULL
expr_stmt|;
name|insert
argument_list|(
name|onew
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|oold
operator|->
name|obj_kind
operator|!=
name|OBJ_ITEM
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sets cannot be members of sets; %s\n"
argument_list|,
name|adr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|oold
argument_list|,
name|onew
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|Object
argument_list|)
argument_list|)
expr_stmt|;
name|onew
operator|->
name|obj_members
operator|=
name|onew
operator|->
name|obj_left
operator|=
name|onew
operator|->
name|obj_right
operator|=
name|NULL
expr_stmt|;
block|}
name|onew
operator|->
name|obj_members
operator|=
name|o
operator|->
name|obj_members
expr_stmt|;
name|o
operator|->
name|obj_members
operator|=
name|onew
expr_stmt|;
block|}
end_block

begin_function
name|struct
name|Object
modifier|*
name|Lookup
parameter_list|(
name|type
parameter_list|,
name|name
parameter_list|)
name|unsigned
name|char
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|struct
name|Object
modifier|*
name|o
init|=
name|lookup
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Trying to use undefined %s: %s\n"
argument_list|,
name|type
operator|==
name|STATESET
condition|?
literal|"state"
else|:
literal|"event"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|o
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|AddCurrentEventName
argument_list|(
name|x
argument_list|)
specifier|register
name|char
operator|*
operator|*
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|n
init|=
name|EV_PREFIX
decl_stmt|;
empty_stmt|;
if|if
condition|(
name|CurrentEvent
operator|==
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No event named!  BARF!\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|CurrentEvent
operator|->
name|obj_struc
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No attributes for current event!\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* add prefix first */
while|while
condition|(
operator|*
name|n
condition|)
block|{
operator|*
operator|(
operator|*
name|x
operator|)
operator|++
operator|=
operator|*
name|n
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|CurrentEvent
operator|->
name|obj_name
expr_stmt|;
while|while
condition|(
operator|*
name|n
condition|)
block|{
operator|*
operator|(
operator|*
name|x
operator|)
operator|++
operator|=
operator|*
name|n
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|dumptree
argument_list|(
name|o
argument_list|,
name|i
argument_list|)
specifier|register
expr|struct
name|Object
operator|*
name|o
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%3d NULL\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dumptree
argument_list|(
name|o
operator|->
name|obj_left
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|fputc
argument_list|(
literal|' '
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%3d 0x%x: %s\n"
argument_list|,
name|i
argument_list|,
name|o
argument_list|,
name|OBJ_NAME
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|dumptree
argument_list|(
name|o
operator|->
name|obj_right
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|dump
argument_list|(
argument|c
argument_list|,
argument|a
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|int
name|x
init|=
literal|8
decl_stmt|;
name|int
name|zero
init|=
literal|0
decl_stmt|;
include|#
directive|include
file|<sys/signal.h>
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dump: c 0x%x, a 0x%x\n"
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|x
operator|=
name|x
operator|/
name|zero
expr_stmt|;
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dump_trans
argument_list|(
argument|pred
argument_list|,
argument|oldstate
argument_list|,
argument|newstate
argument_list|,
argument|action
argument_list|,
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|Object
modifier|*
name|oldstate
decl_stmt|,
modifier|*
name|newstate
decl_stmt|,
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|pred
decl_stmt|,
modifier|*
name|action
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|transno
decl_stmt|;
name|struct
name|Object
modifier|*
name|o
decl_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n%d:  "
argument_list|,
name|transno
argument_list|)
expr_stmt|;
define|#
directive|define
name|dumpit
parameter_list|(
name|x
parameter_list|)
define|\
value|if((x)->obj_kind == OBJ_SET) {\ 		o = (x)->obj_members; fprintf( stdout, "[ " );\ 		while(o) { fprintf(stdout, "%s ", o->obj_name); o = o->obj_members; }\ 		fprintf( stdout, " ] ");\ 	} else { fprintf(stdout, "%s ", (x)->obj_name); }
name|dumpit
argument_list|(
name|newstate
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"<== "
argument_list|)
expr_stmt|;
name|dumpit
argument_list|(
name|oldstate
argument_list|)
expr_stmt|;
name|dumpit
argument_list|(
name|event
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"\n\t\t%s\n\t\t%s\n"
argument_list|,
name|pred
condition|?
name|pred
else|:
literal|"DEFAULT"
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

