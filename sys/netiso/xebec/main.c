begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/xebec/Attic/main.c,v $ */
end_comment

begin_comment
comment|/*  * TODO:  * rewrite the command line stuff altogether - it's kludged beyond  * belief (as is the rest of the code...)  *  * DISCLAIMER DISCLAIMER DISCLAIMER  * This code is such a kludge that I don't want to put my name on it.  * It was a ridiculously fast hack and needs rewriting.  * However it does work...  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_decl_stmt
name|int
name|debug
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lineno
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|statefile
decl_stmt|,
modifier|*
name|actfile
decl_stmt|,
modifier|*
name|eventfile_h
decl_stmt|,
modifier|*
name|statevalfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|infile
decl_stmt|,
modifier|*
name|astringfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Transfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|astringfile_name
init|=
name|DEBUGFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|actfile_name
init|=
name|ACTFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|statefile_name
init|=
name|STATEFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|statevalfile_name
init|=
name|STATEVALFILE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|eventfile_h_name
init|=
name|EVENTFILE_H
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_trans
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|print_protoerrs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pgoption
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|kerneldirname
index|[
literal|50
index|]
init|=
literal|"\0"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|protocol
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|synonyms
index|[]
init|=
block|{
literal|"EVENT"
block|,
literal|"PCB"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|usage
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s<transition file> {-D<debug options>}<other options>\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t<other options> is any combination of:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-A<action file name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-E<event file name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-S<state file name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-I<initial values file name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-X<debugging file name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-K<directory name>\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tThese names do NOT include the suffices (.c, .h)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-D<options> to turn on debug options for xebec itself\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t-<nn> for levels of debugging output\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t<nn> ranges from 1 to 3, 1 is default(everything)\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-T to print transitions\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-e to print list of combinations of\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t\t [event,old_state] that produce protocol errors\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t-g include profiling code in driver\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|openfiles
argument_list|(
name|proto
argument_list|)
specifier|register
name|char
operator|*
name|proto
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|junk
decl_stmt|;
specifier|register
name|int
name|lenp
init|=
name|strlen
argument_list|(
name|proto
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|b
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"openfiles %s\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|HEADER
value|Header
define|#
directive|define
name|SOURCE
value|Source
define|#
directive|define
name|DOIT
parameter_list|(
name|X
parameter_list|)
define|\
comment|/* GAG */
define|\
value|junk = Malloc( 2 + lenp + strlen(X
comment|/**/
value|_name) );\ 	(void) sprintf(junk, "%s_", proto);\ 	X
comment|/**/
value|_name = strcat(junk, X
comment|/**/
value|_name);\ 	X = fopen(X
comment|/**/
value|_name, "w");\ 	if((X)==(FILE *)0)\ 	{ fprintf(stderr,"Open failed: %s\n", "X"); Exit(-1); }\ 	fprintf(X, "/* %cHeader%c */\n",'$', '$' );\ 	fprintf(X, "/* %cSource%c */\n",'$', '$' );
name|DOIT
parameter_list|(
name|eventfile_h
parameter_list|)
function_decl|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
ifdef|#
directive|ifdef
name|DEBUG
name|DOIT
argument_list|(
name|astringfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"#ifndef _NFILE\n#include<stdio.h>\n#endif _NFILE\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|DOIT
parameter_list|(
name|statevalfile
parameter_list|)
function_decl|;
name|DOIT
argument_list|(
name|statefile
argument_list|)
expr_stmt|;
name|DOIT
argument_list|(
name|actfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"#ifndef lint\nstatic char *rcsid = \"$Header/**/$\";\n#endif lint\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgoption
condition|)
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|15
argument_list|)
expr_stmt|;
else|else
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|FakeFilename
argument_list|(
name|actfile
argument_list|,
name|Transfilename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FakeFilename
argument_list|(
name|actfile
argument_list|,
name|Transfilename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"#include \"%s%s\"\n"
argument_list|,
name|kerneldirname
argument_list|,
name|statevalfile_name
argument_list|)
expr_stmt|;
name|FakeFilename
argument_list|(
name|actfile
argument_list|,
name|Transfilename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|initsets
argument_list|(
name|eventfile_h
argument_list|,
name|statefile
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|includecode
argument_list|(
argument|file
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|char
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|static
name|char
name|o
init|=
literal|'{'
decl_stmt|;
specifier|static
name|char
name|c
init|=
literal|'}'
decl_stmt|;
specifier|register
name|char
modifier|*
name|g
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"including: %s, f=0x%x"
argument_list|,
name|f
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|g
init|=
operator|++
name|f
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|g
operator|==
name|o
condition|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|g
operator|==
name|c
condition|)
name|count
operator|--
expr_stmt|;
name|g
operator|++
expr_stmt|;
block|}
operator|*
operator|(
operator|--
name|g
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"derived: %s"
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|f
argument_list|)
decl_stmt|;
name|FakeFilename
argument_list|(
name|file
argument_list|,
name|Transfilename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|putincludes
argument_list|()
end_macro

begin_block
block|{
name|FakeFilename
argument_list|(
name|actfile
argument_list|,
name|Transfilename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"\n#include \"%s%s\"\n"
argument_list|,
name|kerneldirname
argument_list|,
name|eventfile_h_name
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
if|if
condition|(
operator|!
name|debug
index|[
literal|'K'
index|]
condition|)
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"\n#include \"%s\"\n"
argument_list|,
name|astringfile_name
argument_list|)
expr_stmt|;
comment|/* not in kernel mode */
name|ENDDEBUG
name|FakeFilename
parameter_list|(
name|actfile
parameter_list|,
name|Transfilename
parameter_list|,
name|lineno
parameter_list|)
function_decl|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|2
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
name|int
name|start
decl_stmt|,
name|finish
decl_stmt|;
specifier|extern
name|int
name|FirstEventAttribute
decl_stmt|;
specifier|extern
name|int
name|Nevents
decl_stmt|,
name|Nstates
decl_stmt|;
name|start
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"infile = %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|Transfilename
init|=
name|argv
index|[
literal|1
index|]
decl_stmt|;
name|infile
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
while|while
condition|(
name|i
operator|<
name|argc
condition|)
block|{
specifier|register
name|int
name|j
init|=
literal|0
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|==
literal|'-'
condition|)
name|j
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
condition|)
block|{
comment|/* GROT */
case|case
literal|'A'
case|:
name|name
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
name|actfile_name
operator|=
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|actfile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|actfile_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|name
operator|=
endif|#
directive|endif
endif|LINT
name|strcat
argument_list|(
name|actfile_name
argument_list|,
literal|".c"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"debugging file is %s\n"
argument_list|,
name|actfile_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|debug
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"option %c file %s\n"
argument_list|,
name|c
argument_list|,
operator|&
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|kerneldirname
argument_list|,
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|debug
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|name
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
name|astringfile_name
operator|=
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|astringfile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|astringfile_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|name
operator|=
endif|#
directive|endif
endif|LINT
name|strcat
argument_list|(
name|astringfile_name
argument_list|,
literal|".c"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"option %c, astringfile name %s\n"
argument_list|,
name|c
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|name
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
name|eventfile_h_name
operator|=
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|eventfile_h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|eventfile_h_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|name
operator|=
endif|#
directive|endif
endif|LINT
name|strcat
argument_list|(
name|eventfile_h_name
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"event files is %s\n"
argument_list|,
name|eventfile_h_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|name
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
name|statevalfile_name
operator|=
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|statevalfile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|statevalfile_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|name
operator|=
endif|#
directive|endif
endif|LINT
name|strcat
argument_list|(
name|statevalfile_name
argument_list|,
literal|".init"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"state table initial values file is %s\n"
argument_list|,
name|statevalfile_name
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|name
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
name|statefile_name
operator|=
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|statefile_name
operator|=
operator|(
name|char
operator|*
operator|)
name|strcpy
argument_list|(
name|statefile_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|name
operator|=
endif|#
directive|endif
endif|LINT
name|strcat
argument_list|(
name|statefile_name
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"state file is %s\n"
argument_list|,
name|statefile_name
argument_list|)
expr_stmt|;
break|break;
comment|/* END GROT */
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
name|debug
index|[
literal|'X'
index|]
operator|=
operator|(
name|int
operator|)
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|-
operator|(
name|int
operator|)
literal|'0'
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"value of debug['X'] is 0x%x,%d\n"
argument_list|,
name|debug
index|[
literal|'X'
index|]
argument_list|,
name|debug
index|[
literal|'X'
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
while|while
condition|(
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'X'
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"debugging on"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
index|[
literal|'X'
index|]
condition|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|" - overrides any -%d flags used\n"
argument_list|,
name|debug
index|[
literal|'X'
index|]
argument_list|)
expr_stmt|;
block|}
name|debug
index|[
name|c
index|]
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"debug %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'g'
case|:
name|pgoption
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Profiling\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|print_protoerrs
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Protocol error table:\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|print_trans
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Transitions:\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|kerneldirname
index|[
literal|0
index|]
condition|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|debug
index|[
literal|'X'
index|]
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"Option K overrides option X\n"
argument_list|)
expr_stmt|;
name|debug
index|[
literal|'X'
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|notdef
if|if
condition|(
name|strlen
argument_list|(
name|kerneldirname
argument_list|)
operator|<
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"K option: dir name too short!\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* add ../name/ */
name|c
operator|=
operator|(
name|char
operator|*
operator|)
name|Malloc
argument_list|(
name|strlen
argument_list|(
name|kerneldirname
argument_list|)
operator|+
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|<=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"Cannot allocate %d bytes for kerneldirname\n"
argument_list|,
name|strlen
argument_list|(
name|kerneldirname
operator|+
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"kerneldirname is %s\n"
argument_list|,
name|kerneldirname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|c
operator|=
literal|'.'
expr_stmt|;
operator|*
operator|(
name|c
operator|+
literal|1
operator|)
operator|=
literal|'.'
expr_stmt|;
operator|*
operator|(
name|c
operator|+
literal|2
operator|)
operator|=
literal|'/'
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|c
argument_list|,
name|kerneldirname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|c
argument_list|,
literal|"/\0"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|kerneldirname
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
name|init_alloc
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|llparse
argument_list|()
expr_stmt|;
comment|/* {{ */
if|if
condition|(
operator|!
name|FirstEventAttribute
condition|)
name|fprintf
argument_list|(
name|eventfile_h
argument_list|,
literal|"\t}ev_union;\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eventfile_h
argument_list|,
literal|"};/* end struct event */\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eventfile_h
argument_list|,
literal|"\n#define %s_NEVENTS 0x%x\n"
argument_list|,
name|protocol
argument_list|,
name|Nevents
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|eventfile_h
argument_list|,
literal|"\n#define ATTR(X)ev_union.%s/**/X/**/\n"
argument_list|,
name|EV_PREFIX
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|eventfile_h
argument_list|)
expr_stmt|;
comment|/* {{ */
name|fprintf
argument_list|(
name|actfile
argument_list|,
literal|"\t}\nreturn 0;\n}\n"
argument_list|)
expr_stmt|;
comment|/* end switch; end action() */
name|dump_predtable
argument_list|(
name|actfile
argument_list|)
expr_stmt|;
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
if|if
condition|(
operator|!
name|debug
index|[
literal|'K'
index|]
condition|)
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|6
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
comment|/* 		putdriver(actfile, 10); 		*/
if|if
condition|(
name|debug
index|[
literal|'K'
index|]
condition|)
block|{
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|11
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|debug
index|[
literal|'X'
index|]
condition|)
block|{
case|case
literal|1
case|:
default|default:
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|7
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|13
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
break|break;
block|}
block|}
name|ENDDEBUG
name|putdriver
argument_list|(
name|actfile
argument_list|,
literal|8
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|actfile
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
comment|/* { */
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"};\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|astringfile
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|fclose
argument_list|(
name|statevalfile
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|statefile
argument_list|,
literal|"\n#define %s_NSTATES 0x%x\n"
argument_list|,
name|protocol
argument_list|,
name|Nstates
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|statefile
argument_list|)
expr_stmt|;
name|finish
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%d seconds\n"
argument_list|,
name|finish
operator|-
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_protoerrs
condition|)
name|printprotoerrs
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|transno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|Exit
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error at line %d\n"
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|transno
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Transition number %d\n"
argument_list|,
name|transno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|statefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|eventfile_h
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|actfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|syntax
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
modifier|*
name|synt
index|[]
init|=
block|{
literal|"*PROTOCOL<string>\n"
block|,
literal|"*PCB<string><optional: SYNONYM synonymstring>\n"
block|,
literal|"<optional: *INCLUDE {\n<C source>\n}>\n"
block|,
literal|"*STATES<string>\n"
block|,
literal|"*EVENTS<string>\n"
block|,
literal|"*TRANSITIONS<string>\n"
block|, 	}
decl_stmt|;
block|}
end_block

begin_macro
name|FakeFilename
argument_list|(
argument|outfile
argument_list|,
argument|name
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|l
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	doesn't work 	fprintf(outfile, "\n\n\n\n# line %d \"%s\"\n", l, name); 	*/
block|}
end_block

end_unit

