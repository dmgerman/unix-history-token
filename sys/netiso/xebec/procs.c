begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: procs.c,v 2.3 88/09/19 12:55:22 nhall Exp $ */
end_comment

begin_comment
comment|/* $Source: /var/home/tadl/src/argo/xebec/RCS/procs.c,v $ */
end_comment

begin_comment
comment|/*  * This code is such a kludge that I don't want to put my name on it.  * It was a ridiculously fast hack and needs rewriting.  * However it does work...  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_include
include|#
directive|include
file|"sets.h"
end_include

begin_include
include|#
directive|include
file|"procs.h"
end_include

begin_struct
struct|struct
name|Predicate
block|{
name|int
name|p_index
decl_stmt|;
name|int
name|p_transno
decl_stmt|;
name|char
modifier|*
name|p_str
decl_stmt|;
name|struct
name|Predicate
modifier|*
name|p_next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|Stateent
block|{
name|int
name|s_index
decl_stmt|;
name|int
name|s_newstate
decl_stmt|;
name|int
name|s_action
decl_stmt|;
name|struct
name|Stateent
modifier|*
name|s_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|Object
modifier|*
name|SameState
init|=
operator|(
expr|struct
name|Object
operator|*
operator|)
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Index
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nstates
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Nevents
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Predicate
modifier|*
modifier|*
name|Predlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Stateent
modifier|*
modifier|*
name|Statelist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|astringfile
decl_stmt|;
end_decl_stmt

begin_macro
name|end_events
argument_list|()
end_macro

begin_block
block|{
name|int
name|size
decl_stmt|,
name|part
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
comment|/* finish estring[], start astring[] */
if|if
condition|(
name|debug
index|[
literal|'X'
index|]
operator|<
literal|2
condition|)
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"};\n\nchar *%s_astring[] = {\n\"NULLACTION\",\n"
argument_list|,
name|protocol
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* NOSTRICT */
name|Statelist
init|=
operator|(
expr|struct
name|Stateent
operator|*
operator|*
operator|)
name|Malloc
argument_list|(
operator|(
name|Nstates
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Statent
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* NOSTRICT */
name|Predlist
operator|=
operator|(
expr|struct
name|Predicate
operator|*
operator|*
operator|)
name|Malloc
argument_list|(
operator|(
operator|(
operator|(
name|Nevents
operator|)
operator|<<
name|Eventshift
operator|)
operator|+
name|Nstates
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Predicate
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
operator|(
name|Nevents
operator|)
operator|<<
name|Eventshift
operator|)
operator|+
name|Nstates
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|Predicate
operator|*
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
name|Predlist
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|N
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"Predlist at 0x%x, sbrk 0x%x bzero size %d at addr 0x%x\n"
argument_list|,
name|Predlist
argument_list|,
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|,
name|size
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|BZSIZE
value|8192
while|while
condition|(
name|size
condition|)
block|{
name|part
operator|=
name|size
operator|>
name|BZSIZE
condition|?
name|BZSIZE
else|:
name|size
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|N
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"bzero addr 0x%x part %d size %d\n"
argument_list|,
name|addr
argument_list|,
name|part
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bzero
parameter_list|(
name|addr
parameter_list|,
name|part
parameter_list|)
function_decl|;
name|IFDEBUG
argument_list|(
argument|N
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"after bzero addr 0x%x part %d size %d\n"
argument_list|,
name|addr
argument_list|,
name|part
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|addr
operator|+=
name|part
expr_stmt|;
name|size
operator|-=
name|part
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|N
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"endevents..done \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_function
name|int
name|acttable
parameter_list|(
name|f
parameter_list|,
name|actstring
parameter_list|)
name|char
modifier|*
name|actstring
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
block|{
specifier|static
name|Actindex
operator|=
literal|0
expr_stmt|;
specifier|extern
name|FILE
modifier|*
name|astringfile
decl_stmt|;
specifier|extern
name|int
name|pgoption
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"acttable()\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case 0x%x: \n"
argument_list|,
operator|++
name|Actindex
argument_list|)
decl_stmt|;
if|if
condition|(
name|pgoption
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\" # dummy statement\");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\"_Xebec_action_%x: \");\n"
argument_list|,
name|Actindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\".data\");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\".globl _Xebec_action_%x# X profiling\");\n"
argument_list|,
name|Actindex
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\".long 0 # X profiling\");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\".text # X profiling\");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\"cas r0,r15,r0 # X profiling\");\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"asm(\"bali r15,mcount   # X profiling\");\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"\t\t%s\n\t\t break;\n"
argument_list|,
name|actstring
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|X
argument_list|)
if|if
condition|(
name|debug
index|[
literal|'X'
index|]
operator|<
literal|2
condition|)
block|{
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|fputc
argument_list|(
literal|'"'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|actstring
condition|)
block|{
if|if
condition|(
operator|*
name|actstring
operator|==
literal|'\n'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|fputc
argument_list|(
literal|'n'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|actstring
operator|==
literal|'\\'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|actstring
operator|==
literal|'\"'
condition|)
block|{
name|fputc
argument_list|(
literal|'\\'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|fputc
argument_list|(
literal|'\"'
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
block|}
else|else
name|fputc
argument_list|(
operator|*
name|actstring
argument_list|,
name|astringfile
argument_list|)
expr_stmt|;
name|actstring
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|astringfile
argument_list|,
literal|"\",\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|LINELEN
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Action too long: %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ENDDEBUG
return|return
operator|(
name|Actindex
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|Npred
init|=
literal|0
decl_stmt|,
name|Ndefpred
init|=
literal|0
decl_stmt|,
name|Ntrans
init|=
literal|0
decl_stmt|,
name|Ndefevent
init|=
literal|0
decl_stmt|,
name|Nnulla
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|statetable
argument_list|(
argument|string
argument_list|,
argument|oldstate
argument_list|,
argument|newstate
argument_list|,
argument|action
argument_list|,
argument|event
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Object
modifier|*
name|oldstate
decl_stmt|,
modifier|*
name|newstate
decl_stmt|,
modifier|*
name|event
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|different
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"statetable(0x%x, 0x%x,0x%x, 0x%x)\n"
argument_list|,
name|string
argument_list|,
name|oldstate
argument_list|,
name|newstate
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"statetable(%s, %s,%s, 0x%x)\n"
argument_list|,
name|string
argument_list|,
name|oldstate
operator|->
name|obj_name
argument_list|,
name|newstate
operator|->
name|obj_name
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|action
condition|)
name|Nnulla
operator|++
expr_stmt|;
if|if
condition|(
name|newstate
operator|->
name|obj_kind
operator|==
name|OBJ_SET
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Newstate cannot be a set\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|different
operator|=
operator|(
name|newstate
operator|!=
name|SameState
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|predtable
argument_list|(
name|oldstate
argument_list|,
name|event
argument_list|,
name|string
argument_list|,
name|action
argument_list|,
operator|(
name|newstate
operator|->
name|obj_number
operator|)
operator|*
name|different
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"EXIT statetable\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_macro
name|stateentry
argument_list|(
argument|index
argument_list|,
argument|oldstate
argument_list|,
argument|newstate
argument_list|,
argument|action
argument_list|)
end_macro

begin_decl_stmt
name|int
name|index
decl_stmt|,
name|action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|oldstate
decl_stmt|,
name|newstate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|FILE
modifier|*
name|statevalfile
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"stateentry(0x%x,0x%x,0x%x,0x%x) Statelist@0x%x, val 0x%x\n"
argument_list|,
name|index
argument_list|,
name|oldstate
argument_list|,
name|newstate
argument_list|,
name|action
argument_list|,
operator|&
name|Statelist
argument_list|,
name|Statelist
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|fprintf
argument_list|(
name|statevalfile
argument_list|,
literal|"{0x%x,0x%x},\n"
argument_list|,
name|newstate
argument_list|,
name|action
argument_list|)
decl_stmt|;
block|}
end_block

begin_function
name|int
name|predtable
parameter_list|(
name|os
parameter_list|,
name|oe
parameter_list|,
name|str
parameter_list|,
name|action
parameter_list|,
name|newstate
parameter_list|)
name|struct
name|Object
modifier|*
name|os
decl_stmt|,
decl|*
name|oe
decl_stmt|;
end_function

begin_decl_stmt
name|char
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action
decl_stmt|,
name|newstate
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Predicate
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|event
decl_stmt|,
name|state
decl_stmt|;
specifier|register
name|struct
name|Object
modifier|*
name|e
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|struct
name|Object
modifier|*
name|firste
decl_stmt|;
if|if
condition|(
name|oe
operator|==
operator|(
expr|struct
name|Object
operator|*
operator|)
literal|0
condition|)
block|{
name|Ndefevent
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"DEFAULT EVENTS aren't implemented; trans ignored\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|Ntrans
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"PREDTAB: s %5s;  e %5s\n"
argument_list|,
name|os
operator|->
name|obj_kind
operator|==
name|OBJ_SET
condition|?
literal|"SET"
else|:
literal|"item"
argument_list|,
name|oe
operator|->
name|obj_kind
operator|==
name|OBJ_SET
condition|?
literal|"SET"
else|:
literal|"item"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|os
operator|->
name|obj_kind
operator|==
name|OBJ_SET
condition|)
name|s
operator|=
name|os
operator|->
name|obj_members
expr_stmt|;
else|else
name|s
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|oe
operator|->
name|obj_kind
operator|==
name|OBJ_SET
condition|)
name|firste
operator|=
name|oe
operator|->
name|obj_members
expr_stmt|;
else|else
name|firste
operator|=
name|oe
expr_stmt|;
if|if
condition|(
name|newstate
condition|)
block|{
name|fprintf
argument_list|(
name|statevalfile
argument_list|,
literal|"{0x%x,0x%x},\n"
argument_list|,
name|newstate
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|Index
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|s
condition|)
block|{
if|if
condition|(
operator|!
name|newstate
condition|)
block|{
comment|/* !newstate --> SAME */
comment|/* i.e., use old obj_number */
name|fprintf
argument_list|(
name|statevalfile
argument_list|,
literal|"{0x%x,0x%x},\n"
argument_list|,
name|s
operator|->
name|obj_number
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|Index
operator|++
expr_stmt|;
block|}
name|e
operator|=
name|firste
expr_stmt|;
while|while
condition|(
name|e
condition|)
block|{
name|event
operator|=
name|e
operator|->
name|obj_number
expr_stmt|;
name|state
operator|=
name|s
operator|->
name|obj_number
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"pred table event=0x%x, state 0x%x\n"
argument_list|,
name|event
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|str
comment|/* DEFAULT PREDICATE */
condition|)
block|{
name|Ndefpred
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"DEFAULT pred state 0x%x, event 0x%x, Index 0x%x\n"
argument_list|,
name|state
argument_list|,
name|event
argument_list|,
name|Index
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
else|else
name|Npred
operator|++
expr_stmt|;
comment|/* put at END of list */
ifndef|#
directive|ifndef
name|LINT
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"predicate for event 0x%x, state 0x%x is 0x%x, %s\n"
argument_list|,
name|event
argument_list|,
name|state
argument_list|,
name|Index
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|ENDDEBUG
endif|#
directive|endif
endif|LINT
for|for
control|(
operator|(
operator|(
name|q
operator|=
operator|&
name|Predlist
index|[
operator|(
name|event
operator|<<
name|Eventshift
operator|)
operator|+
name|state
index|]
operator|)
operator|,
operator|(
name|p
operator|=
name|Predlist
index|[
operator|(
name|event
operator|<<
name|Eventshift
operator|)
operator|+
name|state
index|]
operator|)
operator|)
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p_next
control|)
block|{
name|q
operator|=
operator|&
name|p
operator|->
name|p_next
expr_stmt|;
block|}
name|p
operator|=
operator|(
expr|struct
name|Predicate
operator|*
operator|)
name|Malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|Predicate
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_next
operator|=
operator|(
expr|struct
name|Predicate
operator|*
operator|)
literal|0
expr_stmt|;
name|p
operator|->
name|p_str
operator|=
name|str
expr_stmt|;
name|p
operator|->
name|p_index
operator|=
name|Index
expr_stmt|;
name|p
operator|->
name|p_transno
operator|=
name|transno
expr_stmt|;
operator|*
name|q
operator|=
name|p
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"predtable index 0x%x, transno %d, E 0x%x, S 0x%x\n"
argument_list|,
name|Index
argument_list|,
name|transno
argument_list|,
name|e
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|e
init|=
name|e
operator|->
name|obj_members
decl_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|obj_members
expr_stmt|;
block|}
return|return
name|Index
return|;
block|}
end_block

begin_macro
name|printprotoerrs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|e
decl_stmt|,
name|s
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[ Event, State ] without any transitions :\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|Nevents
condition|;
name|e
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Event 0x%x: states "
argument_list|,
name|e
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|Nstates
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"0x%x "
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_macro
name|dump_predtable
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|Predicate
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|e
decl_stmt|,
name|s
decl_stmt|,
name|hadapred
decl_stmt|;
name|int
name|defaultindex
decl_stmt|;
name|int
name|defaultItrans
decl_stmt|;
specifier|extern
name|int
name|bytesmalloced
decl_stmt|;
specifier|extern
name|int
name|byteswasted
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" Xebec used %8d bytes of storage, wasted %8d bytes\n"
argument_list|,
name|bytesmalloced
argument_list|,
name|byteswasted
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %8d states\n %8d events\n %8d transitions\n"
argument_list|,
name|Nstates
argument_list|,
name|Nevents
argument_list|,
name|Ntrans
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %8d predicates\n %8d default predicates used\n"
argument_list|,
name|Npred
argument_list|,
name|Ndefpred
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|" %8d null actions\n"
argument_list|,
name|Nnulla
argument_list|)
expr_stmt|;
name|putdriver
argument_list|(
name|f
argument_list|,
literal|5
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|Nevents
condition|;
name|e
operator|++
control|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|Nstates
condition|;
name|s
operator|++
control|)
block|{
name|p
operator|=
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
expr_stmt|;
name|hadapred
operator|=
literal|0
expr_stmt|;
name|defaultindex
operator|=
literal|0
expr_stmt|;
name|defaultItrans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|d
argument_list|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_str
condition|)
block|{
if|if
condition|(
operator|!
name|hadapred
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"case 0x%x:\n\t"
argument_list|,
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
argument_list|)
expr_stmt|;
name|hadapred
operator|=
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"if %s return 0x%x;\n\t else "
argument_list|,
name|p
operator|->
name|p_str
argument_list|,
name|p
operator|->
name|p_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|defaultindex
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nConflict between transitions %d and %d: duplicate default \n"
argument_list|,
name|p
operator|->
name|p_transno
argument_list|,
name|defaultItrans
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|defaultindex
operator|=
name|p
operator|->
name|p_index
expr_stmt|;
name|defaultItrans
operator|=
name|p
operator|->
name|p_transno
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|p_next
expr_stmt|;
block|}
if|if
condition|(
name|hadapred
condition|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"return 0x%x;\n"
argument_list|,
name|defaultindex
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|d
argument_list|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|IFDEBUG
argument_list|(
argument|g
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"loop: e 0x%x s 0x%x hadapred 0x%x dindex 0x%x for trans 0x%x\n"
argument_list|,
name|e
argument_list|,
name|s
argument_list|,
name|hadapred
argument_list|,
name|defaultindex
argument_list|,
name|defaultItrans
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|hadapred
condition|)
block|{
comment|/* put a -1 in the array  - Predlist is temporary storage */
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
operator|=
operator|(
expr|struct
name|Predicate
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* put defaultindex in the array */
comment|/* if defaultindex is zero, then the driver will 			 * cause an erroraction (same as if no default 			 * were given and none of the predicates were true; 			 * also same as if no preds or defaults were given 			 * for this combo) 			 */
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
operator|=
operator|(
expr|struct
name|Predicate
operator|*
operator|)
operator|(
name|defaultindex
operator|)
expr_stmt|;
block|}
block|}
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"default: return 0;\n} /* end switch */\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"/*NOTREACHED*/return 0;\n} /* _Xebec_index() */\n"
argument_list|)
expr_stmt|;
else|#
directive|else
else|notdef
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"} /* _Xebec_index() */\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"static int inx[%d][%d] = { {"
argument_list|,
name|Nevents
operator|+
literal|1
argument_list|,
name|Nstates
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|Nstates
condition|;
name|s
operator|++
control|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"0,"
argument_list|)
expr_stmt|;
comment|/* event 0 */
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"},\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|e
operator|=
literal|0
init|;
name|e
operator|<
name|Nevents
condition|;
name|e
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" {"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|Nstates
condition|;
name|s
operator|++
control|)
block|{
specifier|register
name|struct
name|Predicate
modifier|*
name|xyz
init|=
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
decl_stmt|;
comment|/* this kludge is to avoid a lint msg. concerning 			 * loss of bits  			 */
if|if
condition|(
name|xyz
operator|==
operator|(
expr|struct
name|Predicate
operator|*
operator|)
operator|(
operator|-
literal|1
operator|)
condition|)
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"-1,"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"0x%x,"
argument_list|,
name|Predlist
index|[
operator|(
name|e
operator|<<
name|Eventshift
operator|)
operator|+
name|s
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|" },\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"};"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|LINT
end_endif

begin_function
name|char
modifier|*
name|stash
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|char
modifier|*
name|c
decl_stmt|;
comment|/* grot */
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|c
operator|=
name|Malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
name|c
operator|=
endif|#
directive|endif
endif|LINT
name|strcpy
argument_list|(
name|c
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|z
argument_list|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"stash %s at 0x%x\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_macro
name|dump_pentry
argument_list|(
argument|event
argument_list|,
argument|state
argument_list|)
end_macro

begin_decl_stmt
name|int
name|event
decl_stmt|,
name|state
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|Predicate
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|q
decl_stmt|;
for|for
control|(
operator|(
operator|(
name|q
operator|=
operator|&
name|Predlist
index|[
operator|(
name|event
operator|<<
name|Eventshift
operator|)
operator|+
name|state
index|]
operator|)
operator|,
operator|(
name|p
operator|=
name|Predlist
index|[
operator|(
name|event
operator|<<
name|Eventshift
operator|)
operator|+
name|state
index|]
operator|)
operator|)
init|;
name|p
operator|!=
operator|(
expr|struct
name|Predicate
operator|*
operator|)
literal|0
condition|;
name|p
operator|=
name|p
operator|->
name|p_next
control|)
block|{
ifndef|#
directive|ifndef
name|LINT
name|IFDEBUG
argument_list|(
argument|a
argument_list|)
name|fprintf
argument_list|(
name|OUT
argument_list|,
literal|"dump_pentry for event 0x%x, state 0x%x is 0x%x\n"
argument_list|,
name|event
argument_list|,
name|state
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ENDDEBUG
endif|#
directive|endif
endif|LINT
name|q
init|=
operator|&
name|p
operator|->
name|p_next
decl_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|notdef
end_endif

end_unit

