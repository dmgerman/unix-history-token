begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/xebec/Attic/llparse.c,v $ */
end_comment

begin_comment
comment|/*  * ************************* NOTICE *******************************  * This code is in the public domain.  It cannot be copyrighted.  * This ll parser was originally written by Keith Thompson for the  * University of Wisconsin Crystal project.  * It was based on an FMQ lr parser written by Jon Mauney at the  * University of Wisconsin.  * It was subsequently modified very slightly by Nancy Hall at the  * University of Wisconsin for the Crystal project.  * ****************************************************************  */
end_comment

begin_include
include|#
directive|include
file|"xebec.h"
end_include

begin_include
include|#
directive|include
file|"llparse.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"debug.h"
end_include

begin_define
define|#
directive|define
name|LLMINACTION
value|-LLINF
end_define

begin_decl_stmt
name|short
name|llparsestack
index|[
name|STACKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|llstackptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LLtoken
name|lltoken
decl_stmt|;
end_decl_stmt

begin_macro
name|llparse
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|havetoken
operator|=
name|FALSE
expr_stmt|;
specifier|register
name|sym
expr_stmt|;
specifier|register
name|LLtoken
modifier|*
name|t
init|=
operator|&
name|lltoken
decl_stmt|;
specifier|register
name|parseaction
expr_stmt|;
specifier|register
name|accepted
operator|=
name|FALSE
expr_stmt|;
name|llpushprod
argument_list|(
name|llnprods
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* $$$ ::=<start symbol>  */
do|do
block|{
name|sym
operator|=
name|llparsestack
index|[
name|llstackptr
index|]
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llparse() top of loop, llstackptr=%d, sym=%d\n"
argument_list|,
name|llstackptr
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
comment|/* action symbol */
if|if
condition|(
name|sym
operator|<=
name|LLMINACTION
condition|)
block|{
for|for
control|(
init|;
name|sym
operator|<=
name|LLMINACTION
condition|;
name|sym
operator|++
control|)
block|{
name|llaction
argument_list|(
literal|1
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* calls llfinprod */
block|}
name|llstackptr
operator|--
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|llaction
argument_list|(
operator|-
name|sym
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|llstackptr
operator|--
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|sym
operator|<
name|llnterms
condition|)
block|{
comment|/* it's a terminal symbol */
if|if
condition|(
operator|!
name|havetoken
condition|)
block|{
name|llgettoken
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|havetoken
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|==
name|t
operator|->
name|llterm
condition|)
block|{
name|llpushattr
argument_list|(
name|t
operator|->
name|llattrib
argument_list|)
expr_stmt|;
name|llaccept
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|llstackptr
operator|--
expr_stmt|;
comment|/* pop terminal */
if|if
condition|(
name|t
operator|->
name|llterm
operator|==
name|llnterms
operator|-
literal|1
condition|)
block|{
comment|/* end symbol $$$ */
name|accepted
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|havetoken
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|llparsererror
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* wrong terminal on input */
name|havetoken
operator|=
name|FALSE
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* non terminal */
if|if
condition|(
operator|!
name|havetoken
condition|)
block|{
name|llgettoken
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|havetoken
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* consult parse table  for new production */
name|parseaction
operator|=
name|llfindaction
argument_list|(
name|sym
argument_list|,
name|t
operator|->
name|llterm
argument_list|)
expr_stmt|;
if|if
condition|(
name|parseaction
operator|==
literal|0
condition|)
block|{
comment|/* error entry */
name|llparsererror
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|havetoken
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|llepsilon
index|[
name|parseaction
index|]
condition|)
block|{
comment|/* epsilon production */
if|if
condition|(
name|llepsilonok
argument_list|(
name|t
operator|->
name|llterm
argument_list|)
condition|)
block|{
name|llstackptr
operator|--
expr_stmt|;
comment|/* pop nonterminal */
name|llpushprod
argument_list|(
name|parseaction
argument_list|)
expr_stmt|;
comment|/* push rhs of production */
block|}
else|else
block|{
name|llparsererror
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|havetoken
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
else|else
block|{
name|llstackptr
operator|--
expr_stmt|;
comment|/* pop nonterminal */
name|llpushprod
argument_list|(
name|parseaction
argument_list|)
expr_stmt|;
comment|/* push rhs of production */
block|}
block|}
do|while
condition|(
operator|!
name|accepted
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|llpushprod
argument_list|(
argument|prod
argument_list|)
end_macro

begin_comment
comment|/* recognize production prod - push rhs on stack */
end_comment

begin_decl_stmt
name|short
name|prod
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|start
expr_stmt|;
specifier|register
name|length
expr_stmt|;
specifier|register
name|count
expr_stmt|;
name|start
operator|=
name|llprodindex
index|[
name|prod
index|]
operator|.
name|llprodstart
expr_stmt|;
name|length
operator|=
name|llprodindex
index|[
name|prod
index|]
operator|.
name|llprodlength
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llpushprod(%d) llstackptr=0x%x(%d), length = 0x%x(%d)\n"
argument_list|,
name|prod
argument_list|,
name|llstackptr
argument_list|,
name|llstackptr
argument_list|,
name|length
argument_list|,
name|length
argument_list|)
expr_stmt|;
comment|/* 		dump_parse_stack(); 		*/
name|ENDDEBUG
if|if
condition|(
name|llstackptr
operator|+
name|length
operator|>=
name|STACKSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Parse stack overflow. llstackptr=0x%x, length=0x%x\n"
argument_list|,
name|llstackptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|llsetattr
argument_list|(
name|llprodindex
index|[
name|prod
index|]
operator|.
name|llprodtlen
argument_list|)
expr_stmt|;
comment|/* put a marker on the stack to mark beginning of production */
if|if
condition|(
name|llparsestack
index|[
name|llstackptr
index|]
operator|<=
name|LLMINACTION
condition|)
block|{
operator|(
name|llparsestack
index|[
name|llstackptr
index|]
operator|)
operator|--
expr_stmt|;
comment|/* if there's already one there, don't 								put another on; just let it represent all of 								the adjacent markers */
block|}
else|else
block|{
name|llstackptr
operator|++
expr_stmt|;
name|llparsestack
index|[
name|llstackptr
index|]
operator|=
name|LLMINACTION
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|length
condition|;
name|count
operator|++
control|)
block|{
name|llstackptr
operator|++
expr_stmt|;
name|llparsestack
index|[
name|llstackptr
index|]
operator|=
name|llproductions
index|[
name|start
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
name|llstackptr
operator|>
name|STACKSIZE
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PARSE STACK OVERFLOW! \n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|llepsilonok
argument_list|(
argument|term
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|ptr
expr_stmt|;
specifier|register
name|sym
expr_stmt|;
specifier|register
name|pact
expr_stmt|;
specifier|register
name|nomore
expr_stmt|;
specifier|register
name|rval
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llepsilonok() enter\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|rval
init|=
name|TRUE
decl_stmt|;
name|ptr
operator|=
name|llstackptr
expr_stmt|;
do|do
block|{
name|sym
operator|=
name|llparsestack
index|[
name|ptr
index|]
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
name|ptr
operator|--
expr_stmt|;
name|nomore
operator|=
name|ptr
operator|==
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sym
operator|<
name|llnterms
condition|)
block|{
name|nomore
operator|=
name|TRUE
expr_stmt|;
name|rval
operator|=
name|sym
operator|==
name|term
expr_stmt|;
continue|continue;
block|}
name|pact
operator|=
name|llfindaction
argument_list|(
name|sym
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|pact
operator|==
literal|0
condition|)
block|{
name|nomore
operator|=
name|TRUE
expr_stmt|;
name|rval
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|llepsilon
index|[
name|pact
index|]
operator|==
name|TRUE
condition|)
block|{
name|ptr
operator|--
expr_stmt|;
name|nomore
operator|=
name|ptr
operator|==
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nomore
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|nomore
condition|)
do|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_function
name|short
name|llfindaction
parameter_list|(
name|sym
parameter_list|,
name|term
parameter_list|)
block|{
specifier|register
name|index
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llfindaction(sym=%d, term=%d) enter \n"
argument_list|,
name|sym
argument_list|,
name|term
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|index
init|=
name|llparseindex
index|[
name|sym
index|]
decl_stmt|;
while|while
condition|(
name|llparsetable
index|[
name|index
index|]
operator|.
name|llterm
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|llparsetable
index|[
name|index
index|]
operator|.
name|llterm
operator|==
name|term
condition|)
block|{
return|return
operator|(
name|llparsetable
index|[
name|index
index|]
operator|.
name|llprod
operator|)
return|;
block|}
name|index
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|llparsererror
argument_list|(
argument|token
argument_list|)
end_macro

begin_decl_stmt
name|LLtoken
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"llparsererror() enter\n"
argument_list|)
expr_stmt|;
name|prt_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Syntax error: "
argument_list|)
decl_stmt|;
name|prt_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|dump_buffer
argument_list|()
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|llgettoken
argument_list|(
argument|token
argument_list|)
end_macro

begin_decl_stmt
name|LLtoken
modifier|*
name|token
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|llscan
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|token
operator|->
name|llstate
operator|=
name|NORMAL
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llgettoken(): "
argument_list|)
expr_stmt|;
name|prt_token
argument_list|(
name|token
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_comment
comment|/******************************************************************************  	Attribute support routines  ******************************************************************************/
end_comment

begin_comment
comment|/* **	attribute stack ** **	AttrStack =	stack of record **				values : array of values; **				ptr	: index; **	end; ** */
end_comment

begin_decl_stmt
name|LLattrib
name|llattributes
index|[
name|LLMAXATTR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|llattrtop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|llattr
name|llattrdesc
index|[
name|LLMAXDESC
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lldescindex
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_macro
name|llsetattr
argument_list|(
argument|n
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|llattr
modifier|*
name|ptr
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llsetattr(%d) enter\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|lldescindex
operator|>=
name|LLMAXDESC
condition|)
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"llattribute stack overflow: desc\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"lldescindex=0x%x, llattrtop=0x%x\n"
argument_list|,
name|lldescindex
argument_list|,
name|llattrtop
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
operator|&
name|llattrdesc
index|[
name|lldescindex
index|]
expr_stmt|;
name|ptr
operator|->
name|llabase
operator|=
operator|&
name|llattributes
index|[
name|llattrtop
index|]
expr_stmt|;
name|ptr
operator|->
name|lloldtop
operator|=
operator|++
name|llattrtop
expr_stmt|;
name|ptr
operator|->
name|llaindex
operator|=
literal|1
expr_stmt|;
name|ptr
operator|->
name|llacnt
operator|=
name|n
operator|+
literal|1
expr_stmt|;
comment|/* the lhs ALWAYS uses an attr; it remains on the 						stack when the production is recognized */
name|lldescindex
operator|++
expr_stmt|;
block|}
end_block

begin_macro
name|llpushattr
argument_list|(
argument|attr
argument_list|)
end_macro

begin_decl_stmt
name|LLattrib
name|attr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|llattr
modifier|*
name|a
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llpushattr() enter\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|llattrtop
operator|+
literal|1
operator|>
name|LLMAXATTR
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ATTRIBUTE STACK OVERFLOW!\n"
argument_list|)
expr_stmt|;
name|Exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|a
operator|=
operator|&
name|llattrdesc
index|[
name|lldescindex
operator|-
literal|1
index|]
expr_stmt|;
name|llattributes
index|[
name|llattrtop
operator|++
index|]
operator|=
name|attr
expr_stmt|;
name|a
operator|->
name|llaindex
operator|++
expr_stmt|;
comment|/* inc count of attrs on the stack for this prod */
block|}
end_block

begin_macro
name|llfinprod
argument_list|()
end_macro

begin_block
block|{
name|IFDEBUG
argument_list|(
argument|L
argument_list|)
name|printf
argument_list|(
literal|"llfinprod() enter\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|lldescindex
operator|--
expr_stmt|;
name|llattrtop
operator|=
name|llattrdesc
index|[
name|lldescindex
index|]
operator|.
name|lloldtop
expr_stmt|;
name|llattrdesc
index|[
name|lldescindex
operator|-
literal|1
index|]
operator|.
name|llaindex
operator|++
expr_stmt|;
comment|/* lhs-of-prod.attr stays on 		the stack; it is now one of the rhs attrs of the now-top production 		on the stack */
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|LINT
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|dump_parse_stack
argument_list|()
end_macro

begin_block
block|{
name|int
name|ind
decl_stmt|;
name|printf
argument_list|(
literal|"PARSE STACK:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|ind
operator|=
name|llstackptr
init|;
name|ind
operator|>=
literal|0
condition|;
name|ind
operator|--
control|)
block|{
name|printf
argument_list|(
literal|"%d\t%d\t%s\n"
argument_list|,
name|ind
argument_list|,
name|llparsestack
index|[
name|ind
index|]
argument_list|,
name|llparsestack
index|[
name|ind
index|]
operator|<
literal|0
condition|?
literal|"Action symbol"
else|:
name|llstrings
index|[
name|llparsestack
index|[
name|ind
index|]
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|DEBUG
end_endif

begin_endif
endif|#
directive|endif
endif|LINT
end_endif

begin_macro
name|prt_token
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|LLtoken
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"t at 0x%x\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"t->llterm=0x%x\n"
argument_list|,
name|t
operator|->
name|llterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"TOK: %s\n"
argument_list|,
name|llstrings
index|[
name|t
operator|->
name|llterm
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LINT
comment|/* to make lint shut up */
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|""
argument_list|,
name|llnterms
argument_list|,
name|llnsyms
argument_list|,
name|llnprods
argument_list|,
name|llinfinite
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LINT
block|}
end_block

end_unit

