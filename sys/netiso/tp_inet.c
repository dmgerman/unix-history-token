begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_inet.c	8.1 (Berkeley) 6/10/93  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  * $Header: tp_inet.c,v 5.3 88/11/18 17:27:29 nhall Exp $   * $Source: /usr/argo/sys/netiso/RCS/tp_inet.c,v $  *  * Here is where you find the inet-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto   * (see tp_pcb.c).   * The routines here are:  * 	in_getsufx: gets transport suffix out of an inpcb structure.  * 	in_putsufx: put transport suffix into an inpcb structure.  *	in_putnetaddr: put a whole net addr into an inpcb.  *	in_getnetaddr: get a whole net addr from an inpcb.  *	in_cmpnetaddr: compare a whole net addr from an isopcb.  *	in_recycle_suffix: clear suffix for reuse in inpcb  *	tpip_mtu: figure out what size tpdu to use  *	tpip_input: take a pkt from ip, strip off its ip header, give to tp  *	tpip_output_dg: package a pkt for ip given 2 addresses& some data  *	tpip_output: package a pkt for ip given an inpcb& some data  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_ip.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ISO
end_ifndef

begin_include
include|#
directive|include
file|<netiso/iso_chksum.c>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NAME:			in_getsufx()   * CALLED FROM: 	pr_usrreq() on PRU_BIND,   *					PRU_CONNECT, PRU_ACCEPT, and PRU_PEERADDR  *  * FUNCTION, ARGUMENTS, and RETURN VALUE:  * 	Get a transport suffix from an inpcb structure (inp).  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  *  * RETURNS:		internet port / transport suffix  *  			(CAST TO AN INT)  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_macro
name|in_getsufx
argument_list|(
argument|inp
argument_list|,
argument|lenp
argument_list|,
argument|data_out
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|lenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|*
name|lenp
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data_out
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
return|return;
case|case
name|TP_FOREIGN
case|:
operator|*
operator|(
name|u_short
operator|*
operator|)
name|data_out
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * NAME:		in_putsufx()  *  * CALLED FROM: tp_newsocket(); i.e., when a connection   *		is being established by an incoming CR_TPDU.  *  * FUNCTION, ARGUMENTS:  * 	Put a transport suffix (found in name) into an inpcb structure (inp).  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  *  * RETURNS:		Nada  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|in_putsufx
parameter_list|(
name|inp
parameter_list|,
name|sufxloc
parameter_list|,
name|sufxlen
parameter_list|,
name|which
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|caddr_t
name|sufxloc
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
if|if
condition|(
name|which
operator|==
name|TP_FOREIGN
condition|)
block|{
name|bcopy
argument_list|(
name|sufxloc
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_fport
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_fport
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * NAME:	in_recycle_tsuffix()	  *  * CALLED FROM:	tp.trans whenever we go into REFWAIT state.  *  * FUNCTION and ARGUMENT:  *	 Called when a ref is frozen, to allow the suffix to be reused.   * 	(inp) is the net level pcb.    *  * RETURNS:			Nada  *  * SIDE EFFECTS:	  *  * NOTES:	This really shouldn't have to be done in a NET level pcb   *	but... for the internet world that just the way it is done in BSD...  * 	The alternative is to have the port unusable until the reference  * 	timer goes off.  */
end_comment

begin_function
name|void
name|in_recycle_tsuffix
parameter_list|(
name|inp
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
block|{
name|inp
operator|->
name|inp_fport
operator|=
name|inp
operator|->
name|inp_lport
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME:	in_putnetaddr()  *  * CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from a struct sockaddr (name).  * 	into an inpcb (inp).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN  *  * RETURNS:		Nada  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|void
name|in_putnetaddr
parameter_list|(
name|inp
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_laddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* won't work if the dst address (name) is INADDR_ANY */
break|break;
case|case
name|TP_FOREIGN
case|:
if|if
condition|(
name|name
operator|!=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
literal|0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|name
operator|->
name|sin_addr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_faddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * NAME:	in_putnetaddr()  *  * CALLED FROM:  * 	tp_input() when a connection is being established by an  * 	incoming CR_TPDU, and considered for interception.  *  * FUNCTION and ARGUMENTS:  * 	Compare a whole net addr from a struct sockaddr (name),  * 	with that implicitly stored in an inpcb (inp).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN  *  * RETURNS:		Nada  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_expr_stmt
name|in_cmpnetaddr
argument_list|(
name|inp
argument_list|,
name|name
argument_list|,
name|which
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|inp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|which
operator|==
name|TP_LOCAL
condition|)
block|{
if|if
condition|(
name|name
operator|->
name|sin_port
operator|&&
name|name
operator|->
name|sin_port
operator|!=
name|inp
operator|->
name|inp_lport
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|name
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|)
return|;
block|}
if|if
condition|(
name|name
operator|->
name|sin_port
operator|&&
name|name
operator|->
name|sin_port
operator|!=
name|inp
operator|->
name|inp_fport
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|name
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	in_getnetaddr()  *  * CALLED FROM:  *  pr_usrreq() PRU_SOCKADDR, PRU_ACCEPT, PRU_PEERADDR  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from an inpcb (inp) into  * 	an mbuf (name);  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN.  *  * RETURNS:		Nada  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|void
name|in_getnetaddr
parameter_list|(
name|inp
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|name
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|mtod
argument_list|(
name|name
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|sin
operator|->
name|sin_addr
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|sin
operator|->
name|sin_addr
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|name
operator|->
name|m_len
operator|=
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME: 	tpip_mtu()  *  * CALLED FROM:  *  tp_route_to() on incoming CR, CC, and pr_usrreq() for PRU_CONNECT  *  * FUNCTION, ARGUMENTS, and RETURN VALUE:  *  * Perform subnetwork dependent part of determining MTU information.  * It appears that setting a double pointer to the rtentry associated with  * the destination, and returning the header size for the network protocol  * suffices.  *   * SIDE EFFECTS:  * Sets tp_routep pointer in pcb.  *  * NOTES:  */
end_comment

begin_expr_stmt
name|tpip_mtu
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|inpcb
modifier|*
name|inp
init|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpip_mtu(tpcb)\n"
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tpip_mtu routing to addr 0x%x\n"
argument_list|,
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_routep
init|=
operator|&
operator|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|)
decl_stmt|;
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:	tpip_output()  *  * CALLED FROM:  tp_emit()  *  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that ip will accept it.  *  This means prepending space for the ip header and filling in a few  *  of the fields.  *  inp is the inpcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURNS:			  *  whatever (E*) is returned form the net layer output routine.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|int
name|tpip_output
parameter_list|(
name|inp
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
return|return
name|tpip_output_dg
argument_list|(
operator|&
name|inp
operator|->
name|inp_laddr
argument_list|,
operator|&
name|inp
operator|->
name|inp_faddr
argument_list|,
name|m0
argument_list|,
name|datalen
argument_list|,
operator|&
name|inp
operator|->
name|inp_route
argument_list|,
name|nochksum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	tpip_output_dg()  *  * CALLED FROM:  tp_error_emit()  *  * FUNCTION and ARGUMENTS:  *  This is a copy of tpip_output that takes the addresses  *  instead of a pcb.  It's used by the tp_error_emit, when we  *  don't have an in_pcb with which to call the normal output rtn.  *  * RETURNS:	 ENOBUFS or  whatever (E*) is   *	returned form the net layer output routine.  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|tpip_output_dg
parameter_list|(
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|ro
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|in_addr
modifier|*
name|laddr
decl_stmt|,
decl|*
name|faddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nochksum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tpip_output_dg  datalen 0x%x m0 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|MGETHDR
parameter_list|(
name|m
parameter_list|,
name|M_DONTWAIT
parameter_list|,
name|TPMT_IPHDR
parameter_list|)
function_decl|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
sizeof|sizeof
expr|*
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ip
operator|->
name|ip_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|datalen
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
comment|/* don't know why you need to set ttl; 		 * overlay doesn't even make this available 		 */
name|ip
operator|->
name|ip_src
operator|=
operator|*
name|laddr
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
operator|*
name|faddr
expr_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"tpip_output_dg before ip_output\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|ro
argument_list|,
name|IP_ALLOWBROADCAST
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tpip_output_dg after ip_output\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_send_drop
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * NAME:  tpip_input()  *  * CALLED FROM:  * 	ip's input routine, indirectly through the protosw.  *  * FUNCTION and ARGUMENTS:  * Take a packet (m) from ip, strip off the ip header and give it to tp  *  * RETURNS:  No return value.    *   * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|ProtoHook
name|tpip_input
parameter_list|(
name|m
parameter_list|,
name|iplen
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|iplen
decl_stmt|;
block|{
name|struct
name|sockaddr_in
name|src
decl_stmt|,
name|dst
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|,
name|hdrlen
decl_stmt|;
name|IncStat
argument_list|(
name|ts_pkt_rcvd
argument_list|)
expr_stmt|;
comment|/* 	 * IP layer has already pulled up the IP header, 	 * but the first byte after the IP header may not be there, 	 * e.g. if you came in via loopback, so you have to do an 	 * m_pullup to before you can even look to see how much you 	 * really need.  The good news is that m_pullup will round 	 * up to almost the next mbuf's worth. 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|iplen
operator|+
literal|1
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
goto|goto
name|discard
goto|;
name|CHANGE_MTYPE
argument_list|(
name|m
argument_list|,
name|TPMT_DATA
argument_list|)
expr_stmt|;
comment|/* 	 * Now pull up the whole tp header: 	 * Unfortunately, there may be IP options to skip past so we 	 * just fetch it as an unsigned char. 	 */
name|hdrlen
operator|=
name|iplen
operator|+
literal|1
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
name|iplen
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hdrlen
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_input, pullup 2!\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|discard
goto|;
block|}
block|}
comment|/*  	 * cannot use tp_inputprep() here 'cause you don't  	 * have quite the same situation 	 */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"after tpip_input both pullups"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/*  	 * m_pullup may have returned a different mbuf 	 */
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
comment|/* 	 * drop the ip header from the front of the mbuf 	 * this is necessary for the tp checksum 	 */
name|m
operator|->
name|m_len
operator|-=
name|iplen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|iplen
expr_stmt|;
name|src
operator|.
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
operator|(
name|ip
operator|->
name|ip_src
operator|)
expr_stmt|;
name|src
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
operator|(
name|ip
operator|->
name|ip_dst
operator|)
expr_stmt|;
name|dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tp_input
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
name|tpip_output_dg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|discard
label|:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpip_input DISCARD\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tpip_input DISCARD m"
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
name|m_freem
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|IncStat
argument_list|(
name|ts_recv_drop
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_function_decl
specifier|extern
name|void
name|tp_quench
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * NAME:	tpin_quench()  *  * CALLED FROM: tpip_ctlinput()  *  * FUNCTION and ARGUMENTS:  find the tpcb pointer and pass it to tp_quench  *  * RETURNS:	Nada  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|void
name|tpin_quench
parameter_list|(
name|inp
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
block|{
name|tp_quench
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|inp
operator|->
name|inp_socket
operator|->
name|so_pcb
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME:	tpip_ctlinput()  *  * CALLED FROM:  *  The network layer through the protosw table.  *  * FUNCTION and ARGUMENTS:  *	When clnp gets an ICMP msg this gets called.  *	It either returns an error status to the user or  *	causes all connections on this address to be aborted  *	by calling the appropriate xx_notify() routine.  *	(cmd) is the type of ICMP error.     * 	(sa) the address of the sender  *  * RETURNS:	 Nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|ProtoHook
name|tpip_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|sin
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
block|{
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
specifier|extern
name|struct
name|in_addr
name|zeroin_addr
decl_stmt|;
name|void
name|tp_quench
name|__P
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
name|void
name|tpin_abort
name|__P
argument_list|(
operator|(
expr|struct
name|inpcb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
operator|&&
name|sin
operator|->
name|sin_family
operator|!=
name|AF_IMPLINK
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH
case|:
name|in_pcbnotify
argument_list|(
operator|&
name|tp_inpcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
literal|0
argument_list|,
name|zeroin_addr
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|,
name|tp_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_ROUTEDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
name|in_pcbnotify
argument_list|(
operator|&
name|tp_inpcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
literal|0
argument_list|,
name|zeroin_addr
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|,
name|in_rtchange
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		case	PRC_MSGSIZE: 		case	PRC_UNREACH_HOST: 		case	PRC_UNREACH_PROTOCOL: 		case	PRC_UNREACH_PORT: 		case	PRC_UNREACH_NEEDFRAG: 		case	PRC_UNREACH_SRCFAIL: 		case	PRC_REDIRECT_NET: 		case	PRC_REDIRECT_HOST: 		case	PRC_REDIRECT_TOSNET: 		case	PRC_REDIRECT_TOSHOST: 		case	PRC_TIMXCEED_INTRANS: 		case	PRC_TIMXCEED_REASS: 		case	PRC_PARAMPROB: 		*/
name|in_pcbnotify
argument_list|(
operator|&
name|tp_inpcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
literal|0
argument_list|,
name|zeroin_addr
argument_list|,
literal|0
argument_list|,
name|cmd
argument_list|,
name|tpin_abort
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	tpin_abort()  *  * CALLED FROM:  *	xxx_notify() from tp_ctlinput() when  *  net level gets some ICMP-equiv. type event.  *  * FUNCTION and ARGUMENTS:  *  Cause the connection to be aborted with some sort of error  *  reason indicating that the network layer caused the abort.  *  Fakes an ER TPDU so we can go through the driver.  *  * RETURNS:	 Nothing  *  * SIDE EFFECTS:	  *  * NOTES:			  */
end_comment

begin_function
name|ProtoHook
name|tpin_abort
parameter_list|(
name|inp
parameter_list|)
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|ER_TPDU
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|ENETRESET
expr_stmt|;
operator|(
name|void
operator|)
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|inp
operator|->
name|inp_ppcb
argument_list|,
operator|&
name|e
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_expr_stmt
name|dump_inaddr
argument_list|(
name|addr
argument_list|)
specifier|register
expr|struct
name|sockaddr_in
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"INET: port 0x%x; addr 0x%x\n"
argument_list|,
name|addr
operator|->
name|sin_port
argument_list|,
name|addr
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGO_DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

end_unit

