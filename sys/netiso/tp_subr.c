begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_subr.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  *  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_subr.c,v $  *  * The main work of data transfer is done here.  * These routines are called from tp.trans.  * They include the routines that check the validity of acks and Xacks,  * (tp_goodack() and tp_goodXack() )  * take packets from socket buffers and send them (tp_send()),  * drop the data from the socket buffers (tp_sbdrop()),  * and put incoming packet data into socket buffers (tp_stash()).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_ip.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_meas.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_seq.h>
end_include

begin_decl_stmt
name|int
name|tp_emit
argument_list|()
decl_stmt|,
name|tp_sbdrop
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tprexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ticks
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|tp_send
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * CALLED FROM:  *	tp.trans, when an XAK arrives  * FUNCTION and ARGUMENTS:  * 	Determines if the sequence number (seq) from the XAK  * 	acks anything new.  If so, drop the appropriate tpdu  * 	from the XPD send queue.  * RETURN VALUE:  * 	Returns 1 if it did this, 0 if the ack caused no action.  */
end_comment

begin_function
name|int
name|tp_goodXack
parameter_list|(
name|tpcb
parameter_list|,
name|seq
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
block|{
name|IFTRACE
argument_list|(
argument|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTgotXack
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_Xuna
argument_list|,
name|tpcb
operator|->
name|tp_Xsndnxt
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|seq
operator|==
name|tpcb
operator|->
name|tp_Xuna
condition|)
block|{
name|tpcb
operator|->
name|tp_Xuna
operator|=
name|tpcb
operator|->
name|tp_Xsndnxt
expr_stmt|;
comment|/* DROP 1 packet from the Xsnd socket buf - just so happens 			 * that only one packet can be there at any time 			 * so drop the whole thing.  If you allow> 1 packet 			 * the socket buffer, then you'll have to keep 			 * track of how many characters went w/ each XPD tpdu, so this 			 * will get messier 			 */
name|IFDEBUG
argument_list|(
argument|D_XPD
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
argument_list|,
literal|"tp_goodXack Xsnd before sbdrop"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_XPD
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"goodXack: dropping cc "
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_cc
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
name|sbdroprecord
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_Xsnd
argument_list|)
decl_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_good_ack()  * FUNCTION and ARGUMENTS:  *  updates  *  smoothed average round trip time (*rtt)  *  roundtrip time variance (*rtv) - actually deviation, not variance  *  given the new value (diff)  * RETURN VALUE:  * void  */
end_comment

begin_function
name|void
name|tp_rtt_rtv
parameter_list|(
name|tpcb
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|int
name|old
init|=
name|tpcb
operator|->
name|tp_rtt
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|elapsed
init|=
name|ticks
operator|-
name|tpcb
operator|->
name|tp_rttemit
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rtt
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * rtt is the smoothed round trip time in machine clock ticks (hz). 		 * It is stored as a fixed point number, unscaled (unlike the tcp 		 * srtt).  The rationale here is that it is only significant to the 		 * nearest unit of slowtimo, which is at least 8 machine clock ticks 		 * so there is no need to scale.  The smoothing is done according 		 * to the same formula as TCP (rtt = rtt*7/8 + measured_rtt/8). 		 */
name|delta
operator|=
name|elapsed
operator|-
name|tpcb
operator|->
name|tp_rtt
expr_stmt|;
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_rtt
operator|+=
operator|(
name|delta
operator|>>
name|TP_RTT_ALPHA
operator|)
operator|)
operator|<=
literal|0
condition|)
name|tpcb
operator|->
name|tp_rtt
operator|=
literal|1
expr_stmt|;
comment|/* 		 * rtv is a smoothed accumulated mean difference, unscaled 		 * for reasons expressed above. 		 * It is smoothed with an alpha of .75, and the round trip timer 		 * will be set to rtt + 4*rtv, also as TCP does. 		 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_rtv
operator|+=
operator|(
operator|(
name|delta
operator|-
name|tpcb
operator|->
name|tp_rtv
operator|)
operator|>>
name|TP_RTV_ALPHA
operator|)
operator|)
operator|<=
literal|0
condition|)
name|tpcb
operator|->
name|tp_rtv
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No rtt measurement yet - use the unsmoothed rtt. 		 * Set the variance to half the rtt (so our first 		 * retransmit happens at 3*rtt) 		 */
name|tpcb
operator|->
name|tp_rtt
operator|=
name|elapsed
expr_stmt|;
name|tpcb
operator|->
name|tp_rtv
operator|=
name|elapsed
operator|>>
literal|1
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_rttemit
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_rxtshift
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Quoting TCP: "the retransmit should happen at rtt + 4 * rttvar. 	 * Because of the way we do the smoothing, srtt and rttvar 	 * will each average +1/2 tick of bias.  When we compute 	 * the retransmit timer, we want 1/2 tick of rounding and 	 * 1 extra tick because of +-1/2 tick uncertainty in the 	 * firing of the timer.  The bias will give us exactly the 	 * 1.5 tick we need.  But, because the bias is 	 * statistical, we have to test that we don't drop below 	 * the minimum feasible timer (which is 2 ticks)." 	 */
name|TP_RANGESET
argument_list|(
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
name|TP_REXMTVAL
argument_list|(
name|tpcb
argument_list|)
argument_list|,
name|tpcb
operator|->
name|tp_peer_acktime
argument_list|,
literal|128
comment|/* XXX */
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_RTT
argument_list|)
name|printf
argument_list|(
literal|"%s tpcb 0x%x, elapsed %d, delta %d, rtt %d, rtv %d, old %d\n"
argument_list|,
literal|"tp_rtt_rtv:"
argument_list|,
name|tpcb
argument_list|,
name|elapsed
argument_list|,
name|delta
argument_list|,
name|tpcb
operator|->
name|tp_rtt
argument_list|,
name|tpcb
operator|->
name|tp_rtv
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_rxtcur
init|=
name|tpcb
operator|->
name|tp_dt_ticks
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans when an AK arrives  * FUNCTION and ARGUMENTS:  * 	Given (cdt), the credit from the AK tpdu, and  *	(seq), the sequence number from the AK tpdu,  *  tp_goodack() determines if the AK acknowledges something in the send  * 	window, and if so, drops the appropriate packets from the retransmission  *  list, computes the round trip time, and updates the retransmission timer  *  based on the new smoothed round trip time.  * RETURN VALUE:  * 	Returns 1 if  * 	EITHER it actually acked something heretofore unacknowledged  * 	OR no news but the credit should be processed.  * 	If something heretofore unacked was acked with this sequence number,  * 	the appropriate tpdus are dropped from the retransmission control list,  * 	by calling tp_sbdrop().  * 	No need to see the tpdu itself.  */
end_comment

begin_function
name|int
name|tp_goodack
parameter_list|(
name|tpcb
parameter_list|,
name|cdt
parameter_list|,
name|seq
parameter_list|,
name|subseq
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|u_int
name|cdt
decl_stmt|;
specifier|register
name|SeqNum
name|seq
decl_stmt|;
name|u_int
name|subseq
decl_stmt|;
block|{
name|int
name|old_fcredit
decl_stmt|;
name|int
name|bang
init|=
literal|0
decl_stmt|;
comment|/* bang --> ack for something heretofore unacked */
name|u_int
name|bytes_acked
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"goodack tpcb 0x%x seq 0x%x cdt %d una 0x%x new 0x%x nxt 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|seq
argument_list|,
name|cdt
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_ACKRECV
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTgotack
argument_list|,
name|seq
argument_list|,
name|cdt
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|subseq
argument_list|)
decl_stmt|;
name|ENDTRACE
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_ack_rcvd
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
literal|0
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDPERF
if|if
condition|(
name|seq
operator|==
name|tpcb
operator|->
name|tp_snduna
condition|)
block|{
if|if
condition|(
name|subseq
operator|<
name|tpcb
operator|->
name|tp_r_subseq
operator|||
operator|(
name|subseq
operator|==
name|tpcb
operator|->
name|tp_r_subseq
operator|&&
name|cdt
operator|<=
name|tpcb
operator|->
name|tp_fcredit
operator|)
condition|)
block|{
name|discard_the_ack
label|:
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"goodack discard : tpcb 0x%x subseq %d r_subseq %d\n"
argument_list|,
name|tpcb
argument_list|,
name|subseq
argument_list|,
name|tpcb
operator|->
name|tp_r_subseq
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cdt
operator|==
name|tpcb
operator|->
name|tp_fcredit
comment|/*&& thus subseq> tpcb->tp_r_subseq */
condition|)
block|{
name|tpcb
operator|->
name|tp_r_subseq
operator|=
name|subseq
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|==
literal|0
condition|)
name|tpcb
operator|->
name|tp_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|tpcb
operator|->
name|tp_dupacks
operator|==
name|tprexmtthresh
condition|)
block|{
comment|/* partner went out of his way to signal with different 				   subsequences that he has the same lack of an expected 				   packet.  This may be an early indiciation of a loss */
name|SeqNum
name|onxt
init|=
name|tpcb
operator|->
name|tp_sndnxt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|onxt_m
init|=
name|tpcb
operator|->
name|tp_sndnxt_m
decl_stmt|;
name|u_int
name|win
init|=
name|min
argument_list|(
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
operator|/
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|)
operator|/
literal|2
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"%s tpcb 0x%x seq 0x%x rttseq 0x%x onxt 0x%x\n"
argument_list|,
literal|"goodack dupacks:"
argument_list|,
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_rttseq
argument_list|,
name|onxt
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|tpcb
operator|->
name|tp_ssthresh
operator|=
name|win
operator|*
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_rttemit
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|tpcb
operator|->
name|tp_snduna
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt_m
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
name|tp_send
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_ssthresh
operator|+
name|tpcb
operator|->
name|tp_dupacks
operator|*
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tpcb
argument_list|,
name|onxt
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|)
condition|)
block|{
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|onxt
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt_m
operator|=
name|onxt_m
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_dupacks
operator|>
name|tprexmtthresh
condition|)
block|{
name|tpcb
operator|->
name|tp_cong_win
operator|+=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|)
condition|)
goto|goto
name|discard_the_ack
goto|;
comment|/* 	 * If the congestion window was inflated to account 	 * for the other side's cached packets, retract it. 	 */
if|if
condition|(
name|tpcb
operator|->
name|tp_dupacks
operator|>
name|tprexmtthresh
operator|&&
name|tpcb
operator|->
name|tp_cong_win
operator|>
name|tpcb
operator|->
name|tp_ssthresh
condition|)
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_ssthresh
expr_stmt|;
name|tpcb
operator|->
name|tp_r_subseq
operator|=
name|subseq
expr_stmt|;
name|old_fcredit
operator|=
name|tpcb
operator|->
name|tp_fcredit
expr_stmt|;
name|tpcb
operator|->
name|tp_fcredit
operator|=
name|cdt
expr_stmt|;
if|if
condition|(
name|cdt
operator|>
name|tpcb
operator|->
name|tp_maxfcredit
condition|)
name|tpcb
operator|->
name|tp_maxfcredit
operator|=
name|cdt
expr_stmt|;
name|tpcb
operator|->
name|tp_dupacks
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN_SWINDOW
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|)
condition|)
block|{
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bytes_acked
operator|=
name|tp_sbdrop
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * If transmit timer is running and timed sequence 		 * number was acked, update smoothed round trip time. 		 * Since we now have an rtt measurement, cancel the 		 * timer backoff (cf., Phil Karn's retransmit alg.). 		 * Recompute the initial retransmit timer. 		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_rttemit
operator|&&
name|SEQ_GT
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_rttseq
argument_list|)
condition|)
name|tp_rtt_rtv
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
comment|/* 		 * If all outstanding data is acked, stop retransmit timer. 		 * If there is more data to be acked, restart retransmit 		 * timer, using current (possibly backed-off) value. 		 * OSI combines the keepalive and persistance functions. 		 * So, there is no persistance timer per se, to restart. 		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
condition|)
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
operator|(
name|seq
operator|==
name|tpcb
operator|->
name|tp_sndnew
operator|)
condition|?
literal|0
else|:
name|tpcb
operator|->
name|tp_rxtcur
expr_stmt|;
comment|/* 		 * When new data is acked, open the congestion window. 		 * If the window gives us less than ssthresh packets 		 * in flight, open exponentially (maxseg per packet). 		 * Otherwise open linearly: maxseg per window 		 * (maxseg^2 / cwnd per packet), plus a constant 		 * fraction of a packet (maxseg/8) to help larger windows 		 * open quickly enough. 		 */
block|{
name|u_int
name|cw
init|=
name|tpcb
operator|->
name|tp_cong_win
decl_stmt|,
name|incr
init|=
name|tpcb
operator|->
name|tp_l_tpdusize
decl_stmt|;
name|incr
operator|=
name|min
argument_list|(
name|incr
argument_list|,
name|bytes_acked
argument_list|)
expr_stmt|;
if|if
condition|(
name|cw
operator|>
name|tpcb
operator|->
name|tp_ssthresh
condition|)
name|incr
operator|=
name|incr
operator|*
name|incr
operator|/
name|cw
operator|+
name|incr
operator|/
literal|8
expr_stmt|;
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|min
argument_list|(
name|cw
operator|+
name|incr
argument_list|,
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_snduna
operator|=
name|seq
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|seq
argument_list|)
condition|)
block|{
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|seq
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt_m
operator|=
literal|0
expr_stmt|;
block|}
name|bang
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cdt
operator|!=
literal|0
operator|&&
name|old_fcredit
operator|==
literal|0
condition|)
block|{
name|tpcb
operator|->
name|tp_sendfcc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cdt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|old_fcredit
operator|!=
literal|0
condition|)
name|IncStat
argument_list|(
name|ts_zfcdt
argument_list|)
expr_stmt|;
comment|/* The following might mean that the window shrunk */
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
condition|)
block|{
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_sendack
index|]
operator|=
name|tpcb
operator|->
name|tp_dt_ticks
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_sndnxt
operator|!=
name|tpcb
operator|->
name|tp_snduna
condition|)
block|{
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|tpcb
operator|->
name|tp_snduna
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt_m
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|tpcb
operator|->
name|tp_fcredit
operator|=
name|cdt
expr_stmt|;
name|bang
operator||=
operator|(
name|old_fcredit
operator|<
name|cdt
operator|)
expr_stmt|;
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"goodack returns 0x%x, cdt 0x%x ocdt 0x%x cwin 0x%x\n"
argument_list|,
name|bang
argument_list|,
name|cdt
argument_list|,
name|old_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* if (bang) XXXXX Very bad to remove this test, but somethings broken */
name|tp_send
argument_list|(
name|tpcb
argument_list|)
decl_stmt|;
return|return
operator|(
name|bang
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_goodack()  * FUNCTION and ARGUMENTS:  *  drops everything up TO but not INCLUDING seq # (seq)  *  from the retransmission queue.  */
end_comment

begin_expr_stmt
name|tp_sbdrop
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SeqNum
name|seq
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|seq
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|)
decl_stmt|;
name|int
name|oldcc
init|=
name|sb
operator|->
name|sb_cc
decl_stmt|,
name|oldi
init|=
name|i
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|tpcb
operator|->
name|tp_seqhalf
condition|)
name|printf
argument_list|(
literal|"tp_spdropping too much -- should panic"
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|sbdroprecord
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"tp_sbdroping %d pkts %d bytes on %x at 0x%x\n"
argument_list|,
name|oldi
argument_list|,
name|oldcc
operator|-
name|sb
operator|->
name|sb_cc
argument_list|,
name|tpcb
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_NOTIFY
condition|)
name|sowwakeup
argument_list|(
name|tpcb
operator|->
name|tp_sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldcc
operator|-
name|sb
operator|->
name|sb_cc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	tp.trans on user send request, arrival of AK and arrival of XAK  * FUNCTION and ARGUMENTS:  * 	Emits tpdus starting at sequence number (tpcb->tp_sndnxt).  * 	Emits until a) runs out of data, or  b) runs into an XPD mark, or  * 			c) it hits seq number (highseq) limited by cong or credit.  *  * 	If you want XPD to buffer> 1 du per socket buffer, you can  * 	modifiy this to issue XPD tpdus also, but then it'll have  * 	to take some argument(s) to distinguish between the type of DU to  * 	hand tp_emit.  *  * 	When something is sent for the first time, its time-of-send  * 	is stashed (in system clock ticks rather than pf_slowtimo ticks).  *  When the ack arrives, the smoothed round-trip time is figured  *  using this value.  */
end_comment

begin_function
name|void
name|tp_send
parameter_list|(
name|tpcb
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
init|=
literal|0
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
decl_stmt|;
name|unsigned
name|int
name|eotsdu
init|=
literal|0
decl_stmt|;
name|SeqNum
name|highseq
decl_stmt|,
name|checkseq
decl_stmt|;
name|int
name|idle
decl_stmt|,
name|idleticks
decl_stmt|,
name|off
decl_stmt|,
name|cong_win
decl_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
name|int
name|send_start_time
init|=
name|ticks
decl_stmt|;
name|SeqNum
name|oldnxt
init|=
name|tpcb
operator|->
name|tp_sndnxt
decl_stmt|;
endif|#
directive|endif
comment|/* TP_PERF_MEAS */
name|idle
operator|=
operator|(
name|tpcb
operator|->
name|tp_snduna
operator|==
name|tpcb
operator|->
name|tp_sndnew
operator|)
expr_stmt|;
if|if
condition|(
name|idle
condition|)
block|{
name|idleticks
operator|=
name|tpcb
operator|->
name|tp_inact_ticks
operator|-
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_inact
index|]
expr_stmt|;
if|if
condition|(
name|idleticks
operator|>
name|tpcb
operator|->
name|tp_dt_ticks
condition|)
comment|/* 			 * We have been idle for "a while" and no acks are 			 * expected to clock out any data we send -- 			 * slow start to get ack "clock" running again. 			 */
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
block|}
name|cong_win
operator|=
name|tpcb
operator|->
name|tp_cong_win
expr_stmt|;
name|highseq
operator|=
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
operator|+
name|tpcb
operator|->
name|tp_snduna
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_Xsnd
operator|.
name|sb_mb
condition|)
name|highseq
operator|=
name|SEQ_MIN
argument_list|(
name|tpcb
argument_list|,
name|highseq
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"tp_send enter tpcb 0x%x nxt 0x%x win %d high 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|cong_win
argument_list|,
name|highseq
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_DATA
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send sndnew snduna"
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send tpcb->tp_sndnxt win fcredit congwin"
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|cong_win
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFTRACE
argument_list|(
name|D_DATA
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send 2 nxt high fcredit congwin"
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|highseq
argument_list|,
name|tpcb
operator|->
name|tp_fcredit
argument_list|,
name|cong_win
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_sndnxt_m
condition|)
name|m
operator|=
name|tpcb
operator|->
name|tp_sndnxt_m
expr_stmt|;
else|else
block|{
name|off
operator|=
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|&&
name|off
operator|>
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|off
operator|--
expr_stmt|;
block|}
name|send
label|:
comment|/* 	 * Avoid silly window syndrome here . . . figure out how! 	 */
name|checkseq
operator|=
name|tpcb
operator|->
name|tp_sndnum
expr_stmt|;
if|if
condition|(
name|idle
operator|&&
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|,
name|highseq
argument_list|)
condition|)
name|checkseq
operator|=
name|highseq
expr_stmt|;
comment|/* i.e. DON'T retain highest assigned packet */
while|while
condition|(
operator|(
name|SEQ_LT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|highseq
argument_list|)
operator|)
operator|&&
name|m
operator|&&
name|cong_win
operator|>
literal|0
condition|)
block|{
name|eotsdu
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
operator|)
operator|!=
literal|0
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_sndnxt
operator|==
name|checkseq
operator|&&
name|eotsdu
operator|==
literal|0
operator|&&
name|len
operator|<
operator|(
name|tpcb
operator|->
name|tp_l_tpdusize
operator|/
literal|2
operator|)
condition|)
break|break;
comment|/* Nagle . . . . . */
name|cong_win
operator|-=
name|len
expr_stmt|;
comment|/* make a copy - mb goes into the retransmission list 		 * while m gets emitted.  m_copy won't copy a zero-length mbuf. 		 */
name|mb
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m_copy
argument_list|(
name|mb
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
break|break;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send mcopy nxt high eotsdu len"
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|highseq
argument_list|,
name|eotsdu
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"tp_sending tpcb 0x%x nxt 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|)
decl_stmt|;
name|ENDDEBUG
comment|/* when headers are precomputed, may need to fill 			   in checksum here */
if|if
condition|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|=
name|tp_emit
argument_list|(
name|DT_TPDU_type
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|eotsdu
argument_list|,
name|m
argument_list|)
condition|)
block|{
comment|/* error */
break|break;
block|}
name|m
operator|=
name|mb
operator|->
name|m_nextpkt
expr_stmt|;
name|tpcb
operator|->
name|tp_sndnxt_m
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_sndnxt
operator|==
name|tpcb
operator|->
name|tp_sndnew
condition|)
block|{
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|)
expr_stmt|;
comment|/* 			 * Time this transmission if not a retransmission and 			 * not currently timing anything. 			 */
if|if
condition|(
name|tpcb
operator|->
name|tp_rttemit
operator|==
literal|0
condition|)
block|{
name|tpcb
operator|->
name|tp_rttemit
operator|=
name|ticks
expr_stmt|;
name|tpcb
operator|->
name|tp_rttseq
operator|=
name|tpcb
operator|->
name|tp_sndnxt
expr_stmt|;
block|}
name|tpcb
operator|->
name|tp_sndnxt
operator|=
name|tpcb
operator|->
name|tp_sndnew
expr_stmt|;
block|}
else|else
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|)
expr_stmt|;
comment|/* 		 * Set retransmit timer if not currently set. 		 * Initial value for retransmit timer is smoothed 		 * round-trip time + 2 * round-trip time variance. 		 * Initialize shift counter which is used for backoff 		 * of retransmit time. 		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|==
literal|0
operator|&&
name|tpcb
operator|->
name|tp_class
operator|!=
name|TP_CLASS_0
condition|)
block|{
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_data_retrans
index|]
operator|=
name|tpcb
operator|->
name|tp_dt_ticks
expr_stmt|;
name|tpcb
operator|->
name|tp_timer
index|[
name|TM_sendack
index|]
operator|=
name|tpcb
operator|->
name|tp_keepalive_ticks
expr_stmt|;
name|tpcb
operator|->
name|tp_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
condition|)
name|tpcb
operator|->
name|tp_oktonagle
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
block|{
specifier|register
name|int
name|npkts
decl_stmt|;
name|int
name|elapsed
init|=
name|ticks
operator|-
name|send_start_time
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|npkts
operator|=
name|SEQ_SUB
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|oldnxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
literal|0
condition|)
name|tpcb
operator|->
name|tp_Nwindow
operator|++
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
name|TP_PM_MAX
condition|)
name|npkts
operator|=
name|TP_PM_MAX
expr_stmt|;
name|t
operator|=
operator|&
operator|(
name|tpcb
operator|->
name|tp_p_meas
operator|->
name|tps_sendtime
index|[
name|npkts
index|]
operator|)
expr_stmt|;
operator|*
name|t
operator|+=
operator|(
name|t
operator|-
name|elapsed
operator|)
operator|>>
name|TP_RTT_ALPHA
expr_stmt|;
if|if
condition|(
name|mb
operator|==
literal|0
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_win_lim_by_data
index|[
name|npkts
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_win_lim_by_cdt
index|[
name|npkts
index|]
argument_list|)
expr_stmt|;
comment|/* not true with congestion-window being used */
block|}
name|now
operator|.
name|tv_sec
operator|=
name|elapsed
operator|/
name|hz
expr_stmt|;
name|now
operator|.
name|tv_usec
operator|=
operator|(
name|elapsed
operator|-
operator|(
name|hz
operator|*
name|now
operator|.
name|tv_sec
operator|)
operator|)
operator|*
literal|1000000
operator|/
name|hz
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPsbsend
argument_list|,
operator|&
name|elapsed
argument_list|,
name|newseq
argument_list|,
name|tpcb
operator|->
name|tp_Nwindow
argument_list|,
name|npkts
argument_list|)
expr_stmt|;
block|}
name|ENDPERF
endif|#
directive|endif
comment|/* TP_PERF_MEAS */
name|IFTRACE
argument_list|(
name|D_DATA
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_send at end: new nxt eotsdu error"
argument_list|,
name|tpcb
operator|->
name|tp_sndnew
argument_list|,
name|tpcb
operator|->
name|tp_sndnxt
argument_list|,
name|eotsdu
argument_list|,
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_decl_stmt
name|int
name|TPNagleok
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|TPNagled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|tp_packetize
argument_list|(
name|tpcb
argument_list|,
name|m
argument_list|,
name|eotsdu
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eotsdu
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
decl_stmt|;
name|int
name|maxsize
init|=
name|tpcb
operator|->
name|tp_l_tpdusize
operator|-
name|tp_headersize
argument_list|(
name|DT_TPDU_type
argument_list|,
name|tpcb
argument_list|)
operator|-
operator|(
name|tpcb
operator|->
name|tp_use_checksum
condition|?
literal|4
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|totlen
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_split
parameter_list|()
function_decl|;
comment|/* 	 * Pre-packetize the data in the sockbuf 	 * according to negotiated mtu.  Do it here 	 * where we can safely wait for mbufs. 	 * 	 * This presumes knowledge of sockbuf conventions. 	 * TODO: allocate space for header and fill it in (once!). 	 */
name|IFDEBUG
argument_list|(
argument|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"SEND BF: maxsize %d totlen %d eotsdu %d sndnum 0x%x\n"
argument_list|,
name|maxsize
argument_list|,
name|totlen
argument_list|,
name|eotsdu
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_oktonagle
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|sb
operator|->
name|sb_mb
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tp_packetize"
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|->
name|m_act
condition|)
name|n
operator|=
name|n
operator|->
name|m_act
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|panic
argument_list|(
literal|"tp_packetize 2"
argument_list|)
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|+
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|maxsize
condition|)
block|{
comment|/* There is an unsent packet with space, combine data */
name|struct
name|mbuf
modifier|*
name|old_n
init|=
name|n
decl_stmt|;
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|totlen
expr_stmt|;
while|while
condition|(
name|n
operator|->
name|m_next
condition|)
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|sbcompress
argument_list|(
name|sb
argument_list|,
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|n
operator|=
name|old_n
expr_stmt|;
name|TPNagled
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
while|while
condition|(
name|m
condition|)
block|{
name|n
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|maxsize
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_split
argument_list|(
name|n
argument_list|,
name|maxsize
argument_list|,
name|M_WAIT
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tp_packetize"
argument_list|)
expr_stmt|;
block|}
else|else
name|m
operator|=
literal|0
expr_stmt|;
name|totlen
operator|-=
name|maxsize
expr_stmt|;
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|tpsbcheck
argument_list|(
name|tpcb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|eotsdu
condition|)
block|{
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
comment|/* XXX belongs at end */
name|tpcb
operator|->
name|tp_oktonagle
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SEQ_DEC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_oktonagle
operator|=
literal|1
expr_stmt|;
name|TPNagleok
operator|++
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"SEND out: oktonagle %d sndnum 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_oktonagle
argument_list|,
name|tpcb
operator|->
name|tp_sndnum
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * NAME: tp_stash()  * CALLED FROM:  *	tp.trans on arrival of a DT tpdu  * FUNCTION, ARGUMENTS, and RETURN VALUE:  * 	Returns 1 if  *		a) something new arrived and it's got eotsdu_reached bit on,  * 		b) this arrival was caused other out-of-sequence things to be  *    	accepted, or  * 		c) this arrival is the highest seq # for which we last gave credit  *   	(sender just sent a whole window)  *  In other words, returns 1 if tp should send an ack immediately, 0 if  *  the ack can wait a while.  *  * Note: this implementation no longer renegs on credit, (except  * when debugging option D_RENEG is on, for the purpose of testing  * ack subsequencing), so we don't  need to check for incoming tpdus  * being in a reneged portion of the window.  */
end_comment

begin_expr_stmt
name|tp_stash
argument_list|(
name|tpcb
argument_list|,
name|e
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|ack_reason
init|=
name|tpcb
operator|->
name|tp_ack_strat
operator|&
name|ACK_STRAT_EACH
decl_stmt|;
comment|/* 0--> delay acks until full window */
comment|/* 1--> ack each tpdu */
ifndef|#
directive|ifndef
name|lint
define|#
directive|define
name|E
value|e->ATTR(DT_TPDU)
else|#
directive|else
comment|/* lint */
define|#
directive|define
name|E
value|e->ev_union.EV_DT_TPDU
endif|#
directive|endif
comment|/* lint */
if|if
condition|(
name|E
operator|.
name|e_eot
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|E
operator|.
name|e_data
decl_stmt|;
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|n
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"stash: so_rcv before appending"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|E
operator|.
name|e_data
argument_list|,
literal|"stash: e_data before appending"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFPERF
argument_list|(
name|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
decl|+=
name|E
operator|.
name|e_datalen
decl_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_ll
argument_list|,
operator|&
name|e
operator|->
name|e_time
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
operator|(
name|u_int
operator|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
argument_list|,
operator|(
name|u_int
operator|)
name|E
operator|.
name|e_datalen
argument_list|)
expr_stmt|;
name|ENDPERF
if|if
condition|(
name|E
operator|.
name|e_seq
operator|==
name|tpcb
operator|->
name|tp_rcvnxt
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|printf
argument_list|(
literal|"stash EQ: seq 0x%x datalen 0x%x eot 0x%x\n"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|,
name|E
operator|.
name|e_eot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_STASH
parameter_list|)
function_decl|tptraceTPCB
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"stash EQ: seq len eot"
operator|,
function_decl|E.e_seq
operator|,
function_decl|E.e_datalen
operator|,
function_decl|E.e_eot
operator|,
function_decl|0
block|)
empty_stmt|;
name|ENDTRACE
name|SET_DELACK
parameter_list|(
name|tpcb
parameter_list|)
function_decl|;
name|sbappend
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
argument_list|,
name|E
operator|.
name|e_data
argument_list|)
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
expr_stmt|;
comment|/* 		 * move chains from the reassembly queue to the socket buffer 		 */
if|if
condition|(
name|tpcb
operator|->
name|tp_rsycnt
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mplim
decl_stmt|;
name|mp
operator|=
name|tpcb
operator|->
name|tp_rsyq
operator|+
operator|(
name|tpcb
operator|->
name|tp_rcvnxt
operator|%
name|tpcb
operator|->
name|tp_maxlcredit
operator|)
expr_stmt|;
name|mplim
operator|=
name|tpcb
operator|->
name|tp_rsyq
operator|+
name|tpcb
operator|->
name|tp_maxlcredit
expr_stmt|;
while|while
condition|(
name|tpcb
operator|->
name|tp_rsycnt
operator|&&
operator|*
name|mp
condition|)
block|{
name|sbappend
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_rsycnt
operator|--
expr_stmt|;
operator|*
name|mp
operator|=
literal|0
expr_stmt|;
name|SEQ_INC
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|)
expr_stmt|;
name|ack_reason
operator||=
name|ACK_REORDER
expr_stmt|;
if|if
condition|(
operator|++
name|mp
operator|==
name|mplim
condition|)
name|mp
operator|=
name|tpcb
operator|->
name|tp_rsyq
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
literal|"stash: so_rcv after appending"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_block

begin_else
else|else
block|{
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|SeqNum
name|uwe
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"stash Reseq: seq rcvnxt lcdt"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|tpcb
operator|->
name|tp_rsyq
operator|==
literal|0
condition|)
name|tp_rsyset
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|uwe
operator|=
name|SEQ
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
operator|+
name|tpcb
operator|->
name|tp_maxlcredit
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rsyq
operator|==
literal|0
operator|||
operator|!
name|IN_RWINDOW
argument_list|(
name|tpcb
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|,
name|uwe
argument_list|)
condition|)
block|{
name|ack_reason
operator|=
name|ACK_DONT
expr_stmt|;
name|m_freem
argument_list|(
name|E
operator|.
name|e_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|mp
operator|=
name|tpcb
operator|->
name|tp_rsyq
operator|+
operator|(
name|E
operator|.
name|e_seq
operator|%
name|tpcb
operator|->
name|tp_maxlcredit
operator|)
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|printf
argument_list|(
literal|"tp_stash - drop& ack\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* retransmission - drop it and force an ack */
name|IncStat
parameter_list|(
name|ts_dt_dup
parameter_list|)
function_decl|;
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_dup
argument_list|)
expr_stmt|;
name|ENDPERF
name|m_freem
parameter_list|(
name|E
operator|.
name|e_data
parameter_list|)
function_decl|;
name|ack_reason
operator||=
name|ACK_DUP
expr_stmt|;
block|}
else|else
block|{
operator|*
name|mp
operator|=
name|E
operator|.
name|e_data
expr_stmt|;
name|tpcb
operator|->
name|tp_rsycnt
operator|++
expr_stmt|;
name|ack_reason
operator|=
name|ACK_DONT
expr_stmt|;
block|}
block|}
end_else

begin_comment
comment|/* there were some comments of historical interest here. */
end_comment

begin_block
block|{
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|e_seq
operator|==
name|tpcb
operator|->
name|tp_sent_uwe
condition|)
name|ack_reason
operator||=
name|ACK_STRAT_FULLWIN
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"end of stash, eot, ack_reason, sent_uwe "
argument_list|,
name|E
operator|.
name|e_eot
argument_list|,
name|ack_reason
argument_list|,
name|tpcb
operator|->
name|tp_sent_uwe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|ack_reason
operator|==
name|ACK_DONT
condition|)
block|{
name|IncStat
argument_list|(
name|ts_ackreason
index|[
name|ACK_DONT
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
if|if
condition|(
name|ack_reason
operator|&
name|ACK_STRAT_EACH
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_strat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack_reason
operator|&
name|ACK_STRAT_FULLWIN
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_fullwin
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ack_reason
operator|&
name|ACK_REORDER
condition|)
block|{
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_n_ack_cuz_reorder
argument_list|)
expr_stmt|;
block|}
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_ack_sent
argument_list|,
literal|0
argument_list|,
name|SEQ_ADD
argument_list|(
name|tpcb
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDPERF
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* keep track of all reasons that apply */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|_ACK_NUM_REASONS_
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ack_reason
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|IncStat
argument_list|(
name|ts_ackreason
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
block|}
end_block

begin_comment
unit|}
comment|/*  * tp_rsyflush - drop all the packets on the reassembly queue.  * Do this when closing the socket, or when somebody has changed  * the space avaible in the receive socket (XXX).  */
end_comment

begin_expr_stmt
unit|tp_rsyflush
operator|(
name|tpcb
operator|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rsycnt
condition|)
block|{
for|for
control|(
name|mp
operator|==
name|tpcb
operator|->
name|tp_rsyq
operator|+
name|tpcb
operator|->
name|tp_maxlcredit
init|;
operator|--
name|mp
operator|>=
name|tpcb
operator|->
name|tp_rsyq
condition|;
control|)
if|if
condition|(
operator|*
name|mp
condition|)
block|{
name|tpcb
operator|->
name|tp_rsycnt
operator|--
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_rsycnt
condition|)
block|{
name|printf
argument_list|(
literal|"tp_rsyflush %x\n"
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_rsycnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_rsyq
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_rsyq
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|tp_rsyset
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
name|tpcb
operator|->
name|tp_sock
decl_stmt|;
name|int
name|maxcredit
init|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
literal|0xffff
else|:
literal|0xf
decl_stmt|;
name|int
name|old_credit
init|=
name|tpcb
operator|->
name|tp_maxlcredit
decl_stmt|;
name|caddr_t
name|rsyq
decl_stmt|;
name|tpcb
operator|->
name|tp_maxlcredit
operator|=
name|maxcredit
operator|=
name|min
argument_list|(
name|maxcredit
argument_list|,
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|+
name|tpcb
operator|->
name|tp_l_tpdusize
operator|)
operator|/
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_credit
operator|==
name|tpcb
operator|->
name|tp_maxlcredit
operator|&&
name|tpcb
operator|->
name|tp_rsyq
operator|!=
literal|0
condition|)
return|return;
name|maxcredit
operator|*=
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rsyq
condition|)
name|tp_rsyflush
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsyq
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|maxcredit
argument_list|,
name|M_PCB
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
name|bzero
argument_list|(
name|rsyq
argument_list|,
name|maxcredit
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_rsyq
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|rsyq
expr_stmt|;
block|}
end_block

begin_macro
name|tpsbcheck
argument_list|(
argument|tpcb
argument_list|,
argument|i
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|,
name|mbcnt
init|=
literal|0
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_snd
decl_stmt|;
for|for
control|(
name|n
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tpsbcheck nohdr"
argument_list|)
expr_stmt|;
name|pktlen
operator|=
name|len
operator|+
name|n
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
for|for
control|(
name|m
operator|=
name|n
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mbcnt
operator|+=
name|MSIZE
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
name|mbcnt
operator|+=
name|m
operator|->
name|m_ext
operator|.
name|ext_size
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|!=
name|pktlen
condition|)
block|{
name|printf
argument_list|(
literal|"test %d; len %d != pktlen %d on mbuf 0x%x\n"
argument_list|,
name|i
argument_list|,
name|len
argument_list|,
name|pktlen
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"tpsbcheck short"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|!=
name|sb
operator|->
name|sb_cc
operator|||
name|mbcnt
operator|!=
name|sb
operator|->
name|sb_mbcnt
condition|)
block|{
name|printf
argument_list|(
literal|"test %d: cc %d != %d || mbcnt %d != %d\n"
argument_list|,
name|i
argument_list|,
name|len
argument_list|,
name|sb
operator|->
name|sb_cc
argument_list|,
name|mbcnt
argument_list|,
name|sb
operator|->
name|sb_mbcnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"tpsbcheck"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

