begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)clnp_options.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/clnp_options.c,v $ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_comment
comment|/*  * FUNCTION:		clnp_update_srcrt  *  * PURPOSE:			Process src rt option accompanying a clnp datagram.  *						- bump src route ptr if src routing and  *							we appear current in src route list.  *  * RETURNS:			none  *  * SIDE EFFECTS:  *  * NOTES:			If source routing has been terminated, do nothing.  */
end_comment

begin_macro
name|clnp_update_srcrt
argument_list|(
argument|options
argument_list|,
argument|oidx
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to options mbuf */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to option index */
end_comment

begin_block
block|{
name|u_char
name|len
decl_stmt|;
comment|/* length of current address */
name|struct
name|iso_addr
name|isoa
decl_stmt|;
comment|/* copy current address into here */
if|if
condition|(
name|CLNPSRCRT_TERM
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_update_srcrt: src rt terminated\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return;
block|}
name|len
operator|=
name|CLNPSRCRT_CLEN
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|CLNPSRCRT_CADDR
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|isoa
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|isoa
operator|.
name|isoa_len
operator|=
name|len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_update_srcrt: current src rt: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|clnp_ours
argument_list|(
operator|&
name|isoa
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_update_srcrt: updating src rt\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* update pointer to next src route */
name|len
operator|++
expr_stmt|;
comment|/* count length byte too! */
name|CLNPSRCRT_OFF
argument_list|(
name|oidx
argument_list|,
name|options
argument_list|)
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_dooptions  *  * PURPOSE:			Process options accompanying a clnp datagram.  *					Processing includes  *						- log our address if recording route  *  * RETURNS:			none  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|clnp_dooptions
argument_list|(
argument|options
argument_list|,
argument|oidx
argument_list|,
argument|ifp
argument_list|,
argument|isoa
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to options mbuf */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to option index */
end_comment

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to interface pkt is leaving on */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to our address for this ifp */
end_comment

begin_block
block|{
comment|/* 	 *	If record route is specified, move all 	 *	existing records over, and insert the address of 	 *	interface passed 	 */
if|if
condition|(
name|oidx
operator|->
name|cni_recrtp
condition|)
block|{
name|char
modifier|*
name|opt
decl_stmt|;
comment|/* ptr to beginning of recrt option */
name|u_char
name|off
decl_stmt|;
comment|/* offset from opt of first free byte */
name|char
modifier|*
name|rec_start
decl_stmt|;
comment|/* beginning of new rt recorded */
name|opt
operator|=
name|CLNP_OFFTOOPT
argument_list|(
name|options
argument_list|,
name|oidx
operator|->
name|cni_recrtp
argument_list|)
expr_stmt|;
name|off
operator|=
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
expr_stmt|;
name|rec_start
operator|=
name|opt
operator|+
name|off
operator|-
literal|1
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_dooptions: record route: option x%x for %d bytes\n"
argument_list|,
name|opt
argument_list|,
name|oidx
operator|->
name|cni_recrt_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfree slot offset x%x\n"
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_dooptions: recording %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|isoa
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_dooptions: option dump:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|opt
argument_list|,
name|oidx
operator|->
name|cni_recrt_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* proceed only if recording has not been terminated */
if|if
condition|(
name|off
operator|!=
literal|0xff
condition|)
block|{
name|int
name|new_addrlen
init|=
name|isoa
operator|->
name|isoa_len
operator|+
literal|1
decl_stmt|;
comment|/* 			 *	if there is insufficient room to store the next address, 			 *	then terminate recording. Plus 1 on isoa_len is for the 			 *	length byte itself 			 */
if|if
condition|(
name|oidx
operator|->
name|cni_recrt_len
operator|-
operator|(
name|off
operator|-
literal|1
operator|)
operator|<
name|new_addrlen
condition|)
block|{
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|=
literal|0xff
expr_stmt|;
comment|/* terminate recording */
block|}
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_dooptions: new addr at x%x for %d\n"
argument_list|,
name|rec_start
argument_list|,
name|new_addrlen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
name|rec_start
argument_list|,
name|new_addrlen
argument_list|)
decl_stmt|;
comment|/* update offset field */
operator|*
operator|(
name|opt
operator|+
literal|1
operator|)
operator|+=
name|new_addrlen
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_dooptions: new option dump:\n"
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|opt
argument_list|,
name|oidx
operator|->
name|cni_recrt_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_set_opts  *  * PURPOSE:			Check the data mbuf passed for option sanity. If it is  *					ok, then set the options ptr to address the data mbuf.  *					If an options mbuf exists, free it. This implies that  *					any old options will be lost. If data is NULL, simply  *					free any old options.  *  * RETURNS:			unix error code  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|clnp_set_opts
argument_list|(
argument|options
argument_list|,
argument|data
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target for option information */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* source of option information */
end_comment

begin_block
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* error return value */
name|struct
name|clnp_optidx
name|dummy
decl_stmt|;
comment|/* dummy index - not used */
comment|/* 	 *	remove any existing options 	 */
if|if
condition|(
operator|*
name|options
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|options
argument_list|)
expr_stmt|;
operator|*
name|options
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|data
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 *	Insure that the options are reasonable. 		 * 		 *	Also, we do not support security, priority, 		 *	nor do we allow one to send an ER option 		 * 		 *	The QOS parameter is checked for the DECBIT. 		 */
if|if
condition|(
operator|(
name|clnp_opt_sanity
argument_list|(
operator|*
name|data
argument_list|,
name|mtod
argument_list|(
operator|*
name|data
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|(
operator|*
name|data
operator|)
operator|->
name|m_len
argument_list|,
operator|&
name|dummy
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|dummy
operator|.
name|cni_securep
operator|)
operator|||
operator|(
name|dummy
operator|.
name|cni_priorp
operator|)
operator|||
operator|(
name|dummy
operator|.
name|cni_er_reason
operator|!=
name|ER_INVALREAS
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|options
operator|=
operator|*
name|data
expr_stmt|;
operator|*
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* so caller won't free mbuf @ *data */
block|}
block|}
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		clnp_opt_sanity  *  * PURPOSE:			Check the options (beginning at opts for len bytes) for  *					sanity. In addition, fill in the option index structure  *					in with information about each option discovered.  *  * RETURNS:			success (options check out) - 0  *					failure - an ER pdu error code describing failure  *  * SIDE EFFECTS:  *  * NOTES:			Each pointer field of the option index is filled in with  *					the offset from the beginning of the mbuf data, not the  *					actual address.  */
end_comment

begin_macro
name|clnp_opt_sanity
argument_list|(
argument|m
argument_list|,
argument|opts
argument_list|,
argument|len
argument_list|,
argument|oidx
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mbuf options reside in */
end_comment

begin_decl_stmt
name|caddr_t
name|opts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to buffer containing options */
end_comment

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of buffer */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RETURN: filled in with option idx info */
end_comment

begin_block
block|{
name|u_char
name|opcode
decl_stmt|;
comment|/* code of particular option */
name|u_char
name|oplen
decl_stmt|;
comment|/* length of a particular option */
name|caddr_t
name|opts_end
decl_stmt|;
comment|/* ptr to end of options */
name|u_char
name|pad
init|=
literal|0
decl_stmt|,
name|secure
init|=
literal|0
decl_stmt|,
name|srcrt
init|=
literal|0
decl_stmt|,
name|recrt
init|=
literal|0
decl_stmt|,
name|qos
init|=
literal|0
decl_stmt|,
name|prior
init|=
literal|0
decl_stmt|;
comment|/* flags for catching duplicate options */
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: checking %d bytes of data:\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|opts
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* clear option index field if passed */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|oidx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_optidx
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 	 *	We need to indicate whether the ER option is present. This is done 	 *	by overloading the er_reason field to also indicate presense of 	 *	the option along with the option value. I would like ER_INVALREAS 	 *	to have value 0, but alas, 0 is a valid er reason... 	 */
name|oidx
operator|->
name|cni_er_reason
operator|=
name|ER_INVALREAS
expr_stmt|;
name|opts_end
operator|=
name|opts
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|opts
operator|<
name|opts_end
condition|)
block|{
comment|/* must have at least 2 bytes per option (opcode and len) */
if|if
condition|(
name|opts
operator|+
literal|2
operator|>
name|opts_end
condition|)
return|return
operator|(
name|GEN_INCOMPLETE
operator|)
return|;
name|opcode
operator|=
operator|*
name|opts
operator|++
expr_stmt|;
name|oplen
operator|=
operator|*
name|opts
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: opcode is %x and oplen %d\n"
argument_list|,
name|opcode
argument_list|,
name|oplen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"clnp_opt_sanity: clnpoval_SRCRT is %x\n"
argument_list|,
name|CLNPOVAL_SRCRT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CLNPOVAL_PAD
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_PAD\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_SECURE
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_SECURE\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_SRCRT
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_SRCRT\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_RECRT
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_RECRT\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_QOS
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_QOS\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_PRIOR
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_PRIOR\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_ERREAS
case|:
block|{
name|printf
argument_list|(
literal|"CLNPOVAL_ERREAS\n"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"UKNOWN option %x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
comment|/* don't allow crazy length values */
if|if
condition|(
name|opts
operator|+
name|oplen
operator|>
name|opts_end
condition|)
return|return
operator|(
name|GEN_INCOMPLETE
operator|)
return|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|CLNPOVAL_PAD
case|:
comment|/* 				 *	Padding: increment pointer by length of padding 				 */
if|if
condition|(
name|pad
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
name|opts
operator|+=
name|oplen
expr_stmt|;
break|break;
case|case
name|CLNPOVAL_SECURE
case|:
block|{
name|u_char
name|format
init|=
operator|*
name|opts
decl_stmt|;
if|if
condition|(
name|secure
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
comment|/* 				 *	Security: high 2 bits of first octet indicate format 				 *	(00 in high bits is reserved). 				 *	Remaining bits must be 0. Remaining octets indicate 				 *	actual security 				 */
if|if
condition|(
operator|(
operator|(
name|format
operator|&
literal|0x3f
operator|)
operator|>
literal|0
operator|)
operator|||
comment|/* low 6 bits set ? */
operator|(
operator|(
name|format
operator|&
literal|0xc0
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* high 2 bits zero ? */
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
name|oidx
operator|->
name|cni_securep
operator|=
name|CLNP_OPTTOOFF
argument_list|(
name|m
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|oidx
operator|->
name|cni_secure_len
operator|=
name|oplen
expr_stmt|;
name|opts
operator|+=
name|oplen
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_SRCRT
case|:
block|{
name|u_char
name|type
decl_stmt|,
name|offset
decl_stmt|;
comment|/* type of rt, offset of start */
name|caddr_t
name|route_end
decl_stmt|;
comment|/* address of end of route option */
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: SRC RT\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|srcrt
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
comment|/* 				 *	source route: There must be 2 bytes following the length 				 *	field: type and offset. The type must be either 				 *	partial route or complete route. The offset field must 				 *	be within the option. A single exception is made, however. 				 *	The offset may be 1 greater than the length. This case 				 *	occurs when the last source route record is consumed. 				 *	In this case, we ignore the source route option. 				 *	RAH? You should be able to set offset to 'ff' like in record 				 *	route! 				 *	Following this is a series of address fields. 				 *	Each address field is composed of a (length, address) pair. 				 *	Insure that the offset and each address length is reasonable 				 */
name|route_end
operator|=
name|opts
operator|+
name|oplen
expr_stmt|;
if|if
condition|(
name|opts
operator|+
literal|2
operator|>
name|route_end
condition|)
return|return
operator|(
name|SRCRT_SYNTAX
operator|)
return|;
name|type
operator|=
operator|*
name|opts
expr_stmt|;
name|offset
operator|=
operator|*
operator|(
name|opts
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* type must be partial or complete */
if|if
condition|(
operator|!
operator|(
operator|(
name|type
operator|==
name|CLNPOVAL_PARTRT
operator|)
operator|||
operator|(
name|type
operator|==
name|CLNPOVAL_COMPRT
operator|)
operator|)
condition|)
return|return
operator|(
name|SRCRT_SYNTAX
operator|)
return|;
name|oidx
operator|->
name|cni_srcrt_s
operator|=
name|CLNP_OPTTOOFF
argument_list|(
name|m
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|oidx
operator|->
name|cni_srcrt_len
operator|=
name|oplen
expr_stmt|;
name|opts
operator|+=
name|offset
operator|-
literal|1
expr_stmt|;
comment|/*set opts to first addr in rt */
comment|/* 				 *	Offset must be reasonable: 				 *	less than end of options, or equal to end of options 				 */
if|if
condition|(
name|opts
operator|>=
name|route_end
condition|)
block|{
if|if
condition|(
name|opts
operator|==
name|route_end
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: end of src route info\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
block|}
else|else
return|return
operator|(
name|SRCRT_SYNTAX
operator|)
return|;
block|}
while|while
condition|(
name|opts
operator|<
name|route_end
condition|)
block|{
name|u_char
name|addrlen
init|=
operator|*
name|opts
operator|++
decl_stmt|;
if|if
condition|(
name|opts
operator|+
name|addrlen
operator|>
name|route_end
condition|)
return|return
operator|(
name|SRCRT_SYNTAX
operator|)
return|;
name|opts
operator|+=
name|addrlen
expr_stmt|;
block|}
block|}
break|break;
case|case
name|CLNPOVAL_RECRT
case|:
block|{
name|u_char
name|type
decl_stmt|,
name|offset
decl_stmt|;
comment|/* type of rt, offset of start */
name|caddr_t
name|record_end
decl_stmt|;
comment|/* address of end of record option */
if|if
condition|(
name|recrt
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
comment|/* 				 *	record route: after the length field, expect a 				 *	type and offset. Type must be partial or complete. 				 *	Offset indicates where to start recording. Insure it 				 *	is within the option. All ones for offset means 				 *	recording is terminated. 				 */
name|record_end
operator|=
name|opts
operator|+
name|oplen
expr_stmt|;
name|oidx
operator|->
name|cni_recrtp
operator|=
name|CLNP_OPTTOOFF
argument_list|(
name|m
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|oidx
operator|->
name|cni_recrt_len
operator|=
name|oplen
expr_stmt|;
if|if
condition|(
name|opts
operator|+
literal|2
operator|>
name|record_end
condition|)
return|return
operator|(
name|GEN_INCOMPLETE
operator|)
return|;
name|type
operator|=
operator|*
name|opts
expr_stmt|;
name|offset
operator|=
operator|*
operator|(
name|opts
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* type must be partial or complete */
if|if
condition|(
operator|!
operator|(
operator|(
name|type
operator|==
name|CLNPOVAL_PARTRT
operator|)
operator|||
operator|(
name|type
operator|==
name|CLNPOVAL_COMPRT
operator|)
operator|)
condition|)
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
comment|/* offset must be reasonable */
if|if
condition|(
operator|(
name|offset
operator|<
literal|0xff
operator|)
operator|&&
operator|(
name|opts
operator|+
name|offset
operator|>
name|record_end
operator|)
condition|)
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
name|opts
operator|+=
name|oplen
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_QOS
case|:
block|{
name|u_char
name|format
init|=
operator|*
name|opts
decl_stmt|;
if|if
condition|(
name|qos
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
comment|/* 				 *	qos: high 2 bits of first octet indicate format 				 *	(00 in high bits is reserved). 				 *	Remaining bits must be 0 (unless format indicates 				 *	globally unique qos, in which case remaining bits indicate 				 *	qos (except bit 6 which is reserved)).  Otherwise, 				 *	remaining octets indicate actual qos. 				 */
if|if
condition|(
operator|(
operator|(
name|format
operator|&
literal|0xc0
operator|)
operator|==
literal|0
operator|)
operator|||
comment|/* high 2 bits zero ? */
operator|(
operator|(
operator|(
name|format
operator|&
literal|0xc0
operator|)
operator|!=
name|CLNPOVAL_GLOBAL
operator|)
operator|&&
operator|(
operator|(
name|format
operator|&
literal|0x3f
operator|)
operator|>
literal|0
operator|)
operator|)
condition|)
comment|/* not global,low bits used ? */
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
name|oidx
operator|->
name|cni_qos_formatp
operator|=
name|CLNP_OPTTOOFF
argument_list|(
name|m
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|oidx
operator|->
name|cni_qos_len
operator|=
name|oplen
expr_stmt|;
name|opts
operator|+=
name|oplen
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_PRIOR
case|:
block|{
if|if
condition|(
name|prior
operator|++
condition|)
comment|/* duplicate ? */
return|return
operator|(
name|GEN_DUPOPT
operator|)
return|;
comment|/* 				 *	priority: value must be one byte long 				 */
if|if
condition|(
name|oplen
operator|!=
literal|1
condition|)
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
name|oidx
operator|->
name|cni_priorp
operator|=
name|CLNP_OPTTOOFF
argument_list|(
name|m
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|opts
operator|+=
name|oplen
expr_stmt|;
block|}
break|break;
case|case
name|CLNPOVAL_ERREAS
case|:
block|{
comment|/* 				 *	er reason: value must be two bytes long 				 */
if|if
condition|(
name|oplen
operator|!=
literal|2
condition|)
return|return
operator|(
name|GEN_HDRSYNTAX
operator|)
return|;
name|oidx
operator|->
name|cni_er_reason
operator|=
operator|*
name|opts
expr_stmt|;
name|opts
operator|+=
name|oplen
expr_stmt|;
block|}
break|break;
default|default:
block|{
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: UNKNOWN OPTION 0x%x\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
name|DISC_UNSUPPOPT
operator|)
return|;
block|}
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_OPTIONS
argument_list|)
name|printf
argument_list|(
literal|"clnp_opt_sanity: return(0)\n"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

end_unit

