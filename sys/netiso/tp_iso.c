begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_iso.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_iso.c,v $  *  * Here is where you find the iso-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto  * (see tp_pcb.c).  * The routines here are:  * 		iso_getsufx: gets transport suffix out of an isopcb structure.  * 		iso_putsufx: put transport suffix into an isopcb structure.  *		iso_putnetaddr: put a whole net addr into an isopcb.  *		iso_getnetaddr: get a whole net addr from an isopcb.  *		iso_cmpnetaddr: compare a whole net addr from an isopcb.  *		iso_recycle_suffix: clear suffix for reuse in isopcb  * 		tpclnp_ctlinput: handle ER CNLPdu : icmp-like stuff  * 		tpclnp_mtu: figure out what size tpdu to use  *		tpclnp_input: take a pkt from clnp, strip off its clnp header,  *				give to tp  *		tpclnp_output_dg: package a pkt for clnp given 2 addresses& some data  *		tpclnp_output: package a pkt for clnp given an isopcb& some data  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/cltp_var.h>
end_include

begin_comment
comment|/*  * CALLED FROM:  * 	pr_usrreq() on PRU_BIND, PRU_CONNECT, PRU_ACCEPT, and PRU_PEERADDR  * FUNCTION, ARGUMENTS:  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_macro
name|iso_getsufx
argument_list|(
argument|isop
argument_list|,
argument|lenp
argument_list|,
argument|data_out
argument_list|,
argument|which
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|lenp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data_out
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|TP_LOCAL
case|:
name|addr
operator|=
name|isop
operator|->
name|isop_laddr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|addr
operator|=
name|isop
operator|->
name|isop_faddr
expr_stmt|;
block|}
if|if
condition|(
name|addr
condition|)
name|bcopy
argument_list|(
name|TSEL
argument_list|(
name|addr
argument_list|)
argument_list|,
name|data_out
argument_list|,
operator|(
operator|*
name|lenp
operator|=
name|addr
operator|->
name|siso_tlen
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION, ARGUMENTS:  * 	Put a transport suffix (found in name) into an isopcb structure (isop).  * 	The argument (which) takes the value TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_putsufx
parameter_list|(
name|isop
parameter_list|,
name|sufxloc
parameter_list|,
name|sufxlen
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|caddr_t
name|sufxloc
decl_stmt|;
name|int
name|sufxlen
decl_stmt|,
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|dst
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
return|return;
case|case
name|TP_LOCAL
case|:
name|dst
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|dst
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|addr
operator|=
operator|*
name|dst
operator|)
operator|==
literal|0
condition|)
block|{
name|addr
operator|=
operator|*
name|dst
operator|=
name|backup
expr_stmt|;
name|addr
operator|->
name|siso_nlen
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|siso_slen
operator|=
literal|0
expr_stmt|;
name|addr
operator|->
name|siso_plen
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"iso_putsufx on un-initialized isopcb\n"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|sufxlen
operator|+
name|addr
operator|->
name|siso_nlen
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|addr
operator|->
name|siso_data
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|backup
condition|)
block|{
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|addr
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|addr
operator|=
operator|*
name|dst
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|*
name|backup
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
block|}
name|bcopy
argument_list|(
name|sufxloc
argument_list|,
name|TSEL
argument_list|(
name|addr
argument_list|)
argument_list|,
name|sufxlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|siso_tlen
operator|=
name|sufxlen
expr_stmt|;
name|addr
operator|->
name|siso_len
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp.trans whenever we go into REFWAIT state.  * FUNCTION and ARGUMENT:  *	 Called when a ref is frozen, to allow the suffix to be reused.  * 	(isop) is the net level pcb.  This really shouldn't have to be  * 	done in a NET level pcb but... for the internet world that just  * 	the way it is done in BSD...  * 	The alternative is to have the port unusable until the reference  * 	timer goes off.  */
end_comment

begin_function
name|void
name|iso_recycle_tsuffix
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_tlen
operator|=
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_tlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp_newsocket(); i.e., when a connection is being established by an  * 	incoming CR_TPDU.  *  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from a struct sockaddr (name).  * 	into an isopcb (isop).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN  */
end_comment

begin_function
name|void
name|iso_putnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|sisop
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"iso_putnetaddr: should panic\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TP_LOCAL
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
block|}
name|siso
operator|=
operator|(
operator|(
operator|*
name|sisop
operator|==
literal|0
operator|)
condition|?
operator|(
operator|*
name|sisop
operator|=
name|backup
operator|)
else|:
operator|*
name|sisop
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"ISO_PUTNETADDR\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|siso
operator|->
name|siso_addr
init|=
name|name
operator|->
name|siso_addr
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	tp_input() when a connection is being established by an  * 	incoming CR_TPDU, and considered for interception.  *  * FUNCTION and ARGUMENTS:  * 	compare a whole net addr from a struct sockaddr (name),  * 	with that implicitly stored in an isopcb (isop).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_expr_stmt
name|iso_cmpnetaddr
argument_list|(
name|isop
argument_list|,
name|name
argument_list|,
name|which
argument_list|)
specifier|register
expr|struct
name|isopcb
operator|*
name|isop
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|which
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|sisop
decl_stmt|,
modifier|*
name|backup
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"iso_cmpnetaddr: should panic\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TP_LOCAL
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_laddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
break|break;
case|case
name|TP_FOREIGN
case|:
name|sisop
operator|=
operator|&
name|isop
operator|->
name|isop_faddr
expr_stmt|;
name|backup
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
block|}
name|siso
operator|=
operator|(
operator|(
operator|*
name|sisop
operator|==
literal|0
operator|)
condition|?
operator|(
operator|*
name|sisop
operator|=
name|backup
operator|)
else|:
operator|*
name|sisop
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"ISO_CMPNETADDR\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|name
operator|->
name|siso_tlen
operator|&&
name|bcmp
argument_list|(
name|TSEL
argument_list|(
name|name
argument_list|)
argument_list|,
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
name|name
operator|->
name|siso_tlen
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|bcmp
argument_list|(
operator|(
name|caddr_t
operator|)
name|name
operator|->
name|siso_data
argument_list|,
operator|(
name|caddr_t
operator|)
name|siso
operator|->
name|siso_data
argument_list|,
name|name
operator|->
name|siso_nlen
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  pr_usrreq() PRU_SOCKADDR, PRU_ACCEPT, PRU_PEERADDR  * FUNCTION and ARGUMENTS:  * 	Copy a whole net addr from an isopcb (isop) into  * 	a struct sockaddr (name).  * 	The argument (which) takes values TP_LOCAL or TP_FOREIGN.  */
end_comment

begin_function
name|void
name|iso_getnetaddr
parameter_list|(
name|isop
parameter_list|,
name|name
parameter_list|,
name|which
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|name
decl_stmt|;
name|int
name|which
decl_stmt|;
block|{
name|struct
name|sockaddr_iso
modifier|*
name|siso
init|=
operator|(
name|which
operator|==
name|TP_LOCAL
condition|?
name|isop
operator|->
name|isop_laddr
else|:
name|isop
operator|->
name|isop_faddr
operator|)
decl_stmt|;
if|if
condition|(
name|siso
condition|)
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|siso
argument_list|,
name|mtod
argument_list|(
name|name
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|name
operator|->
name|m_len
operator|=
name|siso
operator|->
name|siso_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|name
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME: 	tpclnp_mtu()  *  * CALLED FROM:  *  tp_route_to() on incoming CR, CC, and pr_usrreq() for PRU_CONNECT  *  * FUNCTION, ARGUMENTS, and RETURN VALUE:  *  * Perform subnetwork dependent part of determining MTU information.  * It appears that setting a double pointer to the rtentry associated with  * the destination, and returning the header size for the network protocol  * suffices.  *  * SIDE EFFECTS:  * Sets tp_routep pointer in pcb.  *  * NOTES:  */
end_comment

begin_expr_stmt
name|tpclnp_mtu
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_mtu(tpcb)\n"
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_routep
init|=
operator|&
operator|(
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
operator|)
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_netservice
operator|==
name|ISO_CONS
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_fixed
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|clnp_segment
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|iso_addr
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that clnp will accept it.  *  This means prepending space for the clnp header and filling in a few  *  of the fields.  *  isop is the isopcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output
parameter_list|(
name|isop
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|struct
name|tpdu
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"abt to call clnp_output: datalen 0x%x, hdr.li 0x%x, hdr.dutype 0x%x nocsum x%x dst addr:\n"
argument_list|,
name|datalen
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_type
argument_list|,
name|nochksum
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nsrc addr:\n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m0
argument_list|,
literal|"at tpclnp_output"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|clnp_output
argument_list|(
name|m0
argument_list|,
name|isop
argument_list|,
name|datalen
argument_list|,
comment|/* flags */
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  This is a copy of tpclnp_output that takes the addresses  *  instead of a pcb.  It's used by the tp_error_emit, when we  *  don't have an iso_pcb with which to call the normal output rtn.  * RETURN VALUE:  *  ENOBUFS or  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpclnp_output_dg
parameter_list|(
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|ro
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|laddr
decl_stmt|,
decl|*
name|faddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nochksum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|isopcb
name|tmppcb
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|flags
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  datalen 0x%x m0 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Fill in minimal portion of isopcb so that clnp can send the 	 *	packet. 	 */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tmppcb
argument_list|,
sizeof|sizeof
argument_list|(
name|tmppcb
argument_list|)
argument_list|)
decl_stmt|;
name|tmppcb
operator|.
name|isop_laddr
operator|=
operator|&
name|tmppcb
operator|.
name|isop_sladdr
expr_stmt|;
name|tmppcb
operator|.
name|isop_laddr
operator|->
name|siso_addr
operator|=
operator|*
name|laddr
expr_stmt|;
name|tmppcb
operator|.
name|isop_faddr
operator|=
operator|&
name|tmppcb
operator|.
name|isop_sfaddr
expr_stmt|;
name|tmppcb
operator|.
name|isop_faddr
operator|->
name|siso_addr
operator|=
operator|*
name|faddr
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_output_dg  faddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_sfaddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ntpclnp_output_dg  laddr: \n"
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
operator|&
name|tmppcb
operator|.
name|isop_sladdr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	Do not use packet cache since this is a one shot error packet 	 */
name|flags
init|=
operator|(
name|CLNP_NOCACHE
operator||
operator|(
name|nochksum
condition|?
name|CLNP_NO_CKSUM
else|:
literal|0
operator|)
operator|)
decl_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|err
operator|=
name|clnp_output
argument_list|(
name|m0
argument_list|,
operator|&
name|tmppcb
argument_list|,
name|datalen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 *	Free route allocated by clnp (if the route was indeed allocated) 	 */
if|if
condition|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|tmppcb
operator|.
name|isop_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	clnp's input routine, indirectly through the protosw.  * FUNCTION and ARGUMENTS:  * Take a packet (m) from clnp, strip off the clnp header and give it to tp  * No return value.  */
end_comment

begin_function
name|ProtoHook
name|tpclnp_input
parameter_list|(
name|m
parameter_list|,
name|src
parameter_list|,
name|dst
parameter_list|,
name|clnp_len
parameter_list|,
name|ce_bit
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|clnp_len
decl_stmt|,
name|ce_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|tp_inputprep
parameter_list|()
function_decl|;
name|int
name|tp_input
argument_list|()
decl_stmt|,
name|cltp_input
argument_list|()
decl_stmt|,
argument_list|(
operator|*
name|input
argument_list|)
argument_list|()
init|=
name|tp_input
decl_stmt|;
name|IncStat
argument_list|(
name|ts_pkt_rcvd
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_input: m 0x%x clnp_len 0x%x\n"
argument_list|,
name|m
argument_list|,
name|clnp_len
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"at tpclnp_input"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * CLNP gives us an mbuf chain WITH the clnp header pulled up, 	 * and the length of the clnp header. 	 * First, strip off the Clnp header. leave the mbuf there for the 	 * pullup that follows. 	 */
name|m
operator|->
name|m_len
operator|-=
name|clnp_len
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|clnp_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|clnp_len
expr_stmt|;
comment|/* XXXX: should probably be in clnp_input */
switch|switch
condition|(
name|dst
operator|->
name|siso_data
index|[
name|dst
operator|->
name|siso_nlen
operator|-
literal|1
index|]
condition|)
block|{
ifdef|#
directive|ifdef
name|TUBA
case|case
name|ISOPROTO_TCP
case|:
return|return
operator|(
name|tuba_tcpinput
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
operator|)
return|;
endif|#
directive|endif
case|case
literal|0
case|:
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|==
name|ISO10747_IDRP
condition|)
return|return
operator|(
name|idrp_input
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
operator|)
return|;
block|}
name|m
operator|=
name|tp_inputprep
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
index|[
literal|1
index|]
operator|==
name|UD_TPDU_type
condition|)
name|input
operator|=
name|cltp_input
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"after tpclnp_input both pullups"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
parameter_list|(
name|D_TPISO
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"calling %sinput : src 0x%x, dst 0x%x, src addr:\n"
operator|,
parameter_list|(
function_decl|input == tp_input ? "tp_" : "clts_"
block|)
end_block

begin_operator
operator|,
end_operator

begin_expr_stmt
name|src
operator|,
name|dst
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|dump_isoaddr
argument_list|(
name|src
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|" dst addr:\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dump_isoaddr
argument_list|(
name|dst
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ENDDEBUG
argument_list|(
name|void
argument_list|)
argument_list|(
operator|*
name|input
argument_list|)
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
literal|0
argument_list|,
name|tpclnp_output_dg
argument_list|,
name|ce_bit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_QUENCH
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|time
operator|.
name|tv_usec
operator|&
literal|0x4
operator|&&
name|time
operator|.
name|tv_usec
operator|&
literal|0x40
condition|)
block|{
name|printf
argument_list|(
literal|"tpclnp_input: FAKING %s\n"
argument_list|,
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|?
literal|"QUENCH"
else|:
literal|"QUENCH2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp_stat
operator|.
name|ts_pkt_rcvd
operator|&
literal|0x1
condition|)
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tpclnp_ctlinput
argument_list|(
name|PRC_QUENCH2
argument_list|,
operator|&
name|src
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|ENDDEBUG
end_macro

begin_return
return|return
literal|0
return|;
end_return

begin_macro
unit|}  ProtoHook
name|iso_rtchange
argument_list|()
end_macro

begin_block
block|{
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_decbit
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_pcb
argument_list|,
name|PRC_QUENCH2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tpclnp_ctlinput()  * FUNCTION and ARGUMENTS:  *  find the tpcb pointer and pass it to tp_quench  */
end_comment

begin_function
name|void
name|tpiso_quench
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|tp_quench
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_pcb
argument_list|,
name|PRC_QUENCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  The network layer through the protosw table.  * FUNCTION and ARGUMENTS:  *	When clnp an ICMP-like msg this gets called.  *	It either returns an error status to the user or  *	it causes all connections on this address to be aborted  *	by calling the appropriate xx_notify() routine.  *	(cmd) is the type of ICMP error.  * 	(siso) is the address of the guy who sent the ER CLNPDU  */
end_comment

begin_function
name|ProtoHook
name|tpclnp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|siso
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
block|{
specifier|extern
name|u_char
name|inetctlerrmap
index|[]
decl_stmt|;
specifier|extern
name|ProtoHook
name|tpiso_abort
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|iso_rtchange
parameter_list|()
function_decl|;
specifier|extern
name|ProtoHook
name|tpiso_reset
parameter_list|()
function_decl|;
name|void
name|iso_pcbnotify
parameter_list|()
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpclnp_ctlinput1: cmd 0x%x addr: \n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|siso
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|siso
operator|->
name|siso_family
operator|!=
name|AF_ISO
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH2
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|siso
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tpiso_decbit
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_QUENCH
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|siso
argument_list|,
literal|0
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|tpiso_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_TIMXCEED_REASS
case|:
case|case
name|PRC_ROUTEDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|siso
argument_list|,
literal|0
argument_list|,
name|tpiso_reset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_HOSTUNREACH
case|:
case|case
name|PRC_UNREACH_NET
case|:
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|siso
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|iso_rtchange
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		case	PRC_MSGSIZE: 		case	PRC_UNREACH_HOST: 		case	PRC_UNREACH_PROTOCOL: 		case	PRC_UNREACH_PORT: 		case	PRC_UNREACH_NEEDFRAG: 		case	PRC_UNREACH_SRCFAIL: 		case	PRC_REDIRECT_NET: 		case	PRC_REDIRECT_HOST: 		case	PRC_REDIRECT_TOSNET: 		case	PRC_REDIRECT_TOSHOST: 		case	PRC_TIMXCEED_INTRANS: 		case	PRC_PARAMPROB: 		*/
name|iso_pcbnotify
argument_list|(
operator|&
name|tp_isopcb
argument_list|,
name|siso
argument_list|,
operator|(
name|int
operator|)
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|tpiso_abort
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * XXX - Variant which is called by clnp_er.c with an isoaddr rather  * than a sockaddr_iso.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_iso
name|siso
init|=
block|{
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
block|,
name|AF_ISO
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|tpclnp_ctlinput1
argument_list|(
argument|cmd
argument_list|,
argument|isoa
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
operator|.
name|siso_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
operator|.
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|siso
operator|.
name|siso_addr
argument_list|,
name|isoa
operator|->
name|isoa_len
argument_list|)
expr_stmt|;
name|tpclnp_ctlinput
argument_list|(
name|cmd
argument_list|,
operator|&
name|siso
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * These next 2 routines are  * CALLED FROM:  *	xxx_notify() from tp_ctlinput() when  *  net level gets some ICMP-equiv. type event.  * FUNCTION and ARGUMENTS:  *  Cause the connection to be aborted with some sort of error  *  reason indicating that the network layer caused the abort.  *  Fakes an ER TPDU so we can go through the driver.  *  abort always aborts the TP connection.  *  reset may or may not, depending on the TP class that's in use.  */
end_comment

begin_function
name|ProtoHook
name|tpiso_abort
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tpiso_abort 0x%x\n"
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|e
operator|.
name|ev_number
init|=
name|ER_TPDU
decl_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|ECONNABORTED
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_pcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_function
name|ProtoHook
name|tpiso_reset
parameter_list|(
name|isop
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
name|struct
name|tp_event
name|e
decl_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|T_NETRESET
expr_stmt|;
return|return
name|tp_driver
argument_list|(
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_pcb
argument_list|,
operator|&
name|e
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

end_unit

