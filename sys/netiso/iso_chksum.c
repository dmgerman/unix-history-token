begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)iso_chksum.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/iso_chksum.c,v $  *  * ISO CHECKSUM  *  * The checksum generation and check routines are here.  * The checksum is 2 bytes such that the sum of all the bytes b(i) == 0  * and the sum of i * b(i) == 0.  * The whole thing is complicated by the fact that the data are in mbuf  * chains.  * Furthermore, there is the possibility of wraparound in the running  * sums after adding up 4102 octets.  In order to avoid doing a mod  * operation after EACH add, we have restricted this implementation to  * negotiating a maximum of 4096-octets per TPDU (for the transport layer).  * The routine iso_check_csum doesn't need to know where the checksum  * octets are.  * The routine iso_gen_csum takes a pointer to an mbuf chain (logically  * a chunk of data), an offset into the chunk at which the 2 octets are to  * be stuffed, and the length of the chunk.  The 2 octets have to be  * logically adjacent, but may be physically located in separate mbufs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MNULL
end_ifndef

begin_define
define|#
directive|define
name|MNULL
value|(struct mbuf *)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MNULL */
end_comment

begin_comment
comment|/*  * FUNCTION:	iso_check_csum  *  * PURPOSE:		To check the checksum of the packet in the mbuf chain (m).  * 				The total length of the packet is (len).  * 				Called from tp_input() and clnp_intr()  *  * RETURNS:		 TRUE (something non-zero) if there is a checksum error,  * 			 	 FALSE if there was NO checksum error.  *  * SIDE EFFECTS:  none  *  * NOTES:		 It might be possible to gain something by optimizing  *               this routine (unrolling loops, etc). But it is such  *				 a horrible thing to fiddle with anyway, it probably  *				 isn't worth it.  */
end_comment

begin_function
name|int
name|iso_check_csum
parameter_list|(
name|m
parameter_list|,
name|len
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|u_long
name|c0
init|=
literal|0
decl_stmt|,
name|c1
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|cum
init|=
literal|0
decl_stmt|;
comment|/* cumulative length */
name|int
name|l
decl_stmt|;
name|l
operator|=
name|len
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"iso_check_csum: m x%x, l x%x, m->m_len x%x\n"
argument_list|,
name|m
argument_list|,
name|l
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|cum
operator|+=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|cum
condition|)
block|{
name|c0
operator|=
name|c0
operator|+
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|c1
operator|+=
name|c0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"iso_check_csum: new mbuf\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|-
name|i
operator|<
name|m
operator|->
name|m_len
condition|)
name|printf
argument_list|(
literal|"bad mbuf chain in check csum l 0x%x i 0x%x m_data 0x%x"
argument_list|,
name|l
argument_list|,
name|i
argument_list|,
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|ASSERT
argument_list|(
name|m
operator|!=
name|MNULL
argument_list|)
decl_stmt|;
name|len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|l
operator|-
name|i
argument_list|)
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|c0
operator|%
literal|255
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|c1
operator|%
literal|255
operator|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"BAD iso_check_csum l 0x%x cum 0x%x len 0x%x, i 0x%x"
argument_list|,
name|l
argument_list|,
name|cum
argument_list|,
name|len
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
operator|(
operator|(
name|int
operator|)
name|c0
operator|%
literal|255
operator|)
operator|<<
literal|8
operator||
operator|(
operator|(
name|int
operator|)
name|c1
operator|%
literal|255
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * FUNCTION:	iso_gen_csum  *  * PURPOSE:		To generate the checksum of the packet in the mbuf chain (m).  * 				The first of the 2 (logically) adjacent checksum bytes  *				(x and y) go at offset (n).  * 				(n) is an offset relative to the beginning of the data,  *				not the beginning of the mbuf.  * 				(l) is the length of the total mbuf chain's data.  * 				Called from tp_emit(), tp_error_emit()  *				clnp_emit_er(), clnp_forward(), clnp_output().  *  * RETURNS:		Rien  *  * SIDE EFFECTS: Puts the 2 checksum bytes into the packet.  *  * NOTES:		Ditto the note for iso_check_csum().  */
end_comment

begin_function
name|void
name|iso_gen_csum
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|,
name|l
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* offset of 2 checksum bytes */
name|int
name|l
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|c0
init|=
literal|0
decl_stmt|,
name|c1
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|loc
init|=
name|n
operator|++
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|;
comment|/* n is position, loc is offset */
name|u_char
modifier|*
name|xloc
decl_stmt|;
name|u_char
modifier|*
name|yloc
decl_stmt|;
name|int
name|cum
init|=
literal|0
decl_stmt|;
comment|/* cum == cumulative length */
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"enter gen csum m 0x%x n 0x%x l 0x%x\n"
argument_list|,
name|m
argument_list|,
name|n
operator|-
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|i
operator|<
name|l
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|CLBYTES
argument_list|)
expr_stmt|;
comment|/* RAH: don't cksum more than l bytes */
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|l
operator|-
name|i
argument_list|)
expr_stmt|;
name|cum
operator|+=
name|len
expr_stmt|;
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|loc
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|loc
operator|<
name|len
condition|)
block|{
name|xloc
operator|=
name|loc
operator|+
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"1: zeroing xloc 0x%x loc 0x%x\n"
argument_list|,
name|xloc
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|xloc
init|=
operator|(
name|u_char
operator|)
literal|0
decl_stmt|;
if|if
condition|(
name|loc
operator|+
literal|1
operator|<
name|len
condition|)
block|{
comment|/* both xloc and yloc are in same mbuf */
name|yloc
operator|=
literal|1
operator|+
name|xloc
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"2: zeroing yloc 0x%x loc 0x%x\n"
argument_list|,
name|yloc
argument_list|,
name|loc
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|yloc
init|=
operator|(
name|u_char
operator|)
literal|0
decl_stmt|;
block|}
else|else
block|{
comment|/* crosses boundary of mbufs */
name|yloc
operator|=
name|mtod
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"3: zeroing yloc 0x%x \n"
argument_list|,
name|yloc
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|yloc
init|=
operator|(
name|u_char
operator|)
literal|0
decl_stmt|;
block|}
block|}
name|loc
operator|-=
name|len
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|cum
condition|)
block|{
name|c0
operator|=
operator|(
name|c0
operator|+
operator|*
name|p
operator|)
expr_stmt|;
name|c1
operator|+=
name|c0
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"gen csum final xloc 0x%x yloc 0x%x\n"
argument_list|,
name|xloc
argument_list|,
name|yloc
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|c1
init|=
operator|(
operator|(
operator|(
name|c0
operator|*
operator|(
name|l
operator|-
name|n
operator|)
operator|)
operator|-
name|c1
operator|)
operator|%
literal|255
operator|)
decl_stmt|;
operator|*
name|xloc
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|c1
operator|<
literal|0
operator|)
condition|?
name|c1
operator|+
literal|255
else|:
name|c1
argument_list|)
expr_stmt|;
name|c1
operator|=
operator|(
operator|-
call|(
name|int
call|)
argument_list|(
name|c1
operator|+
name|c0
argument_list|)
operator|)
operator|%
literal|255
expr_stmt|;
operator|*
name|yloc
operator|=
call|(
name|u_char
call|)
argument_list|(
name|c1
operator|<
literal|0
condition|?
name|c1
operator|+
literal|255
else|:
name|c1
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CHKSUM
argument_list|)
name|printf
argument_list|(
literal|"gen csum end \n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_function

begin_comment
comment|/*  * FUNCTION:	m_datalen  *  * PURPOSE:		returns length of the mbuf chain.  * 				used all over the iso code.  *  * RETURNS:		integer  *  * SIDE EFFECTS: none  *  * NOTES:  */
end_comment

begin_function
name|int
name|m_datalen
parameter_list|(
name|m
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|int
name|datalen
decl_stmt|;
for|for
control|(
name|datalen
operator|=
literal|0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|datalen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
return|return
name|datalen
return|;
block|}
end_function

begin_function
name|int
name|m_compress
parameter_list|(
name|in
parameter_list|,
name|out
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|in
decl_stmt|,
decl|*
modifier|*
name|out
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|datalen
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|in
operator|->
name|m_next
operator|==
name|MNULL
condition|)
block|{
operator|*
name|out
operator|=
name|in
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress returning 0x%x: A\n"
argument_list|,
name|in
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
name|in
operator|->
name|m_len
return|;
block|}
name|MGET
argument_list|(
operator|(
operator|*
name|out
operator|)
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|out
operator|)
operator|==
name|MNULL
condition|)
block|{
operator|*
name|out
operator|=
name|in
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress returning -1: B\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
operator|*
name|out
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|out
operator|)
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
while|while
condition|(
name|in
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress in 0x%x *out 0x%x\n"
argument_list|,
name|in
argument_list|,
operator|*
name|out
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m_compress in: len 0x%x, off 0x%x\n"
argument_list|,
name|in
operator|->
name|m_len
argument_list|,
name|in
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m_compress *out: len 0x%x, off 0x%x\n"
argument_list|,
operator|(
operator|*
name|out
operator|)
operator|->
name|m_len
argument_list|,
operator|(
operator|*
name|out
operator|)
operator|->
name|m_data
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|in
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|ASSERT
argument_list|(
name|in
operator|->
name|m_len
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|in
operator|=
name|in
operator|->
name|m_next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|out
operator|)
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|out
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|in
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|datalen
operator|+=
name|len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress copying len %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|in
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
operator|(
operator|*
name|out
operator|)
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|(
operator|*
name|out
operator|)
operator|->
name|m_len
argument_list|,
operator|(
name|unsigned
operator|)
name|len
argument_list|)
decl_stmt|;
operator|(
operator|*
name|out
operator|)
operator|->
name|m_len
operator|+=
name|len
expr_stmt|;
name|in
operator|->
name|m_len
operator|-=
name|len
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* (*out) is full */
if|if
condition|(
operator|(
operator|(
operator|*
name|out
operator|)
operator|->
name|m_next
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|out
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|in
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress returning -1: B\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
operator|*
name|out
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|out
operator|)
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
operator|*
name|out
operator|=
operator|(
operator|*
name|out
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"m_compress returning 0x%x: A\n"
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|splx
parameter_list|(
name|s
parameter_list|)
function_decl|;
return|return
name|datalen
return|;
block|}
end_block

end_unit

