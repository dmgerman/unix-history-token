begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_cons.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_cons.c,v $  *  * Here is where you find the iso- and cons-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto  * (see tp_pcb.c).  * The routines here are:  *	tpcons_input: pullup and call tp_input w/ correct arguments  *	tpcons_output: package a pkt for cons given an isopcb& some data  *	cons_chan_to_tpcb: find a tpcb based on the channel #  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|TPCONS
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_errno.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/cons.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_seq.h>
end_include

begin_undef
undef|#
directive|undef
name|FALSE
end_undef

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/if_cons.c>
end_include

begin_function_decl
name|int
name|tpcons_output
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * CALLED FROM:  *  tp_route_to() for PRU_CONNECT  * FUNCTION, ARGUMENTS, SIDE EFFECTS and RETURN VALUE:  *  version of the previous procedure for X.25  */
end_comment

begin_macro
name|tpcons_pcbconnect
argument_list|(
argument|isop
argument_list|,
argument|nam
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|iso_pcbconnect
argument_list|(
name|isop
argument_list|,
name|nam
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_chan
operator|=
operator|(
name|caddr_t
operator|)
name|pk_attach
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"tpcons_pcbconnect: no pklcd; returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|error
operator|=
name|cons_connect
argument_list|(
name|isop
argument_list|)
condition|)
block|{
comment|/* if it doesn't work */
comment|/* oh, dear, throw packet away */
name|pk_disconnect
argument_list|(
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_chan
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|isop
operator|->
name|isop_refcnt
operator|=
literal|1
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	cons  * FUNCTION and ARGUMENTS:  * THIS MAYBE BELONGS IN SOME OTHER PLACE??? but i think not -  */
end_comment

begin_function
name|ProtoHook
name|tpcons_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|siso
parameter_list|,
name|isop
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_socket
condition|)
name|tpcb
operator|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_pcb
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_CONS_SEND_DONE
case|:
if|if
condition|(
name|tpcb
condition|)
block|{
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
comment|/* only if class is exactly class zero, not 				 * still in class negotiation 				 */
comment|/* fake an ack */
specifier|register
name|SeqNum
name|seq
init|=
name|SEQ_ADD
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"FAKE ACK seq cdt 1"
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"FAKE ACK seq 0x%x cdt 1\n"
argument_list|,
name|seq
argument_list|)
decl_stmt|;
name|ENDDEBUG
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
decl|.
name|e_cdt
init|=
literal|1
decl_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seq
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_subseq
operator|=
literal|0
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_fcc_present
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|AK_TPDU
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
block|}
block|}
comment|/* else ignore it */
block|}
break|break;
case|case
name|PRC_ROUTEDEAD
case|:
if|if
condition|(
name|tpcb
operator|&&
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|tpiso_reset
argument_list|(
name|isop
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else drop through */
default|default:
operator|(
name|void
operator|)
name|tpclnp_ctlinput
argument_list|(
name|cmd
argument_list|,
name|siso
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	cons's intr routine  * FUNCTION and ARGUMENTS:  * Take a packet (m) from cons, pullup m as required by tp,  *  ignore the socket argument, and call tp_input.  * No return value.  */
end_comment

begin_function
name|ProtoHook
name|tpcons_input
parameter_list|(
name|m
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|channel
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|faddr
decl_stmt|,
decl|*
name|laddr
decl_stmt|;
end_function

begin_decl_stmt
name|caddr_t
name|channel
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
literal|0
return|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|tp_inputprep
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpcons_input before tp_input(m 0x%x)\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|m
argument_list|,
literal|12
operator|+
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_input
argument_list|(
name|m
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|channel
argument_list|,
name|tpcons_output
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that cons will accept it.  *  This means filling in a few of the fields.  *  inp is the isopcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpcons_output
parameter_list|(
name|isop
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tpcons_output(isop 0x%x, m 0x%x, len 0x%x socket 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|m0
argument_list|,
name|datalen
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|datalen
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_chan
operator|==
literal|0
condition|)
block|{
comment|/* got a restart maybe? */
if|if
condition|(
operator|(
name|isop
operator|->
name|isop_chan
operator|=
operator|(
name|caddr_t
operator|)
name|pk_attach
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"tpcons_output: no pklcd\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|ENOBUFS
decl_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|cons_connect
argument_list|(
name|isop
argument_list|)
condition|)
block|{
name|pk_disconnect
argument_list|(
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_chan
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"tpcons_output: can't reconnect\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
else|else
block|{
name|error
operator|=
name|pk_send
argument_list|(
name|isop
operator|->
name|isop_chan
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that cons will accept it.  *  chan is the cons channel to use; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpcons_dg_output
parameter_list|(
name|chan
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|)
name|caddr_t
name|chan
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
return|return
name|tpcons_output
argument_list|(
operator|(
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|chan
operator|)
operator|->
name|lcd_upnext
argument_list|,
name|m0
argument_list|,
name|datalen
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TPCONS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

end_unit

