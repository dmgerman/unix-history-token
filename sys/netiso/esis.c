begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)esis.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_snpac.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnl.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/esis.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_comment
comment|/*  *	Global variables to esis implementation  *  *	esis_holding_time - the holding time (sec) parameter for outgoing pdus  *	esis_config_time  - the frequency (sec) that hellos are generated  *	esis_esconfig_time - suggested es configuration time placed in the  *						ish.  *  */
end_comment

begin_decl_stmt
name|struct
name|rawcb
name|esis_pcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|esis_config
argument_list|()
decl_stmt|,
name|snpac_age
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esis_sendspace
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|esis_recvspace
init|=
literal|2048
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|esis_holding_time
init|=
name|ESIS_HT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|esis_config_time
init|=
name|ESIS_CONFIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|esis_esconfig_time
init|=
name|ESIS_CONFIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|iso_systype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_dl
name|esis_dl
init|=
block|{
sizeof|sizeof
argument_list|(
name|esis_dl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|all_es_snpa
index|[]
decl_stmt|,
name|all_is_snpa
index|[]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXTEND_PACKET
parameter_list|(
name|m
parameter_list|,
name|mhdr
parameter_list|,
name|cp
parameter_list|)
define|\
value|if (((m)->m_next = m_getclr(M_DONTWAIT, MT_HEADER)) == NULL) {\ 		esis_stat.es_nomem++;\ 		m_freem(mhdr);\ 		return;\ 	} else {\ 		(m) = (m)->m_next;\ 		(cp) = mtod((m), caddr_t);\ 	}
end_define

begin_comment
comment|/*  * FUNCTION:		esis_init  *  * PURPOSE:			Initialize the kernel portion of esis protocol  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_init
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|struct
name|clnl_protosw
name|clnl_protox
index|[
literal|256
index|]
decl_stmt|;
name|int
name|esis_input
argument_list|()
decl_stmt|,
name|isis_input
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|ISO_X25ESIS
name|int
name|x25esis_input
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* ISO_X25ESIS */
name|esis_pcb
operator|.
name|rcb_next
operator|=
name|esis_pcb
operator|.
name|rcb_prev
operator|=
operator|&
name|esis_pcb
expr_stmt|;
name|llinfo_llc
operator|.
name|lc_next
operator|=
name|llinfo_llc
operator|.
name|lc_prev
operator|=
operator|&
name|llinfo_llc
expr_stmt|;
name|timeout
argument_list|(
name|snpac_age
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|esis_config
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|clnl_protox
index|[
name|ISO9542_ESIS
index|]
operator|.
name|clnl_input
operator|=
name|esis_input
expr_stmt|;
name|clnl_protox
index|[
name|ISO10589_ISIS
index|]
operator|.
name|clnl_input
operator|=
name|isis_input
expr_stmt|;
ifdef|#
directive|ifdef
name|ISO_X25ESIS
name|clnl_protox
index|[
name|ISO9542X25_ESIS
index|]
operator|.
name|clnl_input
operator|=
name|x25esis_input
expr_stmt|;
endif|#
directive|endif
comment|/* ISO_X25ESIS */
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_usrreq  *  * PURPOSE:			Handle user level esis requests  *  * RETURNS:			0 or appropriate errno  *  * SIDE EFFECTS:  *  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|esis_usrreq
argument_list|(
argument|so
argument_list|,
argument|req
argument_list|,
argument|m
argument_list|,
argument|nam
argument_list|,
argument|control
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket: used only to get to this code */
end_comment

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* data for request */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional name */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* optional control */
end_comment

begin_block
block|{
name|struct
name|rawcb
modifier|*
name|rp
init|=
name|sotorawcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PRIV
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|rp
operator|==
name|NULL
operator|&&
name|req
operator|!=
name|PRU_ATTACH
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|PRU_ATTACH
case|:
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|MALLOC
argument_list|(
name|rp
argument_list|,
expr|struct
name|rawcb
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|rp
condition|)
block|{
name|bzero
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|rp
argument_list|,
operator|&
name|esis_pcb
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rcb_socket
operator|=
name|so
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|esis_sendspace
argument_list|,
name|esis_recvspace
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
case|case
name|PRU_SEND
case|:
if|if
condition|(
name|nam
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* error checking here */
name|error
operator|=
name|isis_output
argument_list|(
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_dl
operator|*
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PRU_DETACH
case|:
name|raw_detach
argument_list|(
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SHUTDOWN
case|:
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_ABORT
case|:
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|raw_detach
argument_list|(
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRU_SENSE
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|release
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_input  *  * PURPOSE:			Process an incoming esis packet  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_input
argument_list|(
argument|m0
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to first mbuf of pkt */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
specifier|register
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|type
decl_stmt|;
comment|/* 	 *	check checksum if necessary 	 */
if|if
condition|(
name|ESIS_CKSUM_REQUIRED
argument_list|(
name|pdu
argument_list|)
operator|&&
name|iso_check_csum
argument_list|(
name|m0
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
condition|)
block|{
name|esis_stat
operator|.
name|es_badcsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* check version */
if|if
condition|(
name|pdu
operator|->
name|esis_vers
operator|!=
name|ESIS_VERSION
condition|)
block|{
name|esis_stat
operator|.
name|es_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|type
operator|=
name|pdu
operator|->
name|esis_type
operator|&
literal|0x1f
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ESIS_ESH
case|:
name|esis_eshinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESIS_ISH
case|:
name|esis_ishinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ESIS_RD
case|:
name|esis_rdinput
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|esis_stat
operator|.
name|es_badtype
operator|++
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|esis_pcb
operator|.
name|rcb_next
operator|!=
operator|&
name|esis_pcb
condition|)
name|isis_input
argument_list|(
name|m0
argument_list|,
name|shp
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_rdoutput  *  * PURPOSE:			Transmit a redirect pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:			Assumes there is enough space for fixed part of header,  *					DA, BSNPA and NET in first mbuf.  */
end_comment

begin_macro
name|esis_rdoutput
argument_list|(
argument|inbound_shp
argument_list|,
argument|inbound_m
argument_list|,
argument|inbound_oidx
argument_list|,
argument|rd_dstnsap
argument_list|,
argument|rt
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|inbound_shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snpa hdr from incoming packet */
end_comment

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|inbound_m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incoming pkt itself */
end_comment

begin_decl_stmt
name|struct
name|clnp_optidx
modifier|*
name|inbound_oidx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clnp options assoc with incoming pkt */
end_comment

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|rd_dstnsap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ultimate destination of pkt */
end_comment

begin_decl_stmt
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* snpa cache info regarding next hop of 										pkt */
end_comment

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|struct
name|esis_fixed
modifier|*
name|pdu
decl_stmt|;
name|int
name|len
decl_stmt|,
name|total_len
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|inbound_shp
operator|->
name|snh_ifp
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|iso_addr
modifier|*
name|rd_gwnsap
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
name|rd_gwnsap
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
operator|)
operator|->
name|siso_addr
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|0
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
block|}
else|else
name|rd_gwnsap
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|siso_addr
expr_stmt|;
if|if
condition|(
name|rt
operator|==
literal|0
operator|||
operator|(
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
operator|)
operator|==
literal|0
operator|||
name|sdl
operator|->
name|sdl_family
operator|!=
name|AF_LINK
condition|)
block|{
comment|/* maybe we should have a function that you 		   could put in the iso_ifaddr structure 		   which could translate iso_addrs into snpa's 		   where there is a known mapping for that address type */
name|esis_stat
operator|.
name|es_badtype
operator|++
expr_stmt|;
return|return;
block|}
name|esis_stat
operator|.
name|es_rdsent
operator|++
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_rdoutput: ifp x%x (%s%d), ht %d, m x%x, oidx x%x\n"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|esis_holding_time
argument_list|,
name|inbound_m
argument_list|,
name|inbound_oidx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tdestination: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|rd_dstnsap
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tredirected toward:%s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|rd_gwnsap
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|m0
operator|=
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|esis_stat
operator|.
name|es_nomem
operator|++
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
expr_stmt|;
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|pdu
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/*pointer arith.; 1st byte after header */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|esis_fixed
argument_list|)
expr_stmt|;
comment|/* 	 *	Build fixed part of header 	 */
name|pdu
operator|->
name|esis_proto_id
operator|=
name|ISO9542_ESIS
expr_stmt|;
name|pdu
operator|->
name|esis_vers
operator|=
name|ESIS_VERSION
expr_stmt|;
name|pdu
operator|->
name|esis_type
operator|=
name|ESIS_RD
expr_stmt|;
name|HTOC
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|esis_holding_time
argument_list|)
expr_stmt|;
comment|/* Insert destination address */
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
name|rd_dstnsap
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Insert the snpa of better next hop */
operator|*
name|cp
operator|++
operator|=
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|cp
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
name|len
operator|+=
operator|(
name|sdl
operator|->
name|sdl_alen
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 	 *	If the next hop is not the destination, then it ought to be 	 *	an IS and it should be inserted next. Else, set the 	 *	NETL to 0 	 */
comment|/* PHASE2 use mask from ifp of outgoing interface */
if|if
condition|(
operator|!
name|iso_addrmatch1
argument_list|(
name|rd_dstnsap
argument_list|,
name|rd_gwnsap
argument_list|)
condition|)
block|{
comment|/* this should not happen: 		if ((nhop_sc->sc_flags& SNPA_IS) == 0) { 			printf("esis_rdoutput: next hop is not dst and not an IS\n"); 			m_freem(m0); 			return; 		} */
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
name|rd_gwnsap
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* NETL */
name|len
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
comment|/* 	 *	PHASE2 	 *	If redirect is to an IS, add an address mask. The mask to be 	 *	used should be the mask present in the routing entry used to 	 *	forward the original data packet. 	 */
comment|/* 	 *	Copy Qos, priority, or security options present in original npdu 	 */
if|if
condition|(
name|inbound_oidx
condition|)
block|{
comment|/* THIS CODE IS CURRENTLY (mostly) UNTESTED */
name|int
name|optlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_qos_formatp
condition|)
name|optlen
operator|+=
operator|(
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_priorp
condition|)
comment|/* priority option is 1 byte long */
name|optlen
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_securep
condition|)
name|optlen
operator|+=
operator|(
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|optlen
condition|)
block|{
name|EXTEND_PACKET
argument_list|(
name|m
argument_list|,
name|m0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* assumes MLEN> optlen */
block|}
comment|/* assume MLEN-len> optlen */
comment|/* 		 *	When copying options, copy from ptr - 2 in order to grab 		 *	the option code and length 		 */
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_qos_formatp
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|inbound_m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|inbound_oidx
operator|->
name|cni_qos_formatp
operator|-
literal|2
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|inbound_oidx
operator|->
name|cni_qos_len
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_priorp
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|inbound_m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|inbound_oidx
operator|->
name|cni_priorp
operator|-
literal|2
argument_list|,
name|cp
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|inbound_oidx
operator|->
name|cni_securep
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|inbound_m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|inbound_oidx
operator|->
name|cni_securep
operator|-
literal|2
argument_list|,
name|cp
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|inbound_oidx
operator|->
name|cni_secure_len
operator|+
literal|2
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|+=
name|optlen
expr_stmt|;
name|len
operator|+=
name|optlen
expr_stmt|;
block|}
name|pdu
operator|->
name|esis_hdr_len
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|iso_gen_csum
argument_list|(
name|m0
argument_list|,
name|ESIS_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|.
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_SNA
expr_stmt|;
name|siso
operator|.
name|siso_nlen
operator|=
literal|6
operator|+
literal|1
expr_stmt|;
comment|/* should be taken from snpa_hdr */
comment|/* +1 is for AFI */
name|bcopy
argument_list|(
name|inbound_shp
operator|->
name|snh_shost
argument_list|,
name|siso
operator|.
name|siso_data
operator|+
literal|1
argument_list|,
literal|6
argument_list|)
expr_stmt|;
call|(
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|siso
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_insert_addr  *  * PURPOSE:			Insert an iso_addr into a buffer  *  * RETURNS:			true if buffer was big enough, else false  *  * SIDE EFFECTS:	Increment buf& len according to size of iso_addr  *  * NOTES:			Plus 1 here is for length byte  */
end_comment

begin_expr_stmt
name|esis_insert_addr
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|isoa
argument_list|,
name|m
argument_list|,
name|nsellen
argument_list|)
specifier|register
name|caddr_t
operator|*
name|buf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ptr to buffer to put address into */
end_comment

begin_decl_stmt
name|int
modifier|*
name|len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to length of buffer so far */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to address */
end_comment

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* determine if there remains space */
end_comment

begin_decl_stmt
name|int
name|nsellen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|newlen
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|isoa
operator|->
name|isoa_len
operator|-=
name|nsellen
expr_stmt|;
name|newlen
operator|=
name|isoa
operator|->
name|isoa_len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newlen
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|isoa
argument_list|,
operator|*
name|buf
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
operator|*
name|len
operator|+=
name|newlen
expr_stmt|;
operator|*
name|buf
operator|+=
name|newlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|newlen
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
name|isoa
operator|->
name|isoa_len
operator|+=
name|nsellen
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|ESIS_EXTRACT_ADDR
parameter_list|(
name|d
parameter_list|,
name|b
parameter_list|)
value|{ d = (struct iso_addr *)(b); b += (1 + *b); \ 	    if (b> buflim) {esis_stat.es_toosmall++; goto bad;}}
end_define

begin_define
define|#
directive|define
name|ESIS_NEXT_OPTION
parameter_list|(
name|b
parameter_list|)
value|{ b += (2 + b[1]); \ 	    if (b> buflim) {esis_stat.es_toosmall++; goto bad;}}
end_define

begin_decl_stmt
name|int
name|ESHonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  /*  * FUNCTION:		esis_eshinput  *  * PURPOSE:			Process an incoming ESH pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_eshinput
argument_list|(
argument|m
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
name|int
name|naddr
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|int
name|new_entry
init|=
literal|0
decl_stmt|;
name|esis_stat
operator|.
name|es_eshrcvd
operator|++
expr_stmt|;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|naddr
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|buf
operator|>=
name|buflim
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|naddr
operator|==
literal|1
condition|)
block|{
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|new_entry
operator|=
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|nsap
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
name|SNPA_ES
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|nsellength
init|=
literal|0
decl_stmt|,
name|nlen
init|=
literal|0
decl_stmt|;
block|{
comment|/* See if we want to compress out multiple nsaps differing 		   only by nsel */
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|shp
operator|->
name|snh_ifp
operator|->
name|if_addrlist
decl_stmt|;
for|for
control|(
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_ISO
condition|)
block|{
name|nsellength
operator|=
operator|(
operator|(
expr|struct
name|iso_ifaddr
operator|*
operator|)
name|ifa
operator|)
operator|->
name|ia_addr
operator|.
name|siso_tlen
expr_stmt|;
break|break;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_eshinput: esh: ht %d, naddr %d nsellength %d\n"
argument_list|,
name|ht
argument_list|,
name|naddr
argument_list|,
name|nsellength
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|naddr
operator|--
operator|>
literal|0
condition|)
block|{
name|struct
name|iso_addr
modifier|*
name|nsap2
decl_stmt|;
name|u_char
modifier|*
name|buf2
decl_stmt|;
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* see if there is at least one more nsap in ESH differing 			   only by nsel */
if|if
condition|(
name|nsellength
operator|!=
literal|0
condition|)
for|for
control|(
name|buf2
operator|=
name|buf
init|;
name|buf2
operator|<
name|buflim
condition|;
control|)
block|{
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap2
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_eshinput: comparing %s "
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"and %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap2
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|Bcmp
argument_list|(
name|nsap
operator|->
name|isoa_genaddr
argument_list|,
name|nsap2
operator|->
name|isoa_genaddr
argument_list|,
name|nsap
operator|->
name|isoa_len
operator|-
name|nsellength
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nlen
operator|=
name|nsellength
expr_stmt|;
break|break;
block|}
block|}
name|new_entry
operator||=
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|nsap
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
name|SNPA_ES
argument_list|,
name|ht
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|nlen
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_eshinput: nsap %s is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap
argument_list|)
argument_list|,
name|new_entry
condition|?
literal|"new"
else|:
literal|"old"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|new_entry
operator|&&
operator|(
name|iso_systype
operator|&
name|SNPA_IS
operator|)
condition|)
name|esis_shoutput
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|,
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
label|:
return|return;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_ishinput  *  * PURPOSE:			process an incoming ISH pdu  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_ishinput
argument_list|(
argument|m
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|,
name|newct
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|nsap
decl_stmt|;
comment|/* Network Entity Title */
specifier|register
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|int
name|new_entry
decl_stmt|;
name|esis_stat
operator|.
name|es_ishrcvd
operator|++
expr_stmt|;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_ishinput: ish: ht %d\n"
argument_list|,
name|ht
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ESHonly
condition|)
goto|goto
name|bad
goto|;
name|ESIS_EXTRACT_ADDR
argument_list|(
name|nsap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
name|ESISOVAL_ESCT
case|:
if|if
condition|(
name|iso_systype
operator|&
name|SNPA_IS
condition|)
break|break;
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|!=
literal|2
condition|)
goto|goto
name|bad
goto|;
name|CTOH
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|,
name|newct
argument_list|)
expr_stmt|;
if|if
condition|(
name|esis_config_time
operator|!=
name|newct
condition|)
block|{
name|untimeout
argument_list|(
name|esis_config
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|esis_config_time
operator|=
name|newct
expr_stmt|;
name|esis_config
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown ISH option: %x\n"
argument_list|,
operator|*
name|buf
argument_list|)
expr_stmt|;
block|}
name|ESIS_NEXT_OPTION
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|new_entry
operator|=
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|nsap
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
name|SNPA_IS
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_ishinput: nsap %s is %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|nsap
argument_list|)
argument_list|,
name|new_entry
condition|?
literal|"new"
else|:
literal|"old"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|new_entry
condition|)
name|esis_shoutput
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|ESIS_ESH
else|:
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
name|shp
operator|->
name|snh_shost
argument_list|,
literal|6
argument_list|,
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|bad
label|:
return|return;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_rdinput  *  * PURPOSE:			Process an incoming RD pdu  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_rdinput
argument_list|(
argument|m0
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* esh pdu */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
name|struct
name|esis_fixed
modifier|*
name|pdu
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
decl_stmt|;
name|u_short
name|ht
decl_stmt|;
comment|/* holding time */
name|struct
name|iso_addr
modifier|*
name|da
decl_stmt|,
modifier|*
name|net
init|=
literal|0
decl_stmt|,
modifier|*
name|netmask
init|=
literal|0
decl_stmt|,
modifier|*
name|snpamask
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|iso_addr
modifier|*
name|bsnpa
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buf
init|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|pdu
operator|+
literal|1
operator|)
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|buflim
init|=
name|pdu
operator|->
name|esis_hdr_len
operator|+
operator|(
name|u_char
operator|*
operator|)
name|pdu
decl_stmt|;
name|esis_stat
operator|.
name|es_rdrcvd
operator|++
expr_stmt|;
comment|/* intermediate systems ignore redirects */
if|if
condition|(
name|iso_systype
operator|&
name|SNPA_IS
condition|)
return|return;
if|if
condition|(
name|ESHonly
condition|)
return|return;
name|CTOH
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|>=
name|buflim
condition|)
return|return;
comment|/* Extract DA */
name|ESIS_EXTRACT_ADDR
argument_list|(
name|da
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Extract better snpa */
name|ESIS_EXTRACT_ADDR
argument_list|(
name|bsnpa
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Extract NET if present */
if|if
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|0
condition|)
name|buf
operator|++
expr_stmt|;
comment|/* no NET present, skip NETL anyway */
else|else
name|ESIS_EXTRACT_ADDR
argument_list|(
name|net
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* process options */
while|while
condition|(
name|buf
operator|<
name|buflim
condition|)
block|{
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
name|ESISOVAL_SNPAMASK
case|:
if|if
condition|(
name|snpamask
condition|)
comment|/* duplicate */
return|return;
name|snpamask
operator|=
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
case|case
name|ESISOVAL_NETMASK
case|:
if|if
condition|(
name|netmask
condition|)
comment|/* duplicate */
return|return;
name|netmask
operator|=
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
operator|(
name|buf
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Unknown option in ESIS RD (0x%x)\n"
argument_list|,
name|buf
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ESIS_NEXT_OPTION
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISINPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_rdinput: rd: ht %d, da %s\n"
argument_list|,
name|ht
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|da
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
name|printf
argument_list|(
literal|"\t: net %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
name|net
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 *	If netl is zero, then redirect is to an ES. We need to add an entry 	 *	to the snpa cache for (destination, better snpa). 	 *	If netl is not zero, then the redirect is to an IS. In this 	 *	case, add an snpa cache entry for (net, better snpa). 	 * 	 *	If the redirect is to an IS, add a route entry towards that 	 *	IS. 	 */
if|if
condition|(
name|net
operator|==
literal|0
operator|||
name|net
operator|->
name|isoa_len
operator|==
literal|0
operator|||
name|snpamask
condition|)
block|{
comment|/* redirect to an ES */
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|da
argument_list|,
name|bsnpa
operator|->
name|isoa_genaddr
argument_list|,
name|SNPA_ES
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snpac_add
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|net
argument_list|,
name|bsnpa
operator|->
name|isoa_genaddr
argument_list|,
name|SNPA_IS
argument_list|,
name|ht
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|snpac_addrt
argument_list|(
name|shp
operator|->
name|snh_ifp
argument_list|,
name|da
argument_list|,
name|net
argument_list|,
name|netmask
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
empty_stmt|;
comment|/* Needed by ESIS_NEXT_OPTION */
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_config  *  * PURPOSE:			Report configuration  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:			Called every esis_config_time seconds  */
end_comment

begin_function
name|void
name|esis_config
parameter_list|()
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|timeout
argument_list|(
name|esis_config
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|hz
operator|*
name|esis_config_time
argument_list|)
expr_stmt|;
comment|/* 	 *	Report configuration for each interface that 	 *	- is UP 	 *	- has BROADCAST capability 	 *	- has an ISO address 	 */
comment|/* Todo: a better way would be to construct the esh or ish 	 * once and copy it out for all devices, possibly calling 	 * a method in the iso_ifaddr structure to encapsulate and 	 * transmit it.  This could work to advantage for non-broadcast media 	 */
for|for
control|(
name|ifp
operator|=
name|ifnet
init|;
name|ifp
condition|;
name|ifp
operator|=
name|ifp
operator|->
name|if_next
control|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
condition|)
block|{
comment|/* search for an ISO address family */
name|struct
name|ifaddr
modifier|*
name|ia
decl_stmt|;
for|for
control|(
name|ia
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ia
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_ISO
condition|)
block|{
name|esis_shoutput
argument_list|(
name|ifp
argument_list|,
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|ESIS_ESH
else|:
name|ESIS_ISH
argument_list|,
name|esis_holding_time
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
name|iso_systype
operator|&
name|SNPA_ES
condition|?
name|all_is_snpa
else|:
name|all_es_snpa
argument_list|)
argument_list|,
literal|6
argument_list|,
operator|(
expr|struct
name|iso_addr
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * FUNCTION:		esis_shoutput  *  * PURPOSE:			Transmit an esh or ish pdu  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|esis_shoutput
argument_list|(
argument|ifp
argument_list|,
argument|type
argument_list|,
argument|ht
argument_list|,
argument|sn_addr
argument_list|,
argument|sn_len
argument_list|,
argument|isoa
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|short
name|ht
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|sn_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sn_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|iso_addr
modifier|*
name|isoa
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|,
name|naddrp
decl_stmt|;
name|int
name|naddr
init|=
literal|0
decl_stmt|;
name|struct
name|esis_fixed
modifier|*
name|pdu
decl_stmt|;
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
name|esis_stat
operator|.
name|es_eshsent
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ESIS_ISH
condition|)
name|esis_stat
operator|.
name|es_ishsent
operator|++
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"esis_shoutput: bad pdu type\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"esis_shoutput: ifp x%x (%s%d), %s, ht %d, to: [%d] "
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|type
operator|==
name|ESIS_ESH
condition|?
literal|"esh"
else|:
literal|"ish"
argument_list|,
name|ht
argument_list|,
name|sn_len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sn_len
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
operator|*
operator|(
name|sn_addr
operator|+
name|i
operator|)
argument_list|,
name|i
operator|<
operator|(
name|sn_len
operator|-
literal|1
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|m0
operator|=
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|esis_stat
operator|.
name|es_nomem
operator|++
expr_stmt|;
return|return;
block|}
name|bzero
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
name|pdu
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|esis_fixed
operator|*
argument_list|)
expr_stmt|;
name|naddrp
operator|=
name|cp
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|pdu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|esis_fixed
argument_list|)
expr_stmt|;
comment|/* 	 *	Build fixed part of header 	 */
name|pdu
operator|->
name|esis_proto_id
operator|=
name|ISO9542_ESIS
expr_stmt|;
name|pdu
operator|->
name|esis_vers
operator|=
name|ESIS_VERSION
expr_stmt|;
name|pdu
operator|->
name|esis_type
operator|=
name|type
expr_stmt|;
name|HTOC
argument_list|(
name|pdu
operator|->
name|esis_ht_msb
argument_list|,
name|pdu
operator|->
name|esis_ht_lsb
argument_list|,
name|ht
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|isoa
condition|)
block|{
comment|/* 		 * Here we are responding to a clnp packet sent to an NSAP 		 * that is ours which was sent to the MAC addr all_es's. 		 * It is possible that we did not specifically advertise this 		 * NSAP, even though it is ours, so we will respond 		 * directly to the sender that we are here.  If we do have 		 * multiple NSEL's we'll tack them on so he can compress them out. 		 */
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
name|isoa
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|naddr
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
name|int
name|nsellen
init|=
operator|(
name|type
operator|==
name|ESIS_ISH
condition|?
name|ia
operator|->
name|ia_addr
operator|.
name|siso_tlen
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|n
init|=
name|ia
operator|->
name|ia_addr
operator|.
name|siso_nlen
decl_stmt|;
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia2
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|ESIS_ISH
operator|&&
name|naddr
operator|>
literal|0
condition|)
break|break;
for|for
control|(
name|ia2
operator|=
name|iso_ifaddr
init|;
name|ia2
operator|!=
name|ia
condition|;
name|ia2
operator|=
name|ia2
operator|->
name|ia_next
control|)
if|if
condition|(
name|Bcmp
argument_list|(
name|ia
operator|->
name|ia_addr
operator|.
name|siso_data
argument_list|,
name|ia2
operator|->
name|ia_addr
operator|.
name|siso_data
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ia2
operator|!=
name|ia
condition|)
continue|continue;
comment|/* Means we have previously copied this nsap */
if|if
condition|(
name|isoa
operator|&&
name|Bcmp
argument_list|(
name|ia
operator|->
name|ia_addr
operator|.
name|siso_data
argument_list|,
name|isoa
operator|->
name|isoa_genaddr
argument_list|,
name|n
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isoa
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* Ditto */
block|}
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"esis_shoutput: adding NSAP %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|!
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
argument_list|,
name|m
argument_list|,
name|nsellen
argument_list|)
condition|)
block|{
name|EXTEND_PACKET
argument_list|(
name|m
argument_list|,
name|m0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|esis_insert_addr
argument_list|(
operator|&
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|ia
operator|->
name|ia_addr
operator|.
name|siso_addr
argument_list|,
name|m
argument_list|,
name|nsellen
argument_list|)
expr_stmt|;
block|}
name|naddr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ESIS_ESH
condition|)
operator|*
name|naddrp
operator|=
name|naddr
expr_stmt|;
else|else
block|{
comment|/* add suggested es config timer option to ISH */
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"esis_shoutput: extending packet\n"
argument_list|)
expr_stmt|;
name|EXTEND_PACKET
argument_list|(
name|m
argument_list|,
name|m0
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|ESISOVAL_ESCT
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|2
expr_stmt|;
name|HTOC
argument_list|(
operator|*
name|cp
argument_list|,
operator|*
operator|(
name|cp
operator|+
literal|1
operator|)
argument_list|,
name|esis_esconfig_time
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|4
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|4
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ESISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"m0 0x%x, m 0x%x, data 0x%x, len %d, cp 0x%x\n"
argument_list|,
name|m0
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|pdu
operator|->
name|esis_hdr_len
operator|=
name|len
expr_stmt|;
name|iso_gen_csum
argument_list|(
name|m0
argument_list|,
name|ESIS_CKSUM_OFF
argument_list|,
operator|(
name|int
operator|)
name|pdu
operator|->
name|esis_hdr_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
argument_list|)
expr_stmt|;
name|siso
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|.
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_SNA
expr_stmt|;
name|siso
operator|.
name|siso_nlen
operator|=
name|sn_len
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|sn_addr
argument_list|,
name|siso
operator|.
name|siso_data
operator|+
literal|1
argument_list|,
operator|(
name|unsigned
operator|)
name|sn_len
argument_list|)
expr_stmt|;
call|(
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|siso
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		isis_input  *  * PURPOSE:			Process an incoming isis packet  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|isis_input
argument_list|(
argument|m0
argument_list|,
argument|shp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ptr to first mbuf of pkt */
end_comment

begin_decl_stmt
name|struct
name|snpa_hdr
modifier|*
name|shp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subnetwork header */
end_comment

begin_block
block|{
specifier|register
name|int
name|type
decl_stmt|;
specifier|register
name|struct
name|rawcb
modifier|*
name|rp
decl_stmt|,
modifier|*
name|first_rp
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|shp
operator|->
name|snh_ifp
decl_stmt|;
name|char
name|workbuf
index|[
literal|16
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISISINPUT
argument_list|)
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"isis_input: pkt on ifp x%x (%s%d): from:"
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|shp
operator|->
name|snh_shost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" to:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%x%c"
argument_list|,
name|shp
operator|->
name|snh_dhost
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|,
operator|(
name|i
operator|<
literal|5
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|esis_dl
operator|.
name|sdl_alen
init|=
name|ifp
operator|->
name|if_addrlen
decl_stmt|;
name|esis_dl
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|bcopy
argument_list|(
name|shp
operator|->
name|snh_shost
argument_list|,
operator|(
name|caddr_t
operator|)
name|esis_dl
operator|.
name|sdl_data
argument_list|,
name|esis_dl
operator|.
name|sdl_alen
argument_list|)
expr_stmt|;
for|for
control|(
name|rp
operator|=
name|esis_pcb
operator|.
name|rcb_next
init|;
name|rp
operator|!=
operator|&
name|esis_pcb
condition|;
name|rp
operator|=
name|rp
operator|->
name|rcb_next
control|)
block|{
if|if
condition|(
name|first_rp
operator|==
literal|0
condition|)
block|{
name|first_rp
operator|=
name|rp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mm
operator|=
name|m_copy
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
condition|)
block|{
comment|/*can't block at interrupt level */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|rp
operator|->
name|rcb_socket
operator|->
name|so_rcv
argument_list|,
operator|&
name|esis_dl
argument_list|,
name|mm
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sorwakeup
argument_list|(
name|rp
operator|->
name|rcb_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDEBUG
argument_list|(
argument|D_ISISINPUT
argument_list|)
name|printf
argument_list|(
literal|"Error in sbappenaddr, mm = 0x%x\n"
argument_list|,
name|mm
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_freem
parameter_list|(
name|mm
parameter_list|)
function_decl|;
block|}
block|}
block|}
if|if
condition|(
name|first_rp
operator|&&
name|sbappendaddr
argument_list|(
operator|&
name|first_rp
operator|->
name|rcb_socket
operator|->
name|so_rcv
argument_list|,
operator|&
name|esis_dl
argument_list|,
name|m0
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sorwakeup
argument_list|(
name|first_rp
operator|->
name|rcb_socket
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|isis_output
argument_list|(
name|sdl
argument_list|,
name|m
argument_list|)
specifier|register
expr|struct
name|sockaddr_dl
operator|*
name|sdl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|ifa_ifwithnet
argument_list|()
decl_stmt|;
name|struct
name|sockaddr_iso
name|siso
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|sn_len
decl_stmt|;
name|ifa
operator|=
name|ifa_ifwithnet
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sdl
argument_list|)
expr_stmt|;
comment|/* get ifp from sdl */
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ISISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"isis_output: interface not found\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|error
init|=
name|EINVAL
decl_stmt|;
goto|goto
name|release
goto|;
block|}
name|ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
name|sn_len
operator|=
name|sdl
operator|->
name|sdl_alen
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ISISOUTPUT
argument_list|)
name|u_char
modifier|*
name|cp
init|=
operator|(
name|u_char
operator|*
operator|)
name|LLADDR
argument_list|(
name|sdl
argument_list|)
decl_stmt|,
modifier|*
name|cplim
init|=
name|cp
operator|+
name|sn_len
decl_stmt|;
name|printf
argument_list|(
literal|"isis_output: ifp 0x%x (%s%d), to: "
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cplim
condition|)
block|{
name|printf
argument_list|(
literal|"%x"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|cp
operator|<
name|cplim
operator|)
condition|?
literal|':'
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|siso
argument_list|,
sizeof|sizeof
argument_list|(
name|siso
argument_list|)
argument_list|)
decl_stmt|;
name|siso
operator|.
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
comment|/* This convention may be useful for X.25 */
name|siso
operator|.
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_SNA
expr_stmt|;
name|siso
operator|.
name|siso_nlen
operator|=
name|sn_len
operator|+
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|siso
operator|.
name|siso_data
operator|+
literal|1
argument_list|,
name|sn_len
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|siso
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_ISISOUTPUT
argument_list|)
name|printf
argument_list|(
literal|"isis_output: error from ether_output is %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
return|return
operator|(
name|error
operator|)
return|;
name|release
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * FUNCTION:		esis_ctlinput  *  * PURPOSE:			Handle the PRC_IFDOWN transition  *  * RETURNS:			nothing  *  * SIDE EFFECTS:  *  * NOTES:			Calls snpac_flush for interface specified.  *					The loop through iso_ifaddr is stupid because  *					back in if_down, we knew the ifp...  */
end_comment

begin_macro
name|esis_ctlinput
argument_list|(
argument|req
argument_list|,
argument|siso
argument_list|)
end_macro

begin_decl_stmt
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* request: we handle only PRC_IFDOWN */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address of ifp */
end_comment

begin_block
block|{
specifier|register
name|struct
name|iso_ifaddr
modifier|*
name|ia
decl_stmt|;
comment|/* scan through interface addresses */
if|if
condition|(
name|req
operator|==
name|PRC_IFDOWN
condition|)
for|for
control|(
name|ia
operator|=
name|iso_ifaddr
init|;
name|ia
condition|;
name|ia
operator|=
name|ia
operator|->
name|ia_next
control|)
block|{
if|if
condition|(
name|iso_addrmatch
argument_list|(
name|IA_SIS
argument_list|(
name|ia
argument_list|)
argument_list|,
name|siso
argument_list|)
condition|)
name|snpac_flushifp
argument_list|(
name|ia
operator|->
name|ia_ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISO */
end_comment

end_unit

