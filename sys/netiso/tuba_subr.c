begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tuba_subr.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_var.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tuba_table.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_iso
name|null_siso
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_siso
argument_list|)
block|,
name|AF_ISO
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tuba_table_size
decl_stmt|,
name|tcp_keepidle
decl_stmt|,
name|tcp_keepintvl
decl_stmt|,
name|tcp_maxidle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tcppcbcachemiss
decl_stmt|,
name|tcppredack
decl_stmt|,
name|tcppreddat
decl_stmt|,
name|tcprexmtthresh
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|tcpiphdr
name|tcp_saveti
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inpcb
name|tuba_inpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|tuba_last_inpcb
init|=
operator|&
name|tuba_inpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isopcb
name|tuba_isopcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tuba initialization  */
end_comment

begin_macro
name|tuba_init
argument_list|()
end_macro

begin_block
block|{
define|#
directive|define
name|TUBAHDRSIZE
value|(3
comment|/*LLC*/
value|+ 9
comment|/*CLNP Fixed*/
value|+ 42
comment|/*Addresses*/
value|\ 		     + 6
comment|/*CLNP Segment*/
value|+ 20
comment|/*TCP*/
value|)
name|tuba_inpcb
operator|.
name|inp_next
operator|=
name|tuba_inpcb
operator|.
name|inp_prev
operator|=
operator|&
name|tuba_inpcb
expr_stmt|;
name|tuba_isopcb
operator|.
name|isop_next
operator|=
name|tuba_isopcb
operator|.
name|isop_prev
operator|=
operator|&
name|tuba_isopcb
expr_stmt|;
name|tuba_isopcb
operator|.
name|isop_faddr
operator|=
operator|&
name|tuba_isopcb
operator|.
name|isop_sfaddr
expr_stmt|;
name|tuba_isopcb
operator|.
name|isop_laddr
operator|=
operator|&
name|tuba_isopcb
operator|.
name|isop_sladdr
expr_stmt|;
if|if
condition|(
name|max_protohdr
operator|<
name|TUBAHDRSIZE
condition|)
name|max_protohdr
operator|=
name|TUBAHDRSIZE
expr_stmt|;
if|if
condition|(
name|max_linkhdr
operator|+
name|TUBAHDRSIZE
operator|>
name|MHLEN
condition|)
name|panic
argument_list|(
literal|"tuba_init"
argument_list|)
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|addr_arg
block|{
name|int
name|error
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|u_long
name|sum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Calculate contribution to fudge factor for TCP checksum,  * and coincidentally set pointer for convenience of clnp_output  * if we are are responding when there is no isopcb around.  */
end_comment

begin_function
specifier|static
name|void
name|tuba_getaddr
parameter_list|(
name|arg
parameter_list|,
name|siso
parameter_list|,
name|index
parameter_list|)
specifier|register
name|struct
name|addr_arg
modifier|*
name|arg
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
modifier|*
name|siso
decl_stmt|;
name|u_long
name|index
decl_stmt|;
block|{
specifier|register
name|struct
name|tuba_cache
modifier|*
name|tc
decl_stmt|;
if|if
condition|(
name|index
operator|<=
name|tuba_table_size
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|siso
condition|)
operator|*
name|siso
operator|=
operator|&
name|tc
operator|->
name|tc_siso
expr_stmt|;
name|arg
operator|->
name|sum
operator|+=
operator|(
name|arg
operator|->
name|offset
operator|&
literal|1
condition|?
name|tc
operator|->
name|tc_ssum
else|:
name|tc
operator|->
name|tc_sum
operator|)
operator|+
operator|(
literal|0xffff
operator|^
name|index
operator|)
expr_stmt|;
name|arg
operator|->
name|offset
operator|+=
name|tc
operator|->
name|tc_siso
operator|.
name|siso_nlen
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|arg
operator|->
name|error
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|tuba_output
argument_list|(
name|m
argument_list|,
name|tp
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|n
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|addr_arg
name|arg
decl_stmt|;
if|if
condition|(
name|tp
operator|==
literal|0
operator|||
operator|(
name|n
operator|=
name|tp
operator|->
name|t_template
operator|)
operator|==
literal|0
operator|||
operator|(
name|isop
operator|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tp
operator|->
name|t_tuba_pcb
operator|)
operator|==
literal|0
condition|)
block|{
name|isop
operator|=
operator|&
name|tuba_isopcb
expr_stmt|;
name|n
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|arg
operator|.
name|error
operator|=
name|arg
operator|.
name|sum
operator|=
name|arg
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|arg
argument_list|,
operator|&
name|tuba_isopcb
operator|.
name|isop_faddr
argument_list|,
name|n
operator|->
name|ti_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|arg
argument_list|,
operator|&
name|tuba_isopcb
operator|.
name|isop_laddr
argument_list|,
name|n
operator|->
name|ti_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|REDUCE
argument_list|(
name|arg
operator|.
name|sum
argument_list|,
name|arg
operator|.
name|sum
argument_list|)
expr_stmt|;
goto|goto
name|adjust
goto|;
block|}
if|if
condition|(
name|n
operator|->
name|ti_sum
operator|==
literal|0
condition|)
block|{
name|arg
operator|.
name|error
operator|=
name|arg
operator|.
name|sum
operator|=
name|arg
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|arg
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|n
operator|->
name|ti_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|tuba_getaddr
argument_list|(
operator|&
name|arg
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|*
operator|)
literal|0
argument_list|,
name|n
operator|->
name|ti_src
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|REDUCE
argument_list|(
name|arg
operator|.
name|sum
argument_list|,
name|arg
operator|.
name|sum
argument_list|)
expr_stmt|;
name|n
operator|->
name|ti_sum
operator|=
name|arg
operator|.
name|sum
expr_stmt|;
name|n
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|adjust
label|:
if|if
condition|(
name|arg
operator|.
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|REDUCE
argument_list|(
name|n
operator|->
name|ti_sum
argument_list|,
name|n
operator|->
name|ti_sum
operator|+
operator|(
literal|0xffff
operator|^
name|arg
operator|.
name|sum
operator|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|clnp_output
argument_list|(
name|m
argument_list|,
name|isop
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|tuba_refcnt
argument_list|(
argument|isop
argument_list|,
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tuba_cache
modifier|*
name|tc
decl_stmt|;
name|unsigned
name|index
decl_stmt|,
name|sum
decl_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|1
condition|)
name|delta
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isop
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_faddr
operator|==
literal|0
operator|||
name|isop
operator|->
name|isop_laddr
operator|==
literal|0
operator|||
operator|(
name|delta
operator|==
operator|-
literal|1
operator|&&
name|isop
operator|->
name|isop_tuba_cached
operator|==
literal|0
operator|)
operator|||
operator|(
name|delta
operator|==
literal|1
operator|&&
name|isop
operator|->
name|isop_tuba_cached
operator|!=
literal|0
operator|)
condition|)
return|return;
name|isop
operator|->
name|isop_tuba_cached
operator|=
operator|(
name|delta
operator|==
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|tuba_lookup
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|delta
operator|==
literal|1
operator|||
name|tc
operator|->
name|tc_refcnt
operator|>
literal|0
operator|)
condition|)
name|tc
operator|->
name|tc_refcnt
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|index
operator|=
name|tuba_lookup
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|tc
operator|=
name|tuba_table
index|[
name|index
index|]
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|delta
operator|==
literal|1
operator|||
name|tc
operator|->
name|tc_refcnt
operator|>
literal|0
operator|)
condition|)
name|tc
operator|->
name|tc_refcnt
operator|+=
name|delta
expr_stmt|;
block|}
end_block

begin_macro
name|tuba_pcbdetach
argument_list|(
argument|isop
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|isop
operator|==
literal|0
condition|)
return|return;
name|tuba_refcnt
argument_list|(
name|isop
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_socket
operator|=
literal|0
expr_stmt|;
name|iso_pcbdetach
argument_list|(
name|isop
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Avoid  in_pcbconnect in faked out tcp_input()  */
end_comment

begin_expr_stmt
name|tuba_pcbconnect
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|)
specifier|register
expr|struct
name|inpcb
operator|*
name|inp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
decl_stmt|;
name|struct
name|tcpcb
modifier|*
name|tp
init|=
name|intotcpcb
argument_list|(
name|inp
argument_list|)
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tp
operator|->
name|t_tuba_pcb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* hardwire iso_pcbbind() here */
name|siso
operator|=
name|isop
operator|->
name|isop_laddr
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
operator|*
name|siso
operator|=
name|tuba_table
index|[
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
index|]
operator|->
name|tc_siso
expr_stmt|;
name|siso
operator|->
name|siso_tlen
operator|=
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_lport
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_lport
argument_list|,
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_lport
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hardwire in_pcbconnect() here without assigning route */
name|inp
operator|->
name|inp_fport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
name|inp
operator|->
name|inp_faddr
operator|=
name|sin
operator|->
name|sin_addr
expr_stmt|;
comment|/* reuse nam argument to call iso_pcbconnect() */
name|nam
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
expr_stmt|;
name|siso
operator|=
name|mtod
argument_list|(
name|nam
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
operator|*
name|siso
operator|=
name|tuba_table
index|[
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
index|]
operator|->
name|tc_siso
expr_stmt|;
name|siso
operator|->
name|siso_tlen
operator|=
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_fport
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|inp
operator|->
name|inp_fport
argument_list|,
name|TSEL
argument_list|(
name|siso
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|inp_fport
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|iso_pcbconnect
argument_list|(
name|isop
argument_list|,
name|nam
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tuba_refcnt
argument_list|(
name|isop
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  * 	clnp's input routine, indirectly through the protosw.  * FUNCTION and ARGUMENTS:  * Take a packet (m) from clnp, strip off the clnp header  * and do tcp input processing.  * No return value.  */
end_comment

begin_expr_stmt
name|tuba_tcpinput
argument_list|(
name|m
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
specifier|register
expr|struct
name|mbuf
operator|*
name|m
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sockaddr_iso
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|unsigned
name|long
name|sum
decl_stmt|,
name|lindex
decl_stmt|,
name|findex
decl_stmt|;
specifier|register
name|struct
name|tcpiphdr
modifier|*
name|ti
decl_stmt|;
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|caddr_t
name|optp
init|=
name|NULL
decl_stmt|;
name|int
name|optlen
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|struct
name|tcpcb
modifier|*
name|tp
init|=
literal|0
decl_stmt|;
name|int
name|tiflags
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|todrop
decl_stmt|,
name|acked
decl_stmt|,
name|ourfinisacked
decl_stmt|,
name|needoutput
init|=
literal|0
decl_stmt|;
name|short
name|ostate
decl_stmt|;
name|struct
name|in_addr
name|laddr
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|,
name|iss
init|=
literal|0
decl_stmt|;
name|u_long
name|tiwin
decl_stmt|,
name|ts_val
decl_stmt|,
name|ts_ecr
decl_stmt|;
name|int
name|ts_present
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tuba_tcpinput"
argument_list|)
expr_stmt|;
comment|/* 	 * Do some housekeeping looking up CLNP addresses. 	 * If we are out of space might as well drop the packet now. 	 */
name|tcpstat
operator|.
name|tcps_rcvtotal
operator|++
expr_stmt|;
name|lindex
operator|=
name|tuba_lookup
argument_list|(
name|dst
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|findex
operator|=
name|tuba_lookup
argument_list|(
name|src
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|lindex
operator|==
literal|0
operator|||
name|findex
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * CLNP gave us an mbuf chain WITH the clnp header pulled up, 	 * but the data pointer pushed past it. 	 */
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|tlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
expr_stmt|;
comment|/* XXX should do this in clnp_input */
comment|/* 	 * The reassembly code assumes it will be overwriting a useless 	 * part of the packet, which is why we need to have it point 	 * into the packet itself. 	 * 	 * Check to see if the data is properly alligned 	 * so that we can save copying the tcp header. 	 * This code knows way too much about the structure of mbufs! 	 */
name|off
operator|=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|?
operator|(
name|m
operator|->
name|m_data
operator|-
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|)
else|:
operator|(
name|m
operator|->
name|m_data
operator|-
name|m
operator|->
name|m_pktdat
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|off
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m0
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|=
name|m0
operator|->
name|m_pkthdr
expr_stmt|;
name|m
operator|->
name|m_flags
operator|=
name|m0
operator|->
name|m_flags
operator|&
name|M_COPYFLAGS
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tcpiphdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Calculate checksum of extended TCP header and data, 	 * replacing what would have been IP addresses by 	 * the IP checksum of the CLNP addresses. 	 */
name|ti
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tcpiphdr
operator|*
argument_list|)
expr_stmt|;
name|ti
operator|->
name|ti_dst
operator|.
name|s_addr
operator|=
name|tuba_table
index|[
name|lindex
index|]
operator|->
name|tc_sum
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|siso_nlen
operator|&
literal|1
condition|)
name|ti
operator|->
name|ti_src
operator|.
name|s_addr
operator|=
name|tuba_table
index|[
name|findex
index|]
operator|->
name|tc_sum
expr_stmt|;
else|else
name|ti
operator|->
name|ti_src
operator|.
name|s_addr
operator|=
name|tuba_table
index|[
name|findex
index|]
operator|->
name|tc_ssum
expr_stmt|;
name|ti
operator|->
name|ti_prev
operator|=
name|ti
operator|->
name|ti_next
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|ti_x1
operator|=
literal|0
expr_stmt|;
name|ti
operator|->
name|ti_pr
operator|=
name|ISOPROTO_TCP
expr_stmt|;
name|ti
operator|->
name|ti_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|ti_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
condition|)
block|{
name|tcpstat
operator|.
name|tcps_rcvbadsum
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|ti
operator|->
name|ti_src
operator|.
name|s_addr
operator|=
name|findex
expr_stmt|;
name|ti
operator|->
name|ti_dst
operator|.
name|s_addr
operator|=
name|lindex
expr_stmt|;
comment|/* 	 * Now include the rest of TCP input 	 */
define|#
directive|define
name|TUBA_INCLUDE
define|#
directive|define
name|in_pcbconnect
value|tuba_pcbconnect
define|#
directive|define
name|tcb
value|tuba_inpcb
define|#
directive|define
name|tcp_last_inpcb
value|tuba_last_inpcb
include|#
directive|include
file|<netinet/tcp_input.c>
block|}
end_block

begin_define
define|#
directive|define
name|tcp_slowtimo
value|tuba_slowtimo
end_define

begin_define
define|#
directive|define
name|tcp_fasttimo
value|tuba_fasttimo
end_define

begin_include
include|#
directive|include
file|<netinet/tcp_timer.c>
end_include

end_unit

