begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_timer.c	7.5 (Berkeley) 5/6/91  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: /a/cvs/386BSD/src/sys/netiso/tp_timer.c,v 1.1.1.1 1993/06/12 14:57:17 rgrimes Exp $  * $Source: /a/cvs/386BSD/src/sys/netiso/tp_timer.c,v $  *  * Contains all the timer code.    * There are two sources of calls to these routines:  * the clock, and tp.trans. (ok, and tp_pcb.c calls it at init time)  *  * Timers come in two flavors - those that generally get  * cancelled (tp_ctimeout, tp_cuntimeout)  * and those that either usually expire (tp_etimeout,   * tp_euntimeout, tp_slowtimo) or may require more than one instance  * of the timer active at a time.  *  * The C timers are stored in the tp_ref structure. Their "going off"  * is manifested by a driver event of the TM_xxx form.  *  * The E timers are handled like the generic kernel callouts.  * Their "going off" is manifested by a function call w/ 3 arguments.  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_decl_stmt
name|struct
name|Ecallout
modifier|*
name|TP_callfree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|Ecallout
modifier|*
name|TP_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_ref
modifier|*
name|tp_ref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|N_TPREF
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tp_maxrefopen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* highest ref # of an open tp connection */
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  at autoconfig time from tp_init()   * 	a combo of event, state, predicate  * FUNCTION and ARGUMENTS:  *  initialize data structures for the timers  */
end_comment

begin_function
name|void
name|tp_timerinit
parameter_list|()
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|e
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
define|#
directive|define
name|GETME
parameter_list|(
name|x
parameter_list|,
name|t
parameter_list|,
name|n
parameter_list|)
value|{s = (n)*sizeof(*x); x = (t) malloc(s, M_PCB, M_NOWAIT);\ if (x == 0) panic("tp_timerinit"); bzero((caddr_t)x, s);}
comment|/* 	 * Initialize storage 	 */
name|GETME
argument_list|(
name|TP_callout
argument_list|,
expr|struct
name|Ecallout
operator|*
argument_list|,
literal|2
operator|*
name|N_TPREF
argument_list|)
expr_stmt|;
name|GETME
argument_list|(
name|tp_ref
argument_list|,
expr|struct
name|tp_ref
operator|*
argument_list|,
literal|1
operator|+
name|N_TPREF
argument_list|)
expr_stmt|;
name|TP_callfree
operator|=
name|TP_callout
operator|+
operator|(
operator|(
literal|2
operator|*
name|N_TPREF
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|e
operator|=
name|TP_callfree
init|;
name|e
operator|>
name|TP_callout
condition|;
name|e
operator|--
control|)
name|e
operator|->
name|c_next
operator|=
name|e
operator|-
literal|1
expr_stmt|;
comment|/* hate to do this but we really don't want zero to be a legit ref */
name|tp_maxrefopen
operator|=
literal|1
expr_stmt|;
name|tp_ref
index|[
literal|0
index|]
operator|.
name|tpr_state
operator|=
name|REF_FROZEN
expr_stmt|;
comment|/* white lie -- no ref timer, don't 		* want this one to be allocated- ever 		* unless, of course, you make refs and address instead of an 		* index - then 0 can be allocated 		*/
undef|#
directive|undef
name|GETME
block|}
end_function

begin_comment
comment|/**********************  e timers *************************/
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  tp_slowtimo() every 1/2 second, for each open reference  * FUNCTION and ARGUMENTS:  *  (refp) indicates a reference structure that is in use.  *  This ref structure may contain active E-type timers.  *  Update the timers and if any expire, create an event and  *  call the driver.  */
end_comment

begin_function
specifier|static
name|void
name|tp_Eclock
parameter_list|(
name|refp
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
comment|/* the reference structure */
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|p1
decl_stmt|;
comment|/* to drift through the list of callouts */
name|struct
name|tp_event
name|E
decl_stmt|;
comment|/* event to pass to tp_driver() */
name|int
name|tp_driver
parameter_list|()
function_decl|;
comment|/* drives the FSM */
comment|/* 	 * Update real-time timeout queue. 	 * At front of queue are some number of events which are ``due''. 	 * The time to these is<= 0 and if negative represents the 	 * number of ticks which have passed since it was supposed to happen. 	 * The rest of the q elements (times> 0) are events yet to happen, 	 * where the time for each is given as a delta from the previous. 	 * Decrementing just the first of these serves to decrement the time 	 * to all events. 	 *  	 * This version, which calls the driver directly, doesn't pass 	 * along the ticks - may want to add the ticks if there's any use 	 * for them. 	 */
name|IncStat
argument_list|(
name|ts_Eticks
argument_list|)
expr_stmt|;
name|p1
operator|=
name|refp
operator|->
name|tpr_calltodo
operator|.
name|c_next
expr_stmt|;
while|while
condition|(
name|p1
condition|)
block|{
if|if
condition|(
operator|--
name|p1
operator|->
name|c_time
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|p1
operator|->
name|c_time
operator|==
literal|0
condition|)
break|break;
name|p1
operator|=
name|p1
operator|->
name|c_next
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
name|refp
operator|->
name|tpr_calltodo
operator|.
name|c_next
operator|)
operator|==
literal|0
operator|||
name|p1
operator|->
name|c_time
operator|>
literal|0
condition|)
block|{
break|break;
block|}
name|refp
operator|->
name|tpr_calltodo
operator|.
name|c_next
operator|=
name|p1
operator|->
name|c_next
expr_stmt|;
name|p1
operator|->
name|c_next
operator|=
name|TP_callfree
expr_stmt|;
ifndef|#
directive|ifndef
name|lint
name|E
operator|.
name|ev_number
operator|=
name|p1
operator|->
name|c_func
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_low
operator|=
operator|(
name|SeqNum
operator|)
name|p1
operator|->
name|c_arg1
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_high
operator|=
operator|(
name|SeqNum
operator|)
name|p1
operator|->
name|c_arg2
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|TM_data_retrans
argument_list|)
operator|.
name|e_retrans
operator|=
name|p1
operator|->
name|c_arg3
expr_stmt|;
endif|#
directive|endif
endif|lint
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"E expired! event 0x%x (0x%x,0x%x), pcb 0x%x ref %d\n"
argument_list|,
name|p1
operator|->
name|c_func
argument_list|,
name|p1
operator|->
name|c_arg1
argument_list|,
name|p1
operator|->
name|c_arg2
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|TP_callfree
init|=
name|p1
decl_stmt|;
name|IncStat
argument_list|(
name|ts_Eexpired
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tp_driver
argument_list|(
name|tpcb
operator|=
name|refp
operator|->
name|tpr_pcb
argument_list|,
operator|&
name|E
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|c_func
operator|==
name|TM_reference
operator|&&
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSED
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
comment|/* XXX wart; where else to do it? */
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  * Set an E type timer.  (refp) is the ref structure.  * Causes  fun(arg1,arg2,arg3) to be called after time t.  */
end_comment

begin_function
name|void
name|tp_etimeout
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|ticks
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
comment|/* function to be called */
name|u_int
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|int
name|arg3
decl_stmt|;
specifier|register
name|int
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|pnew
decl_stmt|;
comment|/* p1 and p2 drift through the list of timeout callout structures, 		 * pnew points to the newly created callout structure 		 */
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"etimeout pcb 0x%x state 0x%x\n"
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|refp
operator|->
name|tpr_pcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_etimeout ref refstate tks Etick"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|refp
operator|->
name|tpr_state
argument_list|,
name|ticks
argument_list|,
name|tp_stat
operator|.
name|ts_Eticks
argument_list|)
decl_stmt|;
name|ENDTRACE
name|IncStat
argument_list|(
name|ts_Eset
argument_list|)
decl_stmt|;
if|if
condition|(
name|ticks
operator|==
literal|0
condition|)
name|ticks
operator|=
literal|1
expr_stmt|;
name|pnew
operator|=
name|TP_callfree
expr_stmt|;
if|if
condition|(
name|pnew
operator|==
operator|(
expr|struct
name|Ecallout
operator|*
operator|)
literal|0
condition|)
name|panic
argument_list|(
literal|"tp timeout table overflow"
argument_list|)
expr_stmt|;
name|TP_callfree
operator|=
name|pnew
operator|->
name|c_next
expr_stmt|;
name|pnew
operator|->
name|c_arg1
operator|=
name|arg1
expr_stmt|;
name|pnew
operator|->
name|c_arg2
operator|=
name|arg2
expr_stmt|;
name|pnew
operator|->
name|c_arg3
operator|=
name|arg3
expr_stmt|;
name|pnew
operator|->
name|c_func
operator|=
name|fun
expr_stmt|;
for|for
control|(
name|p1
operator|=
operator|&
operator|(
name|refp
operator|->
name|tpr_calltodo
operator|)
init|;
operator|(
name|p2
operator|=
name|p1
operator|->
name|c_next
operator|)
operator|&&
name|p2
operator|->
name|c_time
operator|<
name|ticks
condition|;
name|p1
operator|=
name|p2
control|)
if|if
condition|(
name|p2
operator|->
name|c_time
operator|>
literal|0
condition|)
name|ticks
operator|-=
name|p2
operator|->
name|c_time
expr_stmt|;
name|p1
operator|->
name|c_next
operator|=
name|pnew
expr_stmt|;
name|pnew
operator|->
name|c_next
operator|=
name|p2
expr_stmt|;
name|pnew
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|p2
condition|)
name|p2
operator|->
name|c_time
operator|-=
name|ticks
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans all over  * FUNCTION and ARGUMENTS:  *  Cancel all occurrences of E-timer function (fun) for reference (refp)  */
end_comment

begin_function
name|void
name|tp_euntimeout
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
comment|/* ptrs to drift through the list */
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_euntimeout ref"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|p1
init|=
operator|&
name|refp
operator|->
name|tpr_calltodo
decl_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|c_next
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|c_func
operator|==
name|fun
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|c_next
operator|&&
name|p2
operator|->
name|c_time
operator|>
literal|0
condition|)
name|p2
operator|->
name|c_next
operator|->
name|c_time
operator|+=
name|p2
operator|->
name|c_time
expr_stmt|;
name|p1
operator|->
name|c_next
operator|=
name|p2
operator|->
name|c_next
expr_stmt|;
name|p2
operator|->
name|c_next
operator|=
name|TP_callfree
expr_stmt|;
name|TP_callfree
operator|=
name|p2
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Ecan_act
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans, when an incoming ACK causes things to be dropped  *  from the retransmission queue, and we want their associated  *  timers to be cancelled.  * FUNCTION and ARGUMENTS:  *  cancel all occurrences of function (fun) where (arg2)< (seq)  */
end_comment

begin_function
name|void
name|tp_euntimeout_lss
parameter_list|(
name|refp
parameter_list|,
name|fun
parameter_list|,
name|seq
parameter_list|)
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|fun
decl_stmt|;
name|SeqNum
name|seq
decl_stmt|;
block|{
specifier|register
name|struct
name|Ecallout
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_euntimeoutLSS ref"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|p1
init|=
operator|&
name|refp
operator|->
name|tpr_calltodo
decl_stmt|;
while|while
condition|(
operator|(
name|p2
operator|=
name|p1
operator|->
name|c_next
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p2
operator|->
name|c_func
operator|==
name|fun
operator|)
operator|&&
name|SEQ_LT
argument_list|(
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|p2
operator|->
name|c_arg2
argument_list|,
name|seq
argument_list|)
condition|)
block|{
if|if
condition|(
name|p2
operator|->
name|c_next
operator|&&
name|p2
operator|->
name|c_time
operator|>
literal|0
condition|)
name|p2
operator|->
name|c_next
operator|->
name|c_time
operator|+=
name|p2
operator|->
name|c_time
expr_stmt|;
name|p1
operator|->
name|c_next
operator|=
name|p2
operator|->
name|c_next
expr_stmt|;
name|p2
operator|->
name|c_next
operator|=
name|TP_callfree
expr_stmt|;
name|TP_callfree
operator|=
name|p2
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Ecan_act
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|p1
operator|=
name|p2
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****************  c timers **********************  *  * These are not chained together; they sit  * in the tp_ref structure. they are the kind that  * are typically cancelled so it's faster not to  * mess with the chains  */
end_comment

begin_comment
comment|/*  * CALLED FROM:  *  the clock, every 500 ms  * FUNCTION and ARGUMENTS:  *  Look for open references with active timers.  *  If they exist, call the appropriate timer routines to update  *  the timers and possibly generate events.  *  (The E timers are done in other procedures; the C timers are  *  updated here, and events for them are generated here.)  */
end_comment

begin_function
name|ProtoHook
name|tp_slowtimo
parameter_list|()
block|{
specifier|register
name|int
name|r
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|Ccallout
modifier|*
name|cp
decl_stmt|;
name|struct
name|tp_ref
modifier|*
name|rp
init|=
name|tp_ref
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* check only open reference structures */
name|IncStat
argument_list|(
name|ts_Cticks
argument_list|)
expr_stmt|;
name|rp
operator|++
expr_stmt|;
comment|/* tp_ref[0] is never used */
for|for
control|(
name|r
operator|=
literal|1
init|;
operator|(
name|r
operator|<=
name|tp_maxrefopen
operator|)
condition|;
name|r
operator|++
operator|,
name|rp
operator|++
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|tpr_state
operator|<
name|REF_OPEN
condition|)
continue|continue;
comment|/* check the C-type timers */
name|cp
operator|=
name|rp
operator|->
name|tpr_callout
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|N_CTIMERS
condition|;
name|t
operator|++
operator|,
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|cp
operator|->
name|c_active
condition|)
block|{
if|if
condition|(
operator|--
name|cp
operator|->
name|c_time
operator|<=
literal|0
condition|)
block|{
name|cp
operator|->
name|c_active
operator|=
name|FALSE
expr_stmt|;
name|E
operator|.
name|ev_number
operator|=
name|t
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"C expired! type 0x%x\n"
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
argument_list|(
name|ts_Cexpired
argument_list|)
decl_stmt|;
name|tp_driver
argument_list|(
name|rp
operator|->
name|tpr_pcb
argument_list|,
operator|&
name|E
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* now update the list */
name|tp_Eclock
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans, tp_emit()  * FUNCTION and ARGUMENTS:  * 	Set a C type timer of type (which) to go off after (ticks) time.  */
end_comment

begin_function
name|void
name|tp_ctimeout
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
init|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout ref which tpcb active"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|refp
operator|-
name|tp_ref
argument_list|)
argument_list|,
name|which
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|cp
operator|->
name|c_active
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|cp
operator|->
name|c_active
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
name|cp
operator|->
name|c_active
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans   * FUNCTION and ARGUMENTS:  * 	Version of tp_ctimeout that resets the C-type time if the   * 	parameter (ticks) is> the current value of the timer.  */
end_comment

begin_function
name|void
name|tp_ctimeout_MIN
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|,
name|ticks
parameter_list|)
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
name|int
name|which
decl_stmt|,
name|ticks
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
init|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctimeout_MIN ref which tpcb active"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|refp
operator|-
name|tp_ref
argument_list|)
argument_list|,
name|which
argument_list|,
name|refp
operator|->
name|tpr_pcb
argument_list|,
name|cp
operator|->
name|c_active
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|cp
operator|->
name|c_active
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_Cset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|c_active
condition|)
name|cp
operator|->
name|c_time
operator|=
name|MIN
argument_list|(
name|ticks
argument_list|,
name|cp
operator|->
name|c_time
argument_list|)
expr_stmt|;
else|else
block|{
name|cp
operator|->
name|c_time
operator|=
name|ticks
expr_stmt|;
name|cp
operator|->
name|c_active
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp.trans  * FUNCTION and ARGUMENTS:  *  Cancel the (which) timer in the ref structure indicated by (refp).  */
end_comment

begin_function
name|void
name|tp_cuntimeout
parameter_list|(
name|refp
parameter_list|,
name|which
parameter_list|)
name|int
name|which
decl_stmt|;
specifier|register
name|struct
name|tp_ref
modifier|*
name|refp
decl_stmt|;
block|{
specifier|register
name|struct
name|Ccallout
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|&
operator|(
name|refp
operator|->
name|tpr_callout
index|[
name|which
index|]
operator|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TIMER
argument_list|)
name|printf
argument_list|(
literal|"tp_cuntimeout(0x%x, %d) active %d\n"
argument_list|,
name|refp
argument_list|,
name|which
argument_list|,
name|cp
operator|->
name|c_active
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_TIMER
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_cuntimeout ref which, active"
argument_list|,
name|refp
operator|-
name|tp_ref
argument_list|,
name|which
argument_list|,
name|cp
operator|->
name|c_active
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|cp
operator|->
name|c_active
condition|)
name|IncStat
argument_list|(
name|ts_Ccan_act
argument_list|)
expr_stmt|;
else|else
name|IncStat
argument_list|(
name|ts_Ccan_inact
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_active
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

end_unit

