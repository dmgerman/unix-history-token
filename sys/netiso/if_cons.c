begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)if_cons.c	7.10 (Berkeley) 5/29/91  *	$Id$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * cons.c - Connection Oriented Network Service:  * including support for a) user transport-level service,   *	b) COSNS below CLNP, and c) CONS below TP.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TPCONS
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|Static
end_define

begin_decl_stmt
name|unsigned
name|LAST_CALL_PCB
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|ARGO_DEBUG
end_else

begin_define
define|#
directive|define
name|Static
value|static
end_define

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOCK_STREAM
end_ifndef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"tsleep.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"../net/netisr.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso_errno.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"cons.h"
end_include

begin_include
include|#
directive|include
file|"iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/x25.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/pk.h"
end_include

begin_include
include|#
directive|include
file|"../netccitt/pk_var.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|MT_XCONN
value|0x50
end_define

begin_define
define|#
directive|define
name|MT_XCLOSE
value|0x51
end_define

begin_define
define|#
directive|define
name|MT_XCONFIRM
value|0x52
end_define

begin_define
define|#
directive|define
name|MT_XDATA
value|0x53
end_define

begin_define
define|#
directive|define
name|MT_XHEADER
value|0x54
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MT_XCONN
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XCLOSE
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XCONFIRM
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XDATA
value|MT_DATA
end_define

begin_define
define|#
directive|define
name|MT_XHEADER
value|MT_HEADER
end_define

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_define
define|#
directive|define
name|DONTCLEAR
value|-1
end_define

begin_comment
comment|/*********************************************************************	  * cons.c - CONS interface to the x.25 layer  *  * TODO: figure out what resources we might run out of besides mbufs.  *  If we run out of any of them (including mbufs) close and recycle  *  lru x% of the connections, for some parameter x.  *  * There are 2 interfaces from above:  * 1) from TP0:   *    cons CO network service  *    TP associates a transport connection with a network connection.  * 	  cons_output( isop, m, len, isdgm==0 )   *        co_flags == 0  * 2) from TP4:  *	  It's a datagram service, like clnp is. - even though it calls  *			cons_output( isop, m, len, isdgm==1 )   *	  it eventually goes through  *			cosns_output(ifp, m, dst).  *    TP4 permits multiplexing (reuse, possibly simultaneously) of the   *	  network connections.  *    This means that many sockets (many tpcbs) may be associated with  *    this pklcd, hence cannot have a back ptr from pklcd to a tpcb.  *        co_flags& CONSF_DGM   *    co_socket is null since there may be many sockets that use this pklcd.  * NOTE: 	streams would really be nice. sigh. NOTE: 	PVCs could be handled by config-ing a cons with an address and with the 	IFF_POINTTOPOINT flag on.  This code would then have to skip the 	connection setup stuff for pt-to-pt links.      *********************************************************************/
end_comment

begin_define
define|#
directive|define
name|CONS_IFQMAXLEN
value|5
end_define

begin_comment
comment|/* protosw pointers for getting to higher layer */
end_comment

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|CLNP_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|TP_proto
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|struct
name|protosw
modifier|*
name|X25_proto
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Static
name|int
name|issue_clear_req
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|PHASEONE
end_ifndef

begin_function_decl
specifier|extern
name|struct
name|ifaddr
modifier|*
name|ifa_ifwithnet
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
endif|PHASEONE
end_endif

begin_function_decl
specifier|extern
name|struct
name|ifaddr
modifier|*
name|ifa_ifwithaddr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|Static
name|struct
name|socket
name|dummysocket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use by cosns */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|isopcb
name|tp_isopcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chain of all TP pcbs */
end_comment

begin_decl_stmt
name|struct
name|isopcb
name|tp_incoming_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* incoming connections 										for TP, pending */
end_comment

begin_decl_stmt
name|struct
name|isopcb
modifier|*
name|Xpcblist
index|[]
init|=
block|{
operator|&
name|tp_incoming_pending
block|,
operator|&
name|tp_isopcb
block|,
operator|(
expr|struct
name|isopcb
operator|*
operator|)
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|int
name|parse_facil
argument_list|()
decl_stmt|,
name|NSAPtoDTE
argument_list|()
decl_stmt|,
name|make_partial_x25_packet
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Static
name|int
name|FACILtoNSAP
argument_list|()
decl_stmt|,
name|DTEtoNSAP
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Static
name|struct
name|pklcd
modifier|*
name|cons_chan_to_pcb
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|HIGH_NIBBLE
value|1
end_define

begin_define
define|#
directive|define
name|LOW_NIBBLE
value|0
end_define

begin_comment
comment|/*  * NAME:	nibble_copy()  * FUNCTION and ARGUMENTS:  * 	copies (len) nibbles from (src_octet), high or low nibble  *  to (dst_octet), high or low nibble,  * src_nibble& dst_nibble should be:  * 	HIGH_NIBBLE (1) if leftmost 4 bits/ most significant nibble  * 	LOW_NIBBLE (0) if rightmost 4 bits/ least significant nibble  * RETURNS: VOID  */
end_comment

begin_function
name|void
name|nibble_copy
parameter_list|(
name|src_octet
parameter_list|,
name|src_nibble
parameter_list|,
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src_octet
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst_octet
decl_stmt|;
specifier|register
name|unsigned
name|src_nibble
decl_stmt|;
specifier|register
name|unsigned
name|dst_nibble
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|unsigned
name|dshift
decl_stmt|,
name|sshift
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_copy ( 0x%x, 0x%x, 0x%x, 0x%x 0x%x)\n"
argument_list|,
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|SHIFT
value|0x4
name|dshift
init|=
name|dst_nibble
operator|<<
literal|2
decl_stmt|;
name|sshift
operator|=
name|src_nibble
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* clear dst_nibble  */
operator|*
name|dst_octet
operator|&=
operator|~
operator|(
literal|0xf
operator|<<
name|dshift
operator|)
expr_stmt|;
comment|/* set dst nibble */
operator|*
name|dst_octet
operator||=
operator|(
literal|0xf
operator|&
operator|(
operator|*
name|src_octet
operator|>>
name|sshift
operator|)
operator|)
operator|<<
name|dshift
expr_stmt|;
name|dshift
operator|^=
name|SHIFT
expr_stmt|;
name|sshift
operator|^=
name|SHIFT
expr_stmt|;
name|src_nibble
operator|=
literal|1
operator|-
name|src_nibble
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|src_octet
operator|+=
name|src_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_copy DONE\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_function

begin_comment
comment|/*  * NAME:	nibble_match()  * FUNCTION and ARGUMENTS:  * 	compares src_octet/src_nibble and dst_octet/dst_nibble  for len nibbles.  * RETURNS: 0 if they differ, 1 if they are the same.  */
end_comment

begin_function
name|int
name|nibble_match
parameter_list|(
name|src_octet
parameter_list|,
name|src_nibble
parameter_list|,
name|dst_octet
parameter_list|,
name|dst_nibble
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|src_octet
decl_stmt|;
specifier|register
name|char
modifier|*
name|dst_octet
decl_stmt|;
specifier|register
name|unsigned
name|src_nibble
decl_stmt|;
specifier|register
name|unsigned
name|dst_nibble
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
specifier|register
name|unsigned
name|dshift
decl_stmt|,
name|sshift
decl_stmt|;
name|u_char
name|nibble_a
decl_stmt|,
name|nibble_b
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_match ( 0x%x, 0x%x, 0x%x, 0x%x 0x%x)\n"
argument_list|,
name|src_octet
argument_list|,
name|src_nibble
argument_list|,
name|dst_octet
argument_list|,
name|dst_nibble
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ENDDEBUG
define|#
directive|define
name|SHIFT
value|0x4
name|dshift
init|=
name|dst_nibble
operator|<<
literal|2
decl_stmt|;
name|sshift
operator|=
name|src_nibble
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|nibble_b
operator|=
operator|(
operator|(
operator|*
name|dst_octet
operator|)
operator|>>
name|dshift
operator|)
operator|&
literal|0xf
expr_stmt|;
name|nibble_a
operator|=
operator|(
literal|0xf
operator|&
operator|(
operator|*
name|src_octet
operator|>>
name|sshift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|nibble_b
operator|!=
name|nibble_a
condition|)
return|return
literal|0
return|;
name|dshift
operator|^=
name|SHIFT
expr_stmt|;
name|sshift
operator|^=
name|SHIFT
expr_stmt|;
name|src_nibble
operator|=
literal|1
operator|-
name|src_nibble
expr_stmt|;
name|dst_nibble
operator|=
literal|1
operator|-
name|dst_nibble
expr_stmt|;
name|src_octet
operator|+=
name|src_nibble
expr_stmt|;
name|dst_octet
operator|+=
name|dst_nibble
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"nibble_match DONE\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  **************************** NET PROTOCOL cons ***************************  */
end_comment

begin_comment
comment|/*  * NAME:	cons_init()  * CALLED FROM:  *	autoconf  * FUNCTION:  *	initialize the protocol  */
end_comment

begin_macro
name|cons_init
argument_list|()
end_macro

begin_block
block|{
name|int
name|tp_incoming
argument_list|()
decl_stmt|,
name|clnp_incoming
argument_list|()
decl_stmt|;
name|CLNP_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_CLNP
argument_list|,
name|SOCK_DGRAM
argument_list|)
expr_stmt|;
name|X25_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_X25
argument_list|,
name|SOCK_STREAM
argument_list|)
expr_stmt|;
name|TP_proto
operator|=
name|pffindproto
argument_list|(
name|AF_ISO
argument_list|,
name|ISOPROTO_TP0
argument_list|,
name|SOCK_SEQPACKET
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONS
argument_list|)
name|printf
argument_list|(
literal|"cons_init end : cnlp_proto 0x%x cons proto 0x%x tp proto 0x%x\n"
argument_list|,
name|CLNP_proto
argument_list|,
name|X25_proto
argument_list|,
name|TP_proto
argument_list|)
expr_stmt|;
name|ENDDEBUG
ifdef|#
directive|ifdef
name|notdef
name|pk_protolisten
argument_list|(
literal|0x81
argument_list|,
literal|0
argument_list|,
name|clnp_incoming
argument_list|)
decl_stmt|;
name|pk_protolisten
argument_list|(
literal|0x82
argument_list|,
literal|0
argument_list|,
name|esis_incoming
argument_list|)
expr_stmt|;
name|pk_protolisten
argument_list|(
literal|0x84
argument_list|,
literal|0
argument_list|,
name|tp8878_A_incoming
argument_list|)
expr_stmt|;
name|pk_protolisten
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|tp_incoming
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|tp_incoming
argument_list|(
argument|lcp
argument_list|,
argument|m
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
specifier|extern
name|struct
name|isopcb
name|tp_isopcb
decl_stmt|;
name|int
name|cons_tpinput
parameter_list|()
function_decl|;
if|if
condition|(
name|iso_pcballoc
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|tp_incoming_pending
argument_list|)
condition|)
block|{
name|pk_close
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
return|return;
block|}
name|isop
operator|=
name|tp_incoming_pending
operator|.
name|isop_next
expr_stmt|;
name|lcp
operator|->
name|lcd_upper
operator|=
name|cons_tpinput
expr_stmt|;
name|lcp
operator|->
name|lcd_upnext
operator|=
operator|(
name|caddr_t
operator|)
name|isop
expr_stmt|;
name|lcp
operator|->
name|lcd_send
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
comment|/* Confirms call */
name|isop
operator|->
name|isop_chan
operator|=
operator|(
name|caddr_t
operator|)
name|lcp
expr_stmt|;
name|isop
operator|->
name|isop_laddr
operator|=
operator|&
name|isop
operator|->
name|isop_sladdr
expr_stmt|;
name|isop
operator|->
name|isop_faddr
operator|=
operator|&
name|isop
operator|->
name|isop_sfaddr
expr_stmt|;
name|DTEtoNSAP
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_laddr
argument_list|)
expr_stmt|;
name|DTEtoNSAP
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_faddr
argument_list|)
expr_stmt|;
name|parse_facil
argument_list|(
name|isop
argument_list|,
name|lcp
argument_list|,
operator|&
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
operator|->
name|packet_data
operator|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|PKHEADERLN
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|cons_tpinput
argument_list|(
argument|lcp
argument_list|,
argument|m0
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|lcp
operator|->
name|lcd_upnext
decl_stmt|;
specifier|register
name|struct
name|x25_packet
modifier|*
name|xp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
if|if
condition|(
name|isop
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
name|isop
operator|->
name|isop_chan
operator|=
literal|0
expr_stmt|;
name|isop
operator|->
name|isop_refcnt
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_upnext
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_upper
operator|=
literal|0
expr_stmt|;
goto|goto
name|dead
goto|;
block|}
switch|switch
condition|(
name|m0
operator|->
name|m_type
condition|)
block|{
case|case
name|MT_DATA
case|:
case|case
name|MT_OOBDATA
case|:
name|tpcons_input
argument_list|(
name|m0
argument_list|,
name|isop
operator|->
name|isop_faddr
argument_list|,
name|isop
operator|->
name|isop_laddr
argument_list|,
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|lcp
argument_list|)
expr_stmt|;
return|return;
case|case
name|MT_CONTROL
case|:
switch|switch
condition|(
name|pk_decode
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|x25_packet
operator|*
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|RR
case|:
name|cmd
operator|=
name|PRC_CONS_SEND_DONE
expr_stmt|;
break|break;
case|case
name|CALL_ACCEPTED
case|:
if|if
condition|(
name|lcp
operator|->
name|lcd_sb
operator|.
name|sb_mb
condition|)
name|lcp
operator|->
name|lcd_send
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
comment|/* XXX - fix this */
comment|/*FALLTHROUGH*/
default|default:
return|return;
name|dead
label|:
case|case
name|RESET
case|:
case|case
name|CLEAR
case|:
case|case
name|CLEAR_CONF
case|:
name|cmd
operator|=
name|PRC_ROUTEDEAD
expr_stmt|;
block|}
name|tpcons_ctlinput
argument_list|(
name|cmd
argument_list|,
name|isop
operator|->
name|isop_faddr
argument_list|,
name|isop
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * NAME:	cons_connect()  * CALLED FROM:  *	tpcons_pcbconnect() when opening a new connection.    * FUNCTION anD ARGUMENTS:  *  Figures out which device to use, finding a route if one doesn't  *  already exist.  * RETURN VALUE:  *  returns E*  */
end_comment

begin_expr_stmt
name|cons_connect
argument_list|(
name|isop
argument_list|)
specifier|register
expr|struct
name|isopcb
operator|*
name|isop
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
init|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"cons_connect(0x%x): "
argument_list|,
name|isop
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"myaddr: "
argument_list|)
expr_stmt|;
name|dump_isoaddr
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|NSAPtoDTE
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_faddr
argument_list|)
decl_stmt|;
name|lcp
operator|->
name|lcd_upper
operator|=
name|cons_tpinput
expr_stmt|;
name|lcp
operator|->
name|lcd_upnext
operator|=
operator|(
name|caddr_t
operator|)
name|isop
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"calling make_partial_x25_packet( 0x%x, 0x%x, 0x%x)\n"
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_faddr
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_laddr
argument_list|,
name|isop
operator|->
name|isop_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|error
operator|=
name|make_partial_x25_packet
argument_list|(
name|isop
argument_list|,
name|lcp
argument_list|,
name|m
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|pk_connect
argument_list|(
name|lcp
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_faddr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  **************************** DEVICE cons ***************************  */
end_comment

begin_comment
comment|/*   * NAME:	cons_ctlinput()  * CALLED FROM:  *  lower layer when ECN_CLEAR occurs : this routine is here  *  for consistency - cons subnet service calls its higher layer  *  through the protosw entry.  * FUNCTION& ARGUMENTS:  *  cmd is a PRC_* command, list found in ../sys/protosw.h  *  copcb is the obvious.  *  This serves the higher-layer cons service.  * NOTE: this takes 3rd arg. because cons uses it to inform itself  *  of things (timeouts, etc) but has a pcb instead of an address.  */
end_comment

begin_macro
name|cons_ctlinput
argument_list|(
argument|cmd
argument_list|,
argument|sa
argument_list|,
argument|copcb
argument_list|)
end_macro

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|pklcd
modifier|*
name|copcb
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_expr_stmt
name|find_error_reason
argument_list|(
name|xp
argument_list|)
specifier|register
expr|struct
name|x25_packet
operator|*
name|xp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|u_char
name|x25_error_stats
index|[]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cause
decl_stmt|;
if|if
condition|(
name|xp
condition|)
block|{
name|cause
operator|=
literal|4
index|[
operator|(
name|char
operator|*
operator|)
name|xp
index|]
expr_stmt|;
switch|switch
condition|(
name|cause
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x80
case|:
comment|/* DTE originated; look at the diagnostic */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
name|cause
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|0x01
case|:
comment|/* number busy */
case|case
literal|0x81
case|:
case|case
literal|0x09
case|:
comment|/* Out of order */
case|case
literal|0x89
case|:
case|case
literal|0x11
case|:
comment|/* Remot Procedure Error */
case|case
literal|0x91
case|:
case|case
literal|0x19
case|:
comment|/* reverse charging accept not subscribed */
case|case
literal|0x99
case|:
case|case
literal|0x21
case|:
comment|/* Incampat destination */
case|case
literal|0xa1
case|:
case|case
literal|0x29
case|:
comment|/* fast select accept not subscribed */
case|case
literal|0xa9
case|:
case|case
literal|0x39
case|:
comment|/* ship absent */
case|case
literal|0xb9
case|:
case|case
literal|0x03
case|:
comment|/* invalid facil request */
case|case
literal|0x83
case|:
case|case
literal|0x0b
case|:
comment|/* access barred */
case|case
literal|0x8b
case|:
case|case
literal|0x13
case|:
comment|/* local procedure error */
case|case
literal|0x93
case|:
case|case
literal|0x05
case|:
comment|/* network congestion */
case|case
literal|0x85
case|:
case|case
literal|0x8d
case|:
comment|/* not obtainable */
case|case
literal|0x0d
case|:
case|case
literal|0x95
case|:
comment|/* RPOA out of order */
case|case
literal|0x15
case|:
comment|/* take out bit 8  				 * so we don't have to have so many perror entries  				 */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
literal|0x100
operator||
operator|(
name|cause
operator|&
operator|~
literal|0x80
operator|)
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
literal|0xc1
case|:
comment|/* gateway-detected proc error */
case|case
literal|0xc3
case|:
comment|/* gateway congestion */
name|error
operator|=
operator|(
name|CONL_ERROR_MASK
operator||
literal|0x100
operator||
name|cause
operator|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* otherwise, a *hopefully* valid perror exists in the e_reason field */
name|error
operator|=
name|xp
operator|->
name|packet_data
expr_stmt|;
if|if
condition|(
name|error
operator|=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Incoming PKT TYPE 0x%x with reason 0x%x\n"
argument_list|,
name|pk_decode
argument_list|(
name|xp
argument_list|)
argument_list|,
name|cause
argument_list|)
expr_stmt|;
name|error
operator|=
name|E_CO_HLI_DISCA
expr_stmt|;
block|}
name|done
label|:
return|return
name|error
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|KERNEL
end_endif

begin_comment
comment|/*  * NAME:	make_partial_x25_packet()  *  * FUNCTION and ARGUMENTS:  *	Makes part of an X.25 call packet, for use by x25.  *  (src) and (dst) are the NSAP-addresses of source and destination.  *	(buf) is a ptr to a buffer into which to write this partial header.  *  *	 0			Facility length (in octets)  *	 1			Facility field, which is a set of:  *	  m			facil code  *	  m+1		facil param len (for>2-byte facilities) in octets  *	  m+2..p	facil param field  *  q			user data (protocol identification octet)  *   *  * RETURNS:   *  0 if OK  *  E* if failed.  *  * SIDE EFFECTS:  * Stores facilites mbuf in X.25 control block, where the connect  * routine knows where to look for it.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|X25_1984
end_ifdef

begin_decl_stmt
name|int
name|cons_use_facils
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
else|X25_1984
end_else

begin_decl_stmt
name|int
name|cons_use_facils
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|X25_1984
end_endif

begin_decl_stmt
name|int
name|cons_use_udata
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* KLUDGE FOR DEBUGGING */
end_comment

begin_function
name|Static
name|int
name|make_partial_x25_packet
parameter_list|(
name|isop
parameter_list|,
name|lcp
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
block|{
name|u_int
name|proto
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
specifier|register
name|caddr_t
name|ptr
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|buflen
init|=
literal|0
decl_stmt|;
name|caddr_t
name|facil_len
decl_stmt|;
name|int
name|oddness
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CCONN
argument_list|)
name|printf
argument_list|(
literal|"make_partial_x25_packet(0x%x, 0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|isop
operator|->
name|isop_laddr
argument_list|,
name|isop
operator|->
name|isop_faddr
argument_list|,
name|proto
argument_list|,
name|m
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cons_use_udata
condition|)
block|{
if|if
condition|(
name|isop
operator|->
name|isop_x25crud_len
operator|>
literal|0
condition|)
block|{
comment|/* 			 *	The user specified something. Stick it in 			 */
name|bcopy
argument_list|(
name|isop
operator|->
name|isop_x25crud
argument_list|,
name|lcp
operator|->
name|lcd_faddr
operator|.
name|x25_udata
argument_list|,
name|isop
operator|->
name|isop_x25crud_len
argument_list|)
expr_stmt|;
name|lcp
operator|->
name|lcd_faddr
operator|.
name|x25_udlen
operator|=
name|isop
operator|->
name|isop_x25crud_len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cons_use_facils
operator|==
literal|0
condition|)
block|{
name|lcp
operator|->
name|lcd_facilities
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|MT_DATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|buf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
comment|/* ptr now points to facil length (len of whole facil field in OCTETS */
name|facil_len
operator|=
name|ptr
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|pk_build_facilities
argument_list|(
name|m
argument_list|,
operator|&
name|lcp
operator|->
name|lcd_faddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial  calling: ptr 0x%x, len 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cons_use_facils
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Marker to separate X.25 facitilies from CCITT ones */
operator|*
name|ptr
operator|++
operator|=
literal|0x0f
expr_stmt|;
operator|*
name|ptr
operator|=
literal|0xcb
expr_stmt|;
comment|/* calling facility code */
name|ptr
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for facil param len (in OCTETS + 1) */
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for the facil param len (in nibbles), 				 * high two bits of which indicate full/partial NSAP 				 */
name|len
operator|=
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_addr
operator|.
name|isoa_len
expr_stmt|;
name|bcopy
argument_list|(
name|isop
operator|->
name|isop_laddr
operator|->
name|siso_data
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|2
operator|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* facil param len in octets */
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|len
operator|<<
literal|1
expr_stmt|;
comment|/* facil param len in nibbles */
name|ptr
operator|+=
name|len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial  called: ptr 0x%x, len 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_addr
operator|.
name|isoa_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
modifier|*
name|ptr
init|=
literal|0xc9
decl_stmt|;
comment|/* called facility code */
name|ptr
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for facil param len (in OCTETS + 1) */
name|ptr
operator|++
expr_stmt|;
comment|/* leave room for the facil param len (in nibbles), 				 * high two bits of which indicate full/partial NSAP 				 */
name|len
operator|=
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_nlen
expr_stmt|;
name|bcopy
argument_list|(
name|isop
operator|->
name|isop_faddr
operator|->
name|siso_data
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ptr
operator|-
literal|2
operator|)
operator|=
name|len
operator|+
literal|1
expr_stmt|;
comment|/* facil param len = addr len + 1 for each of these 						  * two length fields, in octets */
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|=
name|len
operator|<<
literal|1
expr_stmt|;
comment|/* facil param len in nibbles */
name|ptr
operator|+=
name|len
expr_stmt|;
block|}
operator|*
name|facil_len
operator|=
name|ptr
operator|-
name|facil_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|facil_len
operator|>
name|MAX_FACILITIES
condition|)
return|return
name|E_CO_PNA_LONG
return|;
name|buflen
operator|=
call|(
name|int
call|)
argument_list|(
name|ptr
operator|-
name|buf
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
name|D_CDUMP_REQ
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
name|printf
argument_list|(
literal|"ECN_CONNECT DATA buf 0x%x len %d (0x%x)\n"
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buflen
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"+%d: %x %x %x %x    %x %x %x %x\n"
argument_list|,
name|i
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|1
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|2
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|3
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|4
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|5
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|6
operator|)
argument_list|,
operator|*
operator|(
name|buf
operator|+
name|i
operator|+
literal|7
operator|)
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|8
expr_stmt|;
block|}
name|ENDDEBUG
name|IFDEBUG
argument_list|(
name|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"make_partial returns buf 0x%x size 0x%x bytes\n"
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|buflen
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
name|buflen
operator|>
name|MHLEN
condition|)
return|return
name|E_CO_PNA_LONG
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|buflen
expr_stmt|;
name|lcp
operator|->
name|lcd_facilities
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	NSAPtoDTE()  * CALLED FROM:  *  make_partial_x25_packet()  * FUNCTION and ARGUMENTS:   *  get a DTE address from an NSAP-address (struct sockaddr_iso)  *  (dst_octet) is the octet into which to begin stashing the DTE addr  *  (dst_nibble) takes 0 or 1.  1 means begin filling in the DTE addr  * 		in the high-order nibble of dst_octet.  0 means low-order nibble.  *  (addr) is the NSAP-address  *  (flag) is true if the transport suffix is to become the  *		last two digits of the DTE address  *  A DTE address is a series of ASCII digits  *  *	A DTE address may have leading zeros. The are significant.  *		1 digit per nibble, may be an odd number of nibbles.  *  *  An NSAP-address has the DTE address in the IDI. Leading zeros are  *		significant. Trailing hex f indicates the end of the DTE address.  *  	The IDI is a series of BCD digits, one per nibble.  *  * RETURNS  *  # significant digits in the DTE address, -1 if error.  */
end_comment

begin_function
name|Static
name|int
name|NSAPtoDTE
parameter_list|(
name|siso
parameter_list|,
name|sx25
parameter_list|)
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sx25
decl_stmt|;
block|{
name|int
name|dtelen
init|=
operator|-
literal|1
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"NSAPtoDTE: nsap: %s\n"
argument_list|,
name|clnp_iso_addrp
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|siso
operator|->
name|siso_data
index|[
literal|0
index|]
operator|==
name|AFI_37
condition|)
block|{
specifier|register
name|char
modifier|*
name|out
init|=
name|sx25
operator|->
name|x25_addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|in
init|=
name|siso
operator|->
name|siso_data
operator|+
literal|1
decl_stmt|;
specifier|register
name|int
name|nibble
decl_stmt|;
name|char
modifier|*
name|lim
init|=
name|siso
operator|->
name|siso_data
operator|+
name|siso
operator|->
name|siso_nlen
decl_stmt|;
name|char
modifier|*
name|olim
init|=
name|out
operator|+
literal|15
decl_stmt|;
name|int
name|lowNibble
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|in
operator|<
name|lim
condition|)
block|{
name|nibble
operator|=
operator|(
operator|(
name|lowNibble
condition|?
operator|*
name|in
operator|++
else|:
operator|(
operator|*
name|in
operator|>>
literal|4
operator|)
operator|)
operator|&
literal|0xf
operator|)
operator||
literal|0x30
expr_stmt|;
name|lowNibble
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|nibble
operator|!=
literal|0x3f
operator|&&
name|out
operator|<
name|olim
condition|)
operator|*
name|out
operator|++
operator|=
name|nibble
expr_stmt|;
block|}
name|dtelen
operator|=
name|out
operator|-
name|sx25
operator|->
name|x25_addr
expr_stmt|;
operator|*
name|out
operator|++
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|rtalloc1
argument_list|(
name|siso
argument_list|,
literal|1
argument_list|)
decl_stmt|;
comment|/* error = iso_8208snparesolve(addr, x121string,&x121strlen);*/
if|if
condition|(
name|rt
condition|)
block|{
specifier|register
name|struct
name|sockaddr_x25
modifier|*
name|sxx
init|=
operator|(
expr|struct
name|sockaddr_x25
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
decl_stmt|;
specifier|register
name|char
modifier|*
name|in
init|=
name|sxx
operator|->
name|x25_addr
decl_stmt|;
name|rt
operator|->
name|rt_use
operator|--
expr_stmt|;
if|if
condition|(
name|sxx
operator|&&
name|sxx
operator|->
name|x25_family
operator|==
name|AF_CCITT
condition|)
block|{
name|bcopy
argument_list|(
name|sx25
operator|->
name|x25_addr
argument_list|,
name|sxx
operator|->
name|x25_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sx25
operator|->
name|x25_addr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|in
operator|++
condition|)
block|{}
name|dtelen
operator|=
name|in
operator|-
name|sxx
operator|->
name|x25_addr
expr_stmt|;
block|}
block|}
block|}
return|return
name|dtelen
return|;
block|}
end_function

begin_comment
comment|/*  * NAME:	FACILtoNSAP()  * CALLED FROM:  *  parse_facil()  * FUNCTION and ARGUMENTS:  * 	Creates and NSAP in the sockaddr_iso (addr) from the  *  x.25 facility found at buf - 1.  * RETURNS:  *  length of parameter if ok, -1 if error.  */
end_comment

begin_function
name|Static
name|int
name|FACILtoNSAP
parameter_list|(
name|addr
parameter_list|,
name|buf
parameter_list|)
name|u_char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
block|{
name|int
name|len_in_nibbles
decl_stmt|,
name|param_len
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|u_char
name|buf_len
decl_stmt|;
comment|/* in bytes */
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"FACILtoNSAP( 0x%x, 0x%x, 0x%x )\n"
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|len_in_nibbles
init|=
operator|*
name|buf
operator|&
literal|0x3f
decl_stmt|;
name|buf_len
operator|=
operator|(
name|len_in_nibbles
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* despite the fact that X.25 makes us put a length in nibbles 	 * here, the NSAP-addrs are always in full octets 	 */
switch|switch
condition|(
operator|*
name|buf
operator|++
operator|&
literal|0xc0
condition|)
block|{
case|case
literal|0
case|:
comment|/* Entire OSI NSAP address */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|addr
operator|->
name|siso_data
argument_list|,
name|addr
operator|->
name|siso_nlen
operator|=
name|buf_len
argument_list|)
expr_stmt|;
break|break;
case|case
literal|40
case|:
comment|/* Partial OSI NSAP address, assume trailing */
if|if
condition|(
name|buf_len
operator|+
name|addr
operator|->
name|siso_nlen
operator|>
sizeof|sizeof
argument_list|(
name|addr
operator|->
name|siso_addr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|buf
argument_list|,
name|TSEL
argument_list|(
name|addr
argument_list|)
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
name|addr
operator|->
name|siso_nlen
operator|+=
name|buf_len
expr_stmt|;
break|break;
default|default:
comment|/* Rather than blow away the connection, just ignore and use 		   NSAP from DTE */
empty_stmt|;
block|}
return|return
name|param_len
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|init_siso
argument_list|(
name|siso
argument_list|)
specifier|register
expr|struct
name|sockaddr_iso
operator|*
name|siso
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|siso
operator|->
name|siso_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|siso
argument_list|)
expr_stmt|;
name|siso
operator|->
name|siso_family
operator|=
name|AF_ISO
expr_stmt|;
name|siso
operator|->
name|siso_data
index|[
literal|0
index|]
operator|=
name|AFI_37
expr_stmt|;
name|siso
operator|->
name|siso_nlen
operator|=
literal|8
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * NAME:	DTEtoNSAP()  * CALLED FROM:  *  parse_facil()  * FUNCTION and ARGUMENTS:  *  Creates a type 37 NSAP in the sockaddr_iso (addr)  * 	from a DTE address found in a sockaddr_x25.  *    * RETURNS:  *  0 if ok; E* otherwise.  */
end_comment

begin_function
name|Static
name|int
name|DTEtoNSAP
parameter_list|(
name|addr
parameter_list|,
name|sx
parameter_list|)
name|struct
name|sockaddr_iso
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_x25
modifier|*
name|sx
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|;
specifier|register
name|int
name|first
decl_stmt|;
name|int
name|pad_tail
init|=
literal|0
decl_stmt|;
name|int
name|src_len
decl_stmt|;
name|init_siso
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|src_len
operator|=
name|strlen
argument_list|(
name|sx
operator|->
name|x25_addr
argument_list|)
expr_stmt|;
name|in
operator|=
name|sx
operator|->
name|x25_addr
expr_stmt|;
name|out
operator|=
name|addr
operator|->
name|siso_data
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|in
operator|==
literal|'0'
operator|&&
operator|(
name|src_len
operator|&
literal|1
operator|==
literal|0
operator|)
condition|)
block|{
name|pad_tail
operator|=
literal|0xf
expr_stmt|;
name|src_len
operator|++
expr_stmt|;
block|}
for|for
control|(
name|first
operator|=
literal|0
init|;
name|src_len
operator|>
literal|0
condition|;
name|src_len
operator|--
control|)
block|{
name|first
operator||=
operator|*
name|in
operator|++
expr_stmt|;
if|if
condition|(
name|src_len
operator|&
literal|1
condition|)
block|{
operator|*
name|out
operator|++
operator|=
name|first
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|first
operator|<<=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|pad_tail
condition|)
name|out
index|[
operator|-
literal|1
index|]
operator||=
literal|0xf
expr_stmt|;
return|return
literal|0
return|;
comment|/* ok */
block|}
end_function

begin_comment
comment|/*  * FUNCTION and ARGUMENTS:  *	parses (buf_len) bytes beginning at (buf) and finds  *  a called nsap, a calling nsap, and protocol identifier.  * RETURNS:  *  0 if ok, E* otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|parse_facil
parameter_list|(
name|lcp
parameter_list|,
name|isop
parameter_list|,
name|buf
parameter_list|,
name|buf_len
parameter_list|)
name|caddr_t
name|buf
decl_stmt|;
name|u_char
name|buf_len
decl_stmt|;
comment|/* in bytes */
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|called
init|=
name|isop
operator|->
name|isop_laddr
decl_stmt|;
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|calling
init|=
name|isop
operator|->
name|isop_faddr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|buf
decl_stmt|;
name|u_char
modifier|*
name|ptr_lim
decl_stmt|,
modifier|*
name|facil_lim
decl_stmt|;
name|int
name|facil_param_len
decl_stmt|,
name|facil_len
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"parse_facil(0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|,
name|called
argument_list|,
name|calling
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* find the beginnings of the facility fields in buf  	 * by skipping over the called& calling DTE addresses 	 * i<- # nibbles in called + # nibbles in calling 	 * i += 1 so that an odd nibble gets rounded up to even   	 * before dividing by 2, then divide by two to get # octets 	 */
name|i
init|=
call|(
name|int
call|)
argument_list|(
operator|*
name|ptr
operator|>>
literal|4
argument_list|)
operator|+
call|(
name|int
call|)
argument_list|(
operator|*
name|ptr
operator|&
literal|0xf
argument_list|)
decl_stmt|;
name|i
operator|++
expr_stmt|;
name|ptr
operator|+=
name|i
operator|>>
literal|1
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
comment|/* plus one for the DTE lengths byte */
comment|/* ptr now is at facil_length field */
name|facil_len
operator|=
operator|*
name|ptr
operator|++
expr_stmt|;
name|facil_lim
operator|=
name|ptr
operator|+
name|facil_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CADDR
argument_list|)
name|printf
argument_list|(
literal|"parse_facils: facil length is  0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|facil_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|ptr
operator|<=
name|facil_lim
condition|)
block|{
comment|/* get NSAP addresses from facilities */
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
literal|0xcb
case|:
comment|/* calling NSAP */
name|facil_param_len
operator|=
name|FACILtoNSAP
argument_list|(
name|isop
operator|->
name|isop_faddr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc9
case|:
comment|/* called NSAP */
name|facil_param_len
operator|=
name|FACILtoNSAP
argument_list|(
name|isop
operator|->
name|isop_laddr
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
comment|/* from here to default are legit cases that I ignore */
comment|/* variable length */
case|case
literal|0xca
case|:
comment|/* end-to-end transit delay negot */
case|case
literal|0xc6
case|:
comment|/* network user id */
case|case
literal|0xc5
case|:
comment|/* charging info : indicating monetary unit */
case|case
literal|0xc2
case|:
comment|/* charging info : indicating segment count */
case|case
literal|0xc1
case|:
comment|/* charging info : indicating call duration */
case|case
literal|0xc4
case|:
comment|/* RPOA extended format */
case|case
literal|0xc3
case|:
comment|/* call redirection notification */
name|facil_param_len
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 1 octet */
case|case
literal|0x0a
case|:
comment|/* min. throughput class negot */
case|case
literal|0x02
case|:
comment|/* throughput class */
case|case
literal|0x03
case|:
case|case
literal|0x47
case|:
comment|/* CUG shit */
case|case
literal|0x0b
case|:
comment|/* expedited data negot */
case|case
literal|0x01
case|:
comment|/* Fast select or reverse charging  						(example of intelligent protocol design) */
case|case
literal|0x04
case|:
comment|/* charging info : requesting service */
case|case
literal|0x08
case|:
comment|/* called line addr modified notification */
name|facil_param_len
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* any 2 octets */
case|case
literal|0x42
case|:
comment|/* pkt size */
case|case
literal|0x43
case|:
comment|/* win size */
case|case
literal|0x44
case|:
comment|/* RPOA basic format */
case|case
literal|0x41
case|:
comment|/* bilateral CUG shit */
case|case
literal|0x49
case|:
comment|/* transit delay selection and indication */
name|facil_param_len
operator|=
literal|2
expr_stmt|;
break|break;
comment|/* don't have any 3 octets */
comment|/* 				facil_param_len = 3; 				*/
default|default:
name|printf
argument_list|(
literal|"BOGUS FACILITY CODE facil_len 0x%x *facil_len 0x%x, ptr 0x%x *ptr 0x%x\n"
argument_list|,
name|ptr
argument_list|,
name|facil_len
argument_list|,
name|ptr
operator|-
literal|1
argument_list|,
name|ptr
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* facil that we don't handle */
return|return
name|E_CO_HLI_REJI
return|;
block|}
if|if
condition|(
name|facil_param_len
operator|==
operator|-
literal|1
condition|)
return|return
name|E_CO_REG_ICDA
return|;
if|if
condition|(
name|facil_param_len
operator|==
literal|0
condition|)
comment|/* variable length */
name|facil_param_len
operator|=
operator|(
name|int
operator|)
operator|*
name|ptr
expr_stmt|;
comment|/* 1 + the real facil param */
name|ptr
operator|+=
name|facil_param_len
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
endif|TPCONS
end_endif

end_unit

