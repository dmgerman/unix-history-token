begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_output.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  *  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_output.c,v $  *  * In here is tp_ctloutput(), the guy called by [sg]etsockopt(),  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_user.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_ip.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_clnp.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_define
define|#
directive|define
name|TPDUSIZESHIFT
value|24
end_define

begin_define
define|#
directive|define
name|CLASSHIFT
value|16
end_define

begin_comment
comment|/*  * NAME: 	tp_consistency()  *  * CALLED FROM:  * 	tp_ctloutput(), tp_input()  *  * FUNCTION and ARGUMENTS:  * 	Checks the consistency of options and tpdusize with class,  *	using the parameters passed in via (param).  *	(cmd) may be TP_STRICT or TP_FORCE or both.  *  Force means it will set all the values in (tpcb) to those in  *  the input arguements iff no errors were encountered.  *  Strict means that no inconsistency will be tolerated.  If it's  *  not used, checksum and tpdusize inconsistencies will be tolerated.  *  The reason for this is that in some cases, when we're negotiating down  *	from class  4, these options should be changed but should not  *  cause negotiation to fail.  *  * RETURNS  *  E* or EOK  *  E* if the various parms aren't ok for a given class  *  EOK if they are ok for a given class  */
end_comment

begin_function
name|int
name|tp_consistency
parameter_list|(
name|tpcb
parameter_list|,
name|cmd
parameter_list|,
name|param
parameter_list|)
name|u_int
name|cmd
decl_stmt|;
name|struct
name|tp_conn_param
modifier|*
name|param
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|int
name|error
init|=
name|EOK
decl_stmt|;
name|int
name|class_to_use
init|=
name|tp_mask_to_num
argument_list|(
name|param
operator|->
name|p_class
argument_list|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_consist enter class_to_use dontchange param.class cmd"
argument_list|,
name|class_to_use
argument_list|,
name|param
operator|->
name|p_dont_change_params
argument_list|,
name|param
operator|->
name|p_class
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"tp_consistency %s %s\n"
argument_list|,
name|cmd
operator|&
name|TP_FORCE
condition|?
literal|"TP_FORCE"
else|:
literal|""
argument_list|,
name|cmd
operator|&
name|TP_STRICT
condition|?
literal|"TP_STRICT"
else|:
literal|""
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|cmd
operator|&
name|TP_FORCE
operator|)
operator|&&
operator|(
name|param
operator|->
name|p_dont_change_params
operator|)
condition|)
block|{
name|cmd
operator|&=
operator|~
name|TP_FORCE
expr_stmt|;
block|}
comment|/* can switch net services within a domain, but 	 * cannot switch domains 	 */
switch|switch
condition|(
name|param
operator|->
name|p_netservice
condition|)
block|{
case|case
name|ISO_CONS
case|:
case|case
name|ISO_CLNS
case|:
case|case
name|ISO_COSNS
case|:
comment|/* param->p_netservice in ISO DOMAIN */
if|if
condition|(
name|tpcb
operator|->
name|tp_domain
operator|!=
name|AF_ISO
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|IN_CLNS
case|:
comment|/* param->p_netservice in INET DOMAIN */
if|if
condition|(
name|tpcb
operator|->
name|tp_domain
operator|!=
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
comment|/* no others not possible-> netservice is a 2-bit field! */
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"p_class 0x%x, class_to_use 0x%x\n"
argument_list|,
name|param
operator|->
name|p_class
argument_list|,
name|class_to_use
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_netservice
operator|<
literal|0
operator|)
operator|||
operator|(
name|param
operator|->
name|p_netservice
operator|>
name|TP_MAX_NETSERVICES
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|param
operator|->
name|p_class
operator|&
name|TP_CLASSES_IMPLEMENTED
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"Nretrans 0x%x\n"
argument_list|,
name|param
operator|->
name|p_Nretrans
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_Nretrans
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_cr_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_cc_ticks
operator|<
literal|1
operator|)
condition|)
block|{
comment|/* bad for any class because negot has to be done a la class 4 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"use_csum 0x%x\n"
argument_list|,
name|param
operator|->
name|p_use_checksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xtd_format 0x%x\n"
argument_list|,
name|param
operator|->
name|p_xtd_format
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"xpd_service 0x%x\n"
argument_list|,
name|param
operator|->
name|p_xpd_service
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tpdusize 0x%x\n"
argument_list|,
name|param
operator|->
name|p_tpdusize
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tpcb->flags 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|class_to_use
condition|)
block|{
case|case
literal|0
case|:
comment|/* do not use checksums, xtd format, or XPD */
if|if
condition|(
name|param
operator|->
name|p_use_checksum
operator||
name|param
operator|->
name|p_xtd_format
operator||
name|param
operator|->
name|p_xpd_service
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_use_checksum
operator|=
literal|0
expr_stmt|;
name|param
operator|->
name|p_xtd_format
operator|=
literal|0
expr_stmt|;
name|param
operator|->
name|p_xpd_service
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|<
name|TP_MIN_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_MIN_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|>
name|TP0_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP0_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
comment|/* connect/disc data not allowed for class 0 */
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|&
name|TP_FORCE
condition|)
block|{
name|m_freem
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_ucddata
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|4
case|:
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"dt_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_dt_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"x_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_x_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dr_ticks 0x%x\n"
argument_list|,
name|param
operator|->
name|p_dr_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"keepalive 0x%x\n"
argument_list|,
name|param
operator|->
name|p_keepalive_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sendack 0x%x\n"
argument_list|,
name|param
operator|->
name|p_sendack_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"inact 0x%x\n"
argument_list|,
name|param
operator|->
name|p_inact_ticks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ref 0x%x\n"
argument_list|,
name|param
operator|->
name|p_ref_ticks
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_class
operator|&
name|TP_CLASS_4
operator|)
operator|&&
operator|(
operator|(
name|param
operator|->
name|p_dt_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_dr_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_x_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_keepalive_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_sendack_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_ref_ticks
operator|<
literal|1
operator|)
operator|||
operator|(
name|param
operator|->
name|p_inact_ticks
operator|<
literal|1
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"rx_strat 0x%x\n"
argument_list|,
name|param
operator|->
name|p_rx_strat
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|param
operator|->
name|p_rx_strat
operator|>
operator|(
name|TPRX_USE_CW
operator||
name|TPRX_EACH
operator||
name|TPRX_FASTSTART
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_rx_strat
operator|=
name|TPRX_USE_CW
expr_stmt|;
block|}
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"ack_strat 0x%x\n"
argument_list|,
name|param
operator|->
name|p_ack_strat
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|param
operator|->
name|p_ack_strat
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|param
operator|->
name|p_ack_strat
operator|!=
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_ack_strat
operator|=
name|TPACK_WINDOW
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|<
name|TP_MIN_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_MIN_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|>
name|TP_TPDUSIZE
condition|)
block|{
if|if
condition|(
name|cmd
operator|&
name|TP_STRICT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|param
operator|->
name|p_tpdusize
operator|=
name|TP_TPDUSIZE
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmd
operator|&
name|TP_FORCE
operator|)
condition|)
block|{
name|long
name|dusize
init|=
operator|(
operator|(
name|long
operator|)
name|param
operator|->
name|p_ptpdusize
operator|)
operator|<<
literal|7
decl_stmt|;
comment|/* Enforce Negotation rules below */
name|tpcb
operator|->
name|tp_class
operator|=
name|param
operator|->
name|p_class
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
operator|||
name|param
operator|->
name|p_use_checksum
condition|)
name|tpcb
operator|->
name|tp_use_checksum
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xpd_service
operator|||
operator|!
name|param
operator|->
name|p_xpd_service
condition|)
name|tpcb
operator|->
name|tp_xpd_service
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_xtd_format
operator|||
operator|!
name|param
operator|->
name|p_xtd_format
condition|)
name|tpcb
operator|->
name|tp_xtd_format
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dusize
condition|)
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_l_tpdusize
operator|>
name|dusize
condition|)
name|tpcb
operator|->
name|tp_l_tpdusize
operator|=
name|dusize
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_ptpdusize
operator|==
literal|0
operator|||
name|tpcb
operator|->
name|tp_ptpdusize
operator|>
name|param
operator|->
name|p_ptpdusize
condition|)
name|tpcb
operator|->
name|tp_ptpdusize
operator|=
name|param
operator|->
name|p_ptpdusize
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|param
operator|->
name|p_tpdusize
operator|!=
literal|0
operator|&&
name|tpcb
operator|->
name|tp_tpdusize
operator|>
name|param
operator|->
name|p_tpdusize
condition|)
name|tpcb
operator|->
name|tp_tpdusize
operator|=
name|param
operator|->
name|p_tpdusize
expr_stmt|;
name|tpcb
operator|->
name|tp_l_tpdusize
operator|=
literal|1
operator|<<
name|tpcb
operator|->
name|tp_tpdusize
expr_stmt|;
block|}
block|}
name|done
label|:
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_consist returns class xtdfmt cmd"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_xtd_format
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_consist rtns 0x%x class 0x%x xtd_fmt 0x%x cmd 0x%x\n"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_xtd_format
argument_list|,
name|cmd
argument_list|)
decl_stmt|;
name|ENDDEBUG
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * NAME: 	tp_ctloutput()  *  * CALLED FROM:  * 	[sg]etsockopt(), via so[sg]etopt().  *  * FUNCTION and ARGUMENTS:  * 	Implements the socket options at transport level.  * 	(cmd) is either PRCO_SETOPT or PRCO_GETOPT (see ../sys/protosw.h).  * 	(so) is the socket.  * 	(level) is SOL_TRANSPORT (see ../sys/socket.h)  * 	(optname) is the particular command or option to be set.  * 	(**mp) is an mbuf structure.  *  * RETURN VALUE:  * 	ENOTSOCK if the socket hasn't got an associated tpcb  *  EINVAL if  * 		trying to set window too big  * 		trying to set illegal max tpdu size  * 		trying to set illegal credit fraction  * 		trying to use unknown or unimplemented class of TP  *		structure passed to set timer values is wrong size  *  	illegal combination of command/GET-SET option,  *			e.g., GET w/ TPOPT_CDDATA_CLEAR:  *  EOPNOTSUPP if the level isn't transport, or command is neither GET nor SET  *   or if the transport-specific command is not implemented  *  EISCONN if trying a command that isn't allowed after a connection  *   is established  *  ENOTCONN if trying a command that is allowed only if a connection is  *   established  *  EMSGSIZE if trying to give too much data on connect/disconnect  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|ProtoHook
name|tp_ctloutput
parameter_list|(
name|cmd
parameter_list|,
name|so
parameter_list|,
name|level
parameter_list|,
name|optname
parameter_list|,
name|mp
parameter_list|)
name|int
name|cmd
decl_stmt|,
name|level
decl_stmt|,
name|optname
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
block|{
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|caddr_t
name|value
decl_stmt|;
name|unsigned
name|val_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_REQUEST
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_ctloutput cmd so optname mp"
argument_list|,
name|cmd
argument_list|,
name|so
argument_list|,
name|optname
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"tp_ctloutput so 0x%x cmd 0x%x optname 0x%x, mp 0x%x *mp 0x%x tpcb 0x%x\n"
argument_list|,
name|so
argument_list|,
name|cmd
argument_list|,
name|optname
argument_list|,
name|mp
argument_list|,
name|mp
condition|?
operator|*
name|mp
else|:
literal|0
argument_list|,
name|tpcb
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
name|tpcb
operator|==
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|MNULL
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|TPMT_SONAME
argument_list|)
expr_stmt|;
comment|/* does off, type, next */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 *	Hook so one can set network options via a tp socket. 	 */
if|if
condition|(
name|level
operator|==
name|SOL_NETWORK
condition|)
block|{
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_nlproto
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tpcb
operator|->
name|tp_npcb
operator|==
name|NULL
operator|)
condition|)
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_ctloutput
operator|==
name|NULL
condition|)
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
else|else
return|return
operator|(
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_ctloutput
call|)
argument_list|(
name|cmd
argument_list|,
name|optname
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
operator|*
name|mp
argument_list|)
operator|)
return|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|level
operator|==
name|SOL_SOCKET
condition|)
block|{
if|if
condition|(
name|optname
operator|==
name|SO_RCVBUF
operator|&&
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|u_long
name|old_credit
init|=
name|tpcb
operator|->
name|tp_maxlcredit
decl_stmt|;
name|tp_rsyset
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_rhiwat
operator|!=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|&&
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_OPEN
operator|&&
operator|(
name|old_credit
operator|<
name|tpcb
operator|->
name|tp_maxlcredit
operator|)
condition|)
name|tp_emit
argument_list|(
name|AK_TPDU_type
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_rcvnxt
argument_list|,
literal|0
argument_list|,
name|MNULL
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_rhiwat
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|level
operator|!=
name|SOL_TRANSPORT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cmd
operator|!=
name|PRCO_GETOPT
operator|&&
name|cmd
operator|!=
name|PRCO_SETOPT
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* The only options allowed after connection is established 	 * are GET (anything) and SET DISC DATA and SET PERF MEAS 	 */
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|)
operator|&&
operator|(
name|cmd
operator|==
name|PRCO_SETOPT
operator|&&
name|optname
operator|!=
name|TPOPT_DISC_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_CFRM_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_PERF_MEAS
operator|&&
name|optname
operator|!=
name|TPOPT_CDDATA_CLEAR
operator|)
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* The only options allowed after disconnection are GET DISC DATA, 	 * and TPOPT_PSTATISTICS 	 * and they're not allowed if the ref timer has gone off, because 	 * the tpcb is gone 	 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONFIRMING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_pcb
operator|==
operator|(
name|caddr_t
operator|)
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_REFWAIT
operator|||
name|tpcb
operator|->
name|tp_state
operator|==
name|TP_CLOSING
operator|)
operator|&&
operator|(
name|optname
operator|!=
name|TPOPT_DISC_DATA
operator|&&
name|optname
operator|!=
name|TPOPT_PSTATISTICS
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|value
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* it's aligned, don't worry, 								  * but lint complains about it 								  */
name|val_len
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|TPOPT_INTERCEPT
case|:
define|#
directive|define
name|INA
parameter_list|(
name|t
parameter_list|)
value|(((struct inpcb *)(t->tp_npcb))->inp_laddr.s_addr)
define|#
directive|define
name|ISOA
parameter_list|(
name|t
parameter_list|)
value|(((struct isopcb *)(t->tp_npcb))->isop_laddr->siso_addr)
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PRIV
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|!=
name|PRCO_SETOPT
operator|||
name|tpcb
operator|->
name|tp_state
operator|!=
name|TP_CLOSED
operator|||
operator|(
name|tpcb
operator|->
name|tp_flags
operator|&
name|TPF_GENERAL_ADDR
operator|)
operator|||
name|tpcb
operator|->
name|tp_next
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|t
decl_stmt|;
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tp_listeners
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|tp_nextlisten
control|)
if|if
condition|(
operator|(
name|t
operator|->
name|tp_flags
operator|&
name|TPF_GENERAL_ADDR
operator|)
operator|==
literal|0
operator|&&
name|t
operator|->
name|tp_domain
operator|==
name|tpcb
operator|->
name|tp_domain
condition|)
switch|switch
condition|(
name|tpcb
operator|->
name|tp_domain
condition|)
block|{
default|default:
goto|goto
name|done
goto|;
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|INA
argument_list|(
name|t
argument_list|)
operator|==
name|INA
argument_list|(
name|tpcb
argument_list|)
condition|)
goto|goto
name|done
goto|;
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISO
case|case
name|AF_ISO
case|:
if|if
condition|(
name|bcmp
argument_list|(
name|ISOA
argument_list|(
name|t
argument_list|)
operator|.
name|isoa_genaddr
argument_list|,
name|ISOA
argument_list|(
name|tpcb
argument_list|)
operator|.
name|isoa_genaddr
argument_list|,
name|ISOA
argument_list|(
name|t
argument_list|)
operator|.
name|isoa_len
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
continue|continue;
endif|#
directive|endif
block|}
name|tpcb
operator|->
name|tp_lsuffixlen
operator|=
literal|0
expr_stmt|;
name|tpcb
operator|->
name|tp_state
operator|=
name|TP_LISTENING
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|remque
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_next
operator|=
name|tpcb
operator|->
name|tp_prev
operator|=
name|tpcb
expr_stmt|;
name|tpcb
operator|->
name|tp_nextlisten
operator|=
name|tp_listeners
expr_stmt|;
name|tp_listeners
operator|=
name|tpcb
expr_stmt|;
block|}
break|break;
case|case
name|TPOPT_MY_TSEL
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_lsuffixlen
operator|<=
name|MAX_TSAP_SEL_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|value
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
name|tpcb
operator|->
name|tp_lsuffixlen
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|val_len
operator|>
name|MAX_TSAP_SEL_LEN
operator|)
operator|||
operator|(
name|val_len
operator|<=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"val_len 0x%x (*mp)->m_len 0x%x\n"
argument_list|,
name|val_len
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|value
argument_list|,
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_lsuffixlen
operator|=
name|val_len
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_PEER_TSEL
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_fsuffixlen
operator|<=
name|MAX_TSAP_SEL_LEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|value
argument_list|,
name|tpcb
operator|->
name|tp_fsuffixlen
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
name|tpcb
operator|->
name|tp_fsuffixlen
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|val_len
operator|>
name|MAX_TSAP_SEL_LEN
operator|)
operator|||
operator|(
name|val_len
operator|<=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"val_len 0x%x (*mp)->m_len 0x%x\n"
argument_list|,
name|val_len
argument_list|,
operator|(
operator|*
name|mp
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|value
argument_list|,
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_fsuffixlen
operator|=
name|val_len
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_FLAGS
case|:
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"%s TPOPT_FLAGS value 0x%x *value 0x%x, flags 0x%x \n"
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|,
name|value
argument_list|,
operator|*
name|value
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|value
operator|=
operator|(
name|int
operator|)
name|tpcb
operator|->
name|tp_flags
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|TPOPT_PARAMS
case|:
comment|/* This handles: 		 * timer values, 		 * class, use of transport expedited data, 		 * max tpdu size, checksum, xtd format and 		 * disconnect indications, and may get rid of connect/disc data 		 */
name|IFDEBUG
argument_list|(
argument|D_SETPARAMS
argument_list|)
name|printf
argument_list|(
literal|"TPOPT_PARAMS value 0x%x, cmd %s \n"
argument_list|,
name|value
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
argument_list|(
name|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"TPOPT_PARAMS value 0x%x, cmd %s \n"
argument_list|,
name|value
argument_list|,
name|cmd
operator|==
name|PRCO_GETOPT
condition|?
literal|"GET"
else|:
literal|"SET"
argument_list|)
decl_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
operator|=
name|tpcb
operator|->
name|_tp_param
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* cmd == PRCO_SETOPT  */
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|tp_consistency
argument_list|(
name|tpcb
argument_list|,
name|TP_STRICT
operator||
name|TP_FORCE
argument_list|,
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * tp_consistency doesn't copy the whole set of params 				 */
name|tpcb
operator|->
name|_tp_param
operator|=
operator|*
operator|(
expr|struct
name|tp_conn_param
operator|*
operator|)
name|value
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|_tp_param
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_PSTATISTICS
case|:
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
if|if
condition|(
operator|*
name|mp
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
do|do
block|{
name|MFREE
argument_list|(
operator|*
name|mp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|n
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
block|}
operator|*
name|mp
operator|=
name|m_copym
argument_list|(
name|tpcb
operator|->
name|tp_p_mbuf
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ENDPERF
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|done
goto|;
endif|#
directive|endif
comment|/* TP_PERF_MEAS */
case|case
name|TPOPT_CDDATA_CLEAR
case|:
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
block|{
name|m_freem
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_ucddata
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TPOPT_CFRM_DATA
case|:
case|case
name|TPOPT_DISC_DATA
case|:
case|case
name|TPOPT_CONN_DATA
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|optname
operator|==
name|TPOPT_DISC_DATA
condition|?
literal|"DISC data"
else|:
literal|"CONN data"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"m_len 0x%x, vallen 0x%x so_snd.cc 0x%x\n"
argument_list|,
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
argument_list|,
name|val_len
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"tp_ctloutput: sosnd "
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|int
name|len
init|=
name|tpcb
operator|->
name|tp_ucddata
condition|?
name|tpcb
operator|->
name|tp_ucddata
operator|->
name|m_len
else|:
literal|0
decl_stmt|;
comment|/* can append connect data in several calls */
if|if
condition|(
name|len
operator|+
name|val_len
operator|>
operator|(
name|optname
operator|==
name|TPOPT_CONN_DATA
condition|?
name|TP_MAX_CR_DATA
else|:
name|TP_MAX_DR_DATA
operator|)
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
operator|=
name|MNULL
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_act
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_ucddata
condition|)
name|m_cat
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
else|else
name|tpcb
operator|->
name|tp_ucddata
operator|=
operator|*
name|mp
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|,
literal|"tp_ctloutput after CONN_DATA"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_REQUEST
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"C/D DATA: flags snd.sbcc val_len"
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|,
name|val_len
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
modifier|*
name|mp
init|=
name|MNULL
decl_stmt|;
if|if
condition|(
name|optname
operator|==
name|TPOPT_CFRM_DATA
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
condition|)
operator|(
name|void
operator|)
name|tp_confirm
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TPOPT_PERF_MEAS
case|:
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
if|if
condition|(
name|cmd
operator|==
name|PRCO_GETOPT
condition|)
block|{
operator|*
name|value
operator|=
operator|(
name|u_int
operator|)
name|tpcb
operator|->
name|tp_perf_on
expr_stmt|;
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|value
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|*
name|value
operator|)
operator|!=
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|tpcb
operator|->
name|tp_perf_on
operator|=
operator|(
operator|*
name|value
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_perf_on
condition|)
name|error
operator|=
name|tp_setup_perf
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* TP_PERF_MEAS */
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
comment|/* TP_PERF_MEAS */
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
argument_list|,
literal|"tp_ctloutput sosnd at end"
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
operator|*
name|mp
argument_list|,
literal|"tp_ctloutput *mp"
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* 	 * sigh: getsockopt looks only at m_len : all output data must 	 * reside in the first mbuf 	 */
if|if
condition|(
operator|*
name|mp
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|PRCO_SETOPT
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|MNULL
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|m_compress
argument_list|(
operator|*
name|mp
argument_list|,
name|mp
argument_list|)
operator|<=
name|MLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_REQUEST
argument_list|)
name|dump_mbuf
argument_list|(
operator|*
name|mp
argument_list|,
literal|"tp_ctloutput *mp after compress"
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

