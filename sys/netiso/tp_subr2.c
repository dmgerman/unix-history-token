begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tp_subr2.c	8.1 (Berkeley) 6/10/93  * $FreeBSD$  */
end_comment

begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*  * ARGO TP  *  * $FreeBSD$  * $Source: /pub/FreeBSD/FreeBSD-CVS/src/sys/netiso/Attic/tp_subr2.c,v $  *  * Some auxiliary routines:  * 	tp_protocol_error: required by xebec- called when a combo of state,  *	    event, predicate isn't covered for by the transition file.  *	tp_indicate: gives indications(signals) to the user process  *	tp_getoptions: initializes variables that are affected by the options  *	    chosen.  */
end_comment

begin_comment
comment|/* this def'n is to cause the expansion of this macro in the  * routine tp_local_credit :  */
end_comment

begin_define
define|#
directive|define
name|LOCAL_CREDIT_EXPAND
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_undef
undef|#
directive|undef
name|MNULL
end_undef

begin_include
include|#
directive|include
file|<netiso/argo_debug.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_param.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_ip.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_errno.h>
end_include

begin_include
include|#
directive|include
file|<netiso/iso_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_stat.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_tpdu.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_trace.h>
end_include

begin_include
include|#
directive|include
file|<netiso/tp_user.h>
end_include

begin_include
include|#
directive|include
file|<netiso/cons.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRUE
end_ifdef

begin_undef
undef|#
directive|undef
name|FALSE
end_undef

begin_undef
undef|#
directive|undef
name|TRUE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netccitt/x25.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk.h>
end_include

begin_include
include|#
directive|include
file|<netccitt/pk_var.h>
end_include

begin_function_decl
name|void
name|tp_rsyset
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * NAME: 	tp_local_credit()  *  * CALLED FROM:  *  tp_emit(), tp_usrreq()  *  * FUNCTION and ARGUMENTS:  *	Computes the local credit and stashes it in tpcb->tp_lcredit.  *  It's a macro in the production system rather than a procdure.  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  *  This doesn't actually get called in a production system -  *  the macro gets expanded instead in place of calls to this proc.  *  But for debugging, we call this and that allows us to add  *  debugging messages easily here.  */
end_comment

begin_function
name|void
name|tp_local_credit
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CREDIT
argument_list|)
name|printf
argument_list|(
literal|"ref 0x%x lcdt 0x%x l_tpdusize 0x%x decbit 0x%x\n"
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
name|tpcb
operator|->
name|tp_decbit
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CREDIT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"lcdt tpdusz \n"
argument_list|,
name|tpcb
operator|->
name|tp_lcredit
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_comment
comment|/*  * NAME:  tp_protocol_error()  *  * CALLED FROM:  *  tp_driver(), when it doesn't know what to do with  * 	a combo of event, state, predicate  *  * FUNCTION and ARGUMENTS:  *  print error mesg  *  * RETURN VALUE:  *  EIO - always  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|int
name|tp_protocol_error
parameter_list|(
name|e
parameter_list|,
name|tpcb
parameter_list|)
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"TP PROTOCOL ERROR! tpcb 0x%x event 0x%x, state 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|e
operator|->
name|ev_number
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_DRIVER
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"PROTOCOL ERROR tpcb event state"
argument_list|,
name|tpcb
argument_list|,
name|e
operator|->
name|ev_number
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
name|EIO
return|;
comment|/* for lack of anything better */
block|}
end_function

begin_comment
comment|/* Not used at the moment */
end_comment

begin_function
name|ProtoHook
name|tp_drain
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * NAME: tp_indicate()  *  * CALLED FROM:  * 	tp.trans when XPD arrive, when a connection is being disconnected by  *  the arrival of a DR or ER, and when a connection times out.  *  * FUNCTION and ARGUMENTS:  *  (ind) is the type of indication : T_DISCONNECT, T_XPD  *  (error) is an E* value that will be put in the socket structure  *  to be passed along to the user later.  * 	Gives a SIGURG to the user process or group indicated by the socket  * 	attached to the tpcb.  *  * RETURNS:  Rien  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_indicate
parameter_list|(
name|ind
parameter_list|,
name|tpcb
parameter_list|,
name|error
parameter_list|)
name|int
name|ind
decl_stmt|;
name|u_short
name|error
decl_stmt|;
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
name|tpcb
operator|->
name|tp_sock
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_INDICATION
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTindicate
argument_list|,
name|ind
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_fsuffix
operator|)
argument_list|,
name|error
argument_list|,
name|so
operator|->
name|so_pgid
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_INDICATION
argument_list|)
name|char
modifier|*
name|ls
decl_stmt|,
modifier|*
name|fs
decl_stmt|;
name|ls
operator|=
name|tpcb
operator|->
name|tp_lsuffix
operator|,
name|fs
operator|=
name|tpcb
operator|->
name|tp_fsuffix
operator|,
name|printf
argument_list|(
literal|"indicate 0x%x lsuf 0x%02x%02x fsuf 0x%02x%02x err 0x%x  noind 0x%x ref 0x%x\n"
argument_list|,
name|ind
argument_list|,
operator|*
name|ls
argument_list|,
operator|*
operator|(
name|ls
operator|+
literal|1
operator|)
argument_list|,
operator|*
name|fs
argument_list|,
operator|*
operator|(
name|fs
operator|+
literal|1
operator|)
argument_list|,
name|error
argument_list|,
comment|/*so->so_pgrp,*/
name|tpcb
operator|->
name|tp_no_disc_indications
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|ind
operator|==
name|ER_TPDU
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|tp_disc_reason
name|x
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTRCVMORE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_OOBDATA
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|x
operator|.
name|dr_hdr
operator|.
name|cmsg_len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|x
operator|.
name|dr_hdr
operator|.
name|cmsg_level
operator|=
name|SOL_TRANSPORT
expr_stmt|;
name|x
operator|.
name|dr_hdr
operator|.
name|cmsg_type
operator|=
name|TPOPT_DISC_REASON
expr_stmt|;
name|x
operator|.
name|dr_reason
operator|=
name|error
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tp_disc_reason
operator|*
argument_list|)
operator|=
name|x
expr_stmt|;
name|sbappendrecord
argument_list|(
operator|&
name|tpcb
operator|->
name|tp_Xrcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
name|so
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|ind
operator|==
name|T_DISCONNECT
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
name|ENOTCONN
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_no_disc_indications
condition|)
return|return;
block|}
name|IFTRACE
argument_list|(
argument|D_INDICATION
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"doing sohasoutofband(so)"
argument_list|,
name|so
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|sohasoutofband
argument_list|(
name|so
argument_list|)
decl_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME : tp_getoptions()  *  * CALLED FROM:  * 	tp.trans whenever we go into OPEN state  *  * FUNCTION and ARGUMENTS:  *  sets the proper flags and values in the tpcb, to control  *  the appropriate actions for the given class, options,  *  sequence space, etc, etc.  *  * RETURNS: Nada  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_getoptions
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|tpcb
operator|->
name|tp_seqmask
operator|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
name|TP_XTD_FMT_MASK
else|:
name|TP_NML_FMT_MASK
expr_stmt|;
name|tpcb
operator|->
name|tp_seqbit
operator|=
name|tpcb
operator|->
name|tp_xtd_format
condition|?
name|TP_XTD_FMT_BIT
else|:
name|TP_NML_FMT_BIT
expr_stmt|;
name|tpcb
operator|->
name|tp_seqhalf
operator|=
name|tpcb
operator|->
name|tp_seqbit
operator|>>
literal|1
expr_stmt|;
name|tpcb
operator|->
name|tp_dt_ticks
operator|=
name|max
argument_list|(
name|tpcb
operator|->
name|tp_dt_ticks
argument_list|,
operator|(
name|tpcb
operator|->
name|tp_peer_acktime
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|tp_rsyset
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME:  tp_recycle_tsuffix()  *  * CALLED FROM:  *  Called when a ref is frozen.  *  * FUNCTION and ARGUMENTS:  *  allows the suffix to be reused.  *  * RETURNS: zilch  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_recycle_tsuffix
parameter_list|(
name|tpcb
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_lsuffix
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
sizeof|sizeof
argument_list|(
name|tpcb
operator|->
name|tp_fsuffix
argument_list|)
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_fsuffixlen
operator|=
name|tpcb
operator|->
name|tp_lsuffixlen
operator|=
literal|0
expr_stmt|;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_recycle_suffix
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * NAME: tp_quench()  *  * CALLED FROM:  *  tp{af}_quench() when ICMP source quench or similar thing arrives.  *  * FUNCTION and ARGUMENTS:  *  Drop the congestion window back to 1.  *  Congestion window scheme:  *  Initial value is 1.  ("slow start" as Nagle, et. al. call it)  *  For each good ack that arrives, the congestion window is increased  *  by 1 (up to max size of logical infinity, which is to say,  *	it doesn't wrap around).  *  Source quench causes it to drop back to 1.  *  tp_send() uses the smaller of (regular window, congestion window).  *  One retransmission strategy option is to have any retransmission  *	cause reset the congestion window back  to 1.  *  *	(cmd) is either PRC_QUENCH: source quench, or  *		PRC_QUENCH2: dest. quench (dec bit)  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_function
name|void
name|tp_quench
parameter_list|(
name|tpcb
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|IFDEBUG
argument_list|(
argument|D_QUENCH
argument_list|)
name|printf
argument_list|(
literal|"tp_quench tpcb 0x%x ref 0x%x sufx 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
operator|*
operator|(
name|u_short
operator|*
operator|)
operator|(
name|tpcb
operator|->
name|tp_lsuffix
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cong_win 0x%x decbit 0x%x \n"
argument_list|,
name|tpcb
operator|->
name|tp_cong_win
argument_list|,
name|tpcb
operator|->
name|tp_decbit
argument_list|)
expr_stmt|;
name|ENDDEBUG
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_QUENCH
case|:
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
name|IncStat
argument_list|(
name|ts_quench
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRC_QUENCH2
case|:
name|tpcb
operator|->
name|tp_cong_win
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
comment|/* might as well quench source also */
name|tpcb
operator|->
name|tp_decbit
operator|=
name|TP_DECBIT_CLEAR_COUNT
expr_stmt|;
name|IncStat
argument_list|(
name|ts_rcvdecbit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * NAME:	tp_netcmd()  *  * CALLED FROM:  *  * FUNCTION and ARGUMENTS:  *  * RETURNS:  *  * SIDE EFFECTS:  *  * NOTES:  */
end_comment

begin_macro
name|tp_netcmd
argument_list|(
argument|tpcb
argument_list|,
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|TPCONS
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|pklcd
modifier|*
name|lcp
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_netservice
operator|!=
name|ISO_CONS
condition|)
return|return;
name|isop
operator|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
expr_stmt|;
name|lcp
operator|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONN_CLOSE
case|:
case|case
name|CONN_REFUSE
case|:
if|if
condition|(
name|isop
operator|->
name|isop_refcnt
operator|==
literal|1
condition|)
block|{
comment|/* This is really superfluous, since it would happen 			   anyway in iso_pcbdetach, although it is a courtesy 			   to free up the x.25 channel before the refwait timer 			   expires. */
name|lcp
operator|->
name|lcd_upper
operator|=
literal|0
expr_stmt|;
name|lcp
operator|->
name|lcd_upnext
operator|=
literal|0
expr_stmt|;
name|pk_disconnect
argument_list|(
name|lcp
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_chan
operator|=
literal|0
expr_stmt|;
name|isop
operator|->
name|isop_refcnt
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"tp_netcmd(0x%x, 0x%x) NOT IMPLEMENTED\n"
argument_list|,
name|tpcb
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
comment|/* TPCONS */
name|printf
argument_list|(
literal|"tp_netcmd(): X25 NOT CONFIGURED!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_ctloutput() and tp_emit()  * FUNCTION and ARGUMENTS:  * 	Convert a class mask to the highest numeric value it represents.  */
end_comment

begin_function
name|int
name|tp_mask_to_num
parameter_list|(
name|x
parameter_list|)
name|u_char
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|4
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|x
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
operator|(
name|j
operator|==
literal|4
operator|)
operator|||
operator|(
name|j
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* for now */
if|if
condition|(
operator|(
name|j
operator|!=
literal|4
operator|)
operator|&&
operator|(
name|j
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"ASSERTION ERROR: tp_mask_to_num: x 0x%x j %d\n"
argument_list|,
name|x
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_mask_to_num(x) returns j"
argument_list|,
name|x
argument_list|,
name|j
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_mask_to_num(0x%x) returns 0x%x\n"
argument_list|,
name|x
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|ENDDEBUG
return|return
name|j
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|copyQOSparms
argument_list|(
argument|src
argument_list|,
argument|dst
argument_list|)
expr|struct
name|tp_conn_param
operator|*
name|src
operator|,
operator|*
name|dst
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* copy all but the bits stuff at the end */
define|#
directive|define
name|COPYSIZE
value|(12 * sizeof(short))
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|src
argument_list|,
operator|(
name|caddr_t
operator|)
name|dst
argument_list|,
name|COPYSIZE
argument_list|)
expr_stmt|;
name|dst
operator|->
name|p_tpdusize
operator|=
name|src
operator|->
name|p_tpdusize
expr_stmt|;
name|dst
operator|->
name|p_ack_strat
operator|=
name|src
operator|->
name|p_ack_strat
expr_stmt|;
name|dst
operator|->
name|p_rx_strat
operator|=
name|src
operator|->
name|p_rx_strat
expr_stmt|;
undef|#
directive|undef
name|COPYSIZE
block|}
end_block

begin_comment
comment|/*  * Determine a reasonable value for maxseg size.  * If the route is known, check route for mtu.  * We also initialize the congestion/slow start  * window to be a single segment if the destination isn't local.  * While looking at the routing entry, we also initialize other path-dependent  * parameters from pre-set or cached values in the routing entry.  */
end_comment

begin_function
name|void
name|tp_mss
parameter_list|(
name|tpcb
parameter_list|,
name|nhdr_size
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|nhdr_size
decl_stmt|;
block|{
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|rtt
decl_stmt|,
name|mss
decl_stmt|;
name|u_long
name|bufsize
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ssthresh
init|=
literal|0
decl_stmt|,
name|rt_mss
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_ptpdusize
condition|)
name|mss
operator|=
name|tpcb
operator|->
name|tp_ptpdusize
operator|<<
literal|7
expr_stmt|;
else|else
name|mss
operator|=
literal|1
operator|<<
name|tpcb
operator|->
name|tp_tpdusize
expr_stmt|;
name|so
operator|=
name|tpcb
operator|->
name|tp_sock
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
operator|*
operator|(
name|tpcb
operator|->
name|tp_routep
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|bufsize
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
goto|goto
name|punt_route
goto|;
block|}
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|RTV_MTU
comment|/* if route characteristics exist ... */
comment|/* 	 * While we're here, check if there's an initial rtt 	 * or rttvar.  Convert from the route-table units 	 * to hz ticks for the smoothed timers and slow-timeout units 	 * for other inital variables. 	 */
if|if
condition|(
name|tpcb
operator|->
name|tp_rtt
operator|==
literal|0
operator|&&
operator|(
name|rtt
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rtt
operator|)
condition|)
block|{
name|tpcb
operator|->
name|tp_rtt
operator|=
name|rtt
operator|*
name|hz
operator|/
name|RTM_RTTUNIT
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rttvar
condition|)
name|tpcb
operator|->
name|tp_rtv
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_rttvar
operator|*
name|hz
operator|/
name|RTM_RTTUNIT
expr_stmt|;
else|else
name|tpcb
operator|->
name|tp_rtv
operator|=
name|tpcb
operator|->
name|tp_rtt
expr_stmt|;
block|}
comment|/* 	 * if there's an mtu associated with the route, use it 	 */
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
condition|)
name|rt_mss
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|-
name|nhdr_size
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* RTV_MTU */
name|rt_mss
operator|=
operator|(
name|ifp
operator|->
name|if_mtu
operator|-
name|nhdr_size
operator|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_ptpdusize
operator|==
literal|0
operator|||
comment|/* assume application doesn't care */
name|mss
operator|>
name|rt_mss
comment|/* network won't support what was asked for */
condition|)
name|mss
operator|=
name|rt_mss
expr_stmt|;
comment|/* can propose mtu which are multiples of 128 */
name|mss
operator|&=
operator|~
literal|0x7f
expr_stmt|;
comment|/* 	 * If there's a pipesize, change the socket buffer 	 * to that size. 	 */
ifdef|#
directive|ifdef
name|RTV_SPIPE
if|if
condition|(
operator|(
name|bufsize
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_sendpipe
operator|)
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
name|bufsize
operator|=
name|min
argument_list|(
name|bufsize
argument_list|,
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sbreserve
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RTV_SPIPE
if|if
condition|(
operator|(
name|bufsize
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_recvpipe
operator|)
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
name|bufsize
operator|=
name|min
argument_list|(
name|bufsize
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sbreserve
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
else|else
name|bufsize
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
ifdef|#
directive|ifdef
name|RTV_SSTHRESH
comment|/* 	 * There's some sort of gateway or interface 	 * buffer limit on the path.  Use this to set 	 * the slow start threshhold, but set the 	 * threshold to no less than 2*mss. 	 */
name|ssthresh
operator|=
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_ssthresh
expr_stmt|;
name|punt_route
label|:
comment|/* 	 * The current mss is initialized to the default value. 	 * If we compute a smaller value, reduce the current mss. 	 * If we compute a larger value, return it for use in sending 	 * a max seg size option. 	 * If we received an offer, don't exceed it. 	 * However, do not accept offers under 128 bytes. 	 */
if|if
condition|(
name|tpcb
operator|->
name|tp_l_tpdusize
condition|)
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|)
expr_stmt|;
comment|/* 	 * We want a minimum recv window of 4 packets to 	 * signal packet loss by duplicate acks. 	 */
name|mss
operator|=
name|min
argument_list|(
name|mss
argument_list|,
name|bufsize
operator|>>
literal|2
argument_list|)
operator|&
operator|~
literal|0x7f
expr_stmt|;
name|mss
operator|=
name|max
argument_list|(
name|mss
argument_list|,
literal|128
argument_list|)
expr_stmt|;
comment|/* sanity */
name|tpcb
operator|->
name|tp_cong_win
operator|=
operator|(
name|rt
operator|==
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|)
condition|?
name|mss
else|:
name|bufsize
expr_stmt|;
name|tpcb
operator|->
name|tp_l_tpdusize
operator|=
name|mss
expr_stmt|;
name|tp_rsyset
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_ssthresh
operator|=
name|max
argument_list|(
literal|2
operator|*
name|mss
argument_list|,
name|ssthresh
argument_list|)
expr_stmt|;
comment|/* Calculate log2 of mss */
for|for
control|(
name|i
operator|=
name|TP_MIN_TPDUSIZE
operator|+
literal|1
init|;
name|i
operator|<=
name|TP_MAX_TPDUSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|>
name|mss
condition|)
break|break;
name|i
operator|--
expr_stmt|;
name|tpcb
operator|->
name|tp_tpdusize
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* RTV_MTU */
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_usrreq on PRU_CONNECT and tp_input on receipt of CR  *  * FUNCTION and ARGUMENTS:  * 	-- An mbuf containing the peer's network address.  *  -- Our control block, which will be modified  *  -- In the case of cons, a control block for that layer.  *  *  * RETURNS:  *	errno value	 :  *	EAFNOSUPPORT if can't find an nl_protosw for x.25 (really could panic)  *	ECONNREFUSED if trying to run TP0 with non-type 37 address  *  possibly other E* returned from cons_netcmd()  *  * SIDE EFFECTS:  *   Determines recommended tpdusize, buffering and intial delays  *	 based on information cached on the route.  */
end_comment

begin_function
name|int
name|tp_route_to
parameter_list|(
name|m
parameter_list|,
name|tpcb
parameter_list|,
name|channel
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|caddr_t
name|channel
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
comment|/* NOTE: this may be a sockaddr_in */
specifier|extern
name|struct
name|tp_conn_param
name|tp_conn_param
index|[]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|save_netservice
init|=
name|tpcb
operator|->
name|tp_netservice
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
literal|0
decl_stmt|;
name|int
name|nhdr_size
decl_stmt|,
name|mtu
decl_stmt|,
name|bufsize
decl_stmt|;
name|siso
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_iso
operator|*
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"route_to: so  afi netservice class"
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
name|siso
operator|->
name|siso_addr
operator|.
name|isoa_genaddr
index|[
literal|0
index|]
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to( m x%x, channel 0x%x, tpcb 0x%x netserv 0x%x)\n"
argument_list|,
name|m
argument_list|,
name|channel
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|"m->mlen x%x, m->m_data:\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|channel
condition|)
block|{
ifdef|#
directive|ifdef
name|TPCONS
name|struct
name|pklcd
modifier|*
name|lcp
init|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|channel
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|lcp
operator|->
name|lcd_upnext
decl_stmt|,
modifier|*
name|isop_new
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
comment|/* The next 2 lines believe that you haven't 		   set any network level options or done a pcbconnect 		   and XXXXXXX'edly apply to both inpcb's and isopcb's */
name|remque
argument_list|(
name|isop_new
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|isop_new
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_npcb
operator|=
operator|(
name|caddr_t
operator|)
name|isop
expr_stmt|;
name|tpcb
operator|->
name|tp_netservice
operator|=
name|ISO_CONS
expr_stmt|;
name|tpcb
operator|->
name|tp_nlproto
operator|=
name|nl_protosw
operator|+
name|ISO_CONS
expr_stmt|;
if|if
condition|(
name|isop
operator|->
name|isop_refcnt
operator|++
operator|==
literal|0
condition|)
block|{
name|iso_putsufx
argument_list|(
name|isop
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|tpcb
operator|->
name|tp_lsuffixlen
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
name|isop
operator|->
name|isop_socket
operator|=
name|tpcb
operator|->
name|tp_sock
expr_stmt|;
block|}
else|else
comment|/* there are already connections sharing this */
empty_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
switch|switch
condition|(
name|siso
operator|->
name|siso_family
condition|)
block|{
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|done
goto|;
ifdef|#
directive|ifdef
name|ISO
case|case
name|AF_ISO
case|:
block|{
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
name|int
name|flags
init|=
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
decl_stmt|;
name|tpcb
operator|->
name|tp_netservice
operator|=
name|ISO_CLNS
expr_stmt|;
if|if
condition|(
name|clnp_route
argument_list|(
operator|&
name|siso
operator|->
name|siso_addr
argument_list|,
operator|&
name|isop
operator|->
name|isop_route
argument_list|,
name|flags
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rt
operator|=
name|isop
operator|->
name|isop_route
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_PROTO1
condition|)
name|tpcb
operator|->
name|tp_netservice
operator|=
name|ISO_CONS
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|tpcb
operator|->
name|tp_netservice
operator|=
name|IN_CLNS
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_afamily
operator|!=
name|siso
operator|->
name|siso_family
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to( CHANGING nlproto old 0x%x new 0x%x)\n"
argument_list|,
name|save_netservice
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|error
operator|=
name|tp_set_npcb
argument_list|(
name|tpcb
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to  calling nlp_pcbconn, netserv %d\n"
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_nlproto
init|=
name|nl_protosw
operator|+
name|tpcb
operator|->
name|tp_netservice
decl_stmt|;
name|error
operator|=
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_pcbconn
call|)
argument_list|(
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|nhdr_size
operator|=
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_mtu
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
comment|/* only gets common info */
name|tp_mss
argument_list|(
name|tpcb
argument_list|,
name|nhdr_size
argument_list|)
expr_stmt|;
name|done
label|:
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to  returns 0x%x\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"route_to: returns: error netserv class"
argument_list|,
name|error
argument_list|,
name|tpcb
operator|->
name|tp_netservice
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* class zero version */
end_comment

begin_function
name|void
name|tp0_stash
parameter_list|(
name|tpcb
parameter_list|,
name|e
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
specifier|register
name|struct
name|tp_event
modifier|*
name|e
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|lint
define|#
directive|define
name|E
value|e->ATTR(DT_TPDU)
else|#
directive|else
comment|/* lint */
define|#
directive|define
name|E
value|e->ev_union.EV_DT_TPDU
endif|#
directive|endif
comment|/* lint */
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_rcv
decl_stmt|;
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
name|IFPERF
argument_list|(
argument|tpcb
argument_list|)
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
operator|+=
name|E
operator|.
name|e_datalen
expr_stmt|;
name|tpmeas
argument_list|(
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|TPtime_from_ll
argument_list|,
operator|&
name|e
operator|->
name|e_time
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|PStat
argument_list|(
name|tpcb
argument_list|,
name|Nb_from_ll
argument_list|)
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|)
expr_stmt|;
name|ENDPERF
name|IFDEBUG
argument_list|(
name|D_STASH
argument_list|)
name|printf
argument_list|(
literal|"stash EQ: seq 0x%x datalen 0x%x eot 0x%x"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|,
name|E
operator|.
name|e_eot
argument_list|)
decl_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_STASH
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"stash EQ: seq len eot"
argument_list|,
name|E
operator|.
name|e_seq
argument_list|,
name|E
operator|.
name|e_datalen
argument_list|,
name|E
operator|.
name|e_eot
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
if|if
condition|(
name|E
operator|.
name|e_eot
condition|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|E
operator|.
name|e_data
decl_stmt|;
name|n
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
name|n
operator|->
name|m_act
operator|=
name|MNULL
expr_stmt|;
comment|/* set on tp_input */
block|}
name|sbappend
argument_list|(
name|sb
argument_list|,
name|E
operator|.
name|e_data
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_STASH
argument_list|)
name|dump_mbuf
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|"stash 0: so_rcv after appending"
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|tpcb
operator|->
name|tp_netservice
operator|!=
name|ISO_CONS
condition|)
name|printf
argument_list|(
literal|"tp0_stash: tp running over something wierd\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
init|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
decl_stmt|;
name|pk_flowcontrol
argument_list|(
name|lcp
argument_list|,
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|<=
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tp0_openflow
parameter_list|(
name|tpcb
parameter_list|)
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
block|{
specifier|register
name|struct
name|isopcb
modifier|*
name|isop
init|=
operator|(
expr|struct
name|isopcb
operator|*
operator|)
name|tpcb
operator|->
name|tp_npcb
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_netservice
operator|!=
name|ISO_CONS
condition|)
name|printf
argument_list|(
literal|"tp0_openflow: tp running over something wierd\n"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|register
name|struct
name|pklcd
modifier|*
name|lcp
init|=
operator|(
expr|struct
name|pklcd
operator|*
operator|)
name|isop
operator|->
name|isop_chan
decl_stmt|;
if|if
condition|(
name|lcp
operator|->
name|lcd_rxrnr_condition
condition|)
name|pk_flowcontrol
argument_list|(
name|lcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|TPCONS
end_ifndef

begin_expr_stmt
specifier|static
name|pk_flowcontrol
argument_list|()
block|{}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
comment|/*  * CALLED FROM:  *  tp_ctloutput() when the user sets TPOPT_PERF_MEAS on  *  and tp_newsocket() when a new connection is made from  *  a listening socket with tp_perf_on == true.  * FUNCTION and ARGUMENTS:  *  (tpcb) is the usual; this procedure gets a clear cluster mbuf for  *  a tp_pmeas structure, and makes tpcb->tp_p_meas point to it.  * RETURN VALUE:  *  ENOBUFS if it cannot get a cluster mbuf.  */
name|int
name|tp_setup_perf
argument_list|(
name|tpcb
argument_list|)
specifier|register
expr|struct
name|tp_pcb
operator|*
name|tpcb
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_p_meas
operator|==
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|q
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_PCB
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|MCLGET
argument_list|(
name|q
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|q
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|q
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|tp_pmeas
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_p_mbuf
operator|=
name|q
expr_stmt|;
name|tpcb
operator|->
name|tp_p_meas
operator|=
name|mtod
argument_list|(
name|q
argument_list|,
expr|struct
name|tp_pmeas
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tpcb
operator|->
name|tp_p_meas
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tp_pmeas
argument_list|)
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_PERF_MEAS
argument_list|)
name|printf
argument_list|(
literal|"tpcb 0x%x so 0x%x ref 0x%x tp_p_meas 0x%x tp_perf_on 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_sock
argument_list|,
name|tpcb
operator|->
name|tp_lref
argument_list|,
name|tpcb
operator|->
name|tp_p_meas
argument_list|,
name|tpcb
operator|->
name|tp_perf_on
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tpcb
operator|->
name|tp_perf_on
init|=
literal|1
decl_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TP_PERF_MEAS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_expr_stmt
name|dump_addr
argument_list|(
name|addr
argument_list|)
specifier|register
expr|struct
name|sockaddr
operator|*
name|addr
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|dump_inaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|ISO
case|case
name|AF_ISO
case|:
name|dump_isoaddr
argument_list|(
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* ISO */
default|default:
name|printf
argument_list|(
literal|"BAD AF: 0x%x\n"
argument_list|,
name|addr
operator|->
name|sa_family
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|MAX_COLUMNS
value|8
end_define

begin_comment
comment|/*  *	Dump the buffer to the screen in a readable format. Format is:  *  *		hex/dec  where hex is the hex format, dec is the decimal format.  *		columns of hex/dec numbers will be printed, followed by the  *		character representations (if printable).  */
end_comment

begin_macro
name|Dump_buf
argument_list|(
argument|buf
argument_list|,
argument|len
argument_list|)
end_macro

begin_decl_stmt
name|caddr_t
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
define|#
directive|define
name|Buf
value|((u_char *)buf)
name|printf
argument_list|(
literal|"Dump buf 0x%x len 0x%x\n"
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|MAX_COLUMNS
control|)
block|{
name|printf
argument_list|(
literal|"+%d:\t"
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_COLUMNS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|j
operator|<
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"%x/%d\t"
argument_list|,
name|Buf
index|[
name|i
operator|+
name|j
index|]
argument_list|,
name|Buf
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"	"
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAX_COLUMNS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|j
operator|<
name|len
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|Buf
index|[
name|i
operator|+
name|j
index|]
operator|)
operator|>
literal|31
operator|)
operator|&&
operator|(
operator|(
name|Buf
index|[
name|i
operator|+
name|j
index|]
operator|)
operator|<
literal|128
operator|)
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|Buf
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGO_DEBUG */
end_comment

end_unit

