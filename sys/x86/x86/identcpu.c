begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Terrence R. Lambert.  * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.  * Copyright (c) 1997 KATO Takenori.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: Id: machdep.c,v 1.193 1996/06/18 01:22:04 bde Exp  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/power.h>
end_include

begin_include
include|#
directive|include
file|<machine/asmacros.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/segments.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<amd64/vmm/intel/vmx_controls.h>
end_include

begin_include
include|#
directive|include
file|<x86/isa/icu.h>
end_include

begin_include
include|#
directive|include
file|<x86/vmware.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|IDENTBLUE_CYRIX486
value|0
end_define

begin_define
define|#
directive|define
name|IDENTBLUE_IBMCPU
value|1
end_define

begin_define
define|#
directive|define
name|IDENTBLUE_CYRIXM2
value|2
end_define

begin_function_decl
specifier|static
name|void
name|identifycyrix
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_transmeta_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|u_int
name|find_cpu_vendor_id
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_AMD_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_INTEL_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_INTEL_TLB
parameter_list|(
name|u_int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_hypervisor_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_svm_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_via_padlock_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_vmx_info
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_decl_stmt
name|int
name|cpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we 386, 386sx, 486, etc? */
end_comment

begin_decl_stmt
name|int
name|cpu_class
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|u_int
name|cpu_feature
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Feature flags */
end_comment

begin_decl_stmt
name|u_int
name|cpu_feature2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Feature flags */
end_comment

begin_decl_stmt
name|u_int
name|amd_feature
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD feature flags */
end_comment

begin_decl_stmt
name|u_int
name|amd_feature2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD feature flags */
end_comment

begin_decl_stmt
name|u_int
name|amd_pminfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD advanced power management info */
end_comment

begin_decl_stmt
name|u_int
name|via_feature_rng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA RNG features */
end_comment

begin_decl_stmt
name|u_int
name|via_feature_xcrypt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VIA ACE features */
end_comment

begin_decl_stmt
name|u_int
name|cpu_high
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest arg to CPUID */
end_comment

begin_decl_stmt
name|u_int
name|cpu_exthigh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Highest arg to extended CPUID */
end_comment

begin_decl_stmt
name|u_int
name|cpu_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stepping ID */
end_comment

begin_decl_stmt
name|u_int
name|cpu_procinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HyperThreading Info / Brand Index / CLFUSH */
end_comment

begin_decl_stmt
name|u_int
name|cpu_procinfo2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Multicore info */
end_comment

begin_decl_stmt
name|char
name|cpu_vendor
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU Origin code */
end_comment

begin_decl_stmt
name|u_int
name|cpu_vendor_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CPU vendor ID */
end_comment

begin_decl_stmt
name|u_int
name|cpu_fxsr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SSE enabled */
end_comment

begin_decl_stmt
name|u_int
name|cpu_mxcsr_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid bits in mxcsr */
end_comment

begin_decl_stmt
name|u_int
name|cpu_clflush_line_size
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cpu_stdext_feature
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cpu_stdext_feature2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cpu_max_ext_state_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|cpu_mon_mwait_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MONITOR/MWAIT flags (CPUID.05H.ECX) */
end_comment

begin_decl_stmt
name|u_int
name|cpu_mon_min_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MONITOR minimum range size, bytes */
end_comment

begin_decl_stmt
name|u_int
name|cpu_mon_max_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MONITOR minimum range size, bytes */
end_comment

begin_decl_stmt
name|u_int
name|cpu_maxphyaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max phys addr width in bits */
end_comment

begin_decl_stmt
name|char
name|machine
index|[]
init|=
name|MACHINE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|via_feature_rng
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|via_feature_rng
argument_list|,
literal|0
argument_list|,
literal|"VIA RNG feature available in CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|via_feature_xcrypt
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|via_feature_xcrypt
argument_list|,
literal|0
argument_list|,
literal|"VIA xcrypt feature available in CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|SCTL_MASK32
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|adaptive_machine_arch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sysctl_hw_machine
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SCTL_MASK32
specifier|static
specifier|const
name|char
name|machine32
index|[]
init|=
literal|"i386"
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTL_MASK32
if|if
condition|(
operator|(
name|req
operator|->
name|flags
operator|&
name|SCTL_MASK32
operator|)
operator|!=
literal|0
operator|&&
name|adaptive_machine_arch
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|machine32
argument_list|,
sizeof|sizeof
argument_list|(
name|machine32
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|machine
argument_list|,
sizeof|sizeof
argument_list|(
name|machine
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|HW_MACHINE
argument_list|,
name|machine
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_hw_machine
argument_list|,
literal|"A"
argument_list|,
literal|"Machine class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|HW_MACHINE
argument_list|,
name|machine
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|machine
argument_list|,
literal|0
argument_list|,
literal|"Machine class"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|cpu_model
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|HW_MODEL
argument_list|,
name|model
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|cpu_model
argument_list|,
literal|0
argument_list|,
literal|"Machine model"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|hw_clockrate
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|clockrate
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|hw_clockrate
argument_list|,
literal|0
argument_list|,
literal|"CPU instruction clock rate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|hv_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|hv_vendor
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|hv_vendor
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|hv_vendor
argument_list|,
literal|0
argument_list|,
literal|"Hypervisor vendor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|tsc_post_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cpu_brand
index|[
literal|48
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|MAX_BRAND_INDEX
value|8
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|cpu_brandtable
index|[
name|MAX_BRAND_INDEX
operator|+
literal|1
index|]
init|=
block|{
name|NULL
block|,
comment|/* No brand */
literal|"Intel Celeron"
block|,
literal|"Intel Pentium III"
block|,
literal|"Intel Pentium III Xeon"
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"Intel Pentium 4"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|cpu_name
decl_stmt|;
name|int
name|cpu_class
decl_stmt|;
block|}
name|cpus
index|[]
init|=
block|{
block|{
literal|"Intel 80286"
block|,
name|CPUCLASS_286
block|}
block|,
comment|/* CPU_286   */
block|{
literal|"i386SX"
block|,
name|CPUCLASS_386
block|}
block|,
comment|/* CPU_386SX */
block|{
literal|"i386DX"
block|,
name|CPUCLASS_386
block|}
block|,
comment|/* CPU_386   */
block|{
literal|"i486SX"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_486SX */
block|{
literal|"i486DX"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_486   */
block|{
literal|"Pentium"
block|,
name|CPUCLASS_586
block|}
block|,
comment|/* CPU_586   */
block|{
literal|"Cyrix 486"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_486DLC */
block|{
literal|"Pentium Pro"
block|,
name|CPUCLASS_686
block|}
block|,
comment|/* CPU_686 */
block|{
literal|"Cyrix 5x86"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_M1SC */
block|{
literal|"Cyrix 6x86"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_M1 */
block|{
literal|"Blue Lightning"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_BLUE */
block|{
literal|"Cyrix 6x86MX"
block|,
name|CPUCLASS_686
block|}
block|,
comment|/* CPU_M2 */
block|{
literal|"NexGen 586"
block|,
name|CPUCLASS_386
block|}
block|,
comment|/* CPU_NX586 (XXX) */
block|{
literal|"Cyrix 486S/DX"
block|,
name|CPUCLASS_486
block|}
block|,
comment|/* CPU_CY486DX */
block|{
literal|"Pentium II"
block|,
name|CPUCLASS_686
block|}
block|,
comment|/* CPU_PII */
block|{
literal|"Pentium III"
block|,
name|CPUCLASS_686
block|}
block|,
comment|/* CPU_PIII */
block|{
literal|"Pentium 4"
block|,
name|CPUCLASS_686
block|}
block|,
comment|/* CPU_P4 */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|vendor
decl_stmt|;
name|u_int
name|vendor_id
decl_stmt|;
block|}
name|cpu_vendors
index|[]
init|=
block|{
block|{
name|INTEL_VENDOR_ID
block|,
name|CPU_VENDOR_INTEL
block|}
block|,
comment|/* GenuineIntel */
block|{
name|AMD_VENDOR_ID
block|,
name|CPU_VENDOR_AMD
block|}
block|,
comment|/* AuthenticAMD */
block|{
name|CENTAUR_VENDOR_ID
block|,
name|CPU_VENDOR_CENTAUR
block|}
block|,
comment|/* CentaurHauls */
ifdef|#
directive|ifdef
name|__i386__
block|{
name|NSC_VENDOR_ID
block|,
name|CPU_VENDOR_NSC
block|}
block|,
comment|/* Geode by NSC */
block|{
name|CYRIX_VENDOR_ID
block|,
name|CPU_VENDOR_CYRIX
block|}
block|,
comment|/* CyrixInstead */
block|{
name|TRANSMETA_VENDOR_ID
block|,
name|CPU_VENDOR_TRANSMETA
block|}
block|,
comment|/* GenuineTMx86 */
block|{
name|SIS_VENDOR_ID
block|,
name|CPU_VENDOR_SIS
block|}
block|,
comment|/* SiS SiS SiS  */
block|{
name|UMC_VENDOR_ID
block|,
name|CPU_VENDOR_UMC
block|}
block|,
comment|/* UMC UMC UMC  */
block|{
name|NEXGEN_VENDOR_ID
block|,
name|CPU_VENDOR_NEXGEN
block|}
block|,
comment|/* NexGenDriven */
block|{
name|RISE_VENDOR_ID
block|,
name|CPU_VENDOR_RISE
block|}
block|,
comment|/* RiseRiseRise */
if|#
directive|if
literal|0
comment|/* XXX CPUID 8000_0000h and 8086_0000h, not 0000_0000h */
block|{ "TransmetaCPU",	CPU_VENDOR_TRANSMETA },
endif|#
directive|endif
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
name|void
name|printcpuinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|brand
decl_stmt|;
name|printf
argument_list|(
literal|"CPU: "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|cpu_class
operator|=
name|cpus
index|[
name|cpu
index|]
operator|.
name|cpu_class
expr_stmt|;
name|strncpy
argument_list|(
name|cpu_model
argument_list|,
name|cpus
index|[
name|cpu
index|]
operator|.
name|cpu_name
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_model
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|strncpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Hammer"
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu_model
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for extended CPUID information and a processor name. */
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000004
condition|)
block|{
name|brand
operator|=
name|cpu_brand
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0x80000002
init|;
name|i
operator|<
literal|0x80000005
condition|;
name|i
operator|++
control|)
block|{
name|do_cpuid
argument_list|(
name|i
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|brand
argument_list|,
name|regs
argument_list|,
sizeof|sizeof
argument_list|(
name|regs
argument_list|)
argument_list|)
expr_stmt|;
name|brand
operator|+=
sizeof|sizeof
argument_list|(
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|cpu_vendor_id
condition|)
block|{
case|case
name|CPU_VENDOR_INTEL
case|:
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
operator|(
name|cpu_id
operator|&
literal|0xf00
operator|)
operator|>
literal|0x300
condition|)
block|{
name|u_int
name|brand_index
decl_stmt|;
name|cpu_model
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0x3000
condition|)
block|{
case|case
literal|0x1000
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Overdrive "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2000
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Dual "
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xf00
condition|)
block|{
case|case
literal|0x400
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"i486 "
argument_list|)
expr_stmt|;
comment|/* Check the particular flavor of 486 */
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0x10
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"DX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"SX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"DX2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"SL"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"SX2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"DX2 Write-Back Enhanced"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"DX4"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x500
case|:
comment|/* Check the particular flavor of 586 */
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|" A-step"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P5"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P54C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P24T"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P55C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P54C"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"/P55C (quarter-micron)"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* nothing */
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_F00F_HACK
argument_list|)
comment|/* 				 * XXX - If/when Intel fixes the bug, this 				 * should also check the version of the 				 * CPU, not just that it's a Pentium. 				 */
name|has_f00f_bug
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|0x600
case|:
comment|/* Check the particular flavor of 686 */
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium Pro A-step"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium Pro"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
case|case
literal|0x50
case|:
case|case
literal|0x60
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium II/Pentium II Xeon/Celeron"
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|CPU_PII
expr_stmt|;
break|break;
case|case
literal|0x70
case|:
case|case
literal|0x80
case|:
case|case
literal|0xa0
case|:
case|case
literal|0xb0
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium III/Pentium III Xeon/Celeron"
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|CPU_PIII
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown 80686"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0xf00
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Pentium 4"
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|CPU_P4
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * If we didn't get a brand name from the extended 			 * CPUID, try to look it up in the brand table. 			 */
if|if
condition|(
name|cpu_high
operator|>
literal|0
operator|&&
operator|*
name|cpu_brand
operator|==
literal|'\0'
condition|)
block|{
name|brand_index
operator|=
name|cpu_procinfo
operator|&
name|CPUID_BRAND_INDEX
expr_stmt|;
if|if
condition|(
name|brand_index
operator|<=
name|MAX_BRAND_INDEX
operator|&&
name|cpu_brandtable
index|[
name|brand_index
index|]
operator|!=
name|NULL
condition|)
name|strcpy
argument_list|(
name|cpu_brand
argument_list|,
name|cpu_brandtable
index|[
name|brand_index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Please make up your mind folks! */
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"EM64T"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|CPU_VENDOR_AMD
case|:
comment|/* 		 * Values taken from AMD Processor Recognition 		 * http://www.amd.com/K6/k6docs/pdf/20734g.pdf 		 * (also describes ``Features'' encodings. 		 */
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"AMD "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xFF0
condition|)
block|{
case|case
literal|0x410
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Standard Am486DX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x430
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Enhanced Am486DX2 Write-Through"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x470
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Enhanced Am486DX2 Write-Back"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x480
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Enhanced Am486DX4/Am5x86 Write-Through"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x490
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Enhanced Am486DX4/Am5x86 Write-Back"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4E0
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Am5x86 Write-Through"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4F0
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Am5x86 Write-Back"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x500
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K5 model 0"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x510
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K5 model 1"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x520
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K5 PR166 (model 2)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x530
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K5 PR200 (model 3)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x560
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K6"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x570
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K6 266 (model 1)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x580
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K6-2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x590
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"K6-III"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a0
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Geode LX"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|cpu_id
operator|&
literal|0xf00
operator|)
operator|==
literal|0xf00
condition|)
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"AMD64 Processor"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|__i386__
case|case
name|CPU_VENDOR_CYRIX
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Cyrix "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xff0
condition|)
block|{
case|case
literal|0x440
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"MediaGX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x520
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"6x86"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x540
case|:
name|cpu_class
operator|=
name|CPUCLASS_586
expr_stmt|;
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"GXm"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x600
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"6x86MX"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Even though CPU supports the cpuid 			 * instruction, it can be disabled. 			 * Therefore, this routine supports all Cyrix 			 * CPUs. 			 */
switch|switch
condition|(
name|cyrix_did
operator|&
literal|0xf0
condition|)
block|{
case|case
literal|0x00
case|:
switch|switch
condition|(
name|cyrix_did
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0x00
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SLC"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DLC"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SLC2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DLC2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SRx"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x05
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DRx"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x06
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SRx2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DRx2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SRu"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x09
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DRu"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SRu2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0b
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DRu2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x10
case|:
switch|switch
condition|(
name|cyrix_did
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0x00
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486S"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x01
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486S2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486Se"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x03
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486S2e"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0a
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0b
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DX2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486DX4"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|0x20
case|:
if|if
condition|(
operator|(
name|cyrix_did
operator|&
literal|0x0f
operator|)
operator|<
literal|8
condition|)
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"6x86"
argument_list|)
expr_stmt|;
comment|/* Where did you get it? */
else|else
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"5x86"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"6x86"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
if|if
condition|(
operator|(
name|cyrix_did
operator|&
literal|0xf000
operator|)
operator|==
literal|0x3000
condition|)
block|{
name|cpu_class
operator|=
name|CPUCLASS_586
expr_stmt|;
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"GXm"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"MediaGX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"6x86MX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf0
case|:
switch|switch
condition|(
name|cyrix_did
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0x0d
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Overdrive CPU"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0e
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Texas Instruments 486SXL"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x0f
case|:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"486SLC/DLC"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
break|break;
case|case
name|CPU_VENDOR_RISE
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Rise "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xff0
condition|)
block|{
case|case
literal|0x500
case|:
comment|/* 6401 and 6441 (Kirin) */
case|case
literal|0x520
case|:
comment|/* 6510 (Lynx) */
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"mP6"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|CPU_VENDOR_CENTAUR
case|:
ifdef|#
directive|ifdef
name|__i386__
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xff0
condition|)
block|{
case|case
literal|0x540
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"IDT WinChip C6"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x580
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"IDT WinChip 2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x590
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"IDT WinChip 3"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x660
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C3 Samuel"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x670
case|:
if|if
condition|(
name|cpu_id
operator|&
literal|0x8
condition|)
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C3 Ezra"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C3 Samuel 2"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x680
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C3 Ezra-T"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x690
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C3 Nehemiah"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6a0
case|:
case|case
literal|0x6d0
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA C7 Esther"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6f0
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA Nano"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA/IDT Unknown"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"VIA "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_id
operator|&
literal|0xff0
operator|)
operator|==
literal|0x6f0
condition|)
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Nano Processor"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
ifdef|#
directive|ifdef
name|__i386__
case|case
name|CPU_VENDOR_IBM
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Blue Lightning CPU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_VENDOR_NSC
case|:
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xff0
condition|)
block|{
case|case
literal|0x540
case|:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Geode SC1100"
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|CPU_GEODE1100
expr_stmt|;
break|break;
default|default:
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
literal|"Geode/NSC unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
default|default:
name|strcat
argument_list|(
name|cpu_model
argument_list|,
literal|"Unknown"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Replace cpu_model with cpu_brand minus leading spaces if 	 * we have one. 	 */
name|brand
operator|=
name|cpu_brand
expr_stmt|;
while|while
condition|(
operator|*
name|brand
operator|==
literal|' '
condition|)
operator|++
name|brand
expr_stmt|;
if|if
condition|(
operator|*
name|brand
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|cpu_model
argument_list|,
name|brand
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s ("
argument_list|,
name|cpu_model
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsc_freq
operator|!=
literal|0
condition|)
block|{
name|hw_clockrate
operator|=
operator|(
name|tsc_freq
operator|+
literal|5000
operator|)
operator|/
literal|1000000
expr_stmt|;
name|printf
argument_list|(
literal|"%jd.%02d-MHz "
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|tsc_freq
operator|+
literal|4999
argument_list|)
operator|/
literal|1000000
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|tsc_freq
operator|+
literal|4999
operator|)
operator|/
literal|10000
argument_list|)
operator|%
literal|100
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__i386__
switch|switch
condition|(
name|cpu_class
condition|)
block|{
case|case
name|CPUCLASS_286
case|:
name|printf
argument_list|(
literal|"286"
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPUCLASS_386
case|:
name|printf
argument_list|(
literal|"386"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|I486_CPU
argument_list|)
case|case
name|CPUCLASS_486
case|:
name|printf
argument_list|(
literal|"486"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I586_CPU
argument_list|)
case|case
name|CPUCLASS_586
case|:
name|printf
argument_list|(
literal|"586"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|I686_CPU
argument_list|)
case|case
name|CPUCLASS_686
case|:
name|printf
argument_list|(
literal|"686"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"Unknown"
argument_list|)
expr_stmt|;
comment|/* will panic below... */
block|}
else|#
directive|else
name|printf
argument_list|(
literal|"K8"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"-class CPU)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpu_vendor
condition|)
name|printf
argument_list|(
literal|"  Origin=\"%s\""
argument_list|,
name|cpu_vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_id
condition|)
name|printf
argument_list|(
literal|"  Id=0x%x"
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CENTAUR
operator|||
ifdef|#
directive|ifdef
name|__i386__
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_TRANSMETA
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_RISE
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_NSC
operator|||
operator|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CYRIX
operator|&&
operator|(
operator|(
name|cpu_id
operator|&
literal|0xf00
operator|)
operator|>
literal|0x500
operator|)
operator|)
operator|||
endif|#
directive|endif
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"  Family=0x%x"
argument_list|,
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Model=0x%x"
argument_list|,
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Stepping=%u"
argument_list|,
name|cpu_id
operator|&
name|CPUID_STEPPING
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CYRIX
condition|)
name|printf
argument_list|(
literal|"\n  DIR=0x%04x"
argument_list|,
name|cyrix_did
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * AMD CPUID Specification 		 * http://support.amd.com/us/Embedded_TechDocs/25481.pdf 		 * 		 * Intel Processor Identification and CPUID Instruction 		 * http://www.intel.com/assets/pdf/appnote/241618.pdf 		 */
if|if
condition|(
name|cpu_high
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Here we should probably set up flags indicating 			 * whether or not various features are available. 			 * The interesting ones are probably VME, PSE, PAE, 			 * and PGE.  The code already assumes without bothering 			 * to check that all CPUs>= Pentium have a TSC and 			 * MSRs. 			 */
name|printf
argument_list|(
literal|"\n  Features=0x%b"
argument_list|,
name|cpu_feature
argument_list|,
literal|"\020"
literal|"\001FPU"
comment|/* Integral FPU */
literal|"\002VME"
comment|/* Extended VM86 mode support */
literal|"\003DE"
comment|/* Debugging Extensions (CR4.DE) */
literal|"\004PSE"
comment|/* 4MByte page tables */
literal|"\005TSC"
comment|/* Timestamp counter */
literal|"\006MSR"
comment|/* Machine specific registers */
literal|"\007PAE"
comment|/* Physical address extension */
literal|"\010MCE"
comment|/* Machine Check support */
literal|"\011CX8"
comment|/* CMPEXCH8 instruction */
literal|"\012APIC"
comment|/* SMP local APIC */
literal|"\013oldMTRR"
comment|/* Previous implementation of MTRR */
literal|"\014SEP"
comment|/* Fast System Call */
literal|"\015MTRR"
comment|/* Memory Type Range Registers */
literal|"\016PGE"
comment|/* PG_G (global bit) support */
literal|"\017MCA"
comment|/* Machine Check Architecture */
literal|"\020CMOV"
comment|/* CMOV instruction */
literal|"\021PAT"
comment|/* Page attributes table */
literal|"\022PSE36"
comment|/* 36 bit address space support */
literal|"\023PN"
comment|/* Processor Serial number */
literal|"\024CLFLUSH"
comment|/* Has the CLFLUSH instruction */
literal|"\025<b20>"
literal|"\026DTS"
comment|/* Debug Trace Store */
literal|"\027ACPI"
comment|/* ACPI support */
literal|"\030MMX"
comment|/* MMX instructions */
literal|"\031FXSR"
comment|/* FXSAVE/FXRSTOR */
literal|"\032SSE"
comment|/* Streaming SIMD Extensions */
literal|"\033SSE2"
comment|/* Streaming SIMD Extensions #2 */
literal|"\034SS"
comment|/* Self snoop */
literal|"\035HTT"
comment|/* Hyperthreading (see EBX bit 16-23) */
literal|"\036TM"
comment|/* Thermal Monitor clock slowdown */
literal|"\037IA64"
comment|/* CPU can execute IA64 instructions */
literal|"\040PBE"
comment|/* Pending Break Enable */
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_feature2
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  Features2=0x%b"
argument_list|,
name|cpu_feature2
argument_list|,
literal|"\020"
literal|"\001SSE3"
comment|/* SSE3 */
literal|"\002PCLMULQDQ"
comment|/* Carry-Less Mul Quadword */
literal|"\003DTES64"
comment|/* 64-bit Debug Trace */
literal|"\004MON"
comment|/* MONITOR/MWAIT Instructions */
literal|"\005DS_CPL"
comment|/* CPL Qualified Debug Store */
literal|"\006VMX"
comment|/* Virtual Machine Extensions */
literal|"\007SMX"
comment|/* Safer Mode Extensions */
literal|"\010EST"
comment|/* Enhanced SpeedStep */
literal|"\011TM2"
comment|/* Thermal Monitor 2 */
literal|"\012SSSE3"
comment|/* SSSE3 */
literal|"\013CNXT-ID"
comment|/* L1 context ID available */
literal|"\014SDBG"
comment|/* IA32 silicon debug */
literal|"\015FMA"
comment|/* Fused Multiply Add */
literal|"\016CX16"
comment|/* CMPXCHG16B Instruction */
literal|"\017xTPR"
comment|/* Send Task Priority Messages*/
literal|"\020PDCM"
comment|/* Perf/Debug Capability MSR */
literal|"\021<b16>"
literal|"\022PCID"
comment|/* Process-context Identifiers*/
literal|"\023DCA"
comment|/* Direct Cache Access */
literal|"\024SSE4.1"
comment|/* SSE 4.1 */
literal|"\025SSE4.2"
comment|/* SSE 4.2 */
literal|"\026x2APIC"
comment|/* xAPIC Extensions */
literal|"\027MOVBE"
comment|/* MOVBE Instruction */
literal|"\030POPCNT"
comment|/* POPCNT Instruction */
literal|"\031TSCDLT"
comment|/* TSC-Deadline Timer */
literal|"\032AESNI"
comment|/* AES Crypto */
literal|"\033XSAVE"
comment|/* XSAVE/XRSTOR States */
literal|"\034OSXSAVE"
comment|/* OS-Enabled State Management*/
literal|"\035AVX"
comment|/* Advanced Vector Extensions */
literal|"\036F16C"
comment|/* Half-precision conversions */
literal|"\037RDRAND"
comment|/* RDRAND Instruction */
literal|"\040HV"
comment|/* Hypervisor */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amd_feature
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  AMD Features=0x%b"
argument_list|,
name|amd_feature
argument_list|,
literal|"\020"
comment|/* in hex */
literal|"\001<s0>"
comment|/* Same */
literal|"\002<s1>"
comment|/* Same */
literal|"\003<s2>"
comment|/* Same */
literal|"\004<s3>"
comment|/* Same */
literal|"\005<s4>"
comment|/* Same */
literal|"\006<s5>"
comment|/* Same */
literal|"\007<s6>"
comment|/* Same */
literal|"\010<s7>"
comment|/* Same */
literal|"\011<s8>"
comment|/* Same */
literal|"\012<s9>"
comment|/* Same */
literal|"\013<b10>"
comment|/* Undefined */
literal|"\014SYSCALL"
comment|/* Have SYSCALL/SYSRET */
literal|"\015<s12>"
comment|/* Same */
literal|"\016<s13>"
comment|/* Same */
literal|"\017<s14>"
comment|/* Same */
literal|"\020<s15>"
comment|/* Same */
literal|"\021<s16>"
comment|/* Same */
literal|"\022<s17>"
comment|/* Same */
literal|"\023<b18>"
comment|/* Reserved, unknown */
literal|"\024MP"
comment|/* Multiprocessor Capable */
literal|"\025NX"
comment|/* Has EFER.NXE, NX */
literal|"\026<b21>"
comment|/* Undefined */
literal|"\027MMX+"
comment|/* AMD MMX Extensions */
literal|"\030<s23>"
comment|/* Same */
literal|"\031<s24>"
comment|/* Same */
literal|"\032FFXSR"
comment|/* Fast FXSAVE/FXRSTOR */
literal|"\033Page1GB"
comment|/* 1-GB large page support */
literal|"\034RDTSCP"
comment|/* RDTSCP */
literal|"\035<b28>"
comment|/* Undefined */
literal|"\036LM"
comment|/* 64 bit long mode */
literal|"\0373DNow!+"
comment|/* AMD 3DNow! Extensions */
literal|"\0403DNow!"
comment|/* AMD 3DNow! */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|amd_feature2
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  AMD Features2=0x%b"
argument_list|,
name|amd_feature2
argument_list|,
literal|"\020"
literal|"\001LAHF"
comment|/* LAHF/SAHF in long mode */
literal|"\002CMP"
comment|/* CMP legacy */
literal|"\003SVM"
comment|/* Secure Virtual Mode */
literal|"\004ExtAPIC"
comment|/* Extended APIC register */
literal|"\005CR8"
comment|/* CR8 in legacy mode */
literal|"\006ABM"
comment|/* LZCNT instruction */
literal|"\007SSE4A"
comment|/* SSE4A */
literal|"\010MAS"
comment|/* Misaligned SSE mode */
literal|"\011Prefetch"
comment|/* 3DNow! Prefetch/PrefetchW */
literal|"\012OSVW"
comment|/* OS visible workaround */
literal|"\013IBS"
comment|/* Instruction based sampling */
literal|"\014XOP"
comment|/* XOP extended instructions */
literal|"\015SKINIT"
comment|/* SKINIT/STGI */
literal|"\016WDT"
comment|/* Watchdog timer */
literal|"\017<b14>"
literal|"\020LWP"
comment|/* Lightweight Profiling */
literal|"\021FMA4"
comment|/* 4-operand FMA instructions */
literal|"\022TCE"
comment|/* Translation Cache Extension */
literal|"\023<b18>"
literal|"\024NodeId"
comment|/* NodeId MSR support */
literal|"\025<b20>"
literal|"\026TBM"
comment|/* Trailing Bit Manipulation */
literal|"\027Topology"
comment|/* Topology Extensions */
literal|"\030PCXC"
comment|/* Core perf count */
literal|"\031PNXC"
comment|/* NB perf count */
literal|"\032<b25>"
literal|"\033DBE"
comment|/* Data Breakpoint extension */
literal|"\034PTSC"
comment|/* Performance TSC */
literal|"\035PL2I"
comment|/* L2I perf count */
literal|"\036MWAITX"
comment|/* MONITORX/MWAITX instructions */
literal|"\037<b30>"
literal|"\040<b31>"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpu_stdext_feature
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  Structured Extended Features=0x%b"
argument_list|,
name|cpu_stdext_feature
argument_list|,
literal|"\020"
comment|/* RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE */
literal|"\001FSGSBASE"
literal|"\002TSCADJ"
literal|"\003SGX"
comment|/* Bit Manipulation Instructions */
literal|"\004BMI1"
comment|/* Hardware Lock Elision */
literal|"\005HLE"
comment|/* Advanced Vector Instructions 2 */
literal|"\006AVX2"
comment|/* FDP_EXCPTN_ONLY */
literal|"\007FDPEXC"
comment|/* Supervisor Mode Execution Prot. */
literal|"\010SMEP"
comment|/* Bit Manipulation Instructions */
literal|"\011BMI2"
literal|"\012ERMS"
comment|/* Invalidate Processor Context ID */
literal|"\013INVPCID"
comment|/* Restricted Transactional Memory */
literal|"\014RTM"
literal|"\015PQM"
literal|"\016NFPUSG"
comment|/* Intel Memory Protection Extensions */
literal|"\017MPX"
literal|"\020PQE"
comment|/* AVX512 Foundation */
literal|"\021AVX512F"
literal|"\022AVX512DQ"
comment|/* Enhanced NRBG */
literal|"\023RDSEED"
comment|/* ADCX + ADOX */
literal|"\024ADX"
comment|/* Supervisor Mode Access Prevention */
literal|"\025SMAP"
literal|"\026AVX512IFMA"
literal|"\027PCOMMIT"
literal|"\030CLFLUSHOPT"
literal|"\031CLWB"
literal|"\032PROCTRACE"
literal|"\033AVX512PF"
literal|"\034AVX512ER"
literal|"\035AVX512CD"
literal|"\036SHA"
literal|"\037AVX512BW"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpu_stdext_feature2
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  Structured Extended Features2=0x%b"
argument_list|,
name|cpu_stdext_feature2
argument_list|,
literal|"\020"
literal|"\001PREFETCHWT1"
literal|"\002AVX512VBMI"
literal|"\003UMIP"
literal|"\004PKU"
literal|"\005OSPKE"
literal|"\027RDPID"
literal|"\037SGXLC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cpu_feature2
operator|&
name|CPUID2_XSAVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpuid_count
argument_list|(
literal|0xd
argument_list|,
literal|0x1
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\n  XSAVE Features=0x%b"
argument_list|,
name|regs
index|[
literal|0
index|]
argument_list|,
literal|"\020"
literal|"\001XSAVEOPT"
literal|"\002XSAVEC"
literal|"\003XINUSE"
literal|"\004XSAVES"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|via_feature_rng
operator|!=
literal|0
operator|||
name|via_feature_xcrypt
operator|!=
literal|0
condition|)
name|print_via_padlock_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu_feature2
operator|&
name|CPUID2_VMX
condition|)
name|print_vmx_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|amd_feature2
operator|&
name|AMDID2_SVM
condition|)
name|print_svm_info
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|&&
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
condition|)
name|cpu_feature
operator|&=
operator|~
name|CPUID_HTT
expr_stmt|;
comment|/* 			 * If this CPU supports P-state invariant TSC then 			 * mention the capability. 			 */
if|if
condition|(
name|tsc_is_invariant
condition|)
block|{
name|printf
argument_list|(
literal|"\n  TSC: P-state invariant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsc_perf_stat
condition|)
name|printf
argument_list|(
literal|", performance statistics"
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|__i386__
block|}
elseif|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CYRIX
condition|)
block|{
name|printf
argument_list|(
literal|"  DIR=0x%04x"
argument_list|,
name|cyrix_did
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Stepping=%u"
argument_list|,
operator|(
name|cyrix_did
operator|&
literal|0xf000
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Revision=%u"
argument_list|,
operator|(
name|cyrix_did
operator|&
literal|0x0f00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CYRIX_CACHE_REALLY_WORKS
if|if
condition|(
name|cpu
operator|==
name|CPU_M1
operator|&&
operator|(
name|cyrix_did
operator|&
literal|0xff00
operator|)
operator|<
literal|0x1700
condition|)
name|printf
argument_list|(
literal|"\n  CPU cache: write-through mode"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* Avoid ugly blank lines: only print newline when we have to. */
if|if
condition|(
operator|*
name|cpu_vendor
operator|||
name|cpu_id
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
condition|)
name|print_AMD_info
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
condition|)
name|print_INTEL_info
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
elseif|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_TRANSMETA
condition|)
name|print_transmeta_info
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
name|print_hypervisor_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
name|void
name|panicifcpuunsupported
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|I486_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I586_CPU
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|I686_CPU
argument_list|)
error|#
directive|error
error|This kernel is not configured for one of the supported CPUs
endif|#
directive|endif
else|#
directive|else
comment|/* lint */
endif|#
directive|endif
comment|/* lint */
comment|/* 	 * Now that we have told the user what they have, 	 * let them know if that machine type isn't configured. 	 */
switch|switch
condition|(
name|cpu_class
condition|)
block|{
case|case
name|CPUCLASS_286
case|:
comment|/* a 286 should not make it this far, anyway */
case|case
name|CPUCLASS_386
case|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|I486_CPU
argument_list|)
case|case
name|CPUCLASS_486
case|:
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|I586_CPU
argument_list|)
case|case
name|CPUCLASS_586
case|:
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|I686_CPU
argument_list|)
case|case
name|CPUCLASS_686
case|:
endif|#
directive|endif
name|panic
argument_list|(
literal|"CPU class not configured"
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|trap_by_rdmsr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special exception 6 handler.  * The rdmsr instruction generates invalid opcodes fault on 486-class  * Cyrix CPU.  Stacked eip register points the rdmsr instruction in the  * function identblue() when this handler is called.  Stacked eip should  * be advanced.  */
end_comment

begin_decl_stmt
name|inthand_t
name|bluetrap6
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUCLIKE_ASM
end_ifdef

begin_asm
asm|__asm
end_asm

begin_expr_stmt
operator|(
literal|"									\n\ 	.text								\n\ 	.p2align 2,0x90							\n\ 	.type	"
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|bluetrap6
argument_list|)
argument_list|)
literal|",@function		\n\ "
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|bluetrap6
argument_list|)
argument_list|)
literal|":					\n\ 	ss								\n\ 	movl	$0xa8c1d,"
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|trap_by_rdmsr
argument_list|)
argument_list|)
literal|"		\n\ 	addl	$2, (%esp)	/* rdmsr is a 2-byte instruction */	\n\ 	iret								\n\ "
operator|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Special exception 13 handler.  * Accessing non-existent MSR generates general protection fault.  */
end_comment

begin_decl_stmt
name|inthand_t
name|bluetrap13
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUCLIKE_ASM
end_ifdef

begin_asm
asm|__asm
end_asm

begin_expr_stmt
operator|(
literal|"									\n\ 	.text								\n\ 	.p2align 2,0x90							\n\ 	.type	"
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|bluetrap13
argument_list|)
argument_list|)
literal|",@function		\n\ "
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|bluetrap13
argument_list|)
argument_list|)
literal|":					\n\ 	ss								\n\ 	movl	$0xa89c4,"
name|__XSTRING
argument_list|(
name|CNAME
argument_list|(
name|trap_by_rdmsr
argument_list|)
argument_list|)
literal|"		\n\ 	popl	%eax		/* discard error code */		\n\ 	addl	$2, (%esp)	/* rdmsr is a 2-byte instruction */	\n\ 	iret								\n\ "
operator|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Distinguish IBM Blue Lightning CPU from Cyrix CPUs that does not  * support cpuid instruction.  This function should be called after  * loading interrupt descriptor table register.  *  * I don't like this method that handles fault, but I couldn't get  * information for any other methods.  Does blue giant know?  */
end_comment

begin_function
specifier|static
name|int
name|identblue
parameter_list|(
name|void
parameter_list|)
block|{
name|trap_by_rdmsr
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Cyrix 486-class CPU does not support rdmsr instruction. 	 * The rdmsr instruction generates invalid opcode fault, and exception 	 * will be trapped by bluetrap6() on Cyrix 486-class CPU.  The 	 * bluetrap6() set the magic number to trap_by_rdmsr. 	 */
name|setidt
argument_list|(
name|IDT_UD
argument_list|,
name|bluetrap6
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Certain BIOS disables cpuid instruction of Cyrix 6x86MX CPU. 	 * In this case, rdmsr generates general protection fault, and 	 * exception will be trapped by bluetrap13(). 	 */
name|setidt
argument_list|(
name|IDT_GP
argument_list|,
name|bluetrap13
argument_list|,
name|SDT_SYS386TGT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL
argument_list|(
name|GCODE_SEL
argument_list|,
name|SEL_KPL
argument_list|)
argument_list|)
expr_stmt|;
name|rdmsr
argument_list|(
literal|0x1002
argument_list|)
expr_stmt|;
comment|/* Cyrix CPU generates fault. */
if|if
condition|(
name|trap_by_rdmsr
operator|==
literal|0xa8c1d
condition|)
return|return
name|IDENTBLUE_CYRIX486
return|;
elseif|else
if|if
condition|(
name|trap_by_rdmsr
operator|==
literal|0xa89c4
condition|)
return|return
name|IDENTBLUE_CYRIXM2
return|;
return|return
name|IDENTBLUE_IBMCPU
return|;
block|}
end_function

begin_comment
comment|/*  * identifycyrix() set lower 16 bits of cyrix_did as follows:  *  *  F E D C B A 9 8 7 6 5 4 3 2 1 0  * +-------+-------+---------------+  * |  SID  |  RID  |   Device ID   |  * |    (DIR 1)    |    (DIR 0)    |  * +-------+-------+---------------+  */
end_comment

begin_function
specifier|static
name|void
name|identifycyrix
parameter_list|(
name|void
parameter_list|)
block|{
name|register_t
name|saveintr
decl_stmt|;
name|int
name|ccr2_test
init|=
literal|0
decl_stmt|,
name|dir_test
init|=
literal|0
decl_stmt|;
name|u_char
name|ccr2
decl_stmt|,
name|ccr3
decl_stmt|;
name|saveintr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|ccr2
operator|=
name|read_cyrix_reg
argument_list|(
name|CCR2
argument_list|)
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR2
argument_list|,
name|ccr2
operator|^
name|CCR2_LOCK_NW
argument_list|)
expr_stmt|;
name|read_cyrix_reg
argument_list|(
name|CCR2
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cyrix_reg
argument_list|(
name|CCR2
argument_list|)
operator|!=
name|ccr2
condition|)
name|ccr2_test
operator|=
literal|1
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR2
argument_list|,
name|ccr2
argument_list|)
expr_stmt|;
name|ccr3
operator|=
name|read_cyrix_reg
argument_list|(
name|CCR3
argument_list|)
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR3
argument_list|,
name|ccr3
operator|^
name|CCR3_MAPEN3
argument_list|)
expr_stmt|;
name|read_cyrix_reg
argument_list|(
name|CCR3
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_cyrix_reg
argument_list|(
name|CCR3
argument_list|)
operator|!=
name|ccr3
condition|)
name|dir_test
operator|=
literal|1
expr_stmt|;
comment|/* CPU supports DIRs. */
name|write_cyrix_reg
argument_list|(
name|CCR3
argument_list|,
name|ccr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir_test
condition|)
block|{
comment|/* Device ID registers are available. */
name|cyrix_did
operator|=
name|read_cyrix_reg
argument_list|(
name|DIR1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|cyrix_did
operator|+=
name|read_cyrix_reg
argument_list|(
name|DIR0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ccr2_test
condition|)
name|cyrix_did
operator|=
literal|0x0010
expr_stmt|;
comment|/* 486S A-step */
else|else
name|cyrix_did
operator|=
literal|0x00ff
expr_stmt|;
comment|/* Old 486SLC/DLC and TI486SXLC/SXL */
name|intr_restore
argument_list|(
name|saveintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Update TSC freq with the value indicated by the caller. */
end_comment

begin_function
specifier|static
name|void
name|tsc_freq_changed
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
specifier|const
name|struct
name|cf_level
modifier|*
name|level
parameter_list|,
name|int
name|status
parameter_list|)
block|{
comment|/* If there was an error during the transition, don't do anything. */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return;
comment|/* Total setting for this level gives the new frequency in MHz. */
name|hw_clockrate
operator|=
name|level
operator|->
name|total_set
operator|.
name|freq
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hook_tsc_freq
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|tsc_is_invariant
condition|)
return|return;
name|tsc_post_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|cpufreq_post_change
argument_list|,
name|tsc_freq_changed
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|hook_tsc_freq
argument_list|,
name|SI_SUB_CONFIGURE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|hook_tsc_freq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|vm_bnames
index|[]
init|=
block|{
literal|"QEMU"
block|,
comment|/* QEMU */
literal|"Plex86"
block|,
comment|/* Plex86 */
literal|"Bochs"
block|,
comment|/* Bochs */
literal|"Xen"
block|,
comment|/* Xen */
literal|"BHYVE"
block|,
comment|/* bhyve */
literal|"Seabios"
block|,
comment|/* KVM */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|vm_pnames
index|[]
init|=
block|{
literal|"VMware Virtual Platform"
block|,
comment|/* VMWare VM */
literal|"Virtual Machine"
block|,
comment|/* Microsoft VirtualPC */
literal|"VirtualBox"
block|,
comment|/* Sun xVM VirtualBox */
literal|"Parallels Virtual Platform"
block|,
comment|/* Parallels VM */
literal|"KVM"
block|,
comment|/* KVM */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|identify_hypervisor
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * [RFC] CPUID usage for interaction between Hypervisors and Linux. 	 * http://lkml.org/lkml/2008/10/1/246 	 * 	 * KB1009458: Mechanisms to determine if software is running in 	 * a VMware virtual machine 	 * http://kb.vmware.com/kb/1009458 	 */
if|if
condition|(
name|cpu_feature2
operator|&
name|CPUID2_HV
condition|)
block|{
name|vm_guest
operator|=
name|VM_GUEST_VM
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0x40000000
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|0
index|]
operator|>=
literal|0x40000000
condition|)
block|{
name|hv_high
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|hv_vendor
operator|)
index|[
literal|0
index|]
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|hv_vendor
operator|)
index|[
literal|1
index|]
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|hv_vendor
operator|)
index|[
literal|2
index|]
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
name|hv_vendor
index|[
literal|12
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hv_vendor
argument_list|,
literal|"VMwareVMware"
argument_list|)
operator|==
literal|0
condition|)
name|vm_guest
operator|=
name|VM_GUEST_VMWARE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hv_vendor
argument_list|,
literal|"Microsoft Hv"
argument_list|)
operator|==
literal|0
condition|)
name|vm_guest
operator|=
name|VM_GUEST_HV
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hv_vendor
argument_list|,
literal|"KVMKVMKVM"
argument_list|)
operator|==
literal|0
condition|)
name|vm_guest
operator|=
name|VM_GUEST_KVM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|hv_vendor
argument_list|,
literal|"bhyve bhyve"
argument_list|)
operator|==
literal|0
condition|)
name|vm_guest
operator|=
name|VM_GUEST_BHYVE
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Examine SMBIOS strings for older hypervisors. 	 */
name|p
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.system.serial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"VMware-"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"VMW"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vmware_hvcall
argument_list|(
name|VMW_HVCMD_GETVERSION
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|1
index|]
operator|==
name|VMW_HVMAGIC
condition|)
block|{
name|vm_guest
operator|=
name|VM_GUEST_VMWARE
expr_stmt|;
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX: Some of these entries may not be needed since they were 	 * added to FreeBSD before the checks above. 	 */
name|p
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.bios.vendor"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vm_bnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|vm_bnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vm_guest
operator|=
name|VM_GUEST_VM
expr_stmt|;
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|kern_getenv
argument_list|(
literal|"smbios.system.product"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|vm_pnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|vm_pnames
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vm_guest
operator|=
name|VM_GUEST_VM
expr_stmt|;
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
name|freeenv
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|fix_cpuid
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|msr
decl_stmt|;
comment|/* 	 * Clear "Limit CPUID Maxval" bit and return true if the caller should 	 * get the largest standard CPUID function number again if it is set 	 * from BIOS.  It is necessary for probing correct CPU topology later 	 * and for the correct operation of the AVX-aware userspace. 	 */
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
operator|&&
operator|(
operator|(
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0xf
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|>=
literal|0x3
operator|)
operator|||
operator|(
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0x6
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|>=
literal|0xe
operator|)
operator|)
condition|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_IA32_MISC_ENABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
name|IA32_MISC_EN_LIMCPUID
operator|)
operator|!=
literal|0
condition|)
block|{
name|msr
operator|&=
operator|~
name|IA32_MISC_EN_LIMCPUID
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_IA32_MISC_ENABLE
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
comment|/* 	 * Re-enable AMD Topology Extension that could be disabled by BIOS 	 * on some notebook processors.  Without the extension it's really 	 * hard to determine the correct CPU cache topology. 	 * See BIOS and Kernel Developers Guide (BKDG) for AMD Family 15h 	 * Models 60h-6Fh Processors, Publication # 50742. 	 */
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
operator|&&
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0x15
condition|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_EXTFEATURES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|54
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|msr
operator||=
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|54
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_EXTFEATURES
argument_list|,
name|msr
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Final stage of CPU identification.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_decl_stmt
name|void
name|finishidentcpu
argument_list|(
name|void
argument_list|)
else|#
directive|else
name|void
name|identify_cpu
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|,
name|cpu_stdext_disable
decl_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|u_char
name|ccr3
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__amd64__
name|do_cpuid
argument_list|(
literal|0
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_high
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|cpu_vendor
operator|)
index|[
literal|0
index|]
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|cpu_vendor
operator|)
index|[
literal|1
index|]
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
operator|(
operator|(
name|u_int
operator|*
operator|)
operator|&
name|cpu_vendor
operator|)
index|[
literal|2
index|]
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
name|cpu_vendor
index|[
literal|12
index|]
operator|=
literal|'\0'
expr_stmt|;
name|do_cpuid
argument_list|(
literal|1
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_id
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
name|cpu_procinfo
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
name|cpu_feature
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
name|cpu_feature2
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
endif|#
directive|endif
name|cpu_vendor_id
operator|=
name|find_cpu_vendor_id
argument_list|()
expr_stmt|;
if|if
condition|(
name|fix_cpuid
argument_list|()
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_high
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cpu_high
operator|>=
literal|5
operator|&&
operator|(
name|cpu_feature2
operator|&
name|CPUID2_MON
operator|)
operator|!=
literal|0
condition|)
block|{
name|do_cpuid
argument_list|(
literal|5
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_mon_mwait_flags
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
name|cpu_mon_min_size
operator|=
name|regs
index|[
literal|0
index|]
operator|&
name|CPUID5_MON_MIN_SIZE
expr_stmt|;
name|cpu_mon_max_size
operator|=
name|regs
index|[
literal|1
index|]
operator|&
name|CPUID5_MON_MAX_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|cpu_high
operator|>=
literal|7
condition|)
block|{
name|cpuid_count
argument_list|(
literal|7
argument_list|,
literal|0
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_stdext_feature
operator|=
name|regs
index|[
literal|1
index|]
expr_stmt|;
comment|/* 		 * Some hypervisors fail to filter out unsupported 		 * extended features.  For now, disable the 		 * extensions, activation of which requires setting a 		 * bit in CR4, and which VM monitors do not support. 		 */
if|if
condition|(
name|cpu_feature2
operator|&
name|CPUID2_HV
condition|)
block|{
name|cpu_stdext_disable
operator|=
name|CPUID_STDEXT_FSGSBASE
operator||
name|CPUID_STDEXT_SMEP
expr_stmt|;
block|}
else|else
name|cpu_stdext_disable
operator|=
literal|0
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.cpu_stdext_disable"
argument_list|,
operator|&
name|cpu_stdext_disable
argument_list|)
expr_stmt|;
name|cpu_stdext_feature
operator|&=
operator|~
name|cpu_stdext_disable
expr_stmt|;
name|cpu_stdext_feature2
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|cpu_high
operator|>
literal|0
operator|&&
operator|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_TRANSMETA
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CENTAUR
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_NSC
operator|)
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000000
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs
index|[
literal|0
index|]
operator|>=
literal|0x80000000
condition|)
name|cpu_exthigh
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
operator|||
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CENTAUR
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000000
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_exthigh
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000001
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000001
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|amd_feature
operator|=
name|regs
index|[
literal|3
index|]
operator|&
operator|~
operator|(
name|cpu_feature
operator|&
literal|0x0183f3ff
operator|)
expr_stmt|;
name|amd_feature2
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000007
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000007
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|amd_pminfo
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
block|}
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000008
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000008
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_maxphyaddr
operator|=
name|regs
index|[
literal|0
index|]
operator|&
literal|0xff
expr_stmt|;
name|cpu_procinfo2
operator|=
name|regs
index|[
literal|2
index|]
expr_stmt|;
block|}
else|else
block|{
name|cpu_maxphyaddr
operator|=
operator|(
name|cpu_feature
operator|&
name|CPUID_PAE
operator|)
operator|!=
literal|0
condition|?
literal|36
else|:
literal|32
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_CYRIX
condition|)
block|{
if|if
condition|(
name|cpu
operator|==
name|CPU_486
condition|)
block|{
comment|/* 			 * These conditions are equivalent to: 			 *     - CPU does not support cpuid instruction. 			 *     - Cyrix/IBM CPU is detected. 			 */
if|if
condition|(
name|identblue
argument_list|()
operator|==
name|IDENTBLUE_IBMCPU
condition|)
block|{
name|strcpy
argument_list|(
name|cpu_vendor
argument_list|,
literal|"IBM"
argument_list|)
expr_stmt|;
name|cpu_vendor_id
operator|=
name|CPU_VENDOR_IBM
expr_stmt|;
name|cpu
operator|=
name|CPU_BLUE
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|cpu_id
operator|&
literal|0xf00
condition|)
block|{
case|case
literal|0x600
case|:
comment|/* 			 * Cyrix's datasheet does not describe DIRs. 			 * Therefor, I assume it does not have them 			 * and use the result of the cpuid instruction. 			 * XXX they seem to have it for now at least. -Peter 			 */
name|identifycyrix
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|CPU_M2
expr_stmt|;
break|break;
default|default:
name|identifycyrix
argument_list|()
expr_stmt|;
comment|/* 			 * This routine contains a trick. 			 * Don't check (cpu_id& 0x00f0) == 0x50 to detect M2, now. 			 */
switch|switch
condition|(
name|cyrix_did
operator|&
literal|0x00f0
condition|)
block|{
case|case
literal|0x00
case|:
case|case
literal|0xf0
case|:
name|cpu
operator|=
name|CPU_486DLC
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|cpu
operator|=
name|CPU_CY486DX
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
if|if
condition|(
operator|(
name|cyrix_did
operator|&
literal|0x000f
operator|)
operator|<
literal|8
condition|)
name|cpu
operator|=
name|CPU_M1
expr_stmt|;
else|else
name|cpu
operator|=
name|CPU_M1SC
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|cpu
operator|=
name|CPU_M1
expr_stmt|;
break|break;
case|case
literal|0x40
case|:
comment|/* MediaGX CPU */
name|cpu
operator|=
name|CPU_M1SC
expr_stmt|;
break|break;
default|default:
comment|/* M2 and later CPUs are treated as M2. */
name|cpu
operator|=
name|CPU_M2
expr_stmt|;
comment|/* 				 * enable cpuid instruction. 				 */
name|ccr3
operator|=
name|read_cyrix_reg
argument_list|(
name|CCR3
argument_list|)
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR3
argument_list|,
name|CCR3_MAPEN0
argument_list|)
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR4
argument_list|,
name|read_cyrix_reg
argument_list|(
name|CCR4
argument_list|)
operator||
name|CCR4_CPUID
argument_list|)
expr_stmt|;
name|write_cyrix_reg
argument_list|(
name|CCR3
argument_list|,
name|ccr3
argument_list|)
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_high
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
comment|/* eax */
name|do_cpuid
argument_list|(
literal|1
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|cpu_id
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
comment|/* eax */
name|cpu_feature
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
comment|/* edx */
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|cpu
operator|==
name|CPU_486
operator|&&
operator|*
name|cpu_vendor
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * There are BlueLightning CPUs that do not change 		 * undefined flags by dividing 5 by 2.  In this case, 		 * the CPU identification routine in locore.s leaves 		 * cpu_vendor null string and puts CPU_486 into the 		 * cpu. 		 */
if|if
condition|(
name|identblue
argument_list|()
operator|==
name|IDENTBLUE_IBMCPU
condition|)
block|{
name|strcpy
argument_list|(
name|cpu_vendor
argument_list|,
literal|"IBM"
argument_list|)
expr_stmt|;
name|cpu_vendor_id
operator|=
name|CPU_VENDOR_IBM
expr_stmt|;
name|cpu
operator|=
name|CPU_BLUE
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
block|}
end_decl_stmt

begin_function
specifier|static
name|u_int
name|find_cpu_vendor_id
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|cpu_vendors
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
name|cpu_vendors
index|[
name|i
index|]
operator|.
name|vendor
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|cpu_vendors
index|[
name|i
index|]
operator|.
name|vendor_id
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_AMD_assoc
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|255
condition|)
name|printf
argument_list|(
literal|", fully associative\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", %d-way associative\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_AMD_l2_assoc
parameter_list|(
name|int
name|i
parameter_list|)
block|{
switch|switch
condition|(
name|i
operator|&
literal|0x0f
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|", disabled/not present\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf
argument_list|(
literal|", direct mapped\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf
argument_list|(
literal|", 2-way associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|printf
argument_list|(
literal|", 4-way associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|printf
argument_list|(
literal|", 8-way associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|printf
argument_list|(
literal|", 16-way associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|printf
argument_list|(
literal|", fully associative\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", reserved configuration\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_AMD_info
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
name|uint64_t
name|amd_whcr
decl_stmt|;
endif|#
directive|endif
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000005
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000005
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 2MB data TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 2MB instruction TLB: %d entries"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 4KB data TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 4KB instruction TLB: %d entries"
argument_list|,
name|regs
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 data cache: %d kbytes"
argument_list|,
name|regs
index|[
literal|2
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d bytes/line"
argument_list|,
name|regs
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d lines/tag"
argument_list|,
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L1 instruction cache: %d kbytes"
argument_list|,
name|regs
index|[
literal|3
index|]
operator|>>
literal|24
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d bytes/line"
argument_list|,
name|regs
index|[
literal|3
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d lines/tag"
argument_list|,
operator|(
name|regs
index|[
literal|3
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_AMD_assoc
argument_list|(
operator|(
name|regs
index|[
literal|3
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000006
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000006
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"L2 2MB data TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|28
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L2 2MB instruction TLB: %d entries"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"L2 2MB unified TLB: %d entries"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
operator|(
name|regs
index|[
literal|0
index|]
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"L2 4KB data TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|28
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L2 4KB instruction TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"L2 4KB unified TLB: %d entries"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xfff
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|28
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"L2 unified cache: %d kbytes"
argument_list|,
name|regs
index|[
literal|2
index|]
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d bytes/line"
argument_list|,
name|regs
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %d lines/tag"
argument_list|,
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|print_AMD_l2_assoc
argument_list|(
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
operator|(
operator|(
name|cpu_id
operator|&
literal|0xf00
operator|)
operator|==
literal|0x500
operator|)
operator|&&
operator|(
operator|(
operator|(
name|cpu_id
operator|&
literal|0x0f0
operator|)
operator|>
literal|0x80
operator|)
operator|||
operator|(
operator|(
operator|(
name|cpu_id
operator|&
literal|0x0f0
operator|)
operator|==
literal|0x80
operator|)
operator|&&
operator|(
name|cpu_id
operator|&
literal|0x00f
operator|)
operator|>
literal|0x07
operator|)
operator|)
condition|)
block|{
comment|/* K6-2(new core [Stepping 8-F]), K6-III or later */
name|amd_whcr
operator|=
name|rdmsr
argument_list|(
literal|0xc0000082
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|amd_whcr
operator|&
operator|(
literal|0x3ff
operator|<<
literal|22
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Write Allocate Disable\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Write Allocate Enable Limit: %dM bytes\n"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|amd_whcr
operator|&
operator|(
literal|0x3ff
operator|<<
literal|22
operator|)
operator|)
operator|>>
literal|22
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Write Allocate 15-16M bytes: %s\n"
argument_list|,
operator|(
name|amd_whcr
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
operator|)
condition|?
literal|"Enable"
else|:
literal|"Disable"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|cpu_id
operator|&
literal|0xf00
operator|)
operator|==
literal|0x500
operator|)
operator|&&
operator|(
operator|(
name|cpu_id
operator|&
literal|0x0f0
operator|)
operator|>
literal|0x50
operator|)
condition|)
block|{
comment|/* K6, K6-2(old core) */
name|amd_whcr
operator|=
name|rdmsr
argument_list|(
literal|0xc0000082
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|amd_whcr
operator|&
operator|(
literal|0x7f
operator|<<
literal|1
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Write Allocate Disable\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Write Allocate Enable Limit: %dM bytes\n"
argument_list|,
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|amd_whcr
operator|&
operator|(
literal|0x7f
operator|<<
literal|1
operator|)
operator|)
operator|>>
literal|1
argument_list|)
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Write Allocate 15-16M bytes: %s\n"
argument_list|,
operator|(
name|amd_whcr
operator|&
literal|0x0001
operator|)
condition|?
literal|"Enable"
else|:
literal|"Disable"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Hardware Write Allocate Control: %s\n"
argument_list|,
operator|(
name|amd_whcr
operator|&
literal|0x0100
operator|)
condition|?
literal|"Enable"
else|:
literal|"Disable"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Opteron Rev E shows a bug as in very rare occasions a read memory 	 * barrier is not performed as expected if it is followed by a 	 * non-atomic read-modify-write instruction. 	 * As long as that bug pops up very rarely (intensive machine usage 	 * on other operating systems generally generates one unexplainable 	 * crash any 2 months) and as long as a model specific fix would be 	 * impractical at this stage, print out a warning string if the broken 	 * model and family are identified. 	 */
if|if
condition|(
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0xf
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|>=
literal|0x20
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|<=
literal|0x3f
condition|)
name|printf
argument_list|(
literal|"WARNING: This architecture revision has known SMP "
literal|"hardware bugs which may cause random instability\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_INTEL_info
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|u_int
name|rounds
decl_stmt|,
name|regnum
decl_stmt|;
name|u_int
name|nwaycode
decl_stmt|,
name|nway
decl_stmt|;
if|if
condition|(
name|cpu_high
operator|>=
literal|2
condition|)
block|{
name|rounds
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|do_cpuid
argument_list|(
literal|0x2
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rounds
operator|==
literal|0
operator|&&
operator|(
name|rounds
operator|=
operator|(
name|regs
index|[
literal|0
index|]
operator|&
literal|0xff
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* we have a buggy CPU */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<=
literal|3
condition|;
operator|++
name|regnum
control|)
block|{
if|if
condition|(
name|regs
index|[
name|regnum
index|]
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
condition|)
continue|continue;
if|if
condition|(
name|regnum
operator|!=
literal|0
condition|)
name|print_INTEL_TLB
argument_list|(
name|regs
index|[
name|regnum
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_INTEL_TLB
argument_list|(
operator|(
name|regs
index|[
name|regnum
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_INTEL_TLB
argument_list|(
operator|(
name|regs
index|[
name|regnum
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|print_INTEL_TLB
argument_list|(
operator|(
name|regs
index|[
name|regnum
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|rounds
operator|>
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000006
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80000006
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|nwaycode
operator|=
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
expr_stmt|;
if|if
condition|(
name|nwaycode
operator|>=
literal|0x02
operator|&&
name|nwaycode
operator|<=
literal|0x08
condition|)
name|nway
operator|=
literal|1
operator|<<
operator|(
name|nwaycode
operator|/
literal|2
operator|)
expr_stmt|;
else|else
name|nway
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"L2 cache: %u kbytes, %u-way associative, %u bytes/line\n"
argument_list|,
operator|(
name|regs
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|,
name|nway
argument_list|,
name|regs
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_INTEL_TLB
parameter_list|(
name|u_int
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|data
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x40
case|:
default|default:
break|break;
case|case
literal|0x1
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KB pages, 4-way set associative, 32 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 MB pages, fully associative, 2 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KB pages, 4-way set associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 MB Pages, 4-way set associative, 8 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
name|printf
argument_list|(
literal|"1st-level instruction cache: 8 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|printf
argument_list|(
literal|"1st-level instruction cache: 16 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|printf
argument_list|(
literal|"1st-level instruction cache: 32 KB, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 8 KB, 2-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 MByte pages, 4-way set associative, 4 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 16 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 16 KBytes, 4-way set associative, 64 byte line size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 24 KBytes, 6-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x1d
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 128 KBytes, 2-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x21
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 256 KBytes, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x22
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 512 KB, 4-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x23
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 1 MB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x24
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MBytes, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 2 MB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x29
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 4 MB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x2c
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 32 KB, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x30
case|:
name|printf
argument_list|(
literal|"1st-level instruction cache: 32 KB, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x39
case|:
comment|/* De-listed in SDM rev. 54 */
name|printf
argument_list|(
literal|"2nd-level cache: 128 KB, 4-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3b
case|:
comment|/* De-listed in SDM rev. 54 */
name|printf
argument_list|(
literal|"2nd-level cache: 128 KB, 2-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3c
case|:
comment|/* De-listed in SDM rev. 54 */
name|printf
argument_list|(
literal|"2nd-level cache: 256 KB, 4-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x41
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 128 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x42
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 256 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x43
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512 KB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x44
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x45
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 2 MB, 4-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x46
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 4 MB, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x47
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 8 MB, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x48
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 3MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x49
case|:
if|if
condition|(
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0xf
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0x6
condition|)
name|printf
argument_list|(
literal|"3rd-level cache: 4MB, 16-way set associative, 64-byte line size\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"2nd-level cache: 4 MByte, 16-way set associative, 64 byte line size"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4a
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 6MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4b
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 8MByte, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4c
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 12MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4d
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 16MByte, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4e
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 6MByte, 24-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4f
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KByte pages, 32 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x50
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KB, 2 MB or 4 MB pages, fully associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x51
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KB, 2 MB or 4 MB pages, fully associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x52
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KB, 2 MB or 4 MB pages, fully associative, 256 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x55
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 2-MByte or 4-MByte pages, fully associative, 7 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x56
case|:
name|printf
argument_list|(
literal|"Data TLB0: 4 MByte pages, 4-way set associative, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x57
case|:
name|printf
argument_list|(
literal|"Data TLB0: 4 KByte pages, 4-way associative, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x59
case|:
name|printf
argument_list|(
literal|"Data TLB0: 4 KByte pages, fully associative, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5a
case|:
name|printf
argument_list|(
literal|"Data TLB0: 2-MByte or 4 MByte pages, 4-way set associative, 32 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5b
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KB or 4 MB pages, fully associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5c
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KB or 4 MB pages, fully associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x5d
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KB or 4 MB pages, fully associative, 256 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x60
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 16 KB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x61
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KByte pages, fully associative, 48 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x63
case|:
name|printf
argument_list|(
literal|"Data TLB: 2 MByte or 4 MByte pages, 4-way set associative, 32 entries and a separate array with 1 GByte pages, 4-way set associative, 4 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x64
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KBytes pages, 4-way set associative, 512 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x66
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 8 KB, 4-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x67
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 16 KB, 4-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x68
case|:
name|printf
argument_list|(
literal|"1st-level data cache: 32 KB, 4 way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6a
case|:
name|printf
argument_list|(
literal|"uTLB: 4KByte pages, 8-way set associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6b
case|:
name|printf
argument_list|(
literal|"DTLB: 4KByte pages, 8-way set associative, 256 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6c
case|:
name|printf
argument_list|(
literal|"DTLB: 2M/4M pages, 8-way set associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6d
case|:
name|printf
argument_list|(
literal|"DTLB: 1 GByte pages, fully associative, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x70
case|:
name|printf
argument_list|(
literal|"Trace cache: 12K-uops, 8-way set associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x71
case|:
name|printf
argument_list|(
literal|"Trace cache: 16K-uops, 8-way set associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x72
case|:
name|printf
argument_list|(
literal|"Trace cache: 32K-uops, 8-way set associative\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x76
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 2M/4M pages, fully associative, 8 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x78
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MB, 4-way set associative, 64-byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x79
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 128 KB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7a
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 256 KB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7b
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512 KB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7c
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MB, 8-way set associative, sectored cache, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7d
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 2-MB, 8-way set associative, 64-byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7f
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512-KB, 2-way set associative, 64-byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512 KByte, 8-way set associative, 64-byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 256 KB, 8-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512 KB, 8-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x84
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MB, 8-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x85
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 2 MB, 8-way set associative, 32 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x86
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 512 KB, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x87
case|:
name|printf
argument_list|(
literal|"2nd-level cache: 1 MB, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa0
case|:
name|printf
argument_list|(
literal|"DTLB: 4k pages, fully associative, 32 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb0
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4 KB Pages, 4-way set associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb1
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 2M pages, 4-way, 8 entries or 4M pages, 4-way, 4 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb2
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4KByte pages, 4-way set associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb3
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KB Pages, 4-way set associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb4
case|:
name|printf
argument_list|(
literal|"Data TLB1: 4 KByte pages, 4-way associative, 256 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb5
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4KByte pages, 8-way set associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb6
case|:
name|printf
argument_list|(
literal|"Instruction TLB: 4KByte pages, 8-way set associative, 128 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xba
case|:
name|printf
argument_list|(
literal|"Data TLB1: 4 KByte pages, 4-way associative, 64 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc0
case|:
name|printf
argument_list|(
literal|"Data TLB: 4 KByte and 4 MByte pages, 4-way associative, 8 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc1
case|:
name|printf
argument_list|(
literal|"Shared 2nd-Level TLB: 4 KByte/2MByte pages, 8-way associative, 1024 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc2
case|:
name|printf
argument_list|(
literal|"DTLB: 4 KByte/2 MByte pages, 4-way associative, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc3
case|:
name|printf
argument_list|(
literal|"Shared 2nd-Level TLB: 4 KByte /2 MByte pages, 6-way associative, 1536 entries. Also 1GBbyte pages, 4-way, 16 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc4
case|:
name|printf
argument_list|(
literal|"DTLB: 2M/4M Byte pages, 4-way associative, 32 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xca
case|:
name|printf
argument_list|(
literal|"Shared 2nd-Level TLB: 4 KByte pages, 4-way associative, 512 entries\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd0
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 512 KByte, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd1
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 1 MByte, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd2
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 2 MByte, 4-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd6
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 1 MByte, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd7
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 2 MByte, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd8
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 4 MByte, 8-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xdc
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 1.5 MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xdd
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 3 MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xde
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 6 MByte, 12-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xe2
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 2 MByte, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xe3
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 4 MByte, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xe4
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 8 MByte, 16-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xea
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 12MByte, 24-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xeb
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 18MByte, 24-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xec
case|:
name|printf
argument_list|(
literal|"3rd-level cache: 24MByte, 24-way set associative, 64 byte line size\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf0
case|:
name|printf
argument_list|(
literal|"64-Byte prefetching\n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf1
case|:
name|printf
argument_list|(
literal|"128-Byte prefetching\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_svm_info
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|features
decl_stmt|,
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|printf
argument_list|(
literal|"\n  SVM: "
argument_list|)
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0x8000000A
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|features
operator|=
name|regs
index|[
literal|3
index|]
expr_stmt|;
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_VM_CR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
name|VM_CR_SVMDIS
operator|)
operator|==
name|VM_CR_SVMDIS
condition|)
name|printf
argument_list|(
literal|"(disabled in BIOS) "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bootverbose
condition|)
block|{
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|features
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%sNP"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%sNRIP"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
operator|(
literal|1
operator|<<
literal|5
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%sVClean"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
operator|(
literal|1
operator|<<
literal|6
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%sAFlush"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|features
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%sDAssist"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%sNAsids=%d"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|,
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Features=0x%b"
argument_list|,
name|features
argument_list|,
literal|"\020"
literal|"\001NP"
comment|/* Nested paging */
literal|"\002LbrVirt"
comment|/* LBR virtualization */
literal|"\003SVML"
comment|/* SVM lock */
literal|"\004NRIPS"
comment|/* NRIP save */
literal|"\005TscRateMsr"
comment|/* MSR based TSC rate control */
literal|"\006VmcbClean"
comment|/* VMCB clean bits */
literal|"\007FlushByAsid"
comment|/* Flush by ASID */
literal|"\010DecodeAssist"
comment|/* Decode assist */
literal|"\011<b8>"
literal|"\012<b9>"
literal|"\013PauseFilter"
comment|/* PAUSE intercept filter */
literal|"\014<b11>"
literal|"\015PauseFilterThreshold"
comment|/* PAUSE filter threshold */
literal|"\016AVIC"
comment|/* virtual interrupt controller */
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nRevision=%d, ASIDs=%d"
argument_list|,
name|regs
index|[
literal|0
index|]
operator|&
literal|0xff
argument_list|,
name|regs
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
specifier|static
name|void
name|print_transmeta_info
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|,
name|nreg
init|=
literal|0
decl_stmt|;
name|do_cpuid
argument_list|(
literal|0x80860000
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|nreg
operator|=
name|regs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|nreg
operator|>=
literal|0x80860001
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80860001
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Processor revision %u.%u.%u.%u\n"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|regs
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nreg
operator|>=
literal|0x80860002
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x80860002
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  Code Morphing Software revision %u.%u.%u-%u-%u\n"
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|regs
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|regs
index|[
literal|1
index|]
operator|&
literal|0xff
argument_list|,
name|regs
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nreg
operator|>=
literal|0x80860006
condition|)
block|{
name|char
name|info
index|[
literal|65
index|]
decl_stmt|;
name|do_cpuid
argument_list|(
literal|0x80860003
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0x80860004
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|info
index|[
literal|16
index|]
argument_list|)
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0x80860005
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|info
index|[
literal|32
index|]
argument_list|)
expr_stmt|;
name|do_cpuid
argument_list|(
literal|0x80860006
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|info
index|[
literal|48
index|]
argument_list|)
expr_stmt|;
name|info
index|[
literal|64
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|print_via_padlock_info
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|do_cpuid
argument_list|(
literal|0xc0000001
argument_list|,
name|regs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  VIA Padlock Features=0x%b"
argument_list|,
name|regs
index|[
literal|3
index|]
argument_list|,
literal|"\020"
literal|"\003RNG"
comment|/* RNG */
literal|"\007AES"
comment|/* ACE */
literal|"\011AES-CTR"
comment|/* ACE2 */
literal|"\013SHA1,SHA256"
comment|/* PHE */
literal|"\015RSA"
comment|/* PMM */
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|vmx_settable
parameter_list|(
name|uint64_t
name|basic
parameter_list|,
name|int
name|msr
parameter_list|,
name|int
name|true_msr
parameter_list|)
block|{
name|uint64_t
name|val
decl_stmt|;
if|if
condition|(
name|basic
operator|&
operator|(
literal|1ULL
operator|<<
literal|55
operator|)
condition|)
name|val
operator|=
name|rdmsr
argument_list|(
name|true_msr
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|rdmsr
argument_list|(
name|msr
argument_list|)
expr_stmt|;
comment|/* Just report the controls that can be set to 1. */
return|return
operator|(
name|val
operator|>>
literal|32
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_vmx_info
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|basic
decl_stmt|,
name|msr
decl_stmt|;
name|uint32_t
name|entry
decl_stmt|,
name|exit
decl_stmt|,
name|mask
decl_stmt|,
name|pin
decl_stmt|,
name|proc
decl_stmt|,
name|proc2
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|printf
argument_list|(
literal|"\n  VT-x: "
argument_list|)
expr_stmt|;
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_IA32_FEATURE_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|msr
operator|&
name|IA32_FEATURE_CONTROL_VMX_EN
operator|)
condition|)
name|printf
argument_list|(
literal|"(disabled in BIOS) "
argument_list|)
expr_stmt|;
name|basic
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_BASIC
argument_list|)
expr_stmt|;
name|pin
operator|=
name|vmx_settable
argument_list|(
name|basic
argument_list|,
name|MSR_VMX_PINBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PINBASED_CTLS
argument_list|)
expr_stmt|;
name|proc
operator|=
name|vmx_settable
argument_list|(
name|basic
argument_list|,
name|MSR_VMX_PROCBASED_CTLS
argument_list|,
name|MSR_VMX_TRUE_PROCBASED_CTLS
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|&
name|PROCBASED_SECONDARY_CONTROLS
condition|)
name|proc2
operator|=
name|vmx_settable
argument_list|(
name|basic
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|,
name|MSR_VMX_PROCBASED_CTLS2
argument_list|)
expr_stmt|;
else|else
name|proc2
operator|=
literal|0
expr_stmt|;
name|exit
operator|=
name|vmx_settable
argument_list|(
name|basic
argument_list|,
name|MSR_VMX_EXIT_CTLS
argument_list|,
name|MSR_VMX_TRUE_EXIT_CTLS
argument_list|)
expr_stmt|;
name|entry
operator|=
name|vmx_settable
argument_list|(
name|basic
argument_list|,
name|MSR_VMX_ENTRY_CTLS
argument_list|,
name|MSR_VMX_TRUE_ENTRY_CTLS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bootverbose
condition|)
block|{
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exit
operator|&
name|VM_EXIT_SAVE_PAT
operator|&&
name|exit
operator|&
name|VM_EXIT_LOAD_PAT
operator|&&
name|entry
operator|&
name|VM_ENTRY_LOAD_PAT
condition|)
block|{
name|printf
argument_list|(
literal|"%sPAT"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|&
name|PROCBASED_HLT_EXITING
condition|)
block|{
name|printf
argument_list|(
literal|"%sHLT"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|&
name|PROCBASED_MTF
condition|)
block|{
name|printf
argument_list|(
literal|"%sMTF"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|&
name|PROCBASED_PAUSE_EXITING
condition|)
block|{
name|printf
argument_list|(
literal|"%sPAUSE"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc2
operator|&
name|PROCBASED2_ENABLE_EPT
condition|)
block|{
name|printf
argument_list|(
literal|"%sEPT"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc2
operator|&
name|PROCBASED2_UNRESTRICTED_GUEST
condition|)
block|{
name|printf
argument_list|(
literal|"%sUG"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc2
operator|&
name|PROCBASED2_ENABLE_VPID
condition|)
block|{
name|printf
argument_list|(
literal|"%sVPID"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|proc
operator|&
name|PROCBASED_USE_TPR_SHADOW
operator|&&
name|proc2
operator|&
name|PROCBASED2_VIRTUALIZE_APIC_ACCESSES
operator|&&
name|proc2
operator|&
name|PROCBASED2_VIRTUALIZE_X2APIC_MODE
operator|&&
name|proc2
operator|&
name|PROCBASED2_APIC_REGISTER_VIRTUALIZATION
operator|&&
name|proc2
operator|&
name|PROCBASED2_VIRTUAL_INTERRUPT_DELIVERY
condition|)
block|{
name|printf
argument_list|(
literal|"%sVID"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pin
operator|&
name|PINBASED_POSTED_INTERRUPT
condition|)
name|printf
argument_list|(
literal|",PostIntr"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|mask
operator|=
name|basic
operator|>>
literal|32
expr_stmt|;
name|printf
argument_list|(
literal|"Basic Features=0x%b"
argument_list|,
name|mask
argument_list|,
literal|"\020"
literal|"\02132PA"
comment|/* 32-bit physical addresses */
literal|"\022SMM"
comment|/* SMM dual-monitor */
literal|"\027INS/OUTS"
comment|/* VM-exit info for INS and OUTS */
literal|"\030TRUE"
comment|/* TRUE_CTLS MSRs */
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n        Pin-Based Controls=0x%b"
argument_list|,
name|pin
argument_list|,
literal|"\020"
literal|"\001ExtINT"
comment|/* External-interrupt exiting */
literal|"\004NMI"
comment|/* NMI exiting */
literal|"\006VNMI"
comment|/* Virtual NMIs */
literal|"\007PreTmr"
comment|/* Activate VMX-preemption timer */
literal|"\010PostIntr"
comment|/* Process posted interrupts */
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n        Primary Processor Controls=0x%b"
argument_list|,
name|proc
argument_list|,
literal|"\020"
literal|"\003INTWIN"
comment|/* Interrupt-window exiting */
literal|"\004TSCOff"
comment|/* Use TSC offsetting */
literal|"\010HLT"
comment|/* HLT exiting */
literal|"\012INVLPG"
comment|/* INVLPG exiting */
literal|"\013MWAIT"
comment|/* MWAIT exiting */
literal|"\014RDPMC"
comment|/* RDPMC exiting */
literal|"\015RDTSC"
comment|/* RDTSC exiting */
literal|"\020CR3-LD"
comment|/* CR3-load exiting */
literal|"\021CR3-ST"
comment|/* CR3-store exiting */
literal|"\024CR8-LD"
comment|/* CR8-load exiting */
literal|"\025CR8-ST"
comment|/* CR8-store exiting */
literal|"\026TPR"
comment|/* Use TPR shadow */
literal|"\027NMIWIN"
comment|/* NMI-window exiting */
literal|"\030MOV-DR"
comment|/* MOV-DR exiting */
literal|"\031IO"
comment|/* Unconditional I/O exiting */
literal|"\032IOmap"
comment|/* Use I/O bitmaps */
literal|"\034MTF"
comment|/* Monitor trap flag */
literal|"\035MSRmap"
comment|/* Use MSR bitmaps */
literal|"\036MONITOR"
comment|/* MONITOR exiting */
literal|"\037PAUSE"
comment|/* PAUSE exiting */
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|&
name|PROCBASED_SECONDARY_CONTROLS
condition|)
name|printf
argument_list|(
literal|"\n        Secondary Processor Controls=0x%b"
argument_list|,
name|proc2
argument_list|,
literal|"\020"
literal|"\001APIC"
comment|/* Virtualize APIC accesses */
literal|"\002EPT"
comment|/* Enable EPT */
literal|"\003DT"
comment|/* Descriptor-table exiting */
literal|"\004RDTSCP"
comment|/* Enable RDTSCP */
literal|"\005x2APIC"
comment|/* Virtualize x2APIC mode */
literal|"\006VPID"
comment|/* Enable VPID */
literal|"\007WBINVD"
comment|/* WBINVD exiting */
literal|"\010UG"
comment|/* Unrestricted guest */
literal|"\011APIC-reg"
comment|/* APIC-register virtualization */
literal|"\012VID"
comment|/* Virtual-interrupt delivery */
literal|"\013PAUSE-loop"
comment|/* PAUSE-loop exiting */
literal|"\014RDRAND"
comment|/* RDRAND exiting */
literal|"\015INVPCID"
comment|/* Enable INVPCID */
literal|"\016VMFUNC"
comment|/* Enable VM functions */
literal|"\017VMCS"
comment|/* VMCS shadowing */
literal|"\020EPT#VE"
comment|/* EPT-violation #VE */
literal|"\021XSAVES"
comment|/* Enable XSAVES/XRSTORS */
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n        Exit Controls=0x%b"
argument_list|,
name|mask
argument_list|,
literal|"\020"
literal|"\003DR"
comment|/* Save debug controls */
comment|/* Ignore Host address-space size */
literal|"\015PERF"
comment|/* Load MSR_PERF_GLOBAL_CTRL */
literal|"\020AckInt"
comment|/* Acknowledge interrupt on exit */
literal|"\023PAT-SV"
comment|/* Save MSR_PAT */
literal|"\024PAT-LD"
comment|/* Load MSR_PAT */
literal|"\025EFER-SV"
comment|/* Save MSR_EFER */
literal|"\026EFER-LD"
comment|/* Load MSR_EFER */
literal|"\027PTMR-SV"
comment|/* Save VMX-preemption timer value */
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n        Entry Controls=0x%b"
argument_list|,
name|mask
argument_list|,
literal|"\020"
literal|"\003DR"
comment|/* Save debug controls */
comment|/* Ignore IA-32e mode guest */
comment|/* Ignore Entry to SMM */
comment|/* Ignore Deactivate dual-monitor treatment */
literal|"\016PERF"
comment|/* Load MSR_PERF_GLOBAL_CTRL */
literal|"\017PAT"
comment|/* Load MSR_PAT */
literal|"\020EFER"
comment|/* Load MSR_EFER */
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|&
name|PROCBASED_SECONDARY_CONTROLS
operator|&&
operator|(
name|proc2
operator|&
operator|(
name|PROCBASED2_ENABLE_EPT
operator||
name|PROCBASED2_ENABLE_VPID
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_VMX_EPT_VPID_CAP
argument_list|)
expr_stmt|;
name|mask
operator|=
name|msr
expr_stmt|;
name|printf
argument_list|(
literal|"\n        EPT Features=0x%b"
argument_list|,
name|mask
argument_list|,
literal|"\020"
literal|"\001XO"
comment|/* Execute-only translations */
literal|"\007PW4"
comment|/* Page-walk length of 4 */
literal|"\011UC"
comment|/* EPT paging-structure mem can be UC */
literal|"\017WB"
comment|/* EPT paging-structure mem can be WB */
literal|"\0212M"
comment|/* EPT PDE can map a 2-Mbyte page */
literal|"\0221G"
comment|/* EPT PDPTE can map a 1-Gbyte page */
literal|"\025INVEPT"
comment|/* INVEPT is supported */
literal|"\026AD"
comment|/* Accessed and dirty flags for EPT */
literal|"\032single"
comment|/* INVEPT single-context type */
literal|"\033all"
comment|/* INVEPT all-context type */
argument_list|)
expr_stmt|;
name|mask
operator|=
name|msr
operator|>>
literal|32
expr_stmt|;
name|printf
argument_list|(
literal|"\n        VPID Features=0x%b"
argument_list|,
name|mask
argument_list|,
literal|"\020"
literal|"\001INVVPID"
comment|/* INVVPID is supported */
literal|"\011individual"
comment|/* INVVPID individual-address type */
literal|"\012single"
comment|/* INVVPID single-context type */
literal|"\013all"
comment|/* INVVPID all-context type */
comment|/* INVVPID single-context-retaining-globals type */
literal|"\014single-globals"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_hypervisor_info
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|*
name|hv_vendor
condition|)
name|printf
argument_list|(
literal|"Hypervisor: Origin = \"%s\"\n"
argument_list|,
name|hv_vendor
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

