begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996, by Steve Passe  * Copyright (c) 2003, by Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|"opt_apic.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|"opt_smp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_comment
comment|/* cngetc() */
end_comment

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GPROF
end_ifdef

begin_include
include|#
directive|include
file|<sys/gmon.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memrange.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<x86/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/psl.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_define
define|#
directive|define
name|WARMBOOT_TARGET
value|0
end_define

begin_define
define|#
directive|define
name|WARMBOOT_OFF
value|(KERNBASE + 0x0467)
end_define

begin_define
define|#
directive|define
name|WARMBOOT_SEG
value|(KERNBASE + 0x0469)
end_define

begin_define
define|#
directive|define
name|CMOS_REG
value|(0x70)
end_define

begin_define
define|#
directive|define
name|CMOS_DATA
value|(0x71)
end_define

begin_define
define|#
directive|define
name|BIOS_RESET
value|(0x0f)
end_define

begin_define
define|#
directive|define
name|BIOS_WARM
value|(0x0a)
end_define

begin_comment
comment|/* lock region used by kernel profiling */
end_comment

begin_decl_stmt
name|int
name|mcount_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|mp_naps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of Applications processors */
end_comment

begin_decl_stmt
name|int
name|boot_cpu_id
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* designated BSP */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|pcpu
name|__pcpu
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AP uses this during bootstrap.  Do not staticize.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|bootSTK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bootAP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free these after use */
end_comment

begin_decl_stmt
name|void
modifier|*
name|bootstacks
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|dpcpu
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pcb
name|stoppcbs
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|susppcb
modifier|*
modifier|*
name|susppcbs
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COUNT_IPIS
end_ifdef

begin_comment
comment|/* Interrupt counts. */
end_comment

begin_decl_stmt
specifier|static
name|u_long
modifier|*
name|ipi_preempt_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
modifier|*
name|ipi_ast_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|ipi_invltlb_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|ipi_invlrng_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|ipi_invlpg_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|ipi_invlcache_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
modifier|*
name|ipi_rendezvous_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
modifier|*
name|ipi_hardclock_counts
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default cpu_ops implementation. */
end_comment

begin_decl_stmt
name|struct
name|cpu_ops
name|cpu_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local data and functions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|cpuset_t
name|ipi_stop_nmi_pending
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used to hold the AP's until we are ready to release them */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|ap_boot_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 once we're ready to let the APs out of the pen. */
end_comment

begin_decl_stmt
specifier|volatile
name|int
name|aps_ready
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Store data from cpu_add() until later in the boot when we actually setup  * the APs.  */
end_comment

begin_decl_stmt
name|struct
name|cpu_info
name|cpu_info
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|apic_cpuids
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpu_apic_ids
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Holds pending bitmap based IPIs per CPU */
end_comment

begin_decl_stmt
specifier|volatile
name|u_int
name|cpu_ipi_pending
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cpustop_handler_post
parameter_list|(
name|u_int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|hyperthreading_allowed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|hyperthreading_allowed
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|hyperthreading_allowed
argument_list|,
literal|0
argument_list|,
literal|"Use Intel HTT logical CPUs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|topo_node
name|topo_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pkg_id_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|core_id_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|disabled_cpus
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cache_info
block|{
name|int
name|id_shift
decl_stmt|;
name|int
name|present
decl_stmt|;
block|}
decl|static
name|caches
index|[
name|MAX_CACHE_LEVELS
index|]
struct|;
end_struct

begin_function
name|void
name|mem_range_AP_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|mem_range_softc
operator|.
name|mr_op
operator|&&
name|mem_range_softc
operator|.
name|mr_op
operator|->
name|initAP
condition|)
name|mem_range_softc
operator|.
name|mr_op
operator|->
name|initAP
argument_list|(
operator|&
name|mem_range_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Round up to the next power of two, if necessary, and then  * take log2.  * Returns -1 if argument is zero.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|mask_width
parameter_list|(
name|u_int
name|x
parameter_list|)
block|{
return|return
operator|(
name|fls
argument_list|(
name|x
operator|<<
operator|(
literal|1
operator|-
name|powerof2
argument_list|(
name|x
argument_list|)
operator|)
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a cache level to the cache topology description.  */
end_comment

begin_function
specifier|static
name|int
name|add_deterministic_cache
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|share_count
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|>
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected cache type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
literal|2
condition|)
comment|/* ignore instruction cache */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|level
operator|==
literal|0
operator|||
name|level
operator|>
name|MAX_CACHE_LEVELS
condition|)
block|{
name|printf
argument_list|(
literal|"unexpected cache level %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|present
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: multiple entries for L%u data cache\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u => %u\n"
argument_list|,
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
argument_list|,
name|mask_width
argument_list|(
name|share_count
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
operator|=
name|mask_width
argument_list|(
name|share_count
argument_list|)
expr_stmt|;
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
operator|>
name|pkg_id_shift
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: L%u data cache covers more "
literal|"APIC IDs than a package\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u> %u\n"
argument_list|,
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
argument_list|,
name|pkg_id_shift
argument_list|)
expr_stmt|;
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
operator|=
name|pkg_id_shift
expr_stmt|;
block|}
if|if
condition|(
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
operator|<
name|core_id_shift
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: L%u data cache covers less "
literal|"APIC IDs than a core\n"
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%u< %u\n"
argument_list|,
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
argument_list|,
name|core_id_shift
argument_list|)
expr_stmt|;
name|caches
index|[
name|level
operator|-
literal|1
index|]
operator|.
name|id_shift
operator|=
name|core_id_shift
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine topology of processing units and caches for AMD CPUs.  * See:  *  - AMD CPUID Specification (Publication # 25481)  *  - BKDG for AMD NPT Family 0Fh Processors (Publication # 32559)  *  - BKDG For AMD Family 10h Processors (Publication # 31116)  *  - BKDG For AMD Family 15h Models 00h-0Fh Processors (Publication # 42301)  *  - BKDG For AMD Family 16h Models 00h-0Fh Processors (Publication # 48751)  */
end_comment

begin_function
specifier|static
name|void
name|topo_probe_amd
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|p
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|v
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|nodes_per_socket
decl_stmt|;
name|int
name|share_count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* No multi-core capability. */
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_CMP
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* For families 10h and newer. */
name|pkg_id_shift
operator|=
operator|(
name|cpu_procinfo2
operator|&
name|AMDID_COREID_SIZE
operator|)
operator|>>
name|AMDID_COREID_SIZE_SHIFT
expr_stmt|;
comment|/* For 0Fh family. */
if|if
condition|(
name|pkg_id_shift
operator|==
literal|0
condition|)
name|pkg_id_shift
operator|=
name|mask_width
argument_list|(
operator|(
name|cpu_procinfo2
operator|&
name|AMDID_CMP_CORES
operator|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Families prior to 16h define the following value as 	 * cores per compute unit and we don't really care about the AMD 	 * compute units at the moment.  Perhaps we should treat them as 	 * cores and cores within the compute units as hardware threads, 	 * but that's up for debate. 	 * Later families define the value as threads per compute unit, 	 * so we are following AMD's nomenclature here. 	 */
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_TOPOLOGY
operator|)
operator|!=
literal|0
operator|&&
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|>=
literal|0x16
condition|)
block|{
name|cpuid_count
argument_list|(
literal|0x8000001e
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|share_count
operator|=
operator|(
operator|(
name|p
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
literal|1
expr_stmt|;
name|core_id_shift
operator|=
name|mask_width
argument_list|(
name|share_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_TOPOLOGY
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|cpuid_count
argument_list|(
literal|0x8000001d
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
expr_stmt|;
name|level
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
name|share_count
operator|=
literal|1
operator|+
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|14
operator|)
operator|&
literal|0xfff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|add_deterministic_cache
argument_list|(
name|type
argument_list|,
name|level
argument_list|,
name|share_count
argument_list|)
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000005
condition|)
block|{
name|cpuid_count
argument_list|(
literal|0x80000005
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0
condition|)
block|{
name|caches
index|[
literal|0
index|]
operator|.
name|id_shift
operator|=
literal|0
expr_stmt|;
name|caches
index|[
literal|0
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cpu_exthigh
operator|>=
literal|0x80000006
condition|)
block|{
name|cpuid_count
argument_list|(
literal|0x80000006
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
operator|)
operator|!=
literal|0
condition|)
block|{
name|caches
index|[
literal|1
index|]
operator|.
name|id_shift
operator|=
literal|0
expr_stmt|;
name|caches
index|[
literal|1
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|p
index|[
literal|3
index|]
operator|>>
literal|18
operator|)
operator|&
literal|0x3fff
operator|)
operator|!=
literal|0
condition|)
block|{
name|nodes_per_socket
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|amd_feature2
operator|&
name|AMDID2_NODE_ID
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * Handle multi-node processors that 					 * have multiple chips, each with its 					 * own L3 cache, on the same die. 					 */
name|v
operator|=
name|rdmsr
argument_list|(
literal|0xc001100c
argument_list|)
expr_stmt|;
name|nodes_per_socket
operator|=
literal|1
operator|+
operator|(
operator|(
name|v
operator|>>
literal|3
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
block|}
name|caches
index|[
literal|2
index|]
operator|.
name|id_shift
operator|=
name|pkg_id_shift
operator|-
name|mask_width
argument_list|(
name|nodes_per_socket
argument_list|)
expr_stmt|;
name|caches
index|[
literal|2
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine topology of processing units for Intel CPUs  * using CPUID Leaf 1 and Leaf 4, if supported.  * See:  *  - Intel 64 Architecture Processor Topology Enumeration  *  - Intel 64 and IA-32 ArchitecturesSoftware Developerâs Manual,  *    Volume 3A: System Programming Guide, PROGRAMMING CONSIDERATIONS  *    FOR HARDWARE MULTI-THREADING CAPABLE PROCESSORS  */
end_comment

begin_function
specifier|static
name|void
name|topo_probe_intel_0x4
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|p
index|[
literal|4
index|]
decl_stmt|;
name|int
name|max_cores
decl_stmt|;
name|int
name|max_logical
decl_stmt|;
comment|/* Both zero and one here mean one logical processor per package. */
name|max_logical
operator|=
operator|(
name|cpu_feature
operator|&
name|CPUID_HTT
operator|)
operator|!=
literal|0
condition|?
operator|(
name|cpu_procinfo
operator|&
name|CPUID_HTT_CORES
operator|)
operator|>>
literal|16
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|max_logical
operator|<=
literal|1
condition|)
return|return;
if|if
condition|(
name|cpu_high
operator|>=
literal|0x4
condition|)
block|{
name|cpuid_count
argument_list|(
literal|0x04
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|max_cores
operator|=
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|max_cores
operator|=
literal|1
expr_stmt|;
name|core_id_shift
operator|=
name|mask_width
argument_list|(
name|max_logical
operator|/
name|max_cores
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|core_id_shift
operator|>=
literal|0
argument_list|,
operator|(
literal|"intel topo: max_cores> max_logical\n"
operator|)
argument_list|)
expr_stmt|;
name|pkg_id_shift
operator|=
name|core_id_shift
operator|+
name|mask_width
argument_list|(
name|max_cores
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine topology of processing units for Intel CPUs  * using CPUID Leaf 11, if supported.  * See:  *  - Intel 64 Architecture Processor Topology Enumeration  *  - Intel 64 and IA-32 ArchitecturesSoftware Developerâs Manual,  *    Volume 3A: System Programming Guide, PROGRAMMING CONSIDERATIONS  *    FOR HARDWARE MULTI-THREADING CAPABLE PROCESSORS  */
end_comment

begin_function
specifier|static
name|void
name|topo_probe_intel_0xb
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|p
index|[
literal|4
index|]
decl_stmt|;
name|int
name|bits
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fall back if CPU leaf 11 doesn't really exist. */
name|cpuid_count
argument_list|(
literal|0x0b
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|topo_probe_intel_0x4
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* We only support three levels for now. */
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|cpuid_count
argument_list|(
literal|0x0b
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|bits
operator|=
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
expr_stmt|;
name|type
operator|=
operator|(
name|p
index|[
literal|2
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
break|break;
comment|/* TODO: check for duplicate (re-)assignment */
if|if
condition|(
name|type
operator|==
name|CPUID_TYPE_SMT
condition|)
name|core_id_shift
operator|=
name|bits
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|CPUID_TYPE_CORE
condition|)
name|pkg_id_shift
operator|=
name|bits
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown CPU level type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pkg_id_shift
operator|<
name|core_id_shift
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: core covers more APIC IDs than a package\n"
argument_list|)
expr_stmt|;
name|core_id_shift
operator|=
name|pkg_id_shift
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine topology of caches for Intel CPUs.  * See:  *  - Intel 64 Architecture Processor Topology Enumeration  *  - Intel 64 and IA-32 Architectures Software Developerâs Manual  *    Volume 2A: Instruction Set Reference, A-M,  *    CPUID instruction  */
end_comment

begin_function
specifier|static
name|void
name|topo_probe_intel_caches
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|p
index|[
literal|4
index|]
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|share_count
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpu_high
operator|<
literal|0x4
condition|)
block|{
comment|/* 		 * Available cache level and sizes can be determined 		 * via CPUID leaf 2, but that requires a huge table of hardcoded 		 * values, so for now just assume L1 and L2 caches potentially 		 * shared only by HTT processing units, if HTT is present. 		 */
name|caches
index|[
literal|0
index|]
operator|.
name|id_shift
operator|=
name|pkg_id_shift
expr_stmt|;
name|caches
index|[
literal|0
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
name|caches
index|[
literal|1
index|]
operator|.
name|id_shift
operator|=
name|pkg_id_shift
expr_stmt|;
name|caches
index|[
literal|1
index|]
operator|.
name|present
operator|=
literal|1
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|cpuid_count
argument_list|(
literal|0x4
argument_list|,
name|i
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
index|[
literal|0
index|]
operator|&
literal|0x1f
expr_stmt|;
name|level
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|5
operator|)
operator|&
literal|0x7
expr_stmt|;
name|share_count
operator|=
literal|1
operator|+
operator|(
operator|(
name|p
index|[
literal|0
index|]
operator|>>
literal|14
operator|)
operator|&
literal|0xfff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|add_deterministic_cache
argument_list|(
name|type
argument_list|,
name|level
argument_list|,
name|share_count
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine topology of processing units and caches for Intel CPUs.  * See:  *  - Intel 64 Architecture Processor Topology Enumeration  */
end_comment

begin_function
specifier|static
name|void
name|topo_probe_intel
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Note that 0x1<= cpu_high< 4 case should be 	 * compatible with topo_probe_intel_0x4() logic when 	 * CPUID.1:EBX[23:16]> 0 (cpu_cores will be 1) 	 * or it should trigger the fallback otherwise. 	 */
if|if
condition|(
name|cpu_high
operator|>=
literal|0xb
condition|)
name|topo_probe_intel_0xb
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_high
operator|>=
literal|0x1
condition|)
name|topo_probe_intel_0x4
argument_list|()
expr_stmt|;
name|topo_probe_intel_caches
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Topology information is queried only on BSP, on which this  * code runs and for which it can query CPUID information.  * Then topology is extrapolated on all packages using an  * assumption that APIC ID to hardware component ID mapping is  * homogenious.  * That doesn't necesserily imply that the topology is uniform.  */
end_comment

begin_function
name|void
name|topo_probe
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|cpu_topo_probed
init|=
literal|0
decl_stmt|;
struct|struct
name|x86_topo_layer
block|{
name|int
name|type
decl_stmt|;
name|int
name|subtype
decl_stmt|;
name|int
name|id_shift
decl_stmt|;
block|}
name|topo_layers
index|[
name|MAX_CACHE_LEVELS
operator|+
literal|3
index|]
struct|;
name|struct
name|topo_node
modifier|*
name|parent
decl_stmt|;
name|struct
name|topo_node
modifier|*
name|node
decl_stmt|;
name|int
name|layer
decl_stmt|;
name|int
name|nlayers
decl_stmt|;
name|int
name|node_id
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cpu_topo_probed
condition|)
return|return;
name|CPU_ZERO
argument_list|(
operator|&
name|logical_cpus_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|<=
literal|1
condition|)
empty_stmt|;
comment|/* nothing */
elseif|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
condition|)
name|topo_probe_amd
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
condition|)
name|topo_probe_intel
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|pkg_id_shift
operator|>=
name|core_id_shift
argument_list|,
operator|(
literal|"bug in APIC topology discovery"
operator|)
argument_list|)
expr_stmt|;
name|nlayers
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|topo_layers
argument_list|,
sizeof|sizeof
argument_list|(
name|topo_layers
argument_list|)
argument_list|)
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|type
operator|=
name|TOPO_TYPE_PKG
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
operator|=
name|pkg_id_shift
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Package ID shift: %u\n"
argument_list|,
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
argument_list|)
expr_stmt|;
name|nlayers
operator|++
expr_stmt|;
comment|/* 	 * Consider all caches to be within a package/chip 	 * and "in front" of all sub-components like 	 * cores and hardware threads. 	 */
for|for
control|(
name|i
operator|=
name|MAX_CACHE_LEVELS
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|caches
index|[
name|i
index|]
operator|.
name|present
condition|)
block|{
name|KASSERT
argument_list|(
name|caches
index|[
name|i
index|]
operator|.
name|id_shift
operator|<=
name|pkg_id_shift
argument_list|,
operator|(
literal|"bug in APIC topology discovery"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|caches
index|[
name|i
index|]
operator|.
name|id_shift
operator|>=
name|core_id_shift
argument_list|,
operator|(
literal|"bug in APIC topology discovery"
operator|)
argument_list|)
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|type
operator|=
name|TOPO_TYPE_CACHE
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|subtype
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
operator|=
name|caches
index|[
name|i
index|]
operator|.
name|id_shift
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"L%u cache ID shift: %u\n"
argument_list|,
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|subtype
argument_list|,
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
argument_list|)
expr_stmt|;
name|nlayers
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pkg_id_shift
operator|>
name|core_id_shift
condition|)
block|{
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|type
operator|=
name|TOPO_TYPE_CORE
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
operator|=
name|core_id_shift
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Core ID shift: %u\n"
argument_list|,
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
argument_list|)
expr_stmt|;
name|nlayers
operator|++
expr_stmt|;
block|}
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|type
operator|=
name|TOPO_TYPE_PU
expr_stmt|;
name|topo_layers
index|[
name|nlayers
index|]
operator|.
name|id_shift
operator|=
literal|0
expr_stmt|;
name|nlayers
operator|++
expr_stmt|;
name|topo_init_root
argument_list|(
operator|&
name|topo_root
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_APIC_ID
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|cpu_info
index|[
name|i
index|]
operator|.
name|cpu_present
condition|)
continue|continue;
name|parent
operator|=
operator|&
name|topo_root
expr_stmt|;
for|for
control|(
name|layer
operator|=
literal|0
init|;
name|layer
operator|<
name|nlayers
condition|;
operator|++
name|layer
control|)
block|{
name|node_id
operator|=
name|i
operator|>>
name|topo_layers
index|[
name|layer
index|]
operator|.
name|id_shift
expr_stmt|;
name|parent
operator|=
name|topo_add_node_by_hwid
argument_list|(
name|parent
argument_list|,
name|node_id
argument_list|,
name|topo_layers
index|[
name|layer
index|]
operator|.
name|type
argument_list|,
name|topo_layers
index|[
name|layer
index|]
operator|.
name|subtype
argument_list|)
expr_stmt|;
block|}
block|}
name|parent
operator|=
operator|&
name|topo_root
expr_stmt|;
for|for
control|(
name|layer
operator|=
literal|0
init|;
name|layer
operator|<
name|nlayers
condition|;
operator|++
name|layer
control|)
block|{
name|node_id
operator|=
name|boot_cpu_id
operator|>>
name|topo_layers
index|[
name|layer
index|]
operator|.
name|id_shift
expr_stmt|;
name|node
operator|=
name|topo_find_node_by_hwid
argument_list|(
name|parent
argument_list|,
name|node_id
argument_list|,
name|topo_layers
index|[
name|layer
index|]
operator|.
name|type
argument_list|,
name|topo_layers
index|[
name|layer
index|]
operator|.
name|subtype
argument_list|)
expr_stmt|;
name|topo_promote_child
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|parent
operator|=
name|node
expr_stmt|;
block|}
name|cpu_topo_probed
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assign logical CPU IDs to local APICs.  */
end_comment

begin_function
name|void
name|assign_cpu_ids
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|topo_node
modifier|*
name|node
decl_stmt|;
name|u_int
name|smt_mask
decl_stmt|;
name|smt_mask
operator|=
operator|(
literal|1u
operator|<<
name|core_id_shift
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Assign CPU IDs to local APIC IDs and disable any CPUs 	 * beyond MAXCPU.  CPU 0 is always assigned to the BSP. 	 */
name|mp_ncpus
operator|=
literal|0
expr_stmt|;
name|TOPO_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&topo_root
argument_list|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|TOPO_TYPE_PU
condition|)
continue|continue;
if|if
condition|(
operator|(
name|node
operator|->
name|hwid
operator|&
name|smt_mask
operator|)
operator|!=
operator|(
name|boot_cpu_id
operator|&
name|smt_mask
operator|)
condition|)
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_hyperthread
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"lapic"
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|hwid
operator|!=
name|boot_cpu_id
condition|)
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Cannot disable BSP, APIC ID = %d\n"
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hyperthreading_allowed
operator|&&
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_hyperthread
condition|)
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mp_ncpus
operator|>=
name|MAXCPU
condition|)
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_disabled
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_disabled
condition|)
block|{
name|disabled_cpus
operator|++
expr_stmt|;
continue|continue;
block|}
name|cpu_apic_ids
index|[
name|mp_ncpus
index|]
operator|=
name|node
operator|->
name|hwid
expr_stmt|;
name|apic_cpuids
index|[
name|node
operator|->
name|hwid
index|]
operator|=
name|mp_ncpus
expr_stmt|;
name|topo_set_pu_id
argument_list|(
name|node
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|mp_ncpus
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|mp_maxid
operator|>=
name|mp_ncpus
operator|-
literal|1
argument_list|,
operator|(
literal|"%s: counters out of sync: max %d, count %d"
operator|,
name|__func__
operator|,
name|mp_maxid
operator|,
name|mp_ncpus
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print various information about the SMP system hardware and setup.  */
end_comment

begin_function
name|void
name|cpu_mp_announce
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|topo_node
modifier|*
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|hyperthread
decl_stmt|;
name|int
name|pkg_count
decl_stmt|;
name|int
name|cores_per_pkg
decl_stmt|;
name|int
name|thrs_per_core
decl_stmt|;
name|printf
argument_list|(
literal|"FreeBSD/SMP: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|topo_analyze
argument_list|(
operator|&
name|topo_root
argument_list|,
literal|1
argument_list|,
operator|&
name|pkg_count
argument_list|,
operator|&
name|cores_per_pkg
argument_list|,
operator|&
name|thrs_per_core
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%d package(s)"
argument_list|,
name|pkg_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|cores_per_pkg
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" x %d core(s)"
argument_list|,
name|cores_per_pkg
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrs_per_core
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|" x %d hardware threads"
argument_list|,
name|thrs_per_core
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Non-uniform topology"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|disabled_cpus
condition|)
block|{
name|printf
argument_list|(
literal|"FreeBSD/SMP Online: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|topo_analyze
argument_list|(
operator|&
name|topo_root
argument_list|,
literal|0
argument_list|,
operator|&
name|pkg_count
argument_list|,
operator|&
name|cores_per_pkg
argument_list|,
operator|&
name|thrs_per_core
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%d package(s)"
argument_list|,
name|pkg_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|cores_per_pkg
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|" x %d core(s)"
argument_list|,
name|cores_per_pkg
argument_list|)
expr_stmt|;
if|if
condition|(
name|thrs_per_core
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|" x %d hardware threads"
argument_list|,
name|thrs_per_core
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Non-uniform topology"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bootverbose
condition|)
return|return;
name|TOPO_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&topo_root
argument_list|)
block|{
switch|switch
condition|(
name|node
operator|->
name|type
condition|)
block|{
case|case
name|TOPO_TYPE_PKG
case|:
name|printf
argument_list|(
literal|"Package HW ID = %u (%#x)\n"
argument_list|,
name|node
operator|->
name|hwid
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOPO_TYPE_CORE
case|:
name|printf
argument_list|(
literal|"\tCore HW ID = %u (%#x)\n"
argument_list|,
name|node
operator|->
name|hwid
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOPO_TYPE_PU
case|:
if|if
condition|(
name|cpu_info
index|[
name|node
operator|->
name|hwid
index|]
operator|.
name|cpu_hyperthread
condition|)
name|hyperthread
operator|=
literal|"/HT"
expr_stmt|;
else|else
name|hyperthread
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|subtype
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t\tCPU (AP%s): APIC ID: %u (%#x)"
literal|"(disabled)\n"
argument_list|,
name|hyperthread
argument_list|,
name|node
operator|->
name|hwid
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|id
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\t\tCPU0 (BSP): APIC ID: %u (%#x)\n"
argument_list|,
name|node
operator|->
name|hwid
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\t\tCPU%u (AP%s): APIC ID: %u (%#x)\n"
argument_list|,
name|node
operator|->
name|id
argument_list|,
name|hyperthread
argument_list|,
name|node
operator|->
name|hwid
argument_list|,
name|node
operator|->
name|hwid
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* ignored */
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add a scheduling group, a group of logical processors sharing  * a particular cache (and, thus having an affinity), to the scheduling  * topology.  * This function recursively works on lower level caches.  */
end_comment

begin_function
specifier|static
name|void
name|x86topo_add_sched_group
parameter_list|(
name|struct
name|topo_node
modifier|*
name|root
parameter_list|,
name|struct
name|cpu_group
modifier|*
name|cg_root
parameter_list|)
block|{
name|struct
name|topo_node
modifier|*
name|node
decl_stmt|;
name|int
name|nchildren
decl_stmt|;
name|int
name|ncores
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|root
operator|->
name|type
operator|==
name|TOPO_TYPE_SYSTEM
operator|||
name|root
operator|->
name|type
operator|==
name|TOPO_TYPE_CACHE
argument_list|,
operator|(
literal|"x86topo_add_sched_group: bad type: %u"
operator|,
name|root
operator|->
name|type
operator|)
argument_list|)
expr_stmt|;
name|CPU_COPY
argument_list|(
operator|&
name|root
operator|->
name|cpuset
argument_list|,
operator|&
name|cg_root
operator|->
name|cg_mask
argument_list|)
expr_stmt|;
name|cg_root
operator|->
name|cg_count
operator|=
name|root
operator|->
name|cpu_count
expr_stmt|;
if|if
condition|(
name|root
operator|->
name|type
operator|==
name|TOPO_TYPE_SYSTEM
condition|)
name|cg_root
operator|->
name|cg_level
operator|=
name|CG_SHARE_NONE
expr_stmt|;
else|else
name|cg_root
operator|->
name|cg_level
operator|=
name|root
operator|->
name|subtype
expr_stmt|;
comment|/* 	 * Check how many core nodes we have under the given root node. 	 * If we have multiple logical processors, but not multiple 	 * cores, then those processors must be hardware threads. 	 */
name|ncores
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|root
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|TOPO_TYPE_CORE
condition|)
block|{
name|node
operator|=
name|topo_next_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ncores
operator|++
expr_stmt|;
name|node
operator|=
name|topo_next_nonchild_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cg_root
operator|->
name|cg_level
operator|!=
name|CG_SHARE_NONE
operator|&&
name|root
operator|->
name|cpu_count
operator|>
literal|1
operator|&&
name|ncores
operator|<
literal|2
condition|)
name|cg_root
operator|->
name|cg_flags
operator|=
name|CG_FLAG_SMT
expr_stmt|;
comment|/* 	 * Find out how many cache nodes we have under the given root node. 	 * We ignore cache nodes that cover all the same processors as the 	 * root node.  Also, we do not descend below found cache nodes. 	 * That is, we count top-level "non-redundant" caches under the root 	 * node. 	 */
name|nchildren
operator|=
literal|0
expr_stmt|;
name|node
operator|=
name|root
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|TOPO_TYPE_CACHE
operator|||
operator|(
name|root
operator|->
name|type
operator|!=
name|TOPO_TYPE_SYSTEM
operator|&&
name|CPU_CMP
argument_list|(
operator|&
name|node
operator|->
name|cpuset
argument_list|,
operator|&
name|root
operator|->
name|cpuset
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|=
name|topo_next_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nchildren
operator|++
expr_stmt|;
name|node
operator|=
name|topo_next_nonchild_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|cg_root
operator|->
name|cg_child
operator|=
name|smp_topo_alloc
argument_list|(
name|nchildren
argument_list|)
expr_stmt|;
name|cg_root
operator|->
name|cg_children
operator|=
name|nchildren
expr_stmt|;
comment|/* 	 * Now find again the same cache nodes as above and recursively 	 * build scheduling topologies for them. 	 */
name|node
operator|=
name|root
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|type
operator|!=
name|TOPO_TYPE_CACHE
operator|||
operator|(
name|root
operator|->
name|type
operator|!=
name|TOPO_TYPE_SYSTEM
operator|&&
name|CPU_CMP
argument_list|(
operator|&
name|node
operator|->
name|cpuset
argument_list|,
operator|&
name|root
operator|->
name|cpuset
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|node
operator|=
name|topo_next_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cg_root
operator|->
name|cg_child
index|[
name|i
index|]
operator|.
name|cg_parent
operator|=
name|cg_root
expr_stmt|;
name|x86topo_add_sched_group
argument_list|(
name|node
argument_list|,
operator|&
name|cg_root
operator|->
name|cg_child
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|node
operator|=
name|topo_next_nonchild_node
argument_list|(
name|root
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Build the MI scheduling topology from the discovered hardware topology.  */
end_comment

begin_function
name|struct
name|cpu_group
modifier|*
name|cpu_topo
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpu_group
modifier|*
name|cg_root
decl_stmt|;
if|if
condition|(
name|mp_ncpus
operator|<=
literal|1
condition|)
return|return
operator|(
name|smp_topo_none
argument_list|()
operator|)
return|;
name|cg_root
operator|=
name|smp_topo_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|x86topo_add_sched_group
argument_list|(
operator|&
name|topo_root
argument_list|,
name|cg_root
argument_list|)
expr_stmt|;
return|return
operator|(
name|cg_root
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a logical CPU to the topology.  */
end_comment

begin_function
name|void
name|cpu_add
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|char
name|boot_cpu
parameter_list|)
block|{
if|if
condition|(
name|apic_id
operator|>
name|MAX_APIC_ID
condition|)
block|{
name|panic
argument_list|(
literal|"SMP: APIC ID %d too high"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|==
literal|0
argument_list|,
operator|(
literal|"CPU %d added twice"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_present
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
block|{
name|KASSERT
argument_list|(
name|boot_cpu_id
operator|==
operator|-
literal|1
argument_list|,
operator|(
literal|"CPU %d claims to be BSP, but CPU %d already is"
operator|,
name|apic_id
operator|,
name|boot_cpu_id
operator|)
argument_list|)
expr_stmt|;
name|boot_cpu_id
operator|=
name|apic_id
expr_stmt|;
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mp_ncpus
operator|<
name|MAXCPU
condition|)
block|{
name|mp_ncpus
operator|++
expr_stmt|;
name|mp_maxid
operator|=
name|mp_ncpus
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"SMP: Added CPU %d (%s)\n"
argument_list|,
name|apic_id
argument_list|,
name|boot_cpu
condition|?
literal|"BSP"
else|:
literal|"AP"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cpu_mp_setmaxid
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * mp_ncpus and mp_maxid should be already set by calls to cpu_add(). 	 * If there were no calls to cpu_add() assume this is a UP system. 	 */
if|if
condition|(
name|mp_ncpus
operator|==
literal|0
condition|)
name|mp_ncpus
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_mp_probe
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Always record BSP in CPU map so that the mbuf init code works 	 * correctly. 	 */
name|CPU_SETOF
argument_list|(
literal|0
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
return|return
operator|(
name|mp_ncpus
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * AP CPU's call this to initialize themselves.  */
end_comment

begin_function
name|void
name|init_secondary_tail
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpuid
decl_stmt|;
comment|/* 	 * On real hardware, switch to x2apic mode if possible.  Do it 	 * after aps_ready was signalled, to avoid manipulating the 	 * mode while BSP might still want to send some IPI to us 	 * (second startup IPI is ignored on modern hardware etc). 	 */
name|lapic_xapic_mode
argument_list|()
expr_stmt|;
comment|/* Initialize the PAT MSR. */
name|pmap_init_pat
argument_list|()
expr_stmt|;
comment|/* set up CPU registers and state */
name|cpu_setregs
argument_list|()
expr_stmt|;
comment|/* set up SSE/NX */
name|initializecpu
argument_list|()
expr_stmt|;
comment|/* set up FPU state on the AP */
ifdef|#
directive|ifdef
name|__amd64__
name|fpuinit
argument_list|()
expr_stmt|;
else|#
directive|else
name|npxinit
argument_list|(
name|false
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cpu_ops
operator|.
name|cpu_init
condition|)
name|cpu_ops
operator|.
name|cpu_init
argument_list|()
expr_stmt|;
comment|/* A quick check from sanity claus */
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
operator|!=
name|lapic_id
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"SMP: cpuid = %d\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: actual apic_id = %d\n"
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: correct apic_id = %d\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cpuid mismatch! boom!!"
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize curthread. */
name|KASSERT
argument_list|(
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no idle thread"
operator|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|curthread
argument_list|,
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
argument_list|)
expr_stmt|;
name|mca_init
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* Init local apic for irq's */
name|lapic_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Set memory range attributes for this CPU to match the BSP */
name|mem_range_AP_init
argument_list|()
expr_stmt|;
name|smp_cpus
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_SMP
argument_list|,
literal|"SMP: AP CPU #%d Launched"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"SMP: AP CPU #%d Launched!\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Determine if we are a logical CPU. */
if|if
condition|(
name|cpu_info
index|[
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
index|]
operator|.
name|cpu_hyperthread
condition|)
name|CPU_SET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|logical_cpus_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|lapic_dump
argument_list|(
literal|"AP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_cpus
operator|==
name|mp_ncpus
condition|)
block|{
comment|/* enable IPI's, tlb shootdown, freezes etc */
name|atomic_store_rel_int
argument_list|(
operator|&
name|smp_started
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__amd64__
comment|/* 	 * Enable global pages TLB extension 	 * This also implicitly flushes the TLB  	 */
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_pcid_enabled
condition|)
name|load_cr4
argument_list|(
name|rcr4
argument_list|()
operator||
name|CR4_PCIDE
argument_list|)
expr_stmt|;
name|load_ds
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|load_es
argument_list|(
name|_udatasel
argument_list|)
expr_stmt|;
name|load_fs
argument_list|(
name|_ufssel
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock_spin
argument_list|(
operator|&
name|ap_boot_mtx
argument_list|)
expr_stmt|;
comment|/* Wait until all the AP's are up. */
while|while
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|smp_started
argument_list|)
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|EARLY_AP_STARTUP
comment|/* Start per-CPU event timers. */
name|cpu_initclocks_ap
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|sched_throw
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"scheduler returned us to %s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*******************************************************************  * local functions and data  */
end_comment

begin_comment
comment|/*  * We tell the I/O APIC code about all the CPUs we want to receive  * interrupts.  If we don't want certain CPUs to receive IRQs we  * can simply not tell the I/O APIC code about them in this function.  * We also do not tell it about the BSP since it tells itself about  * the BSP internally to work with UP kernels and on UP machines.  */
end_comment

begin_function
name|void
name|set_interrupt_apic_ids
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|apic_id
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|apic_id
operator|=
name|cpu_apic_ids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|apic_id
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_bsp
condition|)
continue|continue;
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_disabled
condition|)
continue|continue;
comment|/* Don't let hyperthreads service interrupts. */
if|if
condition|(
name|cpu_info
index|[
name|apic_id
index|]
operator|.
name|cpu_hyperthread
condition|)
continue|continue;
name|intr_add_cpu
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
end_ifdef

begin_decl_stmt
name|u_int
name|xhits_gbl
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|xhits_pg
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|xhits_rng
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|xhits
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|global
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xhits_gbl
argument_list|,
sizeof|sizeof
argument_list|(
name|xhits_gbl
argument_list|)
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|page
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xhits_pg
argument_list|,
sizeof|sizeof
argument_list|(
name|xhits_pg
argument_list|)
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|range
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|xhits_rng
argument_list|,
sizeof|sizeof
argument_list|(
name|xhits_rng
argument_list|)
argument_list|,
literal|"IU"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|ipi_global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ipi_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ipi_range
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ipi_range_size
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|ipi_global
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipi_global
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|ipi_page
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipi_page
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|ipi_range
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipi_range
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_xhits
argument_list|,
name|OID_AUTO
argument_list|,
name|ipi_range_size
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipi_range_size
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COUNT_XINVLTLB_HITS */
end_comment

begin_comment
comment|/*  * Init and startup IPI.  */
end_comment

begin_function
name|void
name|ipi_startup
parameter_list|(
name|int
name|apic_id
parameter_list|,
name|int
name|vector
parameter_list|)
block|{
comment|/* 	 * This attempts to follow the algorithm described in the 	 * Intel Multiprocessor Specification v1.4 in section B.4. 	 * For each IPI, we allow the local APIC ~20us to deliver the 	 * IPI.  If that times out, we panic. 	 */
comment|/* 	 * first we do an INIT IPI: this INIT IPI might be run, resetting 	 * and running the target CPU. OR this INIT IPI might be latched (P5 	 * bug), CPU waiting for STARTUP IPI. OR this INIT IPI might be 	 * ignored. 	 */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_LEVEL
operator||
name|APIC_LEVEL_ASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_INIT
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|lapic_ipi_wait
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Explicitly deassert the INIT IPI. */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_LEVEL
operator||
name|APIC_LEVEL_DEASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_INIT
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* wait ~10mS */
comment|/* 	 * next we do a STARTUP IPI: the previous INIT IPI might still be 	 * latched, (P5 bug) this 1st STARTUP would then terminate 	 * immediately, and the previously started INIT IPI would continue. OR 	 * the previous INIT IPI has already run. and this STARTUP IPI will 	 * run. OR the previous INIT IPI was ignored. and this STARTUP IPI 	 * will run. 	 */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_ASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_STARTUP
operator||
name|vector
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
literal|100
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Failed to deliver first STARTUP IPI to APIC %d"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
comment|/* 	 * finally we do a 2nd STARTUP IPI: this 2nd STARTUP IPI should run IF 	 * the previous STARTUP IPI was cancelled by a latched INIT IPI. OR 	 * this STARTUP IPI will be ignored, as only ONE STARTUP IPI is 	 * recognized after hardware RESET or INIT IPI. 	 */
name|lapic_ipi_raw
argument_list|(
name|APIC_DEST_DESTFLD
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_ASSERT
operator||
name|APIC_DESTMODE_PHY
operator||
name|APIC_DELMODE_STARTUP
operator||
name|vector
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
literal|100
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Failed to deliver second STARTUP IPI to APIC %d"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* wait ~200uS */
block|}
end_function

begin_comment
comment|/*  * Send an IPI to specified CPU handling the bitmap logic.  */
end_comment

begin_function
name|void
name|ipi_send_cpu
parameter_list|(
name|int
name|cpu
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|u_int
name|bitmap
decl_stmt|,
name|old_pending
decl_stmt|,
name|new_pending
decl_stmt|;
name|KASSERT
argument_list|(
name|cpu_apic_ids
index|[
name|cpu
index|]
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"IPI to non-existent CPU %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
condition|)
block|{
name|bitmap
operator|=
literal|1
operator|<<
name|ipi
expr_stmt|;
name|ipi
operator|=
name|IPI_BITMAP_VECTOR
expr_stmt|;
do|do
block|{
name|old_pending
operator|=
name|cpu_ipi_pending
index|[
name|cpu
index|]
expr_stmt|;
name|new_pending
operator|=
name|old_pending
operator||
name|bitmap
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|,
name|old_pending
argument_list|,
name|new_pending
argument_list|)
condition|)
do|;
if|if
condition|(
name|old_pending
condition|)
return|return;
block|}
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|cpu_apic_ids
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipi_bitmap_handler
parameter_list|(
name|struct
name|trapframe
name|frame
parameter_list|)
block|{
name|struct
name|trapframe
modifier|*
name|oldframe
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|u_int
name|ipi_bitmap
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_intr_nesting_level
operator|++
expr_stmt|;
name|oldframe
operator|=
name|td
operator|->
name|td_intr_frame
expr_stmt|;
name|td
operator|->
name|td_intr_frame
operator|=
operator|&
name|frame
expr_stmt|;
name|ipi_bitmap
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|cpu_ipi_pending
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_PREEMPT
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_preempt_counts
index|[
name|cpu
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
name|sched_preempt
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_AST
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_ast_counts
index|[
name|cpu
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Nothing to do for AST */
block|}
if|if
condition|(
name|ipi_bitmap
operator|&
operator|(
literal|1
operator|<<
name|IPI_HARDCLOCK
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_hardclock_counts
index|[
name|cpu
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
name|hardclockintr
argument_list|()
expr_stmt|;
block|}
name|td
operator|->
name|td_intr_frame
operator|=
name|oldframe
expr_stmt|;
name|td
operator|->
name|td_intr_nesting_level
operator|--
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * send an IPI to a set of cpus.  */
end_comment

begin_function
name|void
name|ipi_selected
parameter_list|(
name|cpuset_t
name|cpus
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
comment|/* 	 * IPI_STOP_HARD maps to a NMI and the trap handler needs a bit 	 * of help in order to understand what is the source. 	 * Set the mask of receiving CPUs for this purpose. 	 */
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP_HARD
condition|)
name|CPU_OR_ATOMIC
argument_list|(
operator|&
name|ipi_stop_nmi_pending
argument_list|,
operator|&
name|cpus
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cpu
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|cpus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|cpu
argument_list|,
operator|&
name|cpus
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpu: %d ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|cpu
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|ipi_send_cpu
argument_list|(
name|cpu
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * send an IPI to a specific CPU.  */
end_comment

begin_function
name|void
name|ipi_cpu
parameter_list|(
name|int
name|cpu
parameter_list|,
name|u_int
name|ipi
parameter_list|)
block|{
comment|/* 	 * IPI_STOP_HARD maps to a NMI and the trap handler needs a bit 	 * of help in order to understand what is the source. 	 * Set the mask of receiving CPUs for this purpose. 	 */
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP_HARD
condition|)
name|CPU_SET_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|ipi_stop_nmi_pending
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpu: %d ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|cpu
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|ipi_send_cpu
argument_list|(
name|cpu
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * send an IPI to all CPUs EXCEPT myself  */
end_comment

begin_function
name|void
name|ipi_all_but_self
parameter_list|(
name|u_int
name|ipi
parameter_list|)
block|{
name|cpuset_t
name|other_cpus
decl_stmt|;
name|other_cpus
operator|=
name|all_cpus
expr_stmt|;
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|IPI_IS_BITMAPED
argument_list|(
name|ipi
argument_list|)
condition|)
block|{
name|ipi_selected
argument_list|(
name|other_cpus
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * IPI_STOP_HARD maps to a NMI and the trap handler needs a bit 	 * of help in order to understand what is the source. 	 * Set the mask of receiving CPUs for this purpose. 	 */
if|if
condition|(
name|ipi
operator|==
name|IPI_STOP_HARD
condition|)
name|CPU_OR_ATOMIC
argument_list|(
operator|&
name|ipi_stop_nmi_pending
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|ipi
argument_list|)
expr_stmt|;
name|lapic_ipi_vectored
argument_list|(
name|ipi
argument_list|,
name|APIC_IPI_DEST_OTHERS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ipi_nmi_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpuid
decl_stmt|;
comment|/* 	 * As long as there is not a simple way to know about a NMI's 	 * source, if the bitmask for the current CPU is present in 	 * the global pending bitword an IPI_STOP_HARD has been issued 	 * and should be handled. 	 */
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|ipi_stop_nmi_pending
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|CPU_CLR_ATOMIC
argument_list|(
name|cpuid
argument_list|,
operator|&
name|ipi_stop_nmi_pending
argument_list|)
expr_stmt|;
name|cpustop_handler
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_decl_stmt
name|int
name|nmi_kdb_lock
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|nmi_call_kdb_smp
parameter_list|(
name|u_int
name|type
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|bool
name|call_post
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|nmi_kdb_lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|nmi_call_kdb
argument_list|(
name|cpu
argument_list|,
name|type
argument_list|,
name|frame
argument_list|)
expr_stmt|;
name|call_post
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|savectx
argument_list|(
operator|&
name|stoppcbs
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
name|CPU_SET_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|stopped_cpus
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|nmi_kdb_lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|call_post
operator|=
name|true
expr_stmt|;
block|}
name|atomic_store_rel_int
argument_list|(
operator|&
name|nmi_kdb_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_post
condition|)
name|cpustop_handler_post
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle an IPI_STOP by saving our current context and spinning until we  * are resumed.  */
end_comment

begin_function
name|void
name|cpustop_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|savectx
argument_list|(
operator|&
name|stoppcbs
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
comment|/* Indicate that we are stopped */
name|CPU_SET_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|stopped_cpus
argument_list|)
expr_stmt|;
comment|/* Wait for restart */
while|while
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|started_cpus
argument_list|)
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
name|cpustop_handler_post
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpustop_handler_post
parameter_list|(
name|u_int
name|cpu
parameter_list|)
block|{
name|CPU_CLR_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|started_cpus
argument_list|)
expr_stmt|;
name|CPU_CLR_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|stopped_cpus
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|DDB
argument_list|)
name|amd64_db_resume_dbreg
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cpu
operator|==
literal|0
operator|&&
name|cpustop_restartfunc
operator|!=
name|NULL
condition|)
block|{
name|cpustop_restartfunc
argument_list|()
expr_stmt|;
name|cpustop_restartfunc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle an IPI_SUSPEND by saving our current context and spinning until we  * are resumed.  */
end_comment

begin_function
name|void
name|cpususpend_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|cpu
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|savectx
argument_list|(
operator|&
name|susppcbs
index|[
name|cpu
index|]
operator|->
name|sp_pcb
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__amd64__
name|fpususpend
argument_list|(
name|susppcbs
index|[
name|cpu
index|]
operator|->
name|sp_fpususpend
argument_list|)
expr_stmt|;
else|#
directive|else
name|npxsuspend
argument_list|(
name|susppcbs
index|[
name|cpu
index|]
operator|->
name|sp_fpususpend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wbinvd
argument_list|()
expr_stmt|;
name|CPU_SET_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|suspended_cpus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|__amd64__
name|fpuresume
argument_list|(
name|susppcbs
index|[
name|cpu
index|]
operator|->
name|sp_fpususpend
argument_list|)
expr_stmt|;
else|#
directive|else
name|npxresume
argument_list|(
name|susppcbs
index|[
name|cpu
index|]
operator|->
name|sp_fpususpend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pmap_init_pat
argument_list|()
expr_stmt|;
name|initializecpu
argument_list|()
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchtime
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchticks
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
comment|/* Indicate that we are resumed */
name|CPU_CLR_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|suspended_cpus
argument_list|)
expr_stmt|;
block|}
comment|/* Wait for resume */
while|while
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|started_cpus
argument_list|)
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpu_ops
operator|.
name|cpu_resume
condition|)
name|cpu_ops
operator|.
name|cpu_resume
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__amd64__
if|if
condition|(
name|vmm_resume_p
condition|)
name|vmm_resume_p
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Resume MCA and local APIC */
name|lapic_xapic_mode
argument_list|()
expr_stmt|;
name|mca_resume
argument_list|()
expr_stmt|;
name|lapic_setup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Indicate that we are resumed */
name|CPU_CLR_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|suspended_cpus
argument_list|)
expr_stmt|;
name|CPU_CLR_ATOMIC
argument_list|(
name|cpu
argument_list|,
operator|&
name|started_cpus
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invlcache_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|generation
decl_stmt|;
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invlcache_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
comment|/* 	 * Reading the generation here allows greater parallelism 	 * since wbinvd is a serializing instruction.  Without the 	 * temporary, we'd wait for wbinvd to complete, then the read 	 * would execute, then the dependent write, which must then 	 * complete before return from interrupt. 	 */
name|generation
operator|=
name|smp_tlb_generation
expr_stmt|;
name|wbinvd
argument_list|()
expr_stmt|;
name|PCPU_SET
argument_list|(
name|smp_tlb_done
argument_list|,
name|generation
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called once the rest of the system is up and running and we're  * ready to let the AP's out of the pen.  */
end_comment

begin_function
specifier|static
name|void
name|release_aps
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
return|return;
name|atomic_store_rel_int
argument_list|(
operator|&
name|aps_ready
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|smp_started
operator|==
literal|0
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|start_aps
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|release_aps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COUNT_IPIS
end_ifdef

begin_comment
comment|/*  * Setup interrupt counters for IPI handlers.  */
end_comment

begin_function
specifier|static
name|void
name|mp_ipi_intrcnt
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:invltlb"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_invltlb_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:invlrng"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_invlrng_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:invlpg"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_invlpg_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:invlcache"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_invlcache_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:preempt"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_preempt_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:ast"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_ast_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:rendezvous"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_rendezvous_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:hardclock"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|ipi_hardclock_counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|mp_ipi_intrcnt
argument_list|,
name|SI_SUB_INTR
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|mp_ipi_intrcnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Flush the TLB on other CPU's  */
end_comment

begin_comment
comment|/* Variables needed for SMP tlb shootdown. */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|smp_tlb_addr1
decl_stmt|,
name|smp_tlb_addr2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|pmap_t
name|smp_tlb_pmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|uint32_t
name|smp_tlb_generation
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|read_eflags
parameter_list|()
value|read_rflags()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|smp_targeted_tlb_shootdown
parameter_list|(
name|cpuset_t
name|mask
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
name|cpuset_t
name|other_cpus
decl_stmt|;
specifier|volatile
name|uint32_t
modifier|*
name|p_cpudone
decl_stmt|;
name|uint32_t
name|generation
decl_stmt|;
name|int
name|cpu
decl_stmt|;
comment|/* 	 * Check for other cpus.  Return if none. 	 */
if|if
condition|(
name|CPU_ISFULLSET
argument_list|(
operator|&
name|mask
argument_list|)
condition|)
block|{
if|if
condition|(
name|mp_ncpus
operator|<=
literal|1
condition|)
return|return;
block|}
else|else
block|{
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|CPU_EMPTY
argument_list|(
operator|&
name|mask
argument_list|)
condition|)
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|read_eflags
argument_list|()
operator|&
name|PSL_I
operator|)
condition|)
name|panic
argument_list|(
literal|"%s: interrupts disabled"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
name|smp_tlb_addr1
operator|=
name|addr1
expr_stmt|;
name|smp_tlb_addr2
operator|=
name|addr2
expr_stmt|;
name|smp_tlb_pmap
operator|=
name|pmap
expr_stmt|;
name|generation
operator|=
operator|++
name|smp_tlb_generation
expr_stmt|;
if|if
condition|(
name|CPU_ISFULLSET
argument_list|(
operator|&
name|mask
argument_list|)
condition|)
block|{
name|ipi_all_but_self
argument_list|(
name|vector
argument_list|)
expr_stmt|;
name|other_cpus
operator|=
name|all_cpus
expr_stmt|;
name|CPU_CLR
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|other_cpus
operator|=
name|mask
expr_stmt|;
while|while
condition|(
operator|(
name|cpu
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|mask
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|cpu
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_SMP
argument_list|,
literal|"%s: cpu: %d ipi: %x"
argument_list|,
name|__func__
argument_list|,
name|cpu
argument_list|,
name|vector
argument_list|)
expr_stmt|;
name|ipi_send_cpu
argument_list|(
name|cpu
argument_list|,
name|vector
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|cpu
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|other_cpus
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|--
expr_stmt|;
name|CPU_CLR
argument_list|(
name|cpu
argument_list|,
operator|&
name|other_cpus
argument_list|)
expr_stmt|;
name|p_cpudone
operator|=
operator|&
name|cpuid_to_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_smp_tlb_done
expr_stmt|;
while|while
condition|(
operator|*
name|p_cpudone
operator|!=
name|generation
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|smp_ipi_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smp_masked_invltlb
parameter_list|(
name|cpuset_t
name|mask
parameter_list|,
name|pmap_t
name|pmap
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLTLB
argument_list|,
name|pmap
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|ipi_global
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg
parameter_list|(
name|cpuset_t
name|mask
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLPG
argument_list|,
name|NULL
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|ipi_page
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|smp_masked_invlpg_range
parameter_list|(
name|cpuset_t
name|mask
parameter_list|,
name|vm_offset_t
name|addr1
parameter_list|,
name|vm_offset_t
name|addr2
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|mask
argument_list|,
name|IPI_INVLRNG
argument_list|,
name|NULL
argument_list|,
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|ipi_range
operator|++
expr_stmt|;
name|ipi_range_size
operator|+=
operator|(
name|addr2
operator|-
name|addr1
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|smp_cache_flush
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|smp_started
condition|)
block|{
name|smp_targeted_tlb_shootdown
argument_list|(
name|all_cpus
argument_list|,
name|IPI_INVLCACHE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handlers for TLB related IPIs  */
end_comment

begin_function
name|void
name|invltlb_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|generation
decl_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|xhits_gbl
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_XINVLTLB_HITS */
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invltlb_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
comment|/* 	 * Reading the generation here allows greater parallelism 	 * since invalidating the TLB is a serializing operation. 	 */
name|generation
operator|=
name|smp_tlb_generation
expr_stmt|;
if|if
condition|(
name|smp_tlb_pmap
operator|==
name|kernel_pmap
condition|)
name|invltlb_glob
argument_list|()
expr_stmt|;
else|else
name|invltlb
argument_list|()
expr_stmt|;
name|PCPU_SET
argument_list|(
name|smp_tlb_done
argument_list|,
name|generation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invlpg_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|generation
decl_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|xhits_pg
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_XINVLTLB_HITS */
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invlpg_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
name|generation
operator|=
name|smp_tlb_generation
expr_stmt|;
comment|/* Overlap with serialization */
name|invlpg
argument_list|(
name|smp_tlb_addr1
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|smp_tlb_done
argument_list|,
name|generation
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|invlrng_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|addr2
decl_stmt|;
name|uint32_t
name|generation
decl_stmt|;
ifdef|#
directive|ifdef
name|COUNT_XINVLTLB_HITS
name|xhits_rng
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_XINVLTLB_HITS */
ifdef|#
directive|ifdef
name|COUNT_IPIS
operator|(
operator|*
name|ipi_invlrng_counts
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|)
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* COUNT_IPIS */
name|addr
operator|=
name|smp_tlb_addr1
expr_stmt|;
name|addr2
operator|=
name|smp_tlb_addr2
expr_stmt|;
name|generation
operator|=
name|smp_tlb_generation
expr_stmt|;
comment|/* Overlap with serialization */
do|do
block|{
name|invlpg
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
do|while
condition|(
name|addr
operator|<
name|addr2
condition|)
do|;
name|PCPU_SET
argument_list|(
name|smp_tlb_done
argument_list|,
name|generation
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

