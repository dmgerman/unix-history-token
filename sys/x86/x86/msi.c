begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Yahoo!, Inc.  * All rights reserved.  * Written by: John Baldwin<jhb@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Support for PCI Message Signalled Interrupts (MSI).  MSI interrupts on  * x86 are basically APIC messages that the northbridge delivers directly  * to the local APICs as if they had come from an I/O APIC.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_comment
comment|/* Fields in address for Intel MSI messages. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DEST
value|0x000ff000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH
value|0x00000008
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH_ON
value|0x00000008
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_RH_OFF
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM
value|0x00000004
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM_PHYSICAL
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_ADDR_DM_LOGICAL
value|0x00000004
end_define

begin_comment
comment|/* Fields in data for Intel MSI messages. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGRMOD
value|IOART_TRGRMOD
end_define

begin_comment
comment|/* Trigger mode. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGREDG
value|IOART_TRGREDG
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_TRGRLVL
value|IOART_TRGRLVL
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_LEVEL
value|0x00004000
end_define

begin_comment
comment|/* Polarity. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DEASSERT
value|0x00000000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_ASSERT
value|0x00004000
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELMOD
value|IOART_DELMOD
end_define

begin_comment
comment|/* Delivery mode. */
end_comment

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELFIXED
value|IOART_DELFIXED
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELLOPRI
value|IOART_DELLOPRI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELSMI
value|IOART_DELSMI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELNMI
value|IOART_DELNMI
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELINIT
value|IOART_DELINIT
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_DELEXINT
value|IOART_DELEXINT
end_define

begin_define
define|#
directive|define
name|MSI_INTEL_DATA_INTVEC
value|IOART_INTVEC
end_define

begin_comment
comment|/* Interrupt vector. */
end_comment

begin_comment
comment|/*  * Build Intel MSI message and data values from a source.  AMD64 systems  * seem to be compatible, so we use the same function for both.  */
end_comment

begin_define
define|#
directive|define
name|INTEL_ADDR
parameter_list|(
name|msi
parameter_list|)
define|\
value|(MSI_INTEL_ADDR_BASE | (msi)->msi_cpu<< 12 |			\ 	    MSI_INTEL_ADDR_RH_OFF | MSI_INTEL_ADDR_DM_PHYSICAL)
end_define

begin_define
define|#
directive|define
name|INTEL_DATA
parameter_list|(
name|msi
parameter_list|)
define|\
value|(MSI_INTEL_DATA_TRGREDG | MSI_INTEL_DATA_DELFIXED | (msi)->msi_vector)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MSI
argument_list|,
literal|"msi"
argument_list|,
literal|"PCI MSI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * MSI sources are bunched into groups.  This is because MSI forces  * all of the messages to share the address and data registers and  * thus certain properties (such as the local APIC ID target on x86).  * Each group has a 'first' source that contains information global to  * the group.  These fields are marked with (g) below.  *  * Note that local APIC ID is kind of special.  Each message will be  * assigned an ID by the system; however, a group will use the ID from  * the first message.  *  * For MSI-X, each message is isolated.  */
end_comment

begin_struct
struct|struct
name|msi_intsrc
block|{
name|struct
name|intsrc
name|msi_intsrc
decl_stmt|;
name|device_t
name|msi_dev
decl_stmt|;
comment|/* Owning device. (g) */
name|struct
name|msi_intsrc
modifier|*
name|msi_first
decl_stmt|;
comment|/* First source in group. */
name|u_int
name|msi_irq
decl_stmt|;
comment|/* IRQ cookie. */
name|u_int
name|msi_msix
decl_stmt|;
comment|/* MSI-X message. */
name|u_int
name|msi_vector
range|:
literal|8
decl_stmt|;
comment|/* IDT vector. */
name|u_int
name|msi_cpu
range|:
literal|8
decl_stmt|;
comment|/* Local APIC ID. (g) */
name|u_int
name|msi_count
range|:
literal|8
decl_stmt|;
comment|/* Messages in this group. (g) */
name|u_int
name|msi_maxcount
range|:
literal|8
decl_stmt|;
comment|/* Alignment for this group. (g) */
name|int
modifier|*
name|msi_irqs
decl_stmt|;
comment|/* Group's IRQ list. (g) */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|msi_create_source
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msi_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msi_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pic
name|msi_pic
init|=
block|{
name|msi_enable_source
block|,
name|msi_disable_source
block|,
name|msi_eoi_source
block|,
name|msi_enable_intr
block|,
name|msi_disable_intr
block|,
name|msi_vector
block|,
name|msi_source_pending
block|,
name|NULL
block|,
name|NULL
block|,
name|msi_config_intr
block|,
name|msi_assign_cpu
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/**  * Xen hypervisors prior to 4.6.0 do not properly handle updates to  * enabled MSI-X table entries.  Allow migration of MSI-X interrupts  * to be disabled via a tunable. Values have the following meaning:  *  * -1: automatic detection by FreeBSD  *  0: enable migration  *  1: disable migration  */
end_comment

begin_decl_stmt
name|int
name|msix_disable_migration
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|disable_msix_migration
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msix_disable_migration
argument_list|,
literal|0
argument_list|,
literal|"Disable migration of MSI-X interrupts between CPUs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|msi_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msi_last_irq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|msi_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|msi_enable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|msi_disable_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|int
name|eoi
parameter_list|)
block|{
if|if
condition|(
name|eoi
operator|==
name|PIC_EOI
condition|)
name|lapic_eoi
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_eoi_source
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|lapic_eoi
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_enable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|apic_enable_vector
argument_list|(
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_disable_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|apic_disable_vector
argument_list|(
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_vector
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
return|return
operator|(
name|msi
operator|->
name|msi_irq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_source_pending
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_config_intr
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|enum
name|intr_trigger
name|trig
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msi_assign_cpu
parameter_list|(
name|struct
name|intsrc
modifier|*
name|isrc
parameter_list|,
name|u_int
name|apic_id
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|sib
decl_stmt|,
modifier|*
name|msi
init|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|isrc
decl_stmt|;
name|int
name|old_vector
decl_stmt|;
name|u_int
name|old_id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|vector
decl_stmt|;
comment|/* 	 * Only allow CPUs to be assigned to the first message for an 	 * MSI group. 	 */
if|if
condition|(
name|msi
operator|->
name|msi_first
operator|!=
name|msi
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|msix_disable_migration
operator|&&
name|msi
operator|->
name|msi_msix
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
comment|/* Store information to free existing irq. */
name|old_vector
operator|=
name|msi
operator|->
name|msi_vector
expr_stmt|;
name|old_id
operator|=
name|msi
operator|->
name|msi_cpu
expr_stmt|;
if|if
condition|(
name|old_id
operator|==
name|apic_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Allocate IDT vectors on this cpu. */
if|if
condition|(
name|msi
operator|->
name|msi_count
operator|>
literal|1
condition|)
block|{
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_msix
operator|==
literal|0
argument_list|,
operator|(
literal|"MSI-X message group"
operator|)
argument_list|)
expr_stmt|;
name|vector
operator|=
name|apic_alloc_vectors
argument_list|(
name|apic_id
argument_list|,
name|msi
operator|->
name|msi_irqs
argument_list|,
name|msi
operator|->
name|msi_count
argument_list|,
name|msi
operator|->
name|msi_maxcount
argument_list|)
expr_stmt|;
block|}
else|else
name|vector
operator|=
name|apic_alloc_vector
argument_list|(
name|apic_id
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|msi
operator|->
name|msi_cpu
operator|=
name|apic_id
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
name|vector
expr_stmt|;
if|if
condition|(
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|>
literal|0
condition|)
name|apic_enable_vector
argument_list|(
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: Assigning %s IRQ %d to local APIC %u vector %u\n"
argument_list|,
name|msi
operator|->
name|msi_msix
condition|?
literal|"MSI-X"
else|:
literal|"MSI"
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|,
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|msi
operator|->
name|msi_count
condition|;
name|i
operator|++
control|)
block|{
name|sib
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|msi
operator|->
name|msi_irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sib
operator|->
name|msi_cpu
operator|=
name|apic_id
expr_stmt|;
name|sib
operator|->
name|msi_vector
operator|=
name|vector
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|sib
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|>
literal|0
condition|)
name|apic_enable_vector
argument_list|(
name|sib
operator|->
name|msi_cpu
argument_list|,
name|sib
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: Assigning MSI IRQ %d to local APIC %u vector %u\n"
argument_list|,
name|sib
operator|->
name|msi_irq
argument_list|,
name|sib
operator|->
name|msi_cpu
argument_list|,
name|sib
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
block|}
name|BUS_REMAP_INTR
argument_list|(
name|device_get_parent
argument_list|(
name|msi
operator|->
name|msi_dev
argument_list|)
argument_list|,
name|msi
operator|->
name|msi_dev
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
comment|/* 	 * Free the old vector after the new one is established.  This is done 	 * to prevent races where we could miss an interrupt. 	 */
if|if
condition|(
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|>
literal|0
condition|)
name|apic_disable_vector
argument_list|(
name|old_id
argument_list|,
name|old_vector
argument_list|)
expr_stmt|;
name|apic_free_vector
argument_list|(
name|old_id
argument_list|,
name|old_vector
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|msi
operator|->
name|msi_count
condition|;
name|i
operator|++
control|)
block|{
name|sib
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|msi
operator|->
name|msi_irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sib
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|>
literal|0
condition|)
name|apic_disable_vector
argument_list|(
name|old_id
argument_list|,
name|old_vector
operator|+
name|i
argument_list|)
expr_stmt|;
name|apic_free_vector
argument_list|(
name|old_id
argument_list|,
name|old_vector
operator|+
name|i
argument_list|,
name|msi
operator|->
name|msi_irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|msi_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Check if we have a supported CPU. */
switch|switch
condition|(
name|cpu_vendor_id
condition|)
block|{
case|case
name|CPU_VENDOR_INTEL
case|:
case|case
name|CPU_VENDOR_AMD
case|:
break|break;
case|case
name|CPU_VENDOR_CENTAUR
case|:
if|if
condition|(
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|==
literal|0x6
operator|&&
name|CPUID_TO_MODEL
argument_list|(
name|cpu_id
argument_list|)
operator|>=
literal|0xf
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
return|return;
block|}
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|msix_disable_migration
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* The default is to allow migration of MSI-X interrupts. */
name|msix_disable_migration
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|msi_enabled
operator|=
literal|1
expr_stmt|;
name|intr_register_pic
argument_list|(
operator|&
name|msi_pic
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|msi_lock
argument_list|,
literal|"msi"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|msi_create_source
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi_last_irq
operator|>=
name|NUM_MSI_INTS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|irq
operator|=
name|msi_last_irq
operator|+
name|FIRST_MSI_INT
expr_stmt|;
name|msi_last_irq
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|msi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msi_intsrc
argument_list|)
argument_list|,
name|M_MSI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_pic
operator|=
operator|&
name|msi_pic
expr_stmt|;
name|msi
operator|->
name|msi_irq
operator|=
name|irq
expr_stmt|;
name|intr_register_source
argument_list|(
operator|&
name|msi
operator|->
name|msi_intsrc
argument_list|)
expr_stmt|;
name|nexus_add_irq
argument_list|(
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to allocate 'count' interrupt sources with contiguous IDT values.  */
end_comment

begin_function
name|int
name|msi_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|,
modifier|*
name|fsrc
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|mirqs
decl_stmt|,
name|vector
decl_stmt|;
if|if
condition|(
operator|!
name|msi_enabled
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|mirqs
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mirqs
argument_list|)
argument_list|,
name|M_MSI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|mirqs
operator|=
name|NULL
expr_stmt|;
name|again
label|:
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
comment|/* Try to find 'count' free IRQs. */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FIRST_MSI_INT
init|;
name|i
operator|<
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* End of allocated sources, so break. */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
break|break;
comment|/* If this is a free one, save its IRQ in the array. */
if|if
condition|(
name|msi
operator|->
name|msi_dev
operator|==
name|NULL
condition|)
block|{
name|irqs
index|[
name|cnt
index|]
operator|=
name|i
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
name|count
condition|)
break|break;
block|}
block|}
comment|/* Do we need to create some new sources? */
if|if
condition|(
name|cnt
operator|<
name|count
condition|)
block|{
comment|/* If we would exceed the max, give up. */
if|if
condition|(
name|i
operator|+
operator|(
name|count
operator|-
name|cnt
operator|)
operator|>
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mirqs
argument_list|,
name|M_MSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
comment|/* We need count - cnt more sources. */
while|while
condition|(
name|cnt
operator|<
name|count
condition|)
block|{
name|msi_create_source
argument_list|()
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
goto|goto
name|again
goto|;
block|}
comment|/* Ok, we now have the IRQs allocated. */
name|KASSERT
argument_list|(
name|cnt
operator|==
name|count
argument_list|,
operator|(
literal|"count mismatch"
operator|)
argument_list|)
expr_stmt|;
comment|/* Allocate 'count' IDT vectors. */
name|cpu
operator|=
name|intr_next_cpu
argument_list|()
expr_stmt|;
name|vector
operator|=
name|apic_alloc_vectors
argument_list|(
name|cpu
argument_list|,
name|irqs
argument_list|,
name|count
argument_list|,
name|maxcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mirqs
argument_list|,
name|M_MSI
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* Assign IDT vectors and make these messages owned by 'dev'. */
name|fsrc
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_cpu
operator|=
name|cpu
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|dev
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
name|vector
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: routing MSI IRQ %d to local APIC %u vector %u\n"
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|,
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_first
operator|=
name|fsrc
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"dead MSI has handlers"
operator|)
argument_list|)
expr_stmt|;
block|}
name|fsrc
operator|->
name|msi_count
operator|=
name|count
expr_stmt|;
name|fsrc
operator|->
name|msi_maxcount
operator|=
name|maxcount
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|bcopy
argument_list|(
name|irqs
argument_list|,
name|mirqs
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|mirqs
argument_list|)
argument_list|)
expr_stmt|;
name|fsrc
operator|->
name|msi_irqs
operator|=
name|mirqs
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msi_release
parameter_list|(
name|int
modifier|*
name|irqs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|,
modifier|*
name|first
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|first
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this isn't an MSI-X message. */
if|if
condition|(
name|first
operator|->
name|msi_msix
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make sure this message is allocated to a group. */
if|if
condition|(
name|first
operator|->
name|msi_first
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Make sure this is the start of a group and that we are releasing 	 * the entire group. 	 */
if|if
condition|(
name|first
operator|->
name|msi_first
operator|!=
name|first
operator|||
name|first
operator|->
name|msi_count
operator|!=
name|count
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|first
operator|->
name|msi_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unowned group"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear all the extra messages in the group. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irqs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_first
operator|==
name|first
argument_list|,
operator|(
literal|"message not in group"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_dev
operator|==
name|first
operator|->
name|msi_dev
argument_list|,
operator|(
literal|"owner mismatch"
operator|)
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_first
operator|=
name|NULL
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Clear out the first message. */
name|first
operator|->
name|msi_first
operator|=
name|NULL
expr_stmt|;
name|first
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|first
operator|->
name|msi_cpu
argument_list|,
name|first
operator|->
name|msi_vector
argument_list|,
name|first
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|first
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|first
operator|->
name|msi_maxcount
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|first
operator|->
name|msi_irqs
argument_list|,
name|M_MSI
argument_list|)
expr_stmt|;
name|first
operator|->
name|msi_irqs
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msi_map
parameter_list|(
name|int
name|irq
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this message is allocated to a device. */
if|if
condition|(
name|msi
operator|->
name|msi_dev
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * If this message isn't an MSI-X message, make sure it's part 	 * of a group, and switch to the first message in the 	 * group. 	 */
if|if
condition|(
operator|!
name|msi
operator|->
name|msi_msix
condition|)
block|{
if|if
condition|(
name|msi
operator|->
name|msi_first
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|msi
operator|=
name|msi
operator|->
name|msi_first
expr_stmt|;
block|}
operator|*
name|addr
operator|=
name|INTEL_ADDR
argument_list|(
name|msi
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|INTEL_DATA
argument_list|(
name|msi
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msix_alloc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|,
name|vector
decl_stmt|;
if|if
condition|(
operator|!
name|msi_enabled
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|again
label|:
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
comment|/* Find a free IRQ. */
for|for
control|(
name|i
operator|=
name|FIRST_MSI_INT
init|;
name|i
operator|<
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|;
name|i
operator|++
control|)
block|{
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* End of allocated sources, so break. */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
break|break;
comment|/* Stop at the first free source. */
if|if
condition|(
name|msi
operator|->
name|msi_dev
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Do we need to create a new source? */
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
comment|/* If we would exceed the max, give up. */
if|if
condition|(
name|i
operator|+
literal|1
operator|>
name|FIRST_MSI_INT
operator|+
name|NUM_MSI_INTS
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
comment|/* Create a new source. */
name|msi_create_source
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Allocate an IDT vector. */
name|cpu
operator|=
name|intr_next_cpu
argument_list|()
expr_stmt|;
name|vector
operator|=
name|apic_alloc_vector
argument_list|(
name|cpu
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|vector
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"msi: routing MSI-X IRQ %d to local APIC %u vector %u\n"
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|,
name|cpu
argument_list|,
name|vector
argument_list|)
expr_stmt|;
comment|/* Setup source. */
name|msi
operator|->
name|msi_cpu
operator|=
name|cpu
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|dev
expr_stmt|;
name|msi
operator|->
name|msi_first
operator|=
name|msi
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
name|vector
expr_stmt|;
name|msi
operator|->
name|msi_msix
operator|=
literal|1
expr_stmt|;
name|msi
operator|->
name|msi_count
operator|=
literal|1
expr_stmt|;
name|msi
operator|->
name|msi_maxcount
operator|=
literal|1
expr_stmt|;
name|msi
operator|->
name|msi_irqs
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_intsrc
operator|.
name|is_handlers
operator|==
literal|0
argument_list|,
operator|(
literal|"dead MSI-X has handlers"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
operator|*
name|irq
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msix_release
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|msi_intsrc
modifier|*
name|msi
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
name|msi
operator|=
operator|(
expr|struct
name|msi_intsrc
operator|*
operator|)
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Make sure this is an MSI-X message. */
if|if
condition|(
operator|!
name|msi
operator|->
name|msi_msix
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|msi
operator|->
name|msi_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unowned message"
operator|)
argument_list|)
expr_stmt|;
comment|/* Clear out the message. */
name|msi
operator|->
name|msi_first
operator|=
name|NULL
expr_stmt|;
name|msi
operator|->
name|msi_dev
operator|=
name|NULL
expr_stmt|;
name|apic_free_vector
argument_list|(
name|msi
operator|->
name|msi_cpu
argument_list|,
name|msi
operator|->
name|msi_vector
argument_list|,
name|msi
operator|->
name|msi_irq
argument_list|)
expr_stmt|;
name|msi
operator|->
name|msi_vector
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_msix
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_count
operator|=
literal|0
expr_stmt|;
name|msi
operator|->
name|msi_maxcount
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

