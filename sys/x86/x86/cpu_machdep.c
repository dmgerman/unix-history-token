begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 Peter Wemm.  * Copyright (c) 1992 Terrence R. Lambert.  * Copyright (c) 1982, 1987, 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)machdep.c	7.4 (Berkeley) 6/3/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_atpic.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_cpu.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_maxmem.h"
end_include

begin_include
include|#
directive|include
file|"opt_mp_watchdog.h"
end_include

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|"opt_apic.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/mp_watchdog.h>
end_include

begin_include
include|#
directive|include
file|<machine/tss.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<x86/acpica_machdep.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_define
define|#
directive|define
name|STATE_RUNNING
value|0x0
end_define

begin_define
define|#
directive|define
name|STATE_MWAIT
value|0x1
end_define

begin_define
define|#
directive|define
name|STATE_SLEEPING
value|0x2
end_define

begin_comment
comment|/*  * Machine dependent boot() routine  *  * I haven't seen anything to put here yet  * Possibly some stuff might be grafted back here from boot()  */
end_comment

begin_function
name|void
name|cpu_boot
parameter_list|(
name|int
name|howto
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Flush the D-cache for non-DMA I/O so that the I-cache can  * be made coherent later.  */
end_comment

begin_function
name|void
name|cpu_flush_dcache
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* Not applicable */
block|}
end_function

begin_function
name|void
name|acpi_cpu_c1
parameter_list|(
name|void
parameter_list|)
block|{
asm|__asm __volatile("sti; hlt");
block|}
end_function

begin_comment
comment|/*  * Use mwait to pause execution while waiting for an interrupt or  * another thread to signal that there is more work.  *  * NOTE: Interrupts will cause a wakeup; however, this function does  * not enable interrupt handling. The caller is responsible to enable  * interrupts.  */
end_comment

begin_function
name|void
name|acpi_cpu_idle_mwait
parameter_list|(
name|uint32_t
name|mwait_hint
parameter_list|)
block|{
name|int
modifier|*
name|state
decl_stmt|;
comment|/* 	 * XXXKIB.  Software coordination mode should be supported, 	 * but all Intel CPUs provide hardware coordination. 	 */
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|monitorbuf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|state
operator|==
name|STATE_SLEEPING
argument_list|,
operator|(
literal|"cpu_mwait_cx: wrong monitorbuf state"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_MWAIT
expr_stmt|;
name|cpu_monitor
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|state
operator|==
name|STATE_MWAIT
condition|)
name|cpu_mwait
argument_list|(
name|MWAIT_INTRBREAK
argument_list|,
name|mwait_hint
argument_list|)
expr_stmt|;
comment|/* 	 * We should exit on any event that interrupts mwait, because 	 * that event might be a wanted interrupt. 	 */
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get current clock frequency for the given cpu id. */
end_comment

begin_function
name|int
name|cpu_est_clockrate
parameter_list|(
name|int
name|cpu_id
parameter_list|,
name|uint64_t
modifier|*
name|rate
parameter_list|)
block|{
name|uint64_t
name|tsc1
decl_stmt|,
name|tsc2
decl_stmt|;
name|uint64_t
name|acnt
decl_stmt|,
name|mcnt
decl_stmt|,
name|perf
decl_stmt|;
name|register_t
name|reg
decl_stmt|;
if|if
condition|(
name|pcpu_find
argument_list|(
name|cpu_id
argument_list|)
operator|==
name|NULL
operator|||
name|rate
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_TSC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * If TSC is P-state invariant and APERF/MPERF MSRs do not exist, 	 * DELAY(9) based logic fails. 	 */
if|if
condition|(
name|tsc_is_invariant
operator|&&
operator|!
name|tsc_perf_stat
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|smp_cpus
operator|>
literal|1
condition|)
block|{
comment|/* Schedule ourselves on the indicated cpu. */
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu_id
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Calibrate by measuring a short delay. */
name|reg
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|tsc_is_invariant
condition|)
block|{
name|wrmsr
argument_list|(
name|MSR_MPERF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_APERF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|mcnt
operator|=
name|rdmsr
argument_list|(
name|MSR_MPERF
argument_list|)
expr_stmt|;
name|acnt
operator|=
name|rdmsr
argument_list|(
name|MSR_APERF
argument_list|)
expr_stmt|;
name|tsc2
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|intr_restore
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|perf
operator|=
literal|1000
operator|*
name|acnt
operator|/
name|mcnt
expr_stmt|;
operator|*
name|rate
operator|=
operator|(
name|tsc2
operator|-
name|tsc1
operator|)
operator|*
name|perf
expr_stmt|;
block|}
else|else
block|{
name|tsc1
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|tsc2
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
name|intr_restore
argument_list|(
name|reg
argument_list|)
expr_stmt|;
operator|*
name|rate
operator|=
operator|(
name|tsc2
operator|-
name|tsc1
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|smp_cpus
operator|>
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown the CPU as much as possible  */
end_comment

begin_function
name|void
name|cpu_halt
parameter_list|(
name|void
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
name|halt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|cpu_mwait_usable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|cpu_feature2
operator|&
name|CPUID2_MON
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|cpu_mon_mwait_flags
operator|&
operator|(
name|CPUID5_MON_MWAIT_EXT
operator||
name|CPUID5_MWAIT_INTRBREAK
operator|)
operator|)
operator|==
operator|(
name|CPUID5_MON_MWAIT_EXT
operator||
name|CPUID5_MWAIT_INTRBREAK
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|cpu_idle_hook
function_decl|)
parameter_list|(
name|sbintime_t
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* ACPI idle hook. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|cpu_ident_amdc1e
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* AMD C1E supported. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|idle_mwait
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use MONITOR/MWAIT for short idle. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_mwait
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|idle_mwait
argument_list|,
literal|0
argument_list|,
literal|"Use MONITOR/MWAIT for short idle"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|cpu_idle_acpi
parameter_list|(
name|sbintime_t
name|sbt
parameter_list|)
block|{
name|int
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|monitorbuf
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_SLEEPING
expr_stmt|;
comment|/* See comments in cpu_idle_hlt(). */
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_runnable
argument_list|()
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|cpu_idle_hook
condition|)
name|cpu_idle_hook
argument_list|(
name|sbt
argument_list|)
expr_stmt|;
else|else
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpu_idle_hlt
parameter_list|(
name|sbintime_t
name|sbt
parameter_list|)
block|{
name|int
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|monitorbuf
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_SLEEPING
expr_stmt|;
comment|/* 	 * Since we may be in a critical section from cpu_idle(), if 	 * an interrupt fires during that critical section we may have 	 * a pending preemption.  If the CPU halts, then that thread 	 * may not execute until a later interrupt awakens the CPU. 	 * To handle this race, check for a runnable thread after 	 * disabling interrupts and immediately return if one is 	 * found.  Also, we must absolutely guarentee that hlt is 	 * the next instruction after sti.  This ensures that any 	 * interrupt that fires after the call to disable_intr() will 	 * immediately awaken the CPU from hlt.  Finally, please note 	 * that on x86 this works fine because of interrupts enabled only 	 * after the instruction following sti takes place, while IF is set 	 * to 1 immediately, allowing hlt instruction to acknowledge the 	 * interrupt. 	 */
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_runnable
argument_list|()
condition|)
name|enable_intr
argument_list|()
expr_stmt|;
else|else
name|acpi_cpu_c1
argument_list|()
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpu_idle_mwait
parameter_list|(
name|sbintime_t
name|sbt
parameter_list|)
block|{
name|int
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|monitorbuf
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_MWAIT
expr_stmt|;
comment|/* See comments in cpu_idle_hlt(). */
name|disable_intr
argument_list|()
expr_stmt|;
if|if
condition|(
name|sched_runnable
argument_list|()
condition|)
block|{
name|enable_intr
argument_list|()
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
return|return;
block|}
name|cpu_monitor
argument_list|(
name|state
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|state
operator|==
name|STATE_MWAIT
condition|)
asm|__asm __volatile("sti; mwait" : : "a" (MWAIT_C1), "c" (0));
else|else
name|enable_intr
argument_list|()
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cpu_idle_spin
parameter_list|(
name|sbintime_t
name|sbt
parameter_list|)
block|{
name|int
modifier|*
name|state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|monitorbuf
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
comment|/* 	 * The sched_runnable() call is racy but as long as there is 	 * a loop missing it one time will have just a little impact if any  	 * (and it is much better than missing the check at all). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sched_runnable
argument_list|()
condition|)
return|return;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * C1E renders the local APIC timer dead, so we disable it by  * reading the Interrupt Pending Message register and clearing  * both C1eOnCmpHalt (bit 28) and SmiOnCmpHalt (bit 27).  *   * Reference:  *   "BIOS and Kernel Developer's Guide for AMD NPT Family 0Fh Processors"  *   #32559 revision 3.00+  */
end_comment

begin_define
define|#
directive|define
name|MSR_AMDK8_IPM
value|0xc0010055
end_define

begin_define
define|#
directive|define
name|AMDK8_SMIONCMPHALT
value|(1ULL<< 27)
end_define

begin_define
define|#
directive|define
name|AMDK8_C1EONCMPHALT
value|(1ULL<< 28)
end_define

begin_define
define|#
directive|define
name|AMDK8_CMPHALT
value|(AMDK8_SMIONCMPHALT | AMDK8_C1EONCMPHALT)
end_define

begin_function
name|void
name|cpu_probe_amdc1e
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Detect the presence of C1E capability mostly on latest 	 * dual-cores (or future) k8 family. 	 */
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_AMD
operator|&&
operator|(
name|cpu_id
operator|&
literal|0x00000f00
operator|)
operator|==
literal|0x00000f00
operator|&&
operator|(
name|cpu_id
operator|&
literal|0x0fff0000
operator|)
operator|>=
literal|0x00040000
condition|)
block|{
name|cpu_ident_amdc1e
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|cpu_idle_fn
function_decl|)
parameter_list|(
name|sbintime_t
parameter_list|)
init|=
name|cpu_idle_acpi
function_decl|;
end_function_decl

begin_function
name|void
name|cpu_idle
parameter_list|(
name|int
name|busy
parameter_list|)
block|{
name|uint64_t
name|msr
decl_stmt|;
name|sbintime_t
name|sbt
init|=
operator|-
literal|1
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"cpu_idle(%d) at %d"
argument_list|,
name|busy
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MP_WATCHDOG
name|ap_watchdog
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we are busy - try to use fast methods. */
if|if
condition|(
name|busy
condition|)
block|{
if|if
condition|(
operator|(
name|cpu_feature2
operator|&
name|CPUID2_MON
operator|)
operator|&&
name|idle_mwait
condition|)
block|{
name|cpu_idle_mwait
argument_list|(
name|busy
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* If we have time - switch timers into idle mode. */
if|if
condition|(
operator|!
name|busy
condition|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
name|sbt
operator|=
name|cpu_idleclock
argument_list|()
expr_stmt|;
block|}
comment|/* Apply AMD APIC timer C1E workaround. */
if|if
condition|(
name|cpu_ident_amdc1e
operator|&&
name|cpu_disable_c3_sleep
condition|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMDK8_IPM
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|&
name|AMDK8_CMPHALT
condition|)
name|wrmsr
argument_list|(
name|MSR_AMDK8_IPM
argument_list|,
name|msr
operator|&
operator|~
name|AMDK8_CMPHALT
argument_list|)
expr_stmt|;
block|}
comment|/* Call main idle method. */
name|cpu_idle_fn
argument_list|(
name|sbt
argument_list|)
expr_stmt|;
comment|/* Switch timers back into active mode. */
if|if
condition|(
operator|!
name|busy
condition|)
block|{
name|cpu_activeclock
argument_list|()
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|out
label|:
name|CTR2
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"cpu_idle(%d) at %d done"
argument_list|,
name|busy
argument_list|,
name|curcpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cpu_idle_wakeup
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|int
modifier|*
name|state
decl_stmt|;
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|state
operator|=
operator|(
name|int
operator|*
operator|)
name|pcpu
operator|->
name|pc_monitorbuf
expr_stmt|;
comment|/* 	 * This doesn't need to be atomic since missing the race will 	 * simply result in unnecessary IPIs. 	 */
if|if
condition|(
operator|*
name|state
operator|==
name|STATE_SLEEPING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|state
operator|==
name|STATE_MWAIT
condition|)
operator|*
name|state
operator|=
name|STATE_RUNNING
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ordered by speed/power consumption.  */
end_comment

begin_struct
struct|struct
block|{
name|void
modifier|*
name|id_fn
decl_stmt|;
name|char
modifier|*
name|id_name
decl_stmt|;
block|}
name|idle_tbl
index|[]
init|=
block|{
block|{
name|cpu_idle_spin
block|,
literal|"spin"
block|}
block|,
block|{
name|cpu_idle_mwait
block|,
literal|"mwait"
block|}
block|,
block|{
name|cpu_idle_hlt
block|,
literal|"hlt"
block|}
block|,
block|{
name|cpu_idle_acpi
block|,
literal|"acpi"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|idle_sysctl_available
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|avail
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|avail
operator|=
name|malloc
argument_list|(
literal|256
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|avail
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|,
literal|"mwait"
argument_list|)
operator|&&
operator|(
name|cpu_feature2
operator|&
name|CPUID2_MON
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|,
literal|"acpi"
argument_list|)
operator|==
literal|0
operator|&&
name|cpu_idle_hook
operator|==
name|NULL
condition|)
continue|continue;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"%s%s"
argument_list|,
name|p
operator|!=
name|avail
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|avail
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avail
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_available
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|idle_sysctl_available
argument_list|,
literal|"A"
argument_list|,
literal|"list of available idle functions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|idle_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
literal|"unknown"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_fn
operator|==
name|cpu_idle_fn
condition|)
block|{
name|p
operator|=
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
expr_stmt|;
break|break;
block|}
block|}
name|strncpy
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|,
literal|"mwait"
argument_list|)
operator|&&
operator|(
name|cpu_feature2
operator|&
name|CPUID2_MON
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|,
literal|"acpi"
argument_list|)
operator|==
literal|0
operator|&&
name|cpu_idle_hook
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_name
argument_list|,
name|buf
argument_list|)
condition|)
continue|continue;
name|cpu_idle_fn
operator|=
name|idle_tbl
index|[
name|i
index|]
operator|.
name|id_fn
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|idle
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|idle_sysctl
argument_list|,
literal|"A"
argument_list|,
literal|"currently selected idle function"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|panic_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|panic_on_nmi
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|panic_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Panic on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|nmi_is_broadcast
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|nmi_is_broadcast
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|nmi_is_broadcast
argument_list|,
literal|0
argument_list|,
literal|"Chipset NMI is broadcast"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KDB
end_ifdef

begin_decl_stmt
name|int
name|kdb_on_nmi
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|kdb_on_nmi
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|kdb_on_nmi
argument_list|,
literal|0
argument_list|,
literal|"Go to KDB on NMI"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_function
name|void
name|nmi_call_kdb
parameter_list|(
name|u_int
name|cpu
parameter_list|,
name|u_int
name|type
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
comment|/* machine/parity/power fail/"kitchen sink" faults */
if|if
condition|(
name|isa_nmi
argument_list|(
name|frame
operator|->
name|tf_err
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|KDB
comment|/* 		 * NMI can be hooked up to a pushbutton for debugging. 		 */
if|if
condition|(
name|kdb_on_nmi
condition|)
block|{
name|printf
argument_list|(
literal|"NMI/cpu%d ... going to debugger\n"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|kdb_trap
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* KDB */
block|}
elseif|else
if|if
condition|(
name|panic_on_nmi
condition|)
block|{
name|panic
argument_list|(
literal|"NMI indicates hardware failure"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|nmi_handle_intr
parameter_list|(
name|u_int
name|type
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEV_ISA
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|nmi_is_broadcast
condition|)
block|{
name|nmi_call_kdb_smp
argument_list|(
name|type
argument_list|,
name|frame
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|nmi_call_kdb
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|type
argument_list|,
name|frame
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

