begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Adrian Chadd  * Copyright (c) 2012 Spectra Logic Corporation  * Copyright (c) 2014 Bryan Venteicher  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/pvclock.h>
end_include

begin_comment
comment|/*  * Last time; this guarantees a monotonically increasing clock for when  * a stable TSC is not provided.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|uint64_t
name|pvclock_last_cycles
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pvclock_resume
parameter_list|(
name|void
parameter_list|)
block|{
name|atomic_store_rel_64
argument_list|(
operator|&
name|pvclock_last_cycles
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|pvclock_get_last_cycles
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|atomic_load_acq_64
argument_list|(
operator|&
name|pvclock_last_cycles
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scale a 64-bit delta by scaling and multiplying by a 32-bit fraction,  * yielding a 64-bit result.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|pvclock_scale_delta
parameter_list|(
name|uint64_t
name|delta
parameter_list|,
name|uint32_t
name|mul_frac
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|uint64_t
name|product
decl_stmt|;
if|if
condition|(
name|shift
operator|<
literal|0
condition|)
name|delta
operator|>>=
operator|-
name|shift
expr_stmt|;
else|else
name|delta
operator|<<=
name|shift
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
block|{
name|uint32_t
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
comment|/** 		 * For i386, the formula looks like: 		 * 		 *   lower = (mul_frac * (delta& UINT_MAX))>> 32 		 *   upper = mul_frac * (delta>> 32) 		 *   product = lower + upper 		 */
asm|__asm__ ( 			"mul  %5       ; " 			"mov  %4,%%eax ; " 			"mov  %%edx,%4 ; " 			"mul  %5       ; " 			"xor  %5,%5    ; " 			"add  %4,%%eax ; " 			"adc  %5,%%edx ; " 			: "=A" (product), "=r" (tmp1), "=r" (tmp2) 			: "a" ((uint32_t)delta), "1" ((uint32_t)(delta>> 32)), 			  "2" (mul_frac) );
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
block|{
name|unsigned
name|long
name|tmp
decl_stmt|;
asm|__asm__ ( 			"mulq %[mul_frac] ; shrd $32, %[hi], %[lo]" 			: [lo]"=a" (product), [hi]"=d" (tmp) 			: "0" (delta), [mul_frac]"rm"((uint64_t)mul_frac));
block|}
else|#
directive|else
error|#
directive|error
literal|"pvclock: unsupported x86 architecture?"
endif|#
directive|endif
return|return
operator|(
name|product
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|pvclock_get_nsec_offset
parameter_list|(
name|struct
name|pvclock_vcpu_time_info
modifier|*
name|ti
parameter_list|)
block|{
name|uint64_t
name|delta
decl_stmt|;
name|delta
operator|=
name|rdtsc
argument_list|()
operator|-
name|ti
operator|->
name|tsc_timestamp
expr_stmt|;
return|return
operator|(
name|pvclock_scale_delta
argument_list|(
name|delta
argument_list|,
name|ti
operator|->
name|tsc_to_system_mul
argument_list|,
name|ti
operator|->
name|tsc_shift
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pvclock_read_time_info
parameter_list|(
name|struct
name|pvclock_vcpu_time_info
modifier|*
name|ti
parameter_list|,
name|uint64_t
modifier|*
name|cycles
parameter_list|,
name|uint8_t
modifier|*
name|flags
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
do|do
block|{
name|version
operator|=
name|ti
operator|->
name|version
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
operator|*
name|cycles
operator|=
name|ti
operator|->
name|system_time
operator|+
name|pvclock_get_nsec_offset
argument_list|(
name|ti
argument_list|)
expr_stmt|;
operator|*
name|flags
operator|=
name|ti
operator|->
name|flags
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ti
operator|->
name|version
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|||
name|ti
operator|->
name|version
operator|!=
name|version
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|pvclock_read_wall_clock
parameter_list|(
name|struct
name|pvclock_wall_clock
modifier|*
name|wc
parameter_list|,
name|uint32_t
modifier|*
name|sec
parameter_list|,
name|uint32_t
modifier|*
name|nsec
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
do|do
block|{
name|version
operator|=
name|wc
operator|->
name|version
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
operator|*
name|sec
operator|=
name|wc
operator|->
name|sec
expr_stmt|;
operator|*
name|nsec
operator|=
name|wc
operator|->
name|nsec
expr_stmt|;
name|rmb
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|wc
operator|->
name|version
operator|&
literal|1
operator|)
operator|!=
literal|0
operator|||
name|wc
operator|->
name|version
operator|!=
name|version
condition|)
do|;
block|}
end_function

begin_function
name|uint64_t
name|pvclock_get_timecount
parameter_list|(
name|struct
name|pvclock_vcpu_time_info
modifier|*
name|ti
parameter_list|)
block|{
name|uint64_t
name|now
decl_stmt|,
name|last
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|pvclock_read_time_info
argument_list|(
name|ti
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PVCLOCK_FLAG_TSC_STABLE
condition|)
return|return
operator|(
name|now
operator|)
return|;
comment|/* 	 * Enforce a monotonically increasing clock time across all VCPUs. 	 * If our time is too old, use the last time and return. Otherwise, 	 * try to update the last time. 	 */
do|do
block|{
name|last
operator|=
name|atomic_load_acq_64
argument_list|(
operator|&
name|pvclock_last_cycles
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|>
name|now
condition|)
return|return
operator|(
name|last
operator|)
return|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_64
argument_list|(
operator|&
name|pvclock_last_cycles
argument_list|,
name|last
argument_list|,
name|now
argument_list|)
condition|)
do|;
return|return
operator|(
name|now
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pvclock_get_wallclock
parameter_list|(
name|struct
name|pvclock_wall_clock
modifier|*
name|wc
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|uint32_t
name|sec
decl_stmt|,
name|nsec
decl_stmt|;
name|pvclock_read_wall_clock
argument_list|(
name|wc
argument_list|,
operator|&
name|sec
argument_list|,
operator|&
name|nsec
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|=
name|sec
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
name|nsec
expr_stmt|;
block|}
end_function

end_unit

