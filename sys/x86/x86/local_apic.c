begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 John Baldwin<jhb@FreeBSD.org>  * Copyright (c) 1996, by Steve Passe  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the developer may NOT be used to endorse or promote products  *    derived from this software without specific prior written permission.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Local APIC support on Pentium and later processors.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_atpic.h"
end_include

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeet.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<x86/mca.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/init.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|SDT_APIC
value|SDT_SYSIGT
end_define

begin_define
define|#
directive|define
name|SDT_APICT
value|SDT_SYSIGT
end_define

begin_define
define|#
directive|define
name|GSEL_APIC
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SDT_APIC
value|SDT_SYS386IGT
end_define

begin_define
define|#
directive|define
name|SDT_APICT
value|SDT_SYS386TGT
end_define

begin_define
define|#
directive|define
name|GSEL_APIC
value|GSEL(GCODE_SEL, SEL_KPL)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INTEL_SEOI
value|1
end_define

begin_define
define|#
directive|define
name|AMD_SEOI
value|2
end_define

begin_comment
comment|/* Sanity checks on IDT vectors. */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
operator|==
name|APIC_TIMER_INT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_TIMER_INT
operator|<
name|APIC_LOCAL_INTS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|APIC_LOCAL_INTS
operator|==
literal|240
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|IPI_STOP
operator|<
name|APIC_SPURIOUS_INT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Magic IRQ values for the timer and syscalls. */
end_comment

begin_define
define|#
directive|define
name|IRQ_TIMER
value|(NUM_IO_INTS + 1)
end_define

begin_define
define|#
directive|define
name|IRQ_SYSCALL
value|(NUM_IO_INTS + 2)
end_define

begin_define
define|#
directive|define
name|IRQ_DTRACE_RET
value|(NUM_IO_INTS + 3)
end_define

begin_define
define|#
directive|define
name|IRQ_EVTCHN
value|(NUM_IO_INTS + 4)
end_define

begin_enum
enum|enum
name|lat_timer_mode
block|{
name|LAT_MODE_UNDEF
init|=
literal|0
block|,
name|LAT_MODE_PERIODIC
init|=
literal|1
block|,
name|LAT_MODE_ONESHOT
init|=
literal|2
block|,
name|LAT_MODE_DEADLINE
init|=
literal|3
block|, }
enum|;
end_enum

begin_comment
comment|/*  * Support for local APICs.  Local APICs manage interrupts on each  * individual processor as opposed to I/O APICs which receive interrupts  * from I/O devices and then forward them on to the local APICs.  *  * Local APICs can also send interrupts to each other thus providing the  * mechanism for IPIs.  */
end_comment

begin_struct
struct|struct
name|lvt
block|{
name|u_int
name|lvt_edgetrigger
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_activehi
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_masked
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_active
range|:
literal|1
decl_stmt|;
name|u_int
name|lvt_mode
range|:
literal|16
decl_stmt|;
name|u_int
name|lvt_vector
range|:
literal|8
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|lapic
block|{
name|struct
name|lvt
name|la_lvts
index|[
name|APIC_LVT_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|lvt
name|la_elvts
index|[
name|APIC_ELVT_MAX
operator|+
literal|1
index|]
decl_stmt|;
empty_stmt|;
name|u_int
name|la_id
range|:
literal|8
decl_stmt|;
name|u_int
name|la_cluster
range|:
literal|4
decl_stmt|;
name|u_int
name|la_cluster_id
range|:
literal|2
decl_stmt|;
name|u_int
name|la_present
range|:
literal|1
decl_stmt|;
name|u_long
modifier|*
name|la_timer_count
decl_stmt|;
name|uint64_t
name|la_timer_period
decl_stmt|;
name|enum
name|lat_timer_mode
name|la_timer_mode
decl_stmt|;
name|uint32_t
name|lvt_timer_base
decl_stmt|;
name|uint32_t
name|lvt_timer_last
decl_stmt|;
comment|/* Include IDT_SYSCALL to make indexing easier. */
name|int
name|la_ioint_irqs
index|[
name|APIC_NUM_IOINTS
operator|+
literal|1
index|]
decl_stmt|;
block|}
decl|static
name|lapics
index|[
name|MAX_APIC_ID
operator|+
literal|1
index|]
struct|;
end_struct

begin_comment
comment|/* Global defaults for local APIC LVT entries. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lvt
name|lvts
index|[
name|APIC_LVT_MAX
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_EXTINT
block|,
literal|0
block|}
block|,
comment|/* LINT0: masked ExtINT */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|APIC_LVT_DM_NMI
block|,
literal|0
block|}
block|,
comment|/* LINT1: NMI */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_TIMER_INT
block|}
block|,
comment|/* Timer */
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_ERROR_INT
block|}
block|,
comment|/* Error */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_NMI
block|,
literal|0
block|}
block|,
comment|/* PMC */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_THERMAL_INT
block|}
block|,
comment|/* Thermal */
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_CMC_INT
block|}
block|,
comment|/* CMCI */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global defaults for AMD local APIC ELVT entries. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lvt
name|elvts
index|[
name|APIC_ELVT_MAX
operator|+
literal|1
index|]
init|=
block|{
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|APIC_LVT_DM_FIXED
block|,
name|APIC_CMC_INT
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
name|APIC_LVT_DM_FIXED
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|inthand_t
modifier|*
name|ioint_handlers
index|[]
init|=
block|{
name|NULL
block|,
comment|/* 0 - 31 */
name|IDTVEC
argument_list|(
name|apic_isr1
argument_list|)
block|,
comment|/* 32 - 63 */
name|IDTVEC
argument_list|(
name|apic_isr2
argument_list|)
block|,
comment|/* 64 - 95 */
name|IDTVEC
argument_list|(
name|apic_isr3
argument_list|)
block|,
comment|/* 96 - 127 */
name|IDTVEC
argument_list|(
name|apic_isr4
argument_list|)
block|,
comment|/* 128 - 159 */
name|IDTVEC
argument_list|(
name|apic_isr5
argument_list|)
block|,
comment|/* 160 - 191 */
name|IDTVEC
argument_list|(
name|apic_isr6
argument_list|)
block|,
comment|/* 192 - 223 */
name|IDTVEC
argument_list|(
name|apic_isr7
argument_list|)
block|,
comment|/* 224 - 255 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|lapic_timer_divisors
index|[]
init|=
block|{
name|APIC_TDCR_1
block|,
name|APIC_TDCR_2
block|,
name|APIC_TDCR_4
block|,
name|APIC_TDCR_8
block|,
name|APIC_TDCR_16
block|,
name|APIC_TDCR_32
block|,
name|APIC_TDCR_64
block|,
name|APIC_TDCR_128
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|inthand_t
name|IDTVEC
parameter_list|(
name|rsvd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|volatile
name|char
modifier|*
name|lapic_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|lapic_paddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x2apic_mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lapic_eoi_suppression
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lapic_timer_tsc_deadline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|lapic_timer_divisor
decl_stmt|,
name|count_freq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|eventtimer
name|lapic_et
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|uint64_t
name|lapic_ipi_wait_mult
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_comment
comment|/* IPI vector used for VMM VCPU notifications. */
end_comment

begin_decl_stmt
name|int
name|vmm_ipinum
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|apic
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"APIC options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_apic
argument_list|,
name|OID_AUTO
argument_list|,
name|x2apic_mode
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|x2apic_mode
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_apic
argument_list|,
name|OID_AUTO
argument_list|,
name|eoi_suppression
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lapic_eoi_suppression
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_apic
argument_list|,
name|OID_AUTO
argument_list|,
name|timer_tsc_deadline
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|lapic_timer_tsc_deadline
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|lapic_read32
parameter_list|(
name|enum
name|LAPIC_REGISTERS
name|reg
parameter_list|)
block|{
name|uint32_t
name|res
decl_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|res
operator|=
name|rdmsr32
argument_list|(
name|MSR_APIC_000
operator|+
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|lapic_map
operator|+
name|reg
operator|*
name|LAPIC_MEM_MUL
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_write32
parameter_list|(
name|enum
name|LAPIC_REGISTERS
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|mfence
argument_list|()
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_APIC_000
operator|+
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|lapic_map
operator|+
name|reg
operator|*
name|LAPIC_MEM_MUL
operator|)
operator|=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_write32_nofence
parameter_list|(
name|enum
name|LAPIC_REGISTERS
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|wrmsr
argument_list|(
name|MSR_APIC_000
operator|+
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
operator|(
name|lapic_map
operator|+
name|reg
operator|*
name|LAPIC_MEM_MUL
operator|)
operator|=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|uint64_t
name|lapic_read_icr
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|v
decl_stmt|;
name|uint32_t
name|vhi
decl_stmt|,
name|vlo
decl_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|v
operator|=
name|rdmsr
argument_list|(
name|MSR_APIC_000
operator|+
name|LAPIC_ICR_LO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vhi
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_ICR_HI
argument_list|)
expr_stmt|;
name|vlo
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_ICR_LO
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|vhi
operator|<<
literal|32
operator|)
operator||
name|vlo
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|lapic_read_icr_lo
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|lapic_read32
argument_list|(
name|LAPIC_ICR_LO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_write_icr
parameter_list|(
name|uint32_t
name|vhi
parameter_list|,
name|uint32_t
name|vlo
parameter_list|)
block|{
name|uint64_t
name|v
decl_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|v
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|vhi
operator|<<
literal|32
operator|)
operator||
name|vlo
expr_stmt|;
name|mfence
argument_list|()
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_APIC_000
operator|+
name|LAPIC_ICR_LO
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lapic_write32
argument_list|(
name|LAPIC_ICR_HI
argument_list|,
name|vhi
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_ICR_LO
argument_list|,
name|vlo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
specifier|static
name|void
name|native_lapic_enable_x2apic
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|apic_base
decl_stmt|;
name|apic_base
operator|=
name|rdmsr
argument_list|(
name|MSR_APICBASE
argument_list|)
expr_stmt|;
name|apic_base
operator||=
name|APICBASE_X2APIC
operator||
name|APICBASE_ENABLED
expr_stmt|;
name|wrmsr
argument_list|(
name|MSR_APICBASE
argument_list|,
name|apic_base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|native_lapic_is_x2apic
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|apic_base
decl_stmt|;
name|apic_base
operator|=
name|rdmsr
argument_list|(
name|MSR_APICBASE
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|apic_base
operator|&
operator|(
name|APICBASE_X2APIC
operator||
name|APICBASE_ENABLED
operator|)
operator|)
operator|==
operator|(
name|APICBASE_X2APIC
operator||
name|APICBASE_ENABLED
operator|)
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|lapic_enable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|,
name|bool
name|suspend_cancelled
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_oneshot
parameter_list|(
name|struct
name|lapic
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_oneshot_nointr
parameter_list|(
name|struct
name|lapic
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_periodic
parameter_list|(
name|struct
name|lapic
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_deadline
parameter_list|(
name|struct
name|lapic
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_stop
parameter_list|(
name|struct
name|lapic
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_timer_set_divisor
parameter_list|(
name|u_int
name|divisor
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|lvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lapic_et_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|sbintime_t
name|first
parameter_list|,
name|sbintime_t
name|period
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lapic_et_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|apic_idt_to_irq
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lapic_set_tpr
parameter_list|(
name|u_int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pic
name|lapic_pic
init|=
block|{
operator|.
name|pic_resume
operator|=
name|lapic_resume
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations for apic_ops */
end_comment

begin_function_decl
specifier|static
name|void
name|native_lapic_create
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|int
name|boot_cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_init
parameter_list|(
name|vm_paddr_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_xapic_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_setup
parameter_list|(
name|int
name|boot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_disable
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_id
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_intr_pending
parameter_list|(
name|u_int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|native_apic_cpuid
parameter_list|(
name|u_int
name|apic_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|native_apic_alloc_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|native_apic_alloc_vectors
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
modifier|*
name|irqs
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|align
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_apic_disable_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_apic_enable_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_apic_free_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|u_int
name|irq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_set_logical_id
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|cluster
parameter_list|,
name|u_int
name|cluster_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_enable_pmc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_disable_pmc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_reenable_pmc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_enable_cmc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_enable_mca_elvt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_set_lvt_mask
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|lvt
parameter_list|,
name|u_char
name|masked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_set_lvt_mode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|lvt
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_set_lvt_polarity
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|lvt
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_set_lvt_triggermode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|lvt
parameter_list|,
name|enum
name|intr_trigger
name|trigger
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|native_lapic_ipi_raw
parameter_list|(
name|register_t
name|icrlo
parameter_list|,
name|u_int
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_ipi_vectored
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|int
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|native_lapic_ipi_wait
parameter_list|(
name|int
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function_decl
specifier|static
name|int
name|native_lapic_ipi_alloc
parameter_list|(
name|inthand_t
modifier|*
name|ipifunc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|native_lapic_ipi_free
parameter_list|(
name|int
name|vector
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|apic_ops
name|apic_ops
init|=
block|{
operator|.
name|create
operator|=
name|native_lapic_create
block|,
operator|.
name|init
operator|=
name|native_lapic_init
block|,
operator|.
name|xapic_mode
operator|=
name|native_lapic_xapic_mode
block|,
operator|.
name|is_x2apic
operator|=
name|native_lapic_is_x2apic
block|,
operator|.
name|setup
operator|=
name|native_lapic_setup
block|,
operator|.
name|dump
operator|=
name|native_lapic_dump
block|,
operator|.
name|disable
operator|=
name|native_lapic_disable
block|,
operator|.
name|eoi
operator|=
name|native_lapic_eoi
block|,
operator|.
name|id
operator|=
name|native_lapic_id
block|,
operator|.
name|intr_pending
operator|=
name|native_lapic_intr_pending
block|,
operator|.
name|set_logical_id
operator|=
name|native_lapic_set_logical_id
block|,
operator|.
name|cpuid
operator|=
name|native_apic_cpuid
block|,
operator|.
name|alloc_vector
operator|=
name|native_apic_alloc_vector
block|,
operator|.
name|alloc_vectors
operator|=
name|native_apic_alloc_vectors
block|,
operator|.
name|enable_vector
operator|=
name|native_apic_enable_vector
block|,
operator|.
name|disable_vector
operator|=
name|native_apic_disable_vector
block|,
operator|.
name|free_vector
operator|=
name|native_apic_free_vector
block|,
operator|.
name|enable_pmc
operator|=
name|native_lapic_enable_pmc
block|,
operator|.
name|disable_pmc
operator|=
name|native_lapic_disable_pmc
block|,
operator|.
name|reenable_pmc
operator|=
name|native_lapic_reenable_pmc
block|,
operator|.
name|enable_cmc
operator|=
name|native_lapic_enable_cmc
block|,
operator|.
name|enable_mca_elvt
operator|=
name|native_lapic_enable_mca_elvt
block|,
ifdef|#
directive|ifdef
name|SMP
operator|.
name|ipi_raw
operator|=
name|native_lapic_ipi_raw
block|,
operator|.
name|ipi_vectored
operator|=
name|native_lapic_ipi_vectored
block|,
operator|.
name|ipi_wait
operator|=
name|native_lapic_ipi_wait
block|,
endif|#
directive|endif
operator|.
name|ipi_alloc
operator|=
name|native_lapic_ipi_alloc
block|,
operator|.
name|ipi_free
operator|=
name|native_lapic_ipi_free
block|,
operator|.
name|set_lvt_mask
operator|=
name|native_lapic_set_lvt_mask
block|,
operator|.
name|set_lvt_mode
operator|=
name|native_lapic_set_lvt_mode
block|,
operator|.
name|set_lvt_polarity
operator|=
name|native_lapic_set_lvt_polarity
block|,
operator|.
name|set_lvt_triggermode
operator|=
name|native_lapic_set_lvt_triggermode
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|lvt_mode_impl
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|struct
name|lvt
modifier|*
name|lvt
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|value
operator|&=
operator|~
operator|(
name|APIC_LVT_M
operator||
name|APIC_LVT_TM
operator||
name|APIC_LVT_IIPP
operator||
name|APIC_LVT_DM
operator||
name|APIC_LVT_VECTOR
operator|)
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_edgetrigger
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_TM
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_activehi
operator|==
literal|0
condition|)
name|value
operator||=
name|APIC_LVT_IIPP_INTALO
expr_stmt|;
if|if
condition|(
name|lvt
operator|->
name|lvt_masked
condition|)
name|value
operator||=
name|APIC_LVT_M
expr_stmt|;
name|value
operator||=
name|lvt
operator|->
name|lvt_mode
expr_stmt|;
switch|switch
condition|(
name|lvt
operator|->
name|lvt_mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
if|if
condition|(
operator|!
name|lvt
operator|->
name|lvt_edgetrigger
operator|&&
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"lapic%u: Forcing LINT%u to edge trigger\n"
argument_list|,
name|la
operator|->
name|la_id
argument_list|,
name|pin
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVT_TM
expr_stmt|;
block|}
comment|/* Use a vector of 0. */
break|break;
case|case
name|APIC_LVT_DM_FIXED
case|:
name|value
operator||=
name|lvt
operator|->
name|lvt_vector
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bad APIC LVT delivery mode: %#x\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|lvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
name|KASSERT
argument_list|(
name|pin
operator|<=
name|APIC_LVT_MAX
argument_list|,
operator|(
literal|"%s: pin %u out of range"
operator|,
name|__func__
operator|,
name|pin
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
condition|)
name|lvt
operator|=
operator|&
name|la
operator|->
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
else|else
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
return|return
operator|(
name|lvt_mode_impl
argument_list|(
name|la
argument_list|,
name|lvt
argument_list|,
name|pin
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|elvt_mode
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|uint32_t
name|value
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|elvt
decl_stmt|;
name|KASSERT
argument_list|(
name|idx
operator|<=
name|APIC_ELVT_MAX
argument_list|,
operator|(
literal|"%s: idx %u out of range"
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|elvt
operator|=
operator|&
name|la
operator|->
name|la_elvts
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|elvt
operator|->
name|lvt_active
argument_list|,
operator|(
literal|"%s: ELVT%u is not active"
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|elvt
operator|->
name|lvt_edgetrigger
argument_list|,
operator|(
literal|"%s: ELVT%u is not edge triggered"
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|elvt
operator|->
name|lvt_activehi
argument_list|,
operator|(
literal|"%s: ELVT%u is not active high"
operator|,
name|__func__
operator|,
name|idx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|lvt_mode_impl
argument_list|(
name|la
argument_list|,
name|elvt
argument_list|,
name|idx
argument_list|,
name|value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|amd_read_ext_features
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
if|if
condition|(
name|cpu_vendor_id
operator|!=
name|CPU_VENDOR_AMD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|version
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|version
operator|&
name|APIC_VER_AMD_EXT_SPACE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|lapic_read32
argument_list|(
name|LAPIC_EXT_FEATURES
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|amd_read_elvt_count
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|extf
decl_stmt|;
name|uint32_t
name|count
decl_stmt|;
name|extf
operator|=
name|amd_read_ext_features
argument_list|()
expr_stmt|;
name|count
operator|=
operator|(
name|extf
operator|&
name|APIC_EXTF_ELVT_MASK
operator|)
operator|>>
name|APIC_EXTF_ELVT_SHIFT
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|APIC_ELVT_MAX
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the local APIC and setup necessary interrupt vectors.  */
end_comment

begin_function
specifier|static
name|void
name|native_lapic_init
parameter_list|(
name|vm_paddr_t
name|addr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|uint64_t
name|r
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|rx
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|extf
decl_stmt|,
name|ver
decl_stmt|;
name|u_int
name|regs
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|arat
decl_stmt|,
name|seoi_enable
decl_stmt|;
comment|/* 	 * Enable x2APIC mode if possible. Map the local APIC 	 * registers page. 	 * 	 * Keep the LAPIC registers page mapped uncached for x2APIC 	 * mode too, to have direct map page attribute set to 	 * uncached.  This is needed to work around CPU errata present 	 * on all Intel processors. 	 */
name|KASSERT
argument_list|(
name|trunc_page
argument_list|(
name|addr
argument_list|)
operator|==
name|addr
argument_list|,
operator|(
literal|"local APIC not aligned on a page boundary"
operator|)
argument_list|)
expr_stmt|;
name|lapic_paddr
operator|=
name|addr
expr_stmt|;
name|lapic_map
operator|=
name|pmap_mapdev
argument_list|(
name|addr
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|native_lapic_enable_x2apic
argument_list|()
expr_stmt|;
name|lapic_map
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Setup the spurious interrupt handler. */
name|setidt
argument_list|(
name|APIC_SPURIOUS_INT
argument_list|,
name|IDTVEC
argument_list|(
name|spuriousint
argument_list|)
argument_list|,
name|SDT_APIC
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
comment|/* Perform basic initialization of the BSP's local APIC. */
name|lapic_enable
argument_list|()
expr_stmt|;
comment|/* Set BSP's per-CPU local APIC ID. */
name|PCPU_SET
argument_list|(
name|apic_id
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Local APIC timer interrupt. */
name|setidt
argument_list|(
name|APIC_TIMER_INT
argument_list|,
name|IDTVEC
argument_list|(
name|timerint
argument_list|)
argument_list|,
name|SDT_APIC
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
comment|/* Local APIC error interrupt. */
name|setidt
argument_list|(
name|APIC_ERROR_INT
argument_list|,
name|IDTVEC
argument_list|(
name|errorint
argument_list|)
argument_list|,
name|SDT_APIC
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
comment|/* XXX: Thermal interrupt */
comment|/* Local APIC CMCI. */
name|setidt
argument_list|(
name|APIC_CMC_INT
argument_list|,
name|IDTVEC
argument_list|(
name|cmcint
argument_list|)
argument_list|,
name|SDT_APICT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|resource_int_value
argument_list|(
literal|"apic"
argument_list|,
literal|0
argument_list|,
literal|"clock"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|0
operator|||
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|arat
operator|=
literal|0
expr_stmt|;
comment|/* Intel CPUID 0x06 EAX[2] set if APIC timer runs in C3. */
if|if
condition|(
name|cpu_vendor_id
operator|==
name|CPU_VENDOR_INTEL
operator|&&
name|cpu_high
operator|>=
literal|6
condition|)
block|{
name|do_cpuid
argument_list|(
literal|0x06
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regs
index|[
literal|0
index|]
operator|&
name|CPUTPM1_ARAT
operator|)
operator|!=
literal|0
condition|)
name|arat
operator|=
literal|1
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|lapic_et
argument_list|,
sizeof|sizeof
argument_list|(
name|lapic_et
argument_list|)
argument_list|)
expr_stmt|;
name|lapic_et
operator|.
name|et_name
operator|=
literal|"LAPIC"
expr_stmt|;
name|lapic_et
operator|.
name|et_flags
operator|=
name|ET_FLAGS_PERIODIC
operator||
name|ET_FLAGS_ONESHOT
operator||
name|ET_FLAGS_PERCPU
expr_stmt|;
name|lapic_et
operator|.
name|et_quality
operator|=
literal|600
expr_stmt|;
if|if
condition|(
operator|!
name|arat
condition|)
block|{
name|lapic_et
operator|.
name|et_flags
operator||=
name|ET_FLAGS_C3STOP
expr_stmt|;
name|lapic_et
operator|.
name|et_quality
operator|=
literal|100
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cpu_feature
operator|&
name|CPUID_TSC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|cpu_feature2
operator|&
name|CPUID2_TSCDLT
operator|)
operator|!=
literal|0
operator|&&
name|tsc_is_invariant
operator|&&
name|tsc_freq
operator|!=
literal|0
condition|)
block|{
name|lapic_timer_tsc_deadline
operator|=
literal|1
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.lapic_tsc_deadline"
argument_list|,
operator|&
name|lapic_timer_tsc_deadline
argument_list|)
expr_stmt|;
block|}
name|lapic_et
operator|.
name|et_frequency
operator|=
literal|0
expr_stmt|;
comment|/* We don't know frequency yet, so trying to guess. */
name|lapic_et
operator|.
name|et_min_period
operator|=
literal|0x00001000LL
expr_stmt|;
name|lapic_et
operator|.
name|et_max_period
operator|=
name|SBT_1S
expr_stmt|;
name|lapic_et
operator|.
name|et_start
operator|=
name|lapic_et_start
expr_stmt|;
name|lapic_et
operator|.
name|et_stop
operator|=
name|lapic_et_stop
expr_stmt|;
name|lapic_et
operator|.
name|et_priv
operator|=
name|NULL
expr_stmt|;
name|et_register
argument_list|(
operator|&
name|lapic_et
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set lapic_eoi_suppression after lapic_enable(), to not 	 * enable suppression in the hardware prematurely.  Note that 	 * we by default enable suppression even when system only has 	 * one IO-APIC, since EOI is broadcasted to all APIC agents, 	 * including CPUs, otherwise. 	 * 	 * It seems that at least some KVM versions report 	 * EOI_SUPPRESSION bit, but auto-EOI does not work. 	 */
name|ver
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ver
operator|&
name|APIC_VER_EOI_SUPPRESSION
operator|)
operator|!=
literal|0
condition|)
block|{
name|lapic_eoi_suppression
operator|=
name|INTEL_SEOI
expr_stmt|;
block|}
else|else
block|{
name|extf
operator|=
name|amd_read_ext_features
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|extf
operator|&
name|APIC_EXTF_SEIO_CAP
operator|)
operator|!=
literal|0
condition|)
name|lapic_eoi_suppression
operator|=
name|AMD_SEOI
expr_stmt|;
block|}
if|if
condition|(
name|lapic_eoi_suppression
operator|!=
literal|0
condition|)
block|{
name|seoi_enable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vm_guest
operator|==
name|VM_GUEST_KVM
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"KVM -- disabling lapic eoi suppression\n"
argument_list|)
expr_stmt|;
name|seoi_enable
operator|=
literal|0
expr_stmt|;
block|}
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.lapic_eoi_suppression"
argument_list|,
operator|&
name|seoi_enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|seoi_enable
operator|==
literal|0
condition|)
name|lapic_eoi_suppression
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lapic_eoi_suppression
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"LAPIC specific EOI enabled\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
define|#
directive|define
name|LOOPS
value|100000
comment|/* 	 * Calibrate the busy loop waiting for IPI ack in xAPIC mode. 	 * lapic_ipi_wait_mult contains the number of iterations which 	 * approximately delay execution for 1 microsecond (the 	 * argument to native_lapic_ipi_wait() is in microseconds). 	 * 	 * We assume that TSC is present and already measured. 	 * Possible TSC frequency jumps are irrelevant to the 	 * calibration loop below, the CPU clock management code is 	 * not yet started, and we do not enter sleep states. 	 */
name|KASSERT
argument_list|(
operator|(
name|cpu_feature
operator|&
name|CPUID_TSC
operator|)
operator|!=
literal|0
operator|&&
name|tsc_freq
operator|!=
literal|0
argument_list|,
operator|(
literal|"TSC not initialized"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x2apic_mode
condition|)
block|{
name|r
operator|=
name|rdtsc
argument_list|()
expr_stmt|;
for|for
control|(
name|rx
operator|=
literal|0
init|;
name|rx
operator|<
name|LOOPS
condition|;
name|rx
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|lapic_read_icr_lo
argument_list|()
expr_stmt|;
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
name|r
operator|=
name|rdtsc
argument_list|()
operator|-
name|r
expr_stmt|;
name|r1
operator|=
name|tsc_freq
operator|*
name|LOOPS
expr_stmt|;
name|r2
operator|=
name|r
operator|*
literal|1000000
expr_stmt|;
name|lapic_ipi_wait_mult
operator|=
name|r1
operator|>=
name|r2
condition|?
name|r1
operator|/
name|r2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"LAPIC: ipi_wait() us multiplier %ju (r %ju "
literal|"tsc %ju)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lapic_ipi_wait_mult
argument_list|,
operator|(
name|uintmax_t
operator|)
name|r
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsc_freq
argument_list|)
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|LOOPS
endif|#
directive|endif
comment|/* SMP */
block|}
end_function

begin_comment
comment|/*  * Create a local APIC instance.  */
end_comment

begin_function
specifier|static
name|void
name|native_lapic_create
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|int
name|boot_cpu
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|apic_id
operator|>
name|MAX_APIC_ID
condition|)
block|{
name|printf
argument_list|(
literal|"APIC: Ignoring local APIC with ID %d\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot_cpu
condition|)
name|panic
argument_list|(
literal|"Can't ignore BSP"
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|!
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"duplicate local APIC %u"
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Assume no local LVT overrides and a cluster of 0 and 	 * intra-cluster ID of 0. 	 */
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_id
operator|=
name|apic_id
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|APIC_LVT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|=
name|lvts
index|[
name|i
index|]
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|i
index|]
operator|.
name|lvt_active
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|APIC_ELVT_MAX
condition|;
name|i
operator|++
control|)
block|{
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_elvts
index|[
name|i
index|]
operator|=
name|elvts
index|[
name|i
index|]
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_elvts
index|[
name|i
index|]
operator|.
name|lvt_active
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|APIC_NUM_IOINTS
condition|;
name|i
operator|++
control|)
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|IDT_SYSCALL
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_SYSCALL
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|APIC_TIMER_INT
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_TIMER
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|IDT_DTRACE_RET
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_DTRACE_RET
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XENHVM
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|IDT_EVTCHN
operator|-
name|APIC_IO_INTS
index|]
operator|=
name|IRQ_EVTCHN
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SMP
name|cpu_add
argument_list|(
name|apic_id
argument_list|,
name|boot_cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Dump contents of local APIC registers  */
end_comment

begin_function
specifier|static
name|void
name|native_lapic_dump
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
name|uint32_t
name|maxlvt
decl_stmt|;
name|uint32_t
name|extf
decl_stmt|;
name|int
name|elvt_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|version
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
expr_stmt|;
name|maxlvt
operator|=
operator|(
name|version
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
name|printf
argument_list|(
literal|"cpu%d %s:\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     ID: 0x%08x   VER: 0x%08x LDR: 0x%08x DFR: 0x%08x"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_ID
argument_list|)
argument_list|,
name|version
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LDR
argument_list|)
argument_list|,
name|x2apic_mode
condition|?
literal|0
else|:
name|lapic_read32
argument_list|(
name|LAPIC_DFR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cpu_feature2
operator|&
name|CPUID2_X2APIC
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|" x2APIC: %d"
argument_list|,
name|x2apic_mode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n  lint0: 0x%08x lint1: 0x%08x TPR: 0x%08x SVR: 0x%08x\n"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_LINT0
argument_list|)
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_LINT1
argument_list|)
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_TPR
argument_list|)
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_SVR
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  timer: 0x%08x therm: 0x%08x err: 0x%08x"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|)
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_THERMAL
argument_list|)
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_ERROR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlvt
operator|>=
name|APIC_LVT_PMC
condition|)
name|printf
argument_list|(
literal|" pmc: 0x%08x"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxlvt
operator|>=
name|APIC_LVT_CMCI
condition|)
name|printf
argument_list|(
literal|"   cmci: 0x%08x\n"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_CMCI
argument_list|)
argument_list|)
expr_stmt|;
name|extf
operator|=
name|amd_read_ext_features
argument_list|()
expr_stmt|;
if|if
condition|(
name|extf
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"   AMD ext features: 0x%08x\n"
argument_list|,
name|extf
argument_list|)
expr_stmt|;
name|extf
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_EXT_CTRL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    AMD ext control: 0x%08x\n"
argument_list|,
name|extf
argument_list|)
expr_stmt|;
name|elvt_count
operator|=
name|amd_read_elvt_count
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elvt_count
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"          AMD elvt%d: 0x%08x\n"
argument_list|,
name|i
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_EXT_LVT0
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_xapic_mode
parameter_list|(
name|void
parameter_list|)
block|{
name|register_t
name|saveintr
decl_stmt|;
name|saveintr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
name|native_lapic_enable_x2apic
argument_list|()
expr_stmt|;
name|intr_restore
argument_list|(
name|saveintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_setup
parameter_list|(
name|int
name|boot
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|uint32_t
name|version
decl_stmt|;
name|uint32_t
name|maxlvt
decl_stmt|;
name|register_t
name|saveintr
decl_stmt|;
name|char
name|buf
index|[
name|MAXCOMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|elvt_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|saveintr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|lapic_id
argument_list|()
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|la
operator|->
name|la_present
argument_list|,
operator|(
literal|"missing APIC structure"
operator|)
argument_list|)
expr_stmt|;
name|version
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
expr_stmt|;
name|maxlvt
operator|=
operator|(
name|version
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
comment|/* Initialize the TPR to allow all interrupts. */
name|lapic_set_tpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup spurious vector and enable the local APIC. */
name|lapic_enable
argument_list|()
expr_stmt|;
comment|/* Program LINT[01] LVT entries. */
name|lapic_write32
argument_list|(
name|LAPIC_LVT_LINT0
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_LINT0
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_LINT0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_LINT1
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_LINT1
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_LINT1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Program the PMC LVT entry if present. */
if|if
condition|(
name|maxlvt
operator|>=
name|APIC_LVT_PMC
condition|)
block|{
name|lapic_write32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_PMC
argument_list|,
name|LAPIC_LVT_PCINT
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Program timer LVT and setup handler. */
name|la
operator|->
name|lvt_timer_base
operator|=
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_TIMER
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|)
argument_list|)
expr_stmt|;
name|la
operator|->
name|lvt_timer_last
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|la
operator|->
name|lvt_timer_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|boot
condition|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"cpu%d:timer"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
name|intrcnt_add
argument_list|(
name|buf
argument_list|,
operator|&
name|la
operator|->
name|la_timer_count
argument_list|)
expr_stmt|;
block|}
comment|/* Setup the timer if configured. */
if|if
condition|(
name|la
operator|->
name|la_timer_mode
operator|!=
name|LAT_MODE_UNDEF
condition|)
block|{
name|KASSERT
argument_list|(
name|la
operator|->
name|la_timer_period
operator|!=
literal|0
argument_list|,
operator|(
literal|"lapic%u: zero divisor"
operator|,
name|lapic_id
argument_list|()
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|la
operator|->
name|la_timer_mode
condition|)
block|{
case|case
name|LAT_MODE_PERIODIC
case|:
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|lapic_timer_periodic
argument_list|(
name|la
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAT_MODE_ONESHOT
case|:
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|lapic_timer_oneshot
argument_list|(
name|la
argument_list|)
expr_stmt|;
break|break;
case|case
name|LAT_MODE_DEADLINE
case|:
name|lapic_timer_deadline
argument_list|(
name|la
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"corrupted la_timer_mode %p %d"
argument_list|,
name|la
argument_list|,
name|la
operator|->
name|la_timer_mode
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Program error LVT and clear any existing errors. */
name|lapic_write32
argument_list|(
name|LAPIC_LVT_ERROR
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_ERROR
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_ERROR
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_ESR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX: Thermal LVT */
comment|/* Program the CMCI LVT entry if present. */
if|if
condition|(
name|maxlvt
operator|>=
name|APIC_LVT_CMCI
condition|)
block|{
name|lapic_write32
argument_list|(
name|LAPIC_LVT_CMCI
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_CMCI
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_CMCI
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|elvt_count
operator|=
name|amd_read_elvt_count
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elvt_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|la
operator|->
name|la_elvts
index|[
name|i
index|]
operator|.
name|lvt_active
condition|)
name|lapic_write32
argument_list|(
name|LAPIC_EXT_LVT0
operator|+
name|i
argument_list|,
name|elvt_mode
argument_list|(
name|la
argument_list|,
name|i
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_EXT_LVT0
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|intr_restore
argument_list|(
name|saveintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_reenable_pmc
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|uint32_t
name|value
decl_stmt|;
name|value
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVT_M
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_function
specifier|static
name|void
name|lapic_update_pmc
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|lapic_id
argument_list|()
index|]
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|,
name|lvt_mode
argument_list|(
name|la
argument_list|,
name|APIC_LVT_PMC
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_LVT_PCINT
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|native_lapic_enable_pmc
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|u_int32_t
name|maxlvt
decl_stmt|;
comment|/* Fail if the local APIC is not present. */
if|if
condition|(
operator|!
name|x2apic_mode
operator|&&
name|lapic_map
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Fail if the PMC LVT is not present. */
name|maxlvt
operator|=
operator|(
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
if|if
condition|(
name|maxlvt
operator|<
name|APIC_LVT_PMC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lvts
index|[
name|APIC_LVT_PMC
index|]
operator|.
name|lvt_masked
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|EARLY_AP_STARTUP
name|MPASS
argument_list|(
name|mp_ncpus
operator|==
literal|1
operator|||
name|smp_started
argument_list|)
expr_stmt|;
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|lapic_update_pmc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * If hwpmc was loaded at boot time then the APs may not be 	 * started yet.  In that case, don't forward the request to 	 * them as they will program the lvt when they start. 	 */
if|if
condition|(
name|smp_started
condition|)
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|lapic_update_pmc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|lapic_update_pmc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_disable_pmc
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
name|u_int32_t
name|maxlvt
decl_stmt|;
comment|/* Fail if the local APIC is not present. */
if|if
condition|(
operator|!
name|x2apic_mode
operator|&&
name|lapic_map
operator|==
name|NULL
condition|)
return|return;
comment|/* Fail if the PMC LVT is not present. */
name|maxlvt
operator|=
operator|(
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
expr_stmt|;
if|if
condition|(
name|maxlvt
operator|<
name|APIC_LVT_PMC
condition|)
return|return;
name|lvts
index|[
name|APIC_LVT_PMC
index|]
operator|.
name|lvt_masked
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* The APs should always be started when hwpmc is unloaded. */
name|KASSERT
argument_list|(
name|mp_ncpus
operator|==
literal|1
operator|||
name|smp_started
argument_list|,
operator|(
literal|"hwpmc unloaded too early"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|smp_rendezvous
argument_list|(
name|NULL
argument_list|,
name|lapic_update_pmc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_calibrate_initcount
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|struct
name|lapic
modifier|*
name|la
parameter_list|)
block|{
name|u_long
name|value
decl_stmt|;
comment|/* Start off with a divisor of 2 (power on reset default). */
name|lapic_timer_divisor
operator|=
literal|2
expr_stmt|;
comment|/* Try to calibrate the local APIC timer. */
do|do
block|{
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|lapic_timer_oneshot_nointr
argument_list|(
name|la
argument_list|,
name|APIC_TIMER_MAX_COUNT
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|value
operator|=
name|APIC_TIMER_MAX_COUNT
operator|-
name|lapic_read32
argument_list|(
name|LAPIC_CCR_TIMER
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|APIC_TIMER_MAX_COUNT
condition|)
break|break;
name|lapic_timer_divisor
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|lapic_timer_divisor
operator|<=
literal|128
condition|)
do|;
if|if
condition|(
name|lapic_timer_divisor
operator|>
literal|128
condition|)
name|panic
argument_list|(
literal|"lapic: Divisor too big"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"lapic: Divisor %lu, Frequency %lu Hz\n"
argument_list|,
name|lapic_timer_divisor
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|count_freq
operator|=
name|value
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_calibrate_deadline
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|struct
name|lapic
modifier|*
name|la
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"lapic: deadline tsc mode, Frequency %ju Hz\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tsc_freq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_change_mode
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|enum
name|lat_timer_mode
name|newmode
parameter_list|)
block|{
if|if
condition|(
name|la
operator|->
name|la_timer_mode
operator|==
name|newmode
condition|)
return|return;
switch|switch
condition|(
name|newmode
condition|)
block|{
case|case
name|LAT_MODE_PERIODIC
case|:
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|et
operator|->
name|et_frequency
operator|=
name|count_freq
expr_stmt|;
break|break;
case|case
name|LAT_MODE_DEADLINE
case|:
name|et
operator|->
name|et_frequency
operator|=
name|tsc_freq
expr_stmt|;
break|break;
case|case
name|LAT_MODE_ONESHOT
case|:
name|lapic_timer_set_divisor
argument_list|(
name|lapic_timer_divisor
argument_list|)
expr_stmt|;
name|et
operator|->
name|et_frequency
operator|=
name|count_freq
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"lapic_change_mode %d"
argument_list|,
name|newmode
argument_list|)
expr_stmt|;
block|}
name|la
operator|->
name|la_timer_mode
operator|=
name|newmode
expr_stmt|;
name|et
operator|->
name|et_min_period
operator|=
operator|(
literal|0x00000002LLU
operator|<<
literal|32
operator|)
operator|/
name|et
operator|->
name|et_frequency
expr_stmt|;
name|et
operator|->
name|et_max_period
operator|=
operator|(
literal|0xfffffffeLLU
operator|<<
literal|32
operator|)
operator|/
name|et
operator|->
name|et_frequency
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lapic_et_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|sbintime_t
name|first
parameter_list|,
name|sbintime_t
name|period
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|et
operator|->
name|et_frequency
operator|==
literal|0
condition|)
block|{
name|lapic_calibrate_initcount
argument_list|(
name|et
argument_list|,
name|la
argument_list|)
expr_stmt|;
if|if
condition|(
name|lapic_timer_tsc_deadline
condition|)
name|lapic_calibrate_deadline
argument_list|(
name|et
argument_list|,
name|la
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|period
operator|!=
literal|0
condition|)
block|{
name|lapic_change_mode
argument_list|(
name|et
argument_list|,
name|la
argument_list|,
name|LAT_MODE_PERIODIC
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_timer_period
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|et
operator|->
name|et_frequency
operator|*
name|period
operator|)
operator|>>
literal|32
expr_stmt|;
name|lapic_timer_periodic
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lapic_timer_tsc_deadline
condition|)
block|{
name|lapic_change_mode
argument_list|(
name|et
argument_list|,
name|la
argument_list|,
name|LAT_MODE_DEADLINE
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_timer_period
operator|=
operator|(
name|et
operator|->
name|et_frequency
operator|*
name|first
operator|)
operator|>>
literal|32
expr_stmt|;
name|lapic_timer_deadline
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lapic_change_mode
argument_list|(
name|et
argument_list|,
name|la
argument_list|,
name|LAT_MODE_ONESHOT
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_timer_period
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|et
operator|->
name|et_frequency
operator|*
name|first
operator|)
operator|>>
literal|32
expr_stmt|;
name|lapic_timer_oneshot
argument_list|(
name|la
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lapic_et_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
index|]
expr_stmt|;
name|lapic_timer_stop
argument_list|(
name|la
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_timer_mode
operator|=
name|LAT_MODE_UNDEF
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
comment|/* Software disable the local APIC. */
name|value
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_SVR
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_SVR_SWEN
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_SVR
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
comment|/* Program the spurious vector to enable the local APIC. */
name|value
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_SVR
argument_list|)
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_SVR_VECTOR
operator||
name|APIC_SVR_FOCUS
operator|)
expr_stmt|;
name|value
operator||=
name|APIC_SVR_FEN
operator||
name|APIC_SVR_SWEN
operator||
name|APIC_SPURIOUS_INT
expr_stmt|;
if|if
condition|(
name|lapic_eoi_suppression
operator|==
name|INTEL_SEOI
condition|)
name|value
operator||=
name|APIC_SVR_EOI_SUPPRESSION
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_SVR
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|lapic_eoi_suppression
operator|==
name|AMD_SEOI
condition|)
block|{
name|value
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_EXT_CTRL
argument_list|)
expr_stmt|;
name|value
operator||=
name|APIC_EXTF_SEIO_CAP
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_EXT_CTRL
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reset the local APIC on the BSP during resume. */
end_comment

begin_function
specifier|static
name|void
name|lapic_resume
parameter_list|(
name|struct
name|pic
modifier|*
name|pic
parameter_list|,
name|bool
name|suspend_cancelled
parameter_list|)
block|{
name|lapic_setup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_id
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|KASSERT
argument_list|(
name|x2apic_mode
operator|||
name|lapic_map
operator|!=
name|NULL
argument_list|,
operator|(
literal|"local APIC is not mapped"
operator|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_ID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x2apic_mode
condition|)
name|v
operator|>>=
name|APIC_ID_SHIFT
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_intr_pending
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
name|uint32_t
name|irr
decl_stmt|;
comment|/* 	 * The IRR registers are an array of registers each of which 	 * only describes 32 interrupts in the low 32 bits.  Thus, we 	 * divide the vector by 32 to get the register index. 	 * Finally, we modulus the vector by 32 to determine the 	 * individual bit to test. 	 */
name|irr
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_IRR0
operator|+
name|vector
operator|/
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
name|irr
operator|&
literal|1
operator|<<
operator|(
name|vector
operator|%
literal|32
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_set_logical_id
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|cluster
parameter_list|,
name|u_int
name|cluster_id
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: APIC %u doesn't exist"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster
operator|<=
name|APIC_MAX_CLUSTER
argument_list|,
operator|(
literal|"%s: cluster %u too big"
operator|,
name|__func__
operator|,
name|cluster
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cluster_id
operator|<=
name|APIC_MAX_INTRACLUSTER_ID
argument_list|,
operator|(
literal|"%s: intra cluster id %u too big"
operator|,
name|__func__
operator|,
name|cluster_id
operator|)
argument_list|)
expr_stmt|;
name|la
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
expr_stmt|;
name|la
operator|->
name|la_cluster
operator|=
name|cluster
expr_stmt|;
name|la
operator|->
name|la_cluster_id
operator|=
name|cluster_id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_set_lvt_mask
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_char
name|masked
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|APIC_LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_masked
operator|=
name|masked
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u %s\n"
argument_list|,
name|pin
argument_list|,
name|masked
condition|?
literal|"masked"
else|:
literal|"unmasked"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_set_lvt_mode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|u_int32_t
name|mode
parameter_list|)
block|{
name|struct
name|lvt
modifier|*
name|lvt
decl_stmt|;
if|if
condition|(
name|pin
operator|>
name|APIC_LVT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvt
operator|=
operator|&
name|lvts
index|[
name|pin
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lvt
operator|=
operator|&
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
expr_stmt|;
name|lvt
operator|->
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
name|lvt
operator|->
name|lvt_mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
case|case
name|APIC_LVT_DM_SMI
case|:
case|case
name|APIC_LVT_DM_INIT
case|:
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|lvt
operator|->
name|lvt_edgetrigger
operator|=
literal|1
expr_stmt|;
name|lvt
operator|->
name|lvt_activehi
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|APIC_LVT_DM_EXTINT
condition|)
name|lvt
operator|->
name|lvt_masked
operator|=
literal|1
expr_stmt|;
else|else
name|lvt
operator|->
name|lvt_masked
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unsupported delivery mode: 0x%x\n"
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|" Routing "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|APIC_LVT_DM_NMI
case|:
name|printf
argument_list|(
literal|"NMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_SMI
case|:
name|printf
argument_list|(
literal|"SMI"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_INIT
case|:
name|printf
argument_list|(
literal|"INIT"
argument_list|)
expr_stmt|;
break|break;
case|case
name|APIC_LVT_DM_EXTINT
case|:
name|printf
argument_list|(
literal|"ExtINT"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|" -> LINT%u\n"
argument_list|,
name|pin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_set_lvt_polarity
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|enum
name|intr_polarity
name|pol
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|APIC_LVT_MAX
operator|||
name|pol
operator|==
name|INTR_POLARITY_CONFORM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
operator|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_activehi
operator|=
operator|(
name|pol
operator|==
name|INTR_POLARITY_HIGH
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u polarity: %s\n"
argument_list|,
name|pin
argument_list|,
name|pol
operator|==
name|INTR_POLARITY_HIGH
condition|?
literal|"high"
else|:
literal|"low"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_set_lvt_triggermode
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|pin
parameter_list|,
name|enum
name|intr_trigger
name|trigger
parameter_list|)
block|{
if|if
condition|(
name|pin
operator|>
name|APIC_LVT_MAX
operator|||
name|trigger
operator|==
name|INTR_TRIGGER_CONFORM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|apic_id
operator|==
name|APIC_ID_ALL
condition|)
block|{
name|lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
operator|(
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic:"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_edgetrigger
operator|=
operator|(
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
operator|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|pin
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u:"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|" LINT%u trigger: %s\n"
argument_list|,
name|pin
argument_list|,
name|trigger
operator|==
name|INTR_TRIGGER_EDGE
condition|?
literal|"edge"
else|:
literal|"level"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust the TPR of the current CPU so that it blocks all interrupts below  * the passed in vector.  */
end_comment

begin_function
specifier|static
name|void
name|lapic_set_tpr
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHEAP_TPR
name|lapic_write32
argument_list|(
name|LAPIC_TPR
argument_list|,
name|vector
argument_list|)
expr_stmt|;
else|#
directive|else
name|uint32_t
name|tpr
decl_stmt|;
name|tpr
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_TPR
argument_list|)
operator|&
operator|~
name|APIC_TPR_PRIO
expr_stmt|;
name|tpr
operator||=
name|vector
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_TPR
argument_list|,
name|tpr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|native_lapic_eoi
parameter_list|(
name|u_int
name|vector
parameter_list|)
block|{
if|if
condition|(
name|lapic_eoi_suppression
operator|==
name|AMD_SEOI
condition|)
name|lapic_write32
argument_list|(
name|LAPIC_EXT_SEOI
argument_list|,
name|vector
argument_list|)
expr_stmt|;
else|else
name|lapic_write32_nofence
argument_list|(
name|LAPIC_EOI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_handle_intr
parameter_list|(
name|int
name|vector
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
name|isrc
operator|=
name|intr_lookup_source
argument_list|(
name|apic_idt_to_irq
argument_list|(
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
argument_list|,
name|vector
argument_list|)
argument_list|)
expr_stmt|;
name|intr_execute_handlers
argument_list|(
name|isrc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lapic_handle_timer
parameter_list|(
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|lapic
modifier|*
name|la
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|oldframe
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* Send EOI first thing. */
name|lapic_eoi
argument_list|(
name|APIC_TIMER_INT
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCHED_ULE
argument_list|)
comment|/* 	 * Don't do any accounting for the disabled HTT cores, since it 	 * will provide misleading numbers for the userland. 	 * 	 * No locking is necessary here, since even if we lose the race 	 * when hlt_cpus_mask changes it is not a big deal, really. 	 * 	 * Don't do that for ULE, since ULE doesn't consider hlt_cpus_mask 	 * and unlike other schedulers it actually schedules threads to 	 * those CPUs. 	 */
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|hlt_cpus_mask
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* Look up our local APIC structure for the tick counters. */
name|la
operator|=
operator|&
name|lapics
index|[
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
index|]
expr_stmt|;
operator|(
operator|*
name|la
operator|->
name|la_timer_count
operator|)
operator|++
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|lapic_et
operator|.
name|et_active
condition|)
block|{
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_intr_nesting_level
operator|++
expr_stmt|;
name|oldframe
operator|=
name|td
operator|->
name|td_intr_frame
expr_stmt|;
name|td
operator|->
name|td_intr_frame
operator|=
name|frame
expr_stmt|;
name|lapic_et
operator|.
name|et_event_cb
argument_list|(
operator|&
name|lapic_et
argument_list|,
name|lapic_et
operator|.
name|et_arg
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_intr_frame
operator|=
name|oldframe
expr_stmt|;
name|td
operator|->
name|td_intr_nesting_level
operator|--
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_set_divisor
parameter_list|(
name|u_int
name|divisor
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|divisor
argument_list|)
argument_list|,
operator|(
literal|"lapic: invalid divisor %u"
operator|,
name|divisor
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ffs
argument_list|(
name|divisor
argument_list|)
operator|<=
name|nitems
argument_list|(
name|lapic_timer_divisors
argument_list|)
argument_list|,
operator|(
literal|"lapic: invalid divisor %u"
operator|,
name|divisor
operator|)
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_DCR_TIMER
argument_list|,
name|lapic_timer_divisors
index|[
name|ffs
argument_list|(
name|divisor
argument_list|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_oneshot
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|value
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_LVTT_TM
operator||
name|APIC_LVT_M
operator|)
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_ONE_SHOT
expr_stmt|;
name|la
operator|->
name|lvt_timer_last
operator|=
name|value
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_ICR_TIMER
argument_list|,
name|la
operator|->
name|la_timer_period
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_oneshot_nointr
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|,
name|uint32_t
name|count
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|value
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVTT_TM
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_ONE_SHOT
operator||
name|APIC_LVT_M
expr_stmt|;
name|la
operator|->
name|lvt_timer_last
operator|=
name|value
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_ICR_TIMER
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_periodic
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|value
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_LVTT_TM
operator||
name|APIC_LVT_M
operator|)
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_PERIODIC
expr_stmt|;
name|la
operator|->
name|lvt_timer_last
operator|=
name|value
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_ICR_TIMER
argument_list|,
name|la
operator|->
name|la_timer_period
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_deadline
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
name|value
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|value
operator|&=
operator|~
operator|(
name|APIC_LVTT_TM
operator||
name|APIC_LVT_M
operator|)
expr_stmt|;
name|value
operator||=
name|APIC_LVTT_TM_TSCDLT
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|la
operator|->
name|lvt_timer_last
condition|)
block|{
name|la
operator|->
name|lvt_timer_last
operator|=
name|value
expr_stmt|;
name|lapic_write32_nofence
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x2apic_mode
condition|)
name|mfence
argument_list|()
expr_stmt|;
block|}
name|wrmsr
argument_list|(
name|MSR_TSC_DEADLINE
argument_list|,
name|la
operator|->
name|la_timer_period
operator|+
name|rdtsc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lapic_timer_stop
parameter_list|(
name|struct
name|lapic
modifier|*
name|la
parameter_list|)
block|{
name|uint32_t
name|value
decl_stmt|;
if|if
condition|(
name|la
operator|->
name|la_timer_mode
operator|==
name|LAT_MODE_DEADLINE
condition|)
block|{
name|wrmsr
argument_list|(
name|MSR_TSC_DEADLINE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mfence
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|value
operator|=
name|la
operator|->
name|lvt_timer_base
expr_stmt|;
name|value
operator|&=
operator|~
name|APIC_LVTT_TM
expr_stmt|;
name|value
operator||=
name|APIC_LVT_M
expr_stmt|;
name|la
operator|->
name|lvt_timer_last
operator|=
name|value
expr_stmt|;
name|lapic_write32
argument_list|(
name|LAPIC_LVT_TIMER
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|lapic_handle_cmc
parameter_list|(
name|void
parameter_list|)
block|{
name|lapic_eoi
argument_list|(
name|APIC_CMC_INT
argument_list|)
expr_stmt|;
name|cmc_intr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from the mca_init() to activate the CMC interrupt if this CPU is  * responsible for monitoring any MC banks for CMC events.  Since mca_init()  * is called prior to lapic_setup() during boot, this just needs to unmask  * this CPU's LVT_CMCI entry.  */
end_comment

begin_function
specifier|static
name|void
name|native_lapic_enable_cmc
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|apic_id
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATPIC
if|if
condition|(
operator|!
name|x2apic_mode
operator|&&
name|lapic_map
operator|==
name|NULL
condition|)
return|return;
endif|#
directive|endif
name|apic_id
operator|=
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|APIC_LVT_CMCI
index|]
operator|.
name|lvt_masked
operator|=
literal|0
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_lvts
index|[
name|APIC_LVT_CMCI
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u: CMCI unmasked\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|native_lapic_enable_mca_elvt
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|apic_id
decl_stmt|;
name|uint32_t
name|value
decl_stmt|;
name|int
name|elvt_count
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_ATPIC
if|if
condition|(
name|lapic_map
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
endif|#
directive|endif
name|apic_id
operator|=
name|PCPU_GET
argument_list|(
name|apic_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
argument_list|,
operator|(
literal|"%s: missing APIC %u"
operator|,
name|__func__
operator|,
name|apic_id
operator|)
argument_list|)
expr_stmt|;
name|elvt_count
operator|=
name|amd_read_elvt_count
argument_list|()
expr_stmt|;
if|if
condition|(
name|elvt_count
operator|<=
name|APIC_ELVT_MCA
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|value
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_EXT_LVT0
operator|+
name|APIC_ELVT_MCA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|&
name|APIC_LVT_M
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"AMD MCE Thresholding Extended LVT is already active\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_elvts
index|[
name|APIC_ELVT_MCA
index|]
operator|.
name|lvt_masked
operator|=
literal|0
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_elvts
index|[
name|APIC_ELVT_MCA
index|]
operator|.
name|lvt_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"lapic%u: MCE Thresholding ELVT unmasked\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|APIC_ELVT_MCA
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lapic_handle_error
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|esr
decl_stmt|;
comment|/* 	 * Read the contents of the error status register.  Write to 	 * the register first before reading from it to force the APIC 	 * to update its value to indicate any errors that have 	 * occurred since the previous write to the register. 	 */
name|lapic_write32
argument_list|(
name|LAPIC_ESR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|esr
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_ESR
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"CPU%d: local APIC error 0x%x\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|esr
argument_list|)
expr_stmt|;
name|lapic_eoi
argument_list|(
name|APIC_ERROR_INT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|native_apic_cpuid
parameter_list|(
name|u_int
name|apic_id
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
return|return
name|apic_cpuids
index|[
name|apic_id
index|]
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Request a free IDT vector to be used by the specified IRQ. */
end_comment

begin_function
specifier|static
name|u_int
name|native_apic_alloc_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|u_int
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|irq
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search for a free vector.  Currently we just use a very simple 	 * algorithm to find the first free vector. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|APIC_NUM_IOINTS
condition|;
name|vector
operator|++
control|)
block|{
if|if
condition|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
index|]
operator|!=
operator|-
literal|1
condition|)
continue|continue;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
index|]
operator|=
name|irq
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|vector
operator|+
name|APIC_IO_INTS
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request 'count' free contiguous IDT vectors to be used by 'count'  * IRQs.  'count' must be a power of two and the vectors will be  * aligned on a boundary of 'align'.  If the request cannot be  * satisfied, 0 is returned.  */
end_comment

begin_function
specifier|static
name|u_int
name|native_apic_alloc_vectors
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
modifier|*
name|irqs
parameter_list|,
name|u_int
name|count
parameter_list|,
name|u_int
name|align
parameter_list|)
block|{
name|u_int
name|first
decl_stmt|,
name|run
decl_stmt|,
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|count
argument_list|)
argument_list|,
operator|(
literal|"bad count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|powerof2
argument_list|(
name|align
argument_list|)
argument_list|,
operator|(
literal|"bad align"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|align
operator|>=
name|count
argument_list|,
operator|(
literal|"align< count"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|run
operator|=
literal|0
init|;
name|run
operator|<
name|count
condition|;
name|run
operator|++
control|)
name|KASSERT
argument_list|(
name|irqs
index|[
name|run
index|]
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u at index %u"
operator|,
name|irqs
index|[
name|run
index|]
operator|,
name|run
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Search for 'count' free vectors.  As with apic_alloc_vector(), 	 * this just uses a simple first fit algorithm. 	 */
name|run
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|APIC_NUM_IOINTS
condition|;
name|vector
operator|++
control|)
block|{
comment|/* Vector is in use, end run. */
if|if
condition|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|run
operator|=
literal|0
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Start a new run if run == 0 and vector is aligned. */
if|if
condition|(
name|run
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|vector
operator|&
operator|(
name|align
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|first
operator|=
name|vector
expr_stmt|;
block|}
name|run
operator|++
expr_stmt|;
comment|/* Keep looping if the run isn't long enough yet. */
if|if
condition|(
name|run
operator|<
name|count
condition|)
continue|continue;
comment|/* Found a run, assign IRQs and return the first vector. */
for|for
control|(
name|vector
operator|=
literal|0
init|;
name|vector
operator|<
name|count
condition|;
name|vector
operator|++
control|)
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|first
operator|+
name|vector
index|]
operator|=
name|irqs
index|[
name|vector
index|]
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|+
name|APIC_IO_INTS
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"APIC: Couldn't find APIC vectors for %u IRQs\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable a vector for a particular apic_id.  Since all lapics share idt  * entries and ioint_handlers this enables the vector on all lapics.  lapics  * which do not have the vector configured would report spurious interrupts  * should it fire.  */
end_comment

begin_function
specifier|static
name|void
name|native_apic_enable_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_SYSCALL
argument_list|,
operator|(
literal|"Attempt to overwrite syscall entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No ISR handler for vector %u"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_DTRACE_RET
argument_list|,
operator|(
literal|"Attempt to overwrite DTrace entry"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|setidt
argument_list|(
name|vector
argument_list|,
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
argument_list|,
name|SDT_APIC
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_apic_disable_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_SYSCALL
argument_list|,
operator|(
literal|"Attempt to overwrite syscall entry"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_DTRACE_RET
argument_list|,
operator|(
literal|"Attempt to overwrite DTrace entry"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|ioint_handlers
index|[
name|vector
operator|/
literal|32
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No ISR handler for vector %u"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * We can not currently clear the idt entry because other cpus 	 * may have a valid vector at this offset. 	 */
name|setidt
argument_list|(
name|vector
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
name|SDT_APICT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Release an APIC vector when it's no longer in use. */
end_comment

begin_function
specifier|static
name|void
name|native_apic_free_vector
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
name|APIC_IO_INTS
operator|&&
name|vector
operator|!=
name|IDT_SYSCALL
operator|&&
name|vector
operator|<=
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
argument_list|,
operator|(
literal|"Vector %u does not map to an IRQ line"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|irq
operator|<
name|NUM_IO_INTS
argument_list|,
operator|(
literal|"Invalid IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
operator|==
name|irq
argument_list|,
operator|(
literal|"IRQ mismatch"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_DTRACE_RET
argument_list|,
operator|(
literal|"Attempt to overwrite DTrace entry"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Bind us to the cpu that owned the vector before freeing it so 	 * we don't lose an interrupt delivery race. 	 */
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
operator|!
name|rebooting
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_is_bound
argument_list|(
name|td
argument_list|)
condition|)
name|panic
argument_list|(
literal|"apic_free_vector: Thread already bound.\n"
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|td
argument_list|,
name|apic_cpuid
argument_list|(
name|apic_id
argument_list|)
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rebooting
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Map an IDT vector (APIC) to an IRQ (interrupt source). */
end_comment

begin_function
specifier|static
name|u_int
name|apic_idt_to_irq
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|u_int
name|vector
parameter_list|)
block|{
name|int
name|irq
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
name|APIC_IO_INTS
operator|&&
name|vector
operator|!=
name|IDT_SYSCALL
operator|&&
name|vector
operator|<=
name|APIC_IO_INTS
operator|+
name|APIC_NUM_IOINTS
argument_list|,
operator|(
literal|"Vector %u does not map to an IRQ line"
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|KASSERT
argument_list|(
name|vector
operator|!=
name|IDT_DTRACE_RET
argument_list|,
operator|(
literal|"Attempt to overwrite DTrace entry"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|irq
operator|=
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|vector
operator|-
name|APIC_IO_INTS
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|<
literal|0
condition|)
name|irq
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|irq
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * Dump data about APIC IDT vector mappings.  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|apic
argument_list|,
argument|db_show_apic
argument_list|)
end_macro

begin_block
block|{
name|struct
name|intsrc
modifier|*
name|isrc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|verbose
decl_stmt|;
name|u_int
name|apic_id
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|modif
argument_list|,
literal|"vv"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|modif
argument_list|,
literal|"v"
argument_list|)
operator|==
literal|0
condition|)
name|verbose
operator|=
literal|1
expr_stmt|;
else|else
name|verbose
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|apic_id
operator|=
literal|0
init|;
name|apic_id
operator|<=
name|MAX_APIC_ID
condition|;
name|apic_id
operator|++
control|)
block|{
if|if
condition|(
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_present
operator|==
literal|0
condition|)
continue|continue;
name|db_printf
argument_list|(
literal|"Interrupts bound to lapic %u\n"
argument_list|,
name|apic_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|APIC_NUM_IOINTS
operator|+
literal|1
operator|&&
operator|!
name|db_pager_quit
condition|;
name|i
operator|++
control|)
block|{
name|irq
operator|=
name|lapics
index|[
name|apic_id
index|]
operator|.
name|la_ioint_irqs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|==
operator|-
literal|1
operator|||
name|irq
operator|==
name|IRQ_SYSCALL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
name|irq
operator|==
name|IRQ_DTRACE_RET
condition|)
continue|continue;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XENHVM
if|if
condition|(
name|irq
operator|==
name|IRQ_EVTCHN
condition|)
continue|continue;
endif|#
directive|endif
name|db_printf
argument_list|(
literal|"vec 0x%2x -> "
argument_list|,
name|i
operator|+
name|APIC_IO_INTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|IRQ_TIMER
condition|)
name|db_printf
argument_list|(
literal|"lapic timer\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|irq
operator|<
name|NUM_IO_INTS
condition|)
block|{
name|isrc
operator|=
name|intr_lookup_source
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|isrc
operator|==
name|NULL
operator|||
name|verbose
operator|==
literal|0
condition|)
name|db_printf
argument_list|(
literal|"IRQ %u\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
else|else
name|db_dump_intr_event
argument_list|(
name|isrc
operator|->
name|is_event
argument_list|,
name|verbose
operator|==
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"IRQ %u ???\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|dump_mask
parameter_list|(
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|uint32_t
name|v
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|db_printf
argument_list|(
literal|"%s:"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|" %02x"
argument_list|,
name|base
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show info from the lapic regs for this CPU. */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|lapic
argument_list|,
argument|db_show_lapic
argument_list|)
end_macro

begin_block
block|{
name|uint32_t
name|v
decl_stmt|;
name|db_printf
argument_list|(
literal|"lapic ID = %d\n"
argument_list|,
name|lapic_id
argument_list|()
argument_list|)
expr_stmt|;
name|v
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_VERSION
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"version  = %d.%d\n"
argument_list|,
operator|(
name|v
operator|&
name|APIC_VER_VERSION
operator|)
operator|>>
literal|4
argument_list|,
name|v
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"max LVT  = %d\n"
argument_list|,
operator|(
name|v
operator|&
name|APIC_VER_MAXLVT
operator|)
operator|>>
name|MAXLVTSHIFT
argument_list|)
expr_stmt|;
name|v
operator|=
name|lapic_read32
argument_list|(
name|LAPIC_SVR
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"SVR      = %02x (%s)\n"
argument_list|,
name|v
operator|&
name|APIC_SVR_VECTOR
argument_list|,
name|v
operator|&
name|APIC_SVR_ENABLE
condition|?
literal|"enabled"
else|:
literal|"disabled"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"TPR      = %02x\n"
argument_list|,
name|lapic_read32
argument_list|(
name|LAPIC_TPR
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|dump_field
parameter_list|(
name|prefix
parameter_list|,
name|regn
parameter_list|,
name|index
parameter_list|)
define|\
value|dump_mask(__XSTRING(prefix ## index), 				\ 	    lapic_read32(LAPIC_ ## regn ## index),			\ 	    index * 32)
name|db_printf
argument_list|(
literal|"In-service Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|isr
argument_list|,
name|ISR
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"TMR Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|tmr
argument_list|,
name|TMR
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"IRR Interrupts:\n"
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|dump_field
argument_list|(
name|irr
argument_list|,
name|IRR
argument_list|,
literal|7
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|dump_field
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * APIC probing support code.  This includes code to manage enumerators.  */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|apic_enumerator
argument_list|)
name|enumerators
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|enumerators
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|apic_enumerator
modifier|*
name|best_enum
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|apic_register_enumerator
parameter_list|(
name|struct
name|apic_enumerator
modifier|*
name|enumerator
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|apic_enumerator
modifier|*
name|apic_enum
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|apic_enum
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
if|if
condition|(
name|apic_enum
operator|==
name|enumerator
condition|)
name|panic
argument_list|(
literal|"%s: Duplicate register of %s"
argument_list|,
name|__func__
argument_list|,
name|enumerator
operator|->
name|apic_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|enumerators
argument_list|,
name|enumerator
argument_list|,
name|apic_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We have to look for CPU's very, very early because certain subsystems  * want to know how many CPU's we have extremely early on in the boot  * process.  */
end_comment

begin_function
specifier|static
name|void
name|apic_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|apic_enumerator
modifier|*
name|enumerator
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|best
decl_stmt|;
comment|/* We only support built in local APICs. */
if|if
condition|(
operator|!
operator|(
name|cpu_feature
operator|&
name|CPUID_APIC
operator|)
condition|)
return|return;
comment|/* Don't probe if APIC mode is disabled. */
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"apic"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* Probe all the enumerators to find the best match. */
name|best_enum
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|enumerator
argument_list|,
argument|&enumerators
argument_list|,
argument|apic_next
argument_list|)
block|{
name|retval
operator|=
name|enumerator
operator|->
name|apic_probe
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
continue|continue;
if|if
condition|(
name|best_enum
operator|==
name|NULL
operator|||
name|best
operator|<
name|retval
condition|)
block|{
name|best_enum
operator|=
name|enumerator
expr_stmt|;
name|best
operator|=
name|retval
expr_stmt|;
block|}
block|}
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Could not find any APICs.\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEV_ATPIC
name|panic
argument_list|(
literal|"running without device atpic requires a local APIC"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"APIC: Using the %s enumerator.\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|I686_CPU
comment|/* 	 * To work around an errata, we disable the local APIC on some 	 * CPUs during early startup.  We need to turn the local APIC back 	 * on on such CPUs now. 	 */
name|ppro_reenable_apic
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Probe the CPU's in the system. */
name|retval
operator|=
name|best_enum
operator|->
name|apic_probe_cpus
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to probe CPUs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|apic_init
argument_list|,
name|SI_SUB_TUNABLES
operator|-
literal|1
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|apic_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Setup the local APIC.  We have to do this prior to starting up the APs  * in the SMP case.  */
end_comment

begin_function
specifier|static
name|void
name|apic_setup_local
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
return|return;
comment|/* Initialize the local APIC. */
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_local
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup the local APIC: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|apic_setup_local
argument_list|,
name|SI_SUB_CPU
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|apic_setup_local
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Setup the I/O APICs.  */
end_comment

begin_function
specifier|static
name|void
name|apic_setup_io
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|best_enum
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Local APIC must be registered before other PICs and pseudo PICs 	 * for proper suspend/resume order. 	 */
name|intr_register_pic
argument_list|(
operator|&
name|lapic_pic
argument_list|)
expr_stmt|;
name|retval
operator|=
name|best_enum
operator|->
name|apic_setup_io
argument_list|()
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: Failed to setup I/O APICs: returned %d\n"
argument_list|,
name|best_enum
operator|->
name|apic_name
argument_list|,
name|retval
argument_list|)
expr_stmt|;
comment|/* 	 * Finish setting up the local APIC on the BSP once we know 	 * how to properly program the LINT pins.  In particular, this 	 * enables the EOI suppression mode, if LAPIC support it and 	 * user did not disabled the mode. 	 */
name|lapic_setup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|lapic_dump
argument_list|(
literal|"BSP"
argument_list|)
expr_stmt|;
comment|/* Enable the MSI "pic". */
name|init_ops
operator|.
name|msi_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|apic_setup_io
argument_list|,
name|SI_SUB_INTR
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|apic_setup_io
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * Inter Processor Interrupt functions.  The lapic_ipi_*() functions are  * private to the MD code.  The public interface for the rest of the  * kernel is defined in mp_machdep.c.  */
end_comment

begin_comment
comment|/*  * Wait delay microseconds for IPI to be sent.  If delay is -1, we  * wait forever.  */
end_comment

begin_function
specifier|static
name|int
name|native_lapic_ipi_wait
parameter_list|(
name|int
name|delay
parameter_list|)
block|{
name|uint64_t
name|rx
decl_stmt|;
comment|/* LAPIC_ICR.APIC_DELSTAT_MASK is undefined in x2APIC mode */
if|if
condition|(
name|x2apic_mode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|rx
operator|=
literal|0
init|;
name|delay
operator|==
operator|-
literal|1
operator|||
name|rx
operator|<
name|lapic_ipi_wait_mult
operator|*
name|delay
condition|;
name|rx
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|lapic_read_icr_lo
argument_list|()
operator|&
name|APIC_DELSTAT_MASK
operator|)
operator|==
name|APIC_DELSTAT_IDLE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ia32_pause
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_ipi_raw
parameter_list|(
name|register_t
name|icrlo
parameter_list|,
name|u_int
name|dest
parameter_list|)
block|{
name|uint64_t
name|icr
decl_stmt|;
name|uint32_t
name|vhi
decl_stmt|,
name|vlo
decl_stmt|;
name|register_t
name|saveintr
decl_stmt|;
comment|/* XXX: Need more sanity checking of icrlo? */
name|KASSERT
argument_list|(
name|x2apic_mode
operator|||
name|lapic_map
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s called too early"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|x2apic_mode
operator|||
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid dest field"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|icrlo
operator|&
name|APIC_ICRLO_RESV_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: reserved bits set in ICR LO register"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Set destination in ICR HI register if it is being used. */
if|if
condition|(
operator|!
name|x2apic_mode
condition|)
block|{
name|saveintr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|icr
operator|=
name|lapic_read_icr
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|icrlo
operator|&
name|APIC_DEST_MASK
operator|)
operator|==
name|APIC_DEST_DESTFLD
condition|)
block|{
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|vhi
operator|=
name|dest
expr_stmt|;
block|}
else|else
block|{
name|vhi
operator|=
name|icr
operator|>>
literal|32
expr_stmt|;
name|vhi
operator|&=
operator|~
name|APIC_ID_MASK
expr_stmt|;
name|vhi
operator||=
name|dest
operator|<<
name|APIC_ID_SHIFT
expr_stmt|;
block|}
block|}
else|else
block|{
name|vhi
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Program the contents of the IPI and dispatch it. */
if|if
condition|(
name|x2apic_mode
condition|)
block|{
name|vlo
operator|=
name|icrlo
expr_stmt|;
block|}
else|else
block|{
name|vlo
operator|=
name|icr
expr_stmt|;
name|vlo
operator|&=
name|APIC_ICRLO_RESV_MASK
expr_stmt|;
name|vlo
operator||=
name|icrlo
expr_stmt|;
block|}
name|lapic_write_icr
argument_list|(
name|vhi
argument_list|,
name|vlo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|x2apic_mode
condition|)
name|intr_restore
argument_list|(
name|saveintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BEFORE_SPIN
value|50000
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
end_ifdef

begin_define
define|#
directive|define
name|AFTER_SPIN
value|50
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|native_lapic_ipi_vectored
parameter_list|(
name|u_int
name|vector
parameter_list|,
name|int
name|dest
parameter_list|)
block|{
name|register_t
name|icrlo
decl_stmt|,
name|destfield
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vector
operator|&
operator|~
name|APIC_VECTOR_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|icrlo
operator|=
name|APIC_DESTMODE_PHY
operator||
name|APIC_TRIGMOD_EDGE
operator||
name|APIC_LEVEL_ASSERT
expr_stmt|;
comment|/* 	 * NMI IPIs are just fake vectors used to send a NMI.  Use special rules 	 * regarding NMIs if passed, otherwise specify the vector. 	 */
if|if
condition|(
name|vector
operator|>=
name|IPI_NMI_FIRST
condition|)
name|icrlo
operator||=
name|APIC_DELMODE_NMI
expr_stmt|;
else|else
name|icrlo
operator||=
name|vector
operator||
name|APIC_DELMODE_FIXED
expr_stmt|;
name|destfield
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dest
condition|)
block|{
case|case
name|APIC_IPI_DEST_SELF
case|:
name|icrlo
operator||=
name|APIC_DEST_SELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_ALL
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLISELF
expr_stmt|;
break|break;
case|case
name|APIC_IPI_DEST_OTHERS
case|:
name|icrlo
operator||=
name|APIC_DEST_ALLESELF
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
name|x2apic_mode
operator|||
operator|(
name|dest
operator|&
operator|~
operator|(
name|APIC_ID_MASK
operator|>>
name|APIC_ID_SHIFT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: invalid destination 0x%x"
operator|,
name|__func__
operator|,
name|dest
operator|)
argument_list|)
expr_stmt|;
name|destfield
operator|=
name|dest
expr_stmt|;
block|}
comment|/* Wait for an earlier IPI to finish. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|BEFORE_SPIN
argument_list|)
condition|)
block|{
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
else|else
name|panic
argument_list|(
literal|"APIC: Previous IPI is stuck"
argument_list|)
expr_stmt|;
block|}
name|lapic_ipi_raw
argument_list|(
name|icrlo
argument_list|,
name|destfield
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DETECT_DEADLOCK
comment|/* Wait for IPI to be delivered. */
if|if
condition|(
operator|!
name|lapic_ipi_wait
argument_list|(
name|AFTER_SPIN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|needsattention
comment|/* 		 * XXX FIXME: 		 * 		 * The above function waits for the message to actually be 		 * delivered.  It breaks out after an arbitrary timeout 		 * since the message should eventually be delivered (at 		 * least in theory) and that if it wasn't we would catch 		 * the failure with the check above when the next IPI is 		 * sent. 		 * 		 * We could skip this wait entirely, EXCEPT it probably 		 * protects us from other routines that assume that the 		 * message was delivered and acted upon when this function 		 * returns. 		 */
name|printf
argument_list|(
literal|"APIC: IPI might be stuck\n"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !needsattention */
comment|/* Wait until mesage is sent without a timeout. */
while|while
condition|(
name|lapic_read_icr_lo
argument_list|()
operator|&
name|APIC_DELSTAT_PEND
condition|)
name|ia32_pause
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* needsattention */
block|}
endif|#
directive|endif
comment|/* DETECT_DEADLOCK */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_comment
comment|/*  * Since the IDT is shared by all CPUs the IPI slot update needs to be globally  * visible.  *  * Consider the case where an IPI is generated immediately after allocation:  *     vector = lapic_ipi_alloc(ipifunc);  *     ipi_selected(other_cpus, vector);  *  * In xAPIC mode a write to ICR_LO has serializing semantics because the  * APIC page is mapped as an uncached region. In x2APIC mode there is an  * explicit 'mfence' before the ICR MSR is written. Therefore in both cases  * the IDT slot update is globally visible before the IPI is delivered.  */
end_comment

begin_function
specifier|static
name|int
name|native_lapic_ipi_alloc
parameter_list|(
name|inthand_t
modifier|*
name|ipifunc
parameter_list|)
block|{
name|struct
name|gate_descriptor
modifier|*
name|ip
decl_stmt|;
name|long
name|func
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|vector
decl_stmt|;
name|KASSERT
argument_list|(
name|ipifunc
operator|!=
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
operator|(
literal|"invalid ipifunc %p"
operator|,
name|ipifunc
operator|)
argument_list|)
expr_stmt|;
name|vector
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
name|IPI_DYN_FIRST
init|;
name|idx
operator|<=
name|IPI_DYN_LAST
condition|;
name|idx
operator|++
control|)
block|{
name|ip
operator|=
operator|&
name|idt
index|[
name|idx
index|]
expr_stmt|;
name|func
operator|=
operator|(
name|ip
operator|->
name|gd_hioffset
operator|<<
literal|16
operator|)
operator||
name|ip
operator|->
name|gd_looffset
expr_stmt|;
if|if
condition|(
name|func
operator|==
operator|(
name|uintptr_t
operator|)
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
condition|)
block|{
name|vector
operator|=
name|idx
expr_stmt|;
name|setidt
argument_list|(
name|vector
argument_list|,
name|ipifunc
argument_list|,
name|SDT_APIC
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|vector
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|native_lapic_ipi_free
parameter_list|(
name|int
name|vector
parameter_list|)
block|{
name|struct
name|gate_descriptor
modifier|*
name|ip
decl_stmt|;
name|long
name|func
decl_stmt|;
name|KASSERT
argument_list|(
name|vector
operator|>=
name|IPI_DYN_FIRST
operator|&&
name|vector
operator|<=
name|IPI_DYN_LAST
argument_list|,
operator|(
literal|"%s: invalid vector %d"
operator|,
name|__func__
operator|,
name|vector
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|idt
index|[
name|vector
index|]
expr_stmt|;
name|func
operator|=
operator|(
name|ip
operator|->
name|gd_hioffset
operator|<<
literal|16
operator|)
operator||
name|ip
operator|->
name|gd_looffset
expr_stmt|;
name|KASSERT
argument_list|(
name|func
operator|!=
operator|(
name|uintptr_t
operator|)
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
operator|(
literal|"invalid idtfunc %#lx"
operator|,
name|func
operator|)
argument_list|)
expr_stmt|;
name|setidt
argument_list|(
name|vector
argument_list|,
operator|&
name|IDTVEC
argument_list|(
name|rsvd
argument_list|)
argument_list|,
name|SDT_APICT
argument_list|,
name|SEL_KPL
argument_list|,
name|GSEL_APIC
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|icu_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

