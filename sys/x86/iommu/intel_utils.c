begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_function
name|u_int
name|dmar_nd2mask
parameter_list|(
name|u_int
name|nd
parameter_list|)
block|{
specifier|static
specifier|const
name|u_int
name|masks
index|[]
init|=
block|{
literal|0x000f
block|,
comment|/* nd == 0 */
literal|0x002f
block|,
comment|/* nd == 1 */
literal|0x00ff
block|,
comment|/* nd == 2 */
literal|0x02ff
block|,
comment|/* nd == 3 */
literal|0x0fff
block|,
comment|/* nd == 4 */
literal|0x2fff
block|,
comment|/* nd == 5 */
literal|0xffff
block|,
comment|/* nd == 6 */
literal|0x0000
block|,
comment|/* nd == 7 reserved */
block|}
decl_stmt|;
name|KASSERT
argument_list|(
name|nd
operator|<=
literal|6
argument_list|,
operator|(
literal|"number of domains %d"
operator|,
name|nd
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|masks
index|[
name|nd
index|]
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
name|sagaw_bits_tag
block|{
name|int
name|agaw
decl_stmt|;
name|int
name|cap
decl_stmt|;
name|int
name|awlvl
decl_stmt|;
name|int
name|pglvl
decl_stmt|;
block|}
name|sagaw_bits
index|[]
init|=
block|{
block|{
operator|.
name|agaw
operator|=
literal|30
block|,
operator|.
name|cap
operator|=
name|DMAR_CAP_SAGAW_2LVL
block|,
operator|.
name|awlvl
operator|=
name|DMAR_CTX2_AW_2LVL
block|,
operator|.
name|pglvl
operator|=
literal|2
block|}
block|,
block|{
operator|.
name|agaw
operator|=
literal|39
block|,
operator|.
name|cap
operator|=
name|DMAR_CAP_SAGAW_3LVL
block|,
operator|.
name|awlvl
operator|=
name|DMAR_CTX2_AW_3LVL
block|,
operator|.
name|pglvl
operator|=
literal|3
block|}
block|,
block|{
operator|.
name|agaw
operator|=
literal|48
block|,
operator|.
name|cap
operator|=
name|DMAR_CAP_SAGAW_4LVL
block|,
operator|.
name|awlvl
operator|=
name|DMAR_CTX2_AW_4LVL
block|,
operator|.
name|pglvl
operator|=
literal|4
block|}
block|,
block|{
operator|.
name|agaw
operator|=
literal|57
block|,
operator|.
name|cap
operator|=
name|DMAR_CAP_SAGAW_5LVL
block|,
operator|.
name|awlvl
operator|=
name|DMAR_CTX2_AW_5LVL
block|,
operator|.
name|pglvl
operator|=
literal|5
block|}
block|,
block|{
operator|.
name|agaw
operator|=
literal|64
block|,
operator|.
name|cap
operator|=
name|DMAR_CAP_SAGAW_6LVL
block|,
operator|.
name|awlvl
operator|=
name|DMAR_CTX2_AW_6LVL
block|,
operator|.
name|pglvl
operator|=
literal|6
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SIZEOF_SAGAW_BITS
value|(sizeof(sagaw_bits) / sizeof(sagaw_bits[0]))
end_define

begin_function
name|bool
name|dmar_pglvl_supported
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|pglvl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF_SAGAW_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|pglvl
operator|!=
name|pglvl
condition|)
continue|continue;
if|if
condition|(
operator|(
name|DMAR_CAP_SAGAW
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
operator|&
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|cap
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctx_set_agaw
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|mgaw
parameter_list|)
block|{
name|int
name|sagaw
decl_stmt|,
name|i
decl_stmt|;
name|ctx
operator|->
name|mgaw
operator|=
name|mgaw
expr_stmt|;
name|sagaw
operator|=
name|DMAR_CAP_SAGAW
argument_list|(
name|ctx
operator|->
name|dmar
operator|->
name|hw_cap
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF_SAGAW_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|agaw
operator|>=
name|mgaw
condition|)
block|{
name|ctx
operator|->
name|agaw
operator|=
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|agaw
expr_stmt|;
name|ctx
operator|->
name|pglvl
operator|=
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|pglvl
expr_stmt|;
name|ctx
operator|->
name|awlvl
operator|=
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|awlvl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|device_printf
argument_list|(
name|ctx
operator|->
name|dmar
operator|->
name|dev
argument_list|,
literal|"context request mgaw %d for pci%d:%d:%d:%d, "
literal|"no agaw found, sagaw %x\n"
argument_list|,
name|mgaw
argument_list|,
name|ctx
operator|->
name|dmar
operator|->
name|segment
argument_list|,
name|ctx
operator|->
name|bus
argument_list|,
name|ctx
operator|->
name|slot
argument_list|,
name|ctx
operator|->
name|func
argument_list|,
name|sagaw
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a best fit mgaw for the given maxaddr:  *   - if allow_less is false, must find sagaw which maps all requested  *     addresses (used by identity mappings);  *   - if allow_less is true, and no supported sagaw can map all requested  *     address space, accept the biggest sagaw, whatever is it.  */
end_comment

begin_function
name|int
name|dmar_maxaddr2mgaw
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_gaddr_t
name|maxaddr
parameter_list|,
name|bool
name|allow_less
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SIZEOF_SAGAW_BITS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
literal|1ULL
operator|<<
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|agaw
operator|)
operator|>=
name|maxaddr
operator|&&
operator|(
name|DMAR_CAP_SAGAW
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
operator|&
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|cap
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|allow_less
operator|&&
name|i
operator|==
name|SIZEOF_SAGAW_BITS
condition|)
block|{
do|do
block|{
name|i
operator|--
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|DMAR_CAP_SAGAW
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
operator|&
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|cap
operator|)
operator|==
literal|0
condition|)
do|;
block|}
if|if
condition|(
name|i
operator|<
name|SIZEOF_SAGAW_BITS
condition|)
return|return
operator|(
name|sagaw_bits
index|[
name|i
index|]
operator|.
name|agaw
operator|)
return|;
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"no mgaw for maxaddr %jx allow_less %d"
operator|,
operator|(
name|uintmax_t
operator|)
name|maxaddr
operator|,
name|allow_less
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the total amount of page table pages needed to map the  * whole bus address space on the context with the selected agaw.  */
end_comment

begin_function
name|vm_pindex_t
name|pglvl_max_pages
parameter_list|(
name|int
name|pglvl
parameter_list|)
block|{
name|vm_pindex_t
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|res
operator|=
literal|0
operator|,
name|i
operator|=
name|pglvl
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|res
operator|*=
name|DMAR_NPTEPG
expr_stmt|;
name|res
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the page table level lvl supports the superpage for  * the context ctx.  */
end_comment

begin_function
name|int
name|ctx_is_sp_lvl
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|lvl
parameter_list|)
block|{
name|int
name|alvl
decl_stmt|,
name|cap_sps
decl_stmt|;
specifier|static
specifier|const
name|int
name|sagaw_sp
index|[]
init|=
block|{
name|DMAR_CAP_SPS_2M
block|,
name|DMAR_CAP_SPS_1G
block|,
name|DMAR_CAP_SPS_512G
block|,
name|DMAR_CAP_SPS_1T
block|}
decl_stmt|;
name|alvl
operator|=
name|ctx
operator|->
name|pglvl
operator|-
name|lvl
operator|-
literal|1
expr_stmt|;
name|cap_sps
operator|=
name|DMAR_CAP_SPS
argument_list|(
name|ctx
operator|->
name|dmar
operator|->
name|hw_cap
argument_list|)
expr_stmt|;
return|return
operator|(
name|alvl
operator|<
sizeof|sizeof
argument_list|(
name|sagaw_sp
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sagaw_sp
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|(
name|sagaw_sp
index|[
name|alvl
index|]
operator|&
name|cap_sps
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|dmar_gaddr_t
name|pglvl_page_size
parameter_list|(
name|int
name|total_pglvl
parameter_list|,
name|int
name|lvl
parameter_list|)
block|{
name|int
name|rlvl
decl_stmt|;
specifier|static
specifier|const
name|dmar_gaddr_t
name|pg_sz
index|[]
init|=
block|{
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
block|,
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
operator|<<
name|DMAR_NPTEPGSHIFT
block|,
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
operator|<<
operator|(
literal|2
operator|*
name|DMAR_NPTEPGSHIFT
operator|)
block|,
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
operator|<<
operator|(
literal|3
operator|*
name|DMAR_NPTEPGSHIFT
operator|)
block|,
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
operator|<<
operator|(
literal|4
operator|*
name|DMAR_NPTEPGSHIFT
operator|)
block|,
operator|(
name|dmar_gaddr_t
operator|)
name|DMAR_PAGE_SIZE
operator|<<
operator|(
literal|5
operator|*
name|DMAR_NPTEPGSHIFT
operator|)
block|}
decl_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|>=
literal|0
operator|&&
name|lvl
operator|<
name|total_pglvl
argument_list|,
operator|(
literal|"total %d lvl %d"
operator|,
name|total_pglvl
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|rlvl
operator|=
name|total_pglvl
operator|-
name|lvl
operator|-
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|rlvl
operator|<
sizeof|sizeof
argument_list|(
name|pg_sz
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pg_sz
index|[
literal|0
index|]
argument_list|)
argument_list|,
operator|(
literal|"sizeof pg_sz lvl %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pg_sz
index|[
name|rlvl
index|]
operator|)
return|;
block|}
end_function

begin_function
name|dmar_gaddr_t
name|ctx_page_size
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|int
name|lvl
parameter_list|)
block|{
return|return
operator|(
name|pglvl_page_size
argument_list|(
name|ctx
operator|->
name|pglvl
argument_list|,
name|lvl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|calc_am
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|dmar_gaddr_t
modifier|*
name|isizep
parameter_list|)
block|{
name|dmar_gaddr_t
name|isize
decl_stmt|;
name|int
name|am
decl_stmt|;
for|for
control|(
name|am
operator|=
name|DMAR_CAP_MAMV
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
init|;
condition|;
name|am
operator|--
control|)
block|{
name|isize
operator|=
literal|1ULL
operator|<<
operator|(
name|am
operator|+
name|DMAR_PAGE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|&
operator|(
name|isize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
name|size
operator|>=
name|isize
condition|)
break|break;
if|if
condition|(
name|am
operator|==
literal|0
condition|)
break|break;
block|}
operator|*
name|isizep
operator|=
name|isize
expr_stmt|;
return|return
operator|(
name|am
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|dmar_haddr_t
name|dmar_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|haw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|dmar_tbl_pagecnt
decl_stmt|;
end_decl_stmt

begin_function
name|vm_page_t
name|dmar_pgalloc
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|zeroed
decl_stmt|;
name|zeroed
operator|=
operator|(
name|flags
operator|&
name|DMAR_PGF_ZERO
operator|)
operator|!=
literal|0
condition|?
name|VM_ALLOC_ZERO
else|:
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_NOALLOC
operator|)
operator|!=
literal|0
operator|||
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|vm_page_alloc_contig
argument_list|(
name|obj
argument_list|,
name|idx
argument_list|,
name|VM_ALLOC_NOBUSY
operator||
name|VM_ALLOC_SYSTEM
operator||
name|VM_ALLOC_NODUMP
operator||
name|zeroed
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|dmar_high
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zeroed
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|dmar_tbl_pagecnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_WAITOK
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|!=
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|!=
literal|0
condition|)
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_pgfree
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|dmar_tbl_pagecnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|dmar_map_pgtbl
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sf
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|bool
name|allocated
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|&&
operator|(
name|flags
operator|&
name|DMAR_PGF_ALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|dmar_pgalloc
argument_list|(
name|obj
argument_list|,
name|idx
argument_list|,
name|flags
operator||
name|DMAR_PGF_OBJL
argument_list|)
expr_stmt|;
name|allocated
operator|=
name|true
expr_stmt|;
block|}
else|else
name|allocated
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Sleepable allocations cannot fail. */
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_WAITOK
operator|)
operator|!=
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
operator|*
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
name|SFB_CPUPRIVATE
operator||
operator|(
operator|(
name|flags
operator|&
name|DMAR_PGF_WAITOK
operator|)
operator|==
literal|0
condition|?
name|SFB_NOWAIT
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sf
operator|==
name|NULL
condition|)
block|{
name|sched_unpin
argument_list|()
expr_stmt|;
if|if
condition|(
name|allocated
condition|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|dmar_pgfree
argument_list|(
name|obj
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|flags
operator||
name|DMAR_PGF_OBJL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_OBJL
operator|)
operator|)
operator|==
operator|(
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_OBJL
operator|)
condition|)
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_OBJL
operator|)
operator|)
operator|==
literal|0
condition|)
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|sf_buf_kva
argument_list|(
operator|*
name|sf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_unmap_pgtbl
parameter_list|(
name|struct
name|sf_buf
modifier|*
name|sf
parameter_list|)
block|{
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_flush_transl_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|DMAR_IS_COHERENT
argument_list|(
name|unit
argument_list|)
condition|)
return|return;
comment|/* 	 * If DMAR does not snoop paging structures accesses, flush 	 * CPU cache to memory. 	 */
name|pmap_invalidate_cache_range
argument_list|(
operator|(
name|uintptr_t
operator|)
name|dst
argument_list|,
operator|(
name|uintptr_t
operator|)
name|dst
operator|+
name|sz
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_flush_pte_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_pte_t
modifier|*
name|dst
parameter_list|)
block|{
name|dmar_flush_transl_to_ram
argument_list|(
name|unit
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_flush_ctx_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_ctx_entry_t
modifier|*
name|dst
parameter_list|)
block|{
name|dmar_flush_transl_to_ram
argument_list|(
name|unit
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_flush_root_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_root_entry_t
modifier|*
name|dst
parameter_list|)
block|{
name|dmar_flush_transl_to_ram
argument_list|(
name|unit
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load the root entry pointer into the hardware, busily waiting for  * the completion.  */
end_comment

begin_function
name|int
name|dmar_load_root_entry_ptr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|vm_page_t
name|root_entry
decl_stmt|;
comment|/* 	 * Access to the GCMD register must be serialized while the 	 * command is submitted. 	 */
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* VM_OBJECT_RLOCK(unit->ctx_obj); */
name|VM_OBJECT_WLOCK
argument_list|(
name|unit
operator|->
name|ctx_obj
argument_list|)
expr_stmt|;
name|root_entry
operator|=
name|vm_page_lookup
argument_list|(
name|unit
operator|->
name|ctx_obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* VM_OBJECT_RUNLOCK(unit->ctx_obj); */
name|VM_OBJECT_WUNLOCK
argument_list|(
name|unit
operator|->
name|ctx_obj
argument_list|)
expr_stmt|;
name|dmar_write8
argument_list|(
name|unit
argument_list|,
name|DMAR_RTADDR_REG
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|root_entry
argument_list|)
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|DMAR_GCMD_REG
argument_list|,
name|unit
operator|->
name|hw_gcmd
operator||
name|DMAR_GCMD_SRTP
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_GSTS_REG
argument_list|)
operator|&
name|DMAR_GSTS_RTPS
operator|)
operator|==
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Globally invalidate the context entries cache, busily waiting for  * the completion.  */
end_comment

begin_function
name|int
name|dmar_inv_ctx_glob
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
comment|/* 	 * Access to the CCMD register must be serialized while the 	 * command is submitted. 	 */
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|unit
operator|->
name|qi_enabled
argument_list|,
operator|(
literal|"QI enabled"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The DMAR_CCMD_ICC bit in the upper dword should be written 	 * after the low dword write is completed.  Amd64 	 * dmar_write8() does not have this issue, i386 dmar_write8() 	 * writes the upper dword last. 	 */
name|dmar_write8
argument_list|(
name|unit
argument_list|,
name|DMAR_CCMD_REG
argument_list|,
name|DMAR_CCMD_ICC
operator||
name|DMAR_CCMD_CIRG_GLOB
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_CCMD_REG
operator|+
literal|4
argument_list|)
operator|&
name|DMAR_CCMD_ICC32
operator|)
operator|!=
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Globally invalidate the IOTLB, busily waiting for the completion.  */
end_comment

begin_function
name|int
name|dmar_inv_iotlb_glob
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|unit
operator|->
name|qi_enabled
argument_list|,
operator|(
literal|"QI enabled"
operator|)
argument_list|)
expr_stmt|;
name|reg
operator|=
literal|16
operator|*
name|DMAR_ECAP_IRO
argument_list|(
name|unit
operator|->
name|hw_ecap
argument_list|)
expr_stmt|;
comment|/* See a comment about DMAR_CCMD_ICC in dmar_inv_ctx_glob. */
name|dmar_write8
argument_list|(
name|unit
argument_list|,
name|reg
operator|+
name|DMAR_IOTLB_REG_OFF
argument_list|,
name|DMAR_IOTLB_IVT
operator||
name|DMAR_IOTLB_IIRG_GLB
operator||
name|DMAR_IOTLB_DR
operator||
name|DMAR_IOTLB_DW
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|reg
operator|+
name|DMAR_IOTLB_REG_OFF
operator|+
literal|4
argument_list|)
operator|&
name|DMAR_IOTLB_IVT32
operator|)
operator|!=
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Flush the chipset write buffers.  See 11.1 "Write Buffer Flushing"  * in the architecture specification.  */
end_comment

begin_function
name|int
name|dmar_flush_write_bufs
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * DMAR_GCMD_WBF is only valid when CAP_RWBF is reported. 	 */
name|KASSERT
argument_list|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_RWBF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"dmar%d: no RWBF"
operator|,
name|unit
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|DMAR_GCMD_REG
argument_list|,
name|unit
operator|->
name|hw_gcmd
operator||
name|DMAR_GCMD_WBF
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_GSTS_REG
argument_list|)
operator|&
name|DMAR_GSTS_WBFS
operator|)
operator|==
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_enable_translation
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|->
name|hw_gcmd
operator||=
name|DMAR_GCMD_TE
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|DMAR_GCMD_REG
argument_list|,
name|unit
operator|->
name|hw_gcmd
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_GSTS_REG
argument_list|)
operator|&
name|DMAR_GSTS_TES
operator|)
operator|==
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_disable_translation
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|DMAR_ASSERT_LOCKED
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|->
name|hw_gcmd
operator|&=
operator|~
name|DMAR_GCMD_TE
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|DMAR_GCMD_REG
argument_list|,
name|unit
operator|->
name|hw_gcmd
argument_list|)
expr_stmt|;
comment|/* XXXKIB should have a timeout */
while|while
condition|(
operator|(
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_GSTS_REG
argument_list|)
operator|&
name|DMAR_GSTS_TES
operator|)
operator|!=
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BARRIER_F
define|\
value|u_int f_done, f_inproc, f_wakeup;	\ 						\ 	f_done = 1<< (barrier_id * 3);		\ 	f_inproc = 1<< (barrier_id * 3 + 1);	\ 	f_wakeup = 1<< (barrier_id * 3 + 2)
end_define

begin_function
name|bool
name|dmar_barrier_enter
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|u_int
name|barrier_id
parameter_list|)
block|{
name|BARRIER_F
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
name|f_done
operator|)
operator|!=
literal|0
condition|)
block|{
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
name|f_inproc
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
name|f_inproc
operator|)
operator|!=
literal|0
condition|)
block|{
name|dmar
operator|->
name|barrier_flags
operator||=
name|f_wakeup
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|dmar
operator|->
name|barrier_flags
argument_list|,
operator|&
name|dmar
operator|->
name|lock
argument_list|,
literal|0
argument_list|,
literal|"dmarb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
name|f_done
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"dmar%d barrier %d missing done"
operator|,
name|dmar
operator|->
name|unit
operator|,
name|barrier_id
operator|)
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|dmar
operator|->
name|barrier_flags
operator||=
name|f_inproc
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_barrier_exit
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|u_int
name|barrier_id
parameter_list|)
block|{
name|BARRIER_F
expr_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
operator|(
name|f_done
operator||
name|f_inproc
operator|)
operator|)
operator|==
name|f_inproc
argument_list|,
operator|(
literal|"dmar%d barrier %d missed entry"
operator|,
name|dmar
operator|->
name|unit
operator|,
name|barrier_id
operator|)
argument_list|)
expr_stmt|;
name|dmar
operator|->
name|barrier_flags
operator||=
name|f_done
expr_stmt|;
if|if
condition|(
operator|(
name|dmar
operator|->
name|barrier_flags
operator|&
name|f_wakeup
operator|)
operator|!=
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|dmar
operator|->
name|barrier_flags
argument_list|)
expr_stmt|;
name|dmar
operator|->
name|barrier_flags
operator|&=
operator|~
operator|(
name|f_inproc
operator||
name|f_wakeup
operator|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|dmar_match_verbose
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|dmar
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_dmar
argument_list|,
name|OID_AUTO
argument_list|,
name|tbl_pagecnt
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|dmar_tbl_pagecnt
argument_list|,
literal|0
argument_list|,
literal|"Count of pages used for DMAR pagetables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_dmar
argument_list|,
name|OID_AUTO
argument_list|,
name|match_verbose
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|dmar_match_verbose
argument_list|,
literal|0
argument_list|,
literal|"Verbose matching of the PCI devices to DMAR paths"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_decl_stmt
name|int
name|dmar_check_free
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw_dmar
argument_list|,
name|OID_AUTO
argument_list|,
name|check_free
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|dmar_check_free
argument_list|,
literal|0
argument_list|,
literal|"Check the GPA RBtree for free_down and free_after validity"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

