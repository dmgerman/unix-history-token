begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2015 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__X86_IOMMU_INTEL_DMAR_H
end_ifndef

begin_define
define|#
directive|define
name|__X86_IOMMU_INTEL_DMAR_H
end_define

begin_comment
comment|/* Host or physical memory address, after translation. */
end_comment

begin_typedef
typedef|typedef
name|uint64_t
name|dmar_haddr_t
typedef|;
end_typedef

begin_comment
comment|/* Guest or bus address, before translation. */
end_comment

begin_typedef
typedef|typedef
name|uint64_t
name|dmar_gaddr_t
typedef|;
end_typedef

begin_struct
struct|struct
name|dmar_qi_genseq
block|{
name|u_int
name|gen
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dmar_map_entry
block|{
name|dmar_gaddr_t
name|start
decl_stmt|;
name|dmar_gaddr_t
name|end
decl_stmt|;
name|dmar_gaddr_t
name|free_after
decl_stmt|;
comment|/* Free space after the entry */
name|dmar_gaddr_t
name|free_down
decl_stmt|;
comment|/* Max free space below the 					   current R/B tree node */
name|u_int
name|flags
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|dmar_map_entry
argument_list|)
name|dmamap_link
expr_stmt|;
comment|/* Link for dmamap entries */
name|RB_ENTRY
argument_list|(
argument|dmar_map_entry
argument_list|)
name|rb_entry
expr_stmt|;
comment|/* Links for domain entries */
name|TAILQ_ENTRY
argument_list|(
argument|dmar_map_entry
argument_list|)
name|unroll_link
expr_stmt|;
comment|/* Link for unroll after 						    dmamap_load failure */
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|struct
name|dmar_qi_genseq
name|gseq
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
name|dmar_map_entry
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|RB_PROTOTYPE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
name|dmar_map_entry
argument_list|,
name|rb_entry
argument_list|,
name|dmar_gas_cmp_entries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_PLACE
value|0x0001
end_define

begin_comment
comment|/* Fake entry */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_RMRR
value|0x0002
end_define

begin_comment
comment|/* Permanent, not linked by 					   dmamap_link */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_MAP
value|0x0004
end_define

begin_comment
comment|/* Busdma created, linked by 					   dmamap_link */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_UNMAPPED
value|0x0010
end_define

begin_comment
comment|/* No backing pages */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_QI_NF
value|0x0020
end_define

begin_comment
comment|/* qi task, do not free entry */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_READ
value|0x1000
end_define

begin_comment
comment|/* Read permitted */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_WRITE
value|0x2000
end_define

begin_comment
comment|/* Write permitted */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_SNOOP
value|0x4000
end_define

begin_comment
comment|/* Snoop */
end_comment

begin_define
define|#
directive|define
name|DMAR_MAP_ENTRY_TM
value|0x8000
end_define

begin_comment
comment|/* Transient */
end_comment

begin_comment
comment|/*  * Locking annotations:  * (u) - Protected by dmar unit lock  * (d) - Protected by domain lock  * (c) - Immutable after initialization  */
end_comment

begin_comment
comment|/*  * The domain abstraction.  Most non-constant members of the domain  * are protected by owning dmar unit lock, not by the domain lock.  * Most important, the dmar lock protects the contexts list.  *  * The domain lock protects the address map for the domain, and list  * of unload entries delayed.  *  * Page tables pages and pages content is protected by the vm object  * lock pgtbl_obj, which contains the page tables pages.  */
end_comment

begin_struct
struct|struct
name|dmar_domain
block|{
name|int
name|domain
decl_stmt|;
comment|/* (c) DID, written in context entry */
name|int
name|mgaw
decl_stmt|;
comment|/* (c) Real max address width */
name|int
name|agaw
decl_stmt|;
comment|/* (c) Adjusted guest address width */
name|int
name|pglvl
decl_stmt|;
comment|/* (c) The pagelevel */
name|int
name|awlvl
decl_stmt|;
comment|/* (c) The pagelevel as the bitmask, 					   to set in context entry */
name|dmar_gaddr_t
name|end
decl_stmt|;
comment|/* (c) Highest address + 1 in 					   the guest AS */
name|u_int
name|ctx_cnt
decl_stmt|;
comment|/* (u) Number of contexts owned */
name|u_int
name|refs
decl_stmt|;
comment|/* (u) Refs, including ctx */
name|struct
name|dmar_unit
modifier|*
name|dmar
decl_stmt|;
comment|/* (c) */
name|struct
name|mtx
name|lock
decl_stmt|;
comment|/* (c) */
name|LIST_ENTRY
argument_list|(
argument|dmar_domain
argument_list|)
name|link
expr_stmt|;
comment|/* (u) Member in the dmar list */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|dmar_ctx
argument_list|)
name|contexts
expr_stmt|;
comment|/* (u) */
name|vm_object_t
name|pgtbl_obj
decl_stmt|;
comment|/* (c) Page table pages */
name|u_int
name|flags
decl_stmt|;
comment|/* (u) */
name|u_int
name|entries_cnt
decl_stmt|;
comment|/* (d) */
name|struct
name|dmar_gas_entries_tree
name|rb_root
decl_stmt|;
comment|/* (d) */
name|struct
name|dmar_map_entries_tailq
name|unload_entries
decl_stmt|;
comment|/* (d) Entries to 							 unload */
name|struct
name|dmar_map_entry
modifier|*
name|first_place
decl_stmt|,
modifier|*
name|last_place
decl_stmt|;
comment|/* (d) */
name|struct
name|task
name|unload_task
decl_stmt|;
comment|/* (c) */
name|u_int
name|batch_no
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dmar_ctx
block|{
name|struct
name|bus_dma_tag_dmar
name|ctx_tag
decl_stmt|;
comment|/* (c) Root tag */
name|uint16_t
name|rid
decl_stmt|;
comment|/* (c) pci RID */
name|uint64_t
name|last_fault_rec
index|[
literal|2
index|]
decl_stmt|;
comment|/* Last fault reported */
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
comment|/* (c) */
name|LIST_ENTRY
argument_list|(
argument|dmar_ctx
argument_list|)
name|link
expr_stmt|;
comment|/* (u) Member in the domain list */
name|u_int
name|refs
decl_stmt|;
comment|/* (u) References from tags */
name|u_int
name|flags
decl_stmt|;
comment|/* (u) */
name|u_long
name|loads
decl_stmt|;
comment|/* atomic updates, for stat only */
name|u_long
name|unloads
decl_stmt|;
comment|/* same */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DMAR_DOMAIN_GAS_INITED
value|0x0001
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_PGTBL_INITED
value|0x0002
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_IDMAP
value|0x0010
end_define

begin_comment
comment|/* Domain uses identity 						   page table */
end_comment

begin_define
define|#
directive|define
name|DMAR_DOMAIN_RMRR
value|0x0020
end_define

begin_comment
comment|/* Domain contains RMRR entry, 						   cannot be turned off */
end_comment

begin_comment
comment|/* struct dmar_ctx flags */
end_comment

begin_define
define|#
directive|define
name|DMAR_CTX_FAULTED
value|0x0001
end_define

begin_comment
comment|/* Fault was reported, 					   last_fault_rec is valid */
end_comment

begin_define
define|#
directive|define
name|DMAR_CTX_DISABLED
value|0x0002
end_define

begin_comment
comment|/* Device is disabled, the 					   ephemeral reference is kept 					   to prevent context destruction */
end_comment

begin_define
define|#
directive|define
name|DMAR_DOMAIN_PGLOCK
parameter_list|(
name|dom
parameter_list|)
value|VM_OBJECT_WLOCK((dom)->pgtbl_obj)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_PGTRYLOCK
parameter_list|(
name|dom
parameter_list|)
value|VM_OBJECT_TRYWLOCK((dom)->pgtbl_obj)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_PGUNLOCK
parameter_list|(
name|dom
parameter_list|)
value|VM_OBJECT_WUNLOCK((dom)->pgtbl_obj)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_ASSERT_PGLOCKED
parameter_list|(
name|dom
parameter_list|)
define|\
value|VM_OBJECT_ASSERT_WLOCKED((dom)->pgtbl_obj)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_LOCK
parameter_list|(
name|dom
parameter_list|)
value|mtx_lock(&(dom)->lock)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_UNLOCK
parameter_list|(
name|dom
parameter_list|)
value|mtx_unlock(&(dom)->lock)
end_define

begin_define
define|#
directive|define
name|DMAR_DOMAIN_ASSERT_LOCKED
parameter_list|(
name|dom
parameter_list|)
value|mtx_assert(&(dom)->lock, MA_OWNED)
end_define

begin_struct
struct|struct
name|dmar_msi_data
block|{
name|int
name|irq
decl_stmt|;
name|int
name|irq_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|irq_res
decl_stmt|;
name|void
modifier|*
name|intr_handle
decl_stmt|;
name|int
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
name|msi_data_reg
decl_stmt|;
name|int
name|msi_addr_reg
decl_stmt|;
name|int
name|msi_uaddr_reg
decl_stmt|;
name|void
function_decl|(
modifier|*
name|enable_intr
function_decl|)
parameter_list|(
name|struct
name|dmar_unit
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|disable_intr
function_decl|)
parameter_list|(
name|struct
name|dmar_unit
modifier|*
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DMAR_INTR_FAULT
value|0
end_define

begin_define
define|#
directive|define
name|DMAR_INTR_QI
value|1
end_define

begin_define
define|#
directive|define
name|DMAR_INTR_TOTAL
value|2
end_define

begin_struct
struct|struct
name|dmar_unit
block|{
name|device_t
name|dev
decl_stmt|;
name|int
name|unit
decl_stmt|;
name|uint16_t
name|segment
decl_stmt|;
name|uint64_t
name|base
decl_stmt|;
comment|/* Resources */
name|int
name|reg_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|regs
decl_stmt|;
name|struct
name|dmar_msi_data
name|intrs
index|[
name|DMAR_INTR_TOTAL
index|]
decl_stmt|;
comment|/* Hardware registers cache */
name|uint32_t
name|hw_ver
decl_stmt|;
name|uint64_t
name|hw_cap
decl_stmt|;
name|uint64_t
name|hw_ecap
decl_stmt|;
name|uint32_t
name|hw_gcmd
decl_stmt|;
comment|/* Data for being a dmar */
name|struct
name|mtx
name|lock
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|dmar_domain
argument_list|)
name|domains
expr_stmt|;
name|struct
name|unrhdr
modifier|*
name|domids
decl_stmt|;
name|vm_object_t
name|ctx_obj
decl_stmt|;
name|u_int
name|barrier_flags
decl_stmt|;
comment|/* Fault handler data */
name|struct
name|mtx
name|fault_lock
decl_stmt|;
name|uint64_t
modifier|*
name|fault_log
decl_stmt|;
name|int
name|fault_log_head
decl_stmt|;
name|int
name|fault_log_tail
decl_stmt|;
name|int
name|fault_log_size
decl_stmt|;
name|struct
name|task
name|fault_task
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|fault_taskqueue
decl_stmt|;
comment|/* QI */
name|int
name|qi_enabled
decl_stmt|;
name|vm_offset_t
name|inv_queue
decl_stmt|;
name|vm_size_t
name|inv_queue_size
decl_stmt|;
name|uint32_t
name|inv_queue_avail
decl_stmt|;
name|uint32_t
name|inv_queue_tail
decl_stmt|;
specifier|volatile
name|uint32_t
name|inv_waitd_seq_hw
decl_stmt|;
comment|/* hw writes there on wait 					       descr completion */
name|uint64_t
name|inv_waitd_seq_hw_phys
decl_stmt|;
name|uint32_t
name|inv_waitd_seq
decl_stmt|;
comment|/* next sequence number to use for wait descr */
name|u_int
name|inv_waitd_gen
decl_stmt|;
comment|/* seq number generation AKA seq overflows */
name|u_int
name|inv_seq_waiters
decl_stmt|;
comment|/* count of waiters for seq */
name|u_int
name|inv_queue_full
decl_stmt|;
comment|/* informational counter */
comment|/* IR */
name|int
name|ir_enabled
decl_stmt|;
name|vm_paddr_t
name|irt_phys
decl_stmt|;
name|dmar_irte_t
modifier|*
name|irt
decl_stmt|;
name|u_int
name|irte_cnt
decl_stmt|;
name|vmem_t
modifier|*
name|irtids
decl_stmt|;
comment|/* Delayed freeing of map entries queue processing */
name|struct
name|dmar_map_entries_tailq
name|tlb_flush_entries
decl_stmt|;
name|struct
name|task
name|qi_task
decl_stmt|;
name|struct
name|taskqueue
modifier|*
name|qi_taskqueue
decl_stmt|;
comment|/* Busdma delayed map load */
name|struct
name|task
name|dmamap_load_task
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|bus_dmamap_dmar
argument_list|)
name|delayed_maps
expr_stmt|;
name|struct
name|taskqueue
modifier|*
name|delayed_taskqueue
decl_stmt|;
name|int
name|dma_enabled
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DMAR_LOCK
parameter_list|(
name|dmar
parameter_list|)
value|mtx_lock(&(dmar)->lock)
end_define

begin_define
define|#
directive|define
name|DMAR_UNLOCK
parameter_list|(
name|dmar
parameter_list|)
value|mtx_unlock(&(dmar)->lock)
end_define

begin_define
define|#
directive|define
name|DMAR_ASSERT_LOCKED
parameter_list|(
name|dmar
parameter_list|)
value|mtx_assert(&(dmar)->lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|DMAR_FAULT_LOCK
parameter_list|(
name|dmar
parameter_list|)
value|mtx_lock_spin(&(dmar)->fault_lock)
end_define

begin_define
define|#
directive|define
name|DMAR_FAULT_UNLOCK
parameter_list|(
name|dmar
parameter_list|)
value|mtx_unlock_spin(&(dmar)->fault_lock)
end_define

begin_define
define|#
directive|define
name|DMAR_FAULT_ASSERT_LOCKED
parameter_list|(
name|dmar
parameter_list|)
value|mtx_assert(&(dmar)->fault_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|DMAR_IS_COHERENT
parameter_list|(
name|dmar
parameter_list|)
value|(((dmar)->hw_ecap& DMAR_ECAP_C) != 0)
end_define

begin_define
define|#
directive|define
name|DMAR_HAS_QI
parameter_list|(
name|dmar
parameter_list|)
value|(((dmar)->hw_ecap& DMAR_ECAP_QI) != 0)
end_define

begin_define
define|#
directive|define
name|DMAR_X2APIC
parameter_list|(
name|dmar
parameter_list|)
define|\
value|(x2apic_mode&& ((dmar)->hw_ecap& DMAR_ECAP_EIM) != 0)
end_define

begin_comment
comment|/* Barrier ids */
end_comment

begin_define
define|#
directive|define
name|DMAR_BARRIER_RMRR
value|0
end_define

begin_define
define|#
directive|define
name|DMAR_BARRIER_USEQ
value|1
end_define

begin_function_decl
name|struct
name|dmar_unit
modifier|*
name|dmar_find
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_unit
modifier|*
name|dmar_find_hpet
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_unit
modifier|*
name|dmar_find_ioapic
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|u_int
name|dmar_nd2mask
parameter_list|(
name|u_int
name|nd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|dmar_pglvl_supported
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|pglvl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|domain_set_agaw
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|int
name|mgaw
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_maxaddr2mgaw
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_gaddr_t
name|maxaddr
parameter_list|,
name|bool
name|allow_less
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_pindex_t
name|pglvl_max_pages
parameter_list|(
name|int
name|pglvl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|domain_is_sp_lvl
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|int
name|lvl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dmar_gaddr_t
name|pglvl_page_size
parameter_list|(
name|int
name|total_pglvl
parameter_list|,
name|int
name|lvl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|dmar_gaddr_t
name|domain_page_size
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|int
name|lvl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|calc_am
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|dmar_gaddr_t
modifier|*
name|isizep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|vm_page
modifier|*
name|dmar_pgalloc
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_pgfree
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|dmar_map_pgtbl
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_unmap_pgtbl
parameter_list|(
name|struct
name|sf_buf
modifier|*
name|sf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_load_root_entry_ptr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_inv_ctx_glob
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_inv_iotlb_glob
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_flush_write_bufs
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_flush_pte_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_pte_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_flush_ctx_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_ctx_entry_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_flush_root_to_ram
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|dmar_root_entry_t
modifier|*
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_enable_translation
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_disable_translation
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_load_irt_ptr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_enable_ir
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_disable_ir
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|bool
name|dmar_barrier_enter
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|u_int
name|barrier_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_barrier_exit
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|u_int
name|barrier_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint64_t
name|dmar_get_timeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_update_timeout
parameter_list|(
name|uint64_t
name|newval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_fault_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_enable_fault_intr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_disable_fault_intr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_init_fault_log
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_fini_fault_log
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_qi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_enable_qi_intr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_disable_qi_intr
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_init_qi
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_fini_qi
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_qi_invalidate_locked
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|start
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|struct
name|dmar_qi_genseq
modifier|*
name|psec
parameter_list|,
name|bool
name|emit_wait
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_qi_invalidate_ctx_glob_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_qi_invalidate_iotlb_glob_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_qi_invalidate_iec_glob
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_qi_invalidate_iec
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|u_int
name|start
parameter_list|,
name|u_int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|vm_object_t
name|domain_get_idmap_pgtbl
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|maxaddr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|put_idmap_pgtbl
parameter_list|(
name|vm_object_t
name|obj
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|domain_map_buf
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|uint64_t
name|pflags
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|domain_unmap_buf
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|domain_flush_iotlb_sync
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|domain_alloc_pgtbl
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|domain_free_pgtbl
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_ctx
modifier|*
name|dmar_instantiate_ctx
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|bool
name|rmrr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_ctx
modifier|*
name|dmar_get_ctx_for_dev
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|bool
name|id_mapped
parameter_list|,
name|bool
name|rmrr_init
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_move_ctx_to_domain
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_free_ctx_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_free_ctx
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_ctx
modifier|*
name|dmar_find_ctx_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|uint16_t
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_domain_unload_entry
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|bool
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_domain_unload
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entries_tailq
modifier|*
name|entries
parameter_list|,
name|bool
name|cansleep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_domain_free_entry
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|bool
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_init_busdma
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_fini_busdma
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|device_t
name|dmar_get_requester
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_gas_init_domain
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_gas_fini_domain
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|dmar_map_entry
modifier|*
name|dmar_gas_alloc_entry
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|u_int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_gas_free_entry
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_gas_free_space
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_gas_map
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
specifier|const
name|struct
name|bus_dma_tag_common
modifier|*
name|common
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_int
name|eflags
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
modifier|*
name|res
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_gas_free_region
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_gas_map_region
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|u_int
name|eflags
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_gas_reserve_region
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|dmar_gaddr_t
name|start
parameter_list|,
name|dmar_gaddr_t
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_dev_parse_rmrr
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_map_entries_tailq
modifier|*
name|rmrr_entries
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_instantiate_rmrr_ctxs
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_quirks_post_ident
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_quirks_pre_use
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|dmar_init_irt
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dmar_fini_irt
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|DMAR_GM_CANWAIT
value|0x0001
end_define

begin_define
define|#
directive|define
name|DMAR_GM_CANSPLIT
value|0x0002
end_define

begin_define
define|#
directive|define
name|DMAR_PGF_WAITOK
value|0x0001
end_define

begin_define
define|#
directive|define
name|DMAR_PGF_ZERO
value|0x0002
end_define

begin_define
define|#
directive|define
name|DMAR_PGF_ALLOC
value|0x0004
end_define

begin_define
define|#
directive|define
name|DMAR_PGF_NOALLOC
value|0x0008
end_define

begin_define
define|#
directive|define
name|DMAR_PGF_OBJL
value|0x0010
end_define

begin_decl_stmt
specifier|extern
name|dmar_haddr_t
name|dmar_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|haw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dmar_tbl_pagecnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dmar_match_verbose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dmar_batch_coalesce
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|dmar_check_free
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|uint32_t
name|dmar_read4
parameter_list|(
specifier|const
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
return|return
operator|(
name|bus_read_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|dmar_read8
parameter_list|(
specifier|const
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
name|uint32_t
name|high
decl_stmt|,
name|low
decl_stmt|;
name|low
operator|=
name|bus_read_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|high
operator|=
name|bus_read_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|low
operator||
operator|(
operator|(
name|uint64_t
operator|)
name|high
operator|<<
literal|32
operator|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|bus_read_8
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dmar_write4
parameter_list|(
specifier|const
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|reg
operator|!=
name|DMAR_GCMD_REG
operator|||
operator|(
name|val
operator|&
name|DMAR_GCMD_TE
operator|)
operator|==
operator|(
name|unit
operator|->
name|hw_gcmd
operator|&
name|DMAR_GCMD_TE
operator|)
argument_list|,
operator|(
literal|"dmar%d clearing TE 0x%08x 0x%08x"
operator|,
name|unit
operator|->
name|unit
operator|,
name|unit
operator|->
name|hw_gcmd
operator|,
name|val
operator|)
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dmar_write8
parameter_list|(
specifier|const
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|reg
operator|!=
name|DMAR_GCMD_REG
argument_list|,
operator|(
literal|"8byte GCMD write"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|uint32_t
name|high
decl_stmt|,
name|low
decl_stmt|;
name|low
operator|=
name|val
expr_stmt|;
name|high
operator|=
name|val
operator|>>
literal|32
expr_stmt|;
name|bus_write_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
operator|+
literal|4
argument_list|,
name|high
argument_list|)
expr_stmt|;
else|#
directive|else
name|bus_write_8
argument_list|(
name|unit
operator|->
name|regs
argument_list|,
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * dmar_pte_store and dmar_pte_clear ensure that on i386, 32bit writes  * are issued in the correct order.  For store, the lower word,  * containing the P or R and W bits, is set only after the high word  * is written.  For clear, the P bit is cleared first, then the high  * word is cleared.  *  * dmar_pte_update updates the pte.  For amd64, the update is atomic.  * For i386, it first disables the entry by clearing the word  * containing the P bit, and then defer to dmar_pte_store.  The locked  * cmpxchg8b is probably available on any machine having DMAR support,  * but interrupt translation table may be mapped uncached.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|dmar_pte_store1
parameter_list|(
specifier|volatile
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
specifier|volatile
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|uint32_t
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|hi
operator|=
name|val
operator|>>
literal|32
expr_stmt|;
name|lo
operator|=
name|val
expr_stmt|;
name|p
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
name|hi
expr_stmt|;
operator|*
name|p
operator|=
name|lo
expr_stmt|;
else|#
directive|else
operator|*
name|dst
operator|=
name|val
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dmar_pte_store
parameter_list|(
specifier|volatile
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|*
name|dst
operator|==
literal|0
argument_list|,
operator|(
literal|"used pte %p oldval %jx newval %jx"
operator|,
name|dst
operator|,
operator|(
name|uintmax_t
operator|)
operator|*
name|dst
operator|,
operator|(
name|uintmax_t
operator|)
name|val
operator|)
argument_list|)
expr_stmt|;
name|dmar_pte_store1
argument_list|(
name|dst
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dmar_pte_update
parameter_list|(
specifier|volatile
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|uint64_t
name|val
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
specifier|volatile
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|dmar_pte_store1
argument_list|(
name|dst
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|dmar_pte_clear
parameter_list|(
specifier|volatile
name|uint64_t
modifier|*
name|dst
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__i386__
specifier|volatile
name|uint32_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
specifier|volatile
name|uint32_t
operator|*
operator|)
name|dst
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
else|#
directive|else
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|dmar_test_boundary
parameter_list|(
name|dmar_gaddr_t
name|start
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|dmar_gaddr_t
name|boundary
parameter_list|)
block|{
if|if
condition|(
name|boundary
operator|==
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|start
operator|+
name|size
operator|<=
operator|(
operator|(
name|start
operator|+
name|boundary
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|timespec
name|dmar_hw_timeout
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DMAR_WAIT_UNTIL
parameter_list|(
name|cond
parameter_list|)
define|\
value|{								\ 	struct timespec last, curr;				\ 	bool forever;						\ 								\ 	if (dmar_hw_timeout.tv_sec == 0&&			\ 	    dmar_hw_timeout.tv_nsec == 0) {			\ 		forever = true;					\ 	} else {						\ 		forever = false;				\ 		nanouptime(&curr);				\ 		last = curr;					\ 		timespecadd(&last,&dmar_hw_timeout);		\ 	}							\ 	for (;;) {						\ 		if (cond) {					\ 			error = 0;				\ 			break;					\ 		}						\ 		nanouptime(&curr);				\ 		if (!forever&& timespeccmp(&last,&curr,<)) {	\ 			error = ETIMEDOUT;			\ 			break;					\ 		}						\ 		cpu_spinwait();					\ 	}							\ }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|TD_PREP_PINNED_ASSERT
define|\
value|int old_td_pinned;						\ 	old_td_pinned = curthread->td_pinned
end_define

begin_define
define|#
directive|define
name|TD_PINNED_ASSERT
define|\
value|KASSERT(curthread->td_pinned == old_td_pinned,			\ 	    ("pin count leak: %d %d %s:%d", curthread->td_pinned,	\ 	    old_td_pinned, __FILE__, __LINE__))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TD_PREP_PINNED_ASSERT
end_define

begin_define
define|#
directive|define
name|TD_PINNED_ASSERT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

