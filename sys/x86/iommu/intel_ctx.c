begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DMAR_CTX
argument_list|,
literal|"dmar_ctx"
argument_list|,
literal|"Intel DMAR Context"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DMAR_DOMAIN
argument_list|,
literal|"dmar_dom"
argument_list|,
literal|"Intel DMAR Domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|dmar_domain_unload_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmar_unref_domain_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmar_domain_destroy
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|dmar_ensure_ctx_page
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|int
name|bus
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|dmar_root_entry_t
modifier|*
name|re
decl_stmt|;
name|vm_page_t
name|ctxm
decl_stmt|;
comment|/* 	 * Allocated context page must be linked. 	 */
name|ctxm
operator|=
name|dmar_pgalloc
argument_list|(
name|dmar
operator|->
name|ctx_obj
argument_list|,
literal|1
operator|+
name|bus
argument_list|,
name|DMAR_PGF_NOALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctxm
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * Page not present, allocate and link.  Note that other 	 * thread might execute this sequence in parallel.  This 	 * should be safe, because the context entries written by both 	 * threads are equal. 	 */
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
name|ctxm
operator|=
name|dmar_pgalloc
argument_list|(
name|dmar
operator|->
name|ctx_obj
argument_list|,
literal|1
operator|+
name|bus
argument_list|,
name|DMAR_PGF_ZERO
operator||
name|DMAR_PGF_WAITOK
argument_list|)
expr_stmt|;
name|re
operator|=
name|dmar_map_pgtbl
argument_list|(
name|dmar
operator|->
name|ctx_obj
argument_list|,
literal|0
argument_list|,
name|DMAR_PGF_NOALLOC
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|re
operator|+=
name|bus
expr_stmt|;
name|dmar_pte_store
argument_list|(
operator|&
name|re
operator|->
name|r1
argument_list|,
name|DMAR_ROOT_R1_P
operator||
operator|(
name|DMAR_ROOT_R1_CTP_MASK
operator|&
name|VM_PAGE_TO_PHYS
argument_list|(
name|ctxm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|dmar_flush_root_to_ram
argument_list|(
name|dmar
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|dmar_ctx_entry_t
modifier|*
name|dmar_map_ctx_entry
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sfp
parameter_list|)
block|{
name|dmar_ctx_entry_t
modifier|*
name|ctxp
decl_stmt|;
name|ctxp
operator|=
name|dmar_map_pgtbl
argument_list|(
name|ctx
operator|->
name|domain
operator|->
name|dmar
operator|->
name|ctx_obj
argument_list|,
literal|1
operator|+
name|PCI_RID2BUS
argument_list|(
name|ctx
operator|->
name|rid
argument_list|)
argument_list|,
name|DMAR_PGF_NOALLOC
operator||
name|DMAR_PGF_WAITOK
argument_list|,
name|sfp
argument_list|)
expr_stmt|;
name|ctxp
operator|+=
name|ctx
operator|->
name|rid
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
name|ctxp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctx_tag_init
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|bus_addr_t
name|maxaddr
decl_stmt|;
name|maxaddr
operator|=
name|MIN
argument_list|(
name|ctx
operator|->
name|domain
operator|->
name|end
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|ref_count
operator|=
literal|1
expr_stmt|;
comment|/* Prevent free */
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|impl
operator|=
operator|&
name|bus_dma_dmar_impl
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|boundary
operator|=
name|PCI_DMA_BOUNDARY
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|lowaddr
operator|=
name|maxaddr
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|highaddr
operator|=
name|maxaddr
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|maxsize
operator|=
name|maxaddr
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|nsegments
operator|=
name|BUS_SPACE_UNRESTRICTED
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|common
operator|.
name|maxsegsz
operator|=
name|maxaddr
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
operator|=
name|dev
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctx_id_entry_init
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_ctx_entry_t
modifier|*
name|ctxp
parameter_list|,
name|bool
name|move
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|vm_page_t
name|ctx_root
decl_stmt|;
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|unit
operator|=
name|domain
operator|->
name|dmar
expr_stmt|;
name|KASSERT
argument_list|(
name|move
operator|||
operator|(
name|ctxp
operator|->
name|ctx1
operator|==
literal|0
operator|&&
name|ctxp
operator|->
name|ctx2
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"dmar%d: initialized ctx entry %d:%d:%d 0x%jx 0x%jx"
operator|,
name|unit
operator|->
name|unit
operator|,
name|pci_get_bus
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
operator|,
name|ctxp
operator|->
name|ctx1
operator|,
name|ctxp
operator|->
name|ctx2
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * For update due to move, the store is not atomic.  It is 	 * possible that DMAR read upper doubleword, while low 	 * doubleword is not yet updated.  The domain id is stored in 	 * the upper doubleword, while the table pointer in the lower. 	 * 	 * There is no good solution, for the same reason it is wrong 	 * to clear P bit in the ctx entry for update. 	 */
name|dmar_pte_store1
argument_list|(
operator|&
name|ctxp
operator|->
name|ctx2
argument_list|,
name|DMAR_CTX2_DID
argument_list|(
name|domain
operator|->
name|domain
argument_list|)
operator||
name|domain
operator|->
name|awlvl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|domain
operator|->
name|flags
operator|&
name|DMAR_DOMAIN_IDMAP
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|unit
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_PT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|domain
operator|->
name|pgtbl_obj
operator|==
name|NULL
argument_list|,
operator|(
literal|"ctx %p non-null pgtbl_obj"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|dmar_pte_store1
argument_list|(
operator|&
name|ctxp
operator|->
name|ctx1
argument_list|,
name|DMAR_CTX1_T_PASS
operator||
name|DMAR_CTX1_P
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ctx_root
operator|=
name|dmar_pgalloc
argument_list|(
name|domain
operator|->
name|pgtbl_obj
argument_list|,
literal|0
argument_list|,
name|DMAR_PGF_NOALLOC
argument_list|)
expr_stmt|;
name|dmar_pte_store1
argument_list|(
operator|&
name|ctxp
operator|->
name|ctx1
argument_list|,
name|DMAR_CTX1_T_UNTR
operator||
operator|(
name|DMAR_CTX1_ASR_MASK
operator|&
name|VM_PAGE_TO_PHYS
argument_list|(
name|ctx_root
argument_list|)
operator|)
operator||
name|DMAR_CTX1_P
argument_list|)
expr_stmt|;
block|}
name|dmar_flush_ctx_to_ram
argument_list|(
name|unit
argument_list|,
name|ctxp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_flush_for_ctx_entry
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 	 * If dmar declares Caching Mode as Set, follow 11.5 "Caching 	 * Mode Consideration" and do the (global) invalidation of the 	 * negative TLB entries. 	 */
if|if
condition|(
operator|(
name|dmar
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_CM
operator|)
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dmar
operator|->
name|qi_enabled
condition|)
block|{
name|dmar_qi_invalidate_ctx_glob_locked
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmar
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_DI
operator|)
operator|!=
literal|0
operator|||
name|force
condition|)
name|dmar_qi_invalidate_iotlb_glob_locked
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|dmar_inv_ctx_glob
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|(
name|dmar
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_DI
operator|)
operator|!=
literal|0
operator|||
name|force
operator|)
condition|)
name|error
operator|=
name|dmar_inv_iotlb_glob
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|domain_init_rmrr
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dmar_map_entries_tailq
name|rmrr_entries
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry1
decl_stmt|;
name|vm_page_t
modifier|*
name|ma
decl_stmt|;
name|dmar_gaddr_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|vm_pindex_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|error1
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rmrr_entries
argument_list|)
expr_stmt|;
name|dmar_dev_parse_rmrr
argument_list|(
name|domain
argument_list|,
name|dev
argument_list|,
operator|&
name|rmrr_entries
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&rmrr_entries
argument_list|,
argument|unroll_link
argument_list|,
argument|entry1
argument_list|)
block|{
comment|/* 		 * VT-d specification requires that the start of an 		 * RMRR entry is 4k-aligned.  Buggy BIOSes put 		 * anything into the start and end fields.  Truncate 		 * and round as neccesary. 		 * 		 * We also allow the overlapping RMRR entries, see 		 * dmar_gas_alloc_region(). 		 */
name|start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|end
operator|=
name|entry
operator|->
name|end
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|trunc_page
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|round_page
argument_list|(
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|start
operator|==
name|entry
operator|->
name|end
condition|)
block|{
comment|/* Workaround for some AMI (?) BIOSes */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"BIOS bug: dmar%d RMRR "
literal|"region (%jx, %jx) corrected\n"
argument_list|,
name|domain
operator|->
name|dmar
operator|->
name|unit
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
name|entry
operator|->
name|end
operator|+=
name|DMAR_PAGE_SIZE
operator|*
literal|0x20
expr_stmt|;
block|}
name|size
operator|=
name|OFF_TO_IDX
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
name|ma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
operator|*
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|ma
index|[
name|i
index|]
operator|=
name|vm_page_getfake
argument_list|(
name|entry
operator|->
name|start
operator|+
name|PAGE_SIZE
operator|*
name|i
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
block|}
name|error1
operator|=
name|dmar_gas_map_region
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|,
name|DMAR_MAP_ENTRY_READ
operator||
name|DMAR_MAP_ENTRY_WRITE
argument_list|,
name|DMAR_GM_CANWAIT
argument_list|,
name|ma
argument_list|)
expr_stmt|;
comment|/* 		 * Non-failed RMRR entries are owned by context rb 		 * tree.  Get rid of the failed entry, but do not stop 		 * the loop.  Rest of the parsed RMRR entries are 		 * loaded and removed on the context destruction. 		 */
if|if
condition|(
name|error1
operator|==
literal|0
operator|&&
name|entry
operator|->
name|end
operator|!=
name|entry
operator|->
name|start
condition|)
block|{
name|DMAR_LOCK
argument_list|(
name|domain
operator|->
name|dmar
argument_list|)
expr_stmt|;
name|domain
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* XXXKIB prevent free */
name|domain
operator|->
name|flags
operator||=
name|DMAR_DOMAIN_RMRR
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|domain
operator|->
name|dmar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|error1
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"dmar%d failed to map RMRR region (%jx, %jx) %d\n"
argument_list|,
name|domain
operator|->
name|dmar
operator|->
name|unit
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|error1
argument_list|)
expr_stmt|;
name|error
operator|=
name|error1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rmrr_entries
argument_list|,
name|entry
argument_list|,
name|unroll_link
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|vm_page_putfake
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ma
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dmar_domain
modifier|*
name|dmar_domain_alloc
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|bool
name|id_mapped
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|,
name|mgaw
decl_stmt|;
name|id
operator|=
name|alloc_unr
argument_list|(
name|dmar
operator|->
name|domids
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|domain
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|domain
argument_list|)
argument_list|,
name|M_DMAR_DOMAIN
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|domain
operator|->
name|domain
operator|=
name|id
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|domain
operator|->
name|contexts
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|domain
operator|->
name|rb_root
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|domain
operator|->
name|unload_entries
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|domain
operator|->
name|unload_task
argument_list|,
literal|0
argument_list|,
name|dmar_domain_unload_task
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|domain
operator|->
name|lock
argument_list|,
literal|"dmardom"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|domain
operator|->
name|dmar
operator|=
name|dmar
expr_stmt|;
comment|/* 	 * For now, use the maximal usable physical address of the 	 * installed memory to calculate the mgaw on id_mapped domain. 	 * It is useful for the identity mapping, and less so for the 	 * virtualized bus address space. 	 */
name|domain
operator|->
name|end
operator|=
name|id_mapped
condition|?
name|ptoa
argument_list|(
name|Maxmem
argument_list|)
else|:
name|BUS_SPACE_MAXADDR
expr_stmt|;
name|mgaw
operator|=
name|dmar_maxaddr2mgaw
argument_list|(
name|dmar
argument_list|,
name|domain
operator|->
name|end
argument_list|,
operator|!
name|id_mapped
argument_list|)
expr_stmt|;
name|error
operator|=
name|domain_set_agaw
argument_list|(
name|domain
argument_list|,
name|mgaw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|id_mapped
condition|)
comment|/* Use all supported address space for remapping. */
name|domain
operator|->
name|end
operator|=
literal|1ULL
operator|<<
operator|(
name|domain
operator|->
name|agaw
operator|-
literal|1
operator|)
expr_stmt|;
name|dmar_gas_init_domain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|id_mapped
condition|)
block|{
if|if
condition|(
operator|(
name|dmar
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_PT
operator|)
operator|==
literal|0
condition|)
block|{
name|domain
operator|->
name|pgtbl_obj
operator|=
name|domain_get_idmap_pgtbl
argument_list|(
name|domain
argument_list|,
name|domain
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
name|domain
operator|->
name|flags
operator||=
name|DMAR_DOMAIN_IDMAP
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|domain_alloc_pgtbl
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* Disable local apic region access */
name|error
operator|=
name|dmar_gas_reserve_region
argument_list|(
name|domain
argument_list|,
literal|0xfee00000
argument_list|,
literal|0xfeefffff
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
operator|(
name|domain
operator|)
return|;
name|fail
label|:
name|dmar_domain_destroy
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dmar_ctx
modifier|*
name|dmar_ctx_alloc
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|uint16_t
name|rid
parameter_list|)
block|{
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|,
name|M_DMAR_CTX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|ctx
operator|->
name|rid
operator|=
name|rid
expr_stmt|;
name|ctx
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_ctx_link
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|domain
operator|->
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|refs
operator|>=
name|domain
operator|->
name|ctx_cnt
argument_list|,
operator|(
literal|"dom %p ref underflow %d %d"
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|,
name|domain
operator|->
name|ctx_cnt
operator|)
argument_list|)
expr_stmt|;
name|domain
operator|->
name|refs
operator|++
expr_stmt|;
name|domain
operator|->
name|ctx_cnt
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|domain
operator|->
name|contexts
argument_list|,
name|ctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_ctx_unlink
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|domain
operator|->
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|refs
operator|>
literal|0
argument_list|,
operator|(
literal|"domain %p ctx dtr refs %d"
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|ctx_cnt
operator|>=
name|domain
operator|->
name|refs
argument_list|,
operator|(
literal|"domain %p ctx dtr refs %d ctx_cnt %d"
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|,
name|domain
operator|->
name|ctx_cnt
operator|)
argument_list|)
expr_stmt|;
name|domain
operator|->
name|refs
operator|--
expr_stmt|;
name|domain
operator|->
name|ctx_cnt
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ctx
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_domain_destroy
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|domain
operator|->
name|unload_entries
argument_list|)
argument_list|,
operator|(
literal|"unfinished unloads %p"
operator|,
name|domain
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|domain
operator|->
name|contexts
argument_list|)
argument_list|,
operator|(
literal|"destroying dom %p with contexts"
operator|,
name|domain
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|ctx_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"destroying dom %p with ctx_cnt %d"
operator|,
name|domain
operator|,
name|domain
operator|->
name|ctx_cnt
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|refs
operator|==
literal|0
argument_list|,
operator|(
literal|"destroying dom %p with refs %d"
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|domain
operator|->
name|flags
operator|&
name|DMAR_DOMAIN_GAS_INITED
operator|)
operator|!=
literal|0
condition|)
block|{
name|DMAR_DOMAIN_LOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|dmar_gas_fini_domain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|DMAR_DOMAIN_UNLOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|domain
operator|->
name|flags
operator|&
name|DMAR_DOMAIN_PGTBL_INITED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|domain
operator|->
name|pgtbl_obj
operator|!=
name|NULL
condition|)
name|DMAR_DOMAIN_PGLOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|domain_free_pgtbl
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|domain
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|domain
operator|->
name|dmar
operator|->
name|domids
argument_list|,
name|domain
operator|->
name|domain
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|domain
argument_list|,
name|M_DMAR_DOMAIN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|dmar_ctx
modifier|*
name|dmar_get_ctx_for_dev
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|rid
parameter_list|,
name|bool
name|id_mapped
parameter_list|,
name|bool
name|rmrr_init
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|,
modifier|*
name|domain1
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|,
modifier|*
name|ctx1
decl_stmt|;
name|dmar_ctx_entry_t
modifier|*
name|ctxp
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|bus
decl_stmt|,
name|slot
decl_stmt|,
name|func
decl_stmt|,
name|error
decl_stmt|;
name|bool
name|enable
decl_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|slot
operator|=
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|func
operator|=
name|pci_get_function
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|enable
operator|=
name|false
expr_stmt|;
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|dmar_find_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Perform the allocations which require sleep or have 		 * higher chance to succeed if the sleep is allowed. 		 */
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|dmar_ensure_ctx_page
argument_list|(
name|dmar
argument_list|,
name|PCI_RID2BUS
argument_list|(
name|rid
argument_list|)
argument_list|)
expr_stmt|;
name|domain1
operator|=
name|dmar_domain_alloc
argument_list|(
name|dmar
argument_list|,
name|id_mapped
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain1
operator|==
name|NULL
condition|)
block|{
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|id_mapped
condition|)
block|{
name|error
operator|=
name|domain_init_rmrr
argument_list|(
name|domain1
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_domain_destroy
argument_list|(
name|domain1
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|ctx1
operator|=
name|dmar_ctx_alloc
argument_list|(
name|domain1
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|ctxp
operator|=
name|dmar_map_ctx_entry
argument_list|(
name|ctx1
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
comment|/* 		 * Recheck the contexts, other thread might have 		 * already allocated needed one. 		 */
name|ctx
operator|=
name|dmar_find_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|domain
operator|=
name|domain1
expr_stmt|;
name|ctx
operator|=
name|ctx1
expr_stmt|;
name|dmar_ctx_link
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
operator|=
name|dev
expr_stmt|;
name|ctx_tag_init
argument_list|(
name|ctx
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 			 * This is the first activated context for the 			 * DMAR unit.  Enable the translation after 			 * everything is set up. 			 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|dmar
operator|->
name|domains
argument_list|)
condition|)
name|enable
operator|=
name|true
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|dmar
operator|->
name|domains
argument_list|,
name|domain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ctx_id_entry_init
argument_list|(
name|ctx
argument_list|,
name|ctxp
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"dmar%d pci%d:%d:%d:%d rid %x domain %d mgaw %d "
literal|"agaw %d %s-mapped\n"
argument_list|,
name|dmar
operator|->
name|unit
argument_list|,
name|dmar
operator|->
name|segment
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|rid
argument_list|,
name|domain
operator|->
name|domain
argument_list|,
name|domain
operator|->
name|mgaw
argument_list|,
name|domain
operator|->
name|agaw
argument_list|,
name|id_mapped
condition|?
literal|"id"
else|:
literal|"re"
argument_list|)
expr_stmt|;
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|dmar_domain_destroy
argument_list|(
name|domain1
argument_list|)
expr_stmt|;
comment|/* Nothing needs to be done to destroy ctx1. */
name|free
argument_list|(
name|ctx1
argument_list|,
name|M_DMAR_CTX
argument_list|)
expr_stmt|;
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|ctx
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* tag referenced us */
block|}
block|}
else|else
block|{
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|ctx
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* tag referenced us */
block|}
name|error
operator|=
name|dmar_flush_for_ctx_entry
argument_list|(
name|dmar
argument_list|,
name|enable
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_free_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * The dmar lock was potentially dropped between check for the 	 * empty context list and now.  Recheck the state of GCMD_TE 	 * to avoid unneeded command. 	 */
if|if
condition|(
name|enable
operator|&&
operator|!
name|rmrr_init
operator|&&
operator|(
name|dmar
operator|->
name|hw_gcmd
operator|&
name|DMAR_GCMD_TE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmar_enable_translation
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_free_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_move_ctx_to_domain
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|dmar
decl_stmt|;
name|struct
name|dmar_domain
modifier|*
name|old_domain
decl_stmt|;
name|dmar_ctx_entry_t
modifier|*
name|ctxp
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmar
operator|=
name|domain
operator|->
name|dmar
expr_stmt|;
name|old_domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
if|if
condition|(
name|domain
operator|==
name|old_domain
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|old_domain
operator|->
name|dmar
operator|==
name|dmar
argument_list|,
operator|(
literal|"domain %p %u moving between dmars %u %u"
operator|,
name|domain
operator|,
name|domain
operator|->
name|domain
operator|,
name|old_domain
operator|->
name|dmar
operator|->
name|unit
operator|,
name|domain
operator|->
name|dmar
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
name|ctxp
operator|=
name|dmar_map_ctx_entry
argument_list|(
name|ctx
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|dmar_ctx_unlink
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|domain
operator|=
name|domain
expr_stmt|;
name|dmar_ctx_link
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx_id_entry_init
argument_list|(
name|ctx
argument_list|,
name|ctxp
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_flush_for_ctx_entry
argument_list|(
name|dmar
argument_list|,
name|true
argument_list|)
expr_stmt|;
comment|/* If flush failed, rolling back would not work as well. */
name|printf
argument_list|(
literal|"dmar%d rid %x domain %d->%d %s-mapped\n"
argument_list|,
name|dmar
operator|->
name|unit
argument_list|,
name|ctx
operator|->
name|rid
argument_list|,
name|old_domain
operator|->
name|domain
argument_list|,
name|domain
operator|->
name|domain
argument_list|,
operator|(
name|domain
operator|->
name|flags
operator|&
name|DMAR_DOMAIN_IDMAP
operator|)
operator|!=
literal|0
condition|?
literal|"id"
else|:
literal|"re"
argument_list|)
expr_stmt|;
name|dmar_unref_domain_locked
argument_list|(
name|dmar
argument_list|,
name|old_domain
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_unref_domain_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|)
block|{
name|DMAR_ASSERT_LOCKED
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"dmar %d domain %p refs %u"
operator|,
name|dmar
operator|->
name|unit
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|domain
operator|->
name|refs
operator|>
name|domain
operator|->
name|ctx_cnt
argument_list|,
operator|(
literal|"dmar %d domain %p refs %d ctx_cnt %d"
operator|,
name|dmar
operator|->
name|unit
operator|,
name|domain
operator|,
name|domain
operator|->
name|refs
operator|,
name|domain
operator|->
name|ctx_cnt
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|domain
operator|->
name|refs
operator|--
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|(
name|domain
operator|->
name|flags
operator|&
name|DMAR_DOMAIN_RMRR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"lost ref on RMRR domain %p"
operator|,
name|domain
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|domain
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|dmar
operator|->
name|delayed_taskqueue
argument_list|,
operator|&
name|domain
operator|->
name|unload_task
argument_list|)
expr_stmt|;
name|dmar_domain_destroy
argument_list|(
name|domain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_free_ctx_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|dmar_ctx_entry_t
modifier|*
name|ctxp
decl_stmt|;
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"dmar %p ctx %p refs %u"
operator|,
name|dmar
operator|,
name|ctx
operator|,
name|ctx
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If our reference is not last, only the dereference should 	 * be performed. 	 */
if|if
condition|(
name|ctx
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|ctx
operator|->
name|refs
operator|--
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_DISABLED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"lost ref on disabled ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, the context entry must be cleared before the 	 * page table is destroyed.  The mapping of the context 	 * entries page could require sleep, unlock the dmar. 	 */
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
name|ctxp
operator|=
name|dmar_map_ctx_entry
argument_list|(
name|ctx
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx
operator|->
name|refs
operator|>=
literal|1
argument_list|,
operator|(
literal|"dmar %p ctx %p refs %u"
operator|,
name|dmar
operator|,
name|ctx
operator|,
name|ctx
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Other thread might have referenced the context, in which 	 * case again only the dereference should be performed. 	 */
if|if
condition|(
name|ctx
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|ctx
operator|->
name|refs
operator|--
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_DISABLED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"lost ref on disabled ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the context pointer and flush the caches. 	 * XXXKIB: cannot do this if any RMRR entries are still present. 	 */
name|dmar_pte_clear
argument_list|(
operator|&
name|ctxp
operator|->
name|ctx1
argument_list|)
expr_stmt|;
name|ctxp
operator|->
name|ctx2
operator|=
literal|0
expr_stmt|;
name|dmar_flush_ctx_to_ram
argument_list|(
name|dmar
argument_list|,
name|ctxp
argument_list|)
expr_stmt|;
name|dmar_inv_ctx_glob
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmar
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_DI
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dmar
operator|->
name|qi_enabled
condition|)
name|dmar_qi_invalidate_iotlb_glob_locked
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
else|else
name|dmar_inv_iotlb_glob
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
block|}
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|domain
operator|=
name|ctx
operator|->
name|domain
expr_stmt|;
name|dmar_ctx_unlink
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|,
name|M_DMAR_CTX
argument_list|)
expr_stmt|;
name|dmar_unref_domain_locked
argument_list|(
name|dmar
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_free_ctx
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|dmar
decl_stmt|;
name|dmar
operator|=
name|ctx
operator|->
name|domain
operator|->
name|dmar
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|dmar_free_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns with the domain locked.  */
end_comment

begin_function
name|struct
name|dmar_ctx
modifier|*
name|dmar_find_ctx_locked
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|uint16_t
name|rid
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|DMAR_ASSERT_LOCKED
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|domain
argument_list|,
argument|&dmar->domains
argument_list|,
argument|link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&domain->contexts
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|rid
operator|==
name|rid
condition|)
return|return
operator|(
name|ctx
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_domain_free_entry
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|bool
name|free
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|domain
operator|=
name|entry
operator|->
name|domain
expr_stmt|;
name|DMAR_DOMAIN_LOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_RMRR
operator|)
operator|!=
literal|0
condition|)
name|dmar_gas_free_region
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|dmar_gas_free_space
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DMAR_DOMAIN_UNLOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
condition|)
name|dmar_gas_free_entry
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|entry
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_domain_unload_entry
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|bool
name|free
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|unit
operator|=
name|entry
operator|->
name|domain
operator|->
name|dmar
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|qi_enabled
condition|)
block|{
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_qi_invalidate_locked
argument_list|(
name|entry
operator|->
name|domain
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
operator|&
name|entry
operator|->
name|gseq
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|free
condition|)
name|entry
operator|->
name|flags
operator||=
name|DMAR_MAP_ENTRY_QI_NF
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|unit
operator|->
name|tlb_flush_entries
argument_list|,
name|entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|domain_flush_iotlb_sync
argument_list|(
name|entry
operator|->
name|domain
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
name|dmar_domain_free_entry
argument_list|(
name|entry
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|dmar_domain_unload_emit_wait
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|entry
argument_list|,
name|dmamap_link
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|domain
operator|->
name|batch_no
operator|++
operator|%
name|dmar_batch_coalesce
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_domain_unload
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|struct
name|dmar_map_entries_tailq
modifier|*
name|entries
parameter_list|,
name|bool
name|cansleep
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|domain
operator|->
name|dmar
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|entries
argument_list|,
argument|dmamap_link
argument_list|,
argument|entry1
argument_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_MAP
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"not mapped entry %p %p"
operator|,
name|domain
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|domain_unmap_buf
argument_list|(
name|domain
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
name|cansleep
condition|?
name|DMAR_PGF_WAITOK
else|:
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unmap %p error %d"
operator|,
name|domain
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|qi_enabled
condition|)
block|{
name|domain_flush_iotlb_sync
argument_list|(
name|domain
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|entries
argument_list|,
name|entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|dmar_domain_free_entry
argument_list|(
name|entry
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|entries
argument_list|)
condition|)
return|return;
name|KASSERT
argument_list|(
name|unit
operator|->
name|qi_enabled
argument_list|,
operator|(
literal|"loaded entry left"
operator|)
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|entries
argument_list|,
argument|dmamap_link
argument_list|)
block|{
name|dmar_qi_invalidate_locked
argument_list|(
name|domain
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
operator|&
name|entry
operator|->
name|gseq
argument_list|,
name|dmar_domain_unload_emit_wait
argument_list|(
name|domain
argument_list|,
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TAILQ_CONCAT
argument_list|(
operator|&
name|unit
operator|->
name|tlb_flush_entries
argument_list|,
name|entries
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_domain_unload_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|struct
name|dmar_map_entries_tailq
name|entries
decl_stmt|;
name|domain
operator|=
name|arg
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|entries
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DMAR_DOMAIN_LOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|TAILQ_SWAP
argument_list|(
operator|&
name|domain
operator|->
name|unload_entries
argument_list|,
operator|&
name|entries
argument_list|,
name|dmar_map_entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|DMAR_DOMAIN_UNLOCK
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|entries
argument_list|)
condition|)
break|break;
name|dmar_domain_unload
argument_list|(
name|domain
argument_list|,
operator|&
name|entries
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

