begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_comment
comment|/*  * busdma_dmar.c, the implementation of the busdma(9) interface using  * DMAR units from Intel VT-d.  */
end_comment

begin_function
specifier|static
name|bool
name|dmar_bus_dma_is_dev_disabled
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|slot
parameter_list|,
name|int
name|func
parameter_list|)
block|{
name|char
name|str
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|snprintf
argument_list|(
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
literal|"hw.busdma.pci%d.%d.%d.%d.bounce"
argument_list|,
name|domain
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|env
operator|=
name|getenv
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|freeenv
argument_list|(
name|env
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given original device, find the requester ID that will be seen by  * the DMAR unit and used for page table lookup.  PCI bridges may take  * ownership of transactions from downstream devices, so it may not be  * the same as the BSF of the target device.  In those cases, all  * devices downstream of the bridge must share a single mapping  * domain, and must collectively be assigned to use either DMAR or  * bounce mapping.  */
end_comment

begin_function
specifier|static
name|device_t
name|dmar_get_requester
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
block|{
name|devclass_t
name|pci_class
decl_stmt|;
name|device_t
name|pci
decl_stmt|,
name|pcib
decl_stmt|,
name|requester
decl_stmt|;
name|int
name|cap_offset
decl_stmt|;
name|pci_class
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|requester
operator|=
name|dev
expr_stmt|;
operator|*
name|rid
operator|=
name|pci_get_rid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the bridge hierarchy from the target device to the 	 * host port to find the translating bridge nearest the DMAR 	 * unit. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|pci
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pci
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parent for pci%d:%d:%d:%d"
operator|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|device_get_devclass
argument_list|(
name|pci
argument_list|)
operator|==
name|pci_class
argument_list|,
operator|(
literal|"Non-pci parent for pci%d:%d:%d:%d"
operator|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|pci
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pcib
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL bridge for pci%d:%d:%d:%d"
operator|,
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
operator|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * The parent of our "bridge" isn't another PCI bus, 		 * so pcib isn't a PCI->PCI bridge but rather a host 		 * port, and the requester ID won't be translated 		 * further. 		 */
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
argument_list|)
operator|!=
name|pci_class
condition|)
break|break;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|cap_offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Device is not PCIe, it cannot be seen as a 			 * requester by DMAR unit. 			 */
name|requester
operator|=
name|pcib
expr_stmt|;
comment|/* Check whether the bus above is PCIe. */
if|if
condition|(
name|pci_find_cap
argument_list|(
name|pcib
argument_list|,
name|PCIY_EXPRESS
argument_list|,
operator|&
name|cap_offset
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * The current device is not PCIe, but 				 * the bridge above it is.  This is a 				 * PCIe->PCI bridge.  Assume that the 				 * requester ID will be the secondary 				 * bus number with slot and function 				 * set to zero. 				 * 				 * XXX: Doesn't handle the case where 				 * the bridge is PCIe->PCI-X, and the 				 * bridge will only take ownership of 				 * requests in some cases.  We should 				 * provide context entries with the 				 * same page tables for taken and 				 * non-taken transactions. 				 */
operator|*
name|rid
operator|=
name|PCI_RID
argument_list|(
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Neither the device nor the bridge 				 * above it are PCIe.  This is a 				 * conventional PCI->PCI bridge, which 				 * will use the bridge's BSF as the 				 * requester ID. 				 */
operator|*
name|rid
operator|=
name|pci_get_rid
argument_list|(
name|pcib
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Do not stop the loop even if the target device is 		 * PCIe, because it is possible (but unlikely) to have 		 * a PCI->PCIe bridge somewhere in the hierarchy. 		 */
name|dev
operator|=
name|pcib
expr_stmt|;
block|}
return|return
operator|(
name|requester
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|dmar_ctx
modifier|*
name|dmar_instantiate_ctx
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|bool
name|rmrr
parameter_list|)
block|{
name|device_t
name|requester
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|bool
name|disabled
decl_stmt|;
name|uint16_t
name|rid
decl_stmt|;
name|requester
operator|=
name|dmar_get_requester
argument_list|(
name|dev
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
comment|/* 	 * If the user requested the IOMMU disabled for the device, we 	 * cannot disable the DMAR, due to possibility of other 	 * devices on the same DMAR still requiring translation. 	 * Instead provide the identity mapping for the device 	 * context. 	 */
name|disabled
operator|=
name|dmar_bus_dma_is_dev_disabled
argument_list|(
name|pci_get_domain
argument_list|(
name|requester
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|requester
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|requester
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|requester
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|dmar_get_ctx
argument_list|(
name|dmar
argument_list|,
name|requester
argument_list|,
name|rid
argument_list|,
name|disabled
argument_list|,
name|rmrr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|disabled
condition|)
block|{
comment|/* 		 * Keep the first reference on context, release the 		 * later refs. 		 */
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_DISABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|ctx
operator|->
name|flags
operator||=
name|DMAR_CTX_DISABLED
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmar_free_ctx_locked
argument_list|(
name|dmar
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ctx
operator|)
return|;
block|}
end_function

begin_function
name|bus_dma_tag_t
name|dmar_get_dma_tag
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|dmar
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|bus_dma_tag_t
name|res
decl_stmt|;
name|dmar
operator|=
name|dmar_find
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* Not in scope of any DMAR ? */
if|if
condition|(
name|dmar
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dmar_quirks_pre_use
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|dmar_instantiate_rmrr_ctxs
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|dmar_instantiate_ctx
argument_list|(
name|dmar
argument_list|,
name|child
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|res
operator|=
name|ctx
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|(
name|bus_dma_tag_t
operator|)
operator|&
name|ctx
operator|->
name|ctx_tag
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DMAR_DMAMAP
argument_list|,
literal|"dmar_dmamap"
argument_list|,
literal|"Intel DMAR DMA Map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|dmar_bus_schedule_dmamap
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dmar_bus_dma_tag_create
parameter_list|(
name|bus_dma_tag_t
name|parent
parameter_list|,
name|bus_size_t
name|alignment
parameter_list|,
name|bus_addr_t
name|boundary
parameter_list|,
name|bus_addr_t
name|lowaddr
parameter_list|,
name|bus_addr_t
name|highaddr
parameter_list|,
name|bus_dma_filter_t
modifier|*
name|filter
parameter_list|,
name|void
modifier|*
name|filterarg
parameter_list|,
name|bus_size_t
name|maxsize
parameter_list|,
name|int
name|nsegments
parameter_list|,
name|bus_size_t
name|maxsegsz
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_lock_t
modifier|*
name|lockfunc
parameter_list|,
name|void
modifier|*
name|lockfuncarg
parameter_list|,
name|bus_dma_tag_t
modifier|*
name|dmat
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|newtag
decl_stmt|,
modifier|*
name|oldtag
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|dmat
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|common_bus_dma_tag_create
argument_list|(
name|parent
operator|!=
name|NULL
condition|?
operator|&
operator|(
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|parent
operator|)
operator|->
name|common
else|:
name|NULL
argument_list|,
name|alignment
argument_list|,
name|boundary
argument_list|,
name|lowaddr
argument_list|,
name|highaddr
argument_list|,
name|filter
argument_list|,
name|filterarg
argument_list|,
name|maxsize
argument_list|,
name|nsegments
argument_list|,
name|maxsegsz
argument_list|,
name|flags
argument_list|,
name|lockfunc
argument_list|,
name|lockfuncarg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bus_dma_tag_dmar
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|newtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|oldtag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|parent
expr_stmt|;
name|newtag
operator|->
name|common
operator|.
name|impl
operator|=
operator|&
name|bus_dma_dmar_impl
expr_stmt|;
name|newtag
operator|->
name|ctx
operator|=
name|oldtag
operator|->
name|ctx
expr_stmt|;
name|newtag
operator|->
name|owner
operator|=
name|oldtag
operator|->
name|owner
expr_stmt|;
operator|*
name|dmat
operator|=
operator|(
name|bus_dma_tag_t
operator|)
name|newtag
expr_stmt|;
name|out
label|:
name|CTR4
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s returned tag %p tag flags 0x%x error %d"
argument_list|,
name|__func__
argument_list|,
name|newtag
argument_list|,
operator|(
name|newtag
operator|!=
name|NULL
condition|?
name|newtag
operator|->
name|common
operator|.
name|flags
else|:
literal|0
operator|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dma_tag_destroy
parameter_list|(
name|bus_dma_tag_t
name|dmat1
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|dmat
decl_stmt|,
modifier|*
name|dmat_copy
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|dmat_copy
operator|=
name|dmat
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat1
expr_stmt|;
if|if
condition|(
name|dmat
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dmat
operator|->
name|map_count
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
while|while
condition|(
name|dmat
operator|!=
name|NULL
condition|)
block|{
name|parent
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
operator|->
name|common
operator|.
name|parent
expr_stmt|;
if|if
condition|(
name|atomic_fetchadd_int
argument_list|(
operator|&
name|dmat
operator|->
name|common
operator|.
name|ref_count
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dmat
operator|==
operator|&
name|dmat
operator|->
name|ctx
operator|->
name|ctx_tag
condition|)
name|dmar_free_ctx
argument_list|(
name|dmat
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dmat
operator|->
name|segments
argument_list|,
name|M_DMAR_DMAMAP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dmat
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|dmat
operator|=
name|parent
expr_stmt|;
block|}
else|else
name|dmat
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|CTR3
argument_list|(
name|KTR_BUSDMA
argument_list|,
literal|"%s tag %p error %d"
argument_list|,
name|__func__
argument_list|,
name|dmat_copy
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_create
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dmamap_t
modifier|*
name|mapp
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
name|M_DMAR_DMAMAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|==
name|NULL
condition|)
block|{
operator|*
name|mapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|tag
operator|->
name|segments
operator|==
name|NULL
condition|)
block|{
name|tag
operator|->
name|segments
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dma_segment_t
argument_list|)
operator|*
name|tag
operator|->
name|common
operator|.
name|nsegments
argument_list|,
name|M_DMAR_DMAMAP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|->
name|segments
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|map
argument_list|,
name|M_DMAR_DMAMAP
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|map
operator|->
name|map_entries
argument_list|)
expr_stmt|;
name|map
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|map
operator|->
name|locked
operator|=
name|true
expr_stmt|;
name|map
operator|->
name|cansleep
operator|=
name|false
expr_stmt|;
name|tag
operator|->
name|map_count
operator|++
expr_stmt|;
operator|*
name|mapp
operator|=
operator|(
name|bus_dmamap_t
operator|)
name|map
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_destroy
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|DMAR_CTX_LOCK
argument_list|(
name|tag
operator|->
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|map
operator|->
name|map_entries
argument_list|)
condition|)
block|{
name|DMAR_CTX_UNLOCK
argument_list|(
name|tag
operator|->
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|DMAR_CTX_UNLOCK
argument_list|(
name|tag
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|map
argument_list|,
name|M_DMAR_DMAMAP
argument_list|)
expr_stmt|;
block|}
name|tag
operator|->
name|map_count
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamem_alloc
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|void
modifier|*
modifier|*
name|vaddr
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dmamap_t
modifier|*
name|mapp
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mflags
decl_stmt|;
name|vm_memattr_t
name|attr
decl_stmt|;
name|error
operator|=
name|dmar_bus_dmamap_create
argument_list|(
name|dmat
argument_list|,
name|flags
argument_list|,
name|mapp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mflags
operator|=
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|!=
literal|0
condition|?
name|M_NOWAIT
else|:
name|M_WAITOK
expr_stmt|;
name|mflags
operator||=
operator|(
name|flags
operator|&
name|BUS_DMA_ZERO
operator|)
operator|!=
literal|0
condition|?
name|M_ZERO
else|:
literal|0
expr_stmt|;
name|attr
operator|=
operator|(
name|flags
operator|&
name|BUS_DMA_NOCACHE
operator|)
operator|!=
literal|0
condition|?
name|VM_MEMATTR_UNCACHEABLE
else|:
name|VM_MEMATTR_DEFAULT
expr_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
operator|*
name|mapp
expr_stmt|;
if|if
condition|(
name|tag
operator|->
name|common
operator|.
name|maxsize
operator|<
name|PAGE_SIZE
operator|&&
name|tag
operator|->
name|common
operator|.
name|alignment
operator|<=
name|tag
operator|->
name|common
operator|.
name|maxsize
operator|&&
name|attr
operator|==
name|VM_MEMATTR_DEFAULT
condition|)
block|{
operator|*
name|vaddr
operator|=
name|malloc
argument_list|(
name|tag
operator|->
name|common
operator|.
name|maxsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator||=
name|BUS_DMAMAP_DMAR_MALLOC
expr_stmt|;
block|}
else|else
block|{
operator|*
name|vaddr
operator|=
operator|(
name|void
operator|*
operator|)
name|kmem_alloc_attr
argument_list|(
name|kernel_arena
argument_list|,
name|tag
operator|->
name|common
operator|.
name|maxsize
argument_list|,
name|mflags
argument_list|,
literal|0ul
argument_list|,
name|BUS_SPACE_MAXADDR
argument_list|,
name|attr
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator||=
name|BUS_DMAMAP_DMAR_KMEM_ALLOC
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|vaddr
operator|==
name|NULL
condition|)
block|{
name|dmar_bus_dmamap_destroy
argument_list|(
name|dmat
argument_list|,
operator|*
name|mapp
argument_list|)
expr_stmt|;
operator|*
name|mapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_bus_dmamem_free
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|flags
operator|&
name|BUS_DMAMAP_DMAR_MALLOC
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|vaddr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator|&=
operator|~
name|BUS_DMAMAP_DMAR_MALLOC
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|map
operator|->
name|flags
operator|&
name|BUS_DMAMAP_DMAR_KMEM_ALLOC
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"dmar_bus_dmamem_free for non alloced map %p"
operator|,
name|map
operator|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_arena
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vaddr
argument_list|,
name|tag
operator|->
name|common
operator|.
name|maxsize
argument_list|)
expr_stmt|;
name|map
operator|->
name|flags
operator|&=
operator|~
name|BUS_DMAMAP_DMAR_KMEM_ALLOC
expr_stmt|;
block|}
name|dmar_bus_dmamap_destroy
argument_list|(
name|dmat
argument_list|,
name|map1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_load_something1
parameter_list|(
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
parameter_list|,
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|offset
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|,
name|struct
name|dmar_map_entries_tailq
modifier|*
name|unroll_list
parameter_list|)
block|{
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
name|dmar_gaddr_t
name|size
decl_stmt|;
name|bus_size_t
name|buflen1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|idx
decl_stmt|,
name|gas_flags
decl_stmt|,
name|seg
decl_stmt|;
if|if
condition|(
name|segs
operator|==
name|NULL
condition|)
name|segs
operator|=
name|tag
operator|->
name|segments
expr_stmt|;
name|ctx
operator|=
name|tag
operator|->
name|ctx
expr_stmt|;
name|seg
operator|=
operator|*
name|segp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
name|seg
operator|++
expr_stmt|;
if|if
condition|(
name|seg
operator|>=
name|tag
operator|->
name|common
operator|.
name|nsegments
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
break|break;
block|}
name|buflen1
operator|=
name|buflen
operator|>
name|tag
operator|->
name|common
operator|.
name|maxsegsz
condition|?
name|tag
operator|->
name|common
operator|.
name|maxsegsz
else|:
name|buflen
expr_stmt|;
name|buflen
operator|-=
name|buflen1
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|offset
operator|+
name|buflen1
argument_list|)
expr_stmt|;
comment|/* 		 * (Too) optimistically allow split if there are more 		 * then one segments left. 		 */
name|gas_flags
operator|=
name|map
operator|->
name|cansleep
condition|?
name|DMAR_GM_CANWAIT
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|seg
operator|+
literal|1
operator|<
name|tag
operator|->
name|common
operator|.
name|nsegments
condition|)
name|gas_flags
operator||=
name|DMAR_GM_CANSPLIT
expr_stmt|;
name|error
operator|=
name|dmar_gas_map
argument_list|(
name|ctx
argument_list|,
operator|&
name|tag
operator|->
name|common
argument_list|,
name|size
argument_list|,
name|DMAR_MAP_ENTRY_READ
operator||
name|DMAR_MAP_ENTRY_WRITE
argument_list|,
name|gas_flags
argument_list|,
name|ma
operator|+
name|idx
argument_list|,
operator|&
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|gas_flags
operator|&
name|DMAR_GM_CANSPLIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|size
operator|>=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
operator|(
literal|"split increased entry size %jx %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|buflen1
operator|>
name|size
condition|)
name|buflen1
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
operator|==
name|size
argument_list|,
operator|(
literal|"no split allowed %jx %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
operator|(
name|entry
operator|->
name|start
operator|+
name|offset
operator|)
operator|&
operator|(
name|tag
operator|->
name|common
operator|.
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"alignment failed: ctx %p start 0x%jx offset %x "
literal|"align 0x%jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
name|offset
operator|,
operator|(
name|uintmax_t
operator|)
name|tag
operator|->
name|common
operator|.
name|alignment
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|<=
name|tag
operator|->
name|common
operator|.
name|lowaddr
operator|||
name|entry
operator|->
name|start
operator|>=
name|tag
operator|->
name|common
operator|.
name|highaddr
argument_list|,
operator|(
literal|"entry placement failed: ctx %p start 0x%jx end 0x%jx "
literal|"lowaddr 0x%jx highaddr 0x%jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|tag
operator|->
name|common
operator|.
name|lowaddr
operator|,
operator|(
name|uintmax_t
operator|)
name|tag
operator|->
name|common
operator|.
name|highaddr
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dmar_test_boundary
argument_list|(
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
name|tag
operator|->
name|common
operator|.
name|boundary
argument_list|)
argument_list|,
operator|(
literal|"boundary failed: ctx %p start 0x%jx end 0x%jx "
literal|"boundary 0x%jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|tag
operator|->
name|common
operator|.
name|boundary
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|buflen1
operator|<=
name|tag
operator|->
name|common
operator|.
name|maxsegsz
argument_list|,
operator|(
literal|"segment too large: ctx %p start 0x%jx end 0x%jx "
literal|"maxsegsz 0x%jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|tag
operator|->
name|common
operator|.
name|maxsegsz
operator|)
argument_list|)
expr_stmt|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|map
operator|->
name|map_entries
argument_list|,
name|entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|DMAR_MAP_ENTRY_MAP
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|unroll_list
argument_list|,
name|entry
argument_list|,
name|unroll_link
argument_list|)
expr_stmt|;
name|segs
index|[
name|seg
index|]
operator|.
name|ds_addr
operator|=
name|entry
operator|->
name|start
operator|+
name|offset
expr_stmt|;
name|segs
index|[
name|seg
index|]
operator|.
name|ds_len
operator|=
name|buflen1
expr_stmt|;
name|idx
operator|+=
name|OFF_TO_IDX
argument_list|(
name|trunc_page
argument_list|(
name|offset
operator|+
name|buflen1
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|buflen1
expr_stmt|;
name|offset
operator|&=
name|DMAR_PAGE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|segp
operator|=
name|seg
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_load_something
parameter_list|(
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
parameter_list|,
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|offset
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|)
block|{
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry1
decl_stmt|;
name|struct
name|dmar_map_entries_tailq
name|unroll_list
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ctx
operator|=
name|tag
operator|->
name|ctx
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|ctx
operator|->
name|loads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|unroll_list
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_bus_dmamap_load_something1
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|ma
argument_list|,
name|offset
argument_list|,
name|buflen
argument_list|,
name|flags
argument_list|,
name|segs
argument_list|,
name|segp
argument_list|,
operator|&
name|unroll_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The busdma interface does not allow us to report 		 * partial buffer load, so unfortunately we have to 		 * revert all work done. 		 */
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&unroll_list
argument_list|,
argument|unroll_link
argument_list|,
argument|entry1
argument_list|)
block|{
comment|/* 			 * No entries other than what we have created 			 * during the failed run might have been 			 * inserted there in between, since we own ctx 			 * pglock. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|map
operator|->
name|map_entries
argument_list|,
name|entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|unroll_list
argument_list|,
name|entry
argument_list|,
name|unroll_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ctx
operator|->
name|unload_entries
argument_list|,
name|entry
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
block|}
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|ctx
operator|->
name|dmar
operator|->
name|delayed_taskqueue
argument_list|,
operator|&
name|ctx
operator|->
name|unload_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ENOMEM
operator|&&
operator|(
name|flags
operator|&
name|BUS_DMA_NOWAIT
operator|)
operator|==
literal|0
operator|&&
operator|!
name|map
operator|->
name|cansleep
condition|)
name|error
operator|=
name|EINPROGRESS
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
name|dmar_bus_schedule_dmamap
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_load_ma
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|,
name|struct
name|vm_page
modifier|*
modifier|*
name|ma
parameter_list|,
name|bus_size_t
name|tlen
parameter_list|,
name|int
name|ma_offs
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
return|return
operator|(
name|dmar_bus_dmamap_load_something
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|ma
argument_list|,
name|ma_offs
argument_list|,
name|tlen
argument_list|,
name|flags
argument_list|,
name|segs
argument_list|,
name|segp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_load_phys
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|,
name|vm_paddr_t
name|buf
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|vm_page_t
modifier|*
name|ma
decl_stmt|;
name|vm_paddr_t
name|pstart
decl_stmt|,
name|pend
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ma_cnt
decl_stmt|,
name|offset
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
name|pstart
operator|=
name|trunc_page
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pend
operator|=
name|round_page
argument_list|(
name|buf
operator|+
name|buflen
argument_list|)
expr_stmt|;
name|offset
operator|=
name|buf
operator|&
name|PAGE_MASK
expr_stmt|;
name|ma_cnt
operator|=
name|OFF_TO_IDX
argument_list|(
name|pend
operator|-
name|pstart
argument_list|)
expr_stmt|;
name|ma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
operator|*
name|ma_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|map
operator|->
name|cansleep
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ma
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ma_cnt
condition|;
name|i
operator|++
control|)
name|ma
index|[
name|i
index|]
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pstart
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_bus_dmamap_load_something
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|ma
argument_list|,
name|offset
argument_list|,
name|buflen
argument_list|,
name|flags
argument_list|,
name|segs
argument_list|,
name|segp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ma
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_bus_dmamap_load_buffer
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|bus_size_t
name|buflen
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|int
name|flags
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|segp
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|vm_page_t
modifier|*
name|ma
decl_stmt|,
name|fma
decl_stmt|;
name|vm_paddr_t
name|pstart
decl_stmt|,
name|pend
decl_stmt|,
name|paddr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|ma_cnt
decl_stmt|,
name|offset
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
name|pstart
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|buf
argument_list|)
expr_stmt|;
name|pend
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|buf
operator|+
name|buflen
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|vm_offset_t
operator|)
name|buf
operator|&
name|PAGE_MASK
expr_stmt|;
name|ma_cnt
operator|=
name|OFF_TO_IDX
argument_list|(
name|pend
operator|-
name|pstart
argument_list|)
expr_stmt|;
name|ma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
operator|*
name|ma_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|map
operator|->
name|cansleep
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ma
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|dumping
condition|)
block|{
comment|/* 		 * If dumping, do not attempt to call 		 * PHYS_TO_VM_PAGE() at all.  It may return non-NULL 		 * but the vm_page returned might be not initialized, 		 * e.g. for the kernel itself. 		 */
name|KASSERT
argument_list|(
name|pmap
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"non-kernel address write"
operator|)
argument_list|)
expr_stmt|;
name|fma
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vm_page
argument_list|)
operator|*
name|ma_cnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
operator|(
name|map
operator|->
name|cansleep
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fma
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ma
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ma_cnt
condition|;
name|i
operator|++
operator|,
name|pstart
operator|+=
name|PAGE_SIZE
control|)
block|{
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|pstart
argument_list|)
expr_stmt|;
name|vm_page_initfake
argument_list|(
operator|&
name|fma
index|[
name|i
index|]
argument_list|,
name|paddr
argument_list|,
name|VM_MEMATTR_DEFAULT
argument_list|)
expr_stmt|;
name|ma
index|[
name|i
index|]
operator|=
operator|&
name|fma
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
name|fma
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ma_cnt
condition|;
name|i
operator|++
operator|,
name|pstart
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|paddr
operator|=
name|pmap_kextract
argument_list|(
name|pstart
argument_list|)
expr_stmt|;
else|else
name|paddr
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|pstart
argument_list|)
expr_stmt|;
name|ma
index|[
name|i
index|]
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|)
operator|==
name|paddr
argument_list|,
operator|(
literal|"PHYS_TO_VM_PAGE failed %jx %jx m %p"
operator|,
operator|(
name|uintmax_t
operator|)
name|paddr
operator|,
operator|(
name|uintmax_t
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|)
operator|,
name|ma
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|dmar_bus_dmamap_load_something
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
name|ma
argument_list|,
name|offset
argument_list|,
name|buflen
argument_list|,
name|flags
argument_list|,
name|segs
argument_list|,
name|segp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ma
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fma
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_bus_dmamap_waitok
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|,
name|struct
name|memdesc
modifier|*
name|mem
parameter_list|,
name|bus_dmamap_callback_t
modifier|*
name|callback
parameter_list|,
name|void
modifier|*
name|callback_arg
parameter_list|)
block|{
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
if|if
condition|(
name|map1
operator|==
name|NULL
condition|)
return|return;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
name|map
operator|->
name|mem
operator|=
operator|*
name|mem
expr_stmt|;
name|map
operator|->
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|map
operator|->
name|callback_arg
operator|=
name|callback_arg
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bus_dma_segment_t
modifier|*
name|dmar_bus_dmamap_complete
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
if|if
condition|(
operator|!
name|map
operator|->
name|locked
condition|)
block|{
name|KASSERT
argument_list|(
name|map
operator|->
name|cansleep
argument_list|,
operator|(
literal|"map not locked and not sleepable context %p"
operator|,
name|map
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * We are called from the delayed context.  Relock the 		 * driver. 		 */
call|(
name|tag
operator|->
name|common
operator|.
name|lockfunc
call|)
argument_list|(
name|tag
operator|->
name|common
operator|.
name|lockfuncarg
argument_list|,
name|BUS_DMA_LOCK
argument_list|)
expr_stmt|;
name|map
operator|->
name|locked
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|segs
operator|==
name|NULL
condition|)
name|segs
operator|=
name|tag
operator|->
name|segments
expr_stmt|;
return|return
operator|(
name|segs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The limitations of busdma KPI forces the dmar to perform the actual  * unload, consisting of the unmapping of the map entries page tables,  * from the delayed context on i386, since page table page mapping  * might require a sleep to be successfull.  The unfortunate  * consequence is that the DMA requests can be served some time after  * the bus_dmamap_unload() call returned.  *  * On amd64, we assume that sf allocation cannot fail.  */
end_comment

begin_function
specifier|static
name|void
name|dmar_bus_dmamap_unload
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map1
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
name|struct
name|dmar_map_entries_tailq
name|entries
decl_stmt|;
endif|#
directive|endif
name|tag
operator|=
operator|(
expr|struct
name|bus_dma_tag_dmar
operator|*
operator|)
name|dmat
expr_stmt|;
name|map
operator|=
operator|(
expr|struct
name|bus_dmamap_dmar
operator|*
operator|)
name|map1
expr_stmt|;
name|ctx
operator|=
name|tag
operator|->
name|ctx
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|ctx
operator|->
name|unloads
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|ctx
operator|->
name|unload_entries
argument_list|,
operator|&
name|map
operator|->
name|map_entries
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|ctx
operator|->
name|dmar
operator|->
name|delayed_taskqueue
argument_list|,
operator|&
name|ctx
operator|->
name|unload_task
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* defined(__amd64__) */
name|TAILQ_INIT
argument_list|(
operator|&
name|entries
argument_list|)
expr_stmt|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|entries
argument_list|,
operator|&
name|map
operator|->
name|map_entries
argument_list|,
name|dmamap_link
argument_list|)
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|THREAD_NO_SLEEPING
argument_list|()
expr_stmt|;
name|dmar_ctx_unload
argument_list|(
name|ctx
argument_list|,
operator|&
name|entries
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|THREAD_SLEEPING_OK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|entries
argument_list|)
argument_list|,
operator|(
literal|"lazy dmar_ctx_unload %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_bus_dmamap_sync
parameter_list|(
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_dmasync_op_t
name|op
parameter_list|)
block|{ }
end_function

begin_decl_stmt
name|struct
name|bus_dma_impl
name|bus_dma_dmar_impl
init|=
block|{
operator|.
name|tag_create
operator|=
name|dmar_bus_dma_tag_create
block|,
operator|.
name|tag_destroy
operator|=
name|dmar_bus_dma_tag_destroy
block|,
operator|.
name|map_create
operator|=
name|dmar_bus_dmamap_create
block|,
operator|.
name|map_destroy
operator|=
name|dmar_bus_dmamap_destroy
block|,
operator|.
name|mem_alloc
operator|=
name|dmar_bus_dmamem_alloc
block|,
operator|.
name|mem_free
operator|=
name|dmar_bus_dmamem_free
block|,
operator|.
name|load_phys
operator|=
name|dmar_bus_dmamap_load_phys
block|,
operator|.
name|load_buffer
operator|=
name|dmar_bus_dmamap_load_buffer
block|,
operator|.
name|load_ma
operator|=
name|dmar_bus_dmamap_load_ma
block|,
operator|.
name|map_waitok
operator|=
name|dmar_bus_dmamap_waitok
block|,
operator|.
name|map_complete
operator|=
name|dmar_bus_dmamap_complete
block|,
operator|.
name|map_unload
operator|=
name|dmar_bus_dmamap_unload
block|,
operator|.
name|map_sync
operator|=
name|dmar_bus_dmamap_sync
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dmar_bus_task_dmamap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bus_dma_tag_dmar
modifier|*
name|tag
decl_stmt|;
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
decl_stmt|;
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|unit
operator|=
name|arg
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|map
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|unit
operator|->
name|delayed_maps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|unit
operator|->
name|delayed_maps
argument_list|,
name|map
argument_list|,
name|delay_link
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|tag
operator|=
name|map
operator|->
name|tag
expr_stmt|;
name|ctx
operator|=
name|map
operator|->
name|tag
operator|->
name|ctx
expr_stmt|;
name|map
operator|->
name|cansleep
operator|=
name|true
expr_stmt|;
name|map
operator|->
name|locked
operator|=
name|false
expr_stmt|;
name|bus_dmamap_load_mem
argument_list|(
operator|(
name|bus_dma_tag_t
operator|)
name|tag
argument_list|,
operator|(
name|bus_dmamap_t
operator|)
name|map
argument_list|,
operator|&
name|map
operator|->
name|mem
argument_list|,
name|map
operator|->
name|callback
argument_list|,
name|map
operator|->
name|callback_arg
argument_list|,
name|BUS_DMA_WAITOK
argument_list|)
expr_stmt|;
name|map
operator|->
name|cansleep
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|map
operator|->
name|locked
condition|)
block|{
call|(
name|tag
operator|->
name|common
operator|.
name|lockfunc
call|)
argument_list|(
name|tag
operator|->
name|common
operator|.
name|lockfuncarg
argument_list|,
name|BUS_DMA_UNLOCK
argument_list|)
expr_stmt|;
block|}
else|else
name|map
operator|->
name|locked
operator|=
name|true
expr_stmt|;
name|map
operator|->
name|cansleep
operator|=
name|false
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_bus_schedule_dmamap
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|struct
name|bus_dmamap_dmar
modifier|*
name|map
parameter_list|)
block|{
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|ctx
operator|=
name|map
operator|->
name|tag
operator|->
name|ctx
expr_stmt|;
name|map
operator|->
name|locked
operator|=
name|false
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|unit
operator|->
name|delayed_maps
argument_list|,
name|map
argument_list|,
name|delay_link
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|unit
operator|->
name|delayed_taskqueue
argument_list|,
operator|&
name|unit
operator|->
name|dmamap_load_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmar_init_busdma
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|unit
operator|->
name|delayed_maps
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|unit
operator|->
name|dmamap_load_task
argument_list|,
literal|0
argument_list|,
name|dmar_bus_task_dmamap
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|unit
operator|->
name|delayed_taskqueue
operator|=
name|taskqueue_create
argument_list|(
literal|"dmar"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|unit
operator|->
name|delayed_taskqueue
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|unit
operator|->
name|delayed_taskqueue
argument_list|,
literal|1
argument_list|,
name|PI_DISK
argument_list|,
literal|"dmar%d busdma taskq"
argument_list|,
name|unit
operator|->
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_fini_busdma
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
if|if
condition|(
name|unit
operator|->
name|delayed_taskqueue
operator|==
name|NULL
condition|)
return|return;
name|taskqueue_drain
argument_list|(
name|unit
operator|->
name|delayed_taskqueue
argument_list|,
operator|&
name|unit
operator|->
name|dmamap_load_task
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|unit
operator|->
name|delayed_taskqueue
argument_list|)
expr_stmt|;
name|unit
operator|->
name|delayed_taskqueue
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

