begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RB_AUGMENT
parameter_list|(
name|entry
parameter_list|)
value|dmar_gas_augment_entry(entry)
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_comment
comment|/*  * Guest Address Space management.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|dmar_map_entry_zone
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|intel_gas_init
parameter_list|(
name|void
parameter_list|)
block|{
name|dmar_map_entry_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"DMAR_MAP_ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmar_map_entry
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|intel_gas
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|intel_gas_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|dmar_map_entry
modifier|*
name|dmar_gas_alloc_entry
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|res
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|DMAR_PGF_WAITOK
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"unsupported flags %x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|res
operator|=
name|uma_zalloc
argument_list|(
name|dmar_map_entry_zone
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|DMAR_PGF_WAITOK
operator|)
operator|!=
literal|0
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|NULL
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|ctx
operator|->
name|entries_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_gas_free_entry
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|ctx
operator|->
name|entries_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|dmar_map_entry_zone
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_gas_cmp_entries
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|a
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|b
parameter_list|)
block|{
comment|/* Last entry have zero size, so<= */
name|KASSERT
argument_list|(
name|a
operator|->
name|start
operator|<=
name|a
operator|->
name|end
argument_list|,
operator|(
literal|"inverted entry %p (%jx, %jx)"
operator|,
name|a
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|b
operator|->
name|start
operator|<=
name|b
operator|->
name|end
argument_list|,
operator|(
literal|"inverted entry %p (%jx, %jx)"
operator|,
name|b
operator|,
operator|(
name|uintmax_t
operator|)
name|b
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|b
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|a
operator|->
name|end
operator|<=
name|b
operator|->
name|start
operator|||
name|b
operator|->
name|end
operator|<=
name|a
operator|->
name|start
operator|||
name|a
operator|->
name|end
operator|==
name|a
operator|->
name|start
operator|||
name|b
operator|->
name|end
operator|==
name|b
operator|->
name|start
argument_list|,
operator|(
literal|"overlapping entries %p (%jx, %jx) %p (%jx, %jx)"
operator|,
name|a
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|end
operator|,
name|b
operator|,
operator|(
name|uintmax_t
operator|)
name|b
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|b
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|end
operator|<
name|b
operator|->
name|end
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|b
operator|->
name|end
operator|<
name|a
operator|->
name|end
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_gas_augment_entry
parameter_list|(
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|!=
name|NULL
condition|;
name|entry
operator|=
name|RB_PARENT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
control|)
block|{
name|l
operator|=
name|RB_LEFT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
name|r
operator|=
name|RB_RIGHT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
operator|&&
name|r
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|free_down
operator|=
name|entry
operator|->
name|free_after
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
name|NULL
operator|&&
name|r
operator|!=
name|NULL
condition|)
block|{
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|r
operator|->
name|free_down
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
comment|/*l != NULL&& */
name|r
operator|==
name|NULL
condition|)
block|{
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|l
operator|->
name|free_down
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (l != NULL&& r != NULL) */
block|{
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|l
operator|->
name|free_down
argument_list|)
expr_stmt|;
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_down
argument_list|,
name|r
operator|->
name|free_down
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
name|dmar_map_entry
argument_list|,
name|rb_entry
argument_list|,
name|dmar_gas_cmp_entries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dmar_gas_fix_free
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|free_after
operator|=
operator|(
name|next
operator|!=
name|NULL
condition|?
name|next
operator|->
name|start
else|:
name|ctx
operator|->
name|end
operator|)
operator|-
name|entry
operator|->
name|end
expr_stmt|;
name|dmar_gas_augment_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function
specifier|static
name|void
name|dmar_gas_check_free
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|dmar_gaddr_t
name|v
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|dmar_gas_entries_tree
argument_list|,
argument|&ctx->rb_root
argument_list|)
block|{
name|next
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|free_after
operator|==
name|ctx
operator|->
name|end
operator|-
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|free_after
operator|=
name|next
operator|->
name|start
operator|-
name|entry
operator|->
name|end
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|entry
operator|->
name|end
operator|<=
name|next
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|RB_LEFT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
name|r
operator|=
name|RB_RIGHT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
operator|&&
name|r
operator|==
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|free_down
operator|==
name|entry
operator|->
name|free_after
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|==
name|NULL
operator|&&
name|r
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|r
operator|->
name|free_down
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
name|entry
operator|->
name|free_down
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|l
operator|->
name|free_down
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_after
argument_list|,
name|l
operator|->
name|free_down
argument_list|)
expr_stmt|;
name|v
operator|=
name|MAX
argument_list|(
name|entry
operator|->
name|free_down
argument_list|,
name|r
operator|->
name|free_down
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|entry
operator|->
name|free_down
operator|==
name|v
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|dmar_gas_rb_insert
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|prev
decl_stmt|,
modifier|*
name|found
decl_stmt|;
name|found
operator|=
name|RB_INSERT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dmar_gas_fix_free
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|prev
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|dmar_gas_fix_free
argument_list|(
name|ctx
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_gas_rb_remove
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|prev
decl_stmt|;
name|prev
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|dmar_gas_fix_free
argument_list|(
name|ctx
argument_list|,
name|prev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_gas_init_ctx
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|begin
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|begin
operator|=
name|dmar_gas_alloc_entry
argument_list|(
name|ctx
argument_list|,
name|DMAR_PGF_WAITOK
argument_list|)
expr_stmt|;
name|end
operator|=
name|dmar_gas_alloc_entry
argument_list|(
name|ctx
argument_list|,
name|DMAR_PGF_WAITOK
argument_list|)
expr_stmt|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx
operator|->
name|entries_cnt
operator|==
literal|2
argument_list|,
operator|(
literal|"dirty ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|ctx
operator|->
name|rb_root
argument_list|)
argument_list|,
operator|(
literal|"non-empty entries %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|begin
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|begin
operator|->
name|end
operator|=
name|DMAR_PAGE_SIZE
expr_stmt|;
name|begin
operator|->
name|free_after
operator|=
name|ctx
operator|->
name|end
operator|-
name|begin
operator|->
name|end
expr_stmt|;
name|begin
operator|->
name|flags
operator|=
name|DMAR_MAP_ENTRY_PLACE
operator||
name|DMAR_MAP_ENTRY_UNMAPPED
expr_stmt|;
name|dmar_gas_rb_insert
argument_list|(
name|ctx
argument_list|,
name|begin
argument_list|)
expr_stmt|;
name|end
operator|->
name|start
operator|=
name|ctx
operator|->
name|end
expr_stmt|;
name|end
operator|->
name|end
operator|=
name|ctx
operator|->
name|end
expr_stmt|;
name|end
operator|->
name|free_after
operator|=
literal|0
expr_stmt|;
name|end
operator|->
name|flags
operator|=
name|DMAR_MAP_ENTRY_PLACE
operator||
name|DMAR_MAP_ENTRY_UNMAPPED
expr_stmt|;
name|dmar_gas_rb_insert
argument_list|(
name|ctx
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|first_place
operator|=
name|begin
expr_stmt|;
name|ctx
operator|->
name|last_place
operator|=
name|end
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmar_gas_fini_ctx
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|entry1
decl_stmt|;
name|DMAR_CTX_ASSERT_LOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ctx
operator|->
name|entries_cnt
operator|==
literal|2
argument_list|,
operator|(
literal|"ctx still in use %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|RB_MIN
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|start
operator|==
literal|0
argument_list|,
operator|(
literal|"start entry start %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|==
name|DMAR_PAGE_SIZE
argument_list|,
operator|(
literal|"start entry end %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|==
name|DMAR_MAP_ENTRY_PLACE
argument_list|,
operator|(
literal|"start entry flags %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
name|RB_MAX
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|start
operator|==
name|ctx
operator|->
name|end
argument_list|,
operator|(
literal|"end entry start %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|==
name|ctx
operator|->
name|end
argument_list|,
operator|(
literal|"end entry end %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|free_after
operator|==
literal|0
argument_list|,
operator|(
literal|"end entry free_after%p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|==
name|DMAR_MAP_ENTRY_PLACE
argument_list|,
operator|(
literal|"end entry flags %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|dmar_gas_entries_tree
argument_list|,
argument|&ctx->rb_root
argument_list|,
argument|entry1
argument_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_RMRR
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"non-RMRR entry left %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_struct
struct|struct
name|dmar_gas_match_args
block|{
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|dmar_gaddr_t
name|size
decl_stmt|;
specifier|const
name|struct
name|bus_dma_tag_common
modifier|*
name|common
decl_stmt|;
name|u_int
name|gas_flags
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|bool
name|dmar_gas_match_one
parameter_list|(
name|struct
name|dmar_gas_match_args
modifier|*
name|a
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|prev
parameter_list|,
name|dmar_gaddr_t
name|end
parameter_list|)
block|{
name|dmar_gaddr_t
name|bs
decl_stmt|,
name|start
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|entry
operator|->
name|start
operator|+
name|a
operator|->
name|size
operator|>
name|end
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* DMAR_PAGE_SIZE to create gap after new entry. */
if|if
condition|(
name|a
operator|->
name|entry
operator|->
name|start
operator|<
name|prev
operator|->
name|end
operator|+
name|DMAR_PAGE_SIZE
operator|||
name|a
operator|->
name|entry
operator|->
name|start
operator|+
name|a
operator|->
name|size
operator|+
name|DMAR_PAGE_SIZE
operator|>
name|prev
operator|->
name|end
operator|+
name|prev
operator|->
name|free_after
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* No boundary crossing. */
if|if
condition|(
name|dmar_test_boundary
argument_list|(
name|a
operator|->
name|entry
operator|->
name|start
argument_list|,
name|a
operator|->
name|size
argument_list|,
name|a
operator|->
name|common
operator|->
name|boundary
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* 	 * The start to start + size region crosses the boundary. 	 * Check if there is enough space after the next boundary 	 * after the prev->end. 	 */
name|bs
operator|=
operator|(
name|a
operator|->
name|entry
operator|->
name|start
operator|+
name|a
operator|->
name|common
operator|->
name|boundary
operator|)
operator|&
operator|~
operator|(
name|a
operator|->
name|common
operator|->
name|boundary
operator|-
literal|1
operator|)
expr_stmt|;
name|start
operator|=
name|roundup2
argument_list|(
name|bs
argument_list|,
name|a
operator|->
name|common
operator|->
name|alignment
argument_list|)
expr_stmt|;
comment|/* DMAR_PAGE_SIZE to create gap after new entry. */
if|if
condition|(
name|start
operator|+
name|a
operator|->
name|size
operator|+
name|DMAR_PAGE_SIZE
operator|<=
name|prev
operator|->
name|end
operator|+
name|prev
operator|->
name|free_after
operator|&&
name|start
operator|+
name|a
operator|->
name|size
operator|<=
name|end
condition|)
block|{
name|a
operator|->
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * Not enough space to align at boundary, but allowed to split. 	 * We already checked that start + size does not overlap end. 	 * 	 * XXXKIB. It is possible that bs is exactly at the start of 	 * the next entry, then we do not have gap.  Ignore for now. 	 */
if|if
condition|(
operator|(
name|a
operator|->
name|gas_flags
operator|&
name|DMAR_GM_CANSPLIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|a
operator|->
name|size
operator|=
name|bs
operator|-
name|a
operator|->
name|entry
operator|->
name|start
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_gas_match_insert
parameter_list|(
name|struct
name|dmar_gas_match_args
modifier|*
name|a
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|prev
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|next
decl_stmt|;
name|bool
name|found
decl_stmt|;
comment|/* 	 * The prev->end is always aligned on the page size, which 	 * causes page alignment for the entry->start too.  The size 	 * is checked to be multiple of the page size. 	 * 	 * The page sized gap is created between consequent 	 * allocations to ensure that out-of-bounds accesses fault. 	 */
name|a
operator|->
name|entry
operator|->
name|end
operator|=
name|a
operator|->
name|entry
operator|->
name|start
operator|+
name|a
operator|->
name|size
expr_stmt|;
name|next
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|next
operator|->
name|start
operator|>=
name|a
operator|->
name|entry
operator|->
name|end
operator|&&
name|next
operator|->
name|start
operator|-
name|a
operator|->
name|entry
operator|->
name|start
operator|>=
name|a
operator|->
name|size
argument_list|,
operator|(
literal|"dmar_gas_match_insert hole failed %p prev (%jx, %jx) "
literal|"free_after %jx next (%jx, %jx) entry (%jx, %jx)"
operator|,
name|a
operator|->
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|prev
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|prev
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|prev
operator|->
name|free_after
operator|,
operator|(
name|uintmax_t
operator|)
name|next
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|next
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|entry
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|->
name|free_after
operator|=
name|a
operator|->
name|entry
operator|->
name|start
operator|-
name|prev
operator|->
name|end
expr_stmt|;
name|a
operator|->
name|entry
operator|->
name|free_after
operator|=
name|next
operator|->
name|start
operator|-
name|a
operator|->
name|entry
operator|->
name|end
expr_stmt|;
name|found
operator|=
name|dmar_gas_rb_insert
argument_list|(
name|a
operator|->
name|ctx
argument_list|,
name|a
operator|->
name|entry
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|found
argument_list|,
operator|(
literal|"found dup %p start %jx size %jx"
operator|,
name|a
operator|->
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|a
operator|->
name|size
operator|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|entry
operator|->
name|flags
operator|=
name|DMAR_MAP_ENTRY_MAP
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|a
operator|->
name|entry
argument_list|)
operator|==
name|prev
argument_list|,
operator|(
literal|"entry %p prev %p inserted prev %p"
operator|,
name|a
operator|->
name|entry
operator|,
name|prev
operator|,
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|a
operator|->
name|entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|a
operator|->
name|entry
argument_list|)
operator|==
name|next
argument_list|,
operator|(
literal|"entry %p next %p inserted next %p"
operator|,
name|a
operator|->
name|entry
operator|,
name|next
operator|,
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|a
operator|->
name|entry
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_gas_lowermatch
parameter_list|(
name|struct
name|dmar_gas_match_args
modifier|*
name|a
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|prev
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|l
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|prev
operator|->
name|end
operator|<
name|a
operator|->
name|common
operator|->
name|lowaddr
condition|)
block|{
name|a
operator|->
name|entry
operator|->
name|start
operator|=
name|roundup2
argument_list|(
name|prev
operator|->
name|end
operator|+
name|DMAR_PAGE_SIZE
argument_list|,
name|a
operator|->
name|common
operator|->
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_gas_match_one
argument_list|(
name|a
argument_list|,
name|prev
argument_list|,
name|a
operator|->
name|common
operator|->
name|lowaddr
argument_list|)
condition|)
block|{
name|dmar_gas_match_insert
argument_list|(
name|a
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|prev
operator|->
name|free_down
operator|<
name|a
operator|->
name|size
operator|+
name|DMAR_PAGE_SIZE
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|l
operator|=
name|RB_LEFT
argument_list|(
name|prev
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|dmar_gas_lowermatch
argument_list|(
name|a
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|l
operator|=
name|RB_RIGHT
argument_list|(
name|prev
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|!=
name|NULL
condition|)
return|return
operator|(
name|dmar_gas_lowermatch
argument_list|(
name|a
argument_list|,
name|l
argument_list|)
operator|)
return|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_gas_uppermatch
parameter_list|(
name|struct
name|dmar_gas_match_args
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
name|find_entry
decl_stmt|;
name|find_entry
operator|.
name|start
operator|=
name|a
operator|->
name|common
operator|->
name|highaddr
expr_stmt|;
name|next
operator|=
name|RB_NFIND
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
operator|&
name|find_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|prev
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no prev %p %jx"
operator|,
name|a
operator|->
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|find_entry
operator|.
name|start
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|a
operator|->
name|entry
operator|->
name|start
operator|=
name|prev
operator|->
name|start
operator|+
name|DMAR_PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|entry
operator|->
name|start
operator|<
name|a
operator|->
name|common
operator|->
name|highaddr
condition|)
name|a
operator|->
name|entry
operator|->
name|start
operator|=
name|a
operator|->
name|common
operator|->
name|highaddr
expr_stmt|;
name|a
operator|->
name|entry
operator|->
name|start
operator|=
name|roundup2
argument_list|(
name|a
operator|->
name|entry
operator|->
name|start
argument_list|,
name|a
operator|->
name|common
operator|->
name|alignment
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_gas_match_one
argument_list|(
name|a
argument_list|,
name|prev
argument_list|,
name|a
operator|->
name|ctx
operator|->
name|end
argument_list|)
condition|)
block|{
name|dmar_gas_match_insert
argument_list|(
name|a
argument_list|,
name|prev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * XXXKIB.  This falls back to linear iteration over 		 * the free space in the high region.  But high 		 * regions are almost unused, the code should be 		 * enough to cover the case, although in the 		 * non-optimal way. 		 */
name|prev
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|a
operator|->
name|ctx
operator|->
name|rb_root
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|next
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no next %p %jx"
operator|,
name|a
operator|->
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|find_entry
operator|.
name|start
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|end
operator|>=
name|a
operator|->
name|ctx
operator|->
name|end
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_gas_find_space
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|bus_dma_tag_common
modifier|*
name|common
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_gas_match_args
name|a
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DMAR_CTX_ASSERT_LOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"dirty entry %p %p"
operator|,
name|ctx
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"size %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|a
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|a
operator|.
name|common
operator|=
name|common
expr_stmt|;
name|a
operator|.
name|gas_flags
operator|=
name|flags
expr_stmt|;
name|a
operator|.
name|entry
operator|=
name|entry
expr_stmt|;
comment|/* Handle lower region. */
if|if
condition|(
name|common
operator|->
name|lowaddr
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|dmar_gas_lowermatch
argument_list|(
operator|&
name|a
argument_list|,
name|RB_ROOT
argument_list|(
operator|&
name|ctx
operator|->
name|rb_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|error
operator|==
name|ENOMEM
argument_list|,
operator|(
literal|"error %d from dmar_gas_lowermatch"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle upper region. */
if|if
condition|(
name|common
operator|->
name|highaddr
operator|>=
name|ctx
operator|->
name|end
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|dmar_gas_uppermatch
argument_list|(
operator|&
name|a
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
name|ENOMEM
argument_list|,
operator|(
literal|"error %d from dmar_gas_uppermatch"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_gas_alloc_region
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|bool
name|found
decl_stmt|;
name|DMAR_CTX_ASSERT_LOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|start
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|!=
literal|0
operator|||
operator|(
name|entry
operator|->
name|end
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|start
operator|>=
name|entry
operator|->
name|end
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|end
operator|>=
name|ctx
operator|->
name|end
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|next
operator|=
name|RB_NFIND
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|next
operator|!=
name|NULL
argument_list|,
operator|(
literal|"next must be non-null %p %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* prev could be NULL */
comment|/* 	 * Adapt to broken BIOSes which specify overlapping RMRR 	 * entries. 	 * 	 * XXXKIB: this does not handle a case when prev or next 	 * entries are completely covered by the current one, which 	 * extends both ways. 	 */
if|if
condition|(
name|prev
operator|!=
name|NULL
operator|&&
name|prev
operator|->
name|end
operator|>
name|entry
operator|->
name|start
operator|&&
operator|(
name|prev
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_PLACE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|prev
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_RMRR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|entry
operator|->
name|start
operator|=
name|prev
operator|->
name|end
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|->
name|start
operator|<
name|entry
operator|->
name|end
operator|&&
operator|(
name|next
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_PLACE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|next
operator|->
name|flags
operator|&
name|DMAR_MAP_ENTRY_RMRR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|entry
operator|->
name|end
operator|=
name|next
operator|->
name|start
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|end
operator|==
name|entry
operator|->
name|start
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|prev
operator|!=
name|NULL
operator|&&
name|prev
operator|->
name|end
operator|>
name|entry
operator|->
name|start
condition|)
block|{
comment|/* This assumes that prev is the placeholder entry. */
name|dmar_gas_rb_remove
argument_list|(
name|ctx
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
name|NULL
operator|&&
name|next
operator|->
name|start
operator|<
name|entry
operator|->
name|end
condition|)
block|{
name|dmar_gas_rb_remove
argument_list|(
name|ctx
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|found
operator|=
name|dmar_gas_rb_insert
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|found
argument_list|,
operator|(
literal|"found RMRR dup %p start %jx end %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|start
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
name|DMAR_MAP_ENTRY_RMRR
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|dmar_map_entry
modifier|*
name|ip
decl_stmt|,
modifier|*
name|in
decl_stmt|;
name|ip
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|in
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|prev
operator|==
name|NULL
operator|||
name|ip
operator|==
name|prev
argument_list|,
operator|(
literal|"RMRR %p (%jx %jx) prev %p (%jx %jx) ins prev %p (%jx %jx)"
operator|,
name|entry
operator|,
name|entry
operator|->
name|start
operator|,
name|entry
operator|->
name|end
operator|,
name|prev
operator|,
name|prev
operator|==
name|NULL
condition|?
literal|0
else|:
name|prev
operator|->
name|start
operator|,
name|prev
operator|==
name|NULL
condition|?
literal|0
else|:
name|prev
operator|->
name|end
operator|,
name|ip
operator|,
name|ip
operator|==
name|NULL
condition|?
literal|0
else|:
name|ip
operator|->
name|start
operator|,
name|ip
operator|==
name|NULL
condition|?
literal|0
else|:
name|ip
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|next
operator|==
name|NULL
operator|||
name|in
operator|==
name|next
argument_list|,
operator|(
literal|"RMRR %p (%jx %jx) next %p (%jx %jx) ins next %p (%jx %jx)"
operator|,
name|entry
operator|,
name|entry
operator|->
name|start
operator|,
name|entry
operator|->
name|end
operator|,
name|next
operator|,
name|next
operator|==
name|NULL
condition|?
literal|0
else|:
name|next
operator|->
name|start
operator|,
name|next
operator|==
name|NULL
condition|?
literal|0
else|:
name|next
operator|->
name|end
operator|,
name|in
operator|,
name|in
operator|==
name|NULL
condition|?
literal|0
else|:
name|in
operator|->
name|start
operator|,
name|in
operator|==
name|NULL
condition|?
literal|0
else|:
name|in
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_gas_free_space
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|DMAR_CTX_ASSERT_LOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
operator|(
name|DMAR_MAP_ENTRY_PLACE
operator||
name|DMAR_MAP_ENTRY_RMRR
operator||
name|DMAR_MAP_ENTRY_MAP
operator|)
operator|)
operator|==
name|DMAR_MAP_ENTRY_MAP
argument_list|,
operator|(
literal|"permanent entry %p %p"
operator|,
name|ctx
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|dmar_gas_rb_remove
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|DMAR_MAP_ENTRY_MAP
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dmar_check_free
condition|)
name|dmar_gas_check_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_gas_free_region
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|DMAR_CTX_ASSERT_LOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|entry
operator|->
name|flags
operator|&
operator|(
name|DMAR_MAP_ENTRY_PLACE
operator||
name|DMAR_MAP_ENTRY_RMRR
operator||
name|DMAR_MAP_ENTRY_MAP
operator|)
operator|)
operator|==
name|DMAR_MAP_ENTRY_RMRR
argument_list|,
operator|(
literal|"non-RMRR entry %p %p"
operator|,
name|ctx
operator|,
name|entry
operator|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|RB_PREV
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|next
operator|=
name|RB_NEXT
argument_list|(
name|dmar_gas_entries_tree
argument_list|,
operator|&
name|ctx
operator|->
name|rb_root
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|dmar_gas_rb_remove
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|&=
operator|~
name|DMAR_MAP_ENTRY_RMRR
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|dmar_gas_rb_insert
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|first_place
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
name|dmar_gas_rb_insert
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|last_place
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmar_gas_map
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|struct
name|bus_dma_tag_common
modifier|*
name|common
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|u_int
name|eflags
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|DMAR_GM_CANWAIT
operator||
name|DMAR_GM_CANSPLIT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid flags 0x%x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|dmar_gas_alloc_entry
argument_list|(
name|ctx
argument_list|,
operator|(
name|flags
operator|&
name|DMAR_GM_CANWAIT
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PGF_WAITOK
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_gas_find_space
argument_list|(
name|ctx
argument_list|,
name|common
argument_list|,
name|size
argument_list|,
name|flags
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|dmar_check_free
condition|)
name|dmar_gas_check_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unexpected error %d from dmar_gas_find_entry"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|end
operator|<
name|ctx
operator|->
name|end
argument_list|,
operator|(
literal|"allocated GPA %jx, max GPA %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|entry
operator|->
name|end
operator|,
operator|(
name|uintmax_t
operator|)
name|ctx
operator|->
name|end
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator||=
name|eflags
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctx_map_buf
argument_list|(
name|ctx
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|size
argument_list|,
name|ma
argument_list|,
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_READ
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_R
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_WRITE
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_W
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_SNOOP
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_SNP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_TM
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_TM
else|:
literal|0
operator|)
argument_list|,
operator|(
name|flags
operator|&
name|DMAR_GM_CANWAIT
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PGF_WAITOK
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|dmar_gas_free_space
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unexpected error %d from ctx_map_buf"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|entry
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_gas_map_region
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|,
name|u_int
name|eflags
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|)
block|{
name|dmar_gaddr_t
name|start
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|entry
operator|->
name|flags
operator|==
literal|0
argument_list|,
operator|(
literal|"used RMRR entry %p %p %x"
operator|,
name|ctx
operator|,
name|entry
operator|,
name|entry
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|DMAR_GM_CANWAIT
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid flags 0x%x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|start
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_gas_alloc_region
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|entry
operator|->
name|flags
operator||=
name|eflags
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|end
operator|==
name|entry
operator|->
name|start
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|ctx_map_buf
argument_list|(
name|ctx
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
argument_list|,
name|ma
operator|+
name|OFF_TO_IDX
argument_list|(
name|start
operator|-
name|entry
operator|->
name|start
argument_list|)
argument_list|,
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_READ
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_R
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_WRITE
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_W
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_SNOOP
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_SNP
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|eflags
operator|&
name|DMAR_MAP_ENTRY_TM
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PTE_TM
else|:
literal|0
operator|)
argument_list|,
operator|(
name|flags
operator|&
name|DMAR_GM_CANWAIT
operator|)
operator|!=
literal|0
condition|?
name|DMAR_PGF_WAITOK
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
block|{
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|dmar_gas_free_region
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|entry
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"unexpected error %d from ctx_map_buf"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_gas_reserve_region
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|start
parameter_list|,
name|dmar_gaddr_t
name|end
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entry
operator|=
name|dmar_gas_alloc_entry
argument_list|(
name|ctx
argument_list|,
name|DMAR_PGF_WAITOK
argument_list|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|entry
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|DMAR_CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_gas_alloc_region
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|,
name|DMAR_GM_CANWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|entry
operator|->
name|flags
operator||=
name|DMAR_MAP_ENTRY_UNMAPPED
expr_stmt|;
name|DMAR_CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|dmar_gas_free_entry
argument_list|(
name|ctx
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

