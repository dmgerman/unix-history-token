begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2015 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEV_APIC
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"opt_apic.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/accommon.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_APIC
end_ifdef

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/apicvar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DMAR_FAULT_IRQ_RID
value|0
end_define

begin_define
define|#
directive|define
name|DMAR_QI_IRQ_RID
value|1
end_define

begin_define
define|#
directive|define
name|DMAR_REG_RID
value|2
end_define

begin_decl_stmt
specifier|static
name|devclass_t
name|dmar_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_t
modifier|*
name|dmar_devs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dmar_devcnt
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|dmar_iter_t
function_decl|)
parameter_list|(
name|ACPI_DMAR_HEADER
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|void
name|dmar_iterate_tbl
parameter_list|(
name|dmar_iter_t
name|iter
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ACPI_TABLE_DMAR
modifier|*
name|dmartbl
decl_stmt|;
name|ACPI_DMAR_HEADER
modifier|*
name|dmarh
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_DMAR
argument_list|,
literal|1
argument_list|,
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|*
operator|)
operator|&
name|dmartbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|dmartbl
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dmartbl
argument_list|)
expr_stmt|;
name|ptrend
operator|=
operator|(
name|char
operator|*
operator|)
name|dmartbl
operator|+
name|dmartbl
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
break|break;
name|dmarh
operator|=
operator|(
name|ACPI_DMAR_HEADER
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|dmarh
operator|->
name|Length
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_identify: corrupted DMAR table, l %d\n"
argument_list|,
name|dmarh
operator|->
name|Length
argument_list|)
expr_stmt|;
break|break;
block|}
name|ptr
operator|+=
name|dmarh
operator|->
name|Length
expr_stmt|;
if|if
condition|(
operator|!
name|iter
argument_list|(
name|dmarh
argument_list|,
name|arg
argument_list|)
condition|)
break|break;
block|}
name|AcpiPutTable
argument_list|(
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|)
name|dmartbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|find_iter_args
block|{
name|int
name|i
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|res
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dmar_find_iter
parameter_list|(
name|ACPI_DMAR_HEADER
modifier|*
name|dmarh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|find_iter_args
modifier|*
name|fia
decl_stmt|;
if|if
condition|(
name|dmarh
operator|->
name|Type
operator|!=
name|ACPI_DMAR_TYPE_HARDWARE_UNIT
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fia
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|fia
operator|->
name|i
operator|==
literal|0
condition|)
block|{
name|fia
operator|->
name|res
operator|=
operator|(
name|ACPI_DMAR_HARDWARE_UNIT
operator|*
operator|)
name|dmarh
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|fia
operator|->
name|i
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmar_find_by_index
parameter_list|(
name|int
name|idx
parameter_list|)
block|{
name|struct
name|find_iter_args
name|fia
decl_stmt|;
name|fia
operator|.
name|i
operator|=
name|idx
expr_stmt|;
name|fia
operator|.
name|res
operator|=
name|NULL
expr_stmt|;
name|dmar_iterate_tbl
argument_list|(
name|dmar_find_iter
argument_list|,
operator|&
name|fia
argument_list|)
expr_stmt|;
return|return
operator|(
name|fia
operator|.
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_count_iter
parameter_list|(
name|ACPI_DMAR_HEADER
modifier|*
name|dmarh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dmarh
operator|->
name|Type
operator|==
name|ACPI_DMAR_TYPE_HARDWARE_UNIT
condition|)
name|dmar_devcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|dmar_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dmar_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
name|ACPI_TABLE_DMAR
modifier|*
name|dmartbl
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmarh
decl_stmt|;
name|ACPI_STATUS
name|status
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|acpi_disabled
argument_list|(
literal|"dmar"
argument_list|)
condition|)
return|return;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.dmar.enable"
argument_list|,
operator|&
name|dmar_enable
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dmar_enable
condition|)
return|return;
ifdef|#
directive|ifdef
name|INVARIANTS
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.dmar.check_free"
argument_list|,
operator|&
name|dmar_check_free
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.dmar.match_verbose"
argument_list|,
operator|&
name|dmar_match_verbose
argument_list|)
expr_stmt|;
name|status
operator|=
name|AcpiGetTable
argument_list|(
name|ACPI_SIG_DMAR
argument_list|,
literal|1
argument_list|,
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|*
operator|)
operator|&
name|dmartbl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ACPI_FAILURE
argument_list|(
name|status
argument_list|)
condition|)
return|return;
name|haw
operator|=
name|dmartbl
operator|->
name|Width
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
literal|1ULL
operator|<<
operator|(
name|haw
operator|+
literal|1
operator|)
operator|)
operator|>
name|BUS_SPACE_MAXADDR
condition|)
name|dmar_high
operator|=
name|BUS_SPACE_MAXADDR
expr_stmt|;
else|else
name|dmar_high
operator|=
literal|1ULL
operator|<<
operator|(
name|haw
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"DMAR HAW=%d flags=<%b>\n"
argument_list|,
name|dmartbl
operator|->
name|Width
argument_list|,
operator|(
name|unsigned
operator|)
name|dmartbl
operator|->
name|Flags
argument_list|,
literal|"\020\001INTR_REMAP\002X2APIC_OPT_OUT"
argument_list|)
expr_stmt|;
block|}
name|AcpiPutTable
argument_list|(
operator|(
name|ACPI_TABLE_HEADER
operator|*
operator|)
name|dmartbl
argument_list|)
expr_stmt|;
name|dmar_iterate_tbl
argument_list|(
name|dmar_count_iter
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_devcnt
operator|==
literal|0
condition|)
return|return;
name|dmar_devs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|device_t
argument_list|)
operator|*
name|dmar_devcnt
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmar_devcnt
condition|;
name|i
operator|++
control|)
block|{
name|dmarh
operator|=
name|dmar_find_by_index
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmarh
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_identify: cannot find HWUNIT %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dmar_devs
index|[
name|i
index|]
operator|=
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|1
argument_list|,
literal|"dmar"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_devs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_identify: cannot create instance %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|bus_set_resource
argument_list|(
name|dmar_devs
index|[
name|i
index|]
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|DMAR_REG_RID
argument_list|,
name|dmarh
operator|->
name|Address
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dmar%d: unable to alloc register window at 0x%08jx: error %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmarh
operator|->
name|Address
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|device_delete_child
argument_list|(
name|parent
argument_list|,
name|dmar_devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dmar_devs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|acpi_get_handle
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"DMA remap"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_NOWILDCARD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_release_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|struct
name|dmar_msi_data
modifier|*
name|dmd
decl_stmt|;
name|dmd
operator|=
operator|&
name|unit
operator|->
name|intrs
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|dmd
operator|->
name|irq
operator|==
operator|-
literal|1
condition|)
return|return;
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|,
name|dmd
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dmd
operator|->
name|irq_rid
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|bus_delete_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dmd
operator|->
name|irq_rid
argument_list|)
expr_stmt|;
name|PCIB_RELEASE_MSIX
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
name|dmd
operator|->
name|irq
argument_list|)
expr_stmt|;
name|dmd
operator|->
name|irq
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_release_resources
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dmar_fini_busdma
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_fini_irt
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_fini_qi
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_fini_fault_log
argument_list|(
name|unit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAR_INTR_TOTAL
condition|;
name|i
operator|++
control|)
name|dmar_release_intr
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|regs
operator|!=
name|NULL
condition|)
block|{
name|bus_deactivate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|unit
operator|->
name|reg_rid
argument_list|,
name|unit
operator|->
name|regs
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|unit
operator|->
name|reg_rid
argument_list|,
name|unit
operator|->
name|regs
argument_list|)
expr_stmt|;
name|unit
operator|->
name|regs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|->
name|domids
operator|!=
name|NULL
condition|)
block|{
name|delete_unrhdr
argument_list|(
name|unit
operator|->
name|domids
argument_list|)
expr_stmt|;
name|unit
operator|->
name|domids
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unit
operator|->
name|ctx_obj
operator|!=
name|NULL
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|unit
operator|->
name|ctx_obj
argument_list|)
expr_stmt|;
name|unit
operator|->
name|ctx_obj
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_alloc_irq
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|device_t
name|pcib
decl_stmt|;
name|struct
name|dmar_msi_data
modifier|*
name|dmd
decl_stmt|;
name|uint64_t
name|msi_addr
decl_stmt|;
name|uint32_t
name|msi_data
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmd
operator|=
operator|&
name|unit
operator|->
name|intrs
index|[
name|idx
index|]
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Really not pcib */
name|error
operator|=
name|PCIB_ALLOC_MSIX
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
operator|&
name|dmd
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate %s interrupt, %d\n"
argument_list|,
name|dmd
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
name|error
operator|=
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dmd
operator|->
name|irq_rid
argument_list|,
name|dmd
operator|->
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot set %s interrupt resource, %d\n"
argument_list|,
name|dmd
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|dmd
operator|->
name|irq_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|dmd
operator|->
name|irq_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmd
operator|->
name|irq_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate resource for %s interrupt\n"
argument_list|,
name|dmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|err3
goto|;
block|}
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|,
name|INTR_TYPE_MISC
argument_list|,
name|dmd
operator|->
name|handler
argument_list|,
name|NULL
argument_list|,
name|unit
argument_list|,
operator|&
name|dmd
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot setup %s interrupt, %d\n"
argument_list|,
name|dmd
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err4
goto|;
block|}
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|,
name|dmd
operator|->
name|intr_handle
argument_list|,
literal|"%s"
argument_list|,
name|dmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|dmd
operator|->
name|irq
argument_list|,
operator|&
name|msi_addr
argument_list|,
operator|&
name|msi_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot map %s interrupt, %d\n"
argument_list|,
name|dmd
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|err5
goto|;
block|}
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_data_reg
argument_list|,
name|msi_data
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_addr_reg
argument_list|,
name|msi_addr
argument_list|)
expr_stmt|;
comment|/* Only for xAPIC mode */
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_uaddr_reg
argument_list|,
name|msi_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err5
label|:
name|bus_teardown_intr
argument_list|(
name|dev
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|,
name|dmd
operator|->
name|intr_handle
argument_list|)
expr_stmt|;
name|err4
label|:
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dmd
operator|->
name|irq_rid
argument_list|,
name|dmd
operator|->
name|irq_res
argument_list|)
expr_stmt|;
name|err3
label|:
name|bus_delete_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|dmd
operator|->
name|irq_rid
argument_list|)
expr_stmt|;
name|err2
label|:
name|PCIB_RELEASE_MSIX
argument_list|(
name|pcib
argument_list|,
name|dev
argument_list|,
name|dmd
operator|->
name|irq
argument_list|)
expr_stmt|;
name|dmd
operator|->
name|irq
operator|=
operator|-
literal|1
expr_stmt|;
name|err1
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_APIC
end_ifdef

begin_function
specifier|static
name|int
name|dmar_remap_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|irq
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_msi_data
modifier|*
name|dmd
decl_stmt|;
name|uint64_t
name|msi_addr
decl_stmt|;
name|uint32_t
name|msi_data
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|unit
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAR_INTR_TOTAL
condition|;
name|i
operator|++
control|)
block|{
name|dmd
operator|=
operator|&
name|unit
operator|->
name|intrs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|irq
operator|==
name|dmd
operator|->
name|irq
condition|)
block|{
name|error
operator|=
name|PCIB_MAP_MSI
argument_list|(
name|device_get_parent
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|)
argument_list|,
name|dev
argument_list|,
name|irq
argument_list|,
operator|&
name|msi_addr
argument_list|,
operator|&
name|msi_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
call|(
name|dmd
operator|->
name|disable_intr
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_data_reg
argument_list|,
name|msi_data
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_addr_reg
argument_list|,
name|msi_addr
argument_list|)
expr_stmt|;
name|dmar_write4
argument_list|(
name|unit
argument_list|,
name|dmd
operator|->
name|msi_uaddr_reg
argument_list|,
name|msi_addr
operator|>>
literal|32
argument_list|)
expr_stmt|;
call|(
name|dmd
operator|->
name|enable_intr
call|)
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|dmar_print_caps
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmaru
parameter_list|)
block|{
name|uint32_t
name|caphi
decl_stmt|,
name|ecaphi
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"regs@0x%08jx, ver=%d.%d, seg=%d, flags=<%b>\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmaru
operator|->
name|Address
argument_list|,
name|DMAR_MAJOR_VER
argument_list|(
name|unit
operator|->
name|hw_ver
argument_list|)
argument_list|,
name|DMAR_MINOR_VER
argument_list|(
name|unit
operator|->
name|hw_ver
argument_list|)
argument_list|,
name|dmaru
operator|->
name|Segment
argument_list|,
name|dmaru
operator|->
name|Flags
argument_list|,
literal|"\020\001INCLUDE_ALL_PCI"
argument_list|)
expr_stmt|;
name|caphi
operator|=
name|unit
operator|->
name|hw_cap
operator|>>
literal|32
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cap=%b,"
argument_list|,
operator|(
name|u_int
operator|)
name|unit
operator|->
name|hw_cap
argument_list|,
literal|"\020\004AFL\005WBF\006PLMR\007PHMR\010CM\027ZLR\030ISOCH"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%b, "
argument_list|,
name|caphi
argument_list|,
literal|"\020\010PSI\027DWD\030DRD\031FL1GP\034PSI"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ndoms=%d, sagaw=%d, mgaw=%d, fro=%d, nfr=%d, superp=%d"
argument_list|,
name|DMAR_CAP_ND
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|,
name|DMAR_CAP_SAGAW
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|,
name|DMAR_CAP_MGAW
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|,
name|DMAR_CAP_FRO
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|,
name|DMAR_CAP_NFR
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|,
name|DMAR_CAP_SPS
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_PSI
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", mamv=%d"
argument_list|,
name|DMAR_CAP_MAMV
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|ecaphi
operator|=
name|unit
operator|->
name|hw_ecap
operator|>>
literal|32
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ecap=%b,"
argument_list|,
operator|(
name|u_int
operator|)
name|unit
operator|->
name|hw_ecap
argument_list|,
literal|"\020\001C\002QI\003DI\004IR\005EIM\007PT\010SC\031ECS\032MTS"
literal|"\033NEST\034DIS\035PASID\036PRS\037ERS\040SRS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%b, "
argument_list|,
name|ecaphi
argument_list|,
literal|"\020\002NWFS\003EAFS"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mhmw=%d, iro=%d\n"
argument_list|,
name|DMAR_ECAP_MHMV
argument_list|(
name|unit
operator|->
name|hw_ecap
argument_list|)
argument_list|,
name|DMAR_ECAP_IRO
argument_list|(
name|unit
operator|->
name|hw_ecap
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmaru
decl_stmt|;
name|uint64_t
name|timeout
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|unit
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unit
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|unit
operator|->
name|unit
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dmaru
operator|=
name|dmar_find_by_index
argument_list|(
name|unit
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmaru
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unit
operator|->
name|segment
operator|=
name|dmaru
operator|->
name|Segment
expr_stmt|;
name|unit
operator|->
name|base
operator|=
name|dmaru
operator|->
name|Address
expr_stmt|;
name|unit
operator|->
name|reg_rid
operator|=
name|DMAR_REG_RID
expr_stmt|;
name|unit
operator|->
name|regs
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|unit
operator|->
name|reg_rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|regs
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"cannot allocate register window\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|unit
operator|->
name|hw_ver
operator|=
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_VER_REG
argument_list|)
expr_stmt|;
name|unit
operator|->
name|hw_cap
operator|=
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_CAP_REG
argument_list|)
expr_stmt|;
name|unit
operator|->
name|hw_ecap
operator|=
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_ECAP_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|dmar_print_caps
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|,
name|dmaru
argument_list|)
expr_stmt|;
name|dmar_quirks_post_ident
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|dmar_get_timeout
argument_list|()
expr_stmt|;
name|TUNABLE_UINT64_FETCH
argument_list|(
literal|"hw.dmar.timeout"
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
name|dmar_update_timeout
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAR_INTR_TOTAL
condition|;
name|i
operator|++
control|)
name|unit
operator|->
name|intrs
index|[
name|i
index|]
operator|.
name|irq
operator|=
operator|-
literal|1
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|name
operator|=
literal|"fault"
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|irq_rid
operator|=
name|DMAR_FAULT_IRQ_RID
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|handler
operator|=
name|dmar_fault_intr
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|msi_data_reg
operator|=
name|DMAR_FEDATA_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|msi_addr_reg
operator|=
name|DMAR_FEADDR_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|msi_uaddr_reg
operator|=
name|DMAR_FEUADDR_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|enable_intr
operator|=
name|dmar_enable_fault_intr
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_FAULT
index|]
operator|.
name|disable_intr
operator|=
name|dmar_disable_fault_intr
expr_stmt|;
name|error
operator|=
name|dmar_alloc_irq
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|,
name|DMAR_INTR_FAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|DMAR_HAS_QI
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|name
operator|=
literal|"qi"
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|irq_rid
operator|=
name|DMAR_QI_IRQ_RID
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|handler
operator|=
name|dmar_qi_intr
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|msi_data_reg
operator|=
name|DMAR_IEDATA_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|msi_addr_reg
operator|=
name|DMAR_IEADDR_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|msi_uaddr_reg
operator|=
name|DMAR_IEUADDR_REG
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|enable_intr
operator|=
name|dmar_enable_qi_intr
expr_stmt|;
name|unit
operator|->
name|intrs
index|[
name|DMAR_INTR_QI
index|]
operator|.
name|disable_intr
operator|=
name|dmar_disable_qi_intr
expr_stmt|;
name|error
operator|=
name|dmar_alloc_irq
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|,
name|DMAR_INTR_QI
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|mtx_init
argument_list|(
operator|&
name|unit
operator|->
name|lock
argument_list|,
literal|"dmarhw"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|unit
operator|->
name|domids
operator|=
name|new_unrhdr
argument_list|(
literal|0
argument_list|,
name|dmar_nd2mask
argument_list|(
name|DMAR_CAP_ND
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
argument_list|)
argument_list|,
operator|&
name|unit
operator|->
name|lock
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unit
operator|->
name|domains
argument_list|)
expr_stmt|;
comment|/* 	 * 9.2 "Context Entry": 	 * When Caching Mode (CM) field is reported as Set, the 	 * domain-id value of zero is architecturally reserved. 	 * Software must not use domain-id value of zero 	 * when CM is Set. 	 */
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_CM
operator|)
operator|!=
literal|0
condition|)
name|alloc_unr_specific
argument_list|(
name|unit
operator|->
name|domids
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|unit
operator|->
name|ctx_obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|NULL
argument_list|,
name|IDX_TO_OFF
argument_list|(
literal|1
operator|+
name|DMAR_CTX_CNT
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and load the root entry table pointer.  Enable the 	 * address translation after the required invalidations are 	 * done. 	 */
name|dmar_pgalloc
argument_list|(
name|unit
operator|->
name|ctx_obj
argument_list|,
literal|0
argument_list|,
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_ZERO
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_load_root_entry_ptr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmar_inv_ctx_glob
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_DI
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|dmar_inv_iotlb_glob
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_init_fault_log
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmar_init_qi
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmar_init_irt
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmar_init_busdma
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NOTYET
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_enable_translation
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_release_resources
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* XXXKIB */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|dmar_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|dmar_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|dmar_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|dmar_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|dmar_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|dmar_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|dmar_resume
argument_list|)
block|,
ifdef|#
directive|ifdef
name|DEV_APIC
name|DEVMETHOD
argument_list|(
name|bus_remap_intr
argument_list|,
name|dmar_remap_intr
argument_list|)
block|,
endif|#
directive|endif
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|dmar_driver
init|=
block|{
literal|"dmar"
block|,
name|dmar_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|dmar_unit
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|dmar
argument_list|,
name|acpi
argument_list|,
name|dmar_driver
argument_list|,
name|dmar_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|dmar
argument_list|,
name|acpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dmar_print_path
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|char
modifier|*
name|banner
parameter_list|,
name|int
name|busno
parameter_list|,
name|int
name|depth
parameter_list|,
specifier|const
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s [%d, "
argument_list|,
name|banner
argument_list|,
name|busno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%d, %d)"
argument_list|,
name|path
index|[
name|i
index|]
operator|.
name|Device
argument_list|,
name|path
index|[
name|i
index|]
operator|.
name|Function
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_dev_depth
parameter_list|(
name|device_t
name|child
parameter_list|)
block|{
name|devclass_t
name|pci_class
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|pcib
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|pci_class
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
for|for
control|(
name|depth
operator|=
literal|1
init|;
condition|;
name|depth
operator|++
control|)
block|{
name|bus
operator|=
name|device_get_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
argument_list|)
operator|!=
name|pci_class
condition|)
return|return
operator|(
name|depth
operator|)
return|;
name|child
operator|=
name|pcib
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_dev_path
parameter_list|(
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|busno
parameter_list|,
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|devclass_t
name|pci_class
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|pcib
decl_stmt|;
name|pci_class
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
for|for
control|(
name|depth
operator|--
init|;
name|depth
operator|!=
operator|-
literal|1
condition|;
name|depth
operator|--
control|)
block|{
name|path
index|[
name|depth
index|]
operator|.
name|Device
operator|=
name|pci_get_slot
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|path
index|[
name|depth
index|]
operator|.
name|Function
operator|=
name|pci_get_function
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|bus
operator|=
name|device_get_parent
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
argument_list|)
operator|!=
name|pci_class
condition|)
block|{
comment|/* reached a host bridge */
operator|*
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return;
block|}
name|child
operator|=
name|pcib
expr_stmt|;
block|}
name|panic
argument_list|(
literal|"wrong depth"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_match_pathes
parameter_list|(
name|int
name|busno1
parameter_list|,
specifier|const
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path1
parameter_list|,
name|int
name|depth1
parameter_list|,
name|int
name|busno2
parameter_list|,
specifier|const
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path2
parameter_list|,
name|int
name|depth2
parameter_list|,
name|enum
name|AcpiDmarScopeType
name|scope_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|depth
decl_stmt|;
if|if
condition|(
name|busno1
operator|!=
name|busno2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|scope_type
operator|==
name|ACPI_DMAR_SCOPE_TYPE_ENDPOINT
operator|&&
name|depth1
operator|!=
name|depth2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|depth
operator|=
name|depth1
expr_stmt|;
if|if
condition|(
name|depth2
operator|<
name|depth
condition|)
name|depth
operator|=
name|depth2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|path1
index|[
name|i
index|]
operator|.
name|Device
operator|!=
name|path2
index|[
name|i
index|]
operator|.
name|Device
operator|||
name|path1
index|[
name|i
index|]
operator|.
name|Function
operator|!=
name|path2
index|[
name|i
index|]
operator|.
name|Function
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_match_devscope
parameter_list|(
name|ACPI_DMAR_DEVICE_SCOPE
modifier|*
name|devscope
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|dev_busno
parameter_list|,
specifier|const
name|ACPI_DMAR_PCI_PATH
modifier|*
name|dev_path
parameter_list|,
name|int
name|dev_path_len
parameter_list|)
block|{
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path
decl_stmt|;
name|int
name|path_len
decl_stmt|;
if|if
condition|(
name|devscope
operator|->
name|Length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|devscope
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_find: corrupted DMAR table, dl %d\n"
argument_list|,
name|devscope
operator|->
name|Length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|devscope
operator|->
name|EntryType
operator|!=
name|ACPI_DMAR_SCOPE_TYPE_ENDPOINT
operator|&&
name|devscope
operator|->
name|EntryType
operator|!=
name|ACPI_DMAR_SCOPE_TYPE_BRIDGE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|path_len
operator|=
name|devscope
operator|->
name|Length
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|devscope
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_len
operator|%
literal|2
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_find_bsf: corrupted DMAR table, dl %d\n"
argument_list|,
name|devscope
operator|->
name|Length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|path_len
operator|/=
literal|2
expr_stmt|;
name|path
operator|=
operator|(
name|ACPI_DMAR_PCI_PATH
operator|*
operator|)
operator|(
name|devscope
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|path_len
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dmar_find: corrupted DMAR table, dl %d\n"
argument_list|,
name|devscope
operator|->
name|Length
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dmar_match_verbose
condition|)
name|dmar_print_path
argument_list|(
name|dev
argument_list|,
literal|"DMAR"
argument_list|,
name|devscope
operator|->
name|Bus
argument_list|,
name|path_len
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmar_match_pathes
argument_list|(
name|devscope
operator|->
name|Bus
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|dev_busno
argument_list|,
name|dev_path
argument_list|,
name|dev_path_len
argument_list|,
name|devscope
operator|->
name|EntryType
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|dmar_unit
modifier|*
name|dmar_find
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|dmar_dev
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmarh
decl_stmt|;
name|ACPI_DMAR_DEVICE_SCOPE
modifier|*
name|devscope
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|int
name|i
decl_stmt|,
name|match
decl_stmt|,
name|dev_domain
decl_stmt|,
name|dev_busno
decl_stmt|,
name|dev_path_len
decl_stmt|;
name|dmar_dev
operator|=
name|NULL
expr_stmt|;
name|dev_domain
operator|=
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev_path_len
operator|=
name|dmar_dev_depth
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ACPI_DMAR_PCI_PATH
name|dev_path
index|[
name|dev_path_len
index|]
decl_stmt|;
name|dmar_dev_path
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_busno
argument_list|,
name|dev_path
argument_list|,
name|dev_path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
name|dmar_print_path
argument_list|(
name|dev
argument_list|,
literal|"PCI"
argument_list|,
name|dev_busno
argument_list|,
name|dev_path_len
argument_list|,
name|dev_path
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmar_devcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dmar_devs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|dmarh
operator|=
name|dmar_find_by_index
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmarh
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|dmarh
operator|->
name|Segment
operator|!=
name|dev_domain
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dmarh
operator|->
name|Flags
operator|&
name|ACPI_DMAR_INCLUDE_ALL
operator|)
operator|!=
literal|0
condition|)
block|{
name|dmar_dev
operator|=
name|dmar_devs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pci%d:%d:%d:%d matched dmar%d INCLUDE_ALL\n"
argument_list|,
name|dev_domain
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|dmar_unit
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dmar_dev
argument_list|)
operator|)
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|found
goto|;
block|}
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|dmarh
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dmarh
argument_list|)
expr_stmt|;
name|ptrend
operator|=
operator|(
name|char
operator|*
operator|)
name|dmarh
operator|+
name|dmarh
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
break|break;
name|devscope
operator|=
operator|(
name|ACPI_DMAR_DEVICE_SCOPE
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|devscope
operator|->
name|Length
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pci%d:%d:%d:%d matching dmar%d\n"
argument_list|,
name|dev_domain
argument_list|,
name|pci_get_bus
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|(
operator|(
expr|struct
name|dmar_unit
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dmar_devs
index|[
name|i
index|]
argument_list|)
operator|)
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
name|match
operator|=
name|dmar_match_devscope
argument_list|(
name|devscope
argument_list|,
name|dev
argument_list|,
name|dev_busno
argument_list|,
name|dev_path
argument_list|,
name|dev_path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
if|if
condition|(
name|match
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"table error\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|match
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"not matched\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"matched\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
elseif|else
if|if
condition|(
name|match
operator|==
literal|1
condition|)
block|{
name|dmar_dev
operator|=
name|dmar_devs
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
name|found
label|:
return|return
operator|(
name|device_get_softc
argument_list|(
name|dmar_dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dmar_unit
modifier|*
name|dmar_find_nonpci
parameter_list|(
name|u_int
name|id
parameter_list|,
name|u_int
name|entry_type
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
block|{
name|device_t
name|dmar_dev
decl_stmt|;
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|ACPI_DMAR_HARDWARE_UNIT
modifier|*
name|dmarh
decl_stmt|;
name|ACPI_DMAR_DEVICE_SCOPE
modifier|*
name|devscope
decl_stmt|;
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
ifdef|#
directive|ifdef
name|DEV_APIC
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmar_devcnt
condition|;
name|i
operator|++
control|)
block|{
name|dmar_dev
operator|=
name|dmar_devs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|dmar_dev
operator|==
name|NULL
condition|)
continue|continue;
name|unit
operator|=
operator|(
expr|struct
name|dmar_unit
operator|*
operator|)
name|device_get_softc
argument_list|(
name|dmar_dev
argument_list|)
expr_stmt|;
name|dmarh
operator|=
name|dmar_find_by_index
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmarh
operator|==
name|NULL
condition|)
continue|continue;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|dmarh
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|dmarh
argument_list|)
expr_stmt|;
name|ptrend
operator|=
operator|(
name|char
operator|*
operator|)
name|dmarh
operator|+
name|dmarh
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
break|break;
name|devscope
operator|=
operator|(
name|ACPI_DMAR_DEVICE_SCOPE
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|devscope
operator|->
name|Length
expr_stmt|;
if|if
condition|(
name|devscope
operator|->
name|EntryType
operator|!=
name|entry_type
condition|)
continue|continue;
if|if
condition|(
name|devscope
operator|->
name|EnumerationId
operator|!=
name|id
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|DEV_APIC
if|if
condition|(
name|entry_type
operator|==
name|ACPI_DMAR_SCOPE_TYPE_IOAPIC
condition|)
block|{
name|error
operator|=
name|ioapic_get_rid
argument_list|(
name|id
argument_list|,
name|rid
argument_list|)
expr_stmt|;
comment|/* 				 * If our IOAPIC has PCI bindings then 				 * use the PCI device rid. 				 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|unit
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|devscope
operator|->
name|Length
operator|-
sizeof|sizeof
argument_list|(
name|ACPI_DMAR_DEVICE_SCOPE
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|rid
operator|!=
name|NULL
condition|)
block|{
name|path
operator|=
operator|(
name|ACPI_DMAR_PCI_PATH
operator|*
operator|)
operator|(
name|devscope
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|rid
operator|=
name|PCI_RID
argument_list|(
name|devscope
operator|->
name|Bus
argument_list|,
name|path
operator|->
name|Device
argument_list|,
name|path
operator|->
name|Function
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"dmar_find_nonpci: id %d type %d path length != 2\n"
argument_list|,
name|id
argument_list|,
name|entry_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|dmar_unit
modifier|*
name|dmar_find_hpet
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
block|{
return|return
operator|(
name|dmar_find_nonpci
argument_list|(
name|hpet_get_uid
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ACPI_DMAR_SCOPE_TYPE_HPET
argument_list|,
name|rid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|dmar_unit
modifier|*
name|dmar_find_ioapic
parameter_list|(
name|u_int
name|apic_id
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|)
block|{
return|return
operator|(
name|dmar_find_nonpci
argument_list|(
name|apic_id
argument_list|,
name|ACPI_DMAR_SCOPE_TYPE_IOAPIC
argument_list|,
name|rid
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|rmrr_iter_args
block|{
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|int
name|dev_domain
decl_stmt|;
name|int
name|dev_busno
decl_stmt|;
name|ACPI_DMAR_PCI_PATH
modifier|*
name|dev_path
decl_stmt|;
name|int
name|dev_path_len
decl_stmt|;
name|struct
name|dmar_map_entries_tailq
modifier|*
name|rmrr_entries
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dmar_rmrr_iter
parameter_list|(
name|ACPI_DMAR_HEADER
modifier|*
name|dmarh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|rmrr_iter_args
modifier|*
name|ria
decl_stmt|;
name|ACPI_DMAR_RESERVED_MEMORY
modifier|*
name|resmem
decl_stmt|;
name|ACPI_DMAR_DEVICE_SCOPE
modifier|*
name|devscope
decl_stmt|;
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|int
name|match
decl_stmt|;
if|if
condition|(
name|dmarh
operator|->
name|Type
operator|!=
name|ACPI_DMAR_TYPE_RESERVED_MEMORY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ria
operator|=
name|arg
expr_stmt|;
name|resmem
operator|=
operator|(
name|ACPI_DMAR_RESERVED_MEMORY
operator|*
operator|)
name|dmarh
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"RMRR [%jx,%jx] segment %d\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|resmem
operator|->
name|BaseAddress
argument_list|,
operator|(
name|uintmax_t
operator|)
name|resmem
operator|->
name|EndAddress
argument_list|,
name|resmem
operator|->
name|Segment
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|resmem
operator|->
name|Segment
operator|!=
name|ria
operator|->
name|dev_domain
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|resmem
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|resmem
argument_list|)
expr_stmt|;
name|ptrend
operator|=
operator|(
name|char
operator|*
operator|)
name|resmem
operator|+
name|resmem
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
break|break;
name|devscope
operator|=
operator|(
name|ACPI_DMAR_DEVICE_SCOPE
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|devscope
operator|->
name|Length
expr_stmt|;
name|match
operator|=
name|dmar_match_devscope
argument_list|(
name|devscope
argument_list|,
name|ria
operator|->
name|dev
argument_list|,
name|ria
operator|->
name|dev_busno
argument_list|,
name|ria
operator|->
name|dev_path
argument_list|,
name|ria
operator|->
name|dev_path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|dmar_match_verbose
condition|)
name|printf
argument_list|(
literal|"matched\n"
argument_list|)
expr_stmt|;
name|entry
operator|=
name|dmar_gas_alloc_entry
argument_list|(
name|ria
operator|->
name|domain
argument_list|,
name|DMAR_PGF_WAITOK
argument_list|)
expr_stmt|;
name|entry
operator|->
name|start
operator|=
name|resmem
operator|->
name|BaseAddress
expr_stmt|;
comment|/* The RMRR entry end address is inclusive. */
name|entry
operator|->
name|end
operator|=
name|resmem
operator|->
name|EndAddress
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|ria
operator|->
name|rmrr_entries
argument_list|,
name|entry
argument_list|,
name|unroll_link
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"not matched, err %d\n"
argument_list|,
name|match
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_dev_parse_rmrr
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|struct
name|dmar_map_entries_tailq
modifier|*
name|rmrr_entries
parameter_list|)
block|{
name|struct
name|rmrr_iter_args
name|ria
decl_stmt|;
name|ria
operator|.
name|dev_domain
operator|=
name|pci_get_domain
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ria
operator|.
name|dev_path_len
operator|=
name|dmar_dev_depth
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|ACPI_DMAR_PCI_PATH
name|dev_path
index|[
name|ria
operator|.
name|dev_path_len
index|]
decl_stmt|;
name|dmar_dev_path
argument_list|(
name|dev
argument_list|,
operator|&
name|ria
operator|.
name|dev_busno
argument_list|,
name|dev_path
argument_list|,
name|ria
operator|.
name|dev_path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"parsing RMRR entries for "
argument_list|)
expr_stmt|;
name|dmar_print_path
argument_list|(
name|dev
argument_list|,
literal|"PCI"
argument_list|,
name|ria
operator|.
name|dev_busno
argument_list|,
name|ria
operator|.
name|dev_path_len
argument_list|,
name|dev_path
argument_list|)
expr_stmt|;
block|}
name|ria
operator|.
name|domain
operator|=
name|domain
expr_stmt|;
name|ria
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|ria
operator|.
name|dev_path
operator|=
name|dev_path
expr_stmt|;
name|ria
operator|.
name|rmrr_entries
operator|=
name|rmrr_entries
expr_stmt|;
name|dmar_iterate_tbl
argument_list|(
name|dmar_rmrr_iter
argument_list|,
operator|&
name|ria
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|inst_rmrr_iter_args
block|{
name|struct
name|dmar_unit
modifier|*
name|dmar
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|device_t
name|dmar_path_dev
parameter_list|(
name|int
name|segment
parameter_list|,
name|int
name|path_len
parameter_list|,
name|int
name|busno
parameter_list|,
specifier|const
name|ACPI_DMAR_PCI_PATH
modifier|*
name|path
parameter_list|)
block|{
name|devclass_t
name|pci_class
decl_stmt|;
name|device_t
name|bus
decl_stmt|,
name|pcib
decl_stmt|,
name|dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pci_class
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|dev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_len
condition|;
name|i
operator|++
operator|,
name|path
operator|++
control|)
block|{
name|dev
operator|=
name|pci_find_dbsf
argument_list|(
name|segment
argument_list|,
name|busno
argument_list|,
name|path
operator|->
name|Device
argument_list|,
name|path
operator|->
name|Function
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|!=
name|path_len
operator|-
literal|1
condition|)
block|{
name|bus
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pcib
operator|=
name|device_get_parent
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|device_get_devclass
argument_list|(
name|device_get_parent
argument_list|(
name|pcib
argument_list|)
argument_list|)
operator|!=
name|pci_class
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|busno
operator|=
name|pcib_get_bus
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_inst_rmrr_iter
parameter_list|(
name|ACPI_DMAR_HEADER
modifier|*
name|dmarh
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|ACPI_DMAR_RESERVED_MEMORY
modifier|*
name|resmem
decl_stmt|;
specifier|const
name|ACPI_DMAR_DEVICE_SCOPE
modifier|*
name|devscope
decl_stmt|;
name|struct
name|inst_rmrr_iter_args
modifier|*
name|iria
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|ptrend
decl_stmt|;
name|struct
name|dmar_unit
modifier|*
name|dev_dmar
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
if|if
condition|(
name|dmarh
operator|->
name|Type
operator|!=
name|ACPI_DMAR_TYPE_RESERVED_MEMORY
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|iria
operator|=
name|arg
expr_stmt|;
name|resmem
operator|=
operator|(
name|ACPI_DMAR_RESERVED_MEMORY
operator|*
operator|)
name|dmarh
expr_stmt|;
if|if
condition|(
name|resmem
operator|->
name|Segment
operator|!=
name|iria
operator|->
name|dmar
operator|->
name|segment
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"dmar%d: RMRR [%jx,%jx]\n"
argument_list|,
name|iria
operator|->
name|dmar
operator|->
name|unit
argument_list|,
operator|(
name|uintmax_t
operator|)
name|resmem
operator|->
name|BaseAddress
argument_list|,
operator|(
name|uintmax_t
operator|)
name|resmem
operator|->
name|EndAddress
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|resmem
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|resmem
argument_list|)
expr_stmt|;
name|ptrend
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|resmem
operator|+
name|resmem
operator|->
name|Header
operator|.
name|Length
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ptr
operator|>=
name|ptrend
condition|)
break|break;
name|devscope
operator|=
operator|(
specifier|const
name|ACPI_DMAR_DEVICE_SCOPE
operator|*
operator|)
name|ptr
expr_stmt|;
name|ptr
operator|+=
name|devscope
operator|->
name|Length
expr_stmt|;
comment|/* XXXKIB bridge */
if|if
condition|(
name|devscope
operator|->
name|EntryType
operator|!=
name|ACPI_DMAR_SCOPE_TYPE_ENDPOINT
condition|)
continue|continue;
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|dmar_print_path
argument_list|(
name|iria
operator|->
name|dmar
operator|->
name|dev
argument_list|,
literal|"RMRR scope"
argument_list|,
name|devscope
operator|->
name|Bus
argument_list|,
operator|(
name|devscope
operator|->
name|Length
operator|-
sizeof|sizeof
argument_list|(
name|ACPI_DMAR_DEVICE_SCOPE
argument_list|)
operator|)
operator|/
literal|2
argument_list|,
operator|(
specifier|const
name|ACPI_DMAR_PCI_PATH
operator|*
operator|)
operator|(
name|devscope
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|dmar_path_dev
argument_list|(
name|resmem
operator|->
name|Segment
argument_list|,
operator|(
name|devscope
operator|->
name|Length
operator|-
sizeof|sizeof
argument_list|(
name|ACPI_DMAR_DEVICE_SCOPE
argument_list|)
operator|)
operator|/
literal|2
argument_list|,
name|devscope
operator|->
name|Bus
argument_list|,
operator|(
specifier|const
name|ACPI_DMAR_PCI_PATH
operator|*
operator|)
operator|(
name|devscope
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dmar_match_verbose
condition|)
name|printf
argument_list|(
literal|"null dev\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dev_dmar
operator|=
name|dmar_find
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_dmar
operator|!=
name|iria
operator|->
name|dmar
condition|)
block|{
if|if
condition|(
name|dmar_match_verbose
condition|)
block|{
name|printf
argument_list|(
literal|"dmar%d matched, skipping\n"
argument_list|,
name|dev_dmar
operator|->
name|unit
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|dmar_match_verbose
condition|)
name|printf
argument_list|(
literal|"matched, instantiating RMRR context\n"
argument_list|)
expr_stmt|;
name|dmar_instantiate_ctx
argument_list|(
name|iria
operator|->
name|dmar
argument_list|,
name|dev
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-create all contexts for the DMAR which have RMRR entries.  */
end_comment

begin_function
name|int
name|dmar_instantiate_rmrr_ctxs
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|dmar
parameter_list|)
block|{
name|struct
name|inst_rmrr_iter_args
name|iria
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|dmar_barrier_enter
argument_list|(
name|dmar
argument_list|,
name|DMAR_BARRIER_RMRR
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|iria
operator|.
name|dmar
operator|=
name|dmar
expr_stmt|;
if|if
condition|(
name|dmar_match_verbose
condition|)
name|printf
argument_list|(
literal|"dmar%d: instantiating RMRR contexts\n"
argument_list|,
name|dmar
operator|->
name|unit
argument_list|)
expr_stmt|;
name|dmar_iterate_tbl
argument_list|(
name|dmar_inst_rmrr_iter
argument_list|,
operator|&
name|iria
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|dmar
operator|->
name|domains
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|dmar
operator|->
name|hw_gcmd
operator|&
name|DMAR_GCMD_TE
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"dmar%d: RMRR not handled but translation is already enabled"
operator|,
name|dmar
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmar_enable_translation
argument_list|(
name|dmar
argument_list|)
expr_stmt|;
block|}
name|dmar_barrier_exit
argument_list|(
name|dmar
argument_list|,
name|DMAR_BARRIER_RMRR
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_function
specifier|static
name|void
name|dmar_print_domain_entry
parameter_list|(
specifier|const
name|struct
name|dmar_map_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|db_printf
argument_list|(
literal|"    start %jx end %jx free_after %jx free_down %jx flags %x "
argument_list|,
name|entry
operator|->
name|start
argument_list|,
name|entry
operator|->
name|end
argument_list|,
name|entry
operator|->
name|free_after
argument_list|,
name|entry
operator|->
name|free_down
argument_list|,
name|entry
operator|->
name|flags
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"left "
argument_list|)
expr_stmt|;
name|l
operator|=
name|RB_LEFT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
condition|)
name|db_printf
argument_list|(
literal|"NULL "
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"%jx "
argument_list|,
name|l
operator|->
name|start
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"right "
argument_list|)
expr_stmt|;
name|r
operator|=
name|RB_RIGHT
argument_list|(
name|entry
argument_list|,
name|rb_entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|db_printf
argument_list|(
literal|"NULL"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"%jx"
argument_list|,
name|r
operator|->
name|start
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_print_ctx
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"    @%p pci%d:%d:%d refs %d flags %x loads %lu unloads %lu\n"
argument_list|,
name|ctx
argument_list|,
name|pci_get_bus
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
argument_list|,
name|pci_get_slot
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
argument_list|,
name|ctx
operator|->
name|refs
argument_list|,
name|ctx
operator|->
name|flags
argument_list|,
name|ctx
operator|->
name|loads
argument_list|,
name|ctx
operator|->
name|unloads
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_print_domain
parameter_list|(
name|struct
name|dmar_domain
modifier|*
name|domain
parameter_list|,
name|bool
name|show_mappings
parameter_list|)
block|{
name|struct
name|dmar_map_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|db_printf
argument_list|(
literal|"  @%p dom %d mgaw %d agaw %d pglvl %d end %jx refs %d\n"
literal|"   ctx_cnt %d flags %x pgobj %p map_ents %u\n"
argument_list|,
name|domain
argument_list|,
name|domain
operator|->
name|domain
argument_list|,
name|domain
operator|->
name|mgaw
argument_list|,
name|domain
operator|->
name|agaw
argument_list|,
name|domain
operator|->
name|pglvl
argument_list|,
operator|(
name|uintmax_t
operator|)
name|domain
operator|->
name|end
argument_list|,
name|domain
operator|->
name|refs
argument_list|,
name|domain
operator|->
name|ctx_cnt
argument_list|,
name|domain
operator|->
name|flags
argument_list|,
name|domain
operator|->
name|pgtbl_obj
argument_list|,
name|domain
operator|->
name|entries_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|domain
operator|->
name|contexts
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"  Contexts:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&domain->contexts
argument_list|,
argument|link
argument_list|)
name|dmar_print_ctx
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|show_mappings
condition|)
return|return;
name|db_printf
argument_list|(
literal|"    mapped:\n"
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|dmar_gas_entries_tree
argument_list|,
argument|&domain->rb_root
argument_list|)
block|{
name|dmar_print_domain_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
name|db_printf
argument_list|(
literal|"    unloading:\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&domain->unload_entries
argument_list|,
argument|dmamap_link
argument_list|)
block|{
name|dmar_print_domain_entry
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_function

begin_macro
name|DB_FUNC
argument_list|(
argument|dmar_domain
argument_list|,
argument|db_dmar_print_domain
argument_list|,
argument|db_show_table
argument_list|,
argument|CS_OWN
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_block
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|struct
name|dmar_ctx
modifier|*
name|ctx
decl_stmt|;
name|bool
name|show_mappings
decl_stmt|,
name|valid
decl_stmt|;
name|int
name|pci_domain
decl_stmt|,
name|bus
decl_stmt|,
name|device
decl_stmt|,
name|function
decl_stmt|,
name|i
decl_stmt|,
name|t
decl_stmt|;
name|db_expr_t
name|radix
decl_stmt|;
name|valid
operator|=
name|false
expr_stmt|;
name|radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tSLASH
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad modifier\n"
argument_list|)
expr_stmt|;
name|db_radix
operator|=
name|radix
expr_stmt|;
name|db_skip_to_eol
argument_list|()
expr_stmt|;
return|return;
block|}
name|show_mappings
operator|=
name|strchr
argument_list|(
name|db_tok_string
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|show_mappings
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|t
operator|==
name|tNUMBER
condition|)
block|{
name|pci_domain
operator|=
name|db_tok_number
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tNUMBER
condition|)
block|{
name|bus
operator|=
name|db_tok_number
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tNUMBER
condition|)
block|{
name|device
operator|=
name|db_tok_number
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tNUMBER
condition|)
block|{
name|function
operator|=
name|db_tok_number
expr_stmt|;
name|valid
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
block|}
name|db_radix
operator|=
name|radix
expr_stmt|;
name|db_skip_to_eol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show dmar_domain [/m] "
literal|"<domain><bus><device><func>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmar_devcnt
condition|;
name|i
operator|++
control|)
block|{
name|unit
operator|=
name|device_get_softc
argument_list|(
name|dmar_devs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|domain
argument_list|,
argument|&unit->domains
argument_list|,
argument|link
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|ctx
argument_list|,
argument|&domain->contexts
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|pci_domain
operator|==
name|unit
operator|->
name|segment
operator|&&
name|bus
operator|==
name|pci_get_bus
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
operator|&&
name|device
operator|==
name|pci_get_slot
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
operator|&&
name|function
operator|==
name|pci_get_function
argument_list|(
name|ctx
operator|->
name|ctx_tag
operator|.
name|owner
argument_list|)
condition|)
block|{
name|dmar_print_domain
argument_list|(
name|domain
argument_list|,
name|show_mappings
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
name|out
label|:
empty_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|dmar_print_one
parameter_list|(
name|int
name|idx
parameter_list|,
name|bool
name|show_domains
parameter_list|,
name|bool
name|show_mappings
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|dmar_domain
modifier|*
name|domain
decl_stmt|;
name|int
name|i
decl_stmt|,
name|frir
decl_stmt|;
name|unit
operator|=
name|device_get_softc
argument_list|(
name|dmar_devs
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"dmar%d at %p, root at 0x%jx, ver 0x%x\n"
argument_list|,
name|unit
operator|->
name|unit
argument_list|,
name|unit
argument_list|,
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_RTADDR_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_VER_REG
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cap 0x%jx ecap 0x%jx gsts 0x%x fsts 0x%x fectl 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_CAP_REG
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_ECAP_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_GSTS_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_FSTS_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_FECTL_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|ir_enabled
condition|)
block|{
name|db_printf
argument_list|(
literal|"ir is enabled; IRT @%p phys 0x%jx maxcnt %d\n"
argument_list|,
name|unit
operator|->
name|irt
argument_list|,
operator|(
name|uintmax_t
operator|)
name|unit
operator|->
name|irt_phys
argument_list|,
name|unit
operator|->
name|irte_cnt
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"fed 0x%x fea 0x%x feua 0x%x\n"
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_FEDATA_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_FEADDR_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_FEUADDR_REG
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"primary fault log:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DMAR_CAP_NFR
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|frir
operator|=
operator|(
name|DMAR_CAP_FRO
argument_list|(
name|unit
operator|->
name|hw_cap
argument_list|)
operator|+
name|i
operator|)
operator|*
literal|16
expr_stmt|;
name|db_printf
argument_list|(
literal|"  %d at 0x%x: %jx %jx\n"
argument_list|,
name|i
argument_list|,
name|frir
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|frir
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|frir
operator|+
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DMAR_HAS_QI
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"ied 0x%x iea 0x%x ieua 0x%x\n"
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IEDATA_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IEADDR_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IEUADDR_REG
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|qi_enabled
condition|)
block|{
name|db_printf
argument_list|(
literal|"qi is enabled: queue @0x%jx (IQA 0x%jx) "
literal|"size 0x%jx\n"
literal|"  head 0x%x tail 0x%x avail 0x%x status 0x%x ctrl 0x%x\n"
literal|"  hw compl 0x%x@%p/phys@%jx next seq 0x%x gen 0x%x\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|unit
operator|->
name|inv_queue
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|DMAR_IQA_REG
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|unit
operator|->
name|inv_queue_size
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IQH_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IQT_REG
argument_list|)
argument_list|,
name|unit
operator|->
name|inv_queue_avail
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_ICS_REG
argument_list|)
argument_list|,
name|dmar_read4
argument_list|(
name|unit
argument_list|,
name|DMAR_IECTL_REG
argument_list|)
argument_list|,
name|unit
operator|->
name|inv_waitd_seq_hw
argument_list|,
operator|&
name|unit
operator|->
name|inv_waitd_seq_hw
argument_list|,
operator|(
name|uintmax_t
operator|)
name|unit
operator|->
name|inv_waitd_seq_hw_phys
argument_list|,
name|unit
operator|->
name|inv_waitd_seq
argument_list|,
name|unit
operator|->
name|inv_waitd_gen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_printf
argument_list|(
literal|"qi is disabled\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|show_domains
condition|)
block|{
name|db_printf
argument_list|(
literal|"domains:\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|domain
argument_list|,
argument|&unit->domains
argument_list|,
argument|link
argument_list|)
block|{
name|dmar_print_domain
argument_list|(
name|domain
argument_list|,
name|show_mappings
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|dmar
argument_list|,
argument|db_dmar_print
argument_list|)
end_macro

begin_block
block|{
name|bool
name|show_domains
decl_stmt|,
name|show_mappings
decl_stmt|;
name|show_domains
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'d'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|show_mappings
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show dmar [/d] [/m] index\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmar_print_one
argument_list|(
operator|(
name|int
operator|)
name|addr
argument_list|,
name|show_domains
argument_list|,
name|show_mappings
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_ALL_COMMAND
argument_list|(
argument|dmars
argument_list|,
argument|db_show_all_dmars
argument_list|)
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|bool
name|show_domains
decl_stmt|,
name|show_mappings
decl_stmt|;
name|show_domains
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'d'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|show_mappings
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'m'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dmar_devcnt
condition|;
name|i
operator|++
control|)
block|{
name|dmar_print_one
argument_list|(
name|i
argument_list|,
name|show_domains
argument_list|,
name|show_mappings
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

