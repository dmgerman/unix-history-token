begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/apicreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/apicvar.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/iommu_intrmap.h>
end_include

begin_function_decl
specifier|static
name|struct
name|dmar_unit
modifier|*
name|dmar_ir_find
parameter_list|(
name|device_t
name|src
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|,
name|int
modifier|*
name|is_dmar
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmar_ir_program_irte
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|uint64_t
name|low
parameter_list|,
name|uint16_t
name|rid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dmar_ir_free_irte
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|u_int
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|iommu_alloc_msi_intr
parameter_list|(
name|device_t
name|src
parameter_list|,
name|u_int
modifier|*
name|cookies
parameter_list|,
name|u_int
name|count
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|vmem_addr_t
name|vmem_res
decl_stmt|;
name|u_int
name|idx
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|dmar_ir_find
argument_list|(
name|src
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|NULL
operator|||
operator|!
name|unit
operator|->
name|ir_enabled
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|cookies
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
name|vmem_alloc
argument_list|(
name|unit
operator|->
name|irtids
argument_list|,
name|count
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|,
operator|&
name|vmem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|error
operator|!=
name|EOPNOTSUPP
argument_list|,
operator|(
literal|"impossible EOPNOTSUPP from vmem"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|idx
operator|=
name|vmem_res
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|cookies
index|[
name|i
index|]
operator|=
name|idx
operator|+
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iommu_map_msi_intr
parameter_list|(
name|device_t
name|src
parameter_list|,
name|u_int
name|cpu
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|u_int
name|cookie
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|uint64_t
name|low
decl_stmt|;
name|uint16_t
name|rid
decl_stmt|;
name|int
name|is_dmar
decl_stmt|;
name|unit
operator|=
name|dmar_ir_find
argument_list|(
name|src
argument_list|,
operator|&
name|rid
argument_list|,
operator|&
name|is_dmar
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_dmar
condition|)
block|{
name|KASSERT
argument_list|(
name|unit
operator|==
name|NULL
argument_list|,
operator|(
literal|"DMAR cannot translate itself"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * See VT-d specification, 5.1.6 Remapping Hardware - 		 * Interrupt Programming. 		 */
operator|*
name|data
operator|=
name|vector
expr_stmt|;
operator|*
name|addr
operator|=
name|MSI_INTEL_ADDR_BASE
operator||
operator|(
operator|(
name|cpu
operator|&
literal|0xff
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
if|if
condition|(
name|x2apic_mode
condition|)
operator|*
name|addr
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|cpu
operator|&
literal|0xffffff00
operator|)
operator|<<
literal|32
expr_stmt|;
else|else
name|KASSERT
argument_list|(
name|cpu
operator|<=
literal|0xff
argument_list|,
operator|(
literal|"cpu id too big %d"
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|unit
operator|==
name|NULL
operator|||
operator|!
name|unit
operator|->
name|ir_enabled
operator|||
name|cookie
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|low
operator|=
operator|(
name|DMAR_X2APIC
argument_list|(
name|unit
argument_list|)
condition|?
name|DMAR_IRTE1_DST_x2APIC
argument_list|(
name|cpu
argument_list|)
else|:
name|DMAR_IRTE1_DST_xAPIC
argument_list|(
name|cpu
argument_list|)
operator|)
operator||
name|DMAR_IRTE1_V
argument_list|(
name|vector
argument_list|)
operator||
name|DMAR_IRTE1_DLM_FM
operator||
name|DMAR_IRTE1_TM_EDGE
operator||
name|DMAR_IRTE1_RH_DIRECT
operator||
name|DMAR_IRTE1_DM_PHYSICAL
operator||
name|DMAR_IRTE1_P
expr_stmt|;
name|dmar_ir_program_irte
argument_list|(
name|unit
argument_list|,
name|cookie
argument_list|,
name|low
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * See VT-d specification, 5.1.5.2 MSI and MSI-X 		 * Register Programming. 		 */
operator|*
name|addr
operator|=
name|MSI_INTEL_ADDR_BASE
operator||
operator|(
operator|(
name|cookie
operator|&
literal|0x7fff
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|cookie
operator|&
literal|0x8000
operator|)
operator|<<
literal|2
operator|)
operator||
literal|0x18
expr_stmt|;
operator|*
name|data
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iommu_unmap_msi_intr
parameter_list|(
name|device_t
name|src
parameter_list|,
name|u_int
name|cookie
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
if|if
condition|(
name|cookie
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unit
operator|=
name|dmar_ir_find
argument_list|(
name|src
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmar_ir_free_irte
argument_list|(
name|unit
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iommu_map_ioapic_intr
parameter_list|(
name|u_int
name|ioapic_id
parameter_list|,
name|u_int
name|cpu
parameter_list|,
name|u_int
name|vector
parameter_list|,
name|bool
name|edge
parameter_list|,
name|bool
name|activehi
parameter_list|,
name|int
name|irq
parameter_list|,
name|u_int
modifier|*
name|cookie
parameter_list|,
name|uint32_t
modifier|*
name|hi
parameter_list|,
name|uint32_t
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|vmem_addr_t
name|vmem_res
decl_stmt|;
name|uint64_t
name|low
decl_stmt|,
name|iorte
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|rid
decl_stmt|;
name|unit
operator|=
name|dmar_find_ioapic
argument_list|(
name|ioapic_id
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|==
name|NULL
operator|||
operator|!
name|unit
operator|->
name|ir_enabled
condition|)
block|{
operator|*
name|cookie
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
name|vmem_alloc
argument_list|(
name|unit
operator|->
name|irtids
argument_list|,
literal|1
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|,
operator|&
name|vmem_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|error
operator|!=
name|EOPNOTSUPP
argument_list|,
operator|(
literal|"impossible EOPNOTSUPP from vmem"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|idx
operator|=
name|vmem_res
expr_stmt|;
name|low
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|irq
condition|)
block|{
case|case
name|IRQ_EXTINT
case|:
name|low
operator||=
name|DMAR_IRTE1_DLM_ExtINT
expr_stmt|;
break|break;
case|case
name|IRQ_NMI
case|:
name|low
operator||=
name|DMAR_IRTE1_DLM_NMI
expr_stmt|;
break|break;
case|case
name|IRQ_SMI
case|:
name|low
operator||=
name|DMAR_IRTE1_DLM_SMI
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
name|vector
operator|!=
literal|0
argument_list|,
operator|(
literal|"No vector for IRQ %u"
operator|,
name|irq
operator|)
argument_list|)
expr_stmt|;
name|low
operator||=
name|DMAR_IRTE1_DLM_FM
operator||
name|DMAR_IRTE1_V
argument_list|(
name|vector
argument_list|)
expr_stmt|;
break|break;
block|}
name|low
operator||=
operator|(
name|DMAR_X2APIC
argument_list|(
name|unit
argument_list|)
condition|?
name|DMAR_IRTE1_DST_x2APIC
argument_list|(
name|cpu
argument_list|)
else|:
name|DMAR_IRTE1_DST_xAPIC
argument_list|(
name|cpu
argument_list|)
operator|)
operator||
operator|(
name|edge
condition|?
name|DMAR_IRTE1_TM_EDGE
else|:
name|DMAR_IRTE1_TM_LEVEL
operator|)
operator||
name|DMAR_IRTE1_RH_DIRECT
operator||
name|DMAR_IRTE1_DM_PHYSICAL
operator||
name|DMAR_IRTE1_P
expr_stmt|;
name|dmar_ir_program_irte
argument_list|(
name|unit
argument_list|,
name|idx
argument_list|,
name|low
argument_list|,
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * See VT-d specification, 5.1.5.1 I/OxAPIC 		 * Programming. 		 */
name|iorte
operator|=
operator|(
literal|1ULL
operator|<<
literal|48
operator|)
operator||
operator|(
call|(
name|uint64_t
call|)
argument_list|(
name|idx
operator|&
literal|0x7fff
argument_list|)
operator|<<
literal|49
operator|)
operator||
operator|(
operator|(
name|idx
operator|&
literal|0x8000
operator|)
operator|!=
literal|0
condition|?
operator|(
literal|1
operator|<<
literal|11
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|edge
condition|?
name|IOART_TRGREDG
else|:
name|IOART_TRGRLVL
operator|)
operator||
operator|(
name|activehi
condition|?
name|IOART_INTAHI
else|:
name|IOART_INTALO
operator|)
operator||
name|IOART_DELFIXED
operator||
name|vector
expr_stmt|;
operator|*
name|hi
operator|=
name|iorte
operator|>>
literal|32
expr_stmt|;
operator|*
name|lo
operator|=
name|iorte
expr_stmt|;
block|}
operator|*
name|cookie
operator|=
name|idx
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iommu_unmap_ioapic_intr
parameter_list|(
name|u_int
name|ioapic_id
parameter_list|,
name|u_int
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|u_int
name|idx
decl_stmt|;
name|idx
operator|=
operator|*
name|cookie
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|cookie
operator|=
operator|-
literal|1
expr_stmt|;
name|unit
operator|=
name|dmar_find_ioapic
argument_list|(
name|ioapic_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|!=
name|NULL
operator|&&
name|unit
operator|->
name|ir_enabled
argument_list|,
operator|(
literal|"unmap: cookie %d unit %p"
operator|,
name|idx
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmar_ir_free_irte
argument_list|(
name|unit
argument_list|,
name|idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dmar_unit
modifier|*
name|dmar_ir_find
parameter_list|(
name|device_t
name|src
parameter_list|,
name|uint16_t
modifier|*
name|rid
parameter_list|,
name|int
modifier|*
name|is_dmar
parameter_list|)
block|{
name|devclass_t
name|src_class
decl_stmt|;
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
comment|/* 	 * We need to determine if the interrupt source generates FSB 	 * interrupts.  If yes, it is either DMAR, in which case 	 * interrupts are not remapped.  Or it is HPET, and interrupts 	 * are remapped.  For HPET, source id is reported by HPET 	 * record in DMAR ACPI table. 	 */
if|if
condition|(
name|is_dmar
operator|!=
name|NULL
condition|)
operator|*
name|is_dmar
operator|=
name|FALSE
expr_stmt|;
name|src_class
operator|=
name|device_get_devclass
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_class
operator|==
name|devclass_find
argument_list|(
literal|"dmar"
argument_list|)
condition|)
block|{
name|unit
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|is_dmar
operator|!=
name|NULL
condition|)
operator|*
name|is_dmar
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|src_class
operator|==
name|devclass_find
argument_list|(
literal|"hpet"
argument_list|)
condition|)
block|{
name|unit
operator|=
name|dmar_find_hpet
argument_list|(
name|src
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unit
operator|=
name|dmar_find
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|!=
name|NULL
operator|&&
name|rid
operator|!=
name|NULL
condition|)
name|dmar_get_requester
argument_list|(
name|src
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|unit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmar_ir_program_irte
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|u_int
name|idx
parameter_list|,
name|uint64_t
name|low
parameter_list|,
name|uint16_t
name|rid
parameter_list|)
block|{
name|dmar_irte_t
modifier|*
name|irte
decl_stmt|;
name|uint64_t
name|high
decl_stmt|;
name|KASSERT
argument_list|(
name|idx
operator|<
name|unit
operator|->
name|irte_cnt
argument_list|,
operator|(
literal|"bad cookie %d %d"
operator|,
name|idx
operator|,
name|unit
operator|->
name|irte_cnt
operator|)
argument_list|)
expr_stmt|;
name|irte
operator|=
operator|&
operator|(
name|unit
operator|->
name|irt
index|[
name|idx
index|]
operator|)
expr_stmt|;
name|high
operator|=
name|DMAR_IRTE2_SVT_RID
operator||
name|DMAR_IRTE2_SQ_RID
operator||
name|DMAR_IRTE2_SID_RID
argument_list|(
name|rid
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|unit
operator|->
name|dev
argument_list|,
literal|"programming irte[%d] rid %#x high %#jx low %#jx\n"
argument_list|,
name|idx
argument_list|,
name|rid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|high
argument_list|,
operator|(
name|uintmax_t
operator|)
name|low
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|irte
operator|->
name|irte1
operator|&
name|DMAR_IRTE1_P
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The rte is already valid.  Assume that the request 		 * is to remap the interrupt for balancing.  Only low 		 * word of rte needs to be changed.  Assert that the 		 * high word contains expected value. 		 */
name|KASSERT
argument_list|(
name|irte
operator|->
name|irte2
operator|==
name|high
argument_list|,
operator|(
literal|"irte2 mismatch, %jx %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|irte
operator|->
name|irte2
operator|,
operator|(
name|uintmax_t
operator|)
name|high
operator|)
argument_list|)
expr_stmt|;
name|dmar_pte_update
argument_list|(
operator|&
name|irte
operator|->
name|irte1
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmar_pte_store
argument_list|(
operator|&
name|irte
operator|->
name|irte2
argument_list|,
name|high
argument_list|)
expr_stmt|;
name|dmar_pte_store
argument_list|(
operator|&
name|irte
operator|->
name|irte1
argument_list|,
name|low
argument_list|)
expr_stmt|;
block|}
name|dmar_qi_invalidate_iec
argument_list|(
name|unit
argument_list|,
name|idx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmar_ir_free_irte
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|u_int
name|cookie
parameter_list|)
block|{
name|dmar_irte_t
modifier|*
name|irte
decl_stmt|;
name|KASSERT
argument_list|(
name|unit
operator|!=
name|NULL
operator|&&
name|unit
operator|->
name|ir_enabled
argument_list|,
operator|(
literal|"unmap: cookie %d unit %p"
operator|,
name|cookie
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cookie
operator|<
name|unit
operator|->
name|irte_cnt
argument_list|,
operator|(
literal|"bad cookie %u %u"
operator|,
name|cookie
operator|,
name|unit
operator|->
name|irte_cnt
operator|)
argument_list|)
expr_stmt|;
name|irte
operator|=
operator|&
operator|(
name|unit
operator|->
name|irt
index|[
name|cookie
index|]
operator|)
expr_stmt|;
name|dmar_pte_clear
argument_list|(
operator|&
name|irte
operator|->
name|irte1
argument_list|)
expr_stmt|;
name|dmar_pte_clear
argument_list|(
operator|&
name|irte
operator|->
name|irte2
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_qi_invalidate_iec
argument_list|(
name|unit
argument_list|,
name|cookie
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|vmem_free
argument_list|(
name|unit
operator|->
name|irtids
argument_list|,
name|cookie
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|clp2
parameter_list|(
name|u_int
name|v
parameter_list|)
block|{
return|return
operator|(
name|powerof2
argument_list|(
name|v
argument_list|)
condition|?
name|v
else|:
literal|1
operator|<<
name|fls
argument_list|(
name|v
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmar_init_irt
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_IR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unit
operator|->
name|ir_enabled
operator|=
literal|1
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"hw.dmar.ir"
argument_list|,
operator|&
name|unit
operator|->
name|ir_enabled
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unit
operator|->
name|ir_enabled
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|unit
operator|->
name|qi_enabled
condition|)
block|{
name|unit
operator|->
name|ir_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|device_printf
argument_list|(
name|unit
operator|->
name|dev
argument_list|,
literal|"QI disabled, disabling interrupt remapping\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|unit
operator|->
name|irte_cnt
operator|=
name|clp2
argument_list|(
name|NUM_IO_INTS
argument_list|)
expr_stmt|;
name|unit
operator|->
name|irt
operator|=
operator|(
name|dmar_irte_t
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|kmem_alloc_contig
argument_list|(
name|kernel_arena
argument_list|,
name|unit
operator|->
name|irte_cnt
operator|*
sizeof|sizeof
argument_list|(
name|dmar_irte_t
argument_list|)
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
name|dmar_high
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|unit
argument_list|)
condition|?
name|VM_MEMATTR_DEFAULT
else|:
name|VM_MEMATTR_UNCACHEABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|irt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|unit
operator|->
name|irt_phys
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|unit
operator|->
name|irt
argument_list|)
expr_stmt|;
name|unit
operator|->
name|irtids
operator|=
name|vmem_create
argument_list|(
literal|"dmarirt"
argument_list|,
literal|0
argument_list|,
name|unit
operator|->
name|irte_cnt
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_load_irt_ptr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_qi_invalidate_iec_glob
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize mappings for already configured interrupt pins. 	 * Required, because otherwise the interrupts fault without 	 * irtes. 	 */
name|intr_reprogram
argument_list|()
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_enable_ir
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmar_fini_irt
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|)
block|{
name|unit
operator|->
name|ir_enabled
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unit
operator|->
name|irt
operator|!=
name|NULL
condition|)
block|{
name|dmar_disable_ir
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_qi_invalidate_iec_glob
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|vmem_destroy
argument_list|(
name|unit
operator|->
name|irtids
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|kernel_arena
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|unit
operator|->
name|irt
argument_list|,
name|unit
operator|->
name|irte_cnt
operator|*
sizeof|sizeof
argument_list|(
name|dmar_irte_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

