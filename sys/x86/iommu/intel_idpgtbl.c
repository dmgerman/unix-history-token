begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Konstantin Belousov<kib@FreeBSD.org>  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_reg.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/intel_dmar.h>
end_include

begin_function_decl
specifier|static
name|int
name|ctx_unmap_buf_locked
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The cache of the identity mapping page tables for the DMARs.  Using  * the cache saves significant amount of memory for page tables by  * reusing the page tables, since usually DMARs are identical and have  * the same capabilities.  Still, cache records the information needed  * to match DMAR capabilities and page table format, to correctly  * handle different DMARs.  */
end_comment

begin_struct
struct|struct
name|idpgtbl
block|{
name|dmar_gaddr_t
name|maxaddr
decl_stmt|;
comment|/* Page table covers the guest address 				   range [0..maxaddr) */
name|int
name|pglvl
decl_stmt|;
comment|/* Total page table levels ignoring 				   superpages */
name|int
name|leaf
decl_stmt|;
comment|/* The last materialized page table 				   level, it is non-zero if superpages 				   are supported */
name|vm_object_t
name|pgtbl_obj
decl_stmt|;
comment|/* The page table pages */
name|LIST_ENTRY
argument_list|(
argument|idpgtbl
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sx
name|idpgtbl_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|idpgtbl
argument_list|,
operator|&
name|idpgtbl_lock
argument_list|,
literal|"idpgtbl"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|idpgtbl
argument_list|)
name|idpgtbls
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|idpgtbls
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DMAR_IDPGTBL
argument_list|,
literal|"dmar_idpgtbl"
argument_list|,
literal|"Intel DMAR Identity mappings cache elements"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Build the next level of the page tables for the identity mapping.  * - lvl is the level to build;  * - idx is the index of the page table page in the pgtbl_obj, which is  *   being allocated filled now;  * - addr is the starting address in the bus address space which is  *   mapped by the page table page.  */
end_comment

begin_function
specifier|static
name|void
name|ctx_idmap_nextlvl
parameter_list|(
name|struct
name|idpgtbl
modifier|*
name|tbl
parameter_list|,
name|int
name|lvl
parameter_list|,
name|vm_pindex_t
name|idx
parameter_list|,
name|dmar_gaddr_t
name|addr
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|m1
decl_stmt|;
name|dmar_pte_t
modifier|*
name|pte
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|dmar_gaddr_t
name|f
decl_stmt|,
name|pg_sz
decl_stmt|;
name|vm_pindex_t
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
name|tbl
operator|->
name|maxaddr
condition|)
return|return;
name|m
operator|=
name|dmar_pgalloc
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|,
name|idx
argument_list|,
name|DMAR_PGF_OBJL
operator||
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_ZERO
argument_list|)
expr_stmt|;
name|base
operator|=
name|idx
operator|*
name|DMAR_NPTEPG
operator|+
literal|1
expr_stmt|;
comment|/* Index of the first child page of idx */
name|pg_sz
operator|=
name|pglvl_page_size
argument_list|(
name|tbl
operator|->
name|pglvl
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|!=
name|tbl
operator|->
name|leaf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|f
operator|=
name|addr
init|;
name|i
operator|<
name|DMAR_NPTEPG
condition|;
name|i
operator|++
operator|,
name|f
operator|+=
name|pg_sz
control|)
name|ctx_idmap_nextlvl
argument_list|(
name|tbl
argument_list|,
name|lvl
operator|+
literal|1
argument_list|,
name|base
operator|+
name|i
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|)
expr_stmt|;
name|pte
operator|=
name|dmar_map_pgtbl
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|,
name|idx
argument_list|,
name|DMAR_PGF_WAITOK
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lvl
operator|==
name|tbl
operator|->
name|leaf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|f
operator|=
name|addr
init|;
name|i
operator|<
name|DMAR_NPTEPG
condition|;
name|i
operator|++
operator|,
name|f
operator|+=
name|pg_sz
control|)
block|{
if|if
condition|(
name|f
operator|>=
name|tbl
operator|->
name|maxaddr
condition|)
break|break;
name|pte
index|[
name|i
index|]
operator|.
name|pte
operator|=
operator|(
name|DMAR_PTE_ADDR_MASK
operator|&
name|f
operator|)
operator||
name|DMAR_PTE_R
operator||
name|DMAR_PTE_W
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|f
operator|=
name|addr
init|;
name|i
operator|<
name|DMAR_NPTEPG
condition|;
name|i
operator|++
operator|,
name|f
operator|+=
name|pg_sz
control|)
block|{
if|if
condition|(
name|f
operator|>=
name|tbl
operator|->
name|maxaddr
condition|)
break|break;
name|m1
operator|=
name|dmar_pgalloc
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|,
name|base
operator|+
name|i
argument_list|,
name|DMAR_PGF_NOALLOC
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m1
operator|!=
name|NULL
argument_list|,
operator|(
literal|"lost page table page"
operator|)
argument_list|)
expr_stmt|;
name|pte
index|[
name|i
index|]
operator|.
name|pte
operator|=
operator|(
name|DMAR_PTE_ADDR_MASK
operator|&
name|VM_PAGE_TO_PHYS
argument_list|(
name|m1
argument_list|)
operator|)
operator||
name|DMAR_PTE_R
operator||
name|DMAR_PTE_W
expr_stmt|;
block|}
block|}
comment|/* ctx_get_idmap_pgtbl flushes CPU cache if needed. */
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a ready and compatible identity-mapping page table in the  * cache. If not found, populate the identity-mapping page table for  * the context, up to the maxaddr. The maxaddr byte is allowed to be  * not mapped, which is aligned with the definition of Maxmem as the  * highest usable physical address + 1.  If superpages are used, the  * maxaddr is typically mapped.  */
end_comment

begin_function
name|vm_object_t
name|ctx_get_idmap_pgtbl
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|maxaddr
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|struct
name|idpgtbl
modifier|*
name|tbl
decl_stmt|;
name|vm_object_t
name|res
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|leaf
decl_stmt|,
name|i
decl_stmt|;
name|leaf
operator|=
literal|0
expr_stmt|;
comment|/* silence gcc */
comment|/* 	 * First, determine where to stop the paging structures. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|pglvl
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ctx
operator|->
name|pglvl
operator|-
literal|1
operator|||
name|ctx_is_sp_lvl
argument_list|(
name|ctx
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|leaf
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Search the cache for a compatible page table.  Qualified 	 * page table must map up to maxaddr, its level must be 	 * supported by the DMAR and leaf should be equal to the 	 * calculated value.  The later restriction could be lifted 	 * but I believe it is currently impossible to have any 	 * deviations for existing hardware. 	 */
name|sx_slock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tbl
argument_list|,
argument|&idpgtbls
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|tbl
operator|->
name|maxaddr
operator|>=
name|maxaddr
operator|&&
name|dmar_pglvl_supported
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|,
name|tbl
operator|->
name|pglvl
argument_list|)
operator|&&
name|tbl
operator|->
name|leaf
operator|==
name|leaf
condition|)
block|{
name|res
operator|=
name|tbl
operator|->
name|pgtbl_obj
expr_stmt|;
name|vm_object_reference
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pglvl
operator|=
name|tbl
operator|->
name|pglvl
expr_stmt|;
comment|/* XXXKIB ? */
goto|goto
name|end
goto|;
block|}
block|}
comment|/* 	 * Not found in cache, relock the cache into exclusive mode to 	 * be able to add element, and recheck cache again after the 	 * relock. 	 */
name|sx_sunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|tbl
argument_list|,
argument|&idpgtbls
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|tbl
operator|->
name|maxaddr
operator|>=
name|maxaddr
operator|&&
name|dmar_pglvl_supported
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|,
name|tbl
operator|->
name|pglvl
argument_list|)
operator|&&
name|tbl
operator|->
name|leaf
operator|==
name|leaf
condition|)
block|{
name|res
operator|=
name|tbl
operator|->
name|pgtbl_obj
expr_stmt|;
name|vm_object_reference
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pglvl
operator|=
name|tbl
operator|->
name|pglvl
expr_stmt|;
comment|/* XXXKIB ? */
return|return
operator|(
name|res
operator|)
return|;
block|}
block|}
comment|/* 	 * Still not found, create new page table. 	 */
name|tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
argument_list|,
name|M_DMAR_IDPGTBL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|tbl
operator|->
name|pglvl
operator|=
name|ctx
operator|->
name|pglvl
expr_stmt|;
name|tbl
operator|->
name|leaf
operator|=
name|leaf
expr_stmt|;
name|tbl
operator|->
name|maxaddr
operator|=
name|maxaddr
expr_stmt|;
name|tbl
operator|->
name|pgtbl_obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|NULL
argument_list|,
name|IDX_TO_OFF
argument_list|(
name|pglvl_max_pages
argument_list|(
name|tbl
operator|->
name|pglvl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|)
expr_stmt|;
name|ctx_idmap_nextlvl
argument_list|(
name|tbl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|tbl
operator|->
name|pgtbl_obj
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|idpgtbls
argument_list|,
name|tbl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|res
operator|=
name|tbl
operator|->
name|pgtbl_obj
expr_stmt|;
name|vm_object_reference
argument_list|(
name|res
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|end
label|:
comment|/* 	 * Table was found or created. 	 * 	 * If DMAR does not snoop paging structures accesses, flush 	 * CPU cache to memory.  Note that dmar_unmap_pgtbl() coherent 	 * argument was possibly invalid at the time of the identity 	 * page table creation, since DMAR which was passed at the 	 * time of creation could be coherent, while current DMAR is 	 * not. 	 * 	 * If DMAR cannot look into the chipset write buffer, flush it 	 * as well. 	 */
name|unit
operator|=
name|ctx
operator|->
name|dmar
expr_stmt|;
if|if
condition|(
operator|!
name|DMAR_IS_COHERENT
argument_list|(
name|unit
argument_list|)
condition|)
block|{
name|VM_OBJECT_WLOCK
argument_list|(
name|res
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|res
argument_list|,
literal|0
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|vm_page_next
argument_list|(
name|m
argument_list|)
control|)
name|pmap_invalidate_cache_pages
argument_list|(
operator|&
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|res
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_RWBF
operator|)
operator|!=
literal|0
condition|)
block|{
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_flush_write_bufs
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a reference to the identity mapping page table to the cache.  */
end_comment

begin_function
name|void
name|put_idmap_pgtbl
parameter_list|(
name|vm_object_t
name|obj
parameter_list|)
block|{
name|struct
name|idpgtbl
modifier|*
name|tbl
decl_stmt|,
modifier|*
name|tbl1
decl_stmt|;
name|vm_object_t
name|rmobj
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|ref_count
operator|>=
literal|2
argument_list|,
operator|(
literal|"lost cache reference"
operator|)
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
comment|/* 	 * Cache always owns one last reference on the page table object. 	 * If there is an additional reference, object must stay. 	 */
if|if
condition|(
name|obj
operator|->
name|ref_count
operator|>
literal|1
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Cache reference is the last, remove cache element and free 	 * page table object, returning the page table pages to the 	 * system. 	 */
name|sx_sunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|tbl
argument_list|,
argument|&idpgtbls
argument_list|,
argument|link
argument_list|,
argument|tbl1
argument_list|)
block|{
name|rmobj
operator|=
name|tbl
operator|->
name|pgtbl_obj
expr_stmt|;
if|if
condition|(
name|rmobj
operator|->
name|ref_count
operator|==
literal|1
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|tbl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|dmar_tbl_pagecnt
argument_list|,
name|rmobj
operator|->
name|resident_page_count
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|rmobj
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tbl
argument_list|,
name|M_DMAR_IDPGTBL
argument_list|)
expr_stmt|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|idpgtbl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The core routines to map and unmap host pages at the given guest  * address.  Support superpages.  */
end_comment

begin_comment
comment|/*  * Index of the pte for the guest address base in the page table at  * the level lvl.  */
end_comment

begin_function
specifier|static
name|int
name|ctx_pgtbl_pte_off
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|)
block|{
name|base
operator|>>=
name|DMAR_PAGE_SHIFT
operator|+
operator|(
name|ctx
operator|->
name|pglvl
operator|-
name|lvl
operator|-
literal|1
operator|)
operator|*
name|DMAR_NPTEPGSHIFT
expr_stmt|;
return|return
operator|(
name|base
operator|&
name|DMAR_PTEMASK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the page index of the page table page in the page table  * object, which maps the given address base at the page table level  * lvl.  */
end_comment

begin_function
specifier|static
name|vm_pindex_t
name|ctx_pgtbl_get_pindex
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|)
block|{
name|vm_pindex_t
name|idx
decl_stmt|,
name|pidx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|>=
literal|0
operator|&&
name|lvl
operator|<
name|ctx
operator|->
name|pglvl
argument_list|,
operator|(
literal|"wrong lvl %p %d"
operator|,
name|ctx
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pidx
operator|=
name|idx
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lvl
condition|;
name|i
operator|++
operator|,
name|pidx
operator|=
name|idx
control|)
name|idx
operator|=
name|ctx_pgtbl_pte_off
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|i
argument_list|)
operator|+
name|pidx
operator|*
name|DMAR_NPTEPG
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dmar_pte_t
modifier|*
name|ctx_pgtbl_map_pte
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|,
name|int
name|flags
parameter_list|,
name|vm_pindex_t
modifier|*
name|idxp
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sf
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sfp
decl_stmt|;
name|dmar_pte_t
modifier|*
name|pte
decl_stmt|,
modifier|*
name|ptep
decl_stmt|;
name|vm_pindex_t
name|idx
decl_stmt|,
name|idx1
decl_stmt|;
name|DMAR_CTX_ASSERT_PGLOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|DMAR_PGF_OBJL
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"lost PGF_OBJL"
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|=
name|ctx_pgtbl_get_pindex
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|sf
operator|!=
name|NULL
operator|&&
name|idx
operator|==
operator|*
name|idxp
condition|)
block|{
name|pte
operator|=
operator|(
name|dmar_pte_t
operator|*
operator|)
name|sf_buf_kva
argument_list|(
operator|*
name|sf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|sf
operator|!=
name|NULL
condition|)
name|dmar_unmap_pgtbl
argument_list|(
operator|*
name|sf
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|idxp
operator|=
name|idx
expr_stmt|;
name|retry
label|:
name|pte
operator|=
name|dmar_map_pgtbl
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
argument_list|,
name|idx
argument_list|,
name|flags
argument_list|,
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|lvl
operator|>
literal|0
argument_list|,
operator|(
literal|"lost root page table page %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Page table page does not exists, allocate 			 * it and create pte in the up level. 			 */
name|m
operator|=
name|dmar_pgalloc
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
argument_list|,
name|idx
argument_list|,
name|flags
operator||
name|DMAR_PGF_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * Prevent potential free while pgtbl_obj is 			 * unlocked in the recursive call to 			 * ctx_pgtbl_map_pte(), if other thread did 			 * pte write and clean while the lock if 			 * dropped. 			 */
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|sfp
operator|=
name|NULL
expr_stmt|;
name|ptep
operator|=
name|ctx_pgtbl_map_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
operator|-
literal|1
argument_list|,
name|flags
argument_list|,
operator|&
name|idx1
argument_list|,
operator|&
name|sfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptep
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|pindex
operator|!=
literal|0
argument_list|,
operator|(
literal|"loosing root page %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|dmar_pgfree
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dmar_pte_store
argument_list|(
operator|&
name|ptep
operator|->
name|pte
argument_list|,
name|DMAR_PTE_R
operator||
name|DMAR_PTE_W
operator||
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|sf_buf_page
argument_list|(
name|sfp
argument_list|)
operator|->
name|wire_count
operator|+=
literal|1
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|dmar_unmap_pgtbl
argument_list|(
name|sfp
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only executed once. */
goto|goto
name|retry
goto|;
block|}
block|}
name|pte
operator|+=
name|ctx_pgtbl_pte_off
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|pte
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ctx_map_buf_locked
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|uint64_t
name|pflags
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dmar_pte_t
modifier|*
name|pte
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|dmar_gaddr_t
name|pg_sz
decl_stmt|,
name|base1
decl_stmt|,
name|size1
decl_stmt|;
name|vm_pindex_t
name|pi
decl_stmt|,
name|c
decl_stmt|,
name|idx
decl_stmt|,
name|run_sz
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|bool
name|superpage
decl_stmt|;
name|DMAR_CTX_ASSERT_PGLOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|base1
operator|=
name|base
expr_stmt|;
name|size1
operator|=
name|size
expr_stmt|;
name|flags
operator||=
name|DMAR_PGF_OBJL
expr_stmt|;
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
for|for
control|(
name|sf
operator|=
name|NULL
operator|,
name|pi
operator|=
literal|0
init|;
name|size
operator|>
literal|0
condition|;
name|base
operator|+=
name|pg_sz
operator|,
name|size
operator|-=
name|pg_sz
operator|,
name|pi
operator|+=
name|run_sz
control|)
block|{
for|for
control|(
name|lvl
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
operator|,
name|superpage
operator|=
name|false
init|;
condition|;
name|lvl
operator|++
control|)
block|{
name|pg_sz
operator|=
name|ctx_page_size
argument_list|(
name|ctx
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
name|run_sz
operator|=
name|pg_sz
operator|>>
name|DMAR_PAGE_SHIFT
expr_stmt|;
if|if
condition|(
name|lvl
operator|==
name|ctx
operator|->
name|pglvl
operator|-
literal|1
condition|)
break|break;
comment|/* 			 * Check if the current base suitable for the 			 * superpage mapping.  First, verify the level. 			 */
if|if
condition|(
operator|!
name|ctx_is_sp_lvl
argument_list|(
name|ctx
argument_list|,
name|lvl
argument_list|)
condition|)
continue|continue;
comment|/* 			 * Next, look at the size of the mapping and 			 * alignment of both guest and host addresses. 			 */
if|if
condition|(
name|size
operator|<
name|pg_sz
operator|||
operator|(
name|base
operator|&
operator|(
name|pg_sz
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|pi
index|]
argument_list|)
operator|&
operator|(
name|pg_sz
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* All passed, check host pages contiguouty. */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|1
init|;
name|c
operator|<
name|run_sz
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|pi
operator|+
name|c
index|]
argument_list|)
operator|!=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|pi
operator|+
name|c
operator|-
literal|1
index|]
argument_list|)
operator|+
name|PAGE_SIZE
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|c
operator|>=
name|run_sz
condition|)
block|{
name|superpage
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|size
operator|>=
name|pg_sz
argument_list|,
operator|(
literal|"mapping loop overflow %p %jx %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
operator|(
name|uintmax_t
operator|)
name|pg_sz
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|ctx_pgtbl_map_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|,
name|flags
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
name|DMAR_PGF_WAITOK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"failed waitable pte alloc %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
block|{
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ctx_unmap_buf_locked
argument_list|(
name|ctx
argument_list|,
name|base1
argument_list|,
name|base
operator|-
name|base1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|dmar_pte_store
argument_list|(
operator|&
name|pte
operator|->
name|pte
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|ma
index|[
name|pi
index|]
argument_list|)
operator||
name|pflags
operator||
operator|(
name|superpage
condition|?
name|DMAR_PTE_SP
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sf_buf_page
argument_list|(
name|sf
argument_list|)
operator|->
name|wire_count
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctx_map_buf
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|uint64_t
name|pflags
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unit
operator|=
name|ctx
operator|->
name|dmar
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_IDMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"modifying idmap pagetable ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|base
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"non-aligned base %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"non-aligned size %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|,
operator|(
literal|"zero size %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|<
operator|(
literal|1ULL
operator|<<
name|ctx
operator|->
name|agaw
operator|)
argument_list|,
operator|(
literal|"base too high %p %jx %jx agaw %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
name|ctx
operator|->
name|agaw
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|+
name|size
operator|<
operator|(
literal|1ULL
operator|<<
name|ctx
operator|->
name|agaw
operator|)
argument_list|,
operator|(
literal|"end too high %p %jx %jx agaw %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
name|ctx
operator|->
name|agaw
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|+
name|size
operator|>
name|base
argument_list|,
operator|(
literal|"size overflow %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pflags
operator|&
operator|(
name|DMAR_PTE_R
operator||
name|DMAR_PTE_W
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"neither read nor write %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|pflags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pflags
operator|&
operator|~
operator|(
name|DMAR_PTE_R
operator||
name|DMAR_PTE_W
operator||
name|DMAR_PTE_SNP
operator||
name|DMAR_PTE_TM
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid pte flags %jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|pflags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pflags
operator|&
name|DMAR_PTE_SNP
operator|)
operator|==
literal|0
operator|||
operator|(
name|unit
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_SC
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"PTE_SNP for dmar without snoop control %p %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|pflags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pflags
operator|&
name|DMAR_PTE_TM
operator|)
operator|==
literal|0
operator|||
operator|(
name|unit
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_DI
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"PTE_TM for dmar without DIOTLB %p %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|pflags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|DMAR_PGF_WAITOK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid flags %x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|DMAR_CTX_PGLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctx_map_buf_locked
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|ma
argument_list|,
name|pflags
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DMAR_CTX_PGUNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_CM
operator|)
operator|!=
literal|0
condition|)
name|ctx_flush_iotlb_sync
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_RWBF
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* See 11.1 Write Buffer Flushing. */
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|dmar_flush_write_bufs
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|ctx_unmap_clear_pte
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|,
name|int
name|flags
parameter_list|,
name|dmar_pte_t
modifier|*
name|pte
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sf
parameter_list|,
name|bool
name|free_fs
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ctx_free_pgtbl_pde
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|dmar_pte_t
modifier|*
name|pde
decl_stmt|;
name|vm_pindex_t
name|idx
decl_stmt|;
name|sf
operator|=
name|NULL
expr_stmt|;
name|pde
operator|=
name|ctx_pgtbl_map_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|,
name|flags
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|ctx_unmap_clear_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|,
name|flags
argument_list|,
name|pde
argument_list|,
operator|&
name|sf
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ctx_unmap_clear_pte
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|int
name|lvl
parameter_list|,
name|int
name|flags
parameter_list|,
name|dmar_pte_t
modifier|*
name|pte
parameter_list|,
name|struct
name|sf_buf
modifier|*
modifier|*
name|sf
parameter_list|,
name|bool
name|free_sf
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|dmar_pte_clear
argument_list|(
operator|&
name|pte
operator|->
name|pte
argument_list|)
expr_stmt|;
name|m
operator|=
name|sf_buf_page
argument_list|(
operator|*
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_sf
condition|)
block|{
name|dmar_unmap_pgtbl
argument_list|(
operator|*
name|sf
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sf
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|lvl
operator|!=
literal|0
argument_list|,
operator|(
literal|"lost reference (lvl) on root pg ctx %p base %jx lvl %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|pindex
operator|!=
literal|0
argument_list|,
operator|(
literal|"lost reference (idx) on root pg ctx %p base %jx lvl %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|dmar_pgfree
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ctx_free_pgtbl_pde
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
operator|-
literal|1
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assumes that the unmap is never partial.  */
end_comment

begin_function
specifier|static
name|int
name|ctx_unmap_buf_locked
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dmar_pte_t
modifier|*
name|pte
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|vm_pindex_t
name|idx
decl_stmt|;
name|dmar_gaddr_t
name|pg_sz
decl_stmt|,
name|base1
decl_stmt|,
name|size1
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|DMAR_CTX_ASSERT_PGLOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_IDMAP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"modifying idmap pagetable ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|base
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"non-aligned base %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|DMAR_PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"non-aligned size %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|<
operator|(
literal|1ULL
operator|<<
name|ctx
operator|->
name|agaw
operator|)
argument_list|,
operator|(
literal|"base too high %p %jx %jx agaw %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
name|ctx
operator|->
name|agaw
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|+
name|size
operator|<
operator|(
literal|1ULL
operator|<<
name|ctx
operator|->
name|agaw
operator|)
argument_list|,
operator|(
literal|"end too high %p %jx %jx agaw %d"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
name|ctx
operator|->
name|agaw
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|base
operator|+
name|size
operator|>
name|base
argument_list|,
operator|(
literal|"size overflow %p %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
name|DMAR_PGF_WAITOK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"invalid flags %x"
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
name|pg_sz
operator|=
literal|0
expr_stmt|;
comment|/* silence gcc */
name|base1
operator|=
name|base
expr_stmt|;
name|size1
operator|=
name|size
expr_stmt|;
name|flags
operator||=
name|DMAR_PGF_OBJL
expr_stmt|;
name|TD_PREP_PINNED_ASSERT
expr_stmt|;
for|for
control|(
name|sf
operator|=
name|NULL
init|;
name|size
operator|>
literal|0
condition|;
name|base
operator|+=
name|pg_sz
operator|,
name|size
operator|-=
name|pg_sz
control|)
block|{
for|for
control|(
name|lvl
operator|=
literal|0
init|;
name|lvl
operator|<
name|ctx
operator|->
name|pglvl
condition|;
name|lvl
operator|++
control|)
block|{
if|if
condition|(
name|lvl
operator|!=
name|ctx
operator|->
name|pglvl
operator|-
literal|1
operator|&&
operator|!
name|ctx_is_sp_lvl
argument_list|(
name|ctx
argument_list|,
name|lvl
argument_list|)
condition|)
continue|continue;
name|pg_sz
operator|=
name|ctx_page_size
argument_list|(
name|ctx
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg_sz
operator|>
name|size
condition|)
continue|continue;
name|pte
operator|=
name|ctx_pgtbl_map_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|,
name|flags
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sleeping or page missed %p %jx %d 0x%x"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
name|lvl
operator|,
name|flags
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pte
operator|->
name|pte
operator|&
name|DMAR_PTE_SP
operator|)
operator|!=
literal|0
operator|||
name|lvl
operator|==
name|ctx
operator|->
name|pglvl
operator|-
literal|1
condition|)
block|{
name|ctx_unmap_clear_pte
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|lvl
argument_list|,
name|flags
argument_list|,
name|pte
argument_list|,
operator|&
name|sf
argument_list|,
name|false
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|size
operator|>=
name|pg_sz
argument_list|,
operator|(
literal|"unmapping loop overflow %p %jx %jx %jx"
operator|,
name|ctx
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
operator|(
name|uintmax_t
operator|)
name|pg_sz
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sf
operator|!=
name|NULL
condition|)
name|dmar_unmap_pgtbl
argument_list|(
name|sf
argument_list|,
name|DMAR_IS_COHERENT
argument_list|(
name|ctx
operator|->
name|dmar
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * See 11.1 Write Buffer Flushing for an explanation why RWBF 	 * can be ignored there. 	 */
name|TD_PINNED_ASSERT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctx_unmap_buf
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DMAR_CTX_PGLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ctx_unmap_buf_locked
argument_list|(
name|ctx
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|DMAR_CTX_PGUNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ctx_alloc_pgtbl
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
operator|==
name|NULL
argument_list|,
operator|(
literal|"already initialized %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pgtbl_obj
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|NULL
argument_list|,
name|IDX_TO_OFF
argument_list|(
name|pglvl_max_pages
argument_list|(
name|ctx
operator|->
name|pglvl
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DMAR_CTX_PGLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|m
operator|=
name|dmar_pgalloc
argument_list|(
name|ctx
operator|->
name|pgtbl_obj
argument_list|,
literal|0
argument_list|,
name|DMAR_PGF_WAITOK
operator||
name|DMAR_PGF_ZERO
operator||
name|DMAR_PGF_OBJL
argument_list|)
expr_stmt|;
comment|/* No implicit free of the top level page table page. */
name|m
operator|->
name|wire_count
operator|=
literal|1
expr_stmt|;
name|DMAR_CTX_PGUNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctx_free_pgtbl
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|obj
operator|=
name|ctx
operator|->
name|pgtbl_obj
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|ctx
operator|->
name|dmar
operator|->
name|hw_ecap
operator|&
name|DMAR_ECAP_PT
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_IDMAP
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"lost pagetable object ctx %p"
operator|,
name|ctx
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|DMAR_CTX_ASSERT_PGLOCKED
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|pgtbl_obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ctx
operator|->
name|flags
operator|&
name|DMAR_CTX_IDMAP
operator|)
operator|!=
literal|0
condition|)
block|{
name|put_idmap_pgtbl
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|flags
operator|&=
operator|~
name|DMAR_CTX_IDMAP
expr_stmt|;
return|return;
block|}
comment|/* Obliterate wire_counts */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|vm_page_next
argument_list|(
name|m
argument_list|)
control|)
name|m
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|ctx_wait_iotlb_flush
parameter_list|(
name|struct
name|dmar_unit
modifier|*
name|unit
parameter_list|,
name|uint64_t
name|wt
parameter_list|,
name|int
name|iro
parameter_list|)
block|{
name|uint64_t
name|iotlbr
decl_stmt|;
name|dmar_write8
argument_list|(
name|unit
argument_list|,
name|iro
operator|+
name|DMAR_IOTLB_REG_OFF
argument_list|,
name|DMAR_IOTLB_IVT
operator||
name|DMAR_IOTLB_DR
operator||
name|DMAR_IOTLB_DW
operator||
name|wt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|iotlbr
operator|=
name|dmar_read8
argument_list|(
name|unit
argument_list|,
name|iro
operator|+
name|DMAR_IOTLB_REG_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|iotlbr
operator|&
name|DMAR_IOTLB_IVT
operator|)
operator|==
literal|0
condition|)
break|break;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|iotlbr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ctx_flush_iotlb_sync
parameter_list|(
name|struct
name|dmar_ctx
modifier|*
name|ctx
parameter_list|,
name|dmar_gaddr_t
name|base
parameter_list|,
name|dmar_gaddr_t
name|size
parameter_list|)
block|{
name|struct
name|dmar_unit
modifier|*
name|unit
decl_stmt|;
name|dmar_gaddr_t
name|isize
decl_stmt|;
name|uint64_t
name|iotlbr
decl_stmt|;
name|int
name|am
decl_stmt|,
name|iro
decl_stmt|;
name|unit
operator|=
name|ctx
operator|->
name|dmar
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|unit
operator|->
name|qi_enabled
argument_list|,
operator|(
literal|"dmar%d: sync iotlb flush call"
operator|,
name|unit
operator|->
name|unit
operator|)
argument_list|)
expr_stmt|;
name|iro
operator|=
name|DMAR_ECAP_IRO
argument_list|(
name|unit
operator|->
name|hw_ecap
argument_list|)
operator|*
literal|16
expr_stmt|;
name|DMAR_LOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unit
operator|->
name|hw_cap
operator|&
name|DMAR_CAP_PSI
operator|)
operator|==
literal|0
operator|||
name|size
operator|>
literal|2
operator|*
literal|1024
operator|*
literal|1024
condition|)
block|{
name|iotlbr
operator|=
name|ctx_wait_iotlb_flush
argument_list|(
name|unit
argument_list|,
name|DMAR_IOTLB_IIRG_DOM
operator||
name|DMAR_IOTLB_DID
argument_list|(
name|ctx
operator|->
name|domain
argument_list|)
argument_list|,
name|iro
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|iotlbr
operator|&
name|DMAR_IOTLB_IAIG_MASK
operator|)
operator|!=
name|DMAR_IOTLB_IAIG_INVLD
argument_list|,
operator|(
literal|"dmar%d: invalidation failed %jx"
operator|,
name|unit
operator|->
name|unit
operator|,
operator|(
name|uintmax_t
operator|)
name|iotlbr
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|base
operator|+=
name|isize
operator|,
name|size
operator|-=
name|isize
control|)
block|{
name|am
operator|=
name|calc_am
argument_list|(
name|unit
argument_list|,
name|base
argument_list|,
name|size
argument_list|,
operator|&
name|isize
argument_list|)
expr_stmt|;
name|dmar_write8
argument_list|(
name|unit
argument_list|,
name|iro
argument_list|,
name|base
operator||
name|am
argument_list|)
expr_stmt|;
name|iotlbr
operator|=
name|ctx_wait_iotlb_flush
argument_list|(
name|unit
argument_list|,
name|DMAR_IOTLB_IIRG_PAGE
operator||
name|DMAR_IOTLB_DID
argument_list|(
name|ctx
operator|->
name|domain
argument_list|)
argument_list|,
name|iro
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|iotlbr
operator|&
name|DMAR_IOTLB_IAIG_MASK
operator|)
operator|!=
name|DMAR_IOTLB_IAIG_INVLD
argument_list|,
operator|(
literal|"dmar%d: PSI invalidation failed "
literal|"iotlbr 0x%jx base 0x%jx size 0x%jx am %d"
operator|,
name|unit
operator|->
name|unit
operator|,
operator|(
name|uintmax_t
operator|)
name|iotlbr
operator|,
operator|(
name|uintmax_t
operator|)
name|base
operator|,
operator|(
name|uintmax_t
operator|)
name|size
operator|,
name|am
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Any non-page granularity covers whole guest 			 * address space for the domain. 			 */
if|if
condition|(
operator|(
name|iotlbr
operator|&
name|DMAR_IOTLB_IAIG_MASK
operator|)
operator|!=
name|DMAR_IOTLB_IAIG_PAGE
condition|)
break|break;
block|}
block|}
name|DMAR_UNLOCK
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

