begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Nate Lawson  * Copyright (c) 2004 Colin Percival  * Copyright (c) 2004-2005 Bruno Durcot  * Copyright (c) 2004 FUKUDA Nobuhiko  * Copyright (c) 2009 Michael Reifenberger  * Copyright (c) 2009 Norikatsu Shigemura  * Copyright (c) 2008-2009 Gen Otsuji  *  * This code is depending on kern_cpu.c, est.c, powernow.c, p4tcc.c, smist.c  * in various parts. The authors of these files are Nate Lawson,  * Colin Percival, Bruno Durcot, and FUKUDA Nobuhiko.  * This code contains patches by Michael Reifenberger and Norikatsu Shigemura.  * Thank you.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted providing that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * For more info:  * BIOS and Kernel Developer's Guide(BKDG) for AMD Family 10h Processors  * 31116 Rev 3.20  February 04, 2009  * BIOS and Kernel Developer's Guide(BKDG) for AMD Family 11h Processors  * 41256 Rev 3.00 - July 07, 2008  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<contrib/dev/acpica/include/acpi.h>
end_include

begin_include
include|#
directive|include
file|<dev/acpica/acpivar.h>
end_include

begin_include
include|#
directive|include
file|"acpi_if.h"
end_include

begin_include
include|#
directive|include
file|"cpufreq_if.h"
end_include

begin_define
define|#
directive|define
name|MSR_AMD_10H_11H_LIMIT
value|0xc0010061
end_define

begin_define
define|#
directive|define
name|MSR_AMD_10H_11H_CONTROL
value|0xc0010062
end_define

begin_define
define|#
directive|define
name|MSR_AMD_10H_11H_STATUS
value|0xc0010063
end_define

begin_define
define|#
directive|define
name|MSR_AMD_10H_11H_CONFIG
value|0xc0010064
end_define

begin_define
define|#
directive|define
name|AMD_10H_11H_MAX_STATES
value|16
end_define

begin_comment
comment|/* for MSR_AMD_10H_11H_LIMIT C001_0061 */
end_comment

begin_define
define|#
directive|define
name|AMD_10H_11H_GET_PSTATE_MAX_VAL
parameter_list|(
name|msr
parameter_list|)
value|(((msr)>> 4)& 0x7)
end_define

begin_define
define|#
directive|define
name|AMD_10H_11H_GET_PSTATE_LIMIT
parameter_list|(
name|msr
parameter_list|)
value|(((msr))& 0x7)
end_define

begin_comment
comment|/* for MSR_AMD_10H_11H_CONFIG 10h:C001_0064:68 / 11h:C001_0064:6B */
end_comment

begin_define
define|#
directive|define
name|AMD_10H_11H_CUR_VID
parameter_list|(
name|msr
parameter_list|)
value|(((msr)>> 9)& 0x7F)
end_define

begin_define
define|#
directive|define
name|AMD_10H_11H_CUR_DID
parameter_list|(
name|msr
parameter_list|)
value|(((msr)>> 6)& 0x07)
end_define

begin_define
define|#
directive|define
name|AMD_10H_11H_CUR_FID
parameter_list|(
name|msr
parameter_list|)
value|((msr)& 0x3F)
end_define

begin_define
define|#
directive|define
name|HWPSTATE_DEBUG
parameter_list|(
name|dev
parameter_list|,
name|msg
modifier|...
parameter_list|)
define|\
value|do{						\ 		if(hwpstate_verbose)			\ 			device_printf(dev, msg);	\ 	}while(0)
end_define

begin_struct
struct|struct
name|hwpstate_setting
block|{
name|int
name|freq
decl_stmt|;
comment|/* CPU clock in Mhz or 100ths of a percent. */
name|int
name|volts
decl_stmt|;
comment|/* Voltage in mV. */
name|int
name|power
decl_stmt|;
comment|/* Power consumed in mW. */
name|int
name|lat
decl_stmt|;
comment|/* Transition latency in us. */
name|int
name|pstate_id
decl_stmt|;
comment|/* P-State id */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|hwpstate_softc
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|hwpstate_setting
name|hwpstate_settings
index|[
name|AMD_10H_11H_MAX_STATES
index|]
decl_stmt|;
name|int
name|cfnum
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|hwpstate_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|cf_setting
modifier|*
name|cf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_get
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|cf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_settings
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|sets
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_features
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|u_int
modifier|*
name|features
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_get_info_from_acpi_perf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|perf_dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_get_info_from_msr
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hwpstate_goto_pstate
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|pstate_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|hwpstate_verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|hwpstate_verbose
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|hwpstate_verbose
argument_list|,
literal|0
argument_list|,
literal|"Debug hwpstate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"debug.hwpstate_verbose"
argument_list|,
operator|&
name|hwpstate_verbose
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|hwpstate_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_identify
argument_list|,
name|hwpstate_identify
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|hwpstate_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|hwpstate_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|hwpstate_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|hwpstate_shutdown
argument_list|)
block|,
comment|/* cpufreq interface */
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_set
argument_list|,
name|hwpstate_set
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_get
argument_list|,
name|hwpstate_get
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_settings
argument_list|,
name|hwpstate_settings
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|cpufreq_drv_type
argument_list|,
name|hwpstate_type
argument_list|)
block|,
comment|/* ACPI interface */
name|DEVMETHOD
argument_list|(
name|acpi_get_features
argument_list|,
name|hwpstate_features
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|hwpstate_devclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|hwpstate_driver
init|=
block|{
literal|"hwpstate"
block|,
name|hwpstate_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|hwpstate_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|hwpstate
argument_list|,
name|cpu
argument_list|,
name|hwpstate_driver
argument_list|,
name|hwpstate_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Go to Px-state on all cpus considering the limit.  */
end_comment

begin_function
specifier|static
name|int
name|hwpstate_goto_pstate
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
name|pstate
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|limit
decl_stmt|;
name|int
name|id
init|=
name|pstate
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* get the current pstate limit */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_LIMIT
argument_list|)
expr_stmt|;
name|limit
operator|=
name|AMD_10H_11H_GET_PSTATE_LIMIT
argument_list|(
name|msr
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|>
name|id
condition|)
name|id
operator|=
name|limit
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We are going to the same Px-state on all cpus. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
comment|/* Find each cpu. */
name|pc
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Bind to each cpu. */
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|pc
operator|->
name|pc_cpuid
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"setting P%d-state on cpu%d\n"
argument_list|,
name|id
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Go To Px-state */
name|wrmsr
argument_list|(
name|MSR_AMD_10H_11H_CONTROL
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* wait loop (100*100 usec is enough ?) */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|100
condition|;
name|j
operator|++
control|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|==
name|id
condition|)
block|{
break|break;
block|}
name|DELAY
argument_list|(
literal|100
argument_list|)
expr_stmt|;
block|}
comment|/* get the result. not assure msr=id */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_STATUS
argument_list|)
expr_stmt|;
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"result  P%d-state on cpu%d\n"
argument_list|,
operator|(
name|int
operator|)
name|msr
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|!=
name|id
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"error: loop is not enough.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_set
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|cf_setting
modifier|*
name|cf
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hwpstate_setting
modifier|*
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|set
operator|=
name|sc
operator|->
name|hwpstate_settings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cfnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CPUFREQ_CMP
argument_list|(
name|cf
operator|->
name|freq
argument_list|,
name|set
index|[
name|i
index|]
operator|.
name|freq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|cfnum
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|hwpstate_goto_pstate
argument_list|(
name|dev
argument_list|,
name|set
index|[
name|i
index|]
operator|.
name|pstate_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_get
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|cf
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hwpstate_setting
name|set
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|msr
operator|>=
name|sc
operator|->
name|cfnum
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|set
operator|=
name|sc
operator|->
name|hwpstate_settings
index|[
name|msr
index|]
expr_stmt|;
name|cf
operator|->
name|freq
operator|=
name|set
operator|.
name|freq
expr_stmt|;
name|cf
operator|->
name|volts
operator|=
name|set
operator|.
name|volts
expr_stmt|;
name|cf
operator|->
name|power
operator|=
name|set
operator|.
name|power
expr_stmt|;
name|cf
operator|->
name|lat
operator|=
name|set
operator|.
name|lat
expr_stmt|;
name|cf
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_settings
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|cf_setting
modifier|*
name|sets
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hwpstate_setting
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sets
operator|==
name|NULL
operator|||
name|count
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|count
operator|<
name|sc
operator|->
name|cfnum
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cfnum
condition|;
name|i
operator|++
operator|,
name|sets
operator|++
control|)
block|{
name|set
operator|=
name|sc
operator|->
name|hwpstate_settings
index|[
name|i
index|]
expr_stmt|;
name|sets
operator|->
name|freq
operator|=
name|set
operator|.
name|freq
expr_stmt|;
name|sets
operator|->
name|volts
operator|=
name|set
operator|.
name|volts
expr_stmt|;
name|sets
operator|->
name|power
operator|=
name|set
operator|.
name|power
expr_stmt|;
name|sets
operator|->
name|lat
operator|=
name|set
operator|.
name|lat
expr_stmt|;
name|sets
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
block|}
operator|*
name|count
operator|=
name|sc
operator|->
name|cfnum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_type
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|int
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|type
operator|=
name|CPUFREQ_TYPE_ABSOLUTE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hwpstate_identify
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|device_t
name|parent
parameter_list|)
block|{
if|if
condition|(
name|device_find_child
argument_list|(
name|parent
argument_list|,
literal|"hwpstate"
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
name|NULL
condition|)
return|return;
if|if
condition|(
name|cpu_vendor_id
operator|!=
name|CPU_VENDOR_AMD
operator|||
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
operator|<
literal|0x10
condition|)
return|return;
comment|/* 	 * Check if hardware pstate enable bit is set. 	 */
if|if
condition|(
operator|(
name|amd_pminfo
operator|&
name|AMDPM_HW_PSTATE
operator|)
operator|==
literal|0
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|parent
argument_list|,
literal|"hwpstate enable bit is not set.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|resource_disabled
argument_list|(
literal|"hwpstate"
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
if|if
condition|(
name|BUS_ADD_CHILD
argument_list|(
name|parent
argument_list|,
literal|10
argument_list|,
literal|"hwpstate"
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|parent
argument_list|,
literal|"hwpstate: add child failed\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|perf_dev
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|;
comment|/* 	 * Only hwpstate0. 	 * It goes well with acpi_throttle. 	 */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Check if acpi_perf has INFO only flag. 	 */
name|perf_dev
operator|=
name|device_find_child
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"acpi_perf"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|perf_dev
operator|&&
name|device_is_attached
argument_list|(
name|perf_dev
argument_list|)
condition|)
block|{
name|error
operator|=
name|CPUFREQ_DRV_TYPE
argument_list|(
name|perf_dev
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|&
name|CPUFREQ_FLAG_INFO_ONLY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If acpi_perf doesn't have INFO_ONLY flag, 				 * it will take care of pstate transitions. 				 */
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"acpi_perf will take care of pstate transitions.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * If acpi_perf has INFO_ONLY flag, (_PCT has FFixedHW) 				 * we can get _PSS info from acpi_perf 				 * without going into ACPI. 				 */
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"going to fetch info from acpi_perf\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|hwpstate_get_info_from_acpi_perf
argument_list|(
name|dev
argument_list|,
name|perf_dev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Now we get _PSS info from acpi_perf without error. 		 * Let's check it. 		 */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_LIMIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|cfnum
operator|!=
literal|1
operator|+
name|AMD_10H_11H_GET_PSTATE_MAX_VAL
argument_list|(
name|msr
argument_list|)
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"msr and acpi _PSS count mismatch.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* 	 * If we cannot get info from acpi_perf, 	 * Let's get info from MSRs. 	 */
if|if
condition|(
name|error
condition|)
name|error
operator|=
name|hwpstate_get_info_from_msr
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Cool`n'Quiet 2.0"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|cpufreq_register
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_get_info_from_msr
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|hwpstate_setting
modifier|*
name|hwpstate_set
decl_stmt|;
name|uint64_t
name|msr
decl_stmt|;
name|int
name|family
decl_stmt|,
name|i
decl_stmt|,
name|fid
decl_stmt|,
name|did
decl_stmt|;
name|family
operator|=
name|CPUID_TO_FAMILY
argument_list|(
name|cpu_id
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Get pstate count */
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_LIMIT
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cfnum
operator|=
literal|1
operator|+
name|AMD_10H_11H_GET_PSTATE_MAX_VAL
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|hwpstate_set
operator|=
name|sc
operator|->
name|hwpstate_settings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|cfnum
condition|;
name|i
operator|++
control|)
block|{
name|msr
operator|=
name|rdmsr
argument_list|(
name|MSR_AMD_10H_11H_CONFIG
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msr
operator|&
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
operator|)
operator|)
operator|!=
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|<<
literal|63
operator|)
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"msr is not valid.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|did
operator|=
name|AMD_10H_11H_CUR_DID
argument_list|(
name|msr
argument_list|)
expr_stmt|;
name|fid
operator|=
name|AMD_10H_11H_CUR_FID
argument_list|(
name|msr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|family
condition|)
block|{
case|case
literal|0x11
case|:
comment|/* fid/did to frequency */
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|freq
operator|=
literal|100
operator|*
operator|(
name|fid
operator|+
literal|0x08
operator|)
operator|/
operator|(
literal|1
operator|<<
name|did
operator|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
comment|/* fid/did to frequency */
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|freq
operator|=
literal|100
operator|*
operator|(
name|fid
operator|+
literal|0x10
operator|)
operator|/
operator|(
literal|1
operator|<<
name|did
operator|)
expr_stmt|;
break|break;
default|default:
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"get_info_from_msr: AMD family %d CPU's are not implemented yet. sorry.\n"
argument_list|,
name|family
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
break|break;
block|}
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|pstate_id
operator|=
name|i
expr_stmt|;
comment|/* There was volts calculation, but deleted it. */
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|volts
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|power
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|lat
operator|=
name|CPUFREQ_VAL_UNKNOWN
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_get_info_from_acpi_perf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|perf_dev
parameter_list|)
block|{
name|struct
name|hwpstate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cf_setting
modifier|*
name|perf_set
decl_stmt|;
name|struct
name|hwpstate_setting
modifier|*
name|hwpstate_set
decl_stmt|;
name|int
name|count
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|perf_set
operator|=
name|malloc
argument_list|(
name|MAX_SETTINGS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|perf_set
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|perf_set
operator|==
name|NULL
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"nomem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Fetch settings from acpi_perf. 	 * Now it is attached, and has info only flag. 	 */
name|count
operator|=
name|MAX_SETTINGS
expr_stmt|;
name|error
operator|=
name|CPUFREQ_DRV_SETTINGS
argument_list|(
name|perf_dev
argument_list|,
name|perf_set
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"error: CPUFREQ_DRV_SETTINGS.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|cfnum
operator|=
name|count
expr_stmt|;
name|hwpstate_set
operator|=
name|sc
operator|->
name|hwpstate_settings
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|perf_set
index|[
name|i
index|]
operator|.
name|spec
index|[
literal|0
index|]
condition|)
block|{
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|pstate_id
operator|=
name|i
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|freq
operator|=
name|perf_set
index|[
name|i
index|]
operator|.
name|freq
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|volts
operator|=
name|perf_set
index|[
name|i
index|]
operator|.
name|volts
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|power
operator|=
name|perf_set
index|[
name|i
index|]
operator|.
name|power
expr_stmt|;
name|hwpstate_set
index|[
name|i
index|]
operator|.
name|lat
operator|=
name|perf_set
index|[
name|i
index|]
operator|.
name|lat
expr_stmt|;
block|}
else|else
block|{
name|HWPSTATE_DEBUG
argument_list|(
name|dev
argument_list|,
literal|"ACPI _PSS object mismatch.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|perf_set
condition|)
name|free
argument_list|(
name|perf_set
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|hwpstate_goto_pstate
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpufreq_unregister
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
comment|/* hwpstate_goto_pstate(dev, 0); */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hwpstate_features
parameter_list|(
name|driver_t
modifier|*
name|driver
parameter_list|,
name|u_int
modifier|*
name|features
parameter_list|)
block|{
comment|/* Notify the ACPI CPU that we support direct access to MSRs */
operator|*
name|features
operator|=
name|ACPI_CAP_PERF_MSRS
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

