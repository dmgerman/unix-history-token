begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Poul-Henning Kamp  * Copyright (c) 2010 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_isa.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeet.h>
end_include

begin_include
include|#
directive|include
file|<isa/rtc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_ISA
end_ifdef

begin_include
include|#
directive|include
file|<isa/isareg.h>
end_include

begin_include
include|#
directive|include
file|<isa/isavar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/intr_machdep.h>
end_include

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_comment
comment|/*  * clock_lock protects low-level access to individual hardware registers.  * atrtc_time_lock protects the entire sequence of accessing multiple registers  * to read or write the date and time.  */
end_comment

begin_define
define|#
directive|define
name|RTC_LOCK
value|do { if (!kdb_active) mtx_lock_spin(&clock_lock); } while (0)
end_define

begin_define
define|#
directive|define
name|RTC_UNLOCK
value|do { if (!kdb_active) mtx_unlock_spin(&clock_lock); } while (0)
end_define

begin_decl_stmt
name|struct
name|mtx
name|atrtc_time_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|atrtc_lock_init
argument_list|,
operator|&
name|atrtc_time_lock
argument_list|,
literal|"atrtc"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|atrtcclock_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rtc_reg
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|rtc_statusa
init|=
name|RTCSA_DIVIDER
operator||
name|RTCSA_NOPROF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|rtc_statusb
init|=
name|RTCSB_24HR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * RTC support routines  */
end_comment

begin_function
name|int
name|rtcin
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|u_char
name|val
decl_stmt|;
name|RTC_LOCK
expr_stmt|;
if|if
condition|(
name|rtc_reg
operator|!=
name|reg
condition|)
block|{
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_RTC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rtc_reg
operator|=
name|reg
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|inb
argument_list|(
name|IO_RTC
operator|+
literal|1
argument_list|)
expr_stmt|;
name|RTC_UNLOCK
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|writertc
parameter_list|(
name|int
name|reg
parameter_list|,
name|u_char
name|val
parameter_list|)
block|{
name|RTC_LOCK
expr_stmt|;
if|if
condition|(
name|rtc_reg
operator|!=
name|reg
condition|)
block|{
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|IO_RTC
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|rtc_reg
operator|=
name|reg
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
block|}
name|outb
argument_list|(
name|IO_RTC
operator|+
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|inb
argument_list|(
literal|0x84
argument_list|)
expr_stmt|;
name|RTC_UNLOCK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|readrtc
parameter_list|(
name|int
name|port
parameter_list|)
block|{
return|return
operator|(
name|bcd2bin
argument_list|(
name|rtcin
argument_list|(
name|port
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atrtc_start
parameter_list|(
name|void
parameter_list|)
block|{
name|writertc
argument_list|(
name|RTC_STATUSA
argument_list|,
name|rtc_statusa
argument_list|)
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|RTCSB_24HR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atrtc_rate
parameter_list|(
name|unsigned
name|rate
parameter_list|)
block|{
name|rtc_statusa
operator|=
name|RTCSA_DIVIDER
operator||
name|rate
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSA
argument_list|,
name|rtc_statusa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atrtc_enable_intr
parameter_list|(
name|void
parameter_list|)
block|{
name|rtc_statusb
operator||=
name|RTCSB_PINTR
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|rtc_statusb
argument_list|)
expr_stmt|;
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|atrtc_disable_intr
parameter_list|(
name|void
parameter_list|)
block|{
name|rtc_statusb
operator|&=
operator|~
name|RTCSB_PINTR
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|rtc_statusb
argument_list|)
expr_stmt|;
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|atrtc_restore
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Restore all of the RTC's "status" (actually, control) registers. */
name|rtcin
argument_list|(
name|RTC_STATUSA
argument_list|)
expr_stmt|;
comment|/* dummy to get rtc_reg set */
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|RTCSB_24HR
argument_list|)
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSA
argument_list|,
name|rtc_statusa
argument_list|)
expr_stmt|;
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|rtc_statusb
argument_list|)
expr_stmt|;
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|atrtc_set
parameter_list|(
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
name|clock_ts_to_ct
argument_list|(
name|ts
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|atrtc_time_lock
argument_list|)
expr_stmt|;
comment|/* Disable RTC updates and interrupts. */
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|RTCSB_HALT
operator||
name|RTCSB_24HR
argument_list|)
expr_stmt|;
name|writertc
argument_list|(
name|RTC_SEC
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|sec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Seconds */
name|writertc
argument_list|(
name|RTC_MIN
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|min
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Minutes */
name|writertc
argument_list|(
name|RTC_HRS
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|hour
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Hours   */
name|writertc
argument_list|(
name|RTC_WDAY
argument_list|,
name|ct
operator|.
name|dow
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Write back Weekday */
name|writertc
argument_list|(
name|RTC_DAY
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|day
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Day */
name|writertc
argument_list|(
name|RTC_MONTH
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|mon
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Month   */
name|writertc
argument_list|(
name|RTC_YEAR
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|year
operator|%
literal|100
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write back Year    */
ifdef|#
directive|ifdef
name|USE_RTC_CENTURY
name|writertc
argument_list|(
name|RTC_CENTURY
argument_list|,
name|bin2bcd
argument_list|(
name|ct
operator|.
name|year
operator|/
literal|100
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and Century    */
endif|#
directive|endif
comment|/* Re-enable RTC updates and interrupts. */
name|writertc
argument_list|(
name|RTC_STATUSB
argument_list|,
name|rtc_statusb
argument_list|)
expr_stmt|;
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|atrtc_time_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************  * RTC driver for subr_rtc  */
end_comment

begin_struct
struct|struct
name|atrtc_softc
block|{
name|int
name|port_rid
decl_stmt|,
name|intr_rid
decl_stmt|;
name|struct
name|resource
modifier|*
name|port_res
decl_stmt|;
name|struct
name|resource
modifier|*
name|intr_res
decl_stmt|;
name|void
modifier|*
name|intr_handler
decl_stmt|;
name|struct
name|eventtimer
name|et
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|rtc_start
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|,
name|sbintime_t
name|first
parameter_list|,
name|sbintime_t
name|period
parameter_list|)
block|{
name|atrtc_rate
argument_list|(
name|max
argument_list|(
name|fls
argument_list|(
name|period
operator|+
operator|(
name|period
operator|>>
literal|1
operator|)
argument_list|)
operator|-
literal|17
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|atrtc_enable_intr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rtc_stop
parameter_list|(
name|struct
name|eventtimer
modifier|*
name|et
parameter_list|)
block|{
name|atrtc_disable_intr
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine receives statistical clock interrupts from the RTC.  * As explained above, these occur at 128 interrupts per second.  * When profiling, we receive interrupts at a rate of 1024 Hz.  *  * This does not actually add as much overhead as it sounds, because  * when the statistical clock is active, the hardclock driver no longer  * needs to keep (inaccurate) statistics on its own.  This decouples  * statistics gathering from scheduling interrupts.  *  * The RTC chip requires that we read status register C (RTC_INTR)  * to acknowledge an interrupt, before it will generate the next one.  * Under high interrupt load, rtcintr() can be indefinitely delayed and  * the clock can tick immediately after the read from RTC_INTR.  In this  * case, the mc146818A interrupt signal will not drop for long enough  * to register with the 8259 PIC.  If an interrupt is missed, the stat  * clock will halt, considerably degrading system performance.  This is  * why we use 'while' rather than a more straightforward 'if' below.  * Stat clock ticks can still be lost, causing minor loss of accuracy  * in the statistics, but the stat clock will no longer stop.  */
end_comment

begin_function
specifier|static
name|int
name|rtc_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|atrtc_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|atrtc_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
operator|&
name|RTCIR_PERIOD
condition|)
block|{
name|flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|et
operator|.
name|et_active
condition|)
name|sc
operator|->
name|et
operator|.
name|et_event_cb
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|,
name|sc
operator|->
name|et
operator|.
name|et_arg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|flag
condition|?
name|FILTER_HANDLED
else|:
name|FILTER_STRAY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to the ISA PnP descriptors for the timer and realtime clock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|isa_pnp_id
name|atrtc_ids
index|[]
init|=
block|{
block|{
literal|0x000bd041
comment|/* PNP0B00 */
block|,
literal|"AT realtime clock"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|atrtc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
name|ISA_PNP_PROBE
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|,
name|atrtc_ids
argument_list|)
expr_stmt|;
comment|/* ENOENT means no PnP-ID, device is hinted. */
if|if
condition|(
name|result
operator|==
name|ENOENT
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"AT realtime clock"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_LOW_PRIORITY
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atrtc_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|atrtc_softc
modifier|*
name|sc
decl_stmt|;
name|rman_res_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|port_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
operator|&
name|sc
operator|->
name|port_rid
argument_list|,
name|IO_RTC
argument_list|,
name|IO_RTC
operator|+
literal|1
argument_list|,
literal|2
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|port_res
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Warning: Couldn't map I/O.\n"
argument_list|)
expr_stmt|;
name|atrtc_start
argument_list|()
expr_stmt|;
name|clock_register
argument_list|(
name|dev
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|eventtimer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|atrtcclock_disable
operator|&&
operator|(
name|resource_int_value
argument_list|(
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"clock"
argument_list|,
operator|&
name|i
argument_list|)
operator|!=
literal|0
operator|||
name|i
operator|!=
literal|0
operator|)
condition|)
block|{
name|sc
operator|->
name|intr_rid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bus_get_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|sc
operator|->
name|intr_rid
argument_list|,
operator|&
name|s
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
operator|&&
name|s
operator|!=
literal|8
condition|)
name|sc
operator|->
name|intr_rid
operator|++
expr_stmt|;
name|sc
operator|->
name|intr_res
operator|=
name|bus_alloc_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|sc
operator|->
name|intr_rid
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|intr_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't map interrupt.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
name|INTR_TYPE_CLK
argument_list|,
name|rtc_intr
argument_list|,
name|NULL
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|intr_handler
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Can't setup interrupt.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Bind IRQ to BSP to avoid live migration. */
name|bus_bind_intr
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|intr_res
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|et
operator|.
name|et_name
operator|=
literal|"RTC"
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_flags
operator|=
name|ET_FLAGS_PERIODIC
operator||
name|ET_FLAGS_POW2DIV
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_quality
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_frequency
operator|=
literal|32768
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_min_period
operator|=
literal|0x00080000
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_max_period
operator|=
literal|0x80000000
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_start
operator|=
name|rtc_start
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_stop
operator|=
name|rtc_stop
expr_stmt|;
name|sc
operator|->
name|et
operator|.
name|et_priv
operator|=
name|dev
expr_stmt|;
name|et_register
argument_list|(
operator|&
name|sc
operator|->
name|et
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atrtc_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|atrtc_restore
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atrtc_settime
parameter_list|(
name|device_t
name|dev
name|__unused
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|atrtc_set
argument_list|(
name|ts
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|atrtc_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|clocktime
name|ct
decl_stmt|;
comment|/* Look if we have a RTC present and the time is valid */
if|if
condition|(
operator|!
operator|(
name|rtcin
argument_list|(
name|RTC_STATUSD
argument_list|)
operator|&
name|RTCSD_PWR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"WARNING: Battery failure indication\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * wait for time update to complete 	 * If RTCSA_TUP is zero, we have at least 244us before next update. 	 * This is fast enough on most hardware, but a refinement would be 	 * to make sure that no more than 240us pass after we start reading, 	 * and try again if so. 	 */
name|mtx_lock
argument_list|(
operator|&
name|atrtc_time_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|rtcin
argument_list|(
name|RTC_STATUSA
argument_list|)
operator|&
name|RTCSA_TUP
condition|)
continue|continue;
name|critical_enter
argument_list|()
expr_stmt|;
name|ct
operator|.
name|nsec
operator|=
literal|0
expr_stmt|;
name|ct
operator|.
name|sec
operator|=
name|readrtc
argument_list|(
name|RTC_SEC
argument_list|)
expr_stmt|;
name|ct
operator|.
name|min
operator|=
name|readrtc
argument_list|(
name|RTC_MIN
argument_list|)
expr_stmt|;
name|ct
operator|.
name|hour
operator|=
name|readrtc
argument_list|(
name|RTC_HRS
argument_list|)
expr_stmt|;
name|ct
operator|.
name|day
operator|=
name|readrtc
argument_list|(
name|RTC_DAY
argument_list|)
expr_stmt|;
name|ct
operator|.
name|dow
operator|=
name|readrtc
argument_list|(
name|RTC_WDAY
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ct
operator|.
name|mon
operator|=
name|readrtc
argument_list|(
name|RTC_MONTH
argument_list|)
expr_stmt|;
name|ct
operator|.
name|year
operator|=
name|readrtc
argument_list|(
name|RTC_YEAR
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_RTC_CENTURY
name|ct
operator|.
name|year
operator|+=
name|readrtc
argument_list|(
name|RTC_CENTURY
argument_list|)
operator|*
literal|100
expr_stmt|;
else|#
directive|else
name|ct
operator|.
name|year
operator|+=
operator|(
name|ct
operator|.
name|year
operator|<
literal|80
condition|?
literal|2000
else|:
literal|1900
operator|)
expr_stmt|;
endif|#
directive|endif
name|critical_exit
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|atrtc_time_lock
argument_list|)
expr_stmt|;
comment|/* Set dow = -1 because some clocks don't set it correctly. */
name|ct
operator|.
name|dow
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|clock_ct_to_ts
argument_list|(
operator|&
name|ct
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|atrtc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|atrtc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|atrtc_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|bus_generic_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
comment|/* XXX stop statclock? */
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|atrtc_resume
argument_list|)
block|,
comment|/* clock interface */
name|DEVMETHOD
argument_list|(
name|clock_gettime
argument_list|,
name|atrtc_gettime
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_settime
argument_list|,
name|atrtc_settime
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|atrtc_driver
init|=
block|{
literal|"atrtc"
block|,
name|atrtc_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|atrtc_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|atrtc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atrtc
argument_list|,
name|isa
argument_list|,
name|atrtc_driver
argument_list|,
name|atrtc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|atrtc
argument_list|,
name|acpi
argument_list|,
name|atrtc_driver
argument_list|,
name|atrtc_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|rtc
argument_list|,
argument|rtc
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"%02x/%02x/%02x %02x:%02x:%02x, A = %02x, B = %02x, C = %02x\n"
argument_list|,
name|rtcin
argument_list|(
name|RTC_YEAR
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_MONTH
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_DAY
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_HRS
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_MIN
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_SEC
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_STATUSA
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_STATUSB
argument_list|)
argument_list|,
name|rtcin
argument_list|(
name|RTC_INTR
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

