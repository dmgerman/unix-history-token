begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Connection engine.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/iconv.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_subr.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_conn.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_tran.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_trantcp.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|smb_connobj
name|smb_vclist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smb_vcnext
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* next unique id for VC */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|linker_set
name|sysctl_net_smb
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|smb
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"SMB protocol"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SMBCONN
argument_list|,
literal|"SMB conn"
argument_list|,
literal|"SMB connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|smb_co_init
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|int
name|level
parameter_list|,
name|char
modifier|*
name|objname
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smb_co_done
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_co_lockstatus
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_vc_disconnect
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smb_vc_free
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smb_vc_gone
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|smb_co_free_t
name|smb_share_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|smb_co_gone_t
name|smb_share_gone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|smb_sysctl_treedump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_smb
argument_list|,
name|OID_AUTO
argument_list|,
name|treedump
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|smb_sysctl_treedump
argument_list|,
literal|"S,treedump"
argument_list|,
literal|"Requester tree"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|smb_sm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|smb_co_init
argument_list|(
operator|&
name|smb_vclist
argument_list|,
name|SMBL_SM
argument_list|,
literal|"smbsm"
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|smb_co_unlock
argument_list|(
operator|&
name|smb_vclist
argument_list|,
literal|0
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_sm_done
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* XXX: hold the mutex */
if|if
condition|(
name|smb_vclist
operator|.
name|co_usecount
operator|>
literal|1
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"%d connections still active\n"
argument_list|,
name|smb_vclist
operator|.
name|co_usecount
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|smb_co_done
argument_list|(
operator|&
name|smb_vclist
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_sm_lockvclist
parameter_list|(
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|smb_co_lock
argument_list|(
operator|&
name|smb_vclist
argument_list|,
name|flags
operator||
name|LK_CANRECURSE
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_sm_unlockvclist
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|smb_co_unlock
argument_list|(
operator|&
name|smb_vclist
argument_list|,
name|LK_RELEASE
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_sm_lookupint
parameter_list|(
name|struct
name|smb_vcspec
modifier|*
name|vcspec
parameter_list|,
name|struct
name|smb_sharespec
modifier|*
name|shspec
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_vc
modifier|*
modifier|*
name|vcpp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
decl_stmt|;
name|int
name|exact
init|=
literal|1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vcspec
operator|->
name|shspec
operator|=
name|shspec
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
name|SMBCO_FOREACH
argument_list|(
argument|(struct smb_connobj*)vcp
argument_list|,
argument|&smb_vclist
argument_list|)
block|{
name|error
operator|=
name|smb_vc_lock
argument_list|(
name|vcp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|itry
block|{
if|if
condition|(
operator|(
name|vcp
operator|->
name|obj
operator|.
name|co_flags
operator|&
name|SMBV_PRIVATE
operator|)
operator|||
operator|!
name|CONNADDREQ
argument_list|(
name|vcp
operator|->
name|vc_paddr
argument_list|,
name|vcspec
operator|->
name|sap
argument_list|)
operator|||
name|strcmp
argument_list|(
name|vcp
operator|->
name|vc_username
argument_list|,
name|vcspec
operator|->
name|username
argument_list|)
operator|!=
literal|0
condition|)
name|ithrow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcspec
operator|->
name|owner
operator|!=
name|SMBM_ANY_OWNER
condition|)
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_uid
operator|!=
name|vcspec
operator|->
name|owner
condition|)
name|ithrow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|exact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vcspec
operator|->
name|group
operator|!=
name|SMBM_ANY_GROUP
condition|)
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_grp
operator|!=
name|vcspec
operator|->
name|group
condition|)
name|ithrow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|exact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vcspec
operator|->
name|mode
operator|&
name|SMBM_EXACT
condition|)
block|{
if|if
condition|(
operator|!
name|exact
operator|||
operator|(
name|vcspec
operator|->
name|mode
operator|&
name|SMBM_MASK
operator|)
operator|!=
name|vcp
operator|->
name|vc_mode
condition|)
name|ithrow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smb_vc_access
argument_list|(
name|vcp
argument_list|,
name|scred
argument_list|,
name|vcspec
operator|->
name|mode
argument_list|)
operator|!=
literal|0
condition|)
name|ithrow
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|vcspec
operator|->
name|ssp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|shspec
condition|)
name|ithrow
argument_list|(
name|smb_vc_lookupshare
argument_list|(
name|vcp
argument_list|,
name|shspec
argument_list|,
name|scred
argument_list|,
operator|&
name|vcspec
operator|->
name|ssp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|icatch
argument_list|(
argument|error
argument_list|)
block|{
name|smb_vc_unlock
argument_list|(
name|vcp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|ifinally
block|{ 		}
name|iendtry
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|vcp
condition|)
block|{
name|smb_vc_ref
argument_list|(
name|vcp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|vcpp
operator|=
name|vcp
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|smb_sm_lookup
parameter_list|(
name|struct
name|smb_vcspec
modifier|*
name|vcspec
parameter_list|,
name|struct
name|smb_sharespec
modifier|*
name|shspec
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_vc
modifier|*
modifier|*
name|vcpp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|vcpp
operator|=
name|vcp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|smb_sm_lockvclist
argument_list|(
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smb_sm_lookupint
argument_list|(
name|vcspec
argument_list|,
name|shspec
argument_list|,
name|scred
argument_list|,
name|vcpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|||
operator|(
name|vcspec
operator|->
name|flags
operator|&
name|SMBV_CREATE
operator|)
operator|==
literal|0
condition|)
block|{
name|smb_sm_unlockvclist
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|error
operator|=
name|smb_sm_lookupint
argument_list|(
name|vcspec
argument_list|,
name|NULL
argument_list|,
name|scred
argument_list|,
operator|&
name|vcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|smb_vc_create
argument_list|(
name|vcspec
argument_list|,
name|scred
argument_list|,
operator|&
name|vcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|smb_vc_connect
argument_list|(
name|vcp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|shspec
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|smb_share_create
argument_list|(
name|vcp
argument_list|,
name|shspec
argument_list|,
name|scred
argument_list|,
operator|&
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|smb_smb_treeconnect
argument_list|(
name|ssp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vcspec
operator|->
name|ssp
operator|=
name|ssp
expr_stmt|;
else|else
name|smb_share_put
argument_list|(
name|ssp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
name|out
label|:
name|smb_sm_unlockvclist
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vcpp
operator|=
name|vcp
expr_stmt|;
elseif|else
if|if
condition|(
name|vcp
condition|)
name|smb_vc_put
argument_list|(
name|vcp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Common code for connection object  */
end_comment

begin_function
specifier|static
name|void
name|smb_co_init
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|int
name|level
parameter_list|,
name|char
modifier|*
name|objname
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|cp
operator|->
name|co_children
argument_list|)
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|cp
operator|->
name|co_interlock
argument_list|,
name|objname
argument_list|)
expr_stmt|;
name|lockinit
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|PZERO
argument_list|,
name|objname
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|co_level
operator|=
name|level
expr_stmt|;
name|cp
operator|->
name|co_usecount
operator|=
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
name|smb_co_lock
argument_list|(
name|cp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"smb_co_init: lock failed"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_co_done
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|)
block|{
name|smb_sl_destroy
argument_list|(
operator|&
name|cp
operator|->
name|co_interlock
argument_list|)
expr_stmt|;
name|lockdestroy
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_co_gone
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|struct
name|smb_connobj
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|cp
operator|->
name|co_gone
condition|)
name|cp
operator|->
name|co_gone
argument_list|(
name|cp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
name|parent
operator|=
name|cp
operator|->
name|co_parent
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|smb_co_lock
argument_list|(
name|parent
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|scred
operator|->
name|scr_p
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|parent
operator|->
name|co_children
argument_list|,
name|cp
argument_list|,
name|smb_connobj
argument_list|,
name|co_next
argument_list|)
expr_stmt|;
name|smb_co_put
argument_list|(
name|parent
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|co_free
condition|)
name|cp
operator|->
name|co_free
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_co_ref
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|SMB_CO_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|co_usecount
operator|++
expr_stmt|;
name|SMB_CO_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_co_rele
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|SMB_CO_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|co_usecount
operator|>
literal|1
condition|)
block|{
name|cp
operator|->
name|co_usecount
operator|--
expr_stmt|;
name|SMB_CO_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cp
operator|->
name|co_usecount
operator|==
literal|0
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"negative use_count for object %d"
argument_list|,
name|cp
operator|->
name|co_level
argument_list|)
expr_stmt|;
name|SMB_CO_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
name|cp
operator|->
name|co_usecount
operator|--
expr_stmt|;
name|cp
operator|->
name|co_flags
operator||=
name|SMBO_GONE
expr_stmt|;
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|LK_DRAIN
operator||
name|LK_INTERLOCK
argument_list|,
operator|&
name|cp
operator|->
name|co_interlock
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|smb_co_gone
argument_list|(
name|cp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_co_get
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_INTERLOCK
operator|)
operator|==
literal|0
condition|)
name|SMB_CO_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|co_usecount
operator|++
expr_stmt|;
name|error
operator|=
name|smb_co_lock
argument_list|(
name|cp
argument_list|,
name|flags
operator||
name|LK_INTERLOCK
argument_list|,
name|scred
operator|->
name|scr_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SMB_CO_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|co_usecount
operator|--
expr_stmt|;
name|SMB_CO_UNLOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|smb_co_put
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|LK_RELEASE
expr_stmt|;
name|SMB_CO_LOCK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|co_usecount
operator|>
literal|1
condition|)
block|{
name|cp
operator|->
name|co_usecount
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|co_usecount
operator|==
literal|1
condition|)
block|{
name|cp
operator|->
name|co_usecount
operator|--
expr_stmt|;
name|cp
operator|->
name|co_flags
operator||=
name|SMBO_GONE
expr_stmt|;
name|flags
operator|=
name|LK_DRAIN
expr_stmt|;
block|}
else|else
block|{
name|SMBERROR
argument_list|(
literal|"negative usecount"
argument_list|)
expr_stmt|;
block|}
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|LK_RELEASE
operator||
name|LK_INTERLOCK
argument_list|,
operator|&
name|cp
operator|->
name|co_interlock
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|->
name|co_flags
operator|&
name|SMBO_GONE
operator|)
operator|==
literal|0
condition|)
return|return;
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|LK_DRAIN
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|smb_co_gone
argument_list|(
name|cp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_co_lockstatus
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|lockstatus
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|smb_co_lock
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|co_flags
operator|&
name|SMBO_GONE
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LK_TYPE_MASK
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|LK_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|smb_co_lockstatus
argument_list|(
name|cp
argument_list|,
name|p
argument_list|)
operator|==
name|LK_EXCLUSIVE
operator|&&
operator|(
name|flags
operator|&
name|LK_CANRECURSE
operator|)
operator|==
literal|0
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"recursive lock for object %d\n"
argument_list|,
name|cp
operator|->
name|co_level
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|flags
argument_list|,
operator|&
name|cp
operator|->
name|co_interlock
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|smb_co_unlock
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
operator|(
name|void
operator|)
name|lockmgr
argument_list|(
operator|&
name|cp
operator|->
name|co_lock
argument_list|,
name|flags
operator||
name|LK_RELEASE
argument_list|,
operator|&
name|cp
operator|->
name|co_interlock
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_co_addchild
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|parent
parameter_list|,
name|struct
name|smb_connobj
modifier|*
name|child
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|smb_co_lockstatus
argument_list|(
name|parent
argument_list|,
name|curproc
argument_list|)
operator|==
name|LK_EXCLUSIVE
argument_list|,
operator|(
literal|"smb_co_addchild: parent not locked"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|smb_co_lockstatus
argument_list|(
name|child
argument_list|,
name|curproc
argument_list|)
operator|==
name|LK_EXCLUSIVE
argument_list|,
operator|(
literal|"smb_co_addchild: child not locked"
operator|)
argument_list|)
expr_stmt|;
name|smb_co_ref
argument_list|(
name|parent
argument_list|,
name|curproc
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|co_children
argument_list|,
name|child
argument_list|,
name|co_next
argument_list|)
expr_stmt|;
name|child
operator|->
name|co_parent
operator|=
name|parent
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Session implementation  */
end_comment

begin_function
name|int
name|smb_vc_create
parameter_list|(
name|struct
name|smb_vcspec
modifier|*
name|vcspec
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_vc
modifier|*
modifier|*
name|vcpp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|scred
operator|->
name|scr_cred
decl_stmt|;
name|uid_t
name|uid
init|=
name|vcspec
operator|->
name|owner
decl_stmt|;
name|gid_t
name|gid
init|=
name|vcspec
operator|->
name|group
decl_stmt|;
name|uid_t
name|realuid
init|=
name|cred
operator|->
name|cr_uid
decl_stmt|;
name|char
modifier|*
name|domain
init|=
name|vcspec
operator|->
name|domain
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isroot
decl_stmt|;
name|isroot
operator|=
name|smb_suser
argument_list|(
name|cred
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Only superuser can create VCs with different uid and gid 	 */
if|if
condition|(
name|uid
operator|!=
name|SMBM_ANY_OWNER
operator|&&
name|uid
operator|!=
name|realuid
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|gid
operator|!=
name|SMBM_ANY_GROUP
operator|&&
operator|!
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cred
argument_list|)
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
name|vcp
operator|=
name|smb_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vcp
argument_list|)
argument_list|,
name|M_SMBCONN
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|smb_co_init
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|SMBL_VC
argument_list|,
literal|"smb_vc"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|obj
operator|.
name|co_free
operator|=
name|smb_vc_free
expr_stmt|;
name|vcp
operator|->
name|obj
operator|.
name|co_gone
operator|=
name|smb_vc_gone
expr_stmt|;
name|vcp
operator|->
name|vc_number
operator|=
name|smb_vcnext
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_timo
operator|=
name|SMB_DEFRQTIMO
expr_stmt|;
name|vcp
operator|->
name|vc_smbuid
operator|=
name|SMB_UID_UNKNOWN
expr_stmt|;
name|vcp
operator|->
name|vc_mode
operator|=
name|vcspec
operator|->
name|rights
operator|&
name|SMBM_MASK
expr_stmt|;
name|vcp
operator|->
name|obj
operator|.
name|co_flags
operator|=
name|vcspec
operator|->
name|flags
operator|&
operator|(
name|SMBV_PRIVATE
operator||
name|SMBV_SINGLESHARE
operator|)
expr_stmt|;
name|vcp
operator|->
name|vc_tdesc
operator|=
operator|&
name|smb_tran_nbtcp_desc
expr_stmt|;
if|if
condition|(
name|uid
operator|==
name|SMBM_ANY_OWNER
condition|)
name|uid
operator|=
name|realuid
expr_stmt|;
if|if
condition|(
name|gid
operator|==
name|SMBM_ANY_GROUP
condition|)
name|gid
operator|=
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|vcp
operator|->
name|vc_uid
operator|=
name|uid
expr_stmt|;
name|vcp
operator|->
name|vc_grp
operator|=
name|gid
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|vcp
operator|->
name|vc_stlock
argument_list|,
literal|"vcstlock"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|itry
block|{
name|vcp
operator|->
name|vc_paddr
operator|=
name|dup_sockaddr
argument_list|(
name|vcspec
operator|->
name|sap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
name|vcp
operator|->
name|vc_paddr
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|vc_laddr
operator|=
name|dup_sockaddr
argument_list|(
name|vcspec
operator|->
name|lap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
name|vcp
operator|->
name|vc_laddr
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
operator|(
name|vcp
operator|->
name|vc_pass
operator|=
name|smb_strdup
argument_list|(
name|vcspec
operator|->
name|pass
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|vc_domain
operator|=
name|smb_strdup
argument_list|(
operator|(
name|domain
operator|&&
name|domain
index|[
literal|0
index|]
operator|)
condition|?
name|domain
else|:
literal|"NODOMAIN"
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
name|vcp
operator|->
name|vc_domain
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
operator|(
name|vcp
operator|->
name|vc_srvname
operator|=
name|smb_strdup
argument_list|(
name|vcspec
operator|->
name|srvname
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|ierror
argument_list|(
operator|(
name|vcp
operator|->
name|vc_username
operator|=
name|smb_strdup
argument_list|(
name|vcspec
operator|->
name|username
argument_list|)
operator|)
operator|==
name|NULL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|ithrow
argument_list|(
name|iconv_open
argument_list|(
literal|"tolower"
argument_list|,
name|vcspec
operator|->
name|localcs
argument_list|,
operator|&
name|vcp
operator|->
name|vc_tolower
argument_list|)
argument_list|)
expr_stmt|;
name|ithrow
argument_list|(
name|iconv_open
argument_list|(
literal|"toupper"
argument_list|,
name|vcspec
operator|->
name|localcs
argument_list|,
operator|&
name|vcp
operator|->
name|vc_toupper
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcspec
operator|->
name|servercs
index|[
literal|0
index|]
condition|)
block|{
name|ithrow
argument_list|(
name|iconv_open
argument_list|(
name|vcspec
operator|->
name|servercs
argument_list|,
name|vcspec
operator|->
name|localcs
argument_list|,
operator|&
name|vcp
operator|->
name|vc_toserver
argument_list|)
argument_list|)
expr_stmt|;
name|ithrow
argument_list|(
name|iconv_open
argument_list|(
name|vcspec
operator|->
name|localcs
argument_list|,
name|vcspec
operator|->
name|servercs
argument_list|,
operator|&
name|vcp
operator|->
name|vc_tolocal
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ithrow
argument_list|(
name|smb_iod_create
argument_list|(
name|vcp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vcpp
operator|=
name|vcp
expr_stmt|;
name|smb_co_addchild
argument_list|(
operator|&
name|smb_vclist
argument_list|,
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|icatch
argument_list|(
argument|error
argument_list|)
block|{
name|smb_vc_put
argument_list|(
name|vcp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
name|ifinally
block|{ 	}
name|iendtry
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_vc_free
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|CPTOVC
argument_list|(
name|cp
argument_list|)
decl_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_iod
condition|)
name|smb_iod_destroy
argument_list|(
name|vcp
operator|->
name|vc_iod
argument_list|)
expr_stmt|;
name|SMB_STRFREE
argument_list|(
name|vcp
operator|->
name|vc_username
argument_list|)
expr_stmt|;
name|SMB_STRFREE
argument_list|(
name|vcp
operator|->
name|vc_srvname
argument_list|)
expr_stmt|;
name|SMB_STRFREE
argument_list|(
name|vcp
operator|->
name|vc_pass
argument_list|)
expr_stmt|;
name|SMB_STRFREE
argument_list|(
name|vcp
operator|->
name|vc_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_paddr
condition|)
name|free
argument_list|(
name|vcp
operator|->
name|vc_paddr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_laddr
condition|)
name|free
argument_list|(
name|vcp
operator|->
name|vc_laddr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_tolower
condition|)
name|iconv_close
argument_list|(
name|vcp
operator|->
name|vc_tolower
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_toupper
condition|)
name|iconv_close
argument_list|(
name|vcp
operator|->
name|vc_toupper
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_tolocal
condition|)
name|iconv_close
argument_list|(
name|vcp
operator|->
name|vc_tolocal
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_toserver
condition|)
name|iconv_close
argument_list|(
name|vcp
operator|->
name|vc_toserver
argument_list|)
expr_stmt|;
name|smb_co_done
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|)
expr_stmt|;
name|smb_sl_destroy
argument_list|(
operator|&
name|vcp
operator|->
name|vc_stlock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vcp
argument_list|,
name|M_SMBCONN
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when use count of VC dropped to zero.  * VC should be locked on enter with LK_DRAIN.  */
end_comment

begin_function
specifier|static
name|void
name|smb_vc_gone
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|CPTOVC
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|smb_vc_disconnect
argument_list|(
name|vcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_vc_ref
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|smb_co_ref
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_vc_rele
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|smb_co_rele
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_vc_get
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
return|return
name|smb_co_get
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|scred
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|smb_vc_put
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|smb_co_put
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_vc_lock
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|smb_co_lock
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|smb_vc_unlock
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|smb_co_unlock
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_vc_access
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
init|=
name|scred
operator|->
name|scr_cred
decl_stmt|;
if|if
condition|(
name|smb_suser
argument_list|(
name|cred
argument_list|)
operator|==
literal|0
operator|||
name|cred
operator|->
name|cr_uid
operator|==
name|vcp
operator|->
name|vc_uid
condition|)
return|return
literal|0
return|;
name|mode
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|vcp
operator|->
name|vc_grp
argument_list|,
name|cred
argument_list|)
condition|)
name|mode
operator|>>=
literal|3
expr_stmt|;
return|return
operator|(
name|vcp
operator|->
name|vc_mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_vc_cmpshare
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|smb_sharespec
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|exact
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ssp
operator|->
name|ss_name
argument_list|,
name|dp
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|dp
operator|->
name|owner
operator|!=
name|SMBM_ANY_OWNER
condition|)
block|{
if|if
condition|(
name|ssp
operator|->
name|ss_uid
operator|!=
name|dp
operator|->
name|owner
condition|)
return|return
literal|1
return|;
block|}
else|else
name|exact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|group
operator|!=
name|SMBM_ANY_GROUP
condition|)
block|{
if|if
condition|(
name|ssp
operator|->
name|ss_grp
operator|!=
name|dp
operator|->
name|group
condition|)
return|return
literal|1
return|;
block|}
else|else
name|exact
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|mode
operator|&
name|SMBM_EXACT
condition|)
block|{
if|if
condition|(
operator|!
name|exact
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|dp
operator|->
name|mode
operator|&
name|SMBM_MASK
operator|)
operator|==
name|ssp
operator|->
name|ss_mode
condition|?
literal|0
else|:
literal|1
return|;
block|}
if|if
condition|(
name|smb_share_access
argument_list|(
name|ssp
argument_list|,
name|dp
operator|->
name|scred
argument_list|,
name|dp
operator|->
name|mode
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup share in the given VC. Share referenced and locked on return.  * VC expected to be locked on entry and will be left locked on exit.  */
end_comment

begin_function
name|int
name|smb_vc_lookupshare
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_sharespec
modifier|*
name|dp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_share
modifier|*
modifier|*
name|sspp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|sspp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|->
name|scred
operator|=
name|scred
expr_stmt|;
name|SMBCO_FOREACH
argument_list|(
argument|(struct smb_connobj*)ssp
argument_list|,
argument|VCTOCP(vcp)
argument_list|)
block|{
name|error
operator|=
name|smb_share_lock
argument_list|(
name|ssp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
if|if
condition|(
name|smb_vc_cmpshare
argument_list|(
name|ssp
argument_list|,
name|dp
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|smb_share_unlock
argument_list|(
name|ssp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssp
condition|)
block|{
name|smb_share_ref
argument_list|(
name|ssp
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|sspp
operator|=
name|ssp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|smb_vc_connect
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
return|return
name|smb_iod_request
argument_list|(
name|vcp
operator|->
name|vc_iod
argument_list|,
name|SMBIOD_EV_CONNECT
operator||
name|SMBIOD_EV_SYNC
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy VC to server, invalidate shares linked with it.  * Transport should be locked on entry.  */
end_comment

begin_function
name|int
name|smb_vc_disconnect
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|)
block|{
name|smb_iod_request
argument_list|(
name|vcp
operator|->
name|vc_iod
argument_list|,
name|SMBIOD_EV_DISCONNECT
operator||
name|SMBIOD_EV_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|smb_emptypass
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|smb_vc_getpass
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|)
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_pass
condition|)
return|return
name|vcp
operator|->
name|vc_pass
return|;
return|return
name|smb_emptypass
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_vc_getinfo
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_vc_info
modifier|*
name|vip
parameter_list|)
block|{
name|bzero
argument_list|(
name|vip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|smb_vc_info
argument_list|)
argument_list|)
expr_stmt|;
name|vip
operator|->
name|itype
operator|=
name|SMB_INFO_VC
expr_stmt|;
name|vip
operator|->
name|usecount
operator|=
name|vcp
operator|->
name|obj
operator|.
name|co_usecount
expr_stmt|;
name|vip
operator|->
name|uid
operator|=
name|vcp
operator|->
name|vc_uid
expr_stmt|;
name|vip
operator|->
name|gid
operator|=
name|vcp
operator|->
name|vc_grp
expr_stmt|;
name|vip
operator|->
name|mode
operator|=
name|vcp
operator|->
name|vc_mode
expr_stmt|;
name|vip
operator|->
name|flags
operator|=
name|vcp
operator|->
name|obj
operator|.
name|co_flags
expr_stmt|;
name|vip
operator|->
name|sopt
operator|=
name|vcp
operator|->
name|vc_sopt
expr_stmt|;
name|vip
operator|->
name|iodstate
operator|=
name|vcp
operator|->
name|vc_iod
operator|->
name|iod_state
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vip
operator|->
name|sopt
operator|.
name|sv_skey
argument_list|,
sizeof|sizeof
argument_list|(
name|vip
operator|->
name|sopt
operator|.
name|sv_skey
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|vip
operator|->
name|srvname
argument_list|,
sizeof|sizeof
argument_list|(
name|vip
operator|->
name|srvname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|vcp
operator|->
name|vc_srvname
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|vip
operator|->
name|vcname
argument_list|,
sizeof|sizeof
argument_list|(
name|vip
operator|->
name|vcname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|vcp
operator|->
name|vc_username
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|u_short
name|smb_vc_nextmid
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|)
block|{
name|u_short
name|r
decl_stmt|;
name|SMB_CO_LOCK
argument_list|(
operator|&
name|vcp
operator|->
name|obj
argument_list|)
expr_stmt|;
name|r
operator|=
name|vcp
operator|->
name|vc_mid
operator|++
expr_stmt|;
name|SMB_CO_UNLOCK
argument_list|(
operator|&
name|vcp
operator|->
name|obj
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Share implementation  */
end_comment

begin_comment
comment|/*  * Allocate share structure and attach it to the given VC  * Connection expected to be locked on entry. Share will be returned  * in locked state.  */
end_comment

begin_function
name|int
name|smb_share_create
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|,
name|struct
name|smb_sharespec
modifier|*
name|shspec
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_share
modifier|*
modifier|*
name|sspp
parameter_list|)
block|{
name|struct
name|smb_share
modifier|*
name|ssp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|scred
operator|->
name|scr_p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|scred
operator|->
name|scr_cred
decl_stmt|;
name|uid_t
name|realuid
init|=
name|cred
operator|->
name|cr_uid
decl_stmt|;
name|uid_t
name|uid
init|=
name|shspec
operator|->
name|owner
decl_stmt|;
name|gid_t
name|gid
init|=
name|shspec
operator|->
name|group
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isroot
decl_stmt|;
name|isroot
operator|=
name|smb_suser
argument_list|(
name|cred
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Only superuser can create shares with different uid and gid 	 */
if|if
condition|(
name|uid
operator|!=
name|SMBM_ANY_OWNER
operator|&&
name|uid
operator|!=
name|realuid
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|gid
operator|!=
name|SMBM_ANY_GROUP
operator|&&
operator|!
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cred
argument_list|)
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
name|smb_vc_lookupshare
argument_list|(
name|vcp
argument_list|,
name|shspec
argument_list|,
name|scred
argument_list|,
operator|&
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|smb_share_put
argument_list|(
name|ssp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
return|return
name|EEXIST
return|;
block|}
if|if
condition|(
name|uid
operator|==
name|SMBM_ANY_OWNER
condition|)
name|uid
operator|=
name|realuid
expr_stmt|;
if|if
condition|(
name|gid
operator|==
name|SMBM_ANY_GROUP
condition|)
name|gid
operator|=
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
name|ssp
operator|=
name|smb_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ssp
argument_list|)
argument_list|,
name|M_SMBCONN
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|smb_co_init
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|SMBL_SHARE
argument_list|,
literal|"smbss"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|obj
operator|.
name|co_free
operator|=
name|smb_share_free
expr_stmt|;
name|ssp
operator|->
name|obj
operator|.
name|co_gone
operator|=
name|smb_share_gone
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|ssp
operator|->
name|ss_stlock
argument_list|,
literal|"ssstlock"
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_name
operator|=
name|smb_strdup
argument_list|(
name|shspec
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|shspec
operator|->
name|pass
operator|&&
name|shspec
operator|->
name|pass
index|[
literal|0
index|]
condition|)
name|ssp
operator|->
name|ss_pass
operator|=
name|smb_strdup
argument_list|(
name|shspec
operator|->
name|pass
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_type
operator|=
name|shspec
operator|->
name|stype
expr_stmt|;
name|ssp
operator|->
name|ss_tid
operator|=
name|SMB_TID_UNKNOWN
expr_stmt|;
name|ssp
operator|->
name|ss_uid
operator|=
name|uid
expr_stmt|;
name|ssp
operator|->
name|ss_grp
operator|=
name|gid
expr_stmt|;
name|ssp
operator|->
name|ss_mode
operator|=
name|shspec
operator|->
name|rights
operator|&
name|SMBM_MASK
expr_stmt|;
name|smb_co_addchild
argument_list|(
name|VCTOCP
argument_list|(
name|vcp
argument_list|)
argument_list|,
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sspp
operator|=
name|ssp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_share_free
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|CPTOSS
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|SMB_STRFREE
argument_list|(
name|ssp
operator|->
name|ss_name
argument_list|)
expr_stmt|;
name|SMB_STRFREE
argument_list|(
name|ssp
operator|->
name|ss_pass
argument_list|)
expr_stmt|;
name|smb_sl_destroy
argument_list|(
operator|&
name|ssp
operator|->
name|ss_stlock
argument_list|)
expr_stmt|;
name|smb_co_done
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ssp
argument_list|,
name|M_SMBCONN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_share_gone
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|cp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|CPTOSS
argument_list|(
name|cp
argument_list|)
decl_stmt|;
name|smb_smb_treedisconnect
argument_list|(
name|ssp
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_share_ref
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|smb_co_ref
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_share_rele
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|smb_co_rele
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_share_get
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
return|return
name|smb_co_get
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|scred
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|smb_share_put
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|smb_co_put
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|scred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_share_lock
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|smb_co_lock
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|smb_share_unlock
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|smb_co_unlock
argument_list|(
name|SSTOCP
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_share_access
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
init|=
name|scred
operator|->
name|scr_cred
decl_stmt|;
if|if
condition|(
name|smb_suser
argument_list|(
name|cred
argument_list|)
operator|==
literal|0
operator|||
name|cred
operator|->
name|cr_uid
operator|==
name|ssp
operator|->
name|ss_uid
condition|)
return|return
literal|0
return|;
name|mode
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|ssp
operator|->
name|ss_grp
argument_list|,
name|cred
argument_list|)
condition|)
name|mode
operator|>>=
literal|3
expr_stmt|;
return|return
operator|(
name|ssp
operator|->
name|ss_mode
operator|&
name|mode
operator|)
operator|==
name|mode
condition|?
literal|0
else|:
name|EACCES
return|;
block|}
end_function

begin_function
name|void
name|smb_share_invalidate
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|)
block|{
name|ssp
operator|->
name|ss_tid
operator|=
name|SMB_TID_UNKNOWN
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_share_valid
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|)
block|{
return|return
name|ssp
operator|->
name|ss_tid
operator|!=
name|SMB_TID_UNKNOWN
operator|&&
name|ssp
operator|->
name|ss_vcgenid
operator|==
name|SSTOVC
argument_list|(
name|ssp
argument_list|)
operator|->
name|vc_genid
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|smb_share_getpass
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
decl_stmt|;
if|if
condition|(
name|ssp
operator|->
name|ss_pass
condition|)
return|return
name|ssp
operator|->
name|ss_pass
return|;
name|vcp
operator|=
name|SSTOVC
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_pass
condition|)
return|return
name|vcp
operator|->
name|vc_pass
return|;
return|return
name|smb_emptypass
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_share_getinfo
parameter_list|(
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|,
name|struct
name|smb_share_info
modifier|*
name|sip
parameter_list|)
block|{
name|bzero
argument_list|(
name|sip
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|smb_share_info
argument_list|)
argument_list|)
expr_stmt|;
name|sip
operator|->
name|itype
operator|=
name|SMB_INFO_SHARE
expr_stmt|;
name|sip
operator|->
name|usecount
operator|=
name|ssp
operator|->
name|obj
operator|.
name|co_usecount
expr_stmt|;
name|sip
operator|->
name|tid
operator|=
name|ssp
operator|->
name|ss_tid
expr_stmt|;
name|sip
operator|->
name|type
operator|=
name|ssp
operator|->
name|ss_type
expr_stmt|;
name|sip
operator|->
name|uid
operator|=
name|ssp
operator|->
name|ss_uid
expr_stmt|;
name|sip
operator|->
name|gid
operator|=
name|ssp
operator|->
name|ss_grp
expr_stmt|;
name|sip
operator|->
name|mode
operator|=
name|ssp
operator|->
name|ss_mode
expr_stmt|;
name|sip
operator|->
name|flags
operator|=
name|ssp
operator|->
name|obj
operator|.
name|co_flags
expr_stmt|;
name|snprintf
argument_list|(
name|sip
operator|->
name|sname
argument_list|,
sizeof|sizeof
argument_list|(
name|sip
operator|->
name|sname
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|ssp
operator|->
name|ss_name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Dump an entire tree into sysctl call  */
end_comment

begin_function
specifier|static
name|int
name|smb_sysctl_treedump
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|req
operator|->
name|p
decl_stmt|;
name|struct
name|smb_cred
name|scred
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
decl_stmt|;
name|struct
name|smb_vc_info
name|vci
decl_stmt|;
name|struct
name|smb_share_info
name|ssi
decl_stmt|;
name|int
name|error
decl_stmt|,
name|itype
decl_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|scred
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_sm_lockvclist
argument_list|(
name|LK_SHARED
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|SMBCO_FOREACH
argument_list|(
argument|(struct smb_connobj*)vcp
argument_list|,
argument|&smb_vclist
argument_list|)
block|{
name|error
operator|=
name|smb_vc_lock
argument_list|(
name|vcp
argument_list|,
name|LK_SHARED
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|smb_vc_getinfo
argument_list|(
name|vcp
argument_list|,
operator|&
name|vci
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|vci
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|smb_vc_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|smb_vc_unlock
argument_list|(
name|vcp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|SMBCO_FOREACH
argument_list|(
argument|(struct smb_connobj*)ssp
argument_list|,
argument|VCTOCP(vcp)
argument_list|)
block|{
name|error
operator|=
name|smb_share_lock
argument_list|(
name|ssp
argument_list|,
name|LK_SHARED
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|smb_share_getinfo
argument_list|(
name|ssp
argument_list|,
operator|&
name|ssi
argument_list|)
expr_stmt|;
name|smb_share_unlock
argument_list|(
name|ssp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|ssi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|smb_share_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|smb_vc_unlock
argument_list|(
name|vcp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|itype
operator|=
name|SMB_INFO_NONE
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|itype
argument_list|,
sizeof|sizeof
argument_list|(
name|itype
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|smb_sm_unlockvclist
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

