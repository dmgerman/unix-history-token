begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001 Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_conn.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_rq.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_tran.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_trantcp.h>
end_include

begin_define
define|#
directive|define
name|SMBIOD_SLEEP_TIMO
value|2
end_define

begin_define
define|#
directive|define
name|SMBIOD_PING_TIMO
value|60
end_define

begin_comment
comment|/* seconds */
end_comment

begin_define
define|#
directive|define
name|SMB_IOD_EVLOCKPTR
parameter_list|(
name|iod
parameter_list|)
value|(&((iod)->iod_evlock))
end_define

begin_define
define|#
directive|define
name|SMB_IOD_EVLOCK
parameter_list|(
name|iod
parameter_list|)
value|smb_sl_lock(&((iod)->iod_evlock))
end_define

begin_define
define|#
directive|define
name|SMB_IOD_EVUNLOCK
parameter_list|(
name|iod
parameter_list|)
value|smb_sl_unlock(&((iod)->iod_evlock))
end_define

begin_define
define|#
directive|define
name|SMB_IOD_RQLOCKPTR
parameter_list|(
name|iod
parameter_list|)
value|(&((iod)->iod_rqlock))
end_define

begin_define
define|#
directive|define
name|SMB_IOD_RQLOCK
parameter_list|(
name|iod
parameter_list|)
value|smb_sl_lock(&((iod)->iod_rqlock))
end_define

begin_define
define|#
directive|define
name|SMB_IOD_RQUNLOCK
parameter_list|(
name|iod
parameter_list|)
value|smb_sl_unlock(&((iod)->iod_rqlock))
end_define

begin_define
define|#
directive|define
name|smb_iod_wakeup
parameter_list|(
name|iod
parameter_list|)
value|wakeup(&(iod)->iod_flags)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SMBIOD
argument_list|,
literal|"SMBIOD"
argument_list|,
literal|"SMB network io daemon"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|smb_iod_next
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|smb_iod_sendall
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_iod_disconnect
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|smb_iod_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|void
name|smb_iod_rqprocessed
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|SMBRQ_SLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_lerror
operator|=
name|error
expr_stmt|;
name|rqp
operator|->
name|sr_rpgen
operator|++
expr_stmt|;
name|rqp
operator|->
name|sr_state
operator|=
name|SMBRQ_NOTIFIED
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|rqp
operator|->
name|sr_state
argument_list|)
expr_stmt|;
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_iod_invrq
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_rq
modifier|*
name|rqp
decl_stmt|;
comment|/*          * Invalidate all outstanding requests for this connection 	 */
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rqp
argument_list|,
argument|&iod->iod_rqlist
argument_list|,
argument|sr_link
argument_list|)
block|{
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_INTERNAL
condition|)
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_RESTART
expr_stmt|;
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
block|}
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_iod_closetran
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|iod
operator|->
name|iod_p
decl_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_tdata
operator|==
name|NULL
condition|)
return|return;
name|SMB_TRAN_DISCONNECT
argument_list|(
name|vcp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|SMB_TRAN_DONE
argument_list|(
name|vcp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|vc_tdata
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|smb_iod_dead
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_DEAD
expr_stmt|;
name|smb_iod_closetran
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|smb_iod_invrq
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_iod_connect
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|iod
operator|->
name|iod_p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"%d\n"
argument_list|,
name|iod
operator|->
name|iod_state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iod
operator|->
name|iod_state
condition|)
block|{
case|case
name|SMBIOD_ST_VCACTIVE
case|:
name|SMBERROR
argument_list|(
literal|"called for already opened connection\n"
argument_list|)
expr_stmt|;
return|return
name|EISCONN
return|;
case|case
name|SMBIOD_ST_DEAD
case|:
return|return
name|ENOTCONN
return|;
comment|/* XXX: last error code ? */
default|default:
break|break;
block|}
name|vcp
operator|->
name|vc_genid
operator|++
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|itry
block|{
name|ithrow
argument_list|(
name|SMB_TRAN_CREATE
argument_list|(
name|vcp
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"tcreate\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_laddr
condition|)
block|{
name|ithrow
argument_list|(
name|SMB_TRAN_BIND
argument_list|(
name|vcp
argument_list|,
name|vcp
operator|->
name|vc_laddr
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SMBIODEBUG
argument_list|(
literal|"tbind\n"
argument_list|)
expr_stmt|;
name|ithrow
argument_list|(
name|SMB_TRAN_CONNECT
argument_list|(
name|vcp
argument_list|,
name|vcp
operator|->
name|vc_paddr
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|SMB_TRAN_SETPARAM
argument_list|(
name|vcp
argument_list|,
name|SMBTP_SELECTID
argument_list|,
operator|&
name|iod
operator|->
name|iod_flags
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_TRANACTIVE
expr_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"tconnect\n"
argument_list|)
expr_stmt|;
comment|/*		vcp->vc_mid = 0;*/
name|ithrow
argument_list|(
name|smb_smb_negotiate
argument_list|(
name|vcp
argument_list|,
operator|&
name|iod
operator|->
name|iod_scred
argument_list|)
argument_list|)
expr_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"snegotiate\n"
argument_list|)
expr_stmt|;
name|ithrow
argument_list|(
name|smb_smb_ssnsetup
argument_list|(
name|vcp
argument_list|,
operator|&
name|iod
operator|->
name|iod_scred
argument_list|)
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_VCACTIVE
expr_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"completed\n"
argument_list|)
expr_stmt|;
name|smb_iod_invrq
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
name|icatch
argument_list|(
argument|error
argument_list|)
block|{
name|smb_iod_dead
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
name|ifinally
block|{ 	}
name|iendtry
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_iod_disconnect
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iod
operator|->
name|iod_state
operator|==
name|SMBIOD_ST_VCACTIVE
condition|)
block|{
name|smb_smb_ssnclose
argument_list|(
name|vcp
argument_list|,
operator|&
name|iod
operator|->
name|iod_scred
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_TRANACTIVE
expr_stmt|;
block|}
name|vcp
operator|->
name|vc_smbuid
operator|=
name|SMB_UID_UNKNOWN
expr_stmt|;
name|smb_iod_closetran
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_NOTCONN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_iod_treeconnect
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|,
name|struct
name|smb_share
modifier|*
name|ssp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|iod
operator|->
name|iod_state
operator|!=
name|SMBIOD_ST_VCACTIVE
condition|)
block|{
if|if
condition|(
name|iod
operator|->
name|iod_state
operator|!=
name|SMBIOD_ST_DEAD
condition|)
return|return
name|ENOTCONN
return|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_RECONNECT
expr_stmt|;
name|error
operator|=
name|smb_iod_connect
argument_list|(
name|iod
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|SMBIODEBUG
argument_list|(
literal|"tree reconnect\n"
argument_list|)
expr_stmt|;
name|SMBS_ST_LOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_flags
operator||=
name|SMBS_RECONNECTING
expr_stmt|;
name|SMBS_ST_UNLOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_smb_treeconnect
argument_list|(
name|ssp
argument_list|,
operator|&
name|iod
operator|->
name|iod_scred
argument_list|)
expr_stmt|;
name|SMBS_ST_LOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
name|ssp
operator|->
name|ss_flags
operator|&=
operator|~
name|SMBS_RECONNECTING
expr_stmt|;
name|SMBS_ST_UNLOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ssp
operator|->
name|ss_vcgenid
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_iod_sendrq
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|,
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|iod
operator|->
name|iod_p
decl_stmt|;
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|rqp
operator|->
name|sr_share
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"iod_state = %d\n"
argument_list|,
name|iod
operator|->
name|iod_state
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iod
operator|->
name|iod_state
condition|)
block|{
case|case
name|SMBIOD_ST_NOTCONN
case|:
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SMBIOD_ST_DEAD
case|:
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_RECONNECT
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SMBIOD_ST_RECONNECT
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|rqp
operator|->
name|sr_sendcnt
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|movedtoanotherplace
if|if
condition|(
name|vcp
operator|->
name|vc_maxmux
operator|!=
literal|0
operator|&&
name|iod
operator|->
name|iod_muxcnt
operator|>=
name|vcp
operator|->
name|vc_maxmux
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
operator|*
name|rqp
operator|->
name|sr_rqtid
operator|=
name|htoles
argument_list|(
name|ssp
condition|?
name|ssp
operator|->
name|ss_tid
else|:
name|SMB_TID_UNKNOWN
argument_list|)
expr_stmt|;
operator|*
name|rqp
operator|->
name|sr_rquid
operator|=
name|htoles
argument_list|(
name|vcp
condition|?
name|vcp
operator|->
name|vc_smbuid
else|:
literal|0
argument_list|)
expr_stmt|;
name|mb_fixhdr
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rqp
operator|->
name|sr_sendcnt
operator|++
operator|>
literal|5
condition|)
block|{
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_RESTART
expr_stmt|;
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|rqp
operator|->
name|sr_lerror
argument_list|)
expr_stmt|;
comment|/* 		 * If all attempts to send a request failed, then 		 * something is seriously hosed. 		 */
return|return
name|ENOTCONN
return|;
block|}
name|SMBSDEBUG
argument_list|(
literal|"M:%04x, P:%04x, U:%04x, T:%04x\n"
argument_list|,
name|rqp
operator|->
name|sr_mid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_dumpm
argument_list|(
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_top
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_top
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|error
operator|=
name|rqp
operator|->
name|sr_lerror
operator|=
name|m
condition|?
name|SMB_TRAN_SEND
argument_list|(
name|vcp
argument_list|,
name|m
argument_list|,
name|p
argument_list|)
else|:
name|ENOBUFS
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|getnanotime
argument_list|(
operator|&
name|rqp
operator|->
name|sr_timesent
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_lastrqsent
operator|=
name|rqp
operator|->
name|sr_timesent
expr_stmt|;
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_SENT
expr_stmt|;
name|rqp
operator|->
name|sr_state
operator|=
name|SMBRQ_SENT
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Check for fatal errors 	 */
if|if
condition|(
name|SMB_TRAN_FATAL
argument_list|(
name|vcp
argument_list|,
name|error
argument_list|)
condition|)
block|{
comment|/* 		 * No further attempts should be made 		 */
return|return
name|ENOTCONN
return|;
block|}
if|if
condition|(
name|smb_rq_intr
argument_list|(
name|rqp
argument_list|)
condition|)
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process incoming packets  */
end_comment

begin_function
specifier|static
name|int
name|smb_iod_recvall
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|iod
operator|->
name|iod_p
decl_stmt|;
name|struct
name|smb_rq
modifier|*
name|rqp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|hp
decl_stmt|;
name|u_short
name|mid
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|iod
operator|->
name|iod_state
condition|)
block|{
case|case
name|SMBIOD_ST_NOTCONN
case|:
case|case
name|SMBIOD_ST_DEAD
case|:
case|case
name|SMBIOD_ST_RECONNECT
case|:
return|return
literal|0
return|;
default|default:
break|break;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|SMB_TRAN_RECV
argument_list|(
name|vcp
argument_list|,
operator|&
name|m
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
break|break;
if|if
condition|(
name|SMB_TRAN_FATAL
argument_list|(
name|vcp
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|smb_iod_dead
argument_list|(
name|iod
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"tran return NULL without error\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|SMB_HDRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
comment|/* wait for a good packet */
comment|/* 		 * Now we got an entire and possibly invalid SMB packet. 		 * Be careful while parsing it. 		 */
name|m_dumpm
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|hp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|hp
argument_list|,
name|SMB_SIGNATURE
argument_list|,
name|SMB_SIGLEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mid
operator|=
name|SMB_HDRMID
argument_list|(
name|hp
argument_list|)
expr_stmt|;
name|SMBSDEBUG
argument_list|(
literal|"mid %04x\n"
argument_list|,
operator|(
name|u_int
operator|)
name|mid
argument_list|)
expr_stmt|;
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rqp
argument_list|,
argument|&iod->iod_rqlist
argument_list|,
argument|sr_link
argument_list|)
block|{
if|if
condition|(
name|rqp
operator|->
name|sr_mid
operator|!=
name|mid
condition|)
continue|continue;
name|SMBRQ_SLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_rp
operator|.
name|md_top
operator|==
name|NULL
condition|)
block|{
name|md_initm
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_MULTIPACKET
condition|)
block|{
name|md_append_record
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|SMBERROR
argument_list|(
literal|"duplicate response %d (ignored)\n"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"drop resp with mid %d\n"
argument_list|,
operator|(
name|u_int
operator|)
name|mid
argument_list|)
expr_stmt|;
comment|/*			smb_printrqlist(vcp);*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check for interrupts 	 */
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rqp
argument_list|,
argument|&iod->iod_rqlist
argument_list|,
argument|sr_link
argument_list|)
block|{
if|if
condition|(
name|smb_proc_intr
argument_list|(
name|rqp
operator|->
name|sr_cred
operator|->
name|scr_p
argument_list|)
condition|)
block|{
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
block|}
block|}
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_request
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|ident
parameter_list|)
block|{
name|struct
name|smbiod_event
modifier|*
name|evp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|evp
operator|=
name|smb_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|evp
argument_list|)
argument_list|,
name|M_SMBIOD
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|evp
operator|->
name|ev_type
operator|=
name|event
expr_stmt|;
name|evp
operator|->
name|ev_ident
operator|=
name|ident
expr_stmt|;
name|SMB_IOD_EVLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlist
argument_list|,
name|evp
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|event
operator|&
name|SMBIOD_EV_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|SMB_IOD_EVUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|smb_iod_wakeup
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|smb_iod_wakeup
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|evp
argument_list|,
name|SMB_IOD_EVLOCKPTR
argument_list|(
name|iod
argument_list|)
argument_list|,
name|PWAIT
operator||
name|PDROP
argument_list|,
literal|"90evw"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|evp
operator|->
name|ev_error
expr_stmt|;
name|free
argument_list|(
name|evp
argument_list|,
name|M_SMBIOD
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Place request in the queue.  * Request from smbiod have a high priority.  */
end_comment

begin_function
name|int
name|smb_iod_addrq
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|rqp
operator|->
name|sr_vc
decl_stmt|;
name|struct
name|smbiod
modifier|*
name|iod
init|=
name|vcp
operator|->
name|vc_iod
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_cred
operator|->
name|scr_p
operator|==
name|iod
operator|->
name|iod_p
condition|)
block|{
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_INTERNAL
expr_stmt|;
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|smb_iod_sendrq
argument_list|(
name|iod
argument_list|,
name|rqp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|smb_iod_dead
argument_list|(
name|iod
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * we don't need to lock state field here 			 */
if|if
condition|(
name|rqp
operator|->
name|sr_state
operator|!=
name|SMBRQ_NOTSENT
condition|)
break|break;
name|tsleep
argument_list|(
operator|&
name|iod
operator|->
name|iod_flags
argument_list|,
name|PWAIT
argument_list|,
literal|"90sndw"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rqp
operator|->
name|sr_lerror
condition|)
name|smb_iod_removerq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
return|return
name|rqp
operator|->
name|sr_lerror
return|;
block|}
switch|switch
condition|(
name|iod
operator|->
name|iod_state
condition|)
block|{
case|case
name|SMBIOD_ST_NOTCONN
case|:
return|return
name|ENOTCONN
return|;
case|case
name|SMBIOD_ST_DEAD
case|:
name|error
operator|=
name|smb_iod_request
argument_list|(
name|vcp
operator|->
name|vc_iod
argument_list|,
name|SMBIOD_EV_CONNECT
operator||
name|SMBIOD_EV_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|EXDEV
return|;
default|default:
break|break;
block|}
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|vcp
operator|->
name|vc_maxmux
operator|==
literal|0
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"maxmux == 0\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|iod
operator|->
name|iod_muxcnt
operator|<
name|vcp
operator|->
name|vc_maxmux
condition|)
break|break;
name|iod
operator|->
name|iod_muxwant
operator|++
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|iod
operator|->
name|iod_muxwant
argument_list|,
name|SMB_IOD_RQLOCKPTR
argument_list|(
name|iod
argument_list|)
argument_list|,
name|PWAIT
argument_list|,
literal|"90mux"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|iod
operator|->
name|iod_muxcnt
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|smb_iod_wakeup
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_removerq
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|rqp
operator|->
name|sr_vc
decl_stmt|;
name|struct
name|smbiod
modifier|*
name|iod
init|=
name|vcp
operator|->
name|vc_iod
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_INTERNAL
condition|)
block|{
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
while|while
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_XLOCK
condition|)
block|{
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_XLOCKWANT
expr_stmt|;
name|msleep
argument_list|(
name|rqp
argument_list|,
name|SMB_IOD_RQLOCKPTR
argument_list|(
name|iod
argument_list|)
argument_list|,
name|PWAIT
argument_list|,
literal|"90xrm"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_muxcnt
operator|--
expr_stmt|;
if|if
condition|(
name|iod
operator|->
name|iod_muxwant
condition|)
block|{
name|iod
operator|->
name|iod_muxwant
operator|--
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|iod
operator|->
name|iod_muxwant
argument_list|)
expr_stmt|;
block|}
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_waitrq
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|smbiod
modifier|*
name|iod
init|=
name|rqp
operator|->
name|sr_vc
operator|->
name|vc_iod
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_INTERNAL
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|smb_iod_sendall
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|smb_iod_recvall
argument_list|(
name|iod
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_rpgen
operator|!=
name|rqp
operator|->
name|sr_rplast
condition|)
break|break;
name|tsleep
argument_list|(
operator|&
name|iod
operator|->
name|iod_flags
argument_list|,
name|PWAIT
argument_list|,
literal|"90irq"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|smb_iod_removerq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
return|return
name|rqp
operator|->
name|sr_lerror
return|;
block|}
name|SMBRQ_SLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_rpgen
operator|==
name|rqp
operator|->
name|sr_rplast
condition|)
name|msleep
argument_list|(
operator|&
name|rqp
operator|->
name|sr_state
argument_list|,
name|SMBRQ_SLOCKPTR
argument_list|(
name|rqp
argument_list|)
argument_list|,
name|PWAIT
argument_list|,
literal|"90wrq"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_rplast
operator|++
expr_stmt|;
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|error
operator|=
name|rqp
operator|->
name|sr_lerror
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_MULTIPACKET
condition|)
block|{
comment|/* 		 * If request should stay in the list, then reinsert it 		 * at the end of queue so other waiters have chance to concur 		 */
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|,
name|rqp
argument_list|,
name|sr_link
argument_list|)
expr_stmt|;
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
else|else
name|smb_iod_removerq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_iod_sendall
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|iod
operator|->
name|iod_vc
decl_stmt|;
name|struct
name|smb_rq
modifier|*
name|rqp
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
name|tstimeout
decl_stmt|;
name|int
name|herror
decl_stmt|;
name|herror
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Loop through the list of requests and send them if possible 	 */
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rqp
argument_list|,
argument|&iod->iod_rqlist
argument_list|,
argument|sr_link
argument_list|)
block|{
switch|switch
condition|(
name|rqp
operator|->
name|sr_state
condition|)
block|{
case|case
name|SMBRQ_NOTSENT
case|:
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_XLOCK
expr_stmt|;
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|herror
operator|=
name|smb_iod_sendrq
argument_list|(
name|iod
argument_list|,
name|rqp
argument_list|)
expr_stmt|;
name|SMB_IOD_RQLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_flags
operator|&=
operator|~
name|SMBR_XLOCK
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_XLOCKWANT
condition|)
block|{
name|rqp
operator|->
name|sr_flags
operator|&=
operator|~
name|SMBR_XLOCKWANT
expr_stmt|;
name|wakeup
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SMBRQ_SENT
case|:
name|SMB_TRAN_GETPARAM
argument_list|(
name|vcp
argument_list|,
name|SMBTP_TIMEOUT
argument_list|,
operator|&
name|tstimeout
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|tstimeout
argument_list|,
operator|&
name|tstimeout
argument_list|)
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|tstimeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts
argument_list|,
operator|&
name|rqp
operator|->
name|sr_timesent
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|smb_iod_rqprocessed
argument_list|(
name|rqp
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
block|}
if|if
condition|(
name|herror
condition|)
break|break;
block|}
name|SMB_IOD_RQUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
if|if
condition|(
name|herror
operator|==
name|ENOTCONN
condition|)
name|smb_iod_dead
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * "main" function for smbiod daemon  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|smb_iod_main
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
comment|/*	struct smb_vc *vcp = iod->iod_vc;*/
name|struct
name|smbiod_event
modifier|*
name|evp
decl_stmt|;
comment|/*	struct timespec tsnow;*/
name|int
name|error
decl_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check all interesting events 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|SMB_IOD_EVLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|evp
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|evp
operator|==
name|NULL
condition|)
block|{
name|SMB_IOD_EVUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
break|break;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlist
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|evp
operator|->
name|ev_type
operator||=
name|SMBIOD_EV_PROCESSING
expr_stmt|;
name|SMB_IOD_EVUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|evp
operator|->
name|ev_type
operator|&
name|SMBIOD_EV_MASK
condition|)
block|{
case|case
name|SMBIOD_EV_CONNECT
case|:
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_RECONNECT
expr_stmt|;
name|evp
operator|->
name|ev_error
operator|=
name|smb_iod_connect
argument_list|(
name|iod
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMBIOD_EV_DISCONNECT
case|:
name|evp
operator|->
name|ev_error
operator|=
name|smb_iod_disconnect
argument_list|(
name|iod
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMBIOD_EV_TREECONNECT
case|:
name|evp
operator|->
name|ev_error
operator|=
name|smb_iod_treeconnect
argument_list|(
name|iod
argument_list|,
name|evp
operator|->
name|ev_ident
argument_list|)
expr_stmt|;
break|break;
case|case
name|SMBIOD_EV_SHUTDOWN
case|:
name|iod
operator|->
name|iod_flags
operator||=
name|SMBIOD_SHUTDOWN
expr_stmt|;
break|break;
case|case
name|SMBIOD_EV_NEWRQ
case|:
break|break;
block|}
if|if
condition|(
name|evp
operator|->
name|ev_type
operator|&
name|SMBIOD_EV_SYNC
condition|)
block|{
name|SMB_IOD_EVLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|evp
argument_list|)
expr_stmt|;
name|SMB_IOD_EVUNLOCK
argument_list|(
name|iod
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|evp
argument_list|,
name|M_SMBIOD
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (iod->iod_state == SMBIOD_ST_VCACTIVE) { 		getnanotime(&tsnow); 		timespecsub(&tsnow,&iod->iod_pingtimo); 		if (timespeccmp(&tsnow,&iod->iod_lastrqsent,>)) { 			smb_smb_echo(vcp,&iod->iod_scred); 		} 	}
endif|#
directive|endif
name|smb_iod_sendall
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|smb_iod_recvall
argument_list|(
name|iod
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|FB_CURRENT
end_ifndef

begin_define
define|#
directive|define
name|kthread_create_compat
value|kthread_create2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|kthread_create_compat
value|kthread_create
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|smb_iod_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|smbiod
modifier|*
name|iod
init|=
name|arg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|smb_makescred
argument_list|(
operator|&
name|iod
operator|->
name|iod_scred
argument_list|,
name|iod
operator|->
name|iod_p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|iod
operator|->
name|iod_flags
operator|&
name|SMBIOD_SHUTDOWN
operator|)
operator|==
literal|0
condition|)
block|{
name|smb_iod_main
argument_list|(
name|iod
argument_list|)
expr_stmt|;
name|SMBIODEBUG
argument_list|(
literal|"going to sleep for %d ticks\n"
argument_list|,
name|iod
operator|->
name|iod_sleeptimo
argument_list|)
expr_stmt|;
comment|/*		mtx_unlock(&Giant, MTX_DEF);*/
if|if
condition|(
name|iod
operator|->
name|iod_flags
operator|&
name|SMBIOD_SHUTDOWN
condition|)
break|break;
name|tsleep
argument_list|(
operator|&
name|iod
operator|->
name|iod_flags
argument_list|,
name|PWAIT
argument_list|,
literal|"90idle"
argument_list|,
name|iod
operator|->
name|iod_sleeptimo
argument_list|)
expr_stmt|;
block|}
comment|/*	mtx_lock(&Giant, MTX_DEF);*/
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_iod_create
parameter_list|(
name|struct
name|smb_vc
modifier|*
name|vcp
parameter_list|)
block|{
name|struct
name|smbiod
modifier|*
name|iod
decl_stmt|;
name|int
name|error
decl_stmt|;
name|iod
operator|=
name|smb_zmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iod
argument_list|)
argument_list|,
name|M_SMBIOD
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|iod
operator|->
name|iod_id
operator|=
name|smb_iod_next
operator|++
expr_stmt|;
name|iod
operator|->
name|iod_state
operator|=
name|SMBIOD_ST_NOTCONN
expr_stmt|;
name|iod
operator|->
name|iod_vc
operator|=
name|vcp
expr_stmt|;
name|iod
operator|->
name|iod_sleeptimo
operator|=
name|hz
operator|*
name|SMBIOD_SLEEP_TIMO
expr_stmt|;
name|iod
operator|->
name|iod_pingtimo
operator|.
name|tv_sec
operator|=
name|SMBIOD_PING_TIMO
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|iod
operator|->
name|iod_lastrqsent
argument_list|)
expr_stmt|;
name|vcp
operator|->
name|vc_iod
operator|=
name|iod
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlock
argument_list|,
literal|"90rql"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlist
argument_list|)
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlock
argument_list|,
literal|"90evl"
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlist
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create_compat
argument_list|(
name|smb_iod_thread
argument_list|,
name|iod
argument_list|,
operator|&
name|iod
operator|->
name|iod_p
argument_list|,
name|RFNOWAIT
argument_list|,
literal|"smbiod%d"
argument_list|,
name|iod
operator|->
name|iod_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"can't start smbiod: %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iod
argument_list|,
name|M_SMBIOD
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_destroy
parameter_list|(
name|struct
name|smbiod
modifier|*
name|iod
parameter_list|)
block|{
name|smb_iod_request
argument_list|(
name|iod
argument_list|,
name|SMBIOD_EV_SHUTDOWN
operator||
name|SMBIOD_EV_SYNC
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|iod
operator|->
name|iod_rqlock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|iod
operator|->
name|iod_evlock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iod
argument_list|,
name|M_SMBIOD
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_iod_done
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

