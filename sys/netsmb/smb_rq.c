begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2001, Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_conn.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_rq.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_subr.h>
end_include

begin_include
include|#
directive|include
file|<netsmb/smb_tran.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SMBRQ
argument_list|,
literal|"SMBRQ"
argument_list|,
literal|"SMB request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|netsmb
argument_list|,
name|libmchain
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|smb_rq_reply
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_rq_enqueue
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_rq_getenv
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|layer
parameter_list|,
name|struct
name|smb_vc
modifier|*
modifier|*
name|vcpp
parameter_list|,
name|struct
name|smb_share
modifier|*
modifier|*
name|sspp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_rq_new
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|u_char
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|smb_t2_reply
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|smb_rq_alloc
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|layer
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_rq
modifier|*
modifier|*
name|rqpp
parameter_list|)
block|{
name|struct
name|smb_rq
modifier|*
name|rqp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MALLOC
argument_list|(
name|rqp
argument_list|,
expr|struct
name|smb_rq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rqp
argument_list|)
argument_list|,
name|M_SMBRQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|smb_rq_init
argument_list|(
name|rqp
argument_list|,
name|layer
argument_list|,
name|cmd
argument_list|,
name|scred
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_ALLOCED
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|smb_rq_done
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|rqpp
operator|=
name|rqp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|tzero
index|[
literal|12
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|smb_rq_init
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|struct
name|smb_connobj
modifier|*
name|layer
parameter_list|,
name|u_char
name|cmd
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|rqp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rqp
argument_list|)
argument_list|)
expr_stmt|;
name|smb_sl_init
argument_list|(
operator|&
name|rqp
operator|->
name|sr_slock
argument_list|,
literal|"srslock"
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_rq_getenv
argument_list|(
name|layer
argument_list|,
operator|&
name|rqp
operator|->
name|sr_vc
argument_list|,
operator|&
name|rqp
operator|->
name|sr_share
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smb_vc_access
argument_list|(
name|rqp
operator|->
name|sr_vc
argument_list|,
name|scred
argument_list|,
name|SMBM_EXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|rqp
operator|->
name|sr_share
condition|)
block|{
name|error
operator|=
name|smb_share_access
argument_list|(
name|rqp
operator|->
name|sr_share
argument_list|,
name|scred
argument_list|,
name|SMBM_EXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|rqp
operator|->
name|sr_cred
operator|=
name|scred
expr_stmt|;
name|rqp
operator|->
name|sr_mid
operator|=
name|smb_vc_nextmid
argument_list|(
name|rqp
operator|->
name|sr_vc
argument_list|)
expr_stmt|;
return|return
name|smb_rq_new
argument_list|(
name|rqp
argument_list|,
name|cmd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rq_new
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|u_char
name|cmd
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|rqp
operator|->
name|sr_vc
decl_stmt|;
name|struct
name|mbchain
modifier|*
name|mbp
init|=
operator|&
name|rqp
operator|->
name|sr_rq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rqp
operator|->
name|sr_sendcnt
operator|=
literal|0
expr_stmt|;
name|mb_done
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|)
expr_stmt|;
name|error
operator|=
name|mb_init
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|SMB_SIGNATURE
argument_list|,
name|SMB_SIGLEN
argument_list|,
name|MB_MSYSTEM
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|mb_put_uint32le
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DosError */
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
name|vcp
operator|->
name|vc_hflags
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|vcp
operator|->
name|vc_hflags2
argument_list|)
expr_stmt|;
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|tzero
argument_list|,
literal|12
argument_list|,
name|MB_MSYSTEM
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_rqtid
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|mb_reserve
argument_list|(
name|mbp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
literal|1
comment|/*scred->sc_p->p_pid& 0xffff*/
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_rquid
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|mb_reserve
argument_list|(
name|mbp
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|rqp
operator|->
name|sr_mid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|smb_rq_done
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|mb_done
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rq
argument_list|)
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|)
expr_stmt|;
name|smb_sl_destroy
argument_list|(
operator|&
name|rqp
operator|->
name|sr_slock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_ALLOCED
condition|)
name|free
argument_list|(
name|rqp
argument_list|,
name|M_SMBRQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simple request-reply exchange  */
end_comment

begin_function
name|int
name|smb_rq_simple
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|rqp
operator|->
name|sr_vc
decl_stmt|;
name|int
name|error
init|=
name|EINVAL
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMB_MAXRCN
condition|;
name|i
operator|++
control|)
block|{
name|rqp
operator|->
name|sr_flags
operator|&=
operator|~
name|SMBR_RESTART
expr_stmt|;
name|rqp
operator|->
name|sr_timo
operator|=
name|vcp
operator|->
name|vc_timo
expr_stmt|;
name|rqp
operator|->
name|sr_state
operator|=
name|SMBRQ_NOTSENT
expr_stmt|;
name|error
operator|=
name|smb_rq_enqueue
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|smb_rq_reply
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|rqp
operator|->
name|sr_flags
operator|&
operator|(
name|SMBR_RESTART
operator||
name|SMBR_NORESTART
operator|)
operator|)
operator|!=
name|SMBR_RESTART
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rq_enqueue
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|rqp
operator|->
name|sr_share
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ssp
operator|==
name|NULL
operator|||
name|rqp
operator|->
name|sr_cred
operator|==
operator|&
name|rqp
operator|->
name|sr_vc
operator|->
name|vc_iod
operator|->
name|iod_scred
condition|)
block|{
return|return
name|smb_iod_addrq
argument_list|(
name|rqp
argument_list|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|SMBS_ST_LOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssp
operator|->
name|ss_flags
operator|&
name|SMBS_RECONNECTING
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|ssp
operator|->
name|ss_vcgenid
argument_list|,
name|SMBS_ST_LOCKPTR
argument_list|(
name|ssp
argument_list|)
argument_list|,
name|PWAIT
operator||
name|PDROP
argument_list|,
literal|"90trcn"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|smb_proc_intr
argument_list|(
name|rqp
operator|->
name|sr_cred
operator|->
name|scr_p
argument_list|)
condition|)
return|return
name|EINTR
return|;
continue|continue;
block|}
if|if
condition|(
name|smb_share_valid
argument_list|(
name|ssp
argument_list|)
operator|||
operator|(
name|ssp
operator|->
name|ss_flags
operator|&
name|SMBS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|SMBS_ST_UNLOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SMBS_ST_UNLOCK
argument_list|(
name|ssp
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_iod_request
argument_list|(
name|rqp
operator|->
name|sr_vc
operator|->
name|vc_iod
argument_list|,
name|SMBIOD_EV_TREECONNECT
operator||
name|SMBIOD_EV_SYNC
argument_list|,
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|smb_iod_addrq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EXDEV
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|void
name|smb_rq_wstart
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|rqp
operator|->
name|sr_wcount
operator|=
name|mb_reserve
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rq
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_rq_wend
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
if|if
condition|(
name|rqp
operator|->
name|sr_wcount
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"no wcount\n"
argument_list|)
expr_stmt|;
comment|/* actually panic */
return|return;
block|}
if|if
condition|(
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_count
operator|&
literal|1
condition|)
name|SMBERROR
argument_list|(
literal|"odd word count\n"
argument_list|)
expr_stmt|;
operator|*
name|rqp
operator|->
name|sr_wcount
operator|=
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_count
operator|/
literal|2
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_rq_bstart
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|rqp
operator|->
name|sr_bcount
operator|=
operator|(
name|u_short
operator|*
operator|)
name|mb_reserve
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rq
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|smb_rq_bend
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|int
name|bcnt
decl_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_bcount
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"no bcount\n"
argument_list|)
expr_stmt|;
comment|/* actually panic */
return|return;
block|}
name|bcnt
operator|=
name|rqp
operator|->
name|sr_rq
operator|.
name|mb_count
expr_stmt|;
if|if
condition|(
name|bcnt
operator|>
literal|0xffff
condition|)
name|SMBERROR
argument_list|(
literal|"byte count too large (%d)\n"
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
operator|*
name|rqp
operator|->
name|sr_bcount
operator|=
name|bcnt
expr_stmt|;
block|}
end_function

begin_function
name|int
name|smb_rq_intr
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|rqp
operator|->
name|sr_cred
operator|->
name|scr_p
decl_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_INTR
condition|)
return|return
name|EINTR
return|;
return|return
name|smb_proc_intr
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|smb_rq_getrequest
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|struct
name|mbchain
modifier|*
modifier|*
name|mbpp
parameter_list|)
block|{
operator|*
name|mbpp
operator|=
operator|&
name|rqp
operator|->
name|sr_rq
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_rq_getreply
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|,
name|struct
name|mdchain
modifier|*
modifier|*
name|mbpp
parameter_list|)
block|{
operator|*
name|mbpp
operator|=
operator|&
name|rqp
operator|->
name|sr_rp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_rq_getenv
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|layer
parameter_list|,
name|struct
name|smb_vc
modifier|*
modifier|*
name|vcpp
parameter_list|,
name|struct
name|smb_share
modifier|*
modifier|*
name|sspp
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|NULL
decl_stmt|;
name|struct
name|smb_share
modifier|*
name|ssp
init|=
name|NULL
decl_stmt|;
name|struct
name|smb_connobj
modifier|*
name|cp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|layer
operator|->
name|co_level
condition|)
block|{
case|case
name|SMBL_VC
case|:
name|vcp
operator|=
name|CPTOVC
argument_list|(
name|layer
argument_list|)
expr_stmt|;
if|if
condition|(
name|layer
operator|->
name|co_parent
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"zombie VC %s\n"
argument_list|,
name|vcp
operator|->
name|vc_srvname
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SMBL_SHARE
case|:
name|ssp
operator|=
name|CPTOSS
argument_list|(
name|layer
argument_list|)
expr_stmt|;
name|cp
operator|=
name|layer
operator|->
name|co_parent
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"zombie share %s\n"
argument_list|,
name|ssp
operator|->
name|ss_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|smb_rq_getenv
argument_list|(
name|cp
argument_list|,
operator|&
name|vcp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
break|break;
default|default:
name|SMBERROR
argument_list|(
literal|"invalid layer %d passed\n"
argument_list|,
name|layer
operator|->
name|co_level
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|vcpp
condition|)
operator|*
name|vcpp
operator|=
name|vcp
expr_stmt|;
if|if
condition|(
name|sspp
condition|)
operator|*
name|sspp
operator|=
name|ssp
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for reply on the request  */
end_comment

begin_function
specifier|static
name|int
name|smb_rq_reply
parameter_list|(
name|struct
name|smb_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|struct
name|mdchain
modifier|*
name|mdp
init|=
operator|&
name|rqp
operator|->
name|sr_rp
decl_stmt|;
name|u_int32_t
name|tdw
decl_stmt|;
name|u_int8_t
name|tb
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rperror
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|smb_iod_waitrq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|md_get_uint32
argument_list|(
name|mdp
argument_list|,
operator|&
name|tdw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|sr_vc
operator|->
name|vc_hflags2
operator|&
name|SMB_FLAGS2_ERR_STATUS
condition|)
block|{
name|error
operator|=
name|md_get_uint32le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_errclass
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|tb
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_serror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|rperror
operator|=
name|smb_maperror
argument_list|(
name|rqp
operator|->
name|sr_errclass
argument_list|,
name|rqp
operator|->
name|sr_serror
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rpflags
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rpflags2
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint32
argument_list|(
name|mdp
argument_list|,
operator|&
name|tdw
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint32
argument_list|(
name|mdp
argument_list|,
operator|&
name|tdw
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint32
argument_list|(
name|mdp
argument_list|,
operator|&
name|tdw
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rptid
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rppid
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rpuid
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|rqp
operator|->
name|sr_rpmid
argument_list|)
expr_stmt|;
name|SMBSDEBUG
argument_list|(
literal|"M:%04x, P:%04x, U:%04x, T:%04x, E: %d:%d\n"
argument_list|,
name|rqp
operator|->
name|sr_rpmid
argument_list|,
name|rqp
operator|->
name|sr_rppid
argument_list|,
name|rqp
operator|->
name|sr_rpuid
argument_list|,
name|rqp
operator|->
name|sr_rptid
argument_list|,
name|rqp
operator|->
name|sr_errclass
argument_list|,
name|rqp
operator|->
name|sr_serror
argument_list|)
expr_stmt|;
return|return
name|error
condition|?
name|error
else|:
name|rperror
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ALIGN4
parameter_list|(
name|a
parameter_list|)
value|(((a) + 3)& ~3)
end_define

begin_comment
comment|/*  * TRANS2 request implementation  */
end_comment

begin_function
name|int
name|smb_t2_alloc
parameter_list|(
name|struct
name|smb_connobj
modifier|*
name|layer
parameter_list|,
name|u_short
name|setup
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|,
name|struct
name|smb_t2rq
modifier|*
modifier|*
name|t2pp
parameter_list|)
block|{
name|struct
name|smb_t2rq
modifier|*
name|t2p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MALLOC
argument_list|(
name|t2p
argument_list|,
expr|struct
name|smb_t2rq
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t2p
argument_list|)
argument_list|,
name|M_SMBRQ
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|error
operator|=
name|smb_t2_init
argument_list|(
name|t2p
argument_list|,
name|layer
argument_list|,
name|setup
argument_list|,
name|scred
argument_list|)
expr_stmt|;
name|t2p
operator|->
name|t2_flags
operator||=
name|SMBT2_ALLOCED
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|smb_t2_done
argument_list|(
name|t2p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
operator|*
name|t2pp
operator|=
name|t2p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|smb_t2_init
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|,
name|struct
name|smb_connobj
modifier|*
name|source
parameter_list|,
name|u_short
name|setup
parameter_list|,
name|struct
name|smb_cred
modifier|*
name|scred
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|t2p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t2p
argument_list|)
argument_list|)
expr_stmt|;
name|t2p
operator|->
name|t2_source
operator|=
name|source
expr_stmt|;
name|t2p
operator|->
name|t2_setupcount
operator|=
literal|1
expr_stmt|;
name|t2p
operator|->
name|t2_setupdata
operator|=
name|t2p
operator|->
name|t2_setup
expr_stmt|;
name|t2p
operator|->
name|t2_setup
index|[
literal|0
index|]
operator|=
name|setup
expr_stmt|;
name|t2p
operator|->
name|t2_fid
operator|=
literal|0xffff
expr_stmt|;
name|t2p
operator|->
name|t2_cred
operator|=
name|scred
expr_stmt|;
name|error
operator|=
name|smb_rq_getenv
argument_list|(
name|source
argument_list|,
operator|&
name|t2p
operator|->
name|t2_vc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|smb_t2_done
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|)
block|{
name|mb_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_tparam
argument_list|)
expr_stmt|;
name|mb_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_tdata
argument_list|)
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_rparam
argument_list|)
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2p
operator|->
name|t2_flags
operator|&
name|SMBT2_ALLOCED
condition|)
name|free
argument_list|(
name|t2p
argument_list|,
name|M_SMBRQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_t2_placedata
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mtop
parameter_list|,
name|u_int16_t
name|offset
parameter_list|,
name|u_int16_t
name|count
parameter_list|,
name|struct
name|mdchain
modifier|*
name|mdp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|m0
operator|=
name|m_split
argument_list|(
name|mtop
argument_list|,
name|offset
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
return|return
name|EBADRPC
return|;
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|len
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|md_top
operator|==
name|NULL
condition|)
block|{
name|md_initm
argument_list|(
name|mdp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
name|m_cat
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|smb_t2_reply
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|)
block|{
name|struct
name|mdchain
modifier|*
name|mdp
decl_stmt|;
name|struct
name|smb_rq
modifier|*
name|rqp
init|=
name|t2p
operator|->
name|t2_rq
decl_stmt|;
name|int
name|error
decl_stmt|,
name|totpgot
decl_stmt|,
name|totdgot
decl_stmt|;
name|u_int16_t
name|totpcount
decl_stmt|,
name|totdcount
decl_stmt|,
name|pcount
decl_stmt|,
name|poff
decl_stmt|,
name|doff
decl_stmt|,
name|pdisp
decl_stmt|,
name|ddisp
decl_stmt|;
name|u_int16_t
name|tmp
decl_stmt|,
name|bc
decl_stmt|,
name|dcount
decl_stmt|;
name|u_int8_t
name|wc
decl_stmt|;
name|error
operator|=
name|smb_rq_reply
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|t2p
operator|->
name|t2_flags
operator|&
name|SMBT2_ALLSENT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/*  		 * this is an interim response, ignore it. 		 */
name|SMBRQ_SLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|md_next_record
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|)
expr_stmt|;
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Now we have to get all subseqent responses. The CIFS specification 	 * says that they can be misordered which is weird. 	 * TODO: timo 	 */
name|totpgot
operator|=
name|totdgot
operator|=
literal|0
expr_stmt|;
name|totpcount
operator|=
name|totdcount
operator|=
literal|0xffff
expr_stmt|;
name|mdp
operator|=
operator|&
name|rqp
operator|->
name|sr_rp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|m_dumpm
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|wc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|wc
operator|<
literal|10
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|totpcount
operator|>
name|tmp
condition|)
name|totpcount
operator|=
name|tmp
expr_stmt|;
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|totdcount
operator|>
name|tmp
condition|)
name|totdcount
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
operator|||
comment|/* reserved */
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|pcount
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|poff
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|pdisp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pcount
operator|!=
literal|0
operator|&&
name|pdisp
operator|!=
name|totpgot
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"Can't handle misordered parameters %d:%d\n"
argument_list|,
name|pdisp
argument_list|,
name|totpgot
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|dcount
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|doff
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|ddisp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|dcount
operator|!=
literal|0
operator|&&
name|ddisp
operator|!=
name|totdgot
condition|)
block|{
name|SMBERROR
argument_list|(
literal|"Can't handle misordered data\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
operator|&
name|wc
argument_list|)
expr_stmt|;
name|md_get_uint8
argument_list|(
name|mdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|wc
expr_stmt|;
while|while
condition|(
name|tmp
operator|--
condition|)
name|md_get_uint16
argument_list|(
name|mdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md_get_uint16le
argument_list|(
name|mdp
argument_list|,
operator|&
name|bc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/*		tmp = SMB_HDRLEN + 1 + 10 * 2 + 2 * wc + 2;*/
if|if
condition|(
name|dcount
condition|)
block|{
name|error
operator|=
name|smb_t2_placedata
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|,
name|doff
argument_list|,
name|dcount
argument_list|,
operator|&
name|t2p
operator|->
name|t2_rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|pcount
condition|)
block|{
name|error
operator|=
name|smb_t2_placedata
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|,
name|poff
argument_list|,
name|pcount
argument_list|,
operator|&
name|t2p
operator|->
name|t2_rparam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|totpgot
operator|+=
name|pcount
expr_stmt|;
name|totdgot
operator|+=
name|dcount
expr_stmt|;
if|if
condition|(
name|totpgot
operator|>=
name|totpcount
operator|&&
name|totdgot
operator|>=
name|totdcount
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|t2p
operator|->
name|t2_flags
operator||=
name|SMBT2_ALLRECV
expr_stmt|;
break|break;
block|}
comment|/* 		 * We're done with this reply, look for the next one. 		 */
name|SMBRQ_SLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|md_next_record
argument_list|(
operator|&
name|rqp
operator|->
name|sr_rp
argument_list|)
expr_stmt|;
name|SMBRQ_SUNLOCK
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|error
operator|=
name|smb_rq_reply
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a full round of TRANS2 request  */
end_comment

begin_function
specifier|static
name|int
name|smb_t2_request_int
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|)
block|{
name|struct
name|smb_vc
modifier|*
name|vcp
init|=
name|t2p
operator|->
name|t2_vc
decl_stmt|;
name|struct
name|smb_cred
modifier|*
name|scred
init|=
name|t2p
operator|->
name|t2_cred
decl_stmt|;
name|struct
name|mbchain
modifier|*
name|mbp
decl_stmt|;
name|struct
name|mdchain
modifier|*
name|mdp
decl_stmt|,
name|mbparam
decl_stmt|,
name|mbdata
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|smb_rq
modifier|*
name|rqp
decl_stmt|;
name|int
name|totpcount
decl_stmt|,
name|leftpcount
decl_stmt|,
name|totdcount
decl_stmt|,
name|leftdcount
decl_stmt|,
name|len
decl_stmt|,
name|txmax
decl_stmt|,
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|doff
decl_stmt|,
name|poff
decl_stmt|,
name|txdcount
decl_stmt|,
name|txpcount
decl_stmt|,
name|nmlen
decl_stmt|;
name|m
operator|=
name|t2p
operator|->
name|t2_tparam
operator|.
name|mb_top
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|md_initm
argument_list|(
operator|&
name|mbparam
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* do not free it! */
name|totpcount
operator|=
name|m_fixhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|totpcount
operator|>
literal|0xffff
condition|)
comment|/* maxvalue for u_short */
return|return
name|EINVAL
return|;
block|}
else|else
name|totpcount
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|t2p
operator|->
name|t2_tdata
operator|.
name|mb_top
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|md_initm
argument_list|(
operator|&
name|mbdata
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* do not free it! */
name|totdcount
operator|=
name|m_fixhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|totdcount
operator|>
literal|0xffff
condition|)
return|return
name|EINVAL
return|;
block|}
else|else
name|totdcount
operator|=
literal|0
expr_stmt|;
name|leftdcount
operator|=
name|totdcount
expr_stmt|;
name|leftpcount
operator|=
name|totpcount
expr_stmt|;
name|txmax
operator|=
name|vcp
operator|->
name|vc_txmax
expr_stmt|;
name|error
operator|=
name|smb_rq_alloc
argument_list|(
name|t2p
operator|->
name|t2_source
argument_list|,
name|t2p
operator|->
name|t_name
condition|?
name|SMB_COM_TRANSACTION
else|:
name|SMB_COM_TRANSACTION2
argument_list|,
name|scred
argument_list|,
operator|&
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|rqp
operator|->
name|sr_flags
operator||=
name|SMBR_MULTIPACKET
expr_stmt|;
name|t2p
operator|->
name|t2_rq
operator|=
name|rqp
expr_stmt|;
name|mbp
operator|=
operator|&
name|rqp
operator|->
name|sr_rq
expr_stmt|;
name|smb_rq_wstart
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totdcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_maxpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_maxdcount
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_maxscount
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reserved */
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* flags */
name|mb_put_uint32le
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Timeout */
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reserved 2 */
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
comment|/* 	 * now we have known packet size as 	 * ALIGN4(len + 5 * 2 + setupcount * 2 + 2 + strlen(name) + 1), 	 * and need to decide which parts should go into the first request 	 */
name|nmlen
operator|=
name|t2p
operator|->
name|t_name
condition|?
name|strlen
argument_list|(
name|t2p
operator|->
name|t_name
argument_list|)
else|:
literal|0
expr_stmt|;
name|len
operator|=
name|ALIGN4
argument_list|(
name|len
operator|+
literal|5
operator|*
literal|2
operator|+
name|t2p
operator|->
name|t2_setupcount
operator|*
literal|2
operator|+
literal|2
operator|+
name|nmlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|leftpcount
operator|>
name|txmax
condition|)
block|{
name|txpcount
operator|=
name|min
argument_list|(
name|leftpcount
argument_list|,
name|txmax
operator|-
name|len
argument_list|)
expr_stmt|;
name|poff
operator|=
name|len
expr_stmt|;
name|txdcount
operator|=
literal|0
expr_stmt|;
name|doff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|txpcount
operator|=
name|leftpcount
expr_stmt|;
name|poff
operator|=
name|txpcount
condition|?
name|len
else|:
literal|0
expr_stmt|;
name|len
operator|=
name|ALIGN4
argument_list|(
name|len
operator|+
name|txpcount
argument_list|)
expr_stmt|;
name|txdcount
operator|=
name|min
argument_list|(
name|leftdcount
argument_list|,
name|txmax
operator|-
name|len
argument_list|)
expr_stmt|;
name|doff
operator|=
name|txdcount
condition|?
name|len
else|:
literal|0
expr_stmt|;
block|}
name|leftpcount
operator|-=
name|txpcount
expr_stmt|;
name|leftdcount
operator|-=
name|txdcount
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|txpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|poff
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|txdcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|doff
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_setupcount
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|t2p
operator|->
name|t2_setupcount
condition|;
name|i
operator|++
control|)
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_setupdata
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|smb_rq_wend
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|smb_rq_bstart
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
comment|/* TDUNICODE */
if|if
condition|(
name|t2p
operator|->
name|t_name
condition|)
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t_name
argument_list|,
name|nmlen
argument_list|,
name|MB_MSYSTEM
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* terminating zero */
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|txpcount
condition|)
block|{
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|NULL
argument_list|,
name|ALIGN4
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|MB_MZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_mbuf
argument_list|(
operator|&
name|mbparam
argument_list|,
name|txpcount
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
name|SMBSDEBUG
argument_list|(
literal|"%d:%d:%d\n"
argument_list|,
name|error
argument_list|,
name|txpcount
argument_list|,
name|txmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|freerq
goto|;
name|mb_put_mbuf
argument_list|(
name|mbp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|txdcount
condition|)
block|{
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|NULL
argument_list|,
name|ALIGN4
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|MB_MZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_mbuf
argument_list|(
operator|&
name|mbdata
argument_list|,
name|txdcount
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|freerq
goto|;
name|mb_put_mbuf
argument_list|(
name|mbp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|smb_rq_bend
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
comment|/* incredible, but thats it... */
name|error
operator|=
name|smb_rq_enqueue
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|freerq
goto|;
if|if
condition|(
name|leftpcount
operator|==
literal|0
operator|&&
name|leftdcount
operator|==
literal|0
condition|)
name|t2p
operator|->
name|t2_flags
operator||=
name|SMBT2_ALLSENT
expr_stmt|;
name|error
operator|=
name|smb_t2_reply
argument_list|(
name|t2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
name|leftpcount
operator|||
name|leftdcount
condition|)
block|{
name|error
operator|=
name|smb_rq_new
argument_list|(
name|rqp
argument_list|,
name|t2p
operator|->
name|t_name
condition|?
name|SMB_COM_TRANSACTION_SECONDARY
else|:
name|SMB_COM_TRANSACTION2_SECONDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mbp
operator|=
operator|&
name|rqp
operator|->
name|sr_rq
expr_stmt|;
name|smb_rq_wstart
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totdcount
argument_list|)
expr_stmt|;
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
comment|/* 		 * now we have known packet size as 		 * ALIGN4(len + 7 * 2 + 2) for T2 request, and -2 for T one, 		 * and need to decide which parts should go into request 		 */
name|len
operator|=
name|ALIGN4
argument_list|(
name|len
operator|+
literal|6
operator|*
literal|2
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2p
operator|->
name|t_name
operator|==
name|NULL
condition|)
name|len
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|leftpcount
operator|>
name|txmax
condition|)
block|{
name|txpcount
operator|=
name|min
argument_list|(
name|leftpcount
argument_list|,
name|txmax
operator|-
name|len
argument_list|)
expr_stmt|;
name|poff
operator|=
name|len
expr_stmt|;
name|txdcount
operator|=
literal|0
expr_stmt|;
name|doff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|txpcount
operator|=
name|leftpcount
expr_stmt|;
name|poff
operator|=
name|txpcount
condition|?
name|len
else|:
literal|0
expr_stmt|;
name|len
operator|=
name|ALIGN4
argument_list|(
name|len
operator|+
name|txpcount
argument_list|)
expr_stmt|;
name|txdcount
operator|=
name|min
argument_list|(
name|leftdcount
argument_list|,
name|txmax
operator|-
name|len
argument_list|)
expr_stmt|;
name|doff
operator|=
name|txdcount
condition|?
name|len
else|:
literal|0
expr_stmt|;
block|}
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|txpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|poff
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totpcount
operator|-
name|leftpcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|txdcount
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|doff
argument_list|)
expr_stmt|;
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|totdcount
operator|-
name|leftdcount
argument_list|)
expr_stmt|;
name|leftpcount
operator|-=
name|txpcount
expr_stmt|;
name|leftdcount
operator|-=
name|txdcount
expr_stmt|;
if|if
condition|(
name|t2p
operator|->
name|t_name
operator|==
name|NULL
condition|)
name|mb_put_uint16le
argument_list|(
name|mbp
argument_list|,
name|t2p
operator|->
name|t2_fid
argument_list|)
expr_stmt|;
name|smb_rq_wend
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|smb_rq_bstart
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|mb_put_uint8
argument_list|(
name|mbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* name */
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|txpcount
condition|)
block|{
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|NULL
argument_list|,
name|ALIGN4
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|MB_MZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_mbuf
argument_list|(
operator|&
name|mbparam
argument_list|,
name|txpcount
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mb_put_mbuf
argument_list|(
name|mbp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|mb_fixhdr
argument_list|(
name|mbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|txdcount
condition|)
block|{
name|mb_put_mem
argument_list|(
name|mbp
argument_list|,
name|NULL
argument_list|,
name|ALIGN4
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|MB_MZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|md_get_mbuf
argument_list|(
operator|&
name|mbdata
argument_list|,
name|txdcount
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mb_put_mbuf
argument_list|(
name|mbp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|smb_rq_bend
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|sr_state
operator|=
name|SMBRQ_NOTSENT
expr_stmt|;
name|error
operator|=
name|smb_iod_request
argument_list|(
name|vcp
operator|->
name|vc_iod
argument_list|,
name|SMBIOD_EV_NEWRQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* while left params or data */
name|t2p
operator|->
name|t2_flags
operator||=
name|SMBT2_ALLSENT
expr_stmt|;
name|mdp
operator|=
operator|&
name|t2p
operator|->
name|t2_rdata
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|md_top
condition|)
block|{
name|m_fixhdr
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|)
expr_stmt|;
name|md_initm
argument_list|(
name|mdp
argument_list|,
name|mdp
operator|->
name|md_top
argument_list|)
expr_stmt|;
block|}
name|mdp
operator|=
operator|&
name|t2p
operator|->
name|t2_rparam
expr_stmt|;
if|if
condition|(
name|mdp
operator|->
name|md_top
condition|)
block|{
name|m_fixhdr
argument_list|(
name|mdp
operator|->
name|md_top
argument_list|)
expr_stmt|;
name|md_initm
argument_list|(
name|mdp
argument_list|,
name|mdp
operator|->
name|md_top
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|smb_iod_removerq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|freerq
label|:
name|smb_rq_done
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|rqp
operator|->
name|sr_flags
operator|&
name|SMBR_RESTART
condition|)
name|t2p
operator|->
name|t2_flags
operator||=
name|SMBT2_RESTART
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_rparam
argument_list|)
expr_stmt|;
name|md_done
argument_list|(
operator|&
name|t2p
operator|->
name|t2_rdata
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|smb_t2_request
parameter_list|(
name|struct
name|smb_t2rq
modifier|*
name|t2p
parameter_list|)
block|{
name|int
name|error
init|=
name|EINVAL
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SMB_MAXRCN
condition|;
name|i
operator|++
control|)
block|{
name|t2p
operator|->
name|t2_flags
operator|&=
operator|~
name|SMBR_RESTART
expr_stmt|;
name|error
operator|=
name|smb_t2_request_int
argument_list|(
name|t2p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|t2p
operator|->
name|t2_flags
operator|&
operator|(
name|SMBT2_RESTART
operator||
name|SMBT2_NORESTART
operator|)
operator|)
operator|!=
name|SMBT2_RESTART
condition|)
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

end_unit

