begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   rpcsec_gss_prot.c      Copyright (c) 2000 The Regents of the University of Michigan.   All rights reserved.      Copyright (c) 2000 Dug Song<dugsong@UMICH.EDU>.   All rights reserved, all wrongs reversed.      Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright      notice, this list of conditions and the following disclaimer in the      documentation and/or other materials provided with the distribution.   3. Neither the name of the University nor the names of its      contributors may be used to endorse or promote products derived      from this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    $Id: authgss_prot.c,v 1.18 2000/09/01 04:14:03 dugsong Exp $ */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|"rpcsec_gss_int.h"
end_include

begin_define
define|#
directive|define
name|MAX_GSS_SIZE
value|10240
end_define

begin_comment
comment|/* XXX */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* use the one from kgssapi */
end_comment

begin_endif
unit|bool_t xdr_gss_buffer_desc(XDR *xdrs, gss_buffer_desc *p) { 	char *val; 	u_int len; 	bool_t ret;  	val = p->value; 	len = p->length; 	ret = xdr_bytes(xdrs,&val,&len, MAX_GSS_SIZE); 	p->value = val; 	p->length = len;  	return (ret); }
endif|#
directive|endif
end_endif

begin_function
name|bool_t
name|xdr_rpc_gss_cred
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|rpc_gss_cred
modifier|*
name|p
parameter_list|)
block|{
name|enum_t
name|proc
decl_stmt|,
name|svc
decl_stmt|;
name|bool_t
name|ret
decl_stmt|;
name|proc
operator|=
name|p
operator|->
name|gc_proc
expr_stmt|;
name|svc
operator|=
name|p
operator|->
name|gc_svc
expr_stmt|;
name|ret
operator|=
operator|(
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gc_version
argument_list|)
operator|&&
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|&
name|proc
argument_list|)
operator|&&
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gc_seq
argument_list|)
operator|&&
name|xdr_enum
argument_list|(
name|xdrs
argument_list|,
operator|&
name|svc
argument_list|)
operator|&&
name|xdr_gss_buffer_desc
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gc_handle
argument_list|)
operator|)
expr_stmt|;
name|p
operator|->
name|gc_proc
operator|=
name|proc
expr_stmt|;
name|p
operator|->
name|gc_svc
operator|=
name|svc
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|xdr_rpc_gss_init_res
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|rpc_gss_init_res
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|xdr_gss_buffer_desc
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gr_handle
argument_list|)
operator|&&
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gr_major
argument_list|)
operator|&&
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gr_minor
argument_list|)
operator|&&
name|xdr_u_int
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gr_win
argument_list|)
operator|&&
name|xdr_gss_buffer_desc
argument_list|(
name|xdrs
argument_list|,
operator|&
name|p
operator|->
name|gr_token
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_uint32
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|uint32_t
name|v
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|n
operator|=
name|htonl
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|n
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_function
name|bool_t
name|xdr_rpc_gss_wrap_data
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|argsp
parameter_list|,
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|gss_qop_t
name|qop
parameter_list|,
name|rpc_gss_service_t
name|svc
parameter_list|,
name|u_int
name|seq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|args
decl_stmt|,
modifier|*
name|mic
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|int
name|conf_state
decl_stmt|;
name|u_int
name|len
decl_stmt|;
specifier|static
name|char
name|zpad
index|[
literal|4
index|]
decl_stmt|;
name|args
operator|=
operator|*
name|argsp
expr_stmt|;
comment|/* 	 * Prepend the sequence number before calling gss_get_mic or gss_wrap. 	 */
name|put_uint32
argument_list|(
operator|&
name|args
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_length
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svc
operator|==
name|rpc_gss_svc_integrity
condition|)
block|{
comment|/* Checksum rpc_gss_data_t. */
name|maj_stat
operator|=
name|gss_get_mic_mbuf
argument_list|(
operator|&
name|min_stat
argument_list|,
name|ctx
argument_list|,
name|qop
argument_list|,
name|args
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_debug
argument_list|(
literal|"gss_get_mic failed"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Marshal databody_integ. Note that since args is 		 * already RPC encoded, there will be no padding. 		 */
name|put_uint32
argument_list|(
operator|&
name|args
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * Marshal checksum. This is likely to need padding. 		 */
name|len
operator|=
name|m_length
argument_list|(
name|mic
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|put_uint32
argument_list|(
operator|&
name|mic
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|RNDUP
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|m_append
argument_list|(
name|mic
argument_list|,
name|RNDUP
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|zpad
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Concatenate databody_integ with checksum. 		 */
name|m_cat
argument_list|(
name|args
argument_list|,
name|mic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svc
operator|==
name|rpc_gss_svc_privacy
condition|)
block|{
comment|/* Encrypt rpc_gss_data_t. */
name|maj_stat
operator|=
name|gss_wrap_mbuf
argument_list|(
operator|&
name|min_stat
argument_list|,
name|ctx
argument_list|,
name|TRUE
argument_list|,
name|qop
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|conf_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_wrap"
argument_list|,
name|NULL
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 *  Marshal databody_priv and deal with RPC padding. 		 */
name|len
operator|=
name|m_length
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|put_uint32
argument_list|(
operator|&
name|args
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|RNDUP
argument_list|(
name|len
argument_list|)
condition|)
block|{
name|m_append
argument_list|(
name|args
argument_list|,
name|RNDUP
argument_list|(
name|len
argument_list|)
operator|-
name|len
argument_list|,
name|zpad
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|argsp
operator|=
name|args
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|get_uint32
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|,
operator|&
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|ntohl
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|m_trim
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|off
decl_stmt|;
name|n
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_len
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|bool_t
name|xdr_rpc_gss_unwrap_data
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|resultsp
parameter_list|,
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|gss_qop_t
name|qop
parameter_list|,
name|rpc_gss_service_t
name|svc
parameter_list|,
name|u_int
name|seq
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|results
decl_stmt|,
modifier|*
name|message
decl_stmt|,
modifier|*
name|mic
decl_stmt|;
name|uint32_t
name|len
decl_stmt|,
name|cklen
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|u_int
name|seq_num
decl_stmt|,
name|conf_state
decl_stmt|,
name|qop_state
decl_stmt|;
name|results
operator|=
operator|*
name|resultsp
expr_stmt|;
operator|*
name|resultsp
operator|=
name|NULL
expr_stmt|;
name|message
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|svc
operator|==
name|rpc_gss_svc_integrity
condition|)
block|{
comment|/* 		 * Extract the seq+message part. Remember that there 		 * may be extra RPC padding in the checksum. The 		 * message part is RPC encoded already so no 		 * padding. 		 */
name|len
operator|=
name|get_uint32
argument_list|(
operator|&
name|results
argument_list|)
expr_stmt|;
name|message
operator|=
name|results
expr_stmt|;
name|results
operator|=
name|m_split
argument_list|(
name|results
argument_list|,
name|len
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|results
condition|)
block|{
name|m_freem
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
comment|/* 		 * Extract the MIC and make it contiguous. 		 */
name|cklen
operator|=
name|get_uint32
argument_list|(
operator|&
name|results
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cklen
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"unexpected large GSS-API checksum"
operator|)
argument_list|)
expr_stmt|;
name|mic
operator|=
name|results
expr_stmt|;
if|if
condition|(
name|cklen
operator|>
name|mic
operator|->
name|m_len
condition|)
name|mic
operator|=
name|m_pullup
argument_list|(
name|mic
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cklen
operator|!=
name|RNDUP
argument_list|(
name|cklen
argument_list|)
condition|)
name|m_trim
argument_list|(
name|mic
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
comment|/* Verify checksum and QOP. */
name|maj_stat
operator|=
name|gss_verify_mic_mbuf
argument_list|(
operator|&
name|min_stat
argument_list|,
name|ctx
argument_list|,
name|message
argument_list|,
name|mic
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mic
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|||
name|qop_state
operator|!=
name|qop
condition|)
block|{
name|m_freem
argument_list|(
name|message
argument_list|)
expr_stmt|;
name|rpc_gss_log_status
argument_list|(
literal|"gss_verify_mic"
argument_list|,
name|NULL
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|svc
operator|==
name|rpc_gss_svc_privacy
condition|)
block|{
comment|/* Decode databody_priv. */
name|len
operator|=
name|get_uint32
argument_list|(
operator|&
name|results
argument_list|)
expr_stmt|;
comment|/* Decrypt databody. */
name|message
operator|=
name|results
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|RNDUP
argument_list|(
name|len
argument_list|)
condition|)
name|m_trim
argument_list|(
name|message
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_unwrap_mbuf
argument_list|(
operator|&
name|min_stat
argument_list|,
name|ctx
argument_list|,
operator|&
name|message
argument_list|,
operator|&
name|conf_state
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
comment|/* Verify encryption and QOP. */
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_unwrap"
argument_list|,
name|NULL
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|qop_state
operator|!=
name|qop
operator|||
name|conf_state
operator|!=
name|TRUE
condition|)
block|{
name|m_freem
argument_list|(
name|results
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
comment|/* Decode rpc_gss_data_t (sequence number + arguments). */
name|seq_num
operator|=
name|get_uint32
argument_list|(
operator|&
name|message
argument_list|)
expr_stmt|;
comment|/* Verify sequence number. */
if|if
condition|(
name|seq_num
operator|!=
name|seq
condition|)
block|{
name|rpc_gss_log_debug
argument_list|(
literal|"wrong sequence number in databody"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|message
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
operator|*
name|resultsp
operator|=
name|message
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_function
name|void
name|rpc_gss_log_debug
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rpcsec_gss: "
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rpc_gss_log_status
parameter_list|(
specifier|const
name|char
modifier|*
name|m
parameter_list|,
name|gss_OID
name|mech
parameter_list|,
name|OM_uint32
name|maj_stat
parameter_list|,
name|OM_uint32
name|min_stat
parameter_list|)
block|{
name|OM_uint32
name|min
decl_stmt|;
name|gss_buffer_desc
name|msg
decl_stmt|;
name|int
name|msg_ctx
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"rpcsec_gss: %s: "
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|gss_display_status
argument_list|(
operator|&
name|min
argument_list|,
name|maj_stat
argument_list|,
name|GSS_C_GSS_CODE
argument_list|,
name|GSS_C_NULL_OID
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s - "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
operator|.
name|value
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|gss_display_status
argument_list|(
operator|&
name|min
argument_list|,
name|min_stat
argument_list|,
name|GSS_C_MECH_CODE
argument_list|,
name|mech
argument_list|,
operator|&
name|msg_ctx
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
operator|.
name|value
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|rpc_gss_log_debug
parameter_list|(
name|__unused
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|rpc_gss_log_status
parameter_list|(
name|__unused
specifier|const
name|char
modifier|*
name|m
parameter_list|,
name|__unused
name|gss_OID
name|mech
parameter_list|,
name|__unused
name|OM_uint32
name|maj_stat
parameter_list|,
name|__unused
name|OM_uint32
name|min_stat
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

