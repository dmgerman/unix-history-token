begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2008 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*   auth_gss.c    RPCSEC_GSS client routines.      Copyright (c) 2000 The Regents of the University of Michigan.   All rights reserved.    Copyright (c) 2000 Dug Song<dugsong@UMICH.EDU>.   All rights reserved, all wrongs reversed.    Redistribution and use in source and binary forms, with or without   modification, are permitted provided that the following conditions   are met:    1. Redistributions of source code must retain the above copyright      notice, this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright      notice, this list of conditions and the following disclaimer in the      documentation and/or other materials provided with the distribution.   3. Neither the name of the University nor the names of its      contributors may be used to endorse or promote products derived      from this software without specific prior written permission.    THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED   WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE   DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR   BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.    $Id: auth_gss.c,v 1.32 2002/01/15 15:43:00 andros Exp $ */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/krb5/kcrypto.h>
end_include

begin_include
include|#
directive|include
file|"rpcsec_gss_int.h"
end_include

begin_function_decl
specifier|static
name|void
name|rpc_gss_nextverf
parameter_list|(
name|AUTH
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_marshal
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|XDR
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_init
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_refresh
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|rpc_gss_validate
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|struct
name|opaque_auth
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpc_gss_destroy
parameter_list|(
name|AUTH
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpc_gss_destroy_context
parameter_list|(
name|AUTH
modifier|*
parameter_list|,
name|bool_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|auth_ops
name|rpc_gss_ops
init|=
block|{
name|rpc_gss_nextverf
block|,
name|rpc_gss_marshal
block|,
name|rpc_gss_validate
block|,
name|rpc_gss_refresh
block|,
name|rpc_gss_destroy
block|, }
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|rpcsec_gss_state
block|{
name|RPCSEC_GSS_START
block|,
name|RPCSEC_GSS_CONTEXT
block|,
name|RPCSEC_GSS_ESTABLISHED
block|,
name|RPCSEC_GSS_DESTROYING
block|}
enum|;
end_enum

begin_struct
struct|struct
name|rpc_pending_request
block|{
name|uint32_t
name|pr_xid
decl_stmt|;
comment|/* XID of rpc */
name|uint32_t
name|pr_seq
decl_stmt|;
comment|/* matching GSS seq */
name|LIST_ENTRY
argument_list|(
argument|rpc_pending_request
argument_list|)
name|pr_link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|rpc_pending_request_list
argument_list|,
name|rpc_pending_request
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|rpc_gss_data
block|{
specifier|volatile
name|u_int
name|gd_refs
decl_stmt|;
comment|/* number of current users */
name|struct
name|mtx
name|gd_lock
decl_stmt|;
name|uint32_t
name|gd_hash
decl_stmt|;
name|AUTH
modifier|*
name|gd_auth
decl_stmt|;
comment|/* link back to AUTH */
name|struct
name|ucred
modifier|*
name|gd_ucred
decl_stmt|;
comment|/* matching local cred */
name|char
modifier|*
name|gd_principal
decl_stmt|;
comment|/* server principal name */
name|char
modifier|*
name|gd_clntprincipal
decl_stmt|;
comment|/* client principal name */
name|rpc_gss_options_req_t
name|gd_options
decl_stmt|;
comment|/* GSS context options */
name|enum
name|rpcsec_gss_state
name|gd_state
decl_stmt|;
comment|/* connection state */
name|gss_buffer_desc
name|gd_verf
decl_stmt|;
comment|/* save GSS_S_COMPLETE 						 * NULL RPC verfier to 						 * process at end of 						 * context negotiation */
name|CLIENT
modifier|*
name|gd_clnt
decl_stmt|;
comment|/* client handle */
name|gss_OID
name|gd_mech
decl_stmt|;
comment|/* mechanism to use */
name|gss_qop_t
name|gd_qop
decl_stmt|;
comment|/* quality of protection */
name|gss_ctx_id_t
name|gd_ctx
decl_stmt|;
comment|/* context id */
name|struct
name|rpc_gss_cred
name|gd_cred
decl_stmt|;
comment|/* client credentials */
name|uint32_t
name|gd_seq
decl_stmt|;
comment|/* next sequence number */
name|u_int
name|gd_win
decl_stmt|;
comment|/* sequence window */
name|struct
name|rpc_pending_request_list
name|gd_reqs
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|rpc_gss_data
argument_list|)
name|gd_link
expr_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|rpc_gss_data
argument_list|)
name|gd_alllink
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|rpc_gss_data_list
argument_list|,
name|rpc_gss_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AUTH_PRIVATE
parameter_list|(
name|auth
parameter_list|)
value|((struct rpc_gss_data *)auth->ah_private)
end_define

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|AUTH_TIMEOUT
init|=
block|{
literal|25
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RPC_GSS_HASH_SIZE
value|11
end_define

begin_define
define|#
directive|define
name|RPC_GSS_MAX
value|256
end_define

begin_decl_stmt
specifier|static
name|struct
name|rpc_gss_data_list
name|rpc_gss_cache
index|[
name|RPC_GSS_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rpc_gss_data_list
name|rpc_gss_all
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|rpc_gss_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rpc_gss_count
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|AUTH
modifier|*
name|rpc_gss_seccreate_int
parameter_list|(
name|CLIENT
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|gss_OID
parameter_list|,
name|rpc_gss_service_t
parameter_list|,
name|u_int
parameter_list|,
name|rpc_gss_options_req_t
modifier|*
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rpc_gss_hashinit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RPC_GSS_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|rpc_gss_cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rpc_gss_all
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|,
literal|"rpc_gss_lock"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|rpc_gss_hashinit
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|rpc_gss_hashinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|rpc_gss_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
name|gss_OID
name|mech
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
name|h
operator|=
name|HASHSTEP
argument_list|(
name|HASHINIT
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
name|h
operator|=
name|hash32_str
argument_list|(
name|principal
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|hash32_buf
argument_list|(
name|mech
operator|->
name|elements
argument_list|,
name|mech
operator|->
name|length
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|h
operator|=
name|HASHSTEP
argument_list|(
name|h
argument_list|,
operator|(
name|int
operator|)
name|service
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|%
name|RPC_GSS_HASH_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simplified interface to create a security association for the  * current thread's * ucred.  */
end_comment

begin_function
name|AUTH
modifier|*
name|rpc_gss_secfind
parameter_list|(
name|CLIENT
modifier|*
name|clnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
name|gss_OID
name|mech_oid
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|,
name|th
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|,
modifier|*
name|tgd
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
if|if
condition|(
name|rpc_gss_count
operator|>
name|RPC_GSS_MAX
condition|)
block|{
while|while
condition|(
name|rpc_gss_count
operator|>
name|RPC_GSS_MAX
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|tgd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rpc_gss_all
argument_list|)
expr_stmt|;
name|th
operator|=
name|tgd
operator|->
name|gd_hash
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpc_gss_cache
index|[
name|th
index|]
argument_list|,
name|tgd
argument_list|,
name|gd_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpc_gss_all
argument_list|,
name|tgd
argument_list|,
name|gd_alllink
argument_list|)
expr_stmt|;
name|rpc_gss_count
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|tgd
operator|->
name|gd_auth
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * See if we already have an AUTH which matches. 	 */
name|h
operator|=
name|rpc_gss_hash
argument_list|(
name|principal
argument_list|,
name|mech_oid
argument_list|,
name|cred
argument_list|,
name|service
argument_list|)
expr_stmt|;
name|again
label|:
name|sx_slock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|gd
argument_list|,
argument|&rpc_gss_cache[h]
argument_list|,
argument|gd_link
argument_list|)
block|{
if|if
condition|(
name|gd
operator|->
name|gd_ucred
operator|->
name|cr_uid
operator|==
name|cred
operator|->
name|cr_uid
operator|&&
operator|!
name|strcmp
argument_list|(
name|gd
operator|->
name|gd_principal
argument_list|,
name|principal
argument_list|)
operator|&&
name|gd
operator|->
name|gd_mech
operator|==
name|mech_oid
operator|&&
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|service
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|gd
operator|->
name|gd_refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_try_upgrade
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
condition|)
block|{
comment|/* 				 * Keep rpc_gss_all LRU sorted. 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpc_gss_all
argument_list|,
name|gd
argument_list|,
name|gd_alllink
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rpc_gss_all
argument_list|,
name|gd
argument_list|,
name|gd_alllink
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sx_sunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If the state != ESTABLISHED, try and initialize 			 * the authenticator again. This will happen if the 			 * user's credentials have expired. It may succeed now, 			 * if they have done a kinit or similar. 			 */
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
condition|)
block|{
name|memset
argument_list|(
operator|&
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rpc_gss_init
argument_list|(
name|gd
operator|->
name|gd_auth
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|gd
operator|->
name|gd_auth
operator|)
return|;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We missed in the cache - create a new association. 	 */
name|auth
operator|=
name|rpc_gss_seccreate_int
argument_list|(
name|clnt
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
name|principal
argument_list|,
name|mech_oid
argument_list|,
name|service
argument_list|,
name|GSS_C_QOP_DEFAULT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|auth
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_hash
operator|=
name|h
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tgd
argument_list|,
argument|&rpc_gss_cache[h]
argument_list|,
argument|gd_link
argument_list|)
block|{
if|if
condition|(
name|tgd
operator|->
name|gd_ucred
operator|->
name|cr_uid
operator|==
name|cred
operator|->
name|cr_uid
operator|&&
operator|!
name|strcmp
argument_list|(
name|tgd
operator|->
name|gd_principal
argument_list|,
name|principal
argument_list|)
operator|&&
name|tgd
operator|->
name|gd_mech
operator|==
name|mech_oid
operator|&&
name|tgd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|service
condition|)
block|{
comment|/* 			 * We lost a race to create the AUTH that 			 * matches this cred. 			 */
name|sx_xunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
name|rpc_gss_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rpc_gss_cache
index|[
name|h
index|]
argument_list|,
name|gd
argument_list|,
name|gd_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rpc_gss_all
argument_list|,
name|gd
argument_list|,
name|gd_alllink
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|gd
operator|->
name|gd_refs
argument_list|)
expr_stmt|;
comment|/* one for the cache, one for user */
name|sx_xunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|auth
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rpc_gss_secpurge
parameter_list|(
name|CLIENT
modifier|*
name|clnt
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|,
modifier|*
name|tgd
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|gd
argument_list|,
argument|&rpc_gss_all
argument_list|,
argument|gd_alllink
argument_list|,
argument|tgd
argument_list|)
block|{
if|if
condition|(
name|gd
operator|->
name|gd_clnt
operator|==
name|clnt
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|h
operator|=
name|gd
operator|->
name|gd_hash
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpc_gss_cache
index|[
name|h
index|]
argument_list|,
name|gd
argument_list|,
name|gd_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpc_gss_all
argument_list|,
name|gd
argument_list|,
name|gd_alllink
argument_list|)
expr_stmt|;
name|rpc_gss_count
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|rpc_gss_lock
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|gd
operator|->
name|gd_auth
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|AUTH
modifier|*
name|rpc_gss_seccreate
parameter_list|(
name|CLIENT
modifier|*
name|clnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
specifier|const
name|char
modifier|*
name|clnt_principal
parameter_list|,
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
specifier|const
name|char
modifier|*
name|mechanism
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|qop
parameter_list|,
name|rpc_gss_options_req_t
modifier|*
name|options_req
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
block|{
name|gss_OID
name|oid
decl_stmt|;
name|u_int
name|qop_num
decl_stmt|;
comment|/* 	 * Bail out now if we don't know this mechanism. 	 */
if|if
condition|(
operator|!
name|rpc_gss_mech_to_oid
argument_list|(
name|mechanism
argument_list|,
operator|&
name|oid
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|qop
condition|)
block|{
if|if
condition|(
operator|!
name|rpc_gss_qop_to_num
argument_list|(
name|qop
argument_list|,
name|mechanism
argument_list|,
operator|&
name|qop_num
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|qop_num
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
block|}
return|return
operator|(
name|rpc_gss_seccreate_int
argument_list|(
name|clnt
argument_list|,
name|cred
argument_list|,
name|clnt_principal
argument_list|,
name|principal
argument_list|,
name|oid
argument_list|,
name|service
argument_list|,
name|qop_num
argument_list|,
name|options_req
argument_list|,
name|options_ret
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rpc_gss_refresh_auth
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
comment|/* 	 * If the state != ESTABLISHED, try and initialize 	 * the authenticator again. This will happen if the 	 * user's credentials have expired. It may succeed now, 	 * if they have done a kinit or similar. 	 */
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
condition|)
block|{
name|memset
argument_list|(
operator|&
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|rpc_gss_init
argument_list|(
name|auth
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|AUTH
modifier|*
name|rpc_gss_seccreate_int
parameter_list|(
name|CLIENT
modifier|*
name|clnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
specifier|const
name|char
modifier|*
name|clnt_principal
parameter_list|,
specifier|const
name|char
modifier|*
name|principal
parameter_list|,
name|gss_OID
name|mech_oid
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|,
name|u_int
name|qop_num
parameter_list|,
name|rpc_gss_options_req_t
modifier|*
name|options_req
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
block|{
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
comment|/* 	 * If the caller doesn't want the options, point at local 	 * storage to simplify the code below. 	 */
if|if
condition|(
operator|!
name|options_ret
condition|)
name|options_ret
operator|=
operator|&
name|options
expr_stmt|;
comment|/* 	 * Default service is integrity. 	 */
if|if
condition|(
name|service
operator|==
name|rpc_gss_svc_default
condition|)
name|service
operator|=
name|rpc_gss_svc_integrity
expr_stmt|;
name|memset
argument_list|(
name|options_ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|options_ret
argument_list|)
argument_list|)
expr_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_seccreate()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rpc_createerr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rpc_createerr
argument_list|)
argument_list|)
expr_stmt|;
name|auth
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gd
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|==
name|NULL
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|ENOMEM
expr_stmt|;
name|mem_free
argument_list|(
name|auth
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|auth
operator|->
name|ah_ops
operator|=
operator|&
name|rpc_gss_ops
expr_stmt|;
name|auth
operator|->
name|ah_private
operator|=
operator|(
name|caddr_t
operator|)
name|gd
expr_stmt|;
name|auth
operator|->
name|ah_cred
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|gd
operator|->
name|gd_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|,
literal|"gd->gd_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_auth
operator|=
name|auth
expr_stmt|;
name|gd
operator|->
name|gd_ucred
operator|=
name|crdup
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_principal
operator|=
name|strdup
argument_list|(
name|principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|clnt_principal
operator|!=
name|NULL
condition|)
name|gd
operator|->
name|gd_clntprincipal
operator|=
name|strdup
argument_list|(
name|clnt_principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
else|else
name|gd
operator|->
name|gd_clntprincipal
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|options_req
condition|)
block|{
name|gd
operator|->
name|gd_options
operator|=
operator|*
name|options_req
expr_stmt|;
block|}
else|else
block|{
name|gd
operator|->
name|gd_options
operator|.
name|req_flags
operator|=
name|GSS_C_MUTUAL_FLAG
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|time_req
operator|=
literal|0
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
operator|=
name|GSS_C_NO_CREDENTIAL
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|input_channel_bindings
operator|=
name|NULL
expr_stmt|;
block|}
name|CLNT_ACQUIRE
argument_list|(
name|clnt
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_clnt
operator|=
name|clnt
expr_stmt|;
name|gd
operator|->
name|gd_ctx
operator|=
name|GSS_C_NO_CONTEXT
expr_stmt|;
name|gd
operator|->
name|gd_mech
operator|=
name|mech_oid
expr_stmt|;
name|gd
operator|->
name|gd_qop
operator|=
name|qop_num
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_version
operator|=
name|RPCSEC_GSS_VERSION
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_INIT
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|=
literal|0
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|=
name|service
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|gd
operator|->
name|gd_reqs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_init
argument_list|(
name|auth
argument_list|,
name|options_ret
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
return|return
operator|(
name|auth
operator|)
return|;
name|bad
label|:
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|bool_t
name|rpc_gss_set_defaults
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_service_t
name|service
parameter_list|,
specifier|const
name|char
modifier|*
name|qop
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|u_int
name|qop_num
decl_stmt|;
specifier|const
name|char
modifier|*
name|mechanism
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rpc_gss_oid_to_mech
argument_list|(
name|gd
operator|->
name|gd_mech
argument_list|,
operator|&
name|mechanism
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|qop
condition|)
block|{
if|if
condition|(
operator|!
name|rpc_gss_qop_to_num
argument_list|(
name|qop
argument_list|,
name|mechanism
argument_list|,
operator|&
name|qop_num
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
else|else
block|{
name|qop_num
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
block|}
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|=
name|service
expr_stmt|;
name|gd
operator|->
name|gd_qop
operator|=
name|qop_num
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_purge_xid
parameter_list|(
name|struct
name|rpc_gss_data
modifier|*
name|gd
parameter_list|,
name|uint32_t
name|xid
parameter_list|)
block|{
name|struct
name|rpc_pending_request
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
name|struct
name|rpc_pending_request_list
name|reqs
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|reqs
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&gd->gd_reqs
argument_list|,
argument|pr_link
argument_list|,
argument|npr
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_xid
operator|==
name|xid
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|reqs
argument_list|,
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&reqs
argument_list|,
argument|pr_link
argument_list|,
argument|npr
argument_list|)
block|{
name|mem_free
argument_list|(
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|rpc_gss_alloc_seq
parameter_list|(
name|struct
name|rpc_gss_data
modifier|*
name|gd
parameter_list|)
block|{
name|uint32_t
name|seq
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|seq
operator|=
name|gd
operator|->
name|gd_seq
expr_stmt|;
name|gd
operator|->
name|gd_seq
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|seq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_nextverf
parameter_list|(
name|__unused
name|AUTH
modifier|*
name|auth
parameter_list|)
block|{
comment|/* not used */
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_marshal
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|uint32_t
name|xid
parameter_list|,
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|struct
name|mbuf
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|struct
name|rpc_pending_request
modifier|*
name|pr
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|XDR
name|tmpxdrs
decl_stmt|;
name|struct
name|rpc_gss_cred
name|gsscred
decl_stmt|;
name|char
name|credbuf
index|[
name|MAX_AUTH_BYTES
index|]
decl_stmt|;
name|struct
name|opaque_auth
name|creds
decl_stmt|,
name|verf
decl_stmt|;
name|gss_buffer_desc
name|rpcbuf
decl_stmt|,
name|checksum
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|bool_t
name|xdr_stat
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_marshal()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|gsscred
operator|=
name|gd
operator|->
name|gd_cred
expr_stmt|;
name|seq
operator|=
name|rpc_gss_alloc_seq
argument_list|(
name|gd
argument_list|)
expr_stmt|;
name|gsscred
operator|.
name|gc_seq
operator|=
name|seq
expr_stmt|;
name|xdrmem_create
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
name|credbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|credbuf
argument_list|)
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_rpc_gss_cred
argument_list|(
operator|&
name|tmpxdrs
argument_list|,
operator|&
name|gsscred
argument_list|)
condition|)
block|{
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|creds
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|creds
operator|.
name|oa_base
operator|=
name|credbuf
expr_stmt|;
name|creds
operator|.
name|oa_length
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|XDR_DESTROY
argument_list|(
operator|&
name|tmpxdrs
argument_list|)
expr_stmt|;
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
name|creds
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_INIT
operator|||
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|==
name|RPCSEC_GSS_CONTINUE_INIT
condition|)
block|{
if|if
condition|(
operator|!
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
name|_null_auth
argument_list|)
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|xdrmbuf_append
argument_list|(
name|xdrs
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Keep track of this XID + seq pair so that we can do 		 * the matching gss_verify_mic in AUTH_VALIDATE. 		 */
name|pr
operator|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rpc_pending_request
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|pr
operator|->
name|pr_xid
operator|=
name|xid
expr_stmt|;
name|pr
operator|->
name|pr_seq
operator|=
name|seq
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|gd
operator|->
name|gd_reqs
argument_list|,
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Checksum serialized RPC header, up to and including 		 * credential. For the in-kernel environment, we 		 * assume that our XDR stream is on a contiguous 		 * memory buffer (e.g. an mbuf). 		 */
name|rpcbuf
operator|.
name|length
operator|=
name|XDR_GETPOS
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
name|XDR_SETPOS
argument_list|(
name|xdrs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rpcbuf
operator|.
name|value
operator|=
name|XDR_INLINE
argument_list|(
name|xdrs
argument_list|,
name|rpcbuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_get_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
operator|&
name|rpcbuf
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_get_mic"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|verf
operator|.
name|oa_flavor
operator|=
name|RPCSEC_GSS
expr_stmt|;
name|verf
operator|.
name|oa_base
operator|=
name|checksum
operator|.
name|value
expr_stmt|;
name|verf
operator|.
name|oa_length
operator|=
name|checksum
operator|.
name|length
expr_stmt|;
name|xdr_stat
operator|=
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
name|verf
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_stat
condition|)
block|{
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
operator|||
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|rpc_gss_svc_none
condition|)
block|{
name|xdrmbuf_append
argument_list|(
name|xdrs
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xdr_rpc_gss_wrap_data
argument_list|(
operator|&
name|args
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
argument_list|,
name|seq
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|xdrmbuf_append
argument_list|(
name|xdrs
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_validate
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|uint32_t
name|xid
parameter_list|,
name|struct
name|opaque_auth
modifier|*
name|verf
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|resultsp
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|struct
name|rpc_pending_request
modifier|*
name|pr
decl_stmt|,
modifier|*
name|npr
decl_stmt|;
name|struct
name|rpc_pending_request_list
name|reqs
decl_stmt|;
name|gss_qop_t
name|qop_state
decl_stmt|;
name|uint32_t
name|num
decl_stmt|,
name|seq
decl_stmt|;
name|gss_buffer_desc
name|signbuf
decl_stmt|,
name|checksum
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_validate()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
comment|/* 	 * The client will call us with a NULL verf when it gives up 	 * on an XID. 	 */
if|if
condition|(
operator|!
name|verf
condition|)
block|{
name|rpc_gss_purge_xid
argument_list|(
name|gd
argument_list|,
name|xid
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_CONTEXT
condition|)
block|{
comment|/* 		 * Save the on the wire verifier to validate last INIT 		 * phase packet after decode if the major status is 		 * GSS_S_COMPLETE. 		 */
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
condition|)
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_verf
operator|.
name|value
operator|=
name|mem_alloc
argument_list|(
name|verf
operator|->
name|oa_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"gss_validate: out of memory\n"
argument_list|)
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|resultsp
argument_list|)
expr_stmt|;
operator|*
name|resultsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
argument_list|,
name|verf
operator|->
name|oa_base
argument_list|,
name|verf
operator|->
name|oa_length
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_verf
operator|.
name|length
operator|=
name|verf
operator|->
name|oa_length
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
comment|/* 	 * We need to check the verifier against all the requests 	 * we've send for this XID - for unreliable protocols, we 	 * retransmit with the same XID but different sequence 	 * number. We temporarily take this set of requests out of the 	 * list so that we can work through the list without having to 	 * hold the lock. 	 */
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|reqs
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&gd->gd_reqs
argument_list|,
argument|pr_link
argument_list|,
argument|npr
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_xid
operator|==
name|xid
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|reqs
argument_list|,
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&reqs
argument_list|,
argument|pr_link
argument_list|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_xid
operator|==
name|xid
condition|)
block|{
name|seq
operator|=
name|pr
operator|->
name|pr_seq
expr_stmt|;
name|num
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|signbuf
operator|.
name|value
operator|=
operator|&
name|num
expr_stmt|;
name|signbuf
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|checksum
operator|.
name|value
operator|=
name|verf
operator|->
name|oa_base
expr_stmt|;
name|checksum
operator|.
name|length
operator|=
name|verf
operator|->
name|oa_length
expr_stmt|;
name|maj_stat
operator|=
name|gss_verify_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
operator|&
name|signbuf
argument_list|,
operator|&
name|checksum
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|||
name|qop_state
operator|!=
name|gd
operator|->
name|gd_qop
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|//rpc_gss_purge_reqs(gd, seq);
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&reqs
argument_list|,
argument|pr_link
argument_list|,
argument|npr
argument_list|)
name|mem_free
argument_list|(
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
operator|==
name|rpc_gss_svc_none
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xdr_rpc_gss_unwrap_data
argument_list|(
name|resultsp
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
argument_list|,
name|seq
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
block|}
comment|/* 	 * We didn't match - put back any entries for this XID so that 	 * a future call to validate can retry. 	 */
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pr
argument_list|,
argument|&reqs
argument_list|,
argument|pr_link
argument_list|,
argument|npr
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|gd
operator|->
name|gd_reqs
argument_list|,
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing matches - give up. 	 */
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|resultsp
argument_list|)
expr_stmt|;
operator|*
name|resultsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_init
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|rpc_gss_options_ret_t
modifier|*
name|options_ret
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|crsave
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|struct
name|rpc_gss_init_res
name|gr
decl_stmt|;
name|gss_buffer_desc
name|principal_desc
decl_stmt|;
name|gss_buffer_desc
modifier|*
name|recv_tokenp
decl_stmt|,
name|recv_token
decl_stmt|,
name|send_token
decl_stmt|;
name|gss_name_t
name|name
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|,
name|call_stat
decl_stmt|;
specifier|const
name|char
modifier|*
name|mech
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|gss_OID
name|mech_oid
decl_stmt|;
name|gss_OID_set
name|mechlist
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_refresh()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the context isn't in START state, someone else is 	 * refreshing - we wait till they are done. If they fail, they 	 * will put the state back to START and we can try (most 	 * likely to also fail). 	 */
while|while
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_START
operator|&&
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
condition|)
block|{
name|msleep
argument_list|(
name|gd
argument_list|,
operator|&
name|gd
operator|->
name|gd_lock
argument_list|,
literal|0
argument_list|,
literal|"gssstate"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_ESTABLISHED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_CONTEXT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_INIT
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_seq
operator|=
literal|0
expr_stmt|;
comment|/* 	 * For KerberosV, if there is a client principal name, that implies 	 * that this is a host based initiator credential in the default 	 * keytab file. For this case, it is necessary to do a 	 * gss_acquire_cred(). When this is done, the gssd daemon will 	 * do the equivalent of "kinit -k" to put a TGT for the name in 	 * the credential cache file for the gssd daemon. 	 */
if|if
condition|(
name|gd
operator|->
name|gd_clntprincipal
operator|!=
name|NULL
operator|&&
name|rpc_gss_mech_to_oid
argument_list|(
literal|"kerberosv5"
argument_list|,
operator|&
name|mech_oid
argument_list|)
operator|&&
name|gd
operator|->
name|gd_mech
operator|==
name|mech_oid
condition|)
block|{
comment|/* Get rid of any old credential. */
if|if
condition|(
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
operator|!=
name|GSS_C_NO_CREDENTIAL
condition|)
block|{
name|gss_release_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
operator|=
name|GSS_C_NO_CREDENTIAL
expr_stmt|;
block|}
comment|/* 		 * The mechanism must be set to KerberosV for acquisition 		 * of credentials to work reliably. 		 */
name|maj_stat
operator|=
name|gss_create_empty_oid_set
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|maj_stat
operator|=
name|gss_add_oid_set_member
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
name|gss_release_oid_set
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|principal_desc
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|gd
operator|->
name|gd_clntprincipal
expr_stmt|;
name|principal_desc
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|gd
operator|->
name|gd_clntprincipal
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|principal_desc
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
name|gss_release_oid_set
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Acquire the credentials. */
name|maj_stat
operator|=
name|gss_acquire_cred
argument_list|(
operator|&
name|min_stat
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|mechlist
argument_list|,
name|GSS_C_INITIATE
argument_list|,
operator|&
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|gss_release_oid_set
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|mechlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|principal_desc
operator|.
name|value
operator|=
operator|(
name|void
operator|*
operator|)
name|gd
operator|->
name|gd_principal
expr_stmt|;
name|principal_desc
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|gd
operator|->
name|gd_principal
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_import_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|principal_desc
argument_list|,
name|GSS_C_NT_HOSTBASED_SERVICE
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
condition|)
block|{
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* GSS context establishment loop. */
name|memset
argument_list|(
operator|&
name|recv_token
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|recv_token
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|options_ret
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|options_ret
argument_list|)
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|GSS_S_FAILURE
expr_stmt|;
name|recv_tokenp
operator|=
name|GSS_C_NO_BUFFER
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|crsave
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|gd
operator|->
name|gd_ucred
expr_stmt|;
name|maj_stat
operator|=
name|gss_init_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|my_cred
argument_list|,
operator|&
name|gd
operator|->
name|gd_ctx
argument_list|,
name|name
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|req_flags
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|time_req
argument_list|,
name|gd
operator|->
name|gd_options
operator|.
name|input_channel_bindings
argument_list|,
name|recv_tokenp
argument_list|,
operator|&
name|gd
operator|->
name|gd_mech
argument_list|,
comment|/* used mech */
operator|&
name|send_token
argument_list|,
operator|&
name|options_ret
operator|->
name|ret_flags
argument_list|,
operator|&
name|options_ret
operator|->
name|time_req
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|crsave
expr_stmt|;
comment|/* 		 * Free the token which we got from the server (if 		 * any).  Remember that this was allocated by XDR, not 		 * GSS-API. 		 */
if|if
condition|(
name|recv_tokenp
operator|!=
name|GSS_C_NO_BUFFER
condition|)
block|{
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|recv_token
argument_list|)
expr_stmt|;
name|recv_tokenp
operator|=
name|GSS_C_NO_BUFFER
expr_stmt|;
block|}
if|if
condition|(
name|gd
operator|->
name|gd_mech
operator|&&
name|rpc_gss_oid_to_mech
argument_list|(
name|gd
operator|->
name|gd_mech
argument_list|,
operator|&
name|mech
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|options_ret
operator|->
name|actual_mechanism
argument_list|,
name|mech
argument_list|,
sizeof|sizeof
argument_list|(
name|options_ret
operator|->
name|actual_mechanism
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|maj_stat
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_init_sec_context"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|send_token
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|gr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gr
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|auth
expr_stmt|;
name|call_stat
operator|=
name|CLNT_CALL_EXT
argument_list|(
name|gd
operator|->
name|gd_clnt
argument_list|,
operator|&
name|ext
argument_list|,
name|NULLPROC
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|&
name|send_token
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rpc_gss_init_res
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|gr
argument_list|,
name|AUTH_TIMEOUT
argument_list|)
expr_stmt|;
name|gss_release_buffer
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|send_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_stat
operator|!=
name|RPC_SUCCESS
condition|)
break|break;
if|if
condition|(
name|gr
operator|.
name|gr_major
operator|!=
name|GSS_S_COMPLETE
operator|&&
name|gr
operator|.
name|gr_major
operator|!=
name|GSS_S_CONTINUE_NEEDED
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"server reply"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|gr
operator|.
name|gr_major
argument_list|,
name|gr
operator|.
name|gr_minor
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|gr
operator|.
name|gr_major
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|gr
operator|.
name|gr_minor
expr_stmt|;
break|break;
block|}
comment|/* 			 * Save the server's gr_handle value, freeing 			 * what we have already (remember that this 			 * was allocated by XDR, not GSS-API). 			 */
if|if
condition|(
name|gr
operator|.
name|gr_handle
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
operator|=
name|gr
operator|.
name|gr_handle
expr_stmt|;
block|}
comment|/* 			 * Save the server's token as well. 			 */
if|if
condition|(
name|gr
operator|.
name|gr_token
operator|.
name|length
operator|!=
literal|0
condition|)
block|{
name|recv_token
operator|=
name|gr
operator|.
name|gr_token
expr_stmt|;
name|recv_tokenp
operator|=
operator|&
name|recv_token
expr_stmt|;
block|}
comment|/* 			 * Since we have copied out all the bits of gr 			 * which XDR allocated for us, we don't need 			 * to free it. 			 */
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_CONTINUE_INIT
expr_stmt|;
block|}
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|gss_buffer_desc
name|bufin
decl_stmt|;
name|u_int
name|seq
decl_stmt|,
name|qop_state
init|=
literal|0
decl_stmt|;
comment|/*  			 * gss header verifier, 			 * usually checked in gss_validate 			 */
name|seq
operator|=
name|htonl
argument_list|(
name|gr
operator|.
name|gr_win
argument_list|)
expr_stmt|;
name|bufin
operator|.
name|value
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|seq
expr_stmt|;
name|bufin
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|maj_stat
operator|=
name|gss_verify_mic
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
operator|&
name|bufin
argument_list|,
operator|&
name|gd
operator|->
name|gd_verf
argument_list|,
operator|&
name|qop_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|!=
name|GSS_S_COMPLETE
operator|||
name|qop_state
operator|!=
name|gd
operator|->
name|gd_qop
condition|)
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_verify_mic"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_CONTEXT_EXPIRED
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
name|options_ret
operator|->
name|major_status
operator|=
name|maj_stat
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
name|min_stat
expr_stmt|;
break|break;
block|}
name|options_ret
operator|->
name|major_status
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
name|options_ret
operator|->
name|minor_status
operator|=
literal|0
expr_stmt|;
name|options_ret
operator|->
name|rpcsec_version
operator|=
name|gd
operator|->
name|gd_cred
operator|.
name|gc_version
expr_stmt|;
name|options_ret
operator|->
name|gss_context
operator|=
name|gd
operator|->
name|gd_ctx
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_DATA
expr_stmt|;
name|gd
operator|->
name|gd_seq
operator|=
literal|1
expr_stmt|;
name|gd
operator|->
name|gd_win
operator|=
name|gr
operator|.
name|gr_win
expr_stmt|;
break|break;
block|}
block|}
name|gss_release_name
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* End context negotiation loop. */
if|if
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|!=
name|RPCSEC_GSS_DATA
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_AUTHERROR
expr_stmt|;
name|_rpc_gss_set_error
argument_list|(
name|RPC_GSS_ER_SYSTEMERROR
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_ctx
condition|)
block|{
name|gss_delete_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gd
operator|->
name|gd_ctx
argument_list|,
name|GSS_C_NO_BUFFER
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_START
expr_stmt|;
name|wakeup
argument_list|(
name|gd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_ESTABLISHED
expr_stmt|;
name|wakeup
argument_list|(
name|gd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|rpc_gss_refresh
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|void
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|rpc_msg
modifier|*
name|reply
init|=
operator|(
expr|struct
name|rpc_msg
operator|*
operator|)
name|msg
decl_stmt|;
name|rpc_gss_options_ret_t
name|options
decl_stmt|;
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
comment|/* 	 * If the context is in DESTROYING state, then just return, since 	 * there is no point in refreshing the credentials. 	 */
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|==
name|RPCSEC_GSS_DESTROYING
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the error was RPCSEC_GSS_CREDPROBLEM of 	 * RPCSEC_GSS_CTXPROBLEM we start again from scratch. All 	 * other errors are fatal. 	 */
if|if
condition|(
name|reply
operator|->
name|rm_reply
operator|.
name|rp_stat
operator|==
name|MSG_DENIED
operator|&&
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_stat
operator|==
name|AUTH_ERROR
operator|&&
operator|(
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_why
operator|==
name|RPCSEC_GSS_CREDPROBLEM
operator|||
name|reply
operator|->
name|rm_reply
operator|.
name|rp_rjct
operator|.
name|rj_why
operator|==
name|RPCSEC_GSS_CTXPROBLEM
operator|)
condition|)
block|{
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|options
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|options
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|rpc_gss_init
argument_list|(
name|auth
argument_list|,
operator|&
name|options
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_destroy_context
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|bool_t
name|send_destroy
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|struct
name|rpc_pending_request
modifier|*
name|pr
decl_stmt|;
name|OM_uint32
name|min_stat
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_destroy_context()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the context isn't in ESTABISHED state, someone else is 	 * destroying/refreshing - we wait till they are done. 	 */
if|if
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
condition|)
block|{
while|while
condition|(
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_START
operator|&&
name|gd
operator|->
name|gd_state
operator|!=
name|RPCSEC_GSS_ESTABLISHED
condition|)
name|msleep
argument_list|(
name|gd
argument_list|,
operator|&
name|gd
operator|->
name|gd_lock
argument_list|,
literal|0
argument_list|,
literal|"gssstate"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_DESTROYING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_destroy
condition|)
block|{
name|gd
operator|->
name|gd_cred
operator|.
name|gc_proc
operator|=
name|RPCSEC_GSS_DESTROY
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ext
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|auth
expr_stmt|;
name|CLNT_CALL_EXT
argument_list|(
name|gd
operator|->
name|gd_clnt
argument_list|,
operator|&
name|ext
argument_list|,
name|NULLPROC
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_void
argument_list|,
name|NULL
argument_list|,
name|AUTH_TIMEOUT
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gd
operator|->
name|gd_reqs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pr
argument_list|,
name|pr_link
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|pr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Free the context token. Remember that this was 	 * allocated by XDR, not GSS-API. 	 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_cred
operator|.
name|gc_handle
operator|.
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_ctx
operator|!=
name|GSS_C_NO_CONTEXT
condition|)
name|gss_delete_sec_context
argument_list|(
operator|&
name|min_stat
argument_list|,
operator|&
name|gd
operator|->
name|gd_ctx
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|gd
operator|->
name|gd_state
operator|=
name|RPCSEC_GSS_START
expr_stmt|;
name|wakeup
argument_list|(
name|gd
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpc_gss_destroy
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|rpc_gss_log_debug
argument_list|(
literal|"in rpc_gss_destroy()"
argument_list|)
expr_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|gd
operator|->
name|gd_refs
argument_list|)
condition|)
return|return;
name|rpc_gss_destroy_context
argument_list|(
name|auth
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|gd
operator|->
name|gd_clnt
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|gd
operator|->
name|gd_ucred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gd
operator|->
name|gd_principal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_clntprincipal
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|gd
operator|->
name|gd_clntprincipal
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|gd
operator|->
name|gd_verf
operator|.
name|value
condition|)
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_gss_buffer_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gd
operator|->
name|gd_verf
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|gd
operator|->
name|gd_lock
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|gd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gd
argument_list|)
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|auth
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rpc_gss_max_data_length
parameter_list|(
name|AUTH
modifier|*
name|auth
parameter_list|,
name|int
name|max_tp_unit_len
parameter_list|)
block|{
name|struct
name|rpc_gss_data
modifier|*
name|gd
decl_stmt|;
name|int
name|want_conf
decl_stmt|;
name|OM_uint32
name|max
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|,
name|min_stat
decl_stmt|;
name|int
name|result
decl_stmt|;
name|gd
operator|=
name|AUTH_PRIVATE
argument_list|(
name|auth
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gd
operator|->
name|gd_cred
operator|.
name|gc_svc
condition|)
block|{
case|case
name|rpc_gss_svc_none
case|:
return|return
operator|(
name|max_tp_unit_len
operator|)
return|;
break|break;
case|case
name|rpc_gss_svc_default
case|:
case|case
name|rpc_gss_svc_integrity
case|:
name|want_conf
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
name|rpc_gss_svc_privacy
case|:
name|want_conf
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|maj_stat
operator|=
name|gss_wrap_size_limit
argument_list|(
operator|&
name|min_stat
argument_list|,
name|gd
operator|->
name|gd_ctx
argument_list|,
name|want_conf
argument_list|,
name|gd
operator|->
name|gd_qop
argument_list|,
name|max_tp_unit_len
argument_list|,
operator|&
name|max
argument_list|)
expr_stmt|;
if|if
condition|(
name|maj_stat
operator|==
name|GSS_S_COMPLETE
condition|)
block|{
name|result
operator|=
operator|(
name|int
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|rpc_gss_log_status
argument_list|(
literal|"gss_wrap_size_limit"
argument_list|,
name|gd
operator|->
name|gd_mech
argument_list|,
name|maj_stat
argument_list|,
name|min_stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

