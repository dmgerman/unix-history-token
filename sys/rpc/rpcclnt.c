begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* $Id: rpcclnt.c,v 1.9 2003/11/05 14:59:03 rees Exp $ */
end_comment

begin_comment
comment|/*-  * copyright (c) 2003  * the regents of the university of michigan  * all rights reserved  *   * permission is granted to use, copy, create derivative works and redistribute  * this software and such derivative works for any purpose, so long as the name  * of the university of michigan is not used in any advertising or publicity  * pertaining to the use or distribution of this software without specific,  * written prior authorization.  if the above copyright notice or any other  * identification of the university of michigan is included in any copy of any  * portion of this software, then the disclaimer below must also be included.  *   * this software is provided as is, without representation from the university  * of michigan as to its fitness for any purpose, and without warranty by the  * university of michigan of any kind, either express or implied, including  * without limitation the implied warranties of merchantability and fitness for  * a particular purpose. the regents of the university of michigan shall not be  * liable for any damages, including special, indirect, incidental, or  * consequential damages, with respect to any claim arising out of or in  * connection with the use of the software, even if it has been or is hereafter  * advised of the possibility of such damages.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1989, 1991, 1993, 1995 The Regents of the University of  * California.  All rights reserved.  *   * This code is derived from software contributed to Berkeley by Rick Macklem at  * The University of Guelph.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met: 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer. 2.  * Redistributions in binary form must reproduce the above copyright notice,  * this list of conditions and the following disclaimer in the documentation  * and/or other materials provided with the distribution. 3. All advertising  * materials mentioning features or use of this software must display the  * following acknowledgement: This product includes software developed by the  * University of California, Berkeley and its contributors. 4. Neither the  * name of the University nor the names of its contributors may be used to  * endorse or promote products derived from this software without specific  * prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * @(#)nfs_socket.c	8.5 (Berkeley) 3/30/95  */
end_comment

begin_comment
comment|/* XXX: kill ugly debug strings */
end_comment

begin_comment
comment|/* XXX: get rid of proct, as it is not even being used... (or keep it so v{2,3}  *      can run, but clean it up! */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<nfs/rpcv2.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcm_subs.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcclnt.h>
end_include

begin_comment
comment|/* memory management */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_decl_stmt
name|struct
name|pool
name|rpctask_pool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pool
name|rpcclnt_pool
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RPCTASKPOOL_LWM
value|10
end_define

begin_define
define|#
directive|define
name|RPCTASKPOOL_HWM
value|40
end_define

begin_else
else|#
directive|else
end_else

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_RPC
argument_list|,
literal|"rpcclnt"
argument_list|,
literal|"rpc state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|RPC_RETURN
parameter_list|(
name|X
parameter_list|)
value|do { RPCDEBUG("returning %d", X); return X; }while(0)
end_define

begin_comment
comment|/*  * Estimate rto for an nfs rpc sent via. an unreliable datagram. Use the mean  * and mean deviation of rtt for the appropriate type of rpc for the frequent  * rpcs and a default for the others. The justification for doing "other"  * this way is that these rpcs happen so infrequently that timer est. would  * probably be stale. Also, since many of these rpcs are non-idempotent, a  * conservative timeout is desired. getattr, lookup - A+2D read, write     -  * A+4D other           - nm_timeo  */
end_comment

begin_define
define|#
directive|define
name|RPC_RTO
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|((t) == 0 ? (n)->rc_timeo : \ 	 ((t)< 3 ? \ 	  (((((n)->rc_srtt[t-1] + 3)>> 2) + (n)->rc_sdrtt[t-1] + 1)>> 1) : \ 	  ((((n)->rc_srtt[t-1] + 7)>> 3) + (n)->rc_sdrtt[t-1] + 1)))
end_define

begin_define
define|#
directive|define
name|RPC_SRTT
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
value|(r)->r_rpcclnt->rc_srtt[rpcclnt_proct((s),\ 				(r)->r_procnum) - 1]
end_define

begin_define
define|#
directive|define
name|RPC_SDRTT
parameter_list|(
name|s
parameter_list|,
name|r
parameter_list|)
value|(r)->r_rpcclnt->rc_sdrtt[rpcclnt_proct((s),\ 				(r)->r_procnum) - 1]
end_define

begin_comment
comment|/*  * There is a congestion window for outstanding rpcs maintained per mount  * point. The cwnd size is adjusted in roughly the way that: Van Jacobson,  * Congestion avoidance and Control, In "Proceedings of SIGCOMM '88". ACM,  * August 1988. describes for TCP. The cwnd size is chopped in half on a  * retransmit timeout and incremented by 1/cwnd when each rpc reply is  * received and a full cwnd of rpcs is in progress. (The sent count and cwnd  * are scaled for integer arith.) Variants of "slow start" were tried and  * were found to be too much of a performance hit (ave. rtt 3 times larger),  * I suspect due to the large rtt that nfs rpcs have.  */
end_comment

begin_define
define|#
directive|define
name|RPC_CWNDSCALE
value|256
end_define

begin_define
define|#
directive|define
name|RPC_MAXCWND
value|(RPC_CWNDSCALE * 32)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|rpcclnt_backoff
index|[
literal|8
index|]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|128
block|,
literal|256
block|,}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX ugly debug strings */
end_comment

begin_define
define|#
directive|define
name|RPC_ERRSTR_ACCEPTED_SIZE
value|6
end_define

begin_decl_stmt
name|char
modifier|*
name|rpc_errstr_accepted
index|[
name|RPC_ERRSTR_ACCEPTED_SIZE
index|]
init|=
block|{
literal|""
block|,
comment|/* no good message... */
literal|"remote server hasn't exported program."
block|,
literal|"remote server can't support version number."
block|,
literal|"program can't support procedure."
block|,
literal|"procedure can't decode params."
block|,
literal|"remote error.  remote side memory allocation failure?"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rpc_errstr_denied
index|[
literal|2
index|]
init|=
block|{
literal|"remote server doesnt support rpc version 2!"
block|,
literal|"remote server authentication error."
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|RPC_ERRSTR_AUTH_SIZE
value|6
end_define

begin_decl_stmt
name|char
modifier|*
name|rpc_errstr_auth
index|[
name|RPC_ERRSTR_AUTH_SIZE
index|]
init|=
block|{
literal|""
block|,
literal|"auth error: bad credential (seal broken)."
block|,
literal|"auth error: client must begin new session."
block|,
literal|"auth error: bad verifier (seal broken)."
block|,
literal|"auth error: verifier expired or replayed."
block|,
literal|"auth error: rejected for security reasons."
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Static data, mostly RPC constants in XDR form  */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|rpc_reply
decl_stmt|,
name|rpc_call
decl_stmt|,
name|rpc_vers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * rpc_msgdenied, rpc_mismatch, rpc_auth_unix, rpc_msgaccepted,  * rpc_autherr, rpc_auth_kerb;  */
end_comment

begin_decl_stmt
specifier|static
name|u_int32_t
name|rpcclnt_xid
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|rpcclnt_xid_touched
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rpcstats
name|rpcstats
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rpcclnt_ticks
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|rpc
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"RPC Subsystem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|retries
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rpcstats
operator|.
name|rpcretries
argument_list|,
literal|0
argument_list|,
literal|"retries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|request
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rpcstats
operator|.
name|rpcrequests
argument_list|,
literal|0
argument_list|,
literal|"request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|timeouts
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rpcstats
operator|.
name|rpctimeouts
argument_list|,
literal|0
argument_list|,
literal|"timeouts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|unexpected
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rpcstats
operator|.
name|rpcunexpected
argument_list|,
literal|0
argument_list|,
literal|"unexpected"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|invalid
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rpcstats
operator|.
name|rpcinvalid
argument_list|,
literal|0
argument_list|,
literal|"invalid"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RPCCLNT_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|rpcdebugon
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_rpc
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_on
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rpcdebugon
argument_list|,
literal|0
argument_list|,
literal|"RPC Debug messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Queue head for rpctask's  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|rpctask
argument_list|)
name|rpctask_q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|callout
name|rpcclnt_callout
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__OpenBSD__
end_ifdef

begin_function_decl
specifier|static
name|int
name|rpcclnt_send
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|rpctask
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcclnt_receive
parameter_list|(
name|struct
name|rpctask
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|RPC_EXEC_CTX
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|rpcclnt_send
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|rpctask
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcclnt_receive
parameter_list|(
name|struct
name|rpctask
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|RPC_EXEC_CTX
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|rpcclnt_msg
parameter_list|(
name|RPC_EXEC_CTX
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcclnt_reply
parameter_list|(
name|struct
name|rpctask
modifier|*
parameter_list|,
name|RPC_EXEC_CTX
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpcclnt_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcclnt_sndlock
parameter_list|(
name|int
modifier|*
parameter_list|,
name|struct
name|rpctask
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpcclnt_sndunlock
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcclnt_rcvlock
parameter_list|(
name|struct
name|rpctask
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpcclnt_rcvunlock
parameter_list|(
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|void            rpcclnt_realign(struct mbuf *, int);
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|void
name|rpcclnt_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|rpcclnt_buildheader
parameter_list|(
name|struct
name|rpcclnt
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcm_disct
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|caddr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|rpcclnt_proct
parameter_list|(
name|struct
name|rpcclnt
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpc_adv
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rpcclnt_softterm
parameter_list|(
name|struct
name|rpctask
modifier|*
name|task
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rpcauth_buildheader
parameter_list|(
name|struct
name|rpc_auth
modifier|*
name|auth
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|rpcclnt_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
specifier|static
name|struct
name|timeout
name|rpcclnt_timer_to
decl_stmt|;
endif|#
directive|endif
name|rpcclnt_ticks
operator|=
operator|(
name|hz
operator|*
name|RPC_TICKINTVL
operator|+
literal|500
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|rpcclnt_ticks
operator|<
literal|1
condition|)
name|rpcclnt_ticks
operator|=
literal|1
expr_stmt|;
name|rpcstats
operator|.
name|rpcretries
operator|=
literal|0
expr_stmt|;
name|rpcstats
operator|.
name|rpcrequests
operator|=
literal|0
expr_stmt|;
name|rpcstats
operator|.
name|rpctimeouts
operator|=
literal|0
expr_stmt|;
name|rpcstats
operator|.
name|rpcunexpected
operator|=
literal|0
expr_stmt|;
name|rpcstats
operator|.
name|rpcinvalid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * rpc constants how about actually using more than one of these! 	 */
name|rpc_reply
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_REPLY
argument_list|)
expr_stmt|;
name|rpc_vers
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_VER2
argument_list|)
expr_stmt|;
name|rpc_call
operator|=
name|txdr_unsigned
argument_list|(
name|RPC_CALL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|rpc_msgdenied = txdr_unsigned(RPC_MSGDENIED); 	rpc_msgaccepted = txdr_unsigned(RPC_MSGACCEPTED); 	rpc_mismatch = txdr_unsigned(RPC_MISMATCH); 	rpc_autherr = txdr_unsigned(RPC_AUTHERR); 	rpc_auth_unix = txdr_unsigned(RPCAUTH_UNIX); 	rpc_auth_kerb = txdr_unsigned(RPCAUTH_KERB4);
endif|#
directive|endif
comment|/* initialize rpctask queue */
name|TAILQ_INIT
argument_list|(
operator|&
name|rpctask_q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
comment|/* initialize pools */
name|pool_init
argument_list|(
operator|&
name|rpctask_pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpctask
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|RPCTASKPOOL_LWM
argument_list|,
literal|"rpctask_p"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pool_setlowat
argument_list|(
operator|&
name|rpctask_pool
argument_list|,
name|RPCTASKPOOL_LWM
argument_list|)
expr_stmt|;
name|pool_sethiwat
argument_list|(
operator|&
name|rpctask_pool
argument_list|,
name|RPCTASKPOOL_HWM
argument_list|)
expr_stmt|;
name|pool_init
argument_list|(
operator|&
name|rpcclnt_pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcclnt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|"rpcclnt_p"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* initialize timers */
name|timeout_set
argument_list|(
operator|&
name|rpcclnt_timer_to
argument_list|,
name|rpcclnt_timer
argument_list|,
operator|&
name|rpcclnt_timer_to
argument_list|)
expr_stmt|;
name|rpcclnt_timer
argument_list|(
operator|&
name|rpcclnt_timer_to
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* !__OpenBSD__ */
name|callout_init
argument_list|(
operator|&
name|rpcclnt_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !__OpenBSD__ */
name|RPCDEBUG
argument_list|(
literal|"rpc initialed"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|rpcclnt_uninit
parameter_list|(
name|void
parameter_list|)
block|{
name|RPCDEBUG
argument_list|(
literal|"uninit"
argument_list|)
expr_stmt|;
comment|/* XXX delete sysctl variables? */
name|callout_stop
argument_list|(
operator|&
name|rpcclnt_callout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rpcclnt_setup
parameter_list|(
name|clnt
parameter_list|,
name|program
parameter_list|,
name|addr
parameter_list|,
name|sotype
parameter_list|,
name|soproto
parameter_list|,
name|auth
parameter_list|,
name|max_read_size
parameter_list|,
name|max_write_size
parameter_list|,
name|flags
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|clnt
decl_stmt|;
name|struct
name|rpc_program
modifier|*
name|program
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|int
name|sotype
decl_stmt|;
name|int
name|soproto
decl_stmt|;
name|struct
name|rpc_auth
modifier|*
name|auth
decl_stmt|;
name|int
name|max_read_size
decl_stmt|;
name|int
name|max_write_size
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|clnt
operator|==
name|NULL
operator|||
name|program
operator|==
name|NULL
operator|||
name|addr
operator|==
name|NULL
operator|||
name|auth
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|program
operator|->
name|prog_name
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
name|clnt
operator|->
name|rc_prog
operator|=
name|program
expr_stmt|;
name|clnt
operator|->
name|rc_name
operator|=
name|addr
expr_stmt|;
name|clnt
operator|->
name|rc_sotype
operator|=
name|sotype
expr_stmt|;
name|clnt
operator|->
name|rc_soproto
operator|=
name|soproto
expr_stmt|;
name|clnt
operator|->
name|rc_auth
operator|=
name|auth
expr_stmt|;
name|clnt
operator|->
name|rc_rsize
operator|=
name|max_read_size
expr_stmt|;
name|clnt
operator|->
name|rc_wsize
operator|=
name|max_write_size
expr_stmt|;
name|clnt
operator|->
name|rc_flag
operator|=
name|flags
expr_stmt|;
name|clnt
operator|->
name|rc_proctlen
operator|=
literal|0
expr_stmt|;
name|clnt
operator|->
name|rc_proct
operator|=
name|NULL
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize sockets and congestion for a new RPC connection. We do not free  * the sockaddr if error.  */
end_comment

begin_function
name|int
name|rpcclnt_connect
parameter_list|(
name|rpc
parameter_list|,
name|td
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
name|RPC_EXEC_CTX
name|td
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|rcvreserve
decl_stmt|,
name|sndreserve
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|saddr
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|int
name|soarg
decl_stmt|;
name|struct
name|sockopt
name|opt
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rpc
operator|==
name|NULL
condition|)
block|{
name|RPCDEBUG
argument_list|(
literal|"no rpcclnt struct!\n"
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
block|}
comment|/* create the socket */
name|rpc
operator|->
name|rc_so
operator|=
name|NULL
expr_stmt|;
name|saddr
operator|=
name|rpc
operator|->
name|rc_name
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|saddr
operator|->
name|sa_family
argument_list|,
operator|&
name|rpc
operator|->
name|rc_so
argument_list|,
name|rpc
operator|->
name|rc_sotype
argument_list|,
name|rpc
operator|->
name|rc_soproto
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RPCDEBUG
argument_list|(
literal|"error %d in socreate()"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|so
operator|=
name|rpc
operator|->
name|rc_so
expr_stmt|;
name|rpc
operator|->
name|rc_soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
comment|/* 	 * Some servers require that the client port be a reserved port 	 * number. We always allocate a reserved port, as this prevents 	 * filehandle disclosure through UDP port capture. 	 */
if|if
condition|(
name|saddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
name|mopt
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__OpenBSD__
name|MGET
argument_list|(
name|mopt
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
name|mopt
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
name|IP_PORTRANGE_LOW
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_PORTRANGE
argument_list|,
name|mopt
argument_list|)
expr_stmt|;
else|#
directive|else
name|soarg
operator|=
name|IP_PORTRANGE_LOW
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockopt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|soarg
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|soarg
argument_list|)
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|MGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
name|sin
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 *&thread0 gives us root credentials to ensure sobind 		 * will give us a reserved ephemeral port. 		 */
name|error
operator|=
name|sobind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
operator|&
name|thread0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|MGET
argument_list|(
name|mopt
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
name|mopt
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|mopt
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ip
operator|=
name|IP_PORTRANGE_DEFAULT
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_PORTRANGE
argument_list|,
name|mopt
argument_list|)
expr_stmt|;
else|#
directive|else
name|soarg
operator|=
name|IP_PORTRANGE_DEFAULT
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockopt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|soarg
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|soarg
argument_list|)
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Protocols that do not require connections may be optionally left 	 * unconnected for servers that reply from a port other than 	 * NFS_PORT. 	 */
if|if
condition|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_NOCONN
condition|)
block|{
if|if
condition|(
name|rpc
operator|->
name|rc_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|soconnect
argument_list|(
name|so
argument_list|,
name|saddr
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 		 * Wait for the connection to complete. Cribbed from the 		 * connect system call but with the wait timing out so that 		 * interruptible mounts don't hang here for a long time. 		 */
ifdef|#
directive|ifdef
name|__OpenBSD__
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
operator|)
operator|&&
name|so
operator|->
name|so_error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
argument_list|,
literal|"rpc"
argument_list|,
literal|2
operator|*
name|hz
argument_list|)
expr_stmt|;
comment|/* 			 * XXX needs to catch interrupt signals. something 			 * like this: if ((so->so_state& SS_ISCONNECTING)&& 			 * so->so_error == 0&& rep&& (error = 			 * nfs_sigintr(nmp, rep, rep->r_td)) != 0) { 			 * so->so_state&= ~SS_ISCONNECTING; splx(s); goto 			 * bad; } 			 */
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rpc
operator|->
name|rc_flag
operator|&
operator|(
name|RPCCLNT_SOFT
operator||
name|RPCCLNT_INT
operator|)
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
operator|(
literal|5
operator|*
name|hz
operator|)
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|rpc
operator|->
name|rc_sotype
operator|==
name|SOCK_DGRAM
condition|)
block|{
name|sndreserve
operator|=
name|rpc
operator|->
name|rc_wsize
operator|+
name|RPC_MAXPKTHDR
expr_stmt|;
name|rcvreserve
operator|=
name|rpc
operator|->
name|rc_rsize
operator|+
name|RPC_MAXPKTHDR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rpc
operator|->
name|rc_sotype
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
name|sndreserve
operator|=
operator|(
name|rpc
operator|->
name|rc_wsize
operator|+
name|RPC_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|rpc
operator|->
name|rc_rsize
operator|+
name|RPC_MAXPKTHDR
operator|)
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rpc
operator|->
name|rc_sotype
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"rpcclnt_connect() bad sotype"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|MGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int32_t
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_KEEPALIVE
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|soarg
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockopt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|SO_KEEPALIVE
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|soarg
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|soarg
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|MGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_SOOPTS
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|int32_t
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
name|IPPROTO_TCP
argument_list|,
name|TCP_NODELAY
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
name|soarg
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|opt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockopt
argument_list|)
argument_list|)
expr_stmt|;
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|soarg
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|soarg
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sndreserve
operator|=
operator|(
name|rpc
operator|->
name|rc_wsize
operator|+
name|RPC_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
name|rcvreserve
operator|=
operator|(
name|rpc
operator|->
name|rc_rsize
operator|+
name|RPC_MAXPKTHDR
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
operator|*
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sndreserve
argument_list|,
name|rcvreserve
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
comment|/* Initialize other non-zero congestion variables */
name|rpc
operator|->
name|rc_srtt
index|[
literal|0
index|]
operator|=
name|rpc
operator|->
name|rc_srtt
index|[
literal|1
index|]
operator|=
name|rpc
operator|->
name|rc_srtt
index|[
literal|2
index|]
operator|=
name|rpc
operator|->
name|rc_srtt
index|[
literal|3
index|]
operator|=
operator|(
name|RPC_TIMEO
operator|<<
literal|3
operator|)
expr_stmt|;
name|rpc
operator|->
name|rc_sdrtt
index|[
literal|0
index|]
operator|=
name|rpc
operator|->
name|rc_sdrtt
index|[
literal|1
index|]
operator|=
name|rpc
operator|->
name|rc_sdrtt
index|[
literal|2
index|]
operator|=
name|rpc
operator|->
name|rc_sdrtt
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|rpc
operator|->
name|rc_cwnd
operator|=
name|RPC_MAXCWND
operator|/
literal|2
expr_stmt|;
comment|/* Initial send window */
name|rpc
operator|->
name|rc_sent
operator|=
literal|0
expr_stmt|;
name|rpc
operator|->
name|rc_timeouts
operator|=
literal|0
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|bad
label|:
name|rpcclnt_disconnect
argument_list|(
name|rpc
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reconnect routine:  * Called when a connection is broken on a reliable protocol.  * - clean up the old socket  * - rpcclnt_connect() again  * - set R_MUSTRESEND for all outstanding requests on mount point  * If this fails the mount point is DEAD!  * nb: Must be called with the rpcclnt_sndlock() set on the mount point.  */
end_comment

begin_function
name|int
name|rpcclnt_reconnect
parameter_list|(
name|rep
parameter_list|,
name|td
parameter_list|)
name|struct
name|rpctask
modifier|*
name|rep
decl_stmt|;
name|RPC_EXEC_CTX
name|td
decl_stmt|;
block|{
name|struct
name|rpctask
modifier|*
name|rp
decl_stmt|;
name|struct
name|rpcclnt
modifier|*
name|rpc
init|=
name|rep
operator|->
name|r_rpcclnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rpcclnt_disconnect
argument_list|(
name|rpc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|error
operator|=
name|rpcclnt_connect
argument_list|(
name|rpc
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
name|tsleep
argument_list|(
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"rpccon"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop through outstanding request list and fix up all requests on 	 * old socket. 	 */
for|for
control|(
name|rp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|rpctask_q
argument_list|)
init|;
name|rp
operator|!=
name|NULL
condition|;
name|rp
operator|=
name|TAILQ_NEXT
argument_list|(
name|rp
argument_list|,
name|r_chain
argument_list|)
control|)
block|{
if|if
condition|(
name|rp
operator|->
name|r_rpcclnt
operator|==
name|rpc
condition|)
name|rp
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RPC transport disconnect. Clean up and unlink.  */
end_comment

begin_function
name|void
name|rpcclnt_disconnect
parameter_list|(
name|rpc
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_so
condition|)
block|{
name|so
operator|=
name|rpc
operator|->
name|rc_so
expr_stmt|;
name|rpc
operator|->
name|rc_so
operator|=
name|NULL
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|soshutdown
argument_list|(
name|so
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rpcclnt_safedisconnect
parameter_list|(
name|struct
name|rpcclnt
modifier|*
name|rpc
parameter_list|)
block|{
name|struct
name|rpctask
name|dummytask
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dummytask
argument_list|,
sizeof|sizeof
argument_list|(
name|dummytask
argument_list|)
argument_list|)
expr_stmt|;
name|dummytask
operator|.
name|r_rpcclnt
operator|=
name|rpc
expr_stmt|;
name|rpcclnt_rcvlock
argument_list|(
operator|&
name|dummytask
argument_list|)
expr_stmt|;
name|rpcclnt_disconnect
argument_list|(
name|rpc
argument_list|)
expr_stmt|;
name|rpcclnt_rcvunlock
argument_list|(
operator|&
name|rpc
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the rpc send routine. For connection based socket types, it  * must be called with an rpcclnt_sndlock() on the socket.  * "rep == NULL" indicates that it has been called from a server.  * For the client side:  * - return EINTR if the RPC is terminated, 0 otherwise  * - set R_MUSTRESEND if the send fails for any reason  * - do any cleanup required by recoverable socket errors (?)  * For the server side:  * - return EINTR or ERESTART if interrupted by a signal  * - return EPIPE if a connection is lost for connection based sockets (TCP...)  * - do any cleanup required by recoverable socket errors (?)  */
end_comment

begin_function
specifier|static
name|int
name|rpcclnt_send
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|top
parameter_list|,
name|rep
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|struct
name|rpctask
modifier|*
name|rep
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
name|sendnam
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
modifier|*
name|sendnam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|soflags
decl_stmt|,
name|flags
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_so
operator|)
operator|==
name|NULL
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_MUSTRESEND
expr_stmt|;
name|soflags
operator|=
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_soflags
expr_stmt|;
block|}
else|else
name|soflags
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
expr_stmt|;
if|if
condition|(
operator|(
name|soflags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
condition|)
name|sendnam
operator|=
name|NULL
expr_stmt|;
else|else
name|sendnam
operator|=
name|nam
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_SEQPACKET
condition|)
name|flags
operator|=
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * XXXRW: If/when this code becomes MPSAFE itself, Giant might have 	 * to be conditionally acquired earlier for the stack so has to avoid 	 * lock order reversals with any locks held over rpcclnt_send(). 	 */
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
name|sendnam
argument_list|,
name|NULL
argument_list|,
name|top
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|rep
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rpc send error %d for service %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|)
expr_stmt|;
comment|/* 			 * Deal with errors for the client side. 			 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
name|rep
operator|->
name|r_flags
operator||=
name|R_MUSTRESEND
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"rpc service send error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 		 * Handle any recoverable (soft) socket errors here. 		 */
if|if
condition|(
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
operator|&&
name|error
operator|!=
name|EPIPE
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive a Sun RPC Request/Reply. For SOCK_DGRAM, the work is all done by  * soreceive(), but for SOCK_STREAM we must deal with the Record Mark and  * consolidate the data into a new mbuf list. nb: Sometimes TCP passes the  * data up to soreceive() in long lists of small mbufs. For SOCK_STREAM we  * must be very careful to read an entire record once we have read any of it,  * even if the system call has been interrupted.  */
end_comment

begin_function
specifier|static
name|int
name|rpcclnt_receive
parameter_list|(
name|rep
parameter_list|,
name|aname
parameter_list|,
name|mp
parameter_list|,
name|td
parameter_list|)
name|struct
name|rpctask
modifier|*
name|rep
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
modifier|*
name|aname
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
modifier|*
modifier|*
name|aname
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|RPC_EXEC_CTX
name|td
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
modifier|*
name|getnam
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
modifier|*
modifier|*
name|getnam
decl_stmt|;
endif|#
directive|endif
name|int
name|error
decl_stmt|,
name|sotype
decl_stmt|,
name|rcvflg
decl_stmt|;
comment|/* 	 * Set up arguments for soreceive() 	 */
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
operator|*
name|aname
operator|=
name|NULL
expr_stmt|;
name|sotype
operator|=
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_sotype
expr_stmt|;
comment|/* 	 * For reliable protocols, lock against other senders/receivers in 	 * case a reconnect is necessary. For SOCK_STREAM, first get the 	 * Record Mark to find out how much more there is to get. We must 	 * lock the socket against other receivers until we have an entire 	 * rpc request/reply. 	 */
if|if
condition|(
name|sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
name|error
operator|=
name|rpcclnt_sndlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|tryagain
label|:
comment|/* 		 * Check for fatal errors and resending request. 		 */
comment|/* 		 * Ugh: If a reconnect attempt just happened, rc_so would 		 * have changed. NULL indicates a failed attempt that has 		 * essentially shut down this mount point. 		 */
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|rpcclnt_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
name|so
operator|=
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_so
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
block|{
name|error
operator|=
name|rpcclnt_reconnect
argument_list|(
name|rep
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rpcclnt_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|tryagain
goto|;
block|}
while|while
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
name|rpcstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
name|error
operator|=
name|rpcclnt_send
argument_list|(
name|so
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_name
argument_list|,
name|m
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
operator|||
operator|(
name|error
operator|=
name|rpcclnt_reconnect
argument_list|(
name|rep
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|rpcclnt_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|tryagain
goto|;
block|}
block|}
name|rpcclnt_sndunlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|aio
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|aio
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aio
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|auio
operator|.
name|uio_procp
operator|=
name|td
expr_stmt|;
else|#
directive|else
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|auio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%zu/%zu) from rpc server %s\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|errout
goto|;
name|len
operator|=
name|ntohl
argument_list|(
name|len
argument_list|)
operator|&
operator|~
literal|0x80000000
expr_stmt|;
comment|/* 			 * This is SERIOUS! We are out of sync with the 			 * sender and forcing a disconnect/reconnect is all I 			 * can do. 			 */
if|if
condition|(
name|len
operator|>
name|RPC_MAXPACKET
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s (%d) from rpc server %s\n"
argument_list|,
literal|"impossible packet length"
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|errout
goto|;
block|}
name|auio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
do|do
block|{
name|rcvflg
operator|=
name|MSG_WAITALL
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
do|;
if|if
condition|(
operator|!
name|error
operator|&&
name|auio
operator|.
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"short receive (%d/%d) from rpc server %s\n"
argument_list|,
name|len
operator|-
name|auio
operator|.
name|uio_resid
argument_list|,
name|len
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * NB: Since uio_resid is big, MSG_WAITALL is ignored 			 * and soreceive() will return when it has either a 			 * control msg or a data msg. We have no use for 			 * control msg., but must grab them and then throw 			 * them away so we know what is going on. 			 */
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|100000000
expr_stmt|;
comment|/* Anything Big */
ifdef|#
directive|ifdef
name|__OpenBSD__
name|auio
operator|.
name|uio_procp
operator|=
name|td
expr_stmt|;
else|#
directive|else
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
operator|&
name|control
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|rep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|||
operator|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
operator|&&
name|control
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|rcvflg
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Egad!!\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|*
name|mp
operator|==
name|NULL
condition|)
name|error
operator|=
name|EPIPE
expr_stmt|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
name|errout
label|:
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EINTR
operator|&&
name|error
operator|!=
name|ERESTART
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EPIPE
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"receive error %d from rpc server %s\n"
argument_list|,
name|error
argument_list|,
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|rpcclnt_sndlock
argument_list|(
operator|&
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|rpcclnt_reconnect
argument_list|(
name|rep
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
goto|goto
name|tryagain
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|so
operator|=
name|rep
operator|->
name|r_rpcclnt
operator|->
name|rc_so
operator|)
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EACCES
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
name|getnam
operator|=
name|NULL
expr_stmt|;
else|else
name|getnam
operator|=
name|aname
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|len
operator|=
literal|1000000
expr_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|auio
operator|.
name|uio_procp
operator|=
name|td
expr_stmt|;
else|#
directive|else
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
endif|#
directive|endif
do|do
block|{
name|rcvflg
operator|=
literal|0
expr_stmt|;
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|getnam
argument_list|,
operator|&
name|auio
argument_list|,
name|mp
argument_list|,
name|NULL
argument_list|,
operator|&
name|rcvflg
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
name|RPCDEBUG
argument_list|(
literal|"soreceive returns %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
block|{
name|RPCDEBUG
argument_list|(
literal|"wouldblock&& softerm -> EINTR"
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
do|;
name|len
operator|-=
name|auio
operator|.
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Search for any mbufs that are not a multiple of 4 bytes 		 * long or with m_data not longword aligned. These could 		 * cause pointer alignment problems, so copy them to well 		 * aligned mbufs. 		 */
name|rpcclnt_realign
argument_list|(
name|mp
argument_list|,
literal|5
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement receipt of reply on a socket. We must search through the list of  * received datagrams matching them with outstanding requests using the xid,  * until ours is found.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|rpcclnt_reply
parameter_list|(
name|myrep
parameter_list|,
name|td
parameter_list|)
name|struct
name|rpctask
modifier|*
name|myrep
decl_stmt|;
name|RPC_EXEC_CTX
name|td
decl_stmt|;
block|{
name|struct
name|rpctask
modifier|*
name|rep
decl_stmt|;
name|struct
name|rpcclnt
modifier|*
name|rpc
init|=
name|myrep
operator|->
name|r_rpcclnt
decl_stmt|;
name|int32_t
name|t1
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrep
decl_stmt|,
modifier|*
name|md
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|mbuf
modifier|*
name|nam
decl_stmt|;
else|#
directive|else
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
endif|#
directive|endif
name|u_int32_t
name|rxid
decl_stmt|,
modifier|*
name|tl
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Loop around until we get our own reply 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Lock against other receivers so that I don't get stuck in 		 * sbwait() after someone else has received my reply for me. 		 * Also necessary for connection based protocols to avoid 		 * race conditions during a reconnect. 		 */
name|error
operator|=
name|rpcclnt_rcvlock
argument_list|(
name|myrep
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
comment|/* Already received, bye bye */
if|if
condition|(
name|myrep
operator|->
name|r_mrep
operator|!=
name|NULL
condition|)
block|{
name|rpcclnt_rcvunlock
argument_list|(
operator|&
name|rpc
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Get the next Rpc reply off the socket 		 */
name|error
operator|=
name|rpcclnt_receive
argument_list|(
name|myrep
argument_list|,
operator|&
name|nam
argument_list|,
operator|&
name|mrep
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|rpcclnt_rcvunlock
argument_list|(
operator|&
name|rpc
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Ignore routing errors on connectionless 			 * protocols?? 			 */
if|if
condition|(
name|RPCIGNORE_SOERROR
argument_list|(
name|rpc
operator|->
name|rc_soflags
argument_list|,
name|error
argument_list|)
condition|)
block|{
name|rpc
operator|->
name|rc_so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|RPCDEBUG
argument_list|(
literal|"ingoring routing error on connectionless protocol."
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__OpenBSD__
if|if
condition|(
name|nam
condition|)
name|m_freem
argument_list|(
name|nam
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|nam
condition|)
name|FREE
argument_list|(
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Get the xid and check that it is an rpc reply 		 */
name|md
operator|=
name|mrep
expr_stmt|;
name|dpos
operator|=
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|rxid
operator|=
operator|*
name|tl
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tl
operator|!=
name|rpc_reply
condition|)
block|{
name|rpcstats
operator|.
name|rpcinvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
name|rpcmout
label|:
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Loop through the request list to match up the reply Iff no 		 * match, just drop the datagram 		 */
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&rpctask_q
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
operator|&&
name|rxid
operator|==
name|rep
operator|->
name|r_xid
condition|)
block|{
comment|/* Found it.. */
name|rep
operator|->
name|r_mrep
operator|=
name|mrep
expr_stmt|;
name|rep
operator|->
name|r_md
operator|=
name|md
expr_stmt|;
name|rep
operator|->
name|r_dpos
operator|=
name|dpos
expr_stmt|;
comment|/* 				 * Update congestion window. Do the additive 				 * increase of one rpc/rtt. 				 */
if|if
condition|(
name|rpc
operator|->
name|rc_cwnd
operator|<=
name|rpc
operator|->
name|rc_sent
condition|)
block|{
name|rpc
operator|->
name|rc_cwnd
operator|+=
operator|(
name|RPC_CWNDSCALE
operator|*
name|RPC_CWNDSCALE
operator|+
operator|(
name|rpc
operator|->
name|rc_cwnd
operator|>>
literal|1
operator|)
operator|)
operator|/
name|rpc
operator|->
name|rc_cwnd
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_cwnd
operator|>
name|RPC_MAXCWND
condition|)
name|rpc
operator|->
name|rc_cwnd
operator|=
name|RPC_MAXCWND
expr_stmt|;
block|}
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
name|rpc
operator|->
name|rc_sent
operator|-=
name|RPC_CWNDSCALE
expr_stmt|;
comment|/* 				 * Update rtt using a gain of 0.125 on the 				 * mean and a gain of 0.25 on the deviation. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TIMING
condition|)
block|{
comment|/* 					 * Since the timer resolution of 					 * NFS_HZ is so course, it can often 					 * result in r_rtt == 0. Since r_rtt 					 * == N means that the actual rtt is 					 * between N+dt and N+2-dt ticks, add 					 * 1. 					 */
name|t1
operator|=
name|rep
operator|->
name|r_rtt
operator|+
literal|1
expr_stmt|;
name|t1
operator|-=
operator|(
name|RPC_SRTT
argument_list|(
name|rpc
argument_list|,
name|rep
argument_list|)
operator|>>
literal|3
operator|)
expr_stmt|;
name|RPC_SRTT
argument_list|(
name|rpc
argument_list|,
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
if|if
condition|(
name|t1
operator|<
literal|0
condition|)
name|t1
operator|=
operator|-
name|t1
expr_stmt|;
name|t1
operator|-=
operator|(
name|RPC_SDRTT
argument_list|(
name|rpc
argument_list|,
name|rep
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|RPC_SDRTT
argument_list|(
name|rpc
argument_list|,
name|rep
argument_list|)
operator|+=
name|t1
expr_stmt|;
block|}
name|rpc
operator|->
name|rc_timeouts
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * If not matched to a request, drop it. If it's mine, get 		 * out. 		 */
if|if
condition|(
name|rep
operator|==
literal|0
condition|)
block|{
name|rpcstats
operator|.
name|rpcunexpected
operator|++
expr_stmt|;
name|RPCDEBUG
argument_list|(
literal|"rpc reply not matched\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mrep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|==
name|myrep
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"rpcreply nil"
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|myrep
operator|->
name|r_flags
operator|&
name|R_GETONEREP
condition|)
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX: ignores tryagain! */
end_comment

begin_comment
comment|/*  * code from nfs_request - goes something like this  *	- fill in task struct  *	- links task into list  *	- calls rpcclnt_send() for first transmit  *	- calls rpcclnt_reply() to get reply  *	- fills in reply (which should be initialized prior to  *	  calling), which is valid when 0 is returned and is  *	  NEVER freed in this function  *   * nb: always frees the request header, but NEVER frees 'mrest'  *   * rpcclnt_setauth() should be used before calling this. EAUTH is returned if  * authentication fails.  *  * note that reply->result_* are invalid unless reply->type ==  * RPC_MSGACCEPTED and reply->status == RPC_SUCCESS and that reply->verf_*  * are invalid unless reply->type == RPC_MSGACCEPTED  */
end_comment

begin_function
name|int
name|rpcclnt_request
parameter_list|(
name|rpc
parameter_list|,
name|mrest
parameter_list|,
name|procnum
parameter_list|,
name|td
parameter_list|,
name|cred
parameter_list|,
name|reply
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrest
decl_stmt|;
name|int
name|procnum
decl_stmt|;
name|RPC_EXEC_CTX
name|td
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|rpc_reply
modifier|*
name|reply
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mrep
decl_stmt|;
name|struct
name|rpctask
modifier|*
name|task
decl_stmt|;
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|md
decl_stmt|,
modifier|*
name|mheadend
decl_stmt|;
name|caddr_t
name|dpos
decl_stmt|,
name|cp2
decl_stmt|;
name|int
name|t1
decl_stmt|,
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|mrest_len
decl_stmt|;
name|u_int32_t
name|xid
decl_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|task
operator|=
name|pool_get
argument_list|(
operator|&
name|rpctask_pool
argument_list|,
name|PR_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|MALLOC
argument_list|(
name|task
argument_list|,
expr|struct
name|rpctask
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpctask
argument_list|)
argument_list|,
name|M_RPC
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|task
operator|->
name|r_rpcclnt
operator|=
name|rpc
expr_stmt|;
name|task
operator|->
name|r_procnum
operator|=
name|procnum
expr_stmt|;
name|task
operator|->
name|r_td
operator|=
name|td
expr_stmt|;
name|mrest_len
operator|=
name|m_length
argument_list|(
name|mrest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|m
operator|=
name|rpcclnt_buildheader
argument_list|(
name|rpc
argument_list|,
name|procnum
argument_list|,
name|mrest
argument_list|,
name|mrest_len
argument_list|,
operator|&
name|xid
argument_list|,
operator|&
name|mheadend
argument_list|,
name|cred
argument_list|)
expr_stmt|;
comment|/* 	 * For stream protocols, insert a Sun RPC Record Mark. 	 */
if|if
condition|(
name|rpc
operator|->
name|rc_sotype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|RPCX_UNSIGNED
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
literal|0x80000000
operator||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|RPCX_UNSIGNED
operator|)
argument_list|)
expr_stmt|;
block|}
name|task
operator|->
name|r_mreq
operator|=
name|m
expr_stmt|;
name|task
operator|->
name|r_xid
operator|=
name|xid
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_SOFT
condition|)
name|task
operator|->
name|r_retry
operator|=
name|rpc
operator|->
name|rc_retry
expr_stmt|;
else|else
name|task
operator|->
name|r_retry
operator|=
name|RPC_MAXREXMIT
operator|+
literal|1
expr_stmt|;
comment|/* past clip limit */
name|task
operator|->
name|r_rtt
operator|=
name|task
operator|->
name|r_rexmit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rpcclnt_proct
argument_list|(
name|rpc
argument_list|,
name|procnum
argument_list|)
operator|>
literal|0
condition|)
name|task
operator|->
name|r_flags
operator|=
name|R_TIMING
expr_stmt|;
else|else
name|task
operator|->
name|r_flags
operator|=
literal|0
expr_stmt|;
name|task
operator|->
name|r_mrep
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Do the client side RPC. 	 */
name|rpcstats
operator|.
name|rpcrequests
operator|++
expr_stmt|;
comment|/* 	 * Chain request into list of outstanding requests. Be sure to put it 	 * LAST so timer finds oldest requests first. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rpctask_q
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|rpcclnt_callout
argument_list|,
name|rpcclnt_ticks
argument_list|,
name|rpcclnt_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rpctask_q
argument_list|,
name|task
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
comment|/* 	 * If backing off another request or avoiding congestion, don't send 	 * this one now but let timer do it. If not timing a request, do it 	 * now. 	 */
if|if
condition|(
name|rpc
operator|->
name|rc_so
operator|&&
operator|(
name|rpc
operator|->
name|rc_sotype
operator|!=
name|SOCK_DGRAM
operator|||
operator|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_DUMBTIMR
operator|)
operator|||
name|rpc
operator|->
name|rc_sent
operator|<
name|rpc
operator|->
name|rc_cwnd
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|rpcclnt_sndlock
argument_list|(
operator|&
name|rpc
operator|->
name|rc_flag
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|rpcclnt_send
argument_list|(
name|rpc
operator|->
name|rc_so
argument_list|,
name|rpc
operator|->
name|rc_name
argument_list|,
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_TRYWAIT
argument_list|)
argument_list|,
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_soflags
operator|&
name|PR_CONNREQUIRED
condition|)
name|rpcclnt_sndunlock
argument_list|(
operator|&
name|rpc
operator|->
name|rc_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|task
operator|->
name|r_flags
operator|&
name|R_MUSTRESEND
operator|)
operator|==
literal|0
condition|)
block|{
name|rpc
operator|->
name|rc_sent
operator|+=
name|RPC_CWNDSCALE
expr_stmt|;
name|task
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
block|}
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|task
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Wait for the reply from our send or the timer's. 	 */
if|if
condition|(
operator|!
name|error
operator|||
name|error
operator|==
name|EPIPE
condition|)
name|error
operator|=
name|rpcclnt_reply
argument_list|(
name|task
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * RPC done, unlink the request. 	 */
name|s
operator|=
name|splsoftclock
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rpctask_q
argument_list|,
name|task
argument_list|,
name|r_chain
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rpctask_q
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|rpcclnt_callout
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the outstanding request count. 	 */
if|if
condition|(
name|task
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|task
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
comment|/* paranoia */
name|rpc
operator|->
name|rc_sent
operator|-=
name|RPC_CWNDSCALE
expr_stmt|;
block|}
comment|/* 	 * If there was a successful reply and a tprintf msg. tprintf a 	 * response. 	 */
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|task
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|rpcclnt_msg
argument_list|(
name|task
operator|->
name|r_td
argument_list|,
name|rpc
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|,
literal|"is alive again"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
comment|/* free request header (leaving mrest) */
name|mheadend
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|task
operator|->
name|r_mreq
argument_list|)
expr_stmt|;
comment|/* initialize reply */
name|reply
operator|->
name|mrep
operator|=
name|task
operator|->
name|r_mrep
expr_stmt|;
name|reply
operator|->
name|verf_md
operator|=
name|NULL
expr_stmt|;
name|reply
operator|->
name|result_md
operator|=
name|NULL
expr_stmt|;
name|mrep
operator|=
name|task
operator|->
name|r_mrep
expr_stmt|;
name|md
operator|=
name|task
operator|->
name|r_md
expr_stmt|;
name|dpos
operator|=
name|task
operator|->
name|r_dpos
expr_stmt|;
comment|/* task structure is no longer needed */
ifdef|#
directive|ifdef
name|__OpenBSD__
name|pool_put
argument_list|(
operator|&
name|rpctask_pool
argument_list|,
name|task
argument_list|)
expr_stmt|;
else|#
directive|else
name|FREE
argument_list|(
name|task
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|rpcmout
goto|;
comment|/* 	 * break down the rpc header and check if ok 	 */
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|type
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|->
name|stat
operator|.
name|type
operator|==
name|RPC_MSGDENIED
condition|)
block|{
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|status
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reply
operator|->
name|stat
operator|.
name|status
condition|)
block|{
case|case
name|RPC_MISMATCH
case|:
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|mismatch_info
operator|.
name|low
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|mismatch_info
operator|.
name|high
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|RPC_AUTHERR
case|:
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|autherr
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EACCES
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EBADRPC
expr_stmt|;
break|break;
block|}
goto|goto
name|rpcmout
goto|;
block|}
elseif|else
if|if
condition|(
name|reply
operator|->
name|stat
operator|.
name|type
operator|!=
name|RPC_MSGACCEPTED
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|rpcmout
goto|;
block|}
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|verf_md
operator|=
name|md
expr_stmt|;
name|reply
operator|->
name|verf_dpos
operator|=
name|dpos
expr_stmt|;
name|reply
operator|->
name|verf_type
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|reply
operator|->
name|verf_size
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|->
name|verf_size
operator|!=
literal|0
condition|)
name|rpcm_adv
argument_list|(
name|rpcm_rndup
argument_list|(
name|reply
operator|->
name|verf_size
argument_list|)
argument_list|)
expr_stmt|;
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|status
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
operator|->
name|stat
operator|.
name|status
operator|==
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
call|(
name|uint32_t
call|)
argument_list|(
name|dpos
operator|-
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|>=
name|md
operator|->
name|m_len
condition|)
block|{
name|RPCDEBUG
argument_list|(
literal|"where is the next mbuf?"
argument_list|)
expr_stmt|;
name|RPCDEBUG
argument_list|(
literal|"%d -> %d"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dpos
operator|-
name|mtod
argument_list|(
name|md
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
argument_list|,
name|md
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADRPC
expr_stmt|;
goto|goto
name|rpcmout
goto|;
block|}
else|else
block|{
name|reply
operator|->
name|result_md
operator|=
name|md
operator|->
name|m_next
expr_stmt|;
name|reply
operator|->
name|result_dpos
operator|=
name|mtod
argument_list|(
name|reply
operator|->
name|result_md
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|reply
operator|->
name|result_md
operator|=
name|md
expr_stmt|;
name|reply
operator|->
name|result_dpos
operator|=
name|dpos
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reply
operator|->
name|stat
operator|.
name|status
operator|==
name|RPC_PROGMISMATCH
condition|)
block|{
name|rpcm_dissect
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|2
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|mismatch_info
operator|.
name|low
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
operator|++
argument_list|)
expr_stmt|;
name|reply
operator|->
name|stat
operator|.
name|mismatch_info
operator|.
name|high
operator|=
name|fxdr_unsigned
argument_list|(
name|u_int32_t
argument_list|,
operator|*
name|tl
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|rpcmout
goto|;
block|}
else|else
block|{
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|rpcmout
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|rpcmout
label|:
name|RPC_RETURN
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RPC timer routine  * Scan the rpctask list and retranmit any requests that have timed out.  * To avoid retransmission attempts on STREAM sockets (in the future) make  * sure to set the r_retry field to 0 (implies nm_retry == 0).  */
end_comment

begin_function
name|void
name|rpcclnt_timer
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|struct
name|timeout
modifier|*
name|to
init|=
operator|(
expr|struct
name|timeout
operator|*
operator|)
name|arg
decl_stmt|;
endif|#
directive|endif
name|struct
name|rpctask
modifier|*
name|rep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
name|int
name|timeo
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
ifndef|#
directive|ifndef
name|__OpenBSD__
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__OpenBSD__
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* rpc_msg -> tprintf */
name|TAILQ_FOREACH
argument_list|(
argument|rep
argument_list|,
argument|&rpctask_q
argument_list|,
argument|r_chain
argument_list|)
block|{
name|rpc
operator|=
name|rep
operator|->
name|r_rpcclnt
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_mrep
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
continue|continue;
if|if
condition|(
name|rpcclnt_sigintr
argument_list|(
name|rpc
argument_list|,
name|rep
argument_list|,
name|rep
operator|->
name|r_td
argument_list|)
condition|)
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|>=
literal|0
condition|)
block|{
name|rep
operator|->
name|r_rtt
operator|++
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_DUMBTIMR
condition|)
name|timeo
operator|=
name|rpc
operator|->
name|rc_timeo
expr_stmt|;
else|else
name|timeo
operator|=
name|RPC_RTO
argument_list|(
name|rpc
argument_list|,
name|rpcclnt_proct
argument_list|(
name|rep
operator|->
name|r_rpcclnt
argument_list|,
name|rep
operator|->
name|r_procnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_timeouts
operator|>
literal|0
condition|)
name|timeo
operator|*=
name|rpcclnt_backoff
index|[
name|rpc
operator|->
name|rc_timeouts
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|r_rtt
operator|<=
name|timeo
condition|)
continue|continue;
if|if
condition|(
name|rpc
operator|->
name|rc_timeouts
operator|<
literal|8
condition|)
name|rpc
operator|->
name|rc_timeouts
operator|++
expr_stmt|;
block|}
comment|/* 		 * Check for server not responding 		 */
if|if
condition|(
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_TPRINTFMSG
operator|)
operator|==
literal|0
operator|&&
name|rep
operator|->
name|r_rexmit
operator|>
name|rpc
operator|->
name|rc_deadthresh
condition|)
block|{
name|rpcclnt_msg
argument_list|(
name|rep
operator|->
name|r_td
argument_list|,
name|rpc
operator|->
name|rc_prog
operator|->
name|prog_name
argument_list|,
literal|"not responding"
argument_list|)
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_TPRINTFMSG
expr_stmt|;
block|}
if|if
condition|(
name|rep
operator|->
name|r_rexmit
operator|>=
name|rep
operator|->
name|r_retry
condition|)
block|{
comment|/* too many */
name|rpcstats
operator|.
name|rpctimeouts
operator|++
expr_stmt|;
name|rep
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rpc
operator|->
name|rc_sotype
operator|!=
name|SOCK_DGRAM
condition|)
block|{
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|RPC_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|RPC_MAXREXMIT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|so
operator|=
name|rpc
operator|->
name|rc_so
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * If there is enough space and the window allows.. Resend it 		 * Set r_rtt to -1 in case we fail to send it now. 		 */
name|rep
operator|->
name|r_rtt
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|>=
name|rep
operator|->
name|r_mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|&&
operator|(
operator|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_DUMBTIMR
operator|)
operator|||
operator|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
operator|)
operator|||
name|rpc
operator|->
name|rc_sent
operator|<
name|rpc
operator|->
name|rc_cwnd
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_copym
argument_list|(
name|rep
operator|->
name|r_mreq
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_NOCONN
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|rpc
operator|->
name|rc_name
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|RPCIGNORE_SOERROR
argument_list|(
name|rpc
operator|->
name|rc_soflags
argument_list|,
name|error
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Iff first send, start timing else turn 				 * timing off, backoff timer and divide 				 * congestion window by 2. 				 */
if|if
condition|(
name|rep
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|rep
operator|->
name|r_flags
operator|&=
operator|~
name|R_TIMING
expr_stmt|;
if|if
condition|(
operator|++
name|rep
operator|->
name|r_rexmit
operator|>
name|RPC_MAXREXMIT
condition|)
name|rep
operator|->
name|r_rexmit
operator|=
name|RPC_MAXREXMIT
expr_stmt|;
name|rpc
operator|->
name|rc_cwnd
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|rpc
operator|->
name|rc_cwnd
operator|<
name|RPC_CWNDSCALE
condition|)
name|rpc
operator|->
name|rc_cwnd
operator|=
name|RPC_CWNDSCALE
expr_stmt|;
name|rpcstats
operator|.
name|rpcretries
operator|++
expr_stmt|;
block|}
else|else
block|{
name|rep
operator|->
name|r_flags
operator||=
name|R_SENT
expr_stmt|;
name|rpc
operator|->
name|rc_sent
operator|+=
name|RPC_CWNDSCALE
expr_stmt|;
block|}
name|rep
operator|->
name|r_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* rpc_msg -> tprintf */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|timeout_add
argument_list|(
name|rpcclnt_timer
argument_list|,
name|to
argument_list|,
name|rpcclnt_ticks
argument_list|)
expr_stmt|;
else|#
directive|else
name|callout_reset
argument_list|(
operator|&
name|rpcclnt_callout
argument_list|,
name|rpcclnt_ticks
argument_list|,
name|rpcclnt_timer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Test for a termination condition pending on the process. This is used for  * RPCCLNT_INT mounts.  */
end_comment

begin_function
name|int
name|rpcclnt_sigintr
parameter_list|(
name|rpc
parameter_list|,
name|task
parameter_list|,
name|pr
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
name|struct
name|rpctask
modifier|*
name|task
decl_stmt|;
name|RPC_EXEC_CTX
name|pr
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|sigset_t
name|tmpset
decl_stmt|;
if|if
condition|(
name|rpc
operator|==
name|NULL
condition|)
return|return
name|EFAULT
return|;
comment|/* XXX deal with forced unmounts */
if|if
condition|(
name|task
operator|&&
operator|(
name|task
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rpc
operator|->
name|rc_flag
operator|&
name|RPCCLNT_INT
operator|)
condition|)
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|__OpenBSD__
name|p
operator|=
name|pr
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|p_siglist
operator|&&
operator|(
operator|(
operator|(
name|p
operator|->
name|p_siglist
operator|&
operator|~
name|p
operator|->
name|p_sigmask
operator|)
operator|&
operator|~
name|p
operator|->
name|p_sigignore
operator|)
operator|&
name|RPCINT_SIGMASK
operator|)
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|pr
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|pr
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|&&
name|RPCCLNTINT_SIGMASK
argument_list|(
name|tmpset
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a socket against others. Necessary for STREAM sockets to ensure you  * get an entire rpc request/reply and also to avoid race conditions between  * the processes with nfs requests in progress when a reconnect is necessary.  */
end_comment

begin_function
specifier|static
name|int
name|rpcclnt_sndlock
parameter_list|(
name|flagp
parameter_list|,
name|task
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
name|struct
name|rpctask
modifier|*
name|task
decl_stmt|;
block|{
name|RPC_EXEC_CTX
name|p
decl_stmt|;
name|int
name|slpflag
init|=
literal|0
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
name|p
operator|=
name|task
operator|->
name|r_td
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
operator|&
name|RPCCLNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
while|while
condition|(
operator|*
name|flagp
operator|&
name|RPCCLNT_SNDLOCK
condition|)
block|{
if|if
condition|(
name|rpcclnt_sigintr
argument_list|(
name|task
operator|->
name|r_rpcclnt
argument_list|,
name|task
argument_list|,
name|p
argument_list|)
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|RPCCLNT_WANTSND
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"rpcsndlck"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|flagp
operator||=
name|RPCCLNT_SNDLOCK
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
specifier|static
name|void
name|rpcclnt_sndunlock
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|RPCCLNT_SNDLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"rpc sndunlock"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|&=
operator|~
name|RPCCLNT_SNDLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|RPCCLNT_WANTSND
condition|)
block|{
operator|*
name|flagp
operator|&=
operator|~
name|RPCCLNT_WANTSND
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rpcclnt_rcvlock
parameter_list|(
name|task
parameter_list|)
name|struct
name|rpctask
modifier|*
name|task
decl_stmt|;
block|{
name|int
modifier|*
name|flagp
init|=
operator|&
name|task
operator|->
name|r_rpcclnt
operator|->
name|rc_flag
decl_stmt|;
name|int
name|slpflag
decl_stmt|,
name|slptimeo
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|RPCCLNT_INT
condition|)
name|slpflag
operator|=
name|PCATCH
expr_stmt|;
else|else
name|slpflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|flagp
operator|&
name|RPCCLNT_RCVLOCK
condition|)
block|{
if|if
condition|(
name|rpcclnt_sigintr
argument_list|(
name|task
operator|->
name|r_rpcclnt
argument_list|,
name|task
argument_list|,
name|task
operator|->
name|r_td
argument_list|)
condition|)
name|RPC_RETURN
argument_list|(
name|EINTR
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|RPCCLNT_WANTRCV
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|,
name|slpflag
operator||
operator|(
name|PZERO
operator|-
literal|1
operator|)
argument_list|,
literal|"rpcrcvlk"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|slpflag
operator|==
name|PCATCH
condition|)
block|{
name|slpflag
operator|=
literal|0
expr_stmt|;
name|slptimeo
operator|=
literal|2
operator|*
name|hz
expr_stmt|;
block|}
block|}
operator|*
name|flagp
operator||=
name|RPCCLNT_RCVLOCK
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock the stream socket for others.  */
end_comment

begin_function
specifier|static
name|void
name|rpcclnt_rcvunlock
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
if|if
condition|(
operator|(
operator|*
name|flagp
operator|&
name|RPCCLNT_RCVLOCK
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"nfs rcvunlock"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|&=
operator|~
name|RPCCLNT_RCVLOCK
expr_stmt|;
if|if
condition|(
operator|*
name|flagp
operator|&
name|RPCCLNT_WANTRCV
condition|)
block|{
operator|*
name|flagp
operator|&=
operator|~
name|RPCCLNT_WANTRCV
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|flagp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Check for badly aligned mbuf data areas and realign data in an mbuf list  * by copying the data areas up, as required.  */
end_comment

begin_comment
unit|void rpcclnt_realign(m, hsiz) 	struct mbuf    *m; 	int             hsiz; { 	struct mbuf    *m2; 	int             siz, mlen, olen; 	caddr_t         tcp, fcp; 	struct mbuf    *mnew;  	while (m) {
comment|/* 		 * This never happens for UDP, rarely happens for TCP but 		 * frequently happens for iso transport. 		 */
end_comment

begin_comment
unit|if ((m->m_len& 0x3) || (mtod(m, long)&0x3)) { 			olen = m->m_len; 			fcp = mtod(m, caddr_t); 			if ((long)fcp& 0x3) { 				if (m->m_flags& M_PKTHDR) 					m_tag_delete_chain(m, NULL); 				m->m_flags&= ~M_PKTHDR; 				if (m->m_flags& M_EXT) 					m->m_data = m->m_ext.ext_buf + 						((m->m_ext.ext_size - olen)& ~0x3); 				else 					m->m_data = m->m_dat; 			} 			m->m_len = 0; 			tcp = mtod(m, caddr_t); 			mnew = m; 			m2 = m->m_next;
comment|/* 			 * If possible, only put the first invariant part of 			 * the RPC header in the first mbuf. 			 */
end_comment

begin_comment
unit|mlen = M_TRAILINGSPACE(m); 			if (olen<= hsiz&& mlen> hsiz) 				mlen = hsiz;
comment|/* Loop through the mbuf list consolidating data. */
end_comment

begin_comment
unit|while (m) { 				while (olen> 0) { 					if (mlen == 0) { 						if (m2->m_flags& M_PKTHDR) 							m_tag_delete_chain(m2, NULL); 						m2->m_flags&= ~M_PKTHDR; 						if (m2->m_flags& M_EXT) 							m2->m_data = m2->m_ext.ext_buf; 						else 							m2->m_data = m2->m_dat; 						m2->m_len = 0; 						mlen = M_TRAILINGSPACE(m2); 						tcp = mtod(m2, caddr_t); 						mnew = m2; 						m2 = m2->m_next; 					} 					siz = min(mlen, olen); 					if (tcp != fcp) 						bcopy(fcp, tcp, siz); 					mnew->m_len += siz; 					mlen -= siz; 					olen -= siz; 					tcp += siz; 					fcp += siz; 				} 				m = m->m_next; 				if (m) { 					olen = m->m_len; 					fcp = mtod(m, caddr_t); 				} 			}
comment|/* 			 * Finally, set m_len == 0 for any trailing mbufs 			 * that have been copied out of. 			 */
end_comment

begin_else
unit|while (m2) { 				m2->m_len = 0; 				m2 = m2->m_next; 			} 			return; 		} 		m = m->m_next; 	} }
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|rpcclnt_realign
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|pm
parameter_list|,
name|int
name|hsiz
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|RPCDEBUG
argument_list|(
literal|"in rpcclnt_realign()"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|pm
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_len
operator|&
literal|0x3
operator|)
operator|||
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|intptr_t
argument_list|)
operator|&
literal|0x3
operator|)
condition|)
block|{
name|MGET
argument_list|(
name|n
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|n
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
block|}
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pm
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* 	* If n is non-NULL, loop on m copying data, then replace the 	* portion of the chain that had to be realigned. 	*/
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|m
condition|)
block|{
name|m_copyback
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|off
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m_freem
argument_list|(
operator|*
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pm
operator|=
name|n
expr_stmt|;
block|}
name|RPCDEBUG
argument_list|(
literal|"leave rpcclnt_realign()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|rpcclnt_msg
parameter_list|(
name|p
parameter_list|,
name|server
parameter_list|,
name|msg
parameter_list|)
name|RPC_EXEC_CTX
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|server
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__OpenBSD__
name|tpr_t
name|tpr
decl_stmt|;
name|struct
name|proc
modifier|*
name|pr
init|=
name|p
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|tpr
operator|=
name|tprintf_open
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|tpr
operator|=
name|NULL
expr_stmt|;
name|tprintf
argument_list|(
name|tpr
argument_list|,
literal|"rpc server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|tprintf_close
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|GIANT_REQUIRED
expr_stmt|;
name|tprintf
argument_list|(
name|p
condition|?
name|p
operator|->
name|td_proc
else|:
name|NULL
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Build the RPC header and fill in the authorization info. The authorization  * string argument is only used when the credentials come from outside of the  * kernel (AUTH_KERB). (likewise, the ucred is only used when inside the  * kernel) Returns the head of the mbuf list.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|rpcclnt_buildheader
parameter_list|(
name|rc
parameter_list|,
name|procid
parameter_list|,
name|mrest
parameter_list|,
name|mrest_len
parameter_list|,
name|xidp
parameter_list|,
name|mheadend
parameter_list|,
name|cred
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rc
decl_stmt|;
name|int
name|procid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mrest
decl_stmt|;
name|u_int32_t
name|mrest_len
decl_stmt|;
name|int
modifier|*
name|xidp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mheadend
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
block|{
comment|/* register */
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
comment|/* register */
name|caddr_t
name|bpos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mreq
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MGETHDR
argument_list|(
name|mb
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
literal|6
operator|*
name|RPCX_UNSIGNED
operator|>=
name|MINCLSIZE
condition|)
block|{
name|MCLGET
argument_list|(
name|mb
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|6
operator|*
name|RPCX_UNSIGNED
operator|<
name|MHLEN
condition|)
block|{
name|MH_ALIGN
argument_list|(
name|mb
argument_list|,
literal|6
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RPCDEBUG
argument_list|(
literal|"mbuf too small"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"cheap bailout"
argument_list|)
expr_stmt|;
block|}
name|mb
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mreq
operator|=
name|mb
expr_stmt|;
name|bpos
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* 	 * First the RPC header. 	 */
name|rpcm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
literal|6
operator|*
name|RPCX_UNSIGNED
argument_list|)
expr_stmt|;
comment|/* Get a new (non-zero) xid */
if|if
condition|(
operator|(
name|rpcclnt_xid
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rpcclnt_xid_touched
operator|==
literal|0
operator|)
condition|)
block|{
name|rpcclnt_xid
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|rpcclnt_xid_touched
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
operator|*
name|xidp
operator|=
name|arc4random
argument_list|()
operator|%
literal|256
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|rpcclnt_xid
operator|+=
operator|*
name|xidp
expr_stmt|;
block|}
comment|/* XXX: funky... */
operator|*
name|tl
operator|++
operator|=
operator|*
name|xidp
operator|=
name|txdr_unsigned
argument_list|(
name|rpcclnt_xid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|rpc_call
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|rpc_vers
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|rc
operator|->
name|rc_prog
operator|->
name|prog_id
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|rc
operator|->
name|rc_prog
operator|->
name|prog_version
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|procid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|rpcauth_buildheader
argument_list|(
name|rc
operator|->
name|rc_auth
argument_list|,
name|cred
argument_list|,
operator|&
name|mb
argument_list|,
operator|&
name|bpos
argument_list|)
operator|)
condition|)
block|{
name|RPCDEBUG
argument_list|(
literal|"rpcauth_buildheader failed %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|mb
operator|->
name|m_next
operator|=
name|mrest
expr_stmt|;
operator|*
name|mheadend
operator|=
name|mb
expr_stmt|;
name|mreq
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m_length
argument_list|(
name|mreq
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mreq
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|mreq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Help break down an mbuf chain by setting the first siz bytes contiguous  * pointed to by returned val. This is used by the macros rpcm_dissect and  * rpcm_dissecton for tough cases. (The macros use the vars. dpos and dpos2)  */
end_comment

begin_function
specifier|static
name|int
name|rpcm_disct
parameter_list|(
name|mdp
parameter_list|,
name|dposp
parameter_list|,
name|siz
parameter_list|,
name|left
parameter_list|,
name|cp2
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|int
name|left
decl_stmt|;
name|caddr_t
modifier|*
name|cp2
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
name|int
name|siz2
decl_stmt|,
name|xfer
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|mp
operator|=
operator|*
name|mdp
expr_stmt|;
while|while
condition|(
name|left
operator|==
literal|0
condition|)
block|{
operator|*
name|mdp
operator|=
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EBADRPC
argument_list|)
expr_stmt|;
name|left
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left
operator|>=
name|siz
condition|)
block|{
operator|*
name|cp2
operator|=
operator|*
name|dposp
expr_stmt|;
operator|*
name|dposp
operator|+=
name|siz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mp
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|RPC_RETURN
argument_list|(
name|EBADRPC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|siz
operator|>
name|MHLEN
condition|)
block|{
name|panic
argument_list|(
literal|"rpc S too big"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|mp2
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|mp2
operator|->
name|m_next
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|mp2
expr_stmt|;
name|mp
operator|->
name|m_len
operator|-=
name|left
expr_stmt|;
name|mp
operator|=
name|mp2
expr_stmt|;
operator|*
name|cp2
operator|=
name|p
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|dposp
argument_list|,
name|p
argument_list|,
name|left
argument_list|)
expr_stmt|;
comment|/* Copy what was left */
name|siz2
operator|=
name|siz
operator|-
name|left
expr_stmt|;
name|p
operator|+=
name|left
expr_stmt|;
name|mp2
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
comment|/* Loop around copying up the siz2 bytes */
while|while
condition|(
name|siz2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mp2
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EBADRPC
argument_list|)
expr_stmt|;
name|xfer
operator|=
operator|(
name|siz2
operator|>
name|mp2
operator|->
name|m_len
operator|)
condition|?
name|mp2
operator|->
name|m_len
else|:
name|siz2
expr_stmt|;
if|if
condition|(
name|xfer
operator|>
literal|0
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|p
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|RPCMADV
argument_list|(
name|mp2
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|mp2
operator|->
name|m_len
operator|-=
name|xfer
expr_stmt|;
name|p
operator|+=
name|xfer
expr_stmt|;
name|siz2
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|siz2
operator|>
literal|0
condition|)
name|mp2
operator|=
name|mp2
operator|->
name|m_next
expr_stmt|;
block|}
name|mp
operator|->
name|m_len
operator|=
name|siz
expr_stmt|;
operator|*
name|mdp
operator|=
name|mp2
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|mp2
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|rpcclnt_proct
parameter_list|(
name|rpc
parameter_list|,
name|procid
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
name|u_int32_t
name|procid
decl_stmt|;
block|{
if|if
condition|(
name|rpc
operator|->
name|rc_proctlen
operator|!=
literal|0
operator|&&
name|rpc
operator|->
name|rc_proct
operator|!=
name|NULL
operator|&&
name|procid
operator|<
name|rpc
operator|->
name|rc_proctlen
condition|)
block|{
return|return
name|rpc
operator|->
name|rc_proct
index|[
name|procid
index|]
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rpc_adv
parameter_list|(
name|mdp
parameter_list|,
name|dposp
parameter_list|,
name|offs
parameter_list|,
name|left
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mdp
decl_stmt|;
name|caddr_t
modifier|*
name|dposp
decl_stmt|;
name|int
name|offs
decl_stmt|;
name|int
name|left
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|m
operator|=
operator|*
name|mdp
expr_stmt|;
name|s
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|s
operator|<
name|offs
condition|)
block|{
name|offs
operator|-=
name|s
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|RPC_RETURN
argument_list|(
name|EBADRPC
argument_list|)
expr_stmt|;
name|s
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
operator|*
name|mdp
operator|=
name|m
expr_stmt|;
operator|*
name|dposp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|offs
expr_stmt|;
name|RPC_RETURN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rpcclnt_cancelreqs
parameter_list|(
name|rpc
parameter_list|)
name|struct
name|rpcclnt
modifier|*
name|rpc
decl_stmt|;
block|{
name|struct
name|rpctask
modifier|*
name|task
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|task
argument_list|,
argument|&rpctask_q
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rpc
operator|!=
name|task
operator|->
name|r_rpcclnt
operator|||
name|task
operator|->
name|r_mrep
operator|!=
name|NULL
operator|||
operator|(
name|task
operator|->
name|r_flags
operator|&
name|R_SOFTTERM
operator|)
condition|)
continue|continue;
name|rpcclnt_softterm
argument_list|(
name|task
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|30
condition|;
name|i
operator|++
control|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|task
argument_list|,
argument|&rpctask_q
argument_list|,
argument|r_chain
argument_list|)
block|{
if|if
condition|(
name|rpc
operator|==
name|task
operator|->
name|r_rpcclnt
condition|)
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|task
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tsleep
argument_list|(
operator|&
name|lbolt
argument_list|,
name|PSOCK
argument_list|,
literal|"nfscancel"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rpcclnt_softterm
parameter_list|(
name|struct
name|rpctask
modifier|*
name|task
parameter_list|)
block|{
name|task
operator|->
name|r_flags
operator||=
name|R_SOFTTERM
expr_stmt|;
if|if
condition|(
name|task
operator|->
name|r_flags
operator|&
name|R_SENT
condition|)
block|{
name|task
operator|->
name|r_rpcclnt
operator|->
name|rc_sent
operator|-=
name|RPC_CWNDSCALE
expr_stmt|;
name|task
operator|->
name|r_flags
operator|&=
operator|~
name|R_SENT
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__OpenBSD__
end_ifndef

begin_comment
comment|/* called by rpcclnt_get() */
end_comment

begin_function
name|void
name|rpcclnt_create
parameter_list|(
name|struct
name|rpcclnt
modifier|*
modifier|*
name|rpc
parameter_list|)
block|{
name|MALLOC
argument_list|(
operator|*
name|rpc
argument_list|,
expr|struct
name|rpcclnt
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rpcclnt
argument_list|)
argument_list|,
name|M_RPC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called by rpcclnt_put() */
end_comment

begin_function
name|void
name|rpcclnt_destroy
parameter_list|(
name|struct
name|rpcclnt
modifier|*
name|rpc
parameter_list|)
block|{
if|if
condition|(
name|rpc
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|rpc
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RPCDEBUG
argument_list|(
literal|"attempting to free a NULL rpcclnt (not dereferenced)"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__OpenBSD__ */
end_comment

begin_comment
comment|/* XXX: add a lock around the auth structure in struct rpcclnt and make this  * call safe for calling durring a connection */
end_comment

begin_function
specifier|static
name|int
name|rpcauth_buildheader
parameter_list|(
name|struct
name|rpc_auth
modifier|*
name|auth
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mhdr
parameter_list|,
name|caddr_t
modifier|*
name|bp
parameter_list|)
block|{
name|size_t
name|authsiz
decl_stmt|,
name|verfsiz
decl_stmt|;
name|uint32_t
name|mlen
decl_stmt|,
name|grpsiz
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|,
modifier|*
name|mb2
decl_stmt|;
name|caddr_t
name|bpos
decl_stmt|;
specifier|register
name|u_int32_t
modifier|*
name|tl
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|auth
operator|==
name|NULL
operator|||
name|mhdr
operator|==
name|NULL
condition|)
return|return
name|EFAULT
return|;
switch|switch
condition|(
name|auth
operator|->
name|auth_type
condition|)
block|{
case|case
name|RPCAUTH_NULL
case|:
name|authsiz
operator|=
literal|0
expr_stmt|;
name|verfsiz
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RPCAUTH_UNIX
case|:
name|authsiz
operator|=
operator|(
literal|5
operator|+
name|cred
operator|->
name|cr_ngroups
operator|)
operator|*
name|RPCX_UNSIGNED
expr_stmt|;
name|verfsiz
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|EPROTONOSUPPORT
return|;
break|break;
block|}
empty_stmt|;
name|mlen
operator|=
name|rpcm_rndup
argument_list|(
name|authsiz
argument_list|)
operator|+
name|rpcm_rndup
argument_list|(
name|verfsiz
argument_list|)
operator|+
literal|4
operator|*
name|RPCX_UNSIGNED
expr_stmt|;
name|mb
operator|=
operator|*
name|mhdr
expr_stmt|;
name|bpos
operator|=
operator|*
name|bp
expr_stmt|;
name|rpcm_build
argument_list|(
name|tl
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
name|bpos
expr_stmt|;
operator|*
name|mhdr
operator|=
name|mb
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|auth
operator|->
name|auth_type
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|authsiz
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|auth
operator|->
name|auth_type
condition|)
block|{
case|case
name|RPCAUTH_UNIX
case|:
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|grpsiz
operator|=
name|cred
operator|->
name|cr_ngroups
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|grpsiz
argument_list|)
expr_stmt|;
comment|/* XXX: groups[0] is already sent... */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|grpsiz
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|cred
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* null verification header */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|RPCAUTH_NULL
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|++
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|RPCAUTH_NULL
case|:
comment|/* just a null verf header */
operator|*
name|tl
operator|++
operator|=
name|txdr_unsigned
argument_list|(
name|RPCAUTH_NULL
argument_list|)
expr_stmt|;
operator|*
name|tl
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"inconsistent rpc auth type"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

