begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_pppoe.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_pppoe.c,v 1.10 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|AAA
value|printf("pppoe: %s\n", __FUNCTION__ );
end_define

begin_define
define|#
directive|define
name|BBB
value|printf("-%d-", __LINE__ );
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|AAA
end_define

begin_define
define|#
directive|define
name|BBB
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pppoe.h>
end_include

begin_define
define|#
directive|define
name|SIGNOFF
value|"session closed"
end_define

begin_comment
comment|/*  * This section contains the netgraph method declarations for the  * pppoe node. These methods define the netgraph pppoe 'type'.  */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_pppoe_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_pppoe_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_pppoe_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_pppoe_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_pppoe_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_pppoe_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_pppoe_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_PPPOE_NODE_TYPE
block|,
name|NULL
block|,
name|ng_pppoe_constructor
block|,
name|ng_pppoe_rcvmsg
block|,
name|ng_pppoe_rmnode
block|,
name|ng_pppoe_newhook
block|,
name|NULL
block|,
name|ng_pppoe_connect
block|,
name|ng_pppoe_rcvdata
block|,
name|ng_pppoe_rcvdata
block|,
name|ng_pppoe_disconnect
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|pppoe
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * States for the session state machine.  * These have no meaning if there is no hook attached yet.  */
end_comment

begin_enum
enum|enum
name|state
block|{
name|PPPOE_SNONE
init|=
literal|0
block|,
comment|/* [both] Initial state */
name|PPPOE_LISTENING
block|,
comment|/* [Daemon] Listening for discover initiation pkt */
name|PPPOE_SINIT
block|,
comment|/* [Client] Sent discovery initiation */
name|PPPOE_PRIMED
block|,
comment|/* [Server] Awaiting PADI from daemon */
name|PPPOE_SOFFER
block|,
comment|/* [Server] Sent offer message  (got PADI)*/
name|PPPOE_SREQ
block|,
comment|/* [Client] Sent a Request */
name|PPPOE_NEWCONNECTED
block|,
comment|/* [Server] Connection established, No data received */
name|PPPOE_CONNECTED
block|,
comment|/* [Both] Connection established, Data received */
name|PPPOE_DEAD
comment|/* [Both] */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NUMTAGS
value|20
end_define

begin_comment
comment|/* number of tags we are set up to work with */
end_comment

begin_comment
comment|/*  * Information we store for each hook on each node for negotiating the   * session. The mbuf and cluster are freed once negotiation has completed.  * The whole negotiation block is then discarded.  */
end_comment

begin_struct
struct|struct
name|sess_neg
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* holds cluster with last sent packet */
name|union
name|packet
modifier|*
name|pkt
decl_stmt|;
comment|/* points within the above cluster */
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
comment|/* see timeout(9) */
name|u_int
name|timeout
decl_stmt|;
comment|/* 0,1,2,4,8,16 etc. seconds */
name|u_int
name|numtags
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|tags
index|[
name|NUMTAGS
index|]
decl_stmt|;
name|u_int
name|service_len
decl_stmt|;
name|u_int
name|ac_name_len
decl_stmt|;
name|struct
name|datatag
name|service
decl_stmt|;
name|struct
name|datatag
name|ac_name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sess_neg
modifier|*
name|negp
typedef|;
end_typedef

begin_comment
comment|/*  * Session information that is needed after connection.  */
end_comment

begin_struct
struct|struct
name|sess_con
block|{
name|hook_p
name|hook
decl_stmt|;
name|u_int16_t
name|Session_ID
decl_stmt|;
name|enum
name|state
name|state
decl_stmt|;
name|char
name|creator
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* who to notify */
name|struct
name|pppoe_full_hdr
name|pkt_hdr
decl_stmt|;
comment|/* used when connected */
name|negp
name|neg
decl_stmt|;
comment|/* used when negotiating */
comment|/*struct sess_con	*hash_next;*/
comment|/* not yet used */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sess_con
modifier|*
name|sessp
typedef|;
end_typedef

begin_comment
comment|/*  * Information we store for each node  */
end_comment

begin_struct
struct|struct
name|PPPOE
block|{
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|hook_p
name|ethernet_hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from ethernet */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards ethernet */
name|u_int32_t
name|flags
decl_stmt|;
comment|/*struct sess_con *buckets[HASH_SIZE];*/
comment|/* not yet used */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|PPPOE
modifier|*
name|priv_p
typedef|;
end_typedef

begin_decl_stmt
name|struct
name|ether_header
name|eh_prototype
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
name|ETHERTYPE_PPPOE_DISC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nonstandard
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ngpppoe_set_ethertype
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|nonstandard
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
name|nonstandard
operator|=
literal|1
expr_stmt|;
name|eh_prototype
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_STUPID_DISC
expr_stmt|;
block|}
else|else
block|{
name|nonstandard
operator|=
literal|0
expr_stmt|;
name|eh_prototype
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_DISC
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|nonstandard_pppoe
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|ngpppoe_set_ethertype
argument_list|,
literal|"I"
argument_list|,
literal|"nonstandard ethertype"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_union
union|union
name|uniq
block|{
name|char
name|bytes
index|[
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
index|]
decl_stmt|;
name|void
modifier|*
name|pointer
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|LEAVE
parameter_list|(
name|x
parameter_list|)
value|do { error = x; goto quit; } while(0)
end_define

begin_function_decl
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppoe_send_event
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|enum
name|cmd
name|cmdid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************  * Some basic utilities  from the Linux version with author's permission.*  * Author:	Michal Ostrowski<mostrows@styx.uwaterloo.ca>		 *  ************************************************************************/
end_comment

begin_comment
comment|/*  * Generate a new session id  * XXX find out the FreeBSD locking scheme.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|get_new_sid
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|static
name|int
name|pppoe_sid
init|=
literal|10
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|AAA
name|restart
range|:
name|val
operator|=
name|pppoe_sid
operator|++
decl_stmt|;
comment|/* 	 * Spec says 0xFFFF is reserved. 	 * Also don't use 0x0000 	 */
if|if
condition|(
name|val
operator|==
literal|0xffff
condition|)
block|{
name|pppoe_sid
operator|=
literal|20
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Check it isn't already in use */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
name|val
condition|)
goto|goto
name|restart
goto|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Return the location where the next tag can be put   */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pppoe_tag
operator|*
name|next_tag
argument_list|(
argument|struct pppoe_hdr* ph
argument_list|)
block|{
return|return
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
operator|)
operator|+
name|ntohs
argument_list|(
name|ph
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Look for a tag of a specific type  * Don't trust any length the other end says.  * but assume we already sanity checked ph->length.  */
end_comment

begin_function
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|get_tag
parameter_list|(
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|,
name|u_int16_t
name|idx
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptn
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
name|AAA
while|while
condition|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 	     * If the tag data would go past the end of the packet, abort. 	     */
name|ptn
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pt
operator|->
name|tag_type
operator|==
name|idx
condition|)
return|return
name|pt
return|;
name|pt
operator|=
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * inlines to initialise or add tags to a session's tag list,  **************************************************************************/
end_comment

begin_comment
comment|/*  * Initialise the session's tag list  */
end_comment

begin_function
specifier|static
name|void
name|init_tags
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|AAA
if|if
condition|(
name|sp
operator|->
name|neg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: asked to init NULL neg pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_tag
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_tag
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|negp
name|neg
decl_stmt|;
name|AAA
if|if
condition|(
operator|(
name|neg
operator|=
name|sp
operator|->
name|neg
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: asked to use NULL neg pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|neg
operator|->
name|numtags
operator|++
operator|)
operator|<
name|NUMTAGS
condition|)
block|{
name|neg
operator|->
name|tags
index|[
name|i
index|]
operator|=
name|tp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pppoe: asked to add too many tags to packet\n"
argument_list|)
expr_stmt|;
name|neg
operator|->
name|numtags
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make up a packet, using the tags filled out for the session.  *  * Assume that the actual pppoe header and ethernet header   * are filled out externally to this routine.  * Also assume that neg->wh points to the correct   * location at the front of the buffer space.  */
end_comment

begin_function
specifier|static
name|void
name|make_packet
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
init|=
operator|&
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|u_int16_t
name|length
init|=
literal|0
decl_stmt|;
name|AAA
if|if
condition|(
operator|(
name|sp
operator|->
name|neg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sp
operator|->
name|neg
operator|->
name|m
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: make_packet called from wrong state\n"
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|wh
operator|->
name|ph
operator|.
name|tag
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|tag
operator|=
name|sp
operator|->
name|neg
operator|->
name|tags
init|;
operator|(
operator|(
name|count
operator|<
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|)
operator|&&
operator|(
name|count
operator|<
name|NUMTAGS
operator|)
operator|)
condition|;
name|tag
operator|++
operator|,
name|count
operator|++
control|)
block|{
name|tlen
operator|=
name|ntohs
argument_list|(
operator|(
operator|*
name|tag
operator|)
operator|->
name|tag_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|+
name|tlen
operator|)
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
literal|4
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: tags too long\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
name|count
expr_stmt|;
break|break;
comment|/* XXX chop off what's too long */
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|length
operator|+=
name|tlen
expr_stmt|;
name|dp
operator|+=
name|tlen
expr_stmt|;
block|}
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routine to match a service offered					  *  **************************************************************************/
end_comment

begin_comment
comment|/*   * Find a hook that has a service string that matches that  * we are seeking. for now use a simple string.  * In the future we may need something like regexp().  * for testing allow a null string to match 1st found and a null service  * to match all requests. Also make '*' do the same.  */
end_comment

begin_define
define|#
directive|define
name|NG_MATCH_EXACT
value|1
end_define

begin_define
define|#
directive|define
name|NG_MATCH_ANY
value|2
end_define

begin_function
specifier|static
name|hook_p
name|pppoe_match_svc
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|svc_name
parameter_list|,
name|int
name|svc_len
parameter_list|,
name|int
name|match
parameter_list|)
block|{
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|hook_p
name|allhook
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|AAA
name|LIST_FOREACH
argument_list|(
name|hook
argument_list|,
operator|&
name|node
operator|->
name|hooks
argument_list|,
name|hooks
argument_list|)
block|{
comment|/* skip any hook that is debug or ethernet */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
comment|/* Skip any sessions which are not in LISTEN mode. */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_LISTENING
condition|)
continue|continue;
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
comment|/* Special case for a blank or "*" service name (wildcard) */
if|if
condition|(
name|match
operator|==
name|NG_MATCH_ANY
operator|&&
name|neg
operator|->
name|service_len
operator|==
literal|1
operator|&&
name|neg
operator|->
name|service
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
block|{
name|allhook
operator|=
name|hook
expr_stmt|;
continue|continue;
block|}
comment|/* If the lengths don't match, that aint it. */
if|if
condition|(
name|neg
operator|->
name|service_len
operator|!=
name|svc_len
condition|)
continue|continue;
comment|/* An exact match? */
if|if
condition|(
name|svc_len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|svc_name
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|svc_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|hook
condition|?
name|hook
else|:
name|allhook
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routine to find a particular session that matches an incoming packet	  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_findsession
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
parameter_list|)
block|{
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|u_int16_t
name|session
init|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
decl_stmt|;
comment|/* 	 * find matching peer/session combination. 	 */
name|AAA
name|LIST_FOREACH
argument_list|(
name|hook
argument_list|,
operator|&
name|node
operator|->
name|hooks
argument_list|,
name|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
block|{
continue|continue;
block|}
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_CONNECTED
operator|)
operator|||
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|->
name|Session_ID
operator|==
name|session
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|hook_p
name|pppoe_finduniq
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|union
name|uniq
name|uniq
decl_stmt|;
name|AAA
name|bcopy
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|uniq
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* cycle through all known hooks */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
if|if
condition|(
name|uniq
operator|.
name|pointer
operator|==
name|hook
operator|->
name|private
condition|)
break|break;
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * start of Netgraph entrypoints					  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Allocate the private data structure and the generic node  * and link them together.  *  * ng_make_node_common() returns with a generic node struct  * with a single reference for us.. we transfer it to the  * private structure.. when we free the private struct we must  * unref the node so it gets freed too.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|priv_p
name|privdata
decl_stmt|;
name|int
name|error
decl_stmt|;
name|AAA
comment|/* Initialize private descriptor */
name|MALLOC
argument_list|(
name|privdata
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|privdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|privdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the 'generic' (ie, superclass) node constructor */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Link structs together; this counts as our one reference to *nodep */
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|privdata
expr_stmt|;
name|privdata
operator|->
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our ok for a hook to be added...  * point the hook's private info to the hook structure.  *  * The following hook names are special:  *  Ethernet:  the hook that should be connected to a NIC.  *  debug:	copies of data sent out here  (when I write the code).  * All other hook names need only be unique. (the framework checks this).  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|AAA
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_ETHERNET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
operator|&
name|privp
operator|->
name|ethernet_hook
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
operator|&
name|privp
operator|->
name|debug_hook
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Any other unique name is OK. 		 * The infrastructure has already checked that it's unique, 		 * so just allocate it and hook it in. 		 */
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|sessp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a netgraph control message.  * Check it is one we understand. If needed, send a response.  * We sometimes save the address for an async action later.  * Always free the message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ngpppoe_init_data
modifier|*
name|ourmsg
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|AAA
comment|/* Deal with message according to cookie and command */
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPPOE_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_CONNECT
case|:
case|case
name|NGM_PPPOE_LISTEN
case|:
case|case
name|NGM_PPPOE_OFFER
case|:
case|case
name|NGM_PPPOE_SERVICE
case|:
name|ourmsg
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|>
name|msg
operator|->
name|header
operator|.
name|arglen
operator|)
operator|||
operator|(
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|+
name|ourmsg
operator|->
name|data_len
operator|)
operator|>
name|msg
operator|->
name|header
operator|.
name|arglen
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe_rcvmsg: bad arg size"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ourmsg
operator|->
name|data_len
operator|>
name|PPPOE_SERVICE_NAME_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: init data too long (%d)\n"
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* make sure strcmp will terminate safely */
name|ourmsg
operator|->
name|hook
index|[
sizeof|sizeof
argument_list|(
name|ourmsg
operator|->
name|hook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* cycle through all known hooks */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
if|if
condition|(
name|hook
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|ourmsg
operator|->
name|hook
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPPOE_LISTEN
condition|)
block|{
comment|/* 				 * Ensure we aren't already listening for this 				 * service. 				 */
if|if
condition|(
name|pppoe_match_svc
argument_list|(
name|node
argument_list|,
name|ourmsg
operator|->
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|,
name|NG_MATCH_EXACT
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * PPPOE_SERVICE advertisments are set up 			 * on sessions that are in PRIMED state. 			 */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPPOE_SERVICE
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator||=
name|PPPOE_SNONE
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session already active\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * set up prototype header 			 */
name|MALLOC
argument_list|(
name|neg
argument_list|,
name|negp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session out of memory\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|neg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session out of mbufs\n"
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|MCLGET
argument_list|(
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neg
operator|->
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session out of mcls\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|neg
operator|=
name|neg
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pppoe_full_hdr
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|=
name|mtod
argument_list|(
name|neg
operator|->
name|m
argument_list|,
expr|union
name|packet
operator|*
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|=
name|eh_prototype
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|ver
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|type
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
literal|0x0000
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|sp
operator|->
name|creator
argument_list|,
name|retaddr
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|creator
index|[
name|NG_NODELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_GET_STATUS
case|:
block|{
name|struct
name|ngpppoestat
modifier|*
name|stats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
operator|(
expr|struct
name|ngpppoestat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|stats
operator|->
name|packets_in
operator|=
name|privp
operator|->
name|packets_in
expr_stmt|;
name|stats
operator|->
name|packets_out
operator|=
name|privp
operator|->
name|packets_out
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPPOE_CONNECT
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Send a PADI request, and start the timeout logic. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the session to SINIT 			 * Set up the session to the correct state and 			 * start it. 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
block|{
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|pppoe_start
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_LISTEN
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Install the service matching string. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the hook to 'LISTENING' 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
block|{
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADT_CODE
expr_stmt|;
comment|/* 			 * wait for PADI packet coming from ethernet 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_LISTENING
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_OFFER
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Store the AC-Name given and go to PRIMED. 			 */
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_NAME
expr_stmt|;
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
block|{
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|ac_name
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|ac_name_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * Wait for PADI packet coming from hook 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_PRIMED
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SERVICE
case|:
comment|/*  			 * Check the session is primed. 			 * for now just allow ONE service to be advertised. 			 * If you do it twice you just overwrite. 			 */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_PRIMED
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session not primed\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of synchronous response, if any */
if|if
condition|(
name|rptr
condition|)
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
condition|)
name|FREE
argument_list|(
name|resp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
comment|/* Free the message and return */
name|quit
label|:
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a client into the first state. A separate function because  * it can be needed if the negotiation times out.  */
end_comment

begin_function
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|__attribute
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|uniqtag
struct|;
comment|/*  	 * kick the state machine into starting up 	 */
name|AAA
name|sp
operator|->
name|state
init|=
name|PPPOE_SINIT
decl_stmt|;
comment|/* reset the packet header to broadcast */
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|=
name|eh_prototype
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADI_CODE
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_HOST_UNIQ
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|uniqtag
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_acname
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
decl_stmt|;
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_ACNAME
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sts
operator|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|strncpy
argument_list|(
name|sts
operator|->
name|hook
argument_list|,
name|tag
operator|->
name|tag_data
argument_list|,
name|min
argument_list|(
name|NG_HOOKLEN
operator|+
literal|1
argument_list|,
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_send_msg
argument_list|(
name|sp
operator|->
name|hook
operator|->
name|node
argument_list|,
name|msg
argument_list|,
name|sp
operator|->
name|creator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data, and do something with it.  * The caller will never free m or meta, so  * if we use up this data or abort we must free BOTH of these.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
name|struct
name|pppoe_hdr
modifier|*
name|ph
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|session
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
name|u_int8_t
name|code
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|utag
init|=
name|NULL
decl_stmt|,
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|hook_p
name|sendhook
decl_stmt|;
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|__attribute
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
name|uniqtag
struct|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|AAA
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
comment|/* 		 * Data from the debug hook gets sent without modification 		 * straight to the ethernet.  		 */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
comment|/* 		 * Incoming data.  		 * Dig out various fields from the packet. 		 * use them to decide where to send it. 		 */
name|privp
operator|->
name|packets_in
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checks length */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't m_pullup\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|eh
operator|.
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_PPPOE_STUPID_DISC
case|:
name|nonstandard
operator|=
literal|1
expr_stmt|;
name|eh_prototype
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_STUPID_DISC
expr_stmt|;
comment|/* fall through */
case|case
name|ETHERTYPE_PPPOE_DISC
case|:
comment|/* 			 * We need to try to make sure that the tag area 			 * is contiguous, or we could wander off the end 			 * of a buffer and make a mess.  			 * (Linux wouldn't have this problem). 			 */
comment|/*XXX fix this mess */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|MHLEN
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"couldn't m_pullup\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
comment|/* 				 * It's not all in one piece. 				 * We need to do extra work. 				 */
name|printf
argument_list|(
literal|"packet fragmented\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PADI_CODE
case|:
comment|/* 				 * We are a server: 				 * Look for a hook with the required service 				 * and send the ENTIRE packet up there. 				 * It should come back to a new hook in  				 * PRIMED state. Look there for further 				 * processing. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no service tag\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_match_svc
argument_list|(
name|hook
operator|->
name|node
argument_list|,
name|tag
operator|->
name|tag_data
argument_list|,
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
argument_list|,
name|NG_MATCH_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
condition|)
block|{
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PADO_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the  				 * hook this is in response to. 				 * Received #2, now send #3 				 * For now simply accept the first we receive. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"no host unique field\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"no matching session\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SINIT. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SINIT
condition|)
block|{
name|printf
argument_list|(
literal|"session in wrong state\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
comment|/* 				 * This is the first time we hear 				 * from the server, so note it's 				 * unicast address, replacing the 				 * broadcast address . 				 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADR_CODE
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|utag
argument_list|)
expr_stmt|;
comment|/* Host Unique */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return cookie */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_NAME
argument_list|)
operator|)
condition|)
block|{
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return it */
name|send_acname
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* Service */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SREQ
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADR_CODE
case|:
comment|/* 				 * We are a server: 				 * Use the ac_cookie tag to find the  				 * hook this is in response to. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SOFFER 				 * or PPPOE_NEWCONNECTED. If the latter, 				 * then this is a retry by the client. 				 * so be nice, and resend. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
comment|/* 					 * Whoa! drop back to resend that  					 * PADS packet. 					 * We should still have a copy of it. 					 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SOFFER
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADS_CODE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
literal|0
condition|)
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
name|htons
argument_list|(
name|sp
operator|->
name|Session_ID
operator|=
name|get_new_sid
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* 				 * start working out the tags to respond with. 				 */
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return service */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return it */
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|utag
argument_list|)
expr_stmt|;
comment|/* ac_cookie */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_NEWCONNECTED
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 				 * Having sent the last Negotiation header, 				 * Set up the stored packet header to  				 * be correct for the actual session. 				 * But keep the negotialtion stuff 				 * around in case we need to resend this last  				 * packet. We'll discard it when we move 				 * from NEWCONNECTED to CONNECTED 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
if|if
condition|(
name|nonstandard
condition|)
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_STUPID_SESS
expr_stmt|;
else|else
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADS_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the  				 * hook this is in response to. 				 * take the session ID and store it away. 				 * Also make sure the pre-made header is 				 * correct and set us into Session mode. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SREQ. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SREQ
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
name|wh
operator|->
name|ph
operator|.
name|sid
expr_stmt|;
name|sp
operator|->
name|Session_ID
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
comment|/* 				 * Now we have gone to Connected mode,  				 * Free all resources needed for  				 * negotiation. 				 * Keep a copy of the header we will be using. 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
if|if
condition|(
name|nonstandard
condition|)
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_STUPID_SESS
expr_stmt|;
else|else
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADT_CODE
case|:
comment|/* 				 * Send a 'close' message to the controlling 				 * process (the one that set us up); 				 * And then tear everything down. 				 * 				 * Find matching peer/session combination. 				 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|/* no longer needed */
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* send message to creator */
comment|/* close hook */
if|if
condition|(
name|sendhook
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETHERTYPE_PPPOE_STUPID_SESS
case|:
case|case
name|ETHERTYPE_PPPOE_SESS
case|:
comment|/* 			 * find matching peer/session combination. 			 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|length
condition|)
block|{
comment|/* Packet too short, dump it */
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Also need to trim excess at the end */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|length
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_CONNECTED
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
comment|/* 					 * Now we have gone to Connected mode,  					 * Free all resources needed for  					 * negotiation. Be paranoid about 					 * whether there may be a timeout. 					 */
name|m_freem
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|sp
operator|->
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * 	Not ethernet or debug hook.. 		 * 		 * The packet has come in on a normal hook. 		 * We need to find out what kind of hook, 		 * So we can decide how to handle it. 		 * Check the hook's state. 		 */
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_NEWCONNECTED
case|:
case|case
name|PPPOE_CONNECTED
case|:
block|{
specifier|static
specifier|const
name|u_char
name|addrctrl
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x03
block|}
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
comment|/* 			 * Remove PPP address and control fields, if any. 			 * For example, ng_ppp(4) always sends LCP packets 			 * with address and control fields as required by 			 * generic PPP. PPPoE is an exception to the rule. 			 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|!
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|addrctrl
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Bang in a pre-made header, and set the length up 			 * to be correct. Then send it to the ethernet driver. 			 * But first correct the length. 			 */
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
call|(
name|short
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sp
operator|->
name|pkt_hdr
argument_list|,
name|wh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|PPPOE_PRIMED
case|:
comment|/* 			 * A PADI packet is being returned by the application 			 * that has set up this hook. This indicates that it  			 * wants us to offer service. 			 */
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|PADI_CODE
condition|)
block|{
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
comment|/* 			 * This is the first time we hear 			 * from the client, so note it's 			 * unicast address, replacing the 			 * broadcast address. 			 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * start working out the tags to respond with. 			 */
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_COOKIE
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return service */
comment|/* 			 * If we have a NULL service request 			 * and have an extra service defined in this hook, 			 * then also add a tag for the extra service. 			 * XXX this is a hack. eventually we should be able 			 * to support advertising many services, not just one  			 */
if|if
condition|(
operator|(
operator|(
name|tag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tag
operator|->
name|tag_len
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|!=
literal|0
operator|)
condition|)
block|{
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* SERVICE */
block|}
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned hostunique */
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Packets coming from the hook make no sense 		 * to sessions in these states. Throw them away. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
case|case
name|PPPOE_SOFFER
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
default|default:
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
name|quit
label|:
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing..  * If we are a persistant device, we might refuse to go away, and  * we'd only remove our links and reset ourself.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|privdata
init|=
name|node
operator|->
name|private
decl_stmt|;
name|AAA
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|privdata
operator|->
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called once we've already connected a new hook to the other node.  * It gives us a chance to balk at the last minute.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* be really amiable and just say "YUP that's OK by me! " */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * Clean up all dangling links and information about the session/hook.  * For this type, removal of the last link destroys the node  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|int
name|hooks
decl_stmt|;
name|AAA
name|hooks
init|=
name|node
operator|->
name|numhooks
decl_stmt|;
comment|/* this one already not counted */
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|NULL
expr_stmt|;
name|ng_rmnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SNONE
condition|)
block|{
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_CLOSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * According to the spec, if we are connected, 		 * we should send a DISC packet if we are shutting down 		 * a session. 		 */
if|if
condition|(
operator|(
name|privp
operator|->
name|ethernet_hook
operator|)
operator|&&
operator|(
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_CONNECTED
operator|)
operator|||
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
operator|)
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|tag
decl_stmt|;
name|int
name|msglen
init|=
name|strlen
argument_list|(
name|SIGNOFF
argument_list|)
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* revert the stored header to DISC/PADT mode */
name|wh
operator|=
operator|&
name|sp
operator|->
name|pkt_hdr
expr_stmt|;
name|wh
operator|->
name|ph
operator|.
name|code
operator|=
name|PADT_CODE
expr_stmt|;
if|if
condition|(
name|nonstandard
condition|)
name|wh
operator|->
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_STUPID_DISC
expr_stmt|;
else|else
name|wh
operator|->
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_DISC
expr_stmt|;
comment|/* generate a packet of that type */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"pppoe: Session out of mbufs\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|wh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Add a General error message and adjust 				 * sizes 				 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|tag
operator|=
name|wh
operator|->
name|ph
operator|.
name|tag
expr_stmt|;
name|tag
operator|->
name|tag_type
operator|=
name|PTT_GEN_ERR
expr_stmt|;
name|tag
operator|->
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|msglen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|SIGNOFF
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
operator|+
name|msglen
operator|)
expr_stmt|;
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
operator|+
name|msglen
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * As long as we have somewhere to store the timeout handle, 		 * we may have a timeout pending.. get rid of it. 		 */
if|if
condition|(
name|sp
operator|->
name|neg
condition|)
block|{
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|sp
operator|->
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|neg
operator|->
name|m
condition|)
name|m_freem
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|sp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
comment|/* work out how many session hooks there are */
comment|/* Node goes away on last session hook removal */
if|if
condition|(
name|privp
operator|->
name|ethernet_hook
condition|)
name|hooks
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|debug_hook
condition|)
name|hooks
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * timeouts come here.  */
end_comment

begin_function
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|hook_p
name|hook
init|=
name|arg
decl_stmt|;
name|sessp
name|sp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|meta_p
name|dummy
init|=
name|NULL
decl_stmt|;
name|AAA
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
comment|/* 		 * resend the last packet, using an exponential backoff. 		 * After a period of time, stop growing the backoff, 		 * and either leave it, or revert to the start. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
comment|/* timeouts on these produce resends */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|neg
operator|->
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neg
operator|->
name|timeout
operator|<<=
literal|1
operator|)
operator|>
name|PPPOE_TIMEOUT_LIMIT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_SREQ
condition|)
block|{
comment|/* revert to SINIT mode */
name|pppoe_start
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|neg
operator|->
name|timeout
operator|=
name|PPPOE_TIMEOUT_LIMIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PPPOE_PRIMED
case|:
case|case
name|PPPOE_SOFFER
case|:
comment|/* a timeout on these says "give up" */
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* timeouts have no meaning in other states */
name|printf
argument_list|(
literal|"pppoe: unexpected timeout\n"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|sp
operator|->
name|hook
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|priv_p
name|privp
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|meta_p
name|dummy
init|=
name|NULL
decl_stmt|;
name|AAA
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_CONNECTED
case|:
name|printf
argument_list|(
literal|"pppoe: sendpacket: unexpected state\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_NEWCONNECTED
case|:
comment|/* send the PADS without a timeout - we're now connected */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_PRIMED
case|:
comment|/* No packet to send, but set up the timeout */
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SOFFER
case|:
comment|/* 		 * send the offer but if they don't respond 		 * in PPPOE_OFFER_TIMEOUT seconds, forget about it. 		 */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
operator|(
name|hz
operator|*
name|PPPOE_INITIAL_TIMEOUT
operator|)
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
name|PPPOE_INITIAL_TIMEOUT
operator|*
literal|2
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"pppoe: timeout: bad state\n"
argument_list|)
expr_stmt|;
block|}
comment|/* return (error); */
block|}
end_function

begin_comment
comment|/*  * Parse an incoming packet to see if any tags should be copied to the  * output packet. Don't do any tags that have been handled in the main  * state machine.  */
end_comment

begin_function
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptn
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
name|AAA
while|while
condition|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 		 * If the tag data would go past the end of the packet, abort. 		 */
name|ptn
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|pt
operator|->
name|tag_type
condition|)
block|{
case|case
name|PTT_RELAY_SID
case|:
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|pt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTT_EOL
case|:
return|return
name|NULL
return|;
case|case
name|PTT_SRV_NAME
case|:
case|case
name|PTT_AC_NAME
case|:
case|case
name|PTT_HOST_UNIQ
case|:
case|case
name|PTT_AC_COOKIE
case|:
case|case
name|PTT_VENDOR
case|:
case|case
name|PTT_SRV_ERR
case|:
case|case
name|PTT_SYS_ERR
case|:
case|case
name|PTT_GEN_ERR
case|:
break|break;
block|}
name|pt
operator|=
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pppoe_send_event
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|enum
name|cmd
name|cmdid
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
decl_stmt|;
name|AAA
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|cmdid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sts
operator|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|strncpy
argument_list|(
name|sts
operator|->
name|hook
argument_list|,
name|sp
operator|->
name|hook
operator|->
name|name
argument_list|,
name|NG_HOOKLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_send_msg
argument_list|(
name|sp
operator|->
name|hook
operator|->
name|node
argument_list|,
name|msg
argument_list|,
name|sp
operator|->
name|creator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

