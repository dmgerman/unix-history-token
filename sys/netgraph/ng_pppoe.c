begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_pppoe.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@whistle.com>  *  * $FreeBSD$  * $Whistle: ng_pppoe.c,v 1.7 1999/10/16 10:16:43 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pppoe.h>
end_include

begin_comment
comment|/*  * This section contains the netgraph method declarations for the  * sample node. These methods define the netgraph 'type'.  */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_constructor
parameter_list|(
name|node_p
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_PPPoE_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_PPPOE_NODE_TYPE
block|,
name|NULL
block|,
name|ng_PPPoE_constructor
block|,
name|ng_PPPoE_rcvmsg
block|,
name|ng_PPPoE_rmnode
block|,
name|ng_PPPoE_newhook
block|,
name|NULL
block|,
name|ng_PPPoE_connect
block|,
name|ng_PPPoE_rcvdata
block|,
name|ng_PPPoE_rcvdata
block|,
name|ng_PPPoE_disconnect
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|PPPoE
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * States for the session state machine.  * These have no meaning if there is no hook attached yet.  */
end_comment

begin_enum
enum|enum
name|state
block|{
name|PPPOE_SNONE
init|=
literal|0
block|,
comment|/* [both] Initial state */
name|PPPOE_SINIT
block|,
comment|/* [Client] Sent discovery initiation */
name|PPPOE_PRIMED
block|,
comment|/* [Server] Sent offer message */
name|PPPOE_SOFFER
block|,
comment|/* [Server] Sent offer message */
name|PPPOE_SREQ
block|,
comment|/* [Client] Sent a Request */
name|PPPOE_LISTENING
block|,
comment|/* [Server] Listening for discover initiation msg */
name|PPPOE_NEWCONNECTED
block|,
comment|/* [Both] Connection established, No data received */
name|PPPOE_CONNECTED
block|,
comment|/* [Both] Connection established, Data received */
name|PPPOE_DEAD
comment|/* [Both] */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Events for the state machine  */
end_comment

begin_enum
enum|enum
name|event
block|{
name|PPPOE_TIMEOUT
block|,
comment|/* It's time to do something */
name|PPPOE_PACKET
block|,
comment|/* a packet has been received. */
name|PPPOE_CLOSE
comment|/* start shutdown processing */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NUMTAGS
value|20
end_define

begin_comment
comment|/* number of tags we are set up to work with */
end_comment

begin_comment
comment|/*  * Information we store for each hook on each node for negotiating the   * session. The mbuf and cluster are freed once negotiation has completed.  * The whole negotiation block is then discarded.  */
end_comment

begin_struct
struct|struct
name|sess_neg
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* holds cluster with last sent packet */
name|union
name|packet
modifier|*
name|pkt
decl_stmt|;
comment|/* points within the above cluster */
name|struct
name|callout_handle
name|timeout_handle
decl_stmt|;
comment|/* see timeout(9) */
name|u_int
name|timeout
decl_stmt|;
comment|/* 0,1,2,4,8,16 etc. seconds */
name|u_int
name|numtags
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|tags
index|[
name|NUMTAGS
index|]
decl_stmt|;
name|u_int
name|service_len
decl_stmt|;
name|u_int
name|ac_name_len
decl_stmt|;
name|struct
name|datatag
name|service
decl_stmt|;
name|struct
name|datatag
name|ac_name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sess_neg
modifier|*
name|negp
typedef|;
end_typedef

begin_comment
comment|/*  * Session information that is needed after connection.  */
end_comment

begin_struct
struct|struct
name|session
block|{
name|hook_p
name|hook
decl_stmt|;
name|u_int16_t
name|Session_ID
decl_stmt|;
name|struct
name|session
modifier|*
name|hash_next
decl_stmt|;
comment|/* not yet uesed */
name|enum
name|state
name|state
decl_stmt|;
name|char
name|creator
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* who to notify */
name|struct
name|pppoe_full_hdr
name|pkt_hdr
decl_stmt|;
comment|/* used when connected */
name|negp
name|neg
decl_stmt|;
comment|/* used when negotiating */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|session
modifier|*
name|sessp
typedef|;
end_typedef

begin_comment
comment|/*  * Information we store for each node  */
end_comment

begin_struct
struct|struct
name|PPPOE
block|{
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|hook_p
name|ethernet_hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from ethernet */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards ethernet */
name|u_int32_t
name|flags
decl_stmt|;
comment|/*struct session *buckets[HASH_SIZE];*/
comment|/* not yet used */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|PPPOE
modifier|*
name|priv_p
typedef|;
end_typedef

begin_decl_stmt
specifier|const
name|struct
name|ether_header
name|eh_prototype
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
name|ETHERTYPE_PPPOE_DISC
block|}
decl_stmt|;
end_decl_stmt

begin_union
union|union
name|uniq
block|{
name|char
name|bytes
index|[
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
index|]
decl_stmt|;
name|void
modifier|*
name|pointer
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|LEAVE
parameter_list|(
name|x
parameter_list|)
value|do { error = x; goto quit; } while(0)
end_define

begin_function_decl
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************  * Some basic utilities  from the Linux version with author's permission.*  * Author:	Michal Ostrowski<mostrows@styx.uwaterloo.ca>		 *  ************************************************************************/
end_comment

begin_comment
comment|/*  * Generate a new session id  * XXX find out the freeBSD locking scheme.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|get_new_sid
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|static
name|int
name|pppoe_sid
init|=
literal|10
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|u_int16_t
name|val
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|restart
label|:
name|val
operator|=
name|pppoe_sid
operator|++
expr_stmt|;
comment|/* 	 * Spec says 0xFFFF is reserved. 	 * Also don't use 0x0000 	 */
if|if
condition|(
name|val
operator|==
literal|0xffff
condition|)
block|{
name|pppoe_sid
operator|=
literal|20
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Check it isn't already in use */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
name|val
condition|)
goto|goto
name|restart
goto|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Return the location where the next tag can be put   */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pppoe_tag
operator|*
name|next_tag
argument_list|(
argument|struct pppoe_hdr* ph
argument_list|)
block|{
return|return
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
operator|)
operator|+
name|ntohs
argument_list|(
name|ph
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Look for a tag of a specific type  * Don't trust any length the other end says.  * but assume we already sanity checked ph->length.  */
end_comment

begin_function
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|get_tag
parameter_list|(
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|,
name|u_int16_t
name|idx
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptn
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
while|while
condition|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 	     * If the tag data would go past the end of the packet, abort. 	     */
name|ptn
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pt
operator|->
name|tag_type
operator|==
name|idx
condition|)
return|return
name|pt
return|;
name|pt
operator|=
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * inlines to initialise or add tags to a session's tag list,  **************************************************************************/
end_comment

begin_comment
comment|/*  * Initialise the session's tag list  */
end_comment

begin_function
specifier|static
name|void
name|init_tags
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|neg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: asked to init NULL neg pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_tag
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_tag
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|negp
name|neg
decl_stmt|;
if|if
condition|(
operator|(
name|neg
operator|=
name|sp
operator|->
name|neg
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: asked to use NULL neg pointer\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|neg
operator|->
name|numtags
operator|++
operator|)
operator|<
name|NUMTAGS
condition|)
block|{
name|neg
operator|->
name|tags
index|[
name|i
index|]
operator|=
name|tp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"pppoe: asked to add too many tags to packet\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make up a packet, using the tags filled out for the session.  *  * Assume that the actual pppoe header and ethernet header   * are filled out externally to this routine.  * Also assume that neg->wh points to the correct   * location at the front of the buffer space.  */
end_comment

begin_function
specifier|static
name|void
name|make_packet
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
init|=
operator|&
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|u_int16_t
name|length
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|neg
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sp
operator|->
name|neg
operator|->
name|m
operator|=
name|NULL
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: make_packet called from wrong state\n"
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|wh
operator|->
name|ph
operator|.
name|tag
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|tag
operator|=
name|sp
operator|->
name|neg
operator|->
name|tags
init|;
operator|(
operator|(
name|count
operator|<
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|)
operator|&&
operator|(
name|count
operator|<
name|NUMTAGS
operator|)
operator|)
condition|;
name|tag
operator|++
operator|,
name|count
operator|++
control|)
block|{
name|tlen
operator|=
name|ntohs
argument_list|(
operator|(
operator|*
name|tag
operator|)
operator|->
name|tag_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|+
name|tlen
operator|)
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
literal|4
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: tags too long\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
name|count
expr_stmt|;
break|break;
comment|/* XXX chop off what's too long */
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|*
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|length
operator|+=
name|tlen
expr_stmt|;
name|dp
operator|+=
name|tlen
expr_stmt|;
block|}
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routine to match a service offered					  *  **************************************************************************/
end_comment

begin_comment
comment|/*   * Find a hook that has a service string that matches that  * we are seeking. for now use a simple string.  * In the future we may need something like regexp().  * for testing allow a null string to match 1st found and a null service  * to match all requests. Also make '*' do the same.  */
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_match_svc
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|svc_name
parameter_list|,
name|int
name|svc_len
parameter_list|)
block|{
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* skip any hook that is debug or ethernet */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
comment|/* Skip any sessions which are not in LISTEN mode. */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_LISTENING
condition|)
continue|continue;
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
comment|/* XXX check validity of this */
comment|/* special case, NULL request. match 1st found. */
if|if
condition|(
name|svc_len
operator|==
literal|0
condition|)
break|break;
comment|/* XXX check validity of this */
comment|/* Special case for a blank or "*" service name (wildcard) */
if|if
condition|(
operator|(
name|neg
operator|->
name|service_len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|neg
operator|->
name|service_len
operator|==
literal|1
operator|)
operator|&&
operator|(
name|neg
operator|->
name|service
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* If the lengths don't match, that aint it. */
if|if
condition|(
name|neg
operator|->
name|service_len
operator|!=
name|svc_len
condition|)
continue|continue;
comment|/* An exact match? */
if|if
condition|(
name|strncmp
argument_list|(
name|svc_name
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|svc_len
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routine to find a particular session that matches an incoming packet	  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_findsession
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
parameter_list|)
block|{
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|u_int16_t
name|session
init|=
name|wh
operator|->
name|ph
operator|.
name|sid
decl_stmt|;
comment|/* 	 * find matching peer/session combination. 	 */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
block|{
continue|continue;
block|}
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_CONNECTED
operator|)
operator|||
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|->
name|Session_ID
operator|==
name|session
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|hook_p
name|pppoe_finduniq
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|union
name|uniq
name|uniq
decl_stmt|;
name|bcopy
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|uniq
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cycle through all known hooks */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
if|if
condition|(
name|uniq
operator|.
name|pointer
operator|==
name|hook
operator|->
name|private
condition|)
break|break;
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * start of Netgraph entrypoints					  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Allocate the private data structure and the generic node  * and link them together.  *  * ng_make_node_common() returns with a generic node struct  * with a single reference for us.. we transfer it to the  * private structure.. when we free the private struct we must  * unref the node so it gets freed too.  *  * If this were a device node than this work would be done in the attach()  * routine and the constructor would return EINVAL as you should not be able  * to creatednodes that depend on hardware (unless you can add the hardware :)  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|priv_p
name|privdata
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Initialize private descriptor */
name|MALLOC
argument_list|(
name|privdata
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|privdata
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|privdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the 'generic' (ie, superclass) node constructor */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Link structs together; this counts as our one reference to *nodep */
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|privdata
expr_stmt|;
name|privdata
operator|->
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our ok for a hook to be added...  * point the hook's private info to the hook structure.  *  * The following hook names are special:  *  Ethernet:  the hook that should be connected to a NIC.  *  debug:	copies of data sent out here  (when I write the code).  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_ETHERNET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
operator|&
name|privp
operator|->
name|ethernet_hook
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
operator|&
name|privp
operator|->
name|debug_hook
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Any other unique name is OK. 		 * The infrastructure has already checked that it's unique, 		 * so just allocate it and hook it in. 		 */
name|MALLOC
argument_list|(
name|sp
argument_list|,
name|sessp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|sp
expr_stmt|;
name|sp
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sp
operator|->
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a netgraph control message.  * Check it is one we understand. If needed, send a response.  * We sometimes save the address for an async action later.  * Always free the message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ngPPPoE_init_data
modifier|*
name|ourmsg
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
comment|/* Deal with message according to cookie and command */
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPPOE_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_CONNECT
case|:
case|case
name|NGM_PPPOE_LISTEN
case|:
case|case
name|NGM_PPPOE_OFFER
case|:
name|ourmsg
operator|=
operator|(
expr|struct
name|ngPPPoE_init_data
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|>
name|msg
operator|->
name|header
operator|.
name|arglen
operator|)
operator|||
operator|(
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|+
name|ourmsg
operator|->
name|data_len
operator|)
operator|>
name|msg
operator|->
name|header
operator|.
name|arglen
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"PPPoE_rcvmsg: bad arg size"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ourmsg
operator|->
name|data_len
operator|>
name|PPPOE_SERVICE_NAME_SIZE
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: init data too long (%d)\n"
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* make sure strcmp will terminate safely */
name|ourmsg
operator|->
name|hook
index|[
sizeof|sizeof
argument_list|(
name|ourmsg
operator|->
name|hook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* cycle through all known hooks */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
if|if
condition|(
name|hook
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|ourmsg
operator|->
name|hook
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator||=
name|PPPOE_SNONE
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session already active\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * set up prototype header 			 */
name|MALLOC
argument_list|(
name|neg
argument_list|,
name|negp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"pppoe: Session out of memory\n"
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|neg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|MCLGET
argument_list|(
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neg
operator|->
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|sp
operator|->
name|neg
operator|=
name|neg
expr_stmt|;
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pppoe_full_hdr
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|=
name|mtod
argument_list|(
name|neg
operator|->
name|m
argument_list|,
expr|union
name|packet
operator|*
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|=
name|eh_prototype
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|ver
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|type
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
literal|0x0000
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|sp
operator|->
name|creator
argument_list|,
name|retaddr
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|creator
index|[
name|NG_NODELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_GET_STATUS
case|:
block|{
name|struct
name|ngPPPoEstat
modifier|*
name|stats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|stats
operator|=
operator|(
expr|struct
name|ngPPPoEstat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|stats
operator|->
name|packets_in
operator|=
name|privp
operator|->
name|packets_in
expr_stmt|;
name|stats
operator|->
name|packets_out
operator|=
name|privp
operator|->
name|packets_out
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPPOE_CONNECT
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Send a PADI request, and start the timeout logic. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the session to SINIT 			 * Set up the session to the correct state and 			 * start it. 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADI_CODE
expr_stmt|;
name|pppoe_start
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_LISTEN
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Install the service matching string. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the hook to 'LISTENING' 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADT_CODE
expr_stmt|;
comment|/* 			 * wait for PADI packet coming from ethernet 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_LISTENING
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_OFFER
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Store the AC-Name given and go to PRIMED. 			 */
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_NAME
expr_stmt|;
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|ac_name
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|ac_name_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * Wait for PADI packet coming from hook 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_PRIMED
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of synchronous response, if any */
if|if
condition|(
name|rptr
condition|)
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
condition|)
name|FREE
argument_list|(
name|resp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
comment|/* Free the message and return */
name|quit
label|:
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|uniqtag
struct|;
comment|/*  	 * kick the state machine into starting up 	 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_SINIT
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_HOST_UNIQ
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|uniqtag
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive data, and do something with it.  * The caller will never free m or meta, so  * if we use up this data or abort we must free BOTH of these.  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
name|struct
name|pppoe_hdr
modifier|*
name|ph
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|session
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
name|u_int8_t
name|code
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|hook_p
name|sendhook
decl_stmt|;
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|uniqtag
struct|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
comment|/* 		 * Data from the debug hook gets sent without modification 		 * straight to the ethernet.  		 */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
comment|/* 		 * Incoming data.  		 * Dig out various fields from the packet. 		 * use them to decide where to send it. 		 */
name|privp
operator|->
name|packets_in
operator|++
expr_stmt|;
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checks length */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_type
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_PPPOE_DISC
case|:
comment|/* 			 * We need to try make sure that the tag area 			 * is contiguous, or we could wander of the end 			 * of a buffer and make a mess.  			 * (Linux wouldn't have this problem). 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
comment|/* 				 * It's not all in one piece. 				 * We need to do extra work. 				 */
name|printf
argument_list|(
literal|"packet fragmented\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PADI_CODE
case|:
comment|/* 				 * We are a server: 				 * Look for a hook with the required service 				 * and send the ENTIRE packet up there. 				 * It should come back to a new hook in  				 * PRIMED state. Look there for further 				 * processing. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_match_svc
argument_list|(
name|hook
operator|->
name|node
argument_list|,
name|tag
operator|->
name|tag_data
argument_list|,
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
condition|)
block|{
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PADO_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the  				 * hook this is in response to. 				 * 				 * For now simply accept the first we receive. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SINIT. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SINIT
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
comment|/* 				 * This is the first time we hear 				 * from the server, so note it's 				 * unicast address, replacing the 				 * broadcast address . 				 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADR_CODE
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* Service */
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* Host Unique */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned cookie */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SREQ
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADR_CODE
case|:
comment|/* 				 * We are a server: 				 * Use the ac_cookie tag to find the  				 * hook this is in response to. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SOFFER 				 * or PPPOE_NEWCONNECTED. If the latter, 				 * then this is a retry by the client. 				 * so be nice, and resend. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
comment|/* 					 * Whoa! drop back to resend that  					 * PADS packet. 					 * We should still have a copy of it. 					 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SOFFER
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADS_CODE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
literal|0
condition|)
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
name|sp
operator|->
name|Session_ID
operator|=
name|get_new_sid
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* 				 * start working out the tags to respond with. 				 */
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* ac_cookie */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned service */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned hostuniq */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_NEWCONNECTED
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 				 * Having sent the last Negotiation header, 				 * Set up the stored packet header to  				 * be correct for the actual session. 				 * But keep the negotialtion stuff 				 * around in case we need to resend this last  				 * packet. We'll discard it when we move 				 * from NEWCONNECTED to CONNECTED 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|PADS_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the  				 * hook this is in response to. 				 * take the session ID and store it away. 				 * Also make sure the pre-made header is 				 * correct and set us into Session mode. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SREQ. 				 */
name|sp
operator|=
name|sendhook
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SREQ
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|sendhook
argument_list|,
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|sp
operator|->
name|Session_ID
operator|=
name|wh
operator|->
name|ph
operator|.
name|sid
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 				 * Now we have gone to Connected mode,  				 * Free all resources needed for  				 * negotiation. 				 * Keep a copy of the header we will be using. 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PADT_CODE
case|:
comment|/* 				 * Send a 'close' message to the controlling 				 * process (the one that set us up); 				 * And then tear everything down. 				 * 				 * Find matching peer/session combination. 				 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|/* no longer needed */
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* send message to creator */
comment|/* close hook */
name|ng_destroy_hook
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETHERTYPE_PPPOE_SESS
case|:
comment|/* 			 * find matching peer/session combination. 			 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|length
condition|)
block|{
comment|/* Packet too short, dump it */
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* XXX also need to trim excess at end I should think */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_CONNECTED
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
comment|/* 					 * Now we have gone to Connected mode,  					 * Free all resources needed for  					 * negotiation. 					 */
name|m_freem
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * 	Not ethernet or debug hook.. 		 * 		 * The packet has come in on a normal hook. 		 * We need to find out what kind of hook, 		 * So we can decide how to handle it. 		 * Check the hook's state. 		 */
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_NEWCONNECTED
case|:
case|case
name|PPPOE_CONNECTED
case|:
block|{
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
comment|/* 			 * Bang in a pre-made header, and set the length up 			 * to be correct. Then send it to the ethernet driver. 			 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sp
operator|->
name|pkt_hdr
argument_list|,
name|wh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
call|(
name|short
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|PPPOE_PRIMED
case|:
comment|/* 			 * A PADI packet is being returned by the application 			 * that has set up this hook. This indicates that it  			 * wants us to offer service. 			 */
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checks length */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
comment|/* 			 * This is the first time we hear 			 * from the client, so note it's 			 * unicast address, replacing the 			 * broadcast address . 			 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * start working out the tags to respond with. 			 */
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_COOKIE
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned hostunique */
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC cookie */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned service */
comment|/* XXX maybe put the tag in the session store */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Packets coming from the hook make no sense 		 * to sessions in these states. Throw them away. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
case|case
name|PPPOE_SOFFER
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
default|default:
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
name|quit
label|:
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing..  * If we are a persistant device, we might refuse to go away, and  * we'd only remove our links and reset ourself.  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|privdata
init|=
name|node
operator|->
name|private
decl_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|privdata
operator|->
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called once we've already connected a new hook to the other node.  * It gives us a chance to balk at the last minute.  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
comment|/* be really amiable and just say "YUP that's OK by me! " */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * Clean up all dangling links and infirmation about the session/hook.  * For this type, removal of the last link destroys the node  */
end_comment

begin_function
specifier|static
name|int
name|ng_PPPoE_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
name|priv_p
name|privp
init|=
name|node
operator|->
name|private
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|->
name|private
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|hook
operator|->
name|private
expr_stmt|;
name|untimeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|sp
operator|->
name|neg
operator|->
name|timeout_handle
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * timeouts come here.  */
end_comment

begin_function
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|hook_p
name|hook
init|=
name|arg
decl_stmt|;
name|sessp
name|sp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|priv_p
name|privp
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|meta_p
name|dummy
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
comment|/* 		 * resend the last packet, using an exponential backoff. 		 * After a period of time, stop growing the backoff, 		 * and either leave it, or reverst to the start. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
comment|/* timeouts on these produce resends */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|neg
operator|->
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neg
operator|->
name|timeout
operator|<<=
literal|1
operator|)
operator|>
name|PPPOE_TIMEOUT_LIMIT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_SREQ
condition|)
block|{
comment|/* revert to SINIT mode */
block|}
else|else
block|{
name|neg
operator|->
name|timeout
operator|=
name|PPPOE_TIMEOUT_LIMIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PPPOE_PRIMED
case|:
case|case
name|PPPOE_SOFFER
case|:
comment|/* a timeout on these says "give up" */
comment|/* XXX should notify creator */
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* timeouts have no meaning in other states */
name|printf
argument_list|(
literal|"pppoe: unexpected timeout\n"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|sp
operator|->
name|hook
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|priv_p
name|privp
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|meta_p
name|dummy
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_NEWCONNECTED
case|:
case|case
name|PPPOE_CONNECTED
case|:
name|printf
argument_list|(
literal|"pppoe: timeout: unexpected state\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_PRIMED
case|:
comment|/* No packet to send, but set up the timeout */
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SOFFER
case|:
comment|/* 		 * send the offer but if they don't respond 		 * in PPPOE_OFFER_TIMEOUT seconds, forget about it. 		 */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sp
operator|->
name|hook
argument_list|,
name|m0
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout_handle
operator|=
name|timeout
argument_list|(
name|pppoe_ticker
argument_list|,
name|hook
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"pppoe: timeout: bad state\n"
argument_list|)
expr_stmt|;
block|}
comment|/* return (error); */
block|}
end_function

begin_comment
comment|/*  * Parse an incoming packet to see if any tags should be copied to the  * output packet. DOon't do any tags that are likely to have been  * handles a the main state machine.  */
end_comment

begin_function
specifier|static
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
operator|(
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptn
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
while|while
condition|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 		 * If the tag data would go past the end of the packet, abort. 		 */
name|ptn
operator|=
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|pt
operator|->
name|tag_type
condition|)
block|{
case|case
name|PTT_RELAY_SID
case|:
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|pt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTT_EOL
case|:
return|return
name|NULL
return|;
case|case
name|PTT_SRV_NAME
case|:
case|case
name|PTT_AC_NAME
case|:
case|case
name|PTT_HOST_UNIQ
case|:
case|case
name|PTT_AC_COOKIE
case|:
case|case
name|PTT_VENDOR
case|:
case|case
name|PTT_SRV_ERR
case|:
case|case
name|PTT_SYS_ERR
case|:
case|case
name|PTT_GEN_ERR
case|:
break|break;
block|}
name|pt
operator|=
operator|(
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

