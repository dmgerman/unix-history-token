begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_pppoe.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_pppoe.c,v 1.10 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pppoe.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PPPOE
argument_list|,
literal|"netgraph_pppoe"
argument_list|,
literal|"netgraph pppoe node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PPPOE
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SIGNOFF
value|"session closed"
end_define

begin_define
define|#
directive|define
name|OFFSETOF
parameter_list|(
name|s
parameter_list|,
name|e
parameter_list|)
value|((char *)&((s *)0)->e - (char *)((s *)0))
end_define

begin_comment
comment|/*  * This section contains the netgraph method declarations for the  * pppoe node. These methods define the netgraph pppoe 'type'.  */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_pppoe_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_pppoe_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_pppoe_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_pppoe_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_pppoe_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_pppoe_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ngpppoe_init_data */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ngpppoe_init_data_type_fields
index|[]
init|=
name|NG_PPPOE_INIT_DATA_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ngpppoe_init_data_state_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ngpppoe_init_data_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ngpppoe_sts */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_pppoe_sts_type_fields
index|[]
init|=
name|NG_PPPOE_STS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_pppoe_sts_state_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_pppoe_sts_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_pppoe_cmds
index|[]
init|=
block|{
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_CONNECT
block|,
literal|"pppoe_connect"
block|,
operator|&
name|ngpppoe_init_data_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_LISTEN
block|,
literal|"pppoe_listen"
block|,
operator|&
name|ngpppoe_init_data_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_OFFER
block|,
literal|"pppoe_offer"
block|,
operator|&
name|ngpppoe_init_data_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_SERVICE
block|,
literal|"pppoe_service"
block|,
operator|&
name|ngpppoe_init_data_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_SUCCESS
block|,
literal|"pppoe_success"
block|,
operator|&
name|ng_pppoe_sts_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_FAIL
block|,
literal|"pppoe_fail"
block|,
operator|&
name|ng_pppoe_sts_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_CLOSE
block|,
literal|"pppoe_close"
block|,
operator|&
name|ng_pppoe_sts_state_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_SETMODE
block|,
literal|"pppoe_setmode"
block|,
operator|&
name|ng_parse_string_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPPOE_COOKIE
block|,
name|NGM_PPPOE_GETMODE
block|,
literal|"pppoe_getmode"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_PPPOE_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_pppoe_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_pppoe_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_pppoe_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_pppoe_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_pppoe_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_pppoe_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_pppoe_cmds
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|pppoe
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * States for the session state machine.  * These have no meaning if there is no hook attached yet.  */
end_comment

begin_enum
enum|enum
name|state
block|{
name|PPPOE_SNONE
init|=
literal|0
block|,
comment|/* [both] Initial state */
name|PPPOE_LISTENING
block|,
comment|/* [Daemon] Listening for discover initiation pkt */
name|PPPOE_SINIT
block|,
comment|/* [Client] Sent discovery initiation */
name|PPPOE_PRIMED
block|,
comment|/* [Server] Awaiting PADI from daemon */
name|PPPOE_SOFFER
block|,
comment|/* [Server] Sent offer message  (got PADI)*/
name|PPPOE_SREQ
block|,
comment|/* [Client] Sent a Request */
name|PPPOE_NEWCONNECTED
block|,
comment|/* [Server] Connection established, No data received */
name|PPPOE_CONNECTED
block|,
comment|/* [Both] Connection established, Data received */
name|PPPOE_DEAD
comment|/* [Both] */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|NUMTAGS
value|20
end_define

begin_comment
comment|/* number of tags we are set up to work with */
end_comment

begin_comment
comment|/*  * Information we store for each hook on each node for negotiating the  * session. The mbuf and cluster are freed once negotiation has completed.  * The whole negotiation block is then discarded.  */
end_comment

begin_struct
struct|struct
name|sess_neg
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* holds cluster with last sent packet */
name|union
name|packet
modifier|*
name|pkt
decl_stmt|;
comment|/* points within the above cluster */
name|struct
name|callout
name|handle
decl_stmt|;
comment|/* see timeout(9) */
name|u_int
name|timeout
decl_stmt|;
comment|/* 0,1,2,4,8,16 etc. seconds */
name|u_int
name|numtags
decl_stmt|;
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|tags
index|[
name|NUMTAGS
index|]
decl_stmt|;
name|u_int
name|service_len
decl_stmt|;
name|u_int
name|ac_name_len
decl_stmt|;
name|struct
name|datatag
name|service
decl_stmt|;
name|struct
name|datatag
name|ac_name
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sess_neg
modifier|*
name|negp
typedef|;
end_typedef

begin_comment
comment|/*  * Session information that is needed after connection.  */
end_comment

begin_struct
struct|struct
name|sess_con
block|{
name|hook_p
name|hook
decl_stmt|;
name|uint16_t
name|Session_ID
decl_stmt|;
name|enum
name|state
name|state
decl_stmt|;
name|ng_ID_t
name|creator
decl_stmt|;
comment|/* who to notify */
name|struct
name|pppoe_full_hdr
name|pkt_hdr
decl_stmt|;
comment|/* used when connected */
name|negp
name|neg
decl_stmt|;
comment|/* used when negotiating */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|sess_con
modifier|*
name|sessp
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NG_PPPOE_SESSION_NODE
parameter_list|(
name|sp
parameter_list|)
value|NG_HOOK_NODE(sp->hook)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ether_header
name|eh_standard
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
name|ETHERTYPE_PPPOE_DISC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ether_header
name|eh_3Com
init|=
block|{
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
name|ETHERTYPE_PPPOE_3COM_DISC
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Information we store for each node  */
end_comment

begin_struct
struct|struct
name|PPPoE
block|{
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|hook_p
name|ethernet_hook
decl_stmt|;
name|hook_p
name|debug_hook
decl_stmt|;
name|u_int
name|packets_in
decl_stmt|;
comment|/* packets in from ethernet */
name|u_int
name|packets_out
decl_stmt|;
comment|/* packets out towards ethernet */
name|uint32_t
name|flags
decl_stmt|;
define|#
directive|define
name|COMPAT_3COM
value|0x00000001
define|#
directive|define
name|COMPAT_DLINK
value|0x00000002
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
comment|/* standard PPPoE or 3Com? */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|PPPoE
modifier|*
name|priv_p
typedef|;
end_typedef

begin_union
union|union
name|uniq
block|{
name|char
name|bytes
index|[
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
index|]
decl_stmt|;
name|void
modifier|*
name|pointer
decl_stmt|;
block|}
union|;
end_union

begin_define
define|#
directive|define
name|LEAVE
parameter_list|(
name|x
parameter_list|)
value|do { error = x; goto quit; } while(0)
end_define

begin_function_decl
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pppoe_sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
specifier|const
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppoe_send_event
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|enum
name|cmd
name|cmdid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*************************************************************************  * Some basic utilities  from the Linux version with author's permission.*  * Author:	Michal Ostrowski<mostrows@styx.uwaterloo.ca>		 *  ************************************************************************/
end_comment

begin_comment
comment|/*  * Generate a new session id  * XXX find out the FreeBSD locking scheme.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|get_new_sid
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|static
name|int
name|pppoe_sid
init|=
literal|10
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
name|restart
label|:
name|val
operator|=
name|pppoe_sid
operator|++
expr_stmt|;
comment|/* 	 * Spec says 0xFFFF is reserved. 	 * Also don't use 0x0000 	 */
if|if
condition|(
name|val
operator|==
literal|0xffff
condition|)
block|{
name|pppoe_sid
operator|=
literal|20
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Check it isn't already in use. */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
comment|/* Don't check special hooks. */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
name|val
condition|)
goto|goto
name|restart
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: new sid %d"
argument_list|,
name|__func__
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the location where the next tag can be put  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
specifier|const
expr|struct
name|pppoe_tag
operator|*
name|next_tag
argument_list|(
argument|const struct pppoe_hdr* ph
argument_list|)
block|{
return|return
operator|(
specifier|const
expr|struct
name|pppoe_tag
operator|*
operator|)
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
operator|)
operator|+
name|ntohs
argument_list|(
name|ph
operator|->
name|length
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/*  * Look for a tag of a specific type.  * Don't trust any length the other end says,  * but assume we already sanity checked ph->length.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|get_tag
parameter_list|(
specifier|const
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|,
name|uint16_t
name|idx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptn
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
while|while
condition|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 		 * If the tag data would go past the end of the packet, abort. 		 */
name|ptn
operator|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: invalid length for tag %d"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|pt
operator|->
name|tag_type
operator|==
name|idx
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: found tag %d"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|pt
operator|)
return|;
block|}
name|pt
operator|=
operator|(
specifier|const
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: not found tag %d"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Inlines to initialise or add tags to a session's tag list.  **************************************************************************/
end_comment

begin_comment
comment|/*  * Initialise the session's tag list.  */
end_comment

begin_function
specifier|static
name|void
name|init_tags
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sp
operator|->
name|neg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no neg"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insert_tag
parameter_list|(
name|sessp
name|sp
parameter_list|,
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|tp
parameter_list|)
block|{
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|neg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no neg"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|neg
operator|->
name|numtags
operator|++
operator|)
operator|<
name|NUMTAGS
condition|)
block|{
name|neg
operator|->
name|tags
index|[
name|i
index|]
operator|=
name|tp
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe: asked to add too many tags to "
literal|"packet\n"
argument_list|)
expr_stmt|;
name|neg
operator|->
name|numtags
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make up a packet, using the tags filled out for the session.  *  * Assume that the actual pppoe header and ethernet header  * are filled out externally to this routine.  * Also assume that neg->wh points to the correct  * location at the front of the buffer space.  */
end_comment

begin_function
specifier|static
name|void
name|make_packet
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
init|=
operator|&
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
decl_stmt|;
specifier|const
name|struct
name|pppoe_tag
modifier|*
modifier|*
name|tag
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|tlen
decl_stmt|;
name|uint16_t
name|length
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sp
operator|->
name|neg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|sp
operator|->
name|neg
operator|->
name|m
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"%s: called from wrong state"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
name|dp
operator|=
operator|(
name|char
operator|*
operator|)
name|wh
operator|->
name|ph
operator|.
name|tag
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|tag
operator|=
name|sp
operator|->
name|neg
operator|->
name|tags
init|;
operator|(
operator|(
name|count
operator|<
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|)
operator|&&
operator|(
name|count
operator|<
name|NUMTAGS
operator|)
operator|)
condition|;
name|tag
operator|++
operator|,
name|count
operator|++
control|)
block|{
name|tlen
operator|=
name|ntohs
argument_list|(
operator|(
operator|*
name|tag
operator|)
operator|->
name|tag_len
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|length
operator|+
name|tlen
operator|)
operator|>
operator|(
name|ETHER_MAX_LEN
operator|-
literal|4
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe: tags too long\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|numtags
operator|=
name|count
expr_stmt|;
break|break;
comment|/* XXX chop off what's too long */
block|}
name|bcopy
argument_list|(
operator|*
name|tag
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|length
operator|+=
name|tlen
expr_stmt|;
name|dp
operator|+=
name|tlen
expr_stmt|;
block|}
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
name|length
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routines to match a service.						  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Find a hook that has a service string that matches that  * we are seeking. For now use a simple string.  * In the future we may need something like regexp().  *  * Null string is a wildcard (ANY service), according to RFC2516.  * And historical FreeBSD wildcard is also "*".  */
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_match_svc
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|sessp
name|sp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|negp
name|neg
decl_stmt|;
comment|/* Skip any hook that is debug or ethernet. */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
comment|/* Skip any sessions which are not in LISTEN mode. */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_LISTENING
condition|)
continue|continue;
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
comment|/* Empty Service-Name matches any service. */
if|if
condition|(
name|neg
operator|->
name|service_len
operator|==
literal|0
condition|)
break|break;
comment|/* Special case for a blank or "*" service name (wildcard). */
if|if
condition|(
name|neg
operator|->
name|service_len
operator|==
literal|1
operator|&&
name|neg
operator|->
name|service
operator|.
name|data
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
break|break;
comment|/* If the lengths don't match, that aint it. */
if|if
condition|(
name|neg
operator|->
name|service_len
operator|!=
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: matched %p for %s"
argument_list|,
name|__func__
argument_list|,
name|hook
argument_list|,
name|tag
operator|->
name|tag_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Broadcast the PADI packet in m0 to all listening hooks.  * This routine is called when a PADI with empty Service-Name  * tag is received. Client should receive PADOs with all  * available services.  */
end_comment

begin_function
specifier|static
name|int
name|pppoe_broadcast_padi
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|sessp
name|sp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 		 * Go through all listening hooks and 		 * broadcast the PADI packet up there 		 */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_LISTENING
condition|)
continue|continue;
name|m
operator|=
name|m_dup
argument_list|(
name|m0
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a hook, which name equals to given service.  */
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_find_svc
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|svc_name
parameter_list|,
name|int
name|svc_len
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|sessp
name|sp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|negp
name|neg
decl_stmt|;
comment|/* Skip any hook that is debug or ethernet. */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
comment|/* Skip any sessions which are not in LISTEN mode. */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_LISTENING
condition|)
continue|continue;
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
if|if
condition|(
name|neg
operator|->
name|service_len
operator|==
name|svc_len
operator|&&
name|strncmp
argument_list|(
name|svc_name
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|svc_len
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|hook
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Routine to find a particular session that matches an incoming packet.  *  **************************************************************************/
end_comment

begin_function
specifier|static
name|hook_p
name|pppoe_findsession
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|session
init|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
decl_stmt|;
comment|/* 	 * Find matching peer/session combination. 	 */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
comment|/* don't check special hooks */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
block|{
continue|continue;
block|}
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_CONNECTED
operator|)
operator|||
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
operator|)
operator|)
operator|&&
operator|(
name|sp
operator|->
name|Session_ID
operator|==
name|session
operator|)
operator|&&
operator|(
name|bcmp
argument_list|(
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: matched %p for %d"
argument_list|,
name|__func__
argument_list|,
name|hook
argument_list|,
name|session
argument_list|)
expr_stmt|;
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|hook_p
name|pppoe_finduniq
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|union
name|uniq
name|uniq
decl_stmt|;
name|bcopy
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|uniq
operator|.
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cycle through all known hooks. */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
comment|/* Don't check special hooks. */
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
continue|continue;
if|if
condition|(
name|uniq
operator|.
name|pointer
operator|==
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
condition|)
break|break;
block|}
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: matched %p for %p"
argument_list|,
name|__func__
argument_list|,
name|hook
argument_list|,
name|uniq
operator|.
name|pointer
argument_list|)
expr_stmt|;
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************  * Start of Netgraph entrypoints.					  *  **************************************************************************/
end_comment

begin_comment
comment|/*  * Allocate the private data structure and link it with node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|privp
decl_stmt|;
comment|/* Initialize private descriptor. */
name|privp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|privp
argument_list|)
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|privp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Link structs together; this counts as our one reference to *node. */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|privp
argument_list|)
expr_stmt|;
name|privp
operator|->
name|node
operator|=
name|node
expr_stmt|;
comment|/* Initialize to standard mode. */
name|privp
operator|->
name|eh
operator|=
operator|&
name|eh_standard
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: created node [%x] (%p)"
argument_list|,
name|__func__
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our ok for a hook to be added...  * point the hook's private info to the hook structure.  *  * The following hook names are special:  *  "ethernet":  the hook that should be connected to a NIC.  *  "debug":	copies of data sent out here  (when I write the code).  * All other hook names need only be unique. (the framework checks this).  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_ETHERNET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|&
name|privp
operator|->
name|ethernet_hook
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPPOE_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|&
name|privp
operator|->
name|debug_hook
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Any other unique name is OK. 		 * The infrastructure has already checked that it's unique, 		 * so just allocate it and hook it in. 		 */
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
block|}
name|CTR5
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: node [%x] (%p) connected hook %s (%p)"
argument_list|,
name|__func__
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|node
argument_list|,
name|name
argument_list|,
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a netgraph control message.  * Check it is one we understand. If needed, send a response.  * We sometimes save the address for an async action later.  * Always free the message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngpppoe_init_data
modifier|*
name|ourmsg
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|sessp
name|sp
init|=
name|NULL
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: node [%x] (%p) got message %d with cookie %d"
argument_list|,
name|__func__
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|node
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|header
operator|.
name|typecookie
argument_list|)
expr_stmt|;
comment|/* Deal with message according to cookie and command. */
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPPOE_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_CONNECT
case|:
case|case
name|NGM_PPPOE_LISTEN
case|:
case|case
name|NGM_PPPOE_OFFER
case|:
case|case
name|NGM_PPPOE_SERVICE
case|:
name|ourmsg
operator|=
operator|(
expr|struct
name|ngpppoe_init_data
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ng_pppoe[%x]: init data too "
literal|"small\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|>
name|PPPOE_SERVICE_NAME_SIZE
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ng_pppoe[%x]: service name "
literal|"too big\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
operator|<
name|ourmsg
operator|->
name|data_len
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ng_pppoe[%x]: init data has bad "
literal|"length, %d should be %zd\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|,
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ourmsg
argument_list|)
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure strcmp will terminate safely. */
name|ourmsg
operator|->
name|hook
index|[
sizeof|sizeof
argument_list|(
name|ourmsg
operator|->
name|hook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Cycle through all known hooks. */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
if|if
condition|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|ourmsg
operator|->
name|hook
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
name|LEAVE
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
operator|)
operator|||
operator|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
operator|)
condition|)
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPPOE_LISTEN
condition|)
block|{
comment|/* 				 * Ensure we aren't already listening for this 				 * service. 				 */
if|if
condition|(
name|pppoe_find_svc
argument_list|(
name|node
argument_list|,
name|ourmsg
operator|->
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
operator|!=
name|NULL
condition|)
name|LEAVE
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * PPPOE_SERVICE advertisments are set up 			 * on sessions that are in PRIMED state. 			 */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPPOE_SERVICE
condition|)
break|break;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SNONE
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: Session already "
literal|"active\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Set up prototype header. 			 */
name|neg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|neg
argument_list|)
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|==
name|NULL
condition|)
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|neg
operator|->
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|neg
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|neg
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|neg
operator|->
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|neg
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|)
expr_stmt|;
name|neg
operator|->
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pppoe_full_hdr
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|=
name|mtod
argument_list|(
name|neg
operator|->
name|m
argument_list|,
expr|union
name|packet
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|privp
operator|->
name|eh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|ver
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|type
operator|=
literal|0x1
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
literal|0x0000
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|creator
operator|=
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPPOE_GET_STATUS
case|:
block|{
name|struct
name|ngpppoestat
modifier|*
name|stats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
expr|struct
name|ngpppoestat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|stats
operator|->
name|packets_in
operator|=
name|privp
operator|->
name|packets_in
expr_stmt|;
name|stats
operator|->
name|packets_out
operator|=
name|privp
operator|->
name|packets_out
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPPOE_CONNECT
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Send a PADI request, and start the timeout logic. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the session to SINIT. 			 * Set up the session to the correct state and 			 * start it. 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|pppoe_start
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_LISTEN
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Install the service matching string. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Move the hook to 'LISTENING' 			 */
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADT_CODE
expr_stmt|;
comment|/* 			 * Wait for PADI packet coming from Ethernet. 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_LISTENING
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_OFFER
case|:
comment|/* 			 * Check the hook exists and is Uninitialised. 			 * Store the originator of this message so we can send 			 * a success of fail message to them later. 			 * Store the AC-Name given and go to PRIMED. 			 */
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_NAME
expr_stmt|;
name|neg
operator|->
name|ac_name
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|ac_name
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|ac_name_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * Wait for PADI packet coming from hook. 			 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_PRIMED
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SERVICE
case|:
comment|/* 			 * Check the session is primed. 			 * for now just allow ONE service to be advertised. 			 * If you do it twice you just overwrite. 			 */
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_PRIMED
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: session not "
literal|"primed\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EISCONN
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_SRV_NAME
expr_stmt|;
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ourmsg
operator|->
name|data_len
condition|)
name|bcopy
argument_list|(
name|ourmsg
operator|->
name|data
argument_list|,
name|neg
operator|->
name|service
operator|.
name|data
argument_list|,
name|ourmsg
operator|->
name|data_len
argument_list|)
expr_stmt|;
name|neg
operator|->
name|service_len
operator|=
name|ourmsg
operator|->
name|data_len
expr_stmt|;
break|break;
case|case
name|NGM_PPPOE_SETMODE
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|==
literal|0
condition|)
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
expr_stmt|;
comment|/* Search for matching mode string. */
if|if
condition|(
name|len
operator|==
name|strlen
argument_list|(
name|NG_PPPOE_STANDARD
argument_list|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|NG_PPPOE_STANDARD
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|privp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|privp
operator|->
name|eh
operator|=
operator|&
name|eh_standard
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
name|strlen
argument_list|(
name|NG_PPPOE_3COM
argument_list|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|NG_PPPOE_3COM
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|privp
operator|->
name|flags
operator||=
name|COMPAT_3COM
expr_stmt|;
name|privp
operator|->
name|eh
operator|=
operator|&
name|eh_3Com
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|len
operator|==
name|strlen
argument_list|(
name|NG_PPPOE_DLINK
argument_list|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|NG_PPPOE_DLINK
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|privp
operator|->
name|flags
operator||=
name|COMPAT_DLINK
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPPOE_GETMODE
case|:
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|privp
operator|->
name|flags
operator|==
literal|0
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|NG_PPPOE_STANDARD
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_3COM
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|NG_PPPOE_3COM
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_DLINK
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|NG_PPPOE_DLINK
argument_list|)
operator|+
literal|1
expr_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|LEAVE
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|flags
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|NG_PPPOE_STANDARD
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|s
argument_list|,
name|NG_PPPOE_STANDARD
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_3COM
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|NG_PPPOE_3COM
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|s
argument_list|,
name|NG_PPPOE_3COM
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_DLINK
condition|)
block|{
if|if
condition|(
name|s
operator|!=
name|resp
operator|->
name|data
condition|)
operator|*
name|s
operator|++
operator|=
literal|'|'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|NG_PPPOE_DLINK
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|s
argument_list|,
name|NG_PPPOE_DLINK
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
comment|/* Take care of synchronous response, if any. */
name|quit
label|:
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: returning %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
comment|/* Free the message and return. */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a client into the first state. A separate function because  * it can be needed if the negotiation times out.  */
end_comment

begin_function
specifier|static
name|void
name|pppoe_start
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_PPPOE_SESSION_NODE
argument_list|(
name|sp
argument_list|)
argument_list|)
decl_stmt|;
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|__packed
name|uniqtag
struct|;
comment|/* 	 * Kick the state machine into starting up. 	 */
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SINIT
expr_stmt|;
comment|/* 	 * Reset the packet header to broadcast. Since we are 	 * in a client 	 * mode use configured ethertype. 	 */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|privp
operator|->
name|eh
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADI_CODE
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_HOST_UNIQ
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|uniqtag
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|sp
operator|->
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ng_pppoe_sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_acname
parameter_list|(
name|sessp
name|sp
parameter_list|,
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|tlen
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_ACNAME
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sts
operator|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|tlen
operator|=
name|min
argument_list|(
name|NG_HOOKSIZ
operator|-
literal|1
argument_list|,
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|sts
operator|->
name|hook
argument_list|,
name|tag
operator|->
name|tag_data
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|sts
operator|->
name|hook
index|[
name|tlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|NG_SEND_MSG_ID
argument_list|(
name|error
argument_list|,
name|NG_HOOK_NODE
argument_list|(
name|sp
operator|->
name|hook
argument_list|)
argument_list|,
name|msg
argument_list|,
name|sp
operator|->
name|creator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|send_sessionid
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|NGM_PPPOE_SESSIONID
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|=
name|sp
operator|->
name|Session_ID
expr_stmt|;
name|NG_SEND_MSG_ID
argument_list|(
name|error
argument_list|,
name|NG_HOOK_NODE
argument_list|(
name|sp
operator|->
name|hook
argument_list|)
argument_list|,
name|msg
argument_list|,
name|sp
operator|->
name|creator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data, and do something with it.  * The caller will never free m, so if we use up this data  * or abort we must free it.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|sessp
name|sp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|utag
init|=
name|NULL
decl_stmt|,
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|pppoe_hdr
modifier|*
name|ph
decl_stmt|;
name|negp
name|neg
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|hook_p
name|sendhook
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint16_t
name|session
decl_stmt|;
name|uint16_t
name|length
decl_stmt|;
name|uint8_t
name|code
decl_stmt|;
struct|struct
block|{
name|struct
name|pppoe_tag
name|hdr
decl_stmt|;
name|union
name|uniq
name|data
decl_stmt|;
block|}
name|__packed
name|uniqtag
struct|;
name|CTR6
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: node [%x] (%p) received %p on \"%s\" (%p)"
argument_list|,
name|__func__
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|hook
operator|->
name|hk_name
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
comment|/* 		 * Data from the debug hook gets sent without modification 		 * straight to the ethernet. 		 */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
comment|/* 		 * Incoming data. 		 * Dig out various fields from the packet. 		 * Use them to decide where to send it. 		 */
name|privp
operator|->
name|packets_in
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Checks length */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: couldn't "
literal|"m_pullup(wh)\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|eh
operator|.
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_PPPOE_3COM_DISC
case|:
comment|/* fall through */
case|case
name|ETHERTYPE_PPPOE_DISC
case|:
comment|/* 			 * We need to try to make sure that the tag area 			 * is contiguous, or we could wander off the end 			 * of a buffer and make a mess. 			 * (Linux wouldn't have this problem). 			 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|MHLEN
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: "
literal|"couldn't "
literal|"m_pullup(pkthdr)\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
comment|/* 				 * It's not all in one piece. 				 * We need to do extra work. 				 * Put it into a cluster. 				 */
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* just check we got a cluster */
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: packet "
literal|"fragmented\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|PADI_CODE
case|:
comment|/* 				 * We are a server: 				 * Look for a hook with the required service 				 * and send the ENTIRE packet up there. 				 * It should come back to a new hook in 				 * PRIMED state. Look there for further 				 * processing. 				 */
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: PADI w/o Service-Name"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * First, try to match Service-Name 				 * against our listening hooks. If 				 * no success and we are in D-Link 				 * compat mode and Service-Name is 				 * empty, then we broadcast the PADI 				 * to all listening hooks. 				 */
name|sendhook
operator|=
name|pppoe_match_svc
argument_list|(
name|node
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|!=
name|NULL
condition|)
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_DLINK
operator|&&
name|ntohs
argument_list|(
name|tag
operator|->
name|tag_len
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|pppoe_broadcast_padi
argument_list|(
name|node
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
break|break;
case|case
name|PADO_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the 				 * hook this is in response to. 				 * Received #2, now send #3 				 * For now simply accept the first we receive. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: no host "
literal|"unique field\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: no "
literal|"matching session\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SINIT. 				 */
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SINIT
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: session "
literal|"in wrong state\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* 				 * This is the first time we hear 				 * from the server, so note it's 				 * unicast address, replacing the 				 * broadcast address . 				 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADR_CODE
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|utag
argument_list|)
expr_stmt|;
comment|/* Host Unique */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return cookie */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_NAME
argument_list|)
operator|)
condition|)
block|{
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return it */
name|send_acname
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* Service */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SREQ
expr_stmt|;
name|ng_pppoe_sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADR_CODE
case|:
comment|/* 				 * We are a server: 				 * Use the ac_cookie tag to find the 				 * hook this is in response to. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_AC_COOKIE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SOFFER 				 * or PPPOE_NEWCONNECTED. If the latter, 				 * then this is a retry by the client. 				 * so be nice, and resend. 				 */
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
comment|/* 					 * Whoa! drop back to resend that 					 * PADS packet. 					 * We should still have a copy of it. 					 */
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SOFFER
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADS_CODE
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|Session_ID
operator|==
literal|0
condition|)
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
name|htons
argument_list|(
name|sp
operator|->
name|Session_ID
operator|=
name|get_new_sid
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|send_sessionid
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* 				 * start working out the tags to respond with. 				 */
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return service */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return it */
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|utag
argument_list|)
expr_stmt|;
comment|/* ac_cookie */
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_NEWCONNECTED
expr_stmt|;
name|ng_pppoe_sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 				 * Having sent the last Negotiation header, 				 * Set up the stored packet header to 				 * be correct for the actual session. 				 * But keep the negotialtion stuff 				 * around in case we need to resend this last 				 * packet. We'll discard it when we move 				 * from NEWCONNECTED to CONNECTED 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
comment|/* Configure ethertype depending on what 				 * ethertype was used at discovery phase */
if|if
condition|(
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|==
name|ETHERTYPE_PPPOE_3COM_DISC
condition|)
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_3COM_SESS
expr_stmt|;
else|else
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADS_CODE
case|:
comment|/* 				 * We are a client: 				 * Use the host_uniq tag to find the 				 * hook this is in response to. 				 * take the session ID and store it away. 				 * Also make sure the pre-made header is 				 * correct and set us into Session mode. 				 */
name|utag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ntohs
argument_list|(
name|utag
operator|->
name|tag_len
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
operator|)
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|sendhook
operator|=
name|pppoe_finduniq
argument_list|(
name|node
argument_list|,
name|utag
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Check the session is in the right state. 				 * It needs to be in PPPOE_SREQ. 				 */
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SREQ
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|sid
operator|=
name|wh
operator|->
name|ph
operator|.
name|sid
expr_stmt|;
name|sp
operator|->
name|Session_ID
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|send_sessionid
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
comment|/* 				 * Now we have gone to Connected mode, 				 * Free all resources needed for 				 * negotiation. 				 * Keep a copy of the header we will be using. 				 */
name|sp
operator|->
name|pkt_hdr
operator|=
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|flags
operator|&
name|COMPAT_3COM
condition|)
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_3COM_SESS
expr_stmt|;
else|else
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_SESS
expr_stmt|;
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|code
operator|=
literal|0
expr_stmt|;
name|m_freem
argument_list|(
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
name|PADT_CODE
case|:
comment|/* 				 * Send a 'close' message to the controlling 				 * process (the one that set us up); 				 * And then tear everything down. 				 * 				 * Find matching peer/session combination. 				 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* send message to creator */
comment|/* close hook */
if|if
condition|(
name|sendhook
condition|)
block|{
name|ng_rmhook_self
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ETHERTYPE_PPPOE_3COM_SESS
case|:
case|case
name|ETHERTYPE_PPPOE_SESS
case|:
comment|/* 			 * Find matching peer/session combination. 			 */
name|sendhook
operator|=
name|pppoe_findsession
argument_list|(
name|node
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendhook
operator|==
name|NULL
condition|)
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|sendhook
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|length
condition|)
block|{
comment|/* Packet too short, dump it */
name|LEAVE
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Also need to trim excess at the end */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|length
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
call|(
name|int
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|length
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_CONNECTED
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
condition|)
block|{
name|sp
operator|->
name|state
operator|=
name|PPPOE_CONNECTED
expr_stmt|;
comment|/* 					 * Now we have gone to Connected mode, 					 * Free all resources needed for 					 * negotiation. Be paranoid about 					 * whether there may be a timeout. 					 */
name|m_freem
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|sp
operator|->
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
name|sp
operator|->
name|neg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|sendhook
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LEAVE
argument_list|(
name|EPFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Not ethernet or debug hook.. 		 * 		 * The packet has come in on a normal hook. 		 * We need to find out what kind of hook, 		 * So we can decide how to handle it. 		 * Check the hook's state. 		 */
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_NEWCONNECTED
case|:
case|case
name|PPPOE_CONNECTED
case|:
block|{
specifier|static
specifier|const
name|u_char
name|addrctrl
index|[]
init|=
block|{
literal|0xff
block|,
literal|0x03
block|}
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
comment|/* 			 * Remove PPP address and control fields, if any. 			 * For example, ng_ppp(4) always sends LCP packets 			 * with address and control fields as required by 			 * generic PPP. PPPoE is an exception to the rule. 			 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|!
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|addrctrl
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Bang in a pre-made header, and set the length up 			 * to be correct. Then send it to the ethernet driver. 			 * But first correct the length. 			 */
name|sp
operator|->
name|pkt_hdr
operator|.
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
call|(
name|short
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sp
operator|->
name|pkt_hdr
argument_list|,
name|wh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|privp
operator|->
name|packets_out
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|PPPOE_PRIMED
case|:
comment|/* 			 * A PADI packet is being returned by the application 			 * that has set up this hook. This indicates that it 			 * wants us to offer service. 			 */
name|neg
operator|=
name|sp
operator|->
name|neg
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|LEAVE
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|&
name|wh
operator|->
name|ph
expr_stmt|;
name|session
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|sid
argument_list|)
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|wh
operator|->
name|ph
operator|.
name|length
argument_list|)
expr_stmt|;
name|code
operator|=
name|wh
operator|->
name|ph
operator|.
name|code
expr_stmt|;
comment|/* Use peers mode in session. */
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_type
operator|=
name|wh
operator|->
name|eh
operator|.
name|ether_type
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|PADI_CODE
condition|)
name|LEAVE
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* 			 * This is the first time we hear 			 * from the client, so note it's 			 * unicast address, replacing the 			 * broadcast address. 			 */
name|bcopy
argument_list|(
name|wh
operator|->
name|eh
operator|.
name|ether_shost
argument_list|,
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|eh
operator|.
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|PPPOE_SOFFER
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
name|neg
operator|->
name|pkt
operator|->
name|pkt_header
operator|.
name|ph
operator|.
name|code
operator|=
name|PADO_CODE
expr_stmt|;
comment|/* 			 * Start working out the tags to respond with. 			 */
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_type
operator|=
name|PTT_AC_COOKIE
expr_stmt|;
name|uniqtag
operator|.
name|hdr
operator|.
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|uniqtag
operator|.
name|data
operator|.
name|pointer
operator|=
name|sp
expr_stmt|;
name|init_tags
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|ac_name
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* AC_NAME */
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_SRV_NAME
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* return service */
comment|/* 			 * If we have a NULL service request 			 * and have an extra service defined in this hook, 			 * then also add a tag for the extra service. 			 * XXX this is a hack. eventually we should be able 			 * to support advertising many services, not just one 			 */
if|if
condition|(
operator|(
operator|(
name|tag
operator|==
name|NULL
operator|)
operator|||
operator|(
name|tag
operator|->
name|tag_len
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|neg
operator|->
name|service
operator|.
name|hdr
operator|.
name|tag_len
operator|!=
literal|0
operator|)
condition|)
block|{
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|neg
operator|->
name|service
operator|.
name|hdr
argument_list|)
expr_stmt|;
comment|/* SERVICE */
block|}
if|if
condition|(
operator|(
name|tag
operator|=
name|get_tag
argument_list|(
name|ph
argument_list|,
name|PTT_HOST_UNIQ
argument_list|)
operator|)
condition|)
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* returned hostunique */
name|insert_tag
argument_list|(
name|sp
argument_list|,
operator|&
name|uniqtag
operator|.
name|hdr
argument_list|)
expr_stmt|;
name|scan_tags
argument_list|(
name|sp
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|make_packet
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ng_pppoe_sendpacket
argument_list|(
name|sp
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Packets coming from the hook make no sense 		 * to sessions in these states. Throw them away. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
case|case
name|PPPOE_SOFFER
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
default|default:
name|LEAVE
argument_list|(
name|ENETUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
name|quit
label|:
if|if
condition|(
name|item
condition|)
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing..  * If we are a persistant device, we might refuse to go away, and  * we'd only remove our links and reset ourself.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|privdata
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|privdata
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * Clean up all dangling links and information about the session/hook.  * For this type, removal of the last link destroys the node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pppoe_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|sessp
name|sp
decl_stmt|;
name|int
name|hooks
decl_stmt|;
name|hooks
operator|=
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* This one already not counted. */
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|debug_hook
condition|)
block|{
name|privp
operator|->
name|debug_hook
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|privp
operator|->
name|ethernet_hook
condition|)
block|{
name|privp
operator|->
name|ethernet_hook
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|state
operator|!=
name|PPPOE_SNONE
condition|)
block|{
name|pppoe_send_event
argument_list|(
name|sp
argument_list|,
name|NGM_PPPOE_CLOSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * According to the spec, if we are connected, 		 * we should send a DISC packet if we are shutting down 		 * a session. 		 */
if|if
condition|(
operator|(
name|privp
operator|->
name|ethernet_hook
operator|)
operator|&&
operator|(
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_CONNECTED
operator|)
operator|||
operator|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_NEWCONNECTED
operator|)
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|pppoe_full_hdr
modifier|*
name|wh
decl_stmt|;
name|struct
name|pppoe_tag
modifier|*
name|tag
decl_stmt|;
name|int
name|msglen
init|=
name|strlen
argument_list|(
name|SIGNOFF
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Revert the stored header to DISC/PADT mode. */
name|wh
operator|=
operator|&
name|sp
operator|->
name|pkt_hdr
expr_stmt|;
name|wh
operator|->
name|ph
operator|.
name|code
operator|=
name|PADT_CODE
expr_stmt|;
comment|/* 			 * Configure ethertype depending on what was used 			 * during sessions stage. 			 */
if|if
condition|(
name|sp
operator|->
name|pkt_hdr
operator|.
name|eh
operator|.
name|ether_type
operator|==
name|ETHERTYPE_PPPOE_3COM_SESS
condition|)
name|wh
operator|->
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_3COM_DISC
expr_stmt|;
else|else
name|wh
operator|->
name|eh
operator|.
name|ether_type
operator|=
name|ETHERTYPE_PPPOE_DISC
expr_stmt|;
comment|/* Generate a packet of that type. */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: session out of "
literal|"mbufs\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|wh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * Add a General error message and adjust 				 * sizes. 				 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pppoe_full_hdr
operator|*
argument_list|)
expr_stmt|;
name|tag
operator|=
name|wh
operator|->
name|ph
operator|.
name|tag
expr_stmt|;
name|tag
operator|->
name|tag_type
operator|=
name|PTT_GEN_ERR
expr_stmt|;
name|tag
operator|->
name|tag_len
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|msglen
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tag
operator|->
name|tag_data
argument_list|,
name|SIGNOFF
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
operator|+
name|msglen
operator|)
expr_stmt|;
name|wh
operator|->
name|ph
operator|.
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tag
argument_list|)
operator|+
name|msglen
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * As long as we have somewhere to store the timeout handle, 		 * we may have a timeout pending.. get rid of it. 		 */
if|if
condition|(
name|sp
operator|->
name|neg
condition|)
block|{
name|ng_uncallout
argument_list|(
operator|&
name|sp
operator|->
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|neg
operator|->
name|m
condition|)
name|m_freem
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|neg
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sp
argument_list|,
name|M_NETGRAPH_PPPOE
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Work out how many session hooks there are. 		 * Node goes away on last session hook removal. 		 */
if|if
condition|(
name|privp
operator|->
name|ethernet_hook
condition|)
name|hooks
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|privp
operator|->
name|debug_hook
condition|)
name|hooks
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Timeouts come here.  */
end_comment

begin_function
specifier|static
name|void
name|pppoe_ticker
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|sessp
name|sp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CTR6
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: node [%x] (%p) hook \"%s\" (%p) session %d"
argument_list|,
name|__func__
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|,
name|node
argument_list|,
name|hook
operator|->
name|hk_name
argument_list|,
name|hook
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
comment|/* 		 * Resend the last packet, using an exponential backoff. 		 * After a period of time, stop growing the backoff, 		 * And either leave it, or revert to the start. 		 */
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
comment|/* Timeouts on these produce resends. */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|,
name|hook
argument_list|,
name|neg
operator|->
name|timeout
operator|*
name|hz
argument_list|,
name|pppoe_ticker
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neg
operator|->
name|timeout
operator|<<=
literal|1
operator|)
operator|>
name|PPPOE_TIMEOUT_LIMIT
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|PPPOE_SREQ
condition|)
block|{
comment|/* Revert to SINIT mode. */
name|pppoe_start
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|neg
operator|->
name|timeout
operator|=
name|PPPOE_TIMEOUT_LIMIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PPPOE_PRIMED
case|:
case|case
name|PPPOE_SOFFER
case|:
comment|/* A timeout on these says "give up" */
name|ng_rmhook_self
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Timeouts have no meaning in other states. */
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"ng_pppoe[%x]: unexpected timeout\n"
argument_list|,
name|node
operator|->
name|nd_ID
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ng_pppoe_sendpacket
parameter_list|(
name|sessp
name|sp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|sp
operator|->
name|hook
decl_stmt|;
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|priv_p
name|privp
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|negp
name|neg
init|=
name|sp
operator|->
name|neg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|state
condition|)
block|{
case|case
name|PPPOE_LISTENING
case|:
case|case
name|PPPOE_DEAD
case|:
case|case
name|PPPOE_SNONE
case|:
case|case
name|PPPOE_CONNECTED
case|:
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: unexpected state %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_NEWCONNECTED
case|:
comment|/* Send the PADS without a timeout - we're now connected. */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_PRIMED
case|:
comment|/* No packet to send, but set up the timeout. */
name|ng_callout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|,
name|pppoe_ticker
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SOFFER
case|:
comment|/* 		 * Send the offer but if they don't respond 		 * in PPPOE_OFFER_TIMEOUT seconds, forget about it. 		 */
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|,
name|hook
argument_list|,
name|PPPOE_OFFER_TIMEOUT
operator|*
name|hz
argument_list|,
name|pppoe_ticker
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPOE_SINIT
case|:
case|case
name|PPPOE_SREQ
case|:
name|m0
operator|=
name|m_copypacket
argument_list|(
name|sp
operator|->
name|neg
operator|->
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|privp
operator|->
name|ethernet_hook
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|neg
operator|->
name|handle
argument_list|,
name|node
argument_list|,
name|hook
argument_list|,
name|PPPOE_INITIAL_TIMEOUT
operator|*
name|hz
argument_list|,
name|pppoe_ticker
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|neg
operator|->
name|timeout
operator|=
name|PPPOE_INITIAL_TIMEOUT
operator|*
literal|2
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: bad state %d\n"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse an incoming packet to see if any tags should be copied to the  * output packet. Don't do any tags that have been handled in the main  * state machine.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|scan_tags
parameter_list|(
name|sessp
name|sp
parameter_list|,
specifier|const
name|struct
name|pppoe_hdr
modifier|*
name|ph
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|end
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|next_tag
argument_list|(
name|ph
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptn
decl_stmt|;
specifier|const
name|struct
name|pppoe_tag
modifier|*
name|pt
init|=
operator|&
name|ph
operator|->
name|tag
index|[
literal|0
index|]
decl_stmt|;
comment|/* 	 * Keep processing tags while a tag header will still fit. 	 */
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|<=
name|end
condition|)
block|{
comment|/* 		 * If the tag data would go past the end of the packet, abort. 		 */
name|ptn
operator|=
operator|(
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|pt
operator|+
literal|1
operator|)
operator|)
operator|+
name|ntohs
argument_list|(
name|pt
operator|->
name|tag_len
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ptn
operator|>
name|end
condition|)
return|return
name|NULL
return|;
switch|switch
condition|(
name|pt
operator|->
name|tag_type
condition|)
block|{
case|case
name|PTT_RELAY_SID
case|:
name|insert_tag
argument_list|(
name|sp
argument_list|,
name|pt
argument_list|)
expr_stmt|;
break|break;
case|case
name|PTT_EOL
case|:
return|return
name|NULL
return|;
case|case
name|PTT_SRV_NAME
case|:
case|case
name|PTT_AC_NAME
case|:
case|case
name|PTT_HOST_UNIQ
case|:
case|case
name|PTT_AC_COOKIE
case|:
case|case
name|PTT_VENDOR
case|:
case|case
name|PTT_SRV_ERR
case|:
case|case
name|PTT_SYS_ERR
case|:
case|case
name|PTT_GEN_ERR
case|:
break|break;
block|}
name|pt
operator|=
operator|(
specifier|const
expr|struct
name|pppoe_tag
operator|*
operator|)
name|ptn
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pppoe_send_event
parameter_list|(
name|sessp
name|sp
parameter_list|,
name|enum
name|cmd
name|cmdid
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ngpppoe_sts
modifier|*
name|sts
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%20s: called %d"
argument_list|,
name|__func__
argument_list|,
name|sp
operator|->
name|Session_ID
argument_list|)
expr_stmt|;
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_PPPOE_COOKIE
argument_list|,
name|cmdid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngpppoe_sts
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sts
operator|=
operator|(
expr|struct
name|ngpppoe_sts
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|strncpy
argument_list|(
name|sts
operator|->
name|hook
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|sp
operator|->
name|hook
argument_list|)
argument_list|,
name|NG_HOOKSIZ
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_ID
argument_list|(
name|error
argument_list|,
name|NG_HOOK_NODE
argument_list|(
name|sp
operator|->
name|hook
argument_list|)
argument_list|,
name|msg
argument_list|,
name|sp
operator|->
name|creator
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

