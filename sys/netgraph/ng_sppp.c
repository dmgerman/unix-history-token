begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_sppp.c Netgraph to Sppp module.  */
end_comment

begin_comment
comment|/*-  * Copyright (C) 2002-2004 Cronyx Engineering.  * Copyright (C) 2002-2004 Roman Kurakin<rik@cronyx.ru>  *  * This software is distributed with NO WARRANTIES, not even the implied  * warranties for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Authors grant any other persons or organisations a permission to use,  * modify and redistribute this software in source and binary forms,  * as long as this message is kept with the software, all derivative  * works or modified versions.  *  * Cronyx Id: ng_sppp.c,v 1.1.2.10 2004/03/01 15:17:21 rik Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_sppp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_sppp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_SPPP
argument_list|,
literal|"netgraph_sppp"
argument_list|,
literal|"netgraph sppp node "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_SPPP
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Node private data */
end_comment

begin_struct
struct|struct
name|ng_sppp_private
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* Our interface */
name|int
name|unit
decl_stmt|;
comment|/* Interface unit number */
name|node_p
name|node
decl_stmt|;
comment|/* Our netgraph node */
name|hook_p
name|hook
decl_stmt|;
comment|/* Hook */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_sppp_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Interface methods */
end_comment

begin_function_decl
specifier|static
name|void
name|ng_sppp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_sppp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_sppp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_sppp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_sppp_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_sppp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_sppp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_sppp_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_sppp_cmds
index|[]
init|=
block|{
block|{
name|NGM_SPPP_COOKIE
block|,
name|NGM_SPPP_GET_IFNAME
block|,
literal|"getifname"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_SPPP_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_sppp_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_sppp_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_sppp_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_sppp_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_sppp_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_sppp_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_sppp_cmds
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|sppp
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ng_sppp
argument_list|,
name|sppp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* We keep a bitmap indicating which unit numbers are free.    Zero means the unit number is free, one means it's taken. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|ng_sppp_units
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ng_sppp_units_len
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ng_units_in_use
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find the first free unit number for a new interface.  * Increase the size of the unit bitmap as necessary.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ng_sppp_get_unit
parameter_list|(
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|;
name|unsigned
name|char
name|mask
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|ng_sppp_units_len
operator|&&
name|ng_sppp_units
index|[
name|index
index|]
operator|==
literal|0xFF
condition|;
name|index
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|index
operator|==
name|ng_sppp_units_len
condition|)
block|{
comment|/* extend array */
name|unsigned
name|char
modifier|*
name|newarray
decl_stmt|;
name|int
name|newlen
decl_stmt|;
name|newlen
operator|=
operator|(
literal|2
operator|*
name|ng_sppp_units_len
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ng_sppp_units
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
argument|newarray
argument_list|,
argument|unsigned char *
argument_list|,
argument|newlen * sizeof (*ng_sppp_units)
argument_list|,
argument|M_NETGRAPH_SPPP
argument_list|,
argument|M_NOWAIT
argument_list|)
empty_stmt|;
if|if
condition|(
name|newarray
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|ng_sppp_units
argument_list|,
name|newarray
argument_list|,
name|ng_sppp_units_len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ng_sppp_units
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|newarray
operator|+
name|ng_sppp_units_len
argument_list|,
name|newlen
operator|-
name|ng_sppp_units_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_sppp_units
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ng_sppp_units
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
name|ng_sppp_units
operator|=
name|newarray
expr_stmt|;
name|ng_sppp_units_len
operator|=
name|newlen
expr_stmt|;
block|}
name|mask
operator|=
name|ng_sppp_units
index|[
name|index
index|]
expr_stmt|;
for|for
control|(
name|bit
operator|=
literal|0
init|;
operator|(
name|mask
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|;
name|bit
operator|++
control|)
name|mask
operator|>>=
literal|1
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bit
operator|>=
literal|0
operator|&&
name|bit
operator|<
name|NBBY
operator|)
argument_list|,
operator|(
literal|"%s: word=%d bit=%d"
operator|,
name|__func__
operator|,
name|ng_sppp_units
index|[
name|index
index|]
operator|,
name|bit
operator|)
argument_list|)
expr_stmt|;
name|ng_sppp_units
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
operator|*
name|unit
operator|=
operator|(
name|index
operator|*
name|NBBY
operator|)
operator|+
name|bit
expr_stmt|;
name|ng_units_in_use
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a no longer needed unit number.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ng_sppp_free_unit
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|int
name|index
decl_stmt|,
name|bit
decl_stmt|;
name|index
operator|=
name|unit
operator|/
name|NBBY
expr_stmt|;
name|bit
operator|=
name|unit
operator|%
name|NBBY
expr_stmt|;
name|KASSERT
argument_list|(
name|index
operator|<
name|ng_sppp_units_len
argument_list|,
operator|(
literal|"%s: unit=%d len=%d"
operator|,
name|__func__
operator|,
name|unit
operator|,
name|ng_sppp_units_len
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ng_sppp_units
index|[
name|index
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: unit=%d is free"
operator|,
name|__func__
operator|,
name|unit
operator|)
argument_list|)
expr_stmt|;
name|ng_sppp_units
index|[
name|index
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
name|ng_units_in_use
operator|--
expr_stmt|;
if|if
condition|(
name|ng_units_in_use
operator|==
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|ng_sppp_units
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
name|ng_sppp_units_len
operator|=
literal|0
expr_stmt|;
name|ng_sppp_units
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************ 			INTERFACE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Process an ioctl for the interface  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|sppp_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * This routine should never be called  */
end_comment

begin_function
specifier|static
name|void
name|ng_sppp_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|priv_p
name|priv
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* Check interface flags */
comment|/* 	 * This has side effects. It is not good idea to stop sending if we 	 * are not UP. If we are not running we still want to send LCP term 	 * packets. 	 */
comment|/*	if (!((ifp->if_flags& IFF_UP)&& */
comment|/*	    (ifp->if_drv_flags& IFF_DRV_RUNNING))) { */
comment|/*		return;*/
comment|/*	}*/
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return;
if|if
condition|(
operator|!
name|priv
operator|->
name|hook
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|sppp_dequeue
argument_list|(
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
return|return;
block|}
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Constructor for a node  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|sppp
modifier|*
name|pp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|priv_p
name|priv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Allocate node and interface private structures */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_PPP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|pp
operator|=
name|IFP2SP
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Link them together */
name|ifp
operator|->
name|if_softc
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
comment|/* Get an interface unit number */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_sppp_get_unit
argument_list|(
operator|&
name|priv
operator|->
name|unit
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Link together node and private info */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|node
expr_stmt|;
comment|/* Initialize interface structure */
name|if_initname
argument_list|(
name|SP2IFP
argument_list|(
name|pp
argument_list|)
argument_list|,
name|NG_SPPP_IFACE_NAME
argument_list|,
name|priv
operator|->
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|ng_sppp_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ng_sppp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_watchdog
operator|=
name|NULL
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
comment|/* Give this node the same name as the interface (if possible) */
if|if
condition|(
name|ng_name_node
argument_list|(
name|node
argument_list|,
name|SP2IFP
argument_list|(
name|pp
argument_list|)
operator|->
name|if_xname
argument_list|)
operator|!=
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: can't acquire netgraph name\n"
argument_list|,
name|SP2IFP
argument_list|(
name|pp
argument_list|)
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* Attach the interface */
name|sppp_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our ok for a hook to be added  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_SPPP_HOOK_DOWNSTREAM
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|priv
operator|->
name|hook
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
name|priv
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|priv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|sppp
modifier|*
specifier|const
name|pp
init|=
name|IFP2SP
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_SPPP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SPPP_GET_IFNAME
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|IFNAMSIZ
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|resp
operator|->
name|data
argument_list|,
name|SP2IFP
argument_list|(
name|pp
argument_list|)
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recive data from a hook. Pass the packet to the correct input routine.  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sppp
modifier|*
specifier|const
name|pp
init|=
name|IFP2SP
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Sanity checks */
name|KASSERT
argument_list|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"%s: not pkthdr"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SP2IFP
argument_list|(
name|pp
argument_list|)
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Update interface stats */
name|SP2IFP
argument_list|(
name|pp
argument_list|)
operator|->
name|if_ipackets
operator|++
expr_stmt|;
comment|/* Note receiving interface */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|SP2IFP
argument_list|(
name|pp
argument_list|)
expr_stmt|;
comment|/* Berkeley packet filter */
name|BPF_MTAP
argument_list|(
name|SP2IFP
argument_list|(
name|pp
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Send packet */
name|sppp_input
argument_list|(
name|SP2IFP
argument_list|(
name|pp
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown and remove the node and its associated interface.  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Detach from the packet filter list of interfaces. */
name|bpfdetach
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|sppp_detach
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|ng_sppp_free_unit
argument_list|(
name|priv
operator|->
name|unit
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_SPPP
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection.  */
end_comment

begin_function
specifier|static
name|int
name|ng_sppp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
condition|)
name|priv
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

