begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_btsocket_rfcomm.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001-2003 Maksim Yevmenkin<m_evmenkin@yahoo.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: ng_btsocket_rfcomm.c,v 1.28 2003/09/14 23:29:06 max Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_bluetooth.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_hci.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_l2cap.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_btsocket.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_btsocket_l2cap.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_btsocket_rfcomm.h>
end_include

begin_comment
comment|/* MALLOC define */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|,
literal|"netgraph_btsocks_rfcomm"
argument_list|,
literal|"Netgraph Bluetooth RFCOMM sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_BTSOCKET_RFCOMM
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NG_SEPARATE_MALLOC */
end_comment

begin_comment
comment|/* Debug */
end_comment

begin_define
define|#
directive|define
name|NG_BTSOCKET_RFCOMM_INFO
define|\
value|if (ng_btsocket_rfcomm_debug_level>= NG_BTSOCKET_INFO_LEVEL&& \ 	    ppsratecheck(&ng_btsocket_rfcomm_lasttime,&ng_btsocket_rfcomm_curpps, 1)) \ 		printf
end_define

begin_define
define|#
directive|define
name|NG_BTSOCKET_RFCOMM_WARN
define|\
value|if (ng_btsocket_rfcomm_debug_level>= NG_BTSOCKET_WARN_LEVEL&& \ 	    ppsratecheck(&ng_btsocket_rfcomm_lasttime,&ng_btsocket_rfcomm_curpps, 1)) \ 		printf
end_define

begin_define
define|#
directive|define
name|NG_BTSOCKET_RFCOMM_ERR
define|\
value|if (ng_btsocket_rfcomm_debug_level>= NG_BTSOCKET_ERR_LEVEL&& \ 	    ppsratecheck(&ng_btsocket_rfcomm_lasttime,&ng_btsocket_rfcomm_curpps, 1)) \ 		printf
end_define

begin_define
define|#
directive|define
name|NG_BTSOCKET_RFCOMM_ALERT
define|\
value|if (ng_btsocket_rfcomm_debug_level>= NG_BTSOCKET_ALERT_LEVEL&& \ 	    ppsratecheck(&ng_btsocket_rfcomm_lasttime,&ng_btsocket_rfcomm_curpps, 1)) \ 		printf
end_define

begin_define
define|#
directive|define
name|ALOT
value|0x7fff
end_define

begin_comment
comment|/* Local prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_sessions_task
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_session_task
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ng_btsocket_rfcomm_task_wakeup
parameter_list|()
define|\
value|taskqueue_enqueue(taskqueue_swi_giant,&ng_btsocket_rfcomm_task)
end_define

begin_function_decl
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_connect_ind
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_connect_cfm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_session_create
parameter_list|(
name|ng_btsocket_rfcomm_session_p
modifier|*
name|sp
parameter_list|,
name|struct
name|socket
modifier|*
name|l2so
parameter_list|,
name|bdaddr_p
name|src
parameter_list|,
name|bdaddr_p
name|dst
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_session_accept
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_session_connect
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_session_receive
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_session_send
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_session_clean
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_session_process_pcb
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_btsocket_rfcomm_session_p
name|ng_btsocket_rfcomm_session_by_addr
parameter_list|(
name|bdaddr_p
name|src
parameter_list|,
name|bdaddr_p
name|dst
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_frame
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_sabm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_disc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_ua
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_dm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_uih
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|,
name|int
name|pf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_mcc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_test
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_fc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_msc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_rpn
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_rls
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_pn
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_set_pn
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|u_int8_t
name|cr
parameter_list|,
name|u_int8_t
name|flow_control
parameter_list|,
name|u_int8_t
name|credits
parameter_list|,
name|u_int16_t
name|mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_send_command
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_send_uih
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|u_int8_t
name|address
parameter_list|,
name|u_int8_t
name|pf
parameter_list|,
name|u_int8_t
name|credits
parameter_list|,
name|struct
name|mbuf
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_send_msc
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_send_pn
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_send_credits
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_btsocket_rfcomm_pcb_send
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|int
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_pcb_kill
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_pcb_by_dlci
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_pcb_listener
parameter_list|(
name|bdaddr_p
name|src
parameter_list|,
name|int
name|channel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_timeout
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_untimeout
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_btsocket_rfcomm_process_timeout
parameter_list|(
name|void
modifier|*
name|xpcb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_btsocket_rfcomm_prepare_packet
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Globals */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|ifqmaxlen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ng_btsocket_rfcomm_debug_level
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ng_btsocket_rfcomm_timo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|task
name|ng_btsocket_rfcomm_task
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_btsocket_rfcomm_session
argument_list|)
name|ng_btsocket_rfcomm_sessions
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_btsocket_rfcomm_sessions_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_btsocket_rfcomm_pcb
argument_list|)
name|ng_btsocket_rfcomm_sockets
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_btsocket_rfcomm_sockets_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|ng_btsocket_rfcomm_lasttime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ng_btsocket_rfcomm_curpps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sysctl tree */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_bluetooth_rfcomm_sockets
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_bluetooth_rfcomm_sockets
argument_list|,
name|OID_AUTO
argument_list|,
name|stream
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Bluetooth STREAM RFCOMM sockets family"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_bluetooth_rfcomm_sockets_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|debug_level
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ng_btsocket_rfcomm_debug_level
argument_list|,
name|NG_BTSOCKET_INFO_LEVEL
argument_list|,
literal|"Bluetooth STREAM RFCOMM sockets debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_bluetooth_rfcomm_sockets_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ng_btsocket_rfcomm_timo
argument_list|,
literal|60
argument_list|,
literal|"Bluetooth STREAM RFCOMM sockets timeout"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                              RFCOMM CRC  *****************************************************************************  *****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|u_int8_t
name|ng_btsocket_rfcomm_crc_table
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x91
block|,
literal|0xe3
block|,
literal|0x72
block|,
literal|0x07
block|,
literal|0x96
block|,
literal|0xe4
block|,
literal|0x75
block|,
literal|0x0e
block|,
literal|0x9f
block|,
literal|0xed
block|,
literal|0x7c
block|,
literal|0x09
block|,
literal|0x98
block|,
literal|0xea
block|,
literal|0x7b
block|,
literal|0x1c
block|,
literal|0x8d
block|,
literal|0xff
block|,
literal|0x6e
block|,
literal|0x1b
block|,
literal|0x8a
block|,
literal|0xf8
block|,
literal|0x69
block|,
literal|0x12
block|,
literal|0x83
block|,
literal|0xf1
block|,
literal|0x60
block|,
literal|0x15
block|,
literal|0x84
block|,
literal|0xf6
block|,
literal|0x67
block|,
literal|0x38
block|,
literal|0xa9
block|,
literal|0xdb
block|,
literal|0x4a
block|,
literal|0x3f
block|,
literal|0xae
block|,
literal|0xdc
block|,
literal|0x4d
block|,
literal|0x36
block|,
literal|0xa7
block|,
literal|0xd5
block|,
literal|0x44
block|,
literal|0x31
block|,
literal|0xa0
block|,
literal|0xd2
block|,
literal|0x43
block|,
literal|0x24
block|,
literal|0xb5
block|,
literal|0xc7
block|,
literal|0x56
block|,
literal|0x23
block|,
literal|0xb2
block|,
literal|0xc0
block|,
literal|0x51
block|,
literal|0x2a
block|,
literal|0xbb
block|,
literal|0xc9
block|,
literal|0x58
block|,
literal|0x2d
block|,
literal|0xbc
block|,
literal|0xce
block|,
literal|0x5f
block|,
literal|0x70
block|,
literal|0xe1
block|,
literal|0x93
block|,
literal|0x02
block|,
literal|0x77
block|,
literal|0xe6
block|,
literal|0x94
block|,
literal|0x05
block|,
literal|0x7e
block|,
literal|0xef
block|,
literal|0x9d
block|,
literal|0x0c
block|,
literal|0x79
block|,
literal|0xe8
block|,
literal|0x9a
block|,
literal|0x0b
block|,
literal|0x6c
block|,
literal|0xfd
block|,
literal|0x8f
block|,
literal|0x1e
block|,
literal|0x6b
block|,
literal|0xfa
block|,
literal|0x88
block|,
literal|0x19
block|,
literal|0x62
block|,
literal|0xf3
block|,
literal|0x81
block|,
literal|0x10
block|,
literal|0x65
block|,
literal|0xf4
block|,
literal|0x86
block|,
literal|0x17
block|,
literal|0x48
block|,
literal|0xd9
block|,
literal|0xab
block|,
literal|0x3a
block|,
literal|0x4f
block|,
literal|0xde
block|,
literal|0xac
block|,
literal|0x3d
block|,
literal|0x46
block|,
literal|0xd7
block|,
literal|0xa5
block|,
literal|0x34
block|,
literal|0x41
block|,
literal|0xd0
block|,
literal|0xa2
block|,
literal|0x33
block|,
literal|0x54
block|,
literal|0xc5
block|,
literal|0xb7
block|,
literal|0x26
block|,
literal|0x53
block|,
literal|0xc2
block|,
literal|0xb0
block|,
literal|0x21
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0xb9
block|,
literal|0x28
block|,
literal|0x5d
block|,
literal|0xcc
block|,
literal|0xbe
block|,
literal|0x2f
block|,
literal|0xe0
block|,
literal|0x71
block|,
literal|0x03
block|,
literal|0x92
block|,
literal|0xe7
block|,
literal|0x76
block|,
literal|0x04
block|,
literal|0x95
block|,
literal|0xee
block|,
literal|0x7f
block|,
literal|0x0d
block|,
literal|0x9c
block|,
literal|0xe9
block|,
literal|0x78
block|,
literal|0x0a
block|,
literal|0x9b
block|,
literal|0xfc
block|,
literal|0x6d
block|,
literal|0x1f
block|,
literal|0x8e
block|,
literal|0xfb
block|,
literal|0x6a
block|,
literal|0x18
block|,
literal|0x89
block|,
literal|0xf2
block|,
literal|0x63
block|,
literal|0x11
block|,
literal|0x80
block|,
literal|0xf5
block|,
literal|0x64
block|,
literal|0x16
block|,
literal|0x87
block|,
literal|0xd8
block|,
literal|0x49
block|,
literal|0x3b
block|,
literal|0xaa
block|,
literal|0xdf
block|,
literal|0x4e
block|,
literal|0x3c
block|,
literal|0xad
block|,
literal|0xd6
block|,
literal|0x47
block|,
literal|0x35
block|,
literal|0xa4
block|,
literal|0xd1
block|,
literal|0x40
block|,
literal|0x32
block|,
literal|0xa3
block|,
literal|0xc4
block|,
literal|0x55
block|,
literal|0x27
block|,
literal|0xb6
block|,
literal|0xc3
block|,
literal|0x52
block|,
literal|0x20
block|,
literal|0xb1
block|,
literal|0xca
block|,
literal|0x5b
block|,
literal|0x29
block|,
literal|0xb8
block|,
literal|0xcd
block|,
literal|0x5c
block|,
literal|0x2e
block|,
literal|0xbf
block|,
literal|0x90
block|,
literal|0x01
block|,
literal|0x73
block|,
literal|0xe2
block|,
literal|0x97
block|,
literal|0x06
block|,
literal|0x74
block|,
literal|0xe5
block|,
literal|0x9e
block|,
literal|0x0f
block|,
literal|0x7d
block|,
literal|0xec
block|,
literal|0x99
block|,
literal|0x08
block|,
literal|0x7a
block|,
literal|0xeb
block|,
literal|0x8c
block|,
literal|0x1d
block|,
literal|0x6f
block|,
literal|0xfe
block|,
literal|0x8b
block|,
literal|0x1a
block|,
literal|0x68
block|,
literal|0xf9
block|,
literal|0x82
block|,
literal|0x13
block|,
literal|0x61
block|,
literal|0xf0
block|,
literal|0x85
block|,
literal|0x14
block|,
literal|0x66
block|,
literal|0xf7
block|,
literal|0xa8
block|,
literal|0x39
block|,
literal|0x4b
block|,
literal|0xda
block|,
literal|0xaf
block|,
literal|0x3e
block|,
literal|0x4c
block|,
literal|0xdd
block|,
literal|0xa6
block|,
literal|0x37
block|,
literal|0x45
block|,
literal|0xd4
block|,
literal|0xa1
block|,
literal|0x30
block|,
literal|0x42
block|,
literal|0xd3
block|,
literal|0xb4
block|,
literal|0x25
block|,
literal|0x57
block|,
literal|0xc6
block|,
literal|0xb3
block|,
literal|0x22
block|,
literal|0x50
block|,
literal|0xc1
block|,
literal|0xba
block|,
literal|0x2b
block|,
literal|0x59
block|,
literal|0xc8
block|,
literal|0xbd
block|,
literal|0x2c
block|,
literal|0x5e
block|,
literal|0xcf
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* CRC */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ng_btsocket_rfcomm_crc
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|u_int8_t
name|crc
init|=
literal|0xff
decl_stmt|;
while|while
condition|(
name|length
operator|--
condition|)
name|crc
operator|=
name|ng_btsocket_rfcomm_crc_table
index|[
name|crc
operator|^
operator|*
name|data
operator|++
index|]
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_crc */
end_comment

begin_comment
comment|/* FCS on 2 bytes */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ng_btsocket_rfcomm_fcs2
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
literal|0xff
operator|-
name|ng_btsocket_rfcomm_crc
argument_list|(
name|data
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_fcs2 */
end_comment

begin_comment
comment|/* FCS on 3 bytes */
end_comment

begin_function
specifier|static
name|u_int8_t
name|ng_btsocket_rfcomm_fcs3
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
literal|0xff
operator|-
name|ng_btsocket_rfcomm_crc
argument_list|(
name|data
argument_list|,
literal|3
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_fcs3 */
end_comment

begin_comment
comment|/*   * Check FCS  *  * From Bluetooth spec  *  * "... In 07.10, the frame check sequence (FCS) is calculated on different   * sets of fields for different frame types. These are the fields that the   * FCS are calculated on:  *  * For SABM, DISC, UA, DM frames: on Address, Control and length field.  * For UIH frames: on Address and Control field.  *  * (This is stated here for clarification, and to set the standard for RFCOMM;  * the fields included in FCS calculation have actually changed in version  * 7.0.0 of TS 07.10, but RFCOMM will not change the FCS calculation scheme  * from the one above.) ..."  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_check_fcs
parameter_list|(
name|u_int8_t
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|u_int8_t
name|fcs
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|RFCOMM_FRAME_UIH
condition|)
return|return
operator|(
name|ng_btsocket_rfcomm_fcs3
argument_list|(
name|data
argument_list|)
operator|!=
name|fcs
operator|)
return|;
return|return
operator|(
name|ng_btsocket_rfcomm_fcs2
argument_list|(
name|data
argument_list|)
operator|!=
name|fcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_check_fcs */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                              Socket interface  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*   * Initialize everything  */
end_comment

begin_function
name|void
name|ng_btsocket_rfcomm_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Skip initialization of globals for non-default instances. */
if|if
condition|(
operator|!
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
return|return;
name|ng_btsocket_rfcomm_debug_level
operator|=
name|NG_BTSOCKET_WARN_LEVEL
expr_stmt|;
name|ng_btsocket_rfcomm_timo
operator|=
literal|60
expr_stmt|;
comment|/* RFCOMM task */
name|TASK_INIT
argument_list|(
operator|&
name|ng_btsocket_rfcomm_task
argument_list|,
literal|0
argument_list|,
name|ng_btsocket_rfcomm_sessions_task
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* RFCOMM sessions list */
name|LIST_INIT
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|,
literal|"btsocks_rfcomm_sessions_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* RFCOMM sockets list */
name|LIST_INIT
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|,
literal|"btsocks_rfcomm_sockets_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_init */
end_comment

begin_comment
comment|/*  * Abort connection on socket  */
end_comment

begin_function
name|void
name|ng_btsocket_rfcomm_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|so
operator|->
name|so_error
operator|=
name|ECONNABORTED
expr_stmt|;
operator|(
name|void
operator|)
name|ng_btsocket_rfcomm_disconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_abort */
end_comment

begin_function
name|void
name|ng_btsocket_rfcomm_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
operator|(
name|void
operator|)
name|ng_btsocket_rfcomm_disconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_close */
end_comment

begin_comment
comment|/*  * Accept connection on socket. Nothing to do here, socket must be connected  * and ready, so just return peer address and be done with it.  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
operator|(
name|ng_btsocket_rfcomm_peeraddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_accept */
end_comment

begin_comment
comment|/*  * Create and attach new socket  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check socket and protocol */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
name|ESOCKTNOSUPPORT
operator|)
return|;
if|#
directive|if
literal|0
comment|/* XXX sonewconn() calls "pru_attach" with proto == 0 */
block|if (proto != 0)  		if (proto != BLUETOOTH_PROTO_RFCOMM) 			return (EPROTONOSUPPORT);
endif|#
directive|endif
comment|/* XXX */
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Reserve send and receive space if it is not reserved yet */
if|if
condition|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|NG_BTSOCKET_RFCOMM_SENDSPACE
argument_list|,
name|NG_BTSOCKET_RFCOMM_RECVSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate the PCB */
name|pcb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pcb
argument_list|)
argument_list|,
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Link the PCB and the socket */
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|pcb
expr_stmt|;
name|pcb
operator|->
name|so
operator|=
name|so
expr_stmt|;
comment|/* Initialize PCB */
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CLOSED
expr_stmt|;
name|pcb
operator|->
name|flags
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CFC
expr_stmt|;
name|pcb
operator|->
name|lmodem
operator|=
name|pcb
operator|->
name|rmodem
operator|=
operator|(
name|RFCOMM_MODEM_RTC
operator||
name|RFCOMM_MODEM_RTR
operator||
name|RFCOMM_MODEM_DV
operator|)
expr_stmt|;
name|pcb
operator|->
name|mtu
operator|=
name|RFCOMM_DEFAULT_MTU
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|=
literal|0
expr_stmt|;
name|pcb
operator|->
name|rx_cred
operator|=
name|RFCOMM_DEFAULT_CREDITS
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
literal|"btsocks_rfcomm_pcb_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|pcb
operator|->
name|timo
argument_list|,
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Add the PCB to the list */
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets
argument_list|,
name|pcb
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_attach */
end_comment

begin_comment
comment|/*  * Bind socket  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_t
modifier|*
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|,
modifier|*
name|pcb1
decl_stmt|;
name|struct
name|sockaddr_rfcomm
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_rfcomm
operator|*
operator|)
name|nam
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Verify address */
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_family
operator|!=
name|AF_BLUETOOTH
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_channel
operator|>
literal|30
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_channel
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pcb1
argument_list|,
argument|&ng_btsocket_rfcomm_sockets
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|pcb1
operator|->
name|channel
operator|==
name|sa
operator|->
name|rfcomm_channel
operator|&&
name|bcmp
argument_list|(
operator|&
name|pcb1
operator|->
name|src
argument_list|,
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb1
operator|->
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|,
operator|&
name|pcb
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|channel
operator|=
name|sa
operator|->
name|rfcomm_channel
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_bind */
end_comment

begin_comment
comment|/*  * Connect socket  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_t
modifier|*
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_rfcomm
modifier|*
name|sa
init|=
operator|(
expr|struct
name|sockaddr_rfcomm
operator|*
operator|)
name|nam
decl_stmt|;
name|ng_btsocket_rfcomm_session_t
modifier|*
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|l2so
init|=
name|NULL
decl_stmt|;
name|int
name|dlci
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Verify address */
if|if
condition|(
name|sa
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_family
operator|!=
name|AF_BLUETOOTH
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sa
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_channel
operator|>
literal|30
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sa
operator|->
name|rfcomm_channel
operator|==
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|,
name|NG_HCI_BDADDR_ANY
argument_list|,
sizeof|sizeof
argument_list|(
name|bdaddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EDESTADDRREQ
operator|)
return|;
comment|/* 	 * Note that we will not check for errors in socreate() because 	 * if we failed to create L2CAP socket at this point we still 	 * might have already open session. 	 */
name|error
operator|=
name|socreate
argument_list|(
name|PF_BLUETOOTH
argument_list|,
operator|&
name|l2so
argument_list|,
name|SOCK_SEQPACKET
argument_list|,
name|BLUETOOTH_PROTO_L2CAP
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/*  	 * Look for session between "pcb->src" and "sa->rfcomm_bdaddr" (dst) 	 */
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
name|s
operator|=
name|ng_btsocket_rfcomm_session_by_addr
argument_list|(
operator|&
name|pcb
operator|->
name|src
argument_list|,
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We need to create new RFCOMM session. Check if we have L2CAP 		 * socket. If l2so == NULL then error has the error code from 		 * socreate() 		 */
if|if
condition|(
name|l2so
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ng_btsocket_rfcomm_session_create
argument_list|(
operator|&
name|s
argument_list|,
name|l2so
argument_list|,
operator|&
name|pcb
operator|->
name|src
argument_list|,
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|l2so
operator|!=
name|NULL
condition|)
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
comment|/* we don't need new L2CAP socket */
comment|/* 	 * Check if we already have the same DLCI the same session 	 */
name|mtx_lock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|dlci
operator|=
name|RFCOMM_MKDLCI
argument_list|(
operator|!
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|sa
operator|->
name|rfcomm_channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 * Check session state and if its not acceptable then refuse connection 	 */
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
case|:
comment|/* 		 * Update destination address and channel and attach  		 * DLC to the session 		 */
name|bcopy
argument_list|(
operator|&
name|sa
operator|->
name|rfcomm_bdaddr
argument_list|,
operator|&
name|pcb
operator|->
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|channel
operator|=
name|sa
operator|->
name|rfcomm_channel
expr_stmt|;
name|pcb
operator|->
name|dlci
operator|=
name|dlci
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|,
name|pcb
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|session
operator|=
name|s
expr_stmt|;
name|ng_btsocket_rfcomm_timeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
name|soisconnecting
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
condition|)
block|{
name|pcb
operator|->
name|mtu
operator|=
name|s
operator|->
name|mtu
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|so2l2cap_pcb
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
operator|->
name|src
argument_list|,
operator|&
name|pcb
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_pn
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
block|}
else|else
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ECONNRESET
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_connect */
end_comment

begin_comment
comment|/*  * Process ioctl's calls on socket.  * XXX FIXME this should provide interface to the RFCOMM multiplexor channel  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_control
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_control */
end_comment

begin_comment
comment|/*  * Process getsockopt/setsockopt system calls  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|ng_btsocket_rfcomm_fc_info
name|fcinfo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|SOL_RFCOMM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_RFCOMM_MTU
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|pcb
operator|->
name|mtu
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_RFCOMM_FC_INFO
case|:
name|fcinfo
operator|.
name|lmodem
operator|=
name|pcb
operator|->
name|lmodem
expr_stmt|;
name|fcinfo
operator|.
name|rmodem
operator|=
name|pcb
operator|->
name|rmodem
expr_stmt|;
name|fcinfo
operator|.
name|tx_cred
operator|=
name|pcb
operator|->
name|tx_cred
expr_stmt|;
name|fcinfo
operator|.
name|rx_cred
operator|=
name|pcb
operator|->
name|rx_cred
expr_stmt|;
name|fcinfo
operator|.
name|cfc
operator|=
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|fcinfo
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|fcinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|fcinfo
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_ctloutput */
end_comment

begin_comment
comment|/*  * Detach and destroy socket  */
end_comment

begin_function
name|void
name|ng_btsocket_rfcomm_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|pcb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ng_btsocket_rfcomm_detach: pcb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
case|:
comment|/* XXX What to do with pending request? */
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
condition|)
name|ng_btsocket_rfcomm_untimeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
condition|)
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_DETACHED
expr_stmt|;
else|else
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
expr_stmt|;
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
case|:
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CLOSED
condition|)
name|msleep
argument_list|(
operator|&
name|pcb
operator|->
name|state
argument_list|,
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"rf_det"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|session
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: pcb->session != NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
condition|)
name|panic
argument_list|(
literal|"%s: timeout on closed DLC, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pcb
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pcb
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcb
argument_list|,
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_detach */
end_comment

begin_comment
comment|/*  * Disconnect socket  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINPROGRESS
operator|)
return|;
block|}
comment|/* XXX What to do with pending request? */
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
condition|)
name|ng_btsocket_rfcomm_untimeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
case|:
comment|/* XXX can we get here? */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
case|:
comment|/* XXX can we get here? */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
case|:
comment|/* 		 * Just change DLC state and enqueue RFCOMM task. It will 		 * queue and send DISC on the DLC. 		 */
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
expr_stmt|;
name|soisdisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CLOSED
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid DLC state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_disconnect */
end_comment

begin_comment
comment|/*  * Listen on socket. First call to listen() will create listening RFCOMM session  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|,
name|pcb1
decl_stmt|;
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|l2so
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|socreate_error
decl_stmt|,
name|usedchannels
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pcb
operator|->
name|channel
operator|>
literal|30
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|usedchannels
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|channel
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pcb1
argument_list|,
argument|&ng_btsocket_rfcomm_sockets
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|pcb1
operator|->
name|channel
operator|!=
literal|0
operator|&&
name|bcmp
argument_list|(
operator|&
name|pcb1
operator|->
name|src
argument_list|,
operator|&
name|pcb
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|usedchannels
operator||=
operator|(
literal|1
operator|<<
operator|(
name|pcb1
operator|->
name|channel
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|pcb
operator|->
name|channel
operator|=
literal|30
init|;
name|pcb
operator|->
name|channel
operator|>
literal|0
condition|;
name|pcb
operator|->
name|channel
operator|--
control|)
if|if
condition|(
operator|!
operator|(
name|usedchannels
operator|&
operator|(
literal|1
operator|<<
operator|(
name|pcb
operator|->
name|channel
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|pcb
operator|->
name|channel
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we will not check for errors in socreate() because 	 * if we failed to create L2CAP socket at this point we still 	 * might have already open session. 	 */
name|socreate_error
operator|=
name|socreate
argument_list|(
name|PF_BLUETOOTH
argument_list|,
operator|&
name|l2so
argument_list|,
name|SOCK_SEQPACKET
argument_list|,
name|BLUETOOTH_PROTO_L2CAP
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Transition the socket and session into the LISTENING state.  Check 	 * for collisions first, as there can only be one. 	 */
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ng_btsocket_rfcomm_sessions
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_SESSION_LISTENING
condition|)
break|break;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We need to create default RFCOMM session. Check if we have  		 * L2CAP socket. If l2so == NULL then error has the error code  		 * from socreate() 		 */
if|if
condition|(
name|l2so
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|socreate_error
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/*  		 * Create default listen RFCOMM session. The default RFCOMM  		 * session will listen on ANY address. 		 * 		 * XXX FIXME Note that currently there is no way to adjust MTU 		 * for the default session. 		 */
name|error
operator|=
name|ng_btsocket_rfcomm_session_create
argument_list|(
operator|&
name|s
argument_list|,
name|l2so
argument_list|,
name|NG_HCI_BDADDR_ANY
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|l2so
operator|=
name|NULL
expr_stmt|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If we still have an l2so reference here, it's unneeded, so release 	 * it. 	 */
if|if
condition|(
name|l2so
operator|!=
name|NULL
condition|)
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_listen */
end_comment

begin_comment
comment|/*  * Get peer address  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_rfcomm
name|sa
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|pcb
operator|->
name|dst
argument_list|,
operator|&
name|sa
operator|.
name|rfcomm_bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|rfcomm_bdaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|rfcomm_channel
operator|=
name|pcb
operator|->
name|channel
expr_stmt|;
name|sa
operator|.
name|rfcomm_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|rfcomm_family
operator|=
name|AF_BLUETOOTH
expr_stmt|;
operator|*
name|nam
operator|=
name|sodupsockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|nam
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_peeraddr */
end_comment

begin_comment
comment|/*  * Send data to socket  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_t
modifier|*
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check socket and input */
if|if
condition|(
name|pcb
operator|==
name|NULL
operator|||
name|m
operator|==
name|NULL
operator|||
name|control
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
comment|/* Make sure DLC is connected */
if|if
condition|(
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* Put the packet on the socket's send queue and wakeup RFCOMM task */
name|sbappend
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_snd
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_SENDING
operator|)
condition|)
block|{
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_SENDING
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|drop
label|:
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* checks for != NULL */
name|NG_FREE_M
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send */
end_comment

begin_comment
comment|/*  * Get socket address  */
end_comment

begin_function
name|int
name|ng_btsocket_rfcomm_sockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|so2rfcomm_pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_rfcomm
name|sa
decl_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|pcb
operator|->
name|src
argument_list|,
operator|&
name|sa
operator|.
name|rfcomm_bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|sa
operator|.
name|rfcomm_bdaddr
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|.
name|rfcomm_channel
operator|=
name|pcb
operator|->
name|channel
expr_stmt|;
name|sa
operator|.
name|rfcomm_len
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|sa
operator|.
name|rfcomm_family
operator|=
name|AF_BLUETOOTH
expr_stmt|;
operator|*
name|nam
operator|=
name|sodupsockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|nam
operator|==
name|NULL
operator|)
condition|?
name|ENOMEM
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_sockaddr */
end_comment

begin_comment
comment|/*  * Upcall function for L2CAP sockets. Enqueue RFCOMM task.  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: so == NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|NG_BTSOCKET_RFCOMM_ALERT
argument_list|(
literal|"%s: Could not enqueue RFCOMM task, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|SU_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_upcall */
end_comment

begin_comment
comment|/*  * RFCOMM task. Will handle all RFCOMM sessions in one pass.  * XXX FIXME does not scale very well  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_sessions_task
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|NULL
decl_stmt|,
name|s_next
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions
argument_list|)
init|;
name|s
operator|!=
name|NULL
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|s_next
operator|=
name|LIST_NEXT
argument_list|(
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|ng_btsocket_rfcomm_session_task
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
condition|)
block|{
comment|/* Unlink and clean the session */
name|LIST_REMOVE
argument_list|(
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|NG_BT_MBUFQ_DRAIN
argument_list|(
operator|&
name|s
operator|->
name|outq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: DLC list is not empty\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Close L2CAP socket */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|s
operator|->
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|s
operator|->
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|s
operator|->
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
name|SO_SND
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|s
operator|->
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|s
operator|=
name|s_next
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_sessions_task */
end_comment

begin_comment
comment|/*  * Process RFCOMM session. Will handle all RFCOMM sockets in one pass.  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_session_task
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|l2so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: L2CAP connection has been terminated, so=%p, so_state=%#x, so_count=%d, "
expr|\
literal|"state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|l2so
argument_list|,
name|s
operator|->
name|l2so
operator|->
name|so_state
argument_list|,
name|s
operator|->
name|l2so
operator|->
name|so_count
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* Now process upcall */
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
comment|/* Try to accept new L2CAP connection(s) */
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_LISTENING
case|:
while|while
condition|(
name|ng_btsocket_rfcomm_session_accept
argument_list|(
name|s
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
break|break;
comment|/* Process the results of the L2CAP connect */
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTING
case|:
name|ng_btsocket_rfcomm_session_process_pcb
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_btsocket_rfcomm_session_connect
argument_list|(
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Try to receive/send more data */
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
case|:
name|ng_btsocket_rfcomm_session_process_pcb
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_btsocket_rfcomm_session_receive
argument_list|(
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ng_btsocket_rfcomm_session_send
argument_list|(
name|s
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid session state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_task */
end_comment

begin_comment
comment|/*  * Process RFCOMM connection indicator. Caller must hold s->session_mtx  */
end_comment

begin_function
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_connect_ind
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|,
name|pcb1
init|=
name|NULL
decl_stmt|;
name|ng_btsocket_l2cap_pcb_p
name|l2pcb
init|=
name|NULL
decl_stmt|;
name|struct
name|socket
modifier|*
name|so1
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Try to find RFCOMM socket that listens on given source address  	 * and channel. This will return the best possible match. 	 */
name|l2pcb
operator|=
name|so2l2cap_pcb
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_listener
argument_list|(
operator|&
name|l2pcb
operator|->
name|src
argument_list|,
name|channel
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Check the pending connections queue and if we have space then  	 * create new socket and set proper source and destination address, 	 * and channel. 	 */
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|pcb
operator|->
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|so1
operator|=
name|sonewconn
argument_list|(
name|pcb
operator|->
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|so1
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we got here than we have created new socket. So complete the  	 * connection. Set source and destination address from the session. 	 */
name|pcb1
operator|=
name|so2rfcomm_pcb
argument_list|(
name|so1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb1
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: pcb1 == NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcb1
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|l2pcb
operator|->
name|src
argument_list|,
operator|&
name|pcb1
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb1
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|l2pcb
operator|->
name|dst
argument_list|,
operator|&
name|pcb1
operator|->
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb1
operator|->
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|pcb1
operator|->
name|channel
operator|=
name|channel
expr_stmt|;
comment|/* Link new DLC to the session. We already hold s->session_mtx */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|,
name|pcb1
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
name|pcb1
operator|->
name|session
operator|=
name|s
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb1
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|pcb1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_connect_ind */
end_comment

begin_comment
comment|/*  * Process RFCOMM connect confirmation. Caller must hold s->session_mtx.  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_connect_cfm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|,
name|pcb_next
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Wake up all waiting sockets and send PN request for each of them.  	 * Note that timeout already been set in ng_btsocket_rfcomm_connect() 	 * 	 * Note: cannot use LIST_FOREACH because ng_btsocket_rfcomm_pcb_kill 	 * will unlink DLC from the session 	 */
for|for
control|(
name|pcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
init|;
name|pcb
operator|!=
name|NULL
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb_next
operator|=
name|LIST_NEXT
argument_list|(
name|pcb
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
condition|)
block|{
name|pcb
operator|->
name|mtu
operator|=
name|s
operator|->
name|mtu
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|so2l2cap_pcb
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
operator|->
name|src
argument_list|,
operator|&
name|pcb
operator|->
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|pcb
operator|->
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_pn
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
expr_stmt|;
else|else
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|pcb_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_connect_cfm */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                              RFCOMM sessions  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Create new RFCOMM session. That function WILL NOT take ownership over l2so.  * Caller MUST free l2so if function failed.  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_session_create
parameter_list|(
name|ng_btsocket_rfcomm_session_p
modifier|*
name|sp
parameter_list|,
name|struct
name|socket
modifier|*
name|l2so
parameter_list|,
name|bdaddr_p
name|src
parameter_list|,
name|bdaddr_p
name|dst
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_l2cap
name|l2sa
decl_stmt|;
name|struct
name|sockopt
name|l2sopt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int16_t
name|mtu
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Allocate the RFCOMM session */
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|,
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Set defaults */
name|s
operator|->
name|mtu
operator|=
name|RFCOMM_DEFAULT_MTU
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|NG_BT_MBUFQ_INIT
argument_list|(
operator|&
name|s
operator|->
name|outq
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Mark session mutex as DUPOK to prevent "duplicated lock of  	 * the same type" message. When accepting new L2CAP connection 	 * ng_btsocket_rfcomm_session_accept() holds both session mutexes  	 * for "old" (accepting) session and "new" (created) session. 	 */
name|mtx_init
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
literal|"btsocks_rfcomm_session_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
expr_stmt|;
comment|/* Prepare L2CAP socket */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|l2so
argument_list|,
name|SO_RCV
argument_list|,
name|ng_btsocket_rfcomm_upcall
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|l2so
argument_list|,
name|SO_SND
argument_list|,
name|ng_btsocket_rfcomm_upcall
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|l2so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
name|s
operator|->
name|l2so
operator|=
name|l2so
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * "src" == NULL and "dst" == NULL means just create session. 	 * caller must do the rest 	 */
if|if
condition|(
name|src
operator|==
name|NULL
operator|&&
name|dst
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Set incoming MTU on L2CAP socket. It is RFCOMM session default MTU  	 * plus 5 bytes: RFCOMM frame header, one extra byte for length and one 	 * extra byte for credits. 	 */
name|mtu
operator|=
name|s
operator|->
name|mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|rfcomm_frame_hdr
argument_list|)
operator|+
literal|1
operator|+
literal|1
expr_stmt|;
name|l2sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|l2sopt
operator|.
name|sopt_level
operator|=
name|SOL_L2CAP
expr_stmt|;
name|l2sopt
operator|.
name|sopt_name
operator|=
name|SO_L2CAP_IMTU
expr_stmt|;
name|l2sopt
operator|.
name|sopt_val
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|mtu
expr_stmt|;
name|l2sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
name|l2sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|sosetopt
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
operator|&
name|l2sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* Bind socket to "src" address */
name|l2sa
operator|.
name|l2cap_len
operator|=
sizeof|sizeof
argument_list|(
name|l2sa
argument_list|)
expr_stmt|;
name|l2sa
operator|.
name|l2cap_family
operator|=
name|AF_BLUETOOTH
expr_stmt|;
name|l2sa
operator|.
name|l2cap_psm
operator|=
operator|(
name|dst
operator|==
name|NULL
operator|)
condition|?
name|htole16
argument_list|(
name|NG_L2CAP_PSM_RFCOMM
argument_list|)
else|:
literal|0
expr_stmt|;
name|bcopy
argument_list|(
name|src
argument_list|,
operator|&
name|l2sa
operator|.
name|l2cap_bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|l2sa
operator|.
name|l2cap_bdaddr
argument_list|)
argument_list|)
expr_stmt|;
name|l2sa
operator|.
name|l2cap_cid
operator|=
literal|0
expr_stmt|;
name|l2sa
operator|.
name|l2cap_bdaddr_type
operator|=
name|BDADDR_BREDR
expr_stmt|;
name|error
operator|=
name|sobind
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|l2sa
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
comment|/* If "dst" is not NULL then initiate connect(), otherwise listen() */
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_LISTENING
expr_stmt|;
name|error
operator|=
name|solisten
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
literal|10
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|s
operator|->
name|flags
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_INITIATOR
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTING
expr_stmt|;
name|l2sa
operator|.
name|l2cap_len
operator|=
sizeof|sizeof
argument_list|(
name|l2sa
argument_list|)
expr_stmt|;
name|l2sa
operator|.
name|l2cap_family
operator|=
name|AF_BLUETOOTH
expr_stmt|;
name|l2sa
operator|.
name|l2cap_psm
operator|=
name|htole16
argument_list|(
name|NG_L2CAP_PSM_RFCOMM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dst
argument_list|,
operator|&
name|l2sa
operator|.
name|l2cap_bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|l2sa
operator|.
name|l2cap_bdaddr
argument_list|)
argument_list|)
expr_stmt|;
name|l2sa
operator|.
name|l2cap_cid
operator|=
literal|0
expr_stmt|;
name|l2sa
operator|.
name|l2cap_bdaddr_type
operator|=
name|BDADDR_BREDR
expr_stmt|;
name|error
operator|=
name|soconnect
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|l2sa
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
name|done
label|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions
argument_list|,
name|s
argument_list|,
name|next
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|=
name|s
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
comment|/* Return L2CAP socket back to its original state */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
name|SO_SND
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|l2so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|l2so
operator|->
name|so_state
operator|&=
operator|~
name|SS_NBIO
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|s
argument_list|,
name|M_NETGRAPH_BTSOCKET_RFCOMM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_create */
end_comment

begin_comment
comment|/*  * Process accept() on RFCOMM session  * XXX FIXME locking for "l2so"?  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_session_accept
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s0
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|l2so
decl_stmt|;
name|struct
name|sockaddr_l2cap
modifier|*
name|l2sa
init|=
name|NULL
decl_stmt|;
name|ng_btsocket_l2cap_pcb_t
modifier|*
name|l2pcb
init|=
name|NULL
decl_stmt|;
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s0
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SOLISTEN_LOCK
argument_list|(
name|s0
operator|->
name|l2so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_dequeue
argument_list|(
name|s0
operator|->
name|l2so
argument_list|,
operator|&
name|l2so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not accept connection on L2CAP socket, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|soaccept
argument_list|(
name|l2so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|l2sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: soaccept() on L2CAP socket failed, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check if there is already active RFCOMM session between two devices. 	 * If so then close L2CAP connection. We only support one RFCOMM session 	 * between each pair of devices. Note that here we assume session in any 	 * state. The session even could be in the middle of disconnecting. 	 */
name|l2pcb
operator|=
name|so2l2cap_pcb
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
name|s
operator|=
name|ng_btsocket_rfcomm_session_by_addr
argument_list|(
operator|&
name|l2pcb
operator|->
name|src
argument_list|,
operator|&
name|l2pcb
operator|->
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
comment|/* Create a new RFCOMM session */
name|error
operator|=
name|ng_btsocket_rfcomm_session_create
argument_list|(
operator|&
name|s
argument_list|,
name|l2so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|curthread
comment|/* XXX */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
expr_stmt|;
comment|/* 			 * Adjust MTU on incoming connection. Reserve 5 bytes: 			 * RFCOMM frame header, one extra byte for length and  			 * one extra byte for credits. 			 */
name|s
operator|->
name|mtu
operator|=
name|min
argument_list|(
name|l2pcb
operator|->
name|imtu
argument_list|,
name|l2pcb
operator|->
name|omtu
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rfcomm_frame_hdr
argument_list|)
operator|-
literal|1
operator|-
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NG_BTSOCKET_RFCOMM_ALERT
argument_list|(
literal|"%s: Failed to create new RFCOMM session, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Rejecting duplicating RFCOMM session between src=%x:%x:%x:%x:%x:%x and "
expr|\
literal|"dst=%x:%x:%x:%x:%x:%x, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|5
index|]
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|4
index|]
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|3
index|]
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|2
index|]
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|1
index|]
argument_list|,
name|l2pcb
operator|->
name|src
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|5
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|4
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|3
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|2
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|1
index|]
argument_list|,
name|l2pcb
operator|->
name|dst
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
name|soclose
argument_list|(
name|l2so
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_accept */
end_comment

begin_comment
comment|/*  * Process connect() on RFCOMM session  * XXX FIXME locking for "l2so"?  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_session_connect
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|ng_btsocket_l2cap_pcb_p
name|l2pcb
init|=
name|so2l2cap_pcb
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* First check if connection has failed */
if|if
condition|(
operator|(
name|error
operator|=
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not connect RFCOMM session, error=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Is connection still in progress? */
if|if
condition|(
name|s
operator|->
name|l2so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * If we got here then we are connected. Send SABM on DLCI 0 to  	 * open multiplexor channel. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
expr_stmt|;
comment|/* 		 * Adjust MTU on outgoing connection. Reserve 5 bytes: RFCOMM  		 * frame header, one extra byte for length and one extra byte  		 * for credits. 		 */
name|s
operator|->
name|mtu
operator|=
name|min
argument_list|(
name|l2pcb
operator|->
name|imtu
argument_list|,
name|l2pcb
operator|->
name|omtu
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|rfcomm_frame_hdr
argument_list|)
operator|-
literal|1
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_SABM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_connect */
end_comment

begin_comment
comment|/*  * Receive data on RFCOMM session  * XXX FIXME locking for "l2so"?  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_session_receive
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|int
name|more
decl_stmt|,
name|flags
decl_stmt|,
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Can we read from the L2CAP socket? */
if|if
condition|(
operator|!
name|soreadable
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* First check for error on L2CAP socket */
if|if
condition|(
operator|(
name|error
operator|=
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not receive data from L2CAP socket, error=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Read all packets from the L2CAP socket.  	 * XXX FIXME/VERIFY is that correct? For now use m->m_nextpkt as 	 * indication that there is more packets on the socket's buffer. 	 * Also what should we use in uio.uio_resid? 	 * May be s->mtu + sizeof(struct rfcomm_frame_hdr) + 1 + 1? 	 */
for|for
control|(
name|more
operator|=
literal|1
init|;
name|more
condition|;
control|)
block|{
comment|/* Try to get next packet from socket */
name|bzero
argument_list|(
operator|&
name|uio
argument_list|,
sizeof|sizeof
argument_list|(
name|uio
argument_list|)
argument_list|)
expr_stmt|;
comment|/*		uio.uio_td = NULL; */
name|uio
operator|.
name|uio_resid
operator|=
literal|1000000000
expr_stmt|;
name|flags
operator|=
name|MSG_DONTWAIT
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|soreceive
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
operator|&
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX can happen? */
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not receive data from L2CAP socket, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|more
operator|=
operator|(
name|m
operator|->
name|m_nextpkt
operator|!=
name|NULL
operator|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ng_btsocket_rfcomm_receive_frame
argument_list|(
name|s
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_receive */
end_comment

begin_comment
comment|/*  * Send data on RFCOMM session  * XXX FIXME locking for "l2so"?  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_session_send
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Send as much as we can from the session queue */
while|while
condition|(
name|sowriteable
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
condition|)
block|{
comment|/* Check if socket still OK */
if|if
condition|(
operator|(
name|error
operator|=
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|)
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|l2so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Detected error=%d on L2CAP socket, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NG_BT_MBUFQ_DEQUEUE
argument_list|(
operator|&
name|s
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* we are done */
comment|/* Call send function on the L2CAP socket */
name|error
operator|=
call|(
modifier|*
name|s
operator|->
name|l2so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|s
operator|->
name|l2so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|curthread
comment|/* XXX */
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not send data to L2CAP socket, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_send */
end_comment

begin_comment
comment|/*  * Close and disconnect all DLCs for the given session. Caller must hold   * s->sesson_mtx. Will wakeup session.  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_session_clean
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|,
name|pcb_next
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Note: cannot use LIST_FOREACH because ng_btsocket_rfcomm_pcb_kill 	 * will unlink DLC from the session 	 */
for|for
control|(
name|pcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
init|;
name|pcb
operator|!=
name|NULL
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb_next
operator|=
name|LIST_NEXT
argument_list|(
name|pcb
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Disconnecting dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
name|error
operator|=
name|ECONNRESET
expr_stmt|;
else|else
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|pcb_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_clean */
end_comment

begin_comment
comment|/*  * Process all DLCs on the session. Caller MUST hold s->session_mtx.  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_session_process_pcb
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|,
name|pcb_next
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Note: cannot use LIST_FOREACH because ng_btsocket_rfcomm_pcb_kill 	 * will unlink DLC from the session 	 */
for|for
control|(
name|pcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
init|;
name|pcb
operator|!=
name|NULL
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb_next
operator|=
name|LIST_NEXT
argument_list|(
name|pcb
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|state
condition|)
block|{
comment|/* 		 * If DLC in W4_CONNECT state then we should check for both 		 * timeout and detach. 		 */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
case|:
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_DETACHED
condition|)
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
condition|)
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * If DLC in CONFIGURING or CONNECTING state then we only 		 * should check for timeout. If detach() was called then 		 * DLC will be moved into DISCONNECTING state. 		 */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
case|:
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
condition|)
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * If DLC in CONNECTED state then we need to send data (if any) 		 * from the socket's send queue. Note that we will send data 		 * from either all sockets or none. This may overload session's 		 * outgoing queue (but we do not check for that). 		 *  		 * XXX FIXME need scheduler for RFCOMM sockets 		 */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
case|:
name|error
operator|=
name|ng_btsocket_rfcomm_pcb_send
argument_list|(
name|pcb
argument_list|,
name|ALOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * If DLC in DISCONNECTING state then we must send DISC frame. 		 * Note that if DLC has timeout set then we do not need to  		 * resend DISC frame. 		 * 		 * XXX FIXME need to drain all data from the socket's queue 		 * if LINGER option was set 		 */
case|case
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
case|:
if|if
condition|(
operator|!
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
operator|)
condition|)
block|{
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|pcb
operator|->
name|session
argument_list|,
name|RFCOMM_FRAME_DISC
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ng_btsocket_rfcomm_timeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
else|else
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
condition|)
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
comment|/*		case NG_BTSOCKET_RFCOMM_DLC_CLOSED: */
default|default:
name|panic
argument_list|(
literal|"%s: Invalid DLC state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|=
name|pcb_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_process_pcb */
end_comment

begin_comment
comment|/*  * Find RFCOMM session between "src" and "dst".  * Caller MUST hold ng_btsocket_rfcomm_sessions_mtx.  */
end_comment

begin_function
specifier|static
name|ng_btsocket_rfcomm_session_p
name|ng_btsocket_rfcomm_session_by_addr
parameter_list|(
name|bdaddr_p
name|src
parameter_list|,
name|bdaddr_p
name|dst
parameter_list|)
block|{
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|NULL
decl_stmt|;
name|ng_btsocket_l2cap_pcb_p
name|l2pcb
init|=
name|NULL
decl_stmt|;
name|int
name|any_src
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sessions_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|any_src
operator|=
operator|(
name|bcmp
argument_list|(
name|src
argument_list|,
name|NG_HCI_BDADDR_ANY
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|s
argument_list|,
argument|&ng_btsocket_rfcomm_sessions
argument_list|,
argument|next
argument_list|)
block|{
name|l2pcb
operator|=
name|so2l2cap_pcb
argument_list|(
name|s
operator|->
name|l2so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|any_src
operator|||
name|bcmp
argument_list|(
operator|&
name|l2pcb
operator|->
name|src
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|bcmp
argument_list|(
operator|&
name|l2pcb
operator|->
name|dst
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dst
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_session_by_addr */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                                  RFCOMM   *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Process incoming RFCOMM frame. Caller must hold s->session_mtx.  * XXX FIXME check frame length  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_frame
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_frame_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
name|u_int8_t
name|dlci
decl_stmt|,
name|type
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Pullup as much as we can into first mbuf (for direct access) */
name|length
operator|=
name|min
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
name|length
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ALERT
argument_list|(
literal|"%s: m_pullup(%d) failed\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|hdr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_frame_hdr
operator|*
argument_list|)
expr_stmt|;
name|dlci
operator|=
name|RFCOMM_DLCI
argument_list|(
name|hdr
operator|->
name|address
argument_list|)
expr_stmt|;
name|type
operator|=
name|RFCOMM_TYPE
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
expr_stmt|;
comment|/* Test EA bit in length. If not set then we have 2 bytes of length */
if|if
condition|(
operator|!
name|RFCOMM_EA
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|hdr
operator|->
name|length
argument_list|,
operator|&
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|le16toh
argument_list|(
name|length
argument_list|)
operator|>>
literal|1
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|hdr
operator|->
name|length
operator|>>
literal|1
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got frame type=%#x, dlci=%d, length=%d, cr=%d, pf=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|dlci
argument_list|,
name|length
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|address
argument_list|)
argument_list|,
name|RFCOMM_PF
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Get FCS (the last byte in the frame) 	 * XXX this will not work if mbuf chain ends with empty mbuf. 	 * XXX let's hope it never happens :) 	 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: Empty mbuf at the end of the chain, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check FCS. We only need to calculate FCS on first 2 or 3 bytes 	 * and already m_pullup'ed mbuf chain, so it should be safe. 	 */
if|if
condition|(
name|ng_btsocket_rfcomm_check_fcs
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|hdr
argument_list|,
name|type
argument_list|,
name|m
operator|->
name|m_data
index|[
name|m
operator|->
name|m_len
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Invalid RFCOMM packet. Bad checksum\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Trim FCS byte */
comment|/* 	 * Process RFCOMM frame. 	 * 	 * From TS 07.10 spec 	 *  	 * "... In the case where a SABM or DISC command with the P bit set 	 * to 0 is received then the received frame shall be discarded..."  	 * 	 * "... If a unsolicited DM response is received then the frame shall 	 * be processed irrespective of the P/F setting... " 	 * 	 * "... The station may transmit response frames with the F bit set  	 * to 0 at any opportunity on an asynchronous basis. However, in the  	 * case where a UA response is received with the F bit set to 0 then  	 * the received frame shall be discarded..." 	 * 	 * From Bluetooth spec 	 * 	 * "... When credit based flow control is being used, the meaning of 	 * the P/F bit in the control field of the RFCOMM header is redefined 	 * for UIH frames..." 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RFCOMM_FRAME_SABM
case|:
if|if
condition|(
name|RFCOMM_PF
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_receive_sabm
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
case|case
name|RFCOMM_FRAME_DISC
case|:
if|if
condition|(
name|RFCOMM_PF
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_receive_disc
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
case|case
name|RFCOMM_FRAME_UA
case|:
if|if
condition|(
name|RFCOMM_PF
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_receive_ua
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
case|case
name|RFCOMM_FRAME_DM
case|:
name|error
operator|=
name|ng_btsocket_rfcomm_receive_dm
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
case|case
name|RFCOMM_FRAME_UIH
case|:
if|if
condition|(
name|dlci
operator|==
literal|0
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_receive_mcc
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ng_btsocket_rfcomm_receive_uih
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|,
name|RFCOMM_PF
argument_list|(
name|hdr
operator|->
name|control
argument_list|)
argument_list|,
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* NOT REACHED */
default|default:
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Invalid RFCOMM packet. Unknown type=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_frame */
end_comment

begin_comment
comment|/*  * Process RFCOMM SABM frame  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_sabm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got SABM, session state=%d, flags=%#x, mtu=%d, dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* DLCI == 0 means open multiplexor channel */
if|if
condition|(
name|dlci
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
case|:
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_UA
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
expr_stmt|;
name|ng_btsocket_rfcomm_connect_cfm
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got SABM for session in invalid state state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Make sure multiplexor channel is open */
if|if
condition|(
name|s
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got SABM for dlci=%d with mulitplexor channel closed, state=%d, "
expr|\
literal|"flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check if we have this DLCI. This might happen when remote 	 * peer uses PN command before actual open (SABM) happens. 	 */
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got SABM for dlci=%d in invalid state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|ng_btsocket_rfcomm_untimeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_UA
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_send_msc
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
else|else
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * We do not have requested DLCI, so it must be an incoming connection 	 * with default parameters. Try to accept it. 	 */
name|pcb
operator|=
name|ng_btsocket_rfcomm_connect_ind
argument_list|(
name|s
argument_list|,
name|RFCOMM_SRVCHANNEL
argument_list|(
name|dlci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|dlci
operator|=
name|dlci
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_UA
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ng_btsocket_rfcomm_send_msc
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
else|else
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Nobody is listen()ing on the requested DLCI */
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DM
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_sabm */
end_comment

begin_comment
comment|/*  * Process RFCOMM DISC frame  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_disc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got DISC, session state=%d, flags=%#x, mtu=%d, dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* DLCI == 0 means close multiplexor channel */
if|if
condition|(
name|dlci
operator|==
literal|0
condition|)
block|{
comment|/* XXX FIXME assume that remote side will close the socket */
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_UA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
condition|)
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
comment|/* XXX */
else|else
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
expr_stmt|;
block|}
else|else
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
comment|/* XXX */
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|int
name|err
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got DISC for dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_UA
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
name|err
operator|=
literal|0
expr_stmt|;
else|else
name|err
operator|=
name|ECONNREFUSED
expr_stmt|;
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got DISC for non-existing dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DM
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_disc */
end_comment

begin_comment
comment|/*  * Process RFCOMM UA frame  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_ua
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got UA, session state=%d, flags=%#x, mtu=%d, dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* dlci == 0 means multiplexor channel */
if|if
condition|(
name|dlci
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
case|:
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
expr_stmt|;
name|ng_btsocket_rfcomm_connect_cfm
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
case|:
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UA for session in invalid state=%d(%d), flags=%#x, mtu=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Check if we have this DLCI */
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got UA for dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
case|:
name|ng_btsocket_rfcomm_untimeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_msc
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
case|:
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UA for dlci=%d in invalid state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UA for non-existing dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DM
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_ua */
end_comment

begin_comment
comment|/*  * Process RFCOMM DM frame  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_dm
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got DM, session state=%d, flags=%#x, mtu=%d, dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* DLCI == 0 means multiplexor channel */
if|if
condition|(
name|dlci
operator|==
literal|0
condition|)
block|{
comment|/* Disconnect all dlc's on the session */
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
name|ng_btsocket_rfcomm_session_clean
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got DM for dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
name|error
operator|=
name|ECONNRESET
expr_stmt|;
else|else
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got DM for non-existing dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_dm */
end_comment

begin_comment
comment|/*  * Process RFCOMM UIH frame (data)  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_uih
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|,
name|int
name|pf
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got UIH, session state=%d, flags=%#x, mtu=%d, dlci=%d, pf=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|,
name|pf
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* XXX should we do it here? Check for session flow control */
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_SESSION_LFC
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UIH with session flow control asserted, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* Check if we have this dlci */
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UIH for non-existing dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DM
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
comment|/* Check dlci state */
if|if
condition|(
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got UIH for dlci=%d in invalid state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|drop1
goto|;
block|}
comment|/* Check dlci flow control */
if|if
condition|(
operator|(
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
operator|)
operator|&&
name|pcb
operator|->
name|rx_cred
operator|<=
literal|0
operator|)
operator|||
operator|(
name|pcb
operator|->
name|lmodem
operator|&
name|RFCOMM_MODEM_FC
operator|)
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got UIH for dlci=%d with asserted flow control, state=%d, "
expr|\
literal|"flags=%#x, rx_cred=%d, lmodem=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|,
name|pcb
operator|->
name|lmodem
argument_list|)
expr_stmt|;
goto|goto
name|drop1
goto|;
block|}
comment|/* Did we get any credits? */
if|if
condition|(
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
operator|)
operator|&&
name|pf
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got %d more credits for dlci=%d, state=%d, flags=%#x, "
expr|\
literal|"rx_cred=%d, tx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|+=
operator|*
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send more from the DLC. XXX check for errors? */
name|ng_btsocket_rfcomm_pcb_send
argument_list|(
name|pcb
argument_list|,
name|ALOT
argument_list|)
expr_stmt|;
block|}
comment|/* OK the of the rest of the mbuf is the data */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|0
condition|)
block|{
comment|/* If we are using credit flow control decrease rx_cred here */
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
block|{
comment|/* Give remote peer more credits (if needed) */
if|if
condition|(
operator|--
name|pcb
operator|->
name|rx_cred
operator|<=
name|RFCOMM_MAX_CREDITS
operator|/
literal|2
condition|)
name|ng_btsocket_rfcomm_send_credits
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
else|else
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Remote side still has credits, dlci=%d, state=%d, flags=%#x, "
expr|\
literal|"rx_cred=%d, tx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
block|}
comment|/* Check packet against mtu on dlci */
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|pcb
operator|->
name|mtu
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got oversized UIH for dlci=%d, state=%d, flags=%#x, mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|sbspace
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
comment|/* 			 * This is really bad. Receive queue on socket does 			 * not have enough space for the packet. We do not 			 * have any other choice but drop the packet.  			 */
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Not enough space in socket receive queue. Dropping UIH for dlci=%d, "
expr|\
literal|"state=%d, flags=%#x, len=%d, space=%ld\n"
argument_list|,
name|__func__
argument_list|,
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|sbspace
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
comment|/* Append packet to the socket receive queue */
name|sbappend
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|,
name|m0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m0
operator|=
name|NULL
expr_stmt|;
name|sorwakeup
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
block|}
name|drop1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|drop
label|:
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* checks for != NULL */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_uih */
end_comment

begin_comment
comment|/*  * Process RFCOMM MCC command (Multiplexor)  *   * From TS 07.10 spec  *  * "5.4.3.1 Information Data  *   *  ...The frames (UIH) sent by the initiating station have the C/R bit set   *  to 1 and those sent by the responding station have the C/R bit set to 0..."  *  * "5.4.6.2 Operating procedures  *  *  Messages always exist in pairs; a command message and a corresponding   *  response message. If the C/R bit is set to 1 the message is a command,   *  if it is set to 0 the message is a response...  *  *  ...  *   *  NOTE: Notice that when UIH frames are used to convey information on DLCI 0  *  there are at least two different fields that contain a C/R bit, and the   *  bits are set of different form. The C/R bit in the Type field shall be set  *  as it is stated above, while the C/R bit in the Address field (see subclause  *  5.2.1.2) shall be set as it is described in subclause 5.4.3.1."  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_mcc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|u_int8_t
name|cr
decl_stmt|,
name|type
decl_stmt|,
name|length
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * We can access data directly in the first mbuf, because we have 	 * m_pullup()'ed mbuf chain in ng_btsocket_rfcomm_receive_frame(). 	 * All MCC commands should fit into single mbuf (except probably TEST). 	 */
name|hdr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
expr_stmt|;
name|cr
operator|=
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|RFCOMM_MCC_TYPE
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
expr_stmt|;
name|length
operator|=
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* Check MCC frame length */
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
name|length
operator|!=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Invalid MCC frame length=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RFCOMM_MCC_TEST
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_test
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_FCON
case|:
case|case
name|RFCOMM_MCC_FCOFF
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_fc
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_MSC
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_msc
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_RPN
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_rpn
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_RLS
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_rls
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_PN
case|:
return|return
operator|(
name|ng_btsocket_rfcomm_receive_pn
argument_list|(
name|s
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
case|case
name|RFCOMM_MCC_NSC
case|:
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got MCC NSC, type=%#x, cr=%d, length=%d, session state=%d, flags=%#x, "
expr|\
literal|"mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_MCC_TYPE
argument_list|(
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
operator|)
argument_list|)
argument_list|,
name|cr
argument_list|,
name|length
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got unknown MCC, type=%#x, cr=%d, length=%d, session state=%d, "
expr|\
literal|"flags=%#x, mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|cr
argument_list|,
name|length
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* Reuse mbuf to send NSC */
name|hdr
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
comment|/* Create MCC NSC header */
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_NSC
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|RFCOMM_MKLEN8
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Put back MCC command type we did not like */
name|m0
operator|->
name|m_data
index|[
name|m0
operator|->
name|m_len
index|]
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
name|cr
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|++
expr_stmt|;
name|m0
operator|->
name|m_len
operator|++
expr_stmt|;
comment|/* Send UIH frame */
return|return
operator|(
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_mcc */
end_comment

begin_comment
comment|/*  * Receive RFCOMM TEST MCC command  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_test
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC TEST, cr=%d, length=%d, session state=%d, flags=%#x, mtu=%d, "
expr|\
literal|"len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_TEST
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore response */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_test */
end_comment

begin_comment
comment|/*  * Receive RFCOMM FCON/FCOFF MCC command  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_fc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|u_int8_t
name|type
init|=
name|RFCOMM_MCC_TYPE
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Turn ON/OFF aggregate flow on the entire session. When remote peer  	 * asserted flow control no transmission shall occur except on dlci 0 	 * (control channel). 	 */
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC FC%s, cr=%d, length=%d, session state=%d, flags=%#x, mtu=%d, "
expr|\
literal|"len=%d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|type
operator|==
name|RFCOMM_MCC_FCON
operator|)
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|RFCOMM_MCC_FCON
condition|)
name|s
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_SESSION_RFC
expr_stmt|;
else|else
name|s
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_SESSION_RFC
expr_stmt|;
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore response */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_fc  */
end_comment

begin_comment
comment|/*  * Receive RFCOMM MSC MCC command  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_msc
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|rfcomm_mcc_msc
modifier|*
name|msc
init|=
operator|(
expr|struct
name|rfcomm_mcc_msc
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|ng_btsocket_rfcomm_pcb_t
modifier|*
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC MSC, dlci=%d, cr=%d, length=%d, session state=%d, flags=%#x, "
expr|\
literal|"mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|msc
operator|->
name|address
argument_list|)
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|msc
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|==
name|NULL
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got MSC command for non-existing dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|msc
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
operator|&&
name|pcb
operator|->
name|state
operator|!=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTED
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got MSC on dlci=%d in invalid state=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|msc
operator|->
name|address
argument_list|)
argument_list|,
name|pcb
operator|->
name|state
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pcb
operator|->
name|rmodem
operator|=
name|msc
operator|->
name|modem
expr_stmt|;
comment|/* Update remote port signals */
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_MSC
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* YYY */
comment|/* Send more data from DLC. XXX check for errors? */
block|if (!(pcb->rmodem& RFCOMM_MODEM_FC)&& 		    !(pcb->flags& NG_BTSOCKET_RFCOMM_DLC_CFC)) 			ng_btsocket_rfcomm_pcb_send(pcb, ALOT);
endif|#
directive|endif
comment|/* YYY */
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore response */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_msc */
end_comment

begin_comment
comment|/*  * Receive RFCOMM RPN MCC command  * XXX FIXME do we need htole16/le16toh for RPN param_mask?  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_rpn
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|rfcomm_mcc_rpn
modifier|*
name|rpn
init|=
operator|(
expr|struct
name|rfcomm_mcc_rpn
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|param_mask
decl_stmt|;
name|u_int8_t
name|bit_rate
decl_stmt|,
name|data_bits
decl_stmt|,
name|stop_bits
decl_stmt|,
name|parity
decl_stmt|,
name|flow_control
decl_stmt|,
name|xon_char
decl_stmt|,
name|xoff_char
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC RPN, dlci=%d, cr=%d, length=%d, session state=%d, flags=%#x, "
expr|\
literal|"mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|rpn
operator|->
name|dlci
argument_list|)
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
name|param_mask
operator|=
name|RFCOMM_RPN_PM_ALL
expr_stmt|;
if|if
condition|(
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Request - return default setting */
name|bit_rate
operator|=
name|RFCOMM_RPN_BR_115200
expr_stmt|;
name|data_bits
operator|=
name|RFCOMM_RPN_DATA_8
expr_stmt|;
name|stop_bits
operator|=
name|RFCOMM_RPN_STOP_1
expr_stmt|;
name|parity
operator|=
name|RFCOMM_RPN_PARITY_NONE
expr_stmt|;
name|flow_control
operator|=
name|RFCOMM_RPN_FLOW_NONE
expr_stmt|;
name|xon_char
operator|=
name|RFCOMM_RPN_XON_CHAR
expr_stmt|;
name|xoff_char
operator|=
name|RFCOMM_RPN_XOFF_CHAR
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Ignore/accept bit_rate, 8 bits, 1 stop bit, no  			 * parity, no flow control lines, default XON/XOFF  			 * chars. 			 */
name|bit_rate
operator|=
name|rpn
operator|->
name|bit_rate
expr_stmt|;
name|rpn
operator|->
name|param_mask
operator|=
name|le16toh
argument_list|(
name|rpn
operator|->
name|param_mask
argument_list|)
expr_stmt|;
comment|/* XXX */
name|data_bits
operator|=
name|RFCOMM_RPN_DATA_BITS
argument_list|(
name|rpn
operator|->
name|line_settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_DATA
operator|&&
name|data_bits
operator|!=
name|RFCOMM_RPN_DATA_8
condition|)
block|{
name|data_bits
operator|=
name|RFCOMM_RPN_DATA_8
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_DATA
expr_stmt|;
block|}
name|stop_bits
operator|=
name|RFCOMM_RPN_STOP_BITS
argument_list|(
name|rpn
operator|->
name|line_settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_STOP
operator|&&
name|stop_bits
operator|!=
name|RFCOMM_RPN_STOP_1
condition|)
block|{
name|stop_bits
operator|=
name|RFCOMM_RPN_STOP_1
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_STOP
expr_stmt|;
block|}
name|parity
operator|=
name|RFCOMM_RPN_PARITY
argument_list|(
name|rpn
operator|->
name|line_settings
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_PARITY
operator|&&
name|parity
operator|!=
name|RFCOMM_RPN_PARITY_NONE
condition|)
block|{
name|parity
operator|=
name|RFCOMM_RPN_PARITY_NONE
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_PARITY
expr_stmt|;
block|}
name|flow_control
operator|=
name|rpn
operator|->
name|flow_control
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_FLOW
operator|&&
name|flow_control
operator|!=
name|RFCOMM_RPN_FLOW_NONE
condition|)
block|{
name|flow_control
operator|=
name|RFCOMM_RPN_FLOW_NONE
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_FLOW
expr_stmt|;
block|}
name|xon_char
operator|=
name|rpn
operator|->
name|xon_char
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_XON
operator|&&
name|xon_char
operator|!=
name|RFCOMM_RPN_XON_CHAR
condition|)
block|{
name|xon_char
operator|=
name|RFCOMM_RPN_XON_CHAR
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_XON
expr_stmt|;
block|}
name|xoff_char
operator|=
name|rpn
operator|->
name|xoff_char
expr_stmt|;
if|if
condition|(
name|rpn
operator|->
name|param_mask
operator|&
name|RFCOMM_RPN_PM_XOFF
operator|&&
name|xoff_char
operator|!=
name|RFCOMM_RPN_XOFF_CHAR
condition|)
block|{
name|xoff_char
operator|=
name|RFCOMM_RPN_XOFF_CHAR
expr_stmt|;
name|param_mask
operator|^=
name|RFCOMM_RPN_PM_XOFF
expr_stmt|;
block|}
block|}
name|rpn
operator|->
name|bit_rate
operator|=
name|bit_rate
expr_stmt|;
name|rpn
operator|->
name|line_settings
operator|=
name|RFCOMM_MKRPN_LINE_SETTINGS
argument_list|(
name|data_bits
argument_list|,
name|stop_bits
argument_list|,
name|parity
argument_list|)
expr_stmt|;
name|rpn
operator|->
name|flow_control
operator|=
name|flow_control
expr_stmt|;
name|rpn
operator|->
name|xon_char
operator|=
name|xon_char
expr_stmt|;
name|rpn
operator|->
name|xoff_char
operator|=
name|xoff_char
expr_stmt|;
name|rpn
operator|->
name|param_mask
operator|=
name|htole16
argument_list|(
name|param_mask
argument_list|)
expr_stmt|;
comment|/* XXX */
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m0
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rpn
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_RPN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore response */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_rpn */
end_comment

begin_comment
comment|/*  * Receive RFCOMM RLS MCC command  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_rls
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|rfcomm_mcc_rls
modifier|*
name|rls
init|=
operator|(
expr|struct
name|rfcomm_mcc_rls
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * XXX FIXME Do we have to do anything else here? Remote peer tries to  	 * tell us something about DLCI. Just report what we have received and 	 * return back received values as required by TS 07.10 spec. 	 */
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC RLS, dlci=%d, status=%#x, cr=%d, length=%d, session state=%d, "
expr|\
literal|"flags=%#x, mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|rls
operator|->
name|address
argument_list|)
argument_list|,
name|rls
operator|->
name|status
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|rls
operator|->
name|status
operator|&
literal|0x1
condition|)
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Got RLS dlci=%d, error=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|RFCOMM_DLCI
argument_list|(
name|rls
operator|->
name|address
argument_list|)
argument_list|,
name|rls
operator|->
name|status
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_RLS
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore responses */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_rls */
end_comment

begin_comment
comment|/*  * Receive RFCOMM PN MCC command  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_receive_pn
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|rfcomm_mcc_pn
modifier|*
name|pn
init|=
operator|(
expr|struct
name|rfcomm_mcc_pn
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
decl_stmt|;
name|ng_btsocket_rfcomm_pcb_t
modifier|*
name|pcb
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Got MCC PN, dlci=%d, cr=%d, length=%d, flow_control=%#x, priority=%d, "
expr|\
literal|"ack_timer=%d, mtu=%d, max_retrans=%d, credits=%d, session state=%d, "
expr|\
literal|"flags=%#x, session mtu=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pn
operator|->
name|dlci
argument_list|,
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
argument_list|,
name|RFCOMM_MCC_LENGTH
argument_list|(
name|hdr
operator|->
name|length
argument_list|)
argument_list|,
name|pn
operator|->
name|flow_control
argument_list|,
name|pn
operator|->
name|priority
argument_list|,
name|pn
operator|->
name|ack_timer
argument_list|,
name|le16toh
argument_list|(
name|pn
operator|->
name|mtu
argument_list|)
argument_list|,
name|pn
operator|->
name|max_retrans
argument_list|,
name|pn
operator|->
name|credits
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|dlci
operator|==
literal|0
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Zero dlci in MCC PN\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check if we have this dlci */
name|pcb
operator|=
name|ng_btsocket_rfcomm_pcb_by_dlci
argument_list|(
name|s
argument_list|,
name|pn
operator|->
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* PN Request */
name|ng_btsocket_rfcomm_set_pn
argument_list|(
name|pcb
argument_list|,
literal|1
argument_list|,
name|pn
operator|->
name|flow_control
argument_list|,
name|pn
operator|->
name|credits
argument_list|,
name|pn
operator|->
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0xe0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
name|RFCOMM_DEFAULT_CREDITS
expr_stmt|;
block|}
else|else
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_PN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* PN Response - proceed with SABM. Timeout still set */
if|if
condition|(
name|pcb
operator|->
name|state
operator|==
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
condition|)
block|{
name|ng_btsocket_rfcomm_set_pn
argument_list|(
name|pcb
argument_list|,
literal|0
argument_list|,
name|pn
operator|->
name|flow_control
argument_list|,
name|pn
operator|->
name|credits
argument_list|,
name|pn
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_SABM
argument_list|,
name|pn
operator|->
name|dlci
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_BTSOCKET_RFCOMM_WARN
argument_list|(
literal|"%s: Got PN response for dlci=%d in invalid state=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pn
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|RFCOMM_CR
argument_list|(
name|hdr
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* PN request to non-existing dlci - incoming connection */
name|pcb
operator|=
name|ng_btsocket_rfcomm_connect_ind
argument_list|(
name|s
argument_list|,
name|RFCOMM_SRVCHANNEL
argument_list|(
name|pn
operator|->
name|dlci
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|dlci
operator|=
name|pn
operator|->
name|dlci
expr_stmt|;
name|ng_btsocket_rfcomm_set_pn
argument_list|(
name|pcb
argument_list|,
literal|1
argument_list|,
name|pn
operator|->
name|flow_control
argument_list|,
name|pn
operator|->
name|credits
argument_list|,
name|pn
operator|->
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0xe0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
name|RFCOMM_DEFAULT_CREDITS
expr_stmt|;
block|}
else|else
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|0
argument_list|,
name|RFCOMM_MCC_PN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|s
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ng_btsocket_rfcomm_timeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
expr_stmt|;
name|soisconnecting
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
else|else
name|ng_btsocket_rfcomm_pcb_kill
argument_list|(
name|pcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Nobody is listen()ing on this channel */
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DM
argument_list|,
name|pn
operator|->
name|dlci
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|NG_FREE_M
argument_list|(
name|m0
argument_list|)
expr_stmt|;
comment|/* XXX ignore response to non-existing dlci */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_receive_pn */
end_comment

begin_comment
comment|/*  * Set PN parameters for dlci. Caller must hold pcb->pcb_mtx.  *   * From Bluetooth spec.  *   * "... The CL1 - CL4 field is completely redefined. (In TS07.10 this defines   *  the convergence layer to use, which is not applicable to RFCOMM. In RFCOMM,  *  in Bluetooth versions up to 1.0B, this field was forced to 0).  *  *  In the PN request sent prior to a DLC establishment, this field must contain  *  the value 15 (0xF), indicating support of credit based flow control in the   *  sender. See Table 5.3 below. If the PN response contains any other value   *  than 14 (0xE) in this field, it is inferred that the peer RFCOMM entity is   *  not supporting the credit based flow control feature. (This is only possible  *  if the peer RFCOMM implementation is only conforming to Bluetooth version   *  1.0B.) If a PN request is sent on an already open DLC, then this field must  *  contain the value zero; it is not possible to set initial credits  more   *  than once per DLC activation. A responding implementation must set this   *  field in the PN response to 14 (0xE), if (and only if) the value in the PN   *  request was 15..."  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_set_pn
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|u_int8_t
name|cr
parameter_list|,
name|u_int8_t
name|flow_control
parameter_list|,
name|u_int8_t
name|credits
parameter_list|,
name|u_int16_t
name|mtu
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|mtu
operator|=
name|le16toh
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|cr
condition|)
block|{
if|if
condition|(
name|flow_control
operator|==
literal|0xf0
condition|)
block|{
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_CFC
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|=
name|credits
expr_stmt|;
block|}
else|else
block|{
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_CFC
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flow_control
operator|==
literal|0xe0
condition|)
block|{
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_CFC
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|=
name|credits
expr_stmt|;
block|}
else|else
block|{
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_CFC
expr_stmt|;
name|pcb
operator|->
name|tx_cred
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: cr=%d, dlci=%d, state=%d, flags=%#x, mtu=%d, rx_cred=%d, tx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|cr
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|mtu
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_set_pn */
end_comment

begin_comment
comment|/*  * Send RFCOMM SABM/DISC/UA/DM frames. Caller must hold s->session_mtx  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_send_command
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|u_int8_t
name|type
parameter_list|,
name|u_int8_t
name|dlci
parameter_list|)
block|{
name|struct
name|rfcomm_cmd_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|cr
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Sending command type %#x, session state=%d, flags=%#x, mtu=%d, dlci=%d\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|RFCOMM_FRAME_SABM
case|:
case|case
name|RFCOMM_FRAME_DISC
case|:
name|cr
operator|=
name|INITIATOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|RFCOMM_FRAME_UA
case|:
case|case
name|RFCOMM_FRAME_DM
case|:
name|cr
operator|=
operator|!
name|INITIATOR
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: Invalid frame type=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* NOT REACHED */
block|}
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rfcomm_cmd_hdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|address
operator|=
name|RFCOMM_MKADDRESS
argument_list|(
name|cr
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|control
operator|=
name|RFCOMM_MKCONTROL
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|RFCOMM_MKLEN8
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|fcs
operator|=
name|ng_btsocket_rfcomm_fcs3
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|NG_BT_MBUFQ_ENQUEUE
argument_list|(
operator|&
name|s
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send_command */
end_comment

begin_comment
comment|/*  * Send RFCOMM UIH frame. Caller must hold s->session_mtx  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_send_uih
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|u_int8_t
name|address
parameter_list|,
name|u_int8_t
name|pf
parameter_list|,
name|u_int8_t
name|credits
parameter_list|,
name|struct
name|mbuf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|rfcomm_frame_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|mcrc
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|length
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|mcrc
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcrc
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|mcrc
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
comment|/* Fill UIH frame header */
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rfcomm_frame_hdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|hdr
operator|->
name|control
operator|=
name|RFCOMM_MKCONTROL
argument_list|(
name|RFCOMM_FRAME_UIH
argument_list|,
name|pf
argument_list|)
expr_stmt|;
comment|/* Calculate FCS */
name|mcrc
operator|->
name|m_data
index|[
literal|0
index|]
operator|=
name|ng_btsocket_rfcomm_fcs2
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
name|hdr
argument_list|)
expr_stmt|;
comment|/* Put length back */
name|length
operator|=
operator|(
name|data
operator|!=
name|NULL
operator|)
condition|?
name|data
operator|->
name|m_pkthdr
operator|.
name|len
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|127
condition|)
block|{
name|u_int16_t
name|l
init|=
name|htole16
argument_list|(
name|RFCOMM_MKLEN16
argument_list|(
name|length
argument_list|)
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|l
argument_list|,
operator|&
name|hdr
operator|->
name|length
argument_list|,
sizeof|sizeof
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
else|else
name|hdr
operator|->
name|length
operator|=
name|RFCOMM_MKLEN8
argument_list|(
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
condition|)
block|{
name|m
operator|->
name|m_data
index|[
name|m
operator|->
name|m_len
index|]
operator|=
name|credits
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|++
expr_stmt|;
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
comment|/* Add payload */
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|m_cat
argument_list|(
name|m
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|length
expr_stmt|;
block|}
comment|/* Put FCS back */
name|m_cat
argument_list|(
name|m
argument_list|,
name|mcrc
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|++
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Sending UIH state=%d, flags=%#x, address=%d, length=%d, pf=%d, "
expr|\
literal|"credits=%d, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|address
argument_list|,
name|length
argument_list|,
name|pf
argument_list|,
name|credits
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|NG_BT_MBUFQ_ENQUEUE
argument_list|(
operator|&
name|s
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send_uih */
end_comment

begin_comment
comment|/*  * Send MSC request. Caller must hold pcb->pcb_mtx and pcb->session->session_mtx  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_send_msc
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|rfcomm_mcc_msc
modifier|*
name|msc
init|=
name|NULL
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|session
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msc
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
expr_stmt|;
name|msc
operator|=
operator|(
expr|struct
name|rfcomm_mcc_msc
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|1
argument_list|,
name|RFCOMM_MCC_MSC
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|RFCOMM_MKLEN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|msc
argument_list|)
argument_list|)
expr_stmt|;
name|msc
operator|->
name|address
operator|=
name|RFCOMM_MKADDRESS
argument_list|(
literal|1
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|)
expr_stmt|;
name|msc
operator|->
name|modem
operator|=
name|pcb
operator|->
name|lmodem
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Sending MSC dlci=%d, state=%d, flags=%#x, address=%d, modem=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|msc
operator|->
name|address
argument_list|,
name|msc
operator|->
name|modem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|pcb
operator|->
name|session
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|pcb
operator|->
name|session
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send_msc */
end_comment

begin_comment
comment|/*  * Send PN request. Caller must hold pcb->pcb_mtx and pcb->session->session_mtx  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_send_pn
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|rfcomm_mcc_hdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|struct
name|rfcomm_mcc_pn
modifier|*
name|pn
init|=
name|NULL
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|session
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|pn
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rfcomm_mcc_hdr
operator|*
argument_list|)
expr_stmt|;
name|pn
operator|=
operator|(
expr|struct
name|rfcomm_mcc_pn
operator|*
operator|)
operator|(
name|hdr
operator|+
literal|1
operator|)
expr_stmt|;
name|hdr
operator|->
name|type
operator|=
name|RFCOMM_MKMCC_TYPE
argument_list|(
literal|1
argument_list|,
name|RFCOMM_MCC_PN
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|length
operator|=
name|RFCOMM_MKLEN8
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pn
argument_list|)
argument_list|)
expr_stmt|;
name|pn
operator|->
name|dlci
operator|=
name|pcb
operator|->
name|dlci
expr_stmt|;
comment|/* 	 * Set default DLCI priority as described in GSM 07.10 	 * (ETSI TS 101 369) clause 5.6 page 42 	 */
name|pn
operator|->
name|priority
operator|=
operator|(
name|pcb
operator|->
name|dlci
operator|<
literal|56
operator|)
condition|?
operator|(
operator|(
operator|(
name|pcb
operator|->
name|dlci
operator|>>
literal|3
operator|)
operator|<<
literal|3
operator|)
operator|+
literal|7
operator|)
else|:
literal|61
expr_stmt|;
name|pn
operator|->
name|ack_timer
operator|=
literal|0
expr_stmt|;
name|pn
operator|->
name|mtu
operator|=
name|htole16
argument_list|(
name|pcb
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|pn
operator|->
name|max_retrans
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0xf0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
name|pcb
operator|->
name|rx_cred
expr_stmt|;
block|}
else|else
block|{
name|pn
operator|->
name|flow_control
operator|=
literal|0
expr_stmt|;
name|pn
operator|->
name|credits
operator|=
literal|0
expr_stmt|;
block|}
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Sending PN dlci=%d, state=%d, flags=%#x, mtu=%d, flow_control=%#x, "
expr|\
literal|"credits=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|mtu
argument_list|,
name|pn
operator|->
name|flow_control
argument_list|,
name|pn
operator|->
name|credits
argument_list|)
expr_stmt|;
return|return
operator|(
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|pcb
operator|->
name|session
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|pcb
operator|->
name|session
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send_pn */
end_comment

begin_comment
comment|/*  * Calculate and send credits based on available space in receive buffer  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_send_credits
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|credits
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|session
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Sending more credits, dlci=%d, state=%d, flags=%#x, mtu=%d, "
expr|\
literal|"space=%ld, tx_cred=%d, rx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|mtu
argument_list|,
name|sbspace
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|)
expr_stmt|;
name|credits
operator|=
name|sbspace
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|)
operator|/
name|pcb
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|credits
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pcb
operator|->
name|rx_cred
operator|+
name|credits
operator|>
name|RFCOMM_MAX_CREDITS
condition|)
name|credits
operator|=
name|RFCOMM_MAX_CREDITS
operator|-
name|pcb
operator|->
name|rx_cred
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|pcb
operator|->
name|session
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|pcb
operator|->
name|session
argument_list|)
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|)
argument_list|,
literal|1
argument_list|,
name|credits
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pcb
operator|->
name|rx_cred
operator|+=
name|credits
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Gave remote side %d more credits, dlci=%d, state=%d, flags=%#x, "
expr|\
literal|"rx_cred=%d, tx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|credits
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
block|}
else|else
name|NG_BTSOCKET_RFCOMM_ERR
argument_list|(
literal|"%s: Could not send credits, error=%d, dlci=%d, state=%d, flags=%#x, "
expr|\
literal|"mtu=%d, space=%ld, tx_cred=%d, rx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|mtu
argument_list|,
name|sbspace
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|,
name|pcb
operator|->
name|rx_cred
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_send_credits */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                              RFCOMM DLCs  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Send data from socket send buffer  * Caller must hold pcb->pcb_mtx and pcb->session->session_mtx  */
end_comment

begin_function
specifier|static
name|int
name|ng_btsocket_rfcomm_pcb_send
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|sent
decl_stmt|,
name|length
decl_stmt|,
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|session
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
name|limit
operator|=
name|min
argument_list|(
name|limit
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|pcb
operator|->
name|rmodem
operator|&
name|RFCOMM_MODEM_FC
operator|)
condition|)
name|limit
operator|=
name|min
argument_list|(
name|limit
argument_list|,
name|RFCOMM_MAX_CREDITS
argument_list|)
expr_stmt|;
comment|/* XXX ??? */
else|else
name|limit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|limit
operator|==
literal|0
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Could not send - remote flow control asserted, dlci=%d, flags=%#x, "
expr|\
literal|"rmodem=%#x, tx_cred=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|pcb
operator|->
name|rmodem
argument_list|,
name|pcb
operator|->
name|tx_cred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|error
operator|=
literal|0
operator|,
name|sent
operator|=
literal|0
init|;
name|sent
operator|<
name|limit
condition|;
name|sent
operator|++
control|)
block|{
name|length
operator|=
name|min
argument_list|(
name|pcb
operator|->
name|mtu
argument_list|,
name|sbavail
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_snd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
break|break;
comment|/* Get the chunk from the socket's send buffer */
name|m
operator|=
name|ng_btsocket_rfcomm_prepare_packet
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_snd
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
block|}
name|sbdrop
argument_list|(
operator|&
name|pcb
operator|->
name|so
operator|->
name|so_snd
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_btsocket_rfcomm_send_uih
argument_list|(
name|pcb
operator|->
name|session
argument_list|,
name|RFCOMM_MKADDRESS
argument_list|(
name|INITIATOR
argument_list|(
name|pcb
operator|->
name|session
argument_list|)
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_CFC
condition|)
name|pcb
operator|->
name|tx_cred
operator|-=
name|sent
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|sent
operator|>
literal|0
condition|)
block|{
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_SENDING
expr_stmt|;
name|sowwakeup
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_pcb_send */
end_comment

begin_comment
comment|/*  * Unlink and disconnect DLC. If ng_btsocket_rfcomm_pcb_kill() returns  * non zero value than socket has no reference and has to be detached.  * Caller must hold pcb->pcb_mtx and pcb->session->session_mtx  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_pcb_kill
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|ng_btsocket_rfcomm_session_p
name|s
init|=
name|pcb
operator|->
name|session
decl_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Killing DLC, so=%p, dlci=%d, state=%d, flags=%#x, error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|so
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|session
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: DLC without session, pcb=%p, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|session
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
condition|)
name|ng_btsocket_rfcomm_untimeout
argument_list|(
name|pcb
argument_list|)
expr_stmt|;
comment|/* Detach DLC from the session. Does not matter which state DLC in */
name|LIST_REMOVE
argument_list|(
name|pcb
argument_list|,
name|session_next
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|session
operator|=
name|NULL
expr_stmt|;
comment|/* Change DLC state and wakeup all sleepers */
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_CLOSED
expr_stmt|;
name|pcb
operator|->
name|so
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
name|soisdisconnected
argument_list|(
name|pcb
operator|->
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|pcb
operator|->
name|state
argument_list|)
expr_stmt|;
comment|/* Check if we have any DLCs left on the session */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|s
operator|->
name|dlcs
argument_list|)
operator|&&
name|INITIATOR
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Disconnecting session, state=%d, flags=%#x, mtu=%d\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|,
name|s
operator|->
name|mtu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|s
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
case|:
comment|/* 			 * Do not have to do anything here. We can get here 			 * when L2CAP connection was terminated or we have  			 * received DISC on multiplexor channel 			 */
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_OPEN
case|:
comment|/* Send DISC on multiplexor channel */
name|error
operator|=
name|ng_btsocket_rfcomm_send_command
argument_list|(
name|s
argument_list|,
name|RFCOMM_FRAME_DISC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_DISCONNECTING
expr_stmt|;
break|break;
block|}
comment|/* FALL THROUGH */
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_SESSION_CONNECTED
case|:
name|s
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_SESSION_CLOSED
expr_stmt|;
break|break;
comment|/*		case NG_BTSOCKET_RFCOMM_SESSION_LISTENING: */
default|default:
name|panic
argument_list|(
literal|"%s: Invalid session state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|s
operator|->
name|state
argument_list|,
name|s
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_pcb_kill */
end_comment

begin_comment
comment|/*  * Look for given dlci for given RFCOMM session. Caller must hold s->session_mtx  */
end_comment

begin_function
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_pcb_by_dlci
parameter_list|(
name|ng_btsocket_rfcomm_session_p
name|s
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|s
operator|->
name|session_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pcb
argument_list|,
argument|&s->dlcs
argument_list|,
argument|session_next
argument_list|)
if|if
condition|(
name|pcb
operator|->
name|dlci
operator|==
name|dlci
condition|)
break|break;
return|return
operator|(
name|pcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_pcb_by_dlci */
end_comment

begin_comment
comment|/*  * Look for socket that listens on given src address and given channel  */
end_comment

begin_function
specifier|static
name|ng_btsocket_rfcomm_pcb_p
name|ng_btsocket_rfcomm_pcb_listener
parameter_list|(
name|bdaddr_p
name|src
parameter_list|,
name|int
name|channel
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
name|NULL
decl_stmt|,
name|pcb1
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pcb
argument_list|,
argument|&ng_btsocket_rfcomm_sockets
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|pcb
operator|->
name|channel
operator|!=
name|channel
operator|||
operator|!
operator|(
name|pcb
operator|->
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|pcb
operator|->
name|src
argument_list|,
name|src
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|src
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|pcb
operator|->
name|src
argument_list|,
name|NG_HCI_BDADDR_ANY
argument_list|,
sizeof|sizeof
argument_list|(
name|bdaddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|pcb1
operator|=
name|pcb
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_btsocket_rfcomm_sockets_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pcb
operator|!=
name|NULL
operator|)
condition|?
name|pcb
else|:
name|pcb1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_pcb_listener */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                              Misc. functions   *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  *  Set timeout. Caller MUST hold pcb_mtx  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_timeout
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
operator|)
condition|)
block|{
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
expr_stmt|;
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pcb
operator|->
name|timo
argument_list|,
name|ng_btsocket_rfcomm_timo
operator|*
name|hz
argument_list|,
name|ng_btsocket_rfcomm_process_timeout
argument_list|,
name|pcb
argument_list|)
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"%s: Duplicated socket timeout?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_timeout */
end_comment

begin_comment
comment|/*  *  Unset pcb timeout. Caller MUST hold pcb_mtx  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_untimeout
parameter_list|(
name|ng_btsocket_rfcomm_pcb_p
name|pcb
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcb
operator|->
name|flags
operator|&
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|pcb
operator|->
name|timo
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
expr_stmt|;
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
expr_stmt|;
block|}
else|else
name|panic
argument_list|(
literal|"%s: No socket timeout?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_timeout */
end_comment

begin_comment
comment|/*  * Process pcb timeout  */
end_comment

begin_function
specifier|static
name|void
name|ng_btsocket_rfcomm_process_timeout
parameter_list|(
name|void
modifier|*
name|xpcb
parameter_list|)
block|{
name|ng_btsocket_rfcomm_pcb_p
name|pcb
init|=
operator|(
name|ng_btsocket_rfcomm_pcb_p
operator|)
name|xpcb
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|pcb
operator|->
name|pcb_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NG_BTSOCKET_RFCOMM_INFO
argument_list|(
literal|"%s: Timeout, so=%p, dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|so
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
name|pcb
operator|->
name|flags
operator|&=
operator|~
name|NG_BTSOCKET_RFCOMM_DLC_TIMO
expr_stmt|;
name|pcb
operator|->
name|flags
operator||=
name|NG_BTSOCKET_RFCOMM_DLC_TIMEDOUT
expr_stmt|;
switch|switch
condition|(
name|pcb
operator|->
name|state
condition|)
block|{
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONFIGURING
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_CONNECTING
case|:
name|pcb
operator|->
name|state
operator|=
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
expr_stmt|;
break|break;
case|case
name|NG_BTSOCKET_RFCOMM_DLC_W4_CONNECT
case|:
case|case
name|NG_BTSOCKET_RFCOMM_DLC_DISCONNECTING
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: DLC timeout in invalid state, dlci=%d, state=%d, flags=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|pcb
operator|->
name|dlci
argument_list|,
name|pcb
operator|->
name|state
argument_list|,
name|pcb
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|ng_btsocket_rfcomm_task_wakeup
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_process_timeout */
end_comment

begin_comment
comment|/*  * Get up to length bytes from the socket buffer  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_btsocket_rfcomm_prepare_packet
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|top
init|=
name|NULL
decl_stmt|,
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|n
init|=
name|NULL
decl_stmt|,
modifier|*
name|nextpkt
init|=
name|NULL
decl_stmt|;
name|int
name|mlen
decl_stmt|,
name|noff
decl_stmt|,
name|len
decl_stmt|;
name|MGETHDR
argument_list|(
name|top
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
expr_stmt|;
name|top
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mlen
operator|=
name|MHLEN
expr_stmt|;
name|m
operator|=
name|top
expr_stmt|;
name|n
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
name|nextpkt
operator|=
name|n
operator|->
name|m_nextpkt
expr_stmt|;
name|noff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
name|n
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|mlen
operator|-
name|m
operator|->
name|m_len
argument_list|,
name|n
operator|->
name|m_len
operator|-
name|noff
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|length
condition|)
name|len
operator|=
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|noff
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|len
expr_stmt|;
name|noff
operator|+=
name|len
expr_stmt|;
name|length
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|m
operator|->
name|m_len
operator|==
name|mlen
condition|)
block|{
name|MGET
argument_list|(
name|m
operator|->
name|m_next
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mlen
operator|=
name|MLEN
expr_stmt|;
block|}
if|if
condition|(
name|noff
operator|==
name|n
operator|->
name|m_len
condition|)
block|{
name|noff
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|n
operator|=
name|nextpkt
expr_stmt|;
name|nextpkt
operator|=
operator|(
name|n
operator|!=
name|NULL
operator|)
condition|?
name|n
operator|->
name|m_nextpkt
else|:
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: length=%d\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|n
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: bogus length=%d, n=%p\n"
argument_list|,
name|__func__
argument_list|,
name|length
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_btsocket_rfcomm_prepare_packet */
end_comment

end_unit

