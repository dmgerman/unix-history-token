begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_l2cap_main.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) Maksim Yevmenkin<m_evmenkin@yahoo.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: ng_l2cap_main.c,v 1.2 2003/04/28 21:44:59 max Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_bluetooth.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_hci.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_l2cap.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_var.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_cmds.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_evnt.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_llpi.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_ulpi.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_misc.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/l2cap/ng_l2cap_prse.h>
end_include

begin_comment
comment|/******************************************************************************  ******************************************************************************  **  This node implements Link Layer Control and Adaptation Protocol (L2CAP)  ******************************************************************************  ******************************************************************************/
end_comment

begin_comment
comment|/* MALLOC define */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_L2CAP
argument_list|,
literal|"netgraph_l2cap"
argument_list|,
literal|"Netgraph Bluetooth L2CAP node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_L2CAP
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NG_SEPARATE_MALLOC */
end_comment

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_l2cap_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_l2cap_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_l2cap_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_l2cap_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_l2cap_disconnect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_l2cap_lower_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_l2cap_upper_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_l2cap_default_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_l2cap_rcvdata
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_L2CAP_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_l2cap_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_l2cap_default_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_l2cap_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_l2cap_newhook
block|,
operator|.
name|connect
operator|=
name|ng_l2cap_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_l2cap_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_l2cap_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_l2cap_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|l2cap
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ng_l2cap
argument_list|,
name|NG_BLUETOOTH_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ng_l2cap
argument_list|,
name|ng_bluetooth
argument_list|,
name|NG_BLUETOOTH_VERSION
argument_list|,
name|NG_BLUETOOTH_VERSION
argument_list|,
name|NG_BLUETOOTH_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **                   Netgraph methods implementation  *****************************************************************************  *****************************************************************************/
end_comment

begin_function_decl
specifier|static
name|void
name|ng_l2cap_cleanup
parameter_list|(
name|ng_l2cap_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2cap_destroy_channels
parameter_list|(
name|ng_l2cap_p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Create new instance of L2CAP node  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
name|NULL
decl_stmt|;
comment|/* Create new L2CAP node */
name|MALLOC
argument_list|(
name|l2cap
argument_list|,
name|ng_l2cap_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2cap
argument_list|)
argument_list|,
name|M_NETGRAPH_L2CAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2cap
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|l2cap
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|l2cap
operator|->
name|debug
operator|=
name|NG_L2CAP_WARN_LEVEL
expr_stmt|;
name|l2cap
operator|->
name|discon_timo
operator|=
literal|5
expr_stmt|;
comment|/* sec */
name|LIST_INIT
argument_list|(
operator|&
name|l2cap
operator|->
name|con_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|l2cap
operator|->
name|chan_list
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|l2cap
argument_list|)
expr_stmt|;
name|NG_NODE_FORCE_WRITER
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_constructor */
end_comment

begin_comment
comment|/*  * Shutdown L2CAP node  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Clean up L2CAP node. Delete all connection, channels and commands */
name|l2cap
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|ng_l2cap_cleanup
argument_list|(
name|l2cap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|l2cap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|l2cap
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|l2cap
argument_list|,
name|M_NETGRAPH_L2CAP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_shutdown */
end_comment

begin_comment
comment|/*  * Give our OK for a hook to be added. HCI layer is connected to the HCI   * (NG_L2CAP_HOOK_HCI) hook. As per specification L2CAP layer MUST provide  * Procol/Service Multiplexing, so the L2CAP node provides separate hooks   * for SDP (NG_L2CAP_HOOK_SDP), RFCOMM (NG_L2CAP_HOOK_RFCOMM) and TCP   * (NG_L2CAP_HOOK_TCP) protcols. Unknown PSM will be forwarded to   * NG_L2CAP_HOOK_ORPHAN hook. Control node/application is connected to   * control (NG_L2CAP_HOOK_CTL) hook.   */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|char
specifier|const
modifier|*
name|name
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_L2CAP_HOOK_HCI
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|=
operator|&
name|l2cap
operator|->
name|hci
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_L2CAP_HOOK_L2C
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|=
operator|&
name|l2cap
operator|->
name|l2c
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_L2CAP_HOOK_CTL
argument_list|)
operator|==
literal|0
condition|)
name|h
operator|=
operator|&
name|l2cap
operator|->
name|ctl
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|h
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
operator|*
name|h
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_newhook */
end_comment

begin_comment
comment|/*  * Give our final OK to connect hook. Nothing to do here.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|hci
condition|)
name|NG_HOOK_SET_RCVMSG
argument_list|(
name|hook
argument_list|,
name|ng_l2cap_lower_rcvmsg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|l2c
operator|||
name|hook
operator|==
name|l2cap
operator|->
name|ctl
condition|)
block|{
name|NG_HOOK_SET_RCVMSG
argument_list|(
name|hook
argument_list|,
name|ng_l2cap_upper_rcvmsg
argument_list|)
expr_stmt|;
comment|/* Send delayed notification to the upper layer */
name|error
operator|=
name|ng_send_fn
argument_list|(
name|l2cap
operator|->
name|node
argument_list|,
name|hook
argument_list|,
name|ng_l2cap_send_hook_info
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_connect */
end_comment

begin_comment
comment|/*  * Disconnect the hook. For downstream hook we must notify upper layers.  *   * XXX For upstream hooks this is really ugly :( Hook was disconnected and it   * XXX is now too late to do anything. For now we just clean up our own mess  * XXX and remove all channels that use disconnected upstream hook. If we don't   * XXX do that then L2CAP node can get out of sync with upper layers.  * XXX No notification will be sent to remote peer.   */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|hook_p
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|hci
condition|)
block|{
name|ng_l2cap_cleanup
argument_list|(
name|l2cap
argument_list|)
expr_stmt|;
name|h
operator|=
operator|&
name|l2cap
operator|->
name|hci
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|l2c
condition|)
block|{
name|ng_l2cap_destroy_channels
argument_list|(
name|l2cap
argument_list|)
expr_stmt|;
name|h
operator|=
operator|&
name|l2cap
operator|->
name|l2c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|ctl
condition|)
name|h
operator|=
operator|&
name|l2cap
operator|->
name|ctl
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|h
operator|=
name|NULL
expr_stmt|;
comment|/* Shutdown when all hooks are disconnected */
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|NG_NODE_IS_VALID
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
condition|)
name|ng_rmnode_self
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_disconnect */
end_comment

begin_comment
comment|/*  * Process control message from lower layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_lower_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NGI_MSG
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|/* item still has message */
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_HCI_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
comment|/* HCI node is ready */
case|case
name|NGM_HCI_NODE_UP
case|:
block|{
name|ng_hci_node_up_ep
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
block|{
name|ep
operator|=
operator|(
name|ng_hci_node_up_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
expr_stmt|;
name|NG_L2CAP_INFO
argument_list|(
literal|"%s: %s - HCI node is up, bdaddr: %x:%x:%x:%x:%x:%x, "
expr|\
literal|"pkt_size=%d bytes, num_pkts=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|l2cap
operator|->
name|node
argument_list|)
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|5
index|]
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|4
index|]
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|3
index|]
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|2
index|]
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|1
index|]
argument_list|,
name|ep
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|ep
operator|->
name|pkt_size
argument_list|,
name|ep
operator|->
name|num_pkts
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ep
operator|->
name|bdaddr
argument_list|,
operator|&
name|l2cap
operator|->
name|bdaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|l2cap
operator|->
name|bdaddr
argument_list|)
argument_list|)
expr_stmt|;
name|l2cap
operator|->
name|pkt_size
operator|=
name|ep
operator|->
name|pkt_size
expr_stmt|;
name|l2cap
operator|->
name|num_pkts
operator|=
name|ep
operator|->
name|num_pkts
expr_stmt|;
comment|/* Notify upper layers */
name|ng_l2cap_send_hook_info
argument_list|(
name|l2cap
operator|->
name|node
argument_list|,
name|l2cap
operator|->
name|l2c
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ng_l2cap_send_hook_info
argument_list|(
name|l2cap
operator|->
name|node
argument_list|,
name|l2cap
operator|->
name|ctl
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|NGM_HCI_SYNC_CON_QUEUE
case|:
block|{
name|ng_hci_sync_con_queue_ep
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|ng_l2cap_con_p
name|con
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
block|{
name|ep
operator|=
operator|(
name|ng_hci_sync_con_queue_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
expr_stmt|;
name|con
operator|=
name|ng_l2cap_con_by_handle
argument_list|(
name|l2cap
argument_list|,
name|ep
operator|->
name|con_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|==
name|NULL
condition|)
break|break;
name|NG_L2CAP_INFO
argument_list|(
literal|"%s: %s - sync HCI connection queue, con_handle=%d, pending=%d, completed=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|l2cap
operator|->
name|node
argument_list|)
argument_list|,
name|ep
operator|->
name|con_handle
argument_list|,
name|con
operator|->
name|pending
argument_list|,
name|ep
operator|->
name|completed
argument_list|)
expr_stmt|;
name|con
operator|->
name|pending
operator|-=
name|ep
operator|->
name|completed
expr_stmt|;
if|if
condition|(
name|con
operator|->
name|pending
operator|<
literal|0
condition|)
block|{
name|NG_L2CAP_WARN
argument_list|(
literal|"%s: %s - pending packet counter is out of sync! "
expr|\
literal|"con_handle=%d, pending=%d, completed=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|l2cap
operator|->
name|node
argument_list|)
argument_list|,
name|con
operator|->
name|con_handle
argument_list|,
name|con
operator|->
name|pending
argument_list|,
name|ep
operator|->
name|completed
argument_list|)
expr_stmt|;
name|con
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
block|}
name|ng_l2cap_lp_deliver
argument_list|(
name|con
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* LP_ConnectCfm[Neg] */
case|case
name|NGM_HCI_LP_CON_CFM
case|:
name|error
operator|=
name|ng_l2cap_lp_con_cfm
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* LP_ConnectInd */
case|case
name|NGM_HCI_LP_CON_IND
case|:
name|error
operator|=
name|ng_l2cap_lp_con_ind
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* LP_DisconnectInd */
case|case
name|NGM_HCI_LP_DISCON_IND
case|:
name|error
operator|=
name|ng_l2cap_lp_discon_ind
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* LP_QoSSetupCfm[Neg] */
case|case
name|NGM_HCI_LP_QOS_CFM
case|:
name|error
operator|=
name|ng_l2cap_lp_qos_cfm
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* LP_OoSViolationInd */
case|case
name|NGM_HCI_LP_QOS_IND
case|:
name|error
operator|=
name|ng_l2cap_lp_qos_ind
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
operator|(
name|ng_l2cap_default_rcvmsg
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
block|}
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_lower_rcvmsg */
end_comment

begin_comment
comment|/*  * Process control message from upper layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_upper_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NGI_MSG
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|/* item still has message */
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_L2CAP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
comment|/* L2CA_Connect */
case|case
name|NGM_L2CAP_L2CA_CON
case|:
name|error
operator|=
name|ng_l2cap_l2ca_con_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_ConnectRsp */
case|case
name|NGM_L2CAP_L2CA_CON_RSP
case|:
name|error
operator|=
name|ng_l2cap_l2ca_con_rsp_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_Config */
case|case
name|NGM_L2CAP_L2CA_CFG
case|:
name|error
operator|=
name|ng_l2cap_l2ca_cfg_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_ConfigRsp */
case|case
name|NGM_L2CAP_L2CA_CFG_RSP
case|:
name|error
operator|=
name|ng_l2cap_l2ca_cfg_rsp_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_Disconnect */
case|case
name|NGM_L2CAP_L2CA_DISCON
case|:
name|error
operator|=
name|ng_l2cap_l2ca_discon_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GroupCreate */
case|case
name|NGM_L2CAP_L2CA_GRP_CREATE
case|:
name|error
operator|=
name|ng_l2cap_l2ca_grp_create
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GroupClose */
case|case
name|NGM_L2CAP_L2CA_GRP_CLOSE
case|:
name|error
operator|=
name|ng_l2cap_l2ca_grp_close
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GroupAddMember */
case|case
name|NGM_L2CAP_L2CA_GRP_ADD_MEMBER
case|:
name|error
operator|=
name|ng_l2cap_l2ca_grp_add_member_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GroupDeleteMember */
case|case
name|NGM_L2CAP_L2CA_GRP_REM_MEMBER
case|:
name|error
operator|=
name|ng_l2cap_l2ca_grp_rem_member
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GroupMembership */
case|case
name|NGM_L2CAP_L2CA_GRP_MEMBERSHIP
case|:
name|error
operator|=
name|ng_l2cap_l2ca_grp_get_members
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_Ping */
case|case
name|NGM_L2CAP_L2CA_PING
case|:
name|error
operator|=
name|ng_l2cap_l2ca_ping_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_GetInfo */
case|case
name|NGM_L2CAP_L2CA_GET_INFO
case|:
name|error
operator|=
name|ng_l2cap_l2ca_get_info_req
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
comment|/* L2CA_EnableCLT */
case|case
name|NGM_L2CAP_L2CA_ENABLE_CLT
case|:
name|error
operator|=
name|ng_l2cap_l2ca_enable_clt
argument_list|(
name|l2cap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ng_l2cap_default_rcvmsg
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
block|}
break|break;
default|default:
return|return
operator|(
name|ng_l2cap_default_rcvmsg
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
operator|)
return|;
comment|/* NOT REACHED */
block|}
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_upper_rcvmsg */
end_comment

begin_comment
comment|/*  * Default control message processing routine  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_default_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|rsp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Detach and process message */
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|rsp
operator|->
name|data
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
literal|"bdaddr %x:%x:%x:%x:%x:%x, "
expr|\
literal|"pkt_size %d\n"
expr|\
literal|"Hooks %s %s %s\n"
expr|\
literal|"Flags %#x\n"
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|5
index|]
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|4
index|]
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|3
index|]
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|2
index|]
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|1
index|]
argument_list|,
name|l2cap
operator|->
name|bdaddr
operator|.
name|b
index|[
literal|0
index|]
argument_list|,
name|l2cap
operator|->
name|pkt_size
argument_list|,
operator|(
name|l2cap
operator|->
name|hci
operator|!=
name|NULL
operator|)
condition|?
name|NG_L2CAP_HOOK_HCI
else|:
literal|""
argument_list|,
operator|(
name|l2cap
operator|->
name|l2c
operator|!=
name|NULL
operator|)
condition|?
name|NG_L2CAP_HOOK_L2C
else|:
literal|""
argument_list|,
operator|(
name|l2cap
operator|->
name|ctl
operator|!=
name|NULL
operator|)
condition|?
name|NG_L2CAP_HOOK_CTL
else|:
literal|""
argument_list|,
name|l2cap
operator|->
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
comment|/* Messages from the upper layer or directed to the local node */
case|case
name|NGM_L2CAP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
comment|/* Get node flags */
case|case
name|NGM_L2CAP_NODE_GET_FLAGS
case|:
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_flags_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_l2cap_node_flags_ep
operator|*
operator|)
operator|(
name|rsp
operator|->
name|data
operator|)
operator|)
operator|=
name|l2cap
operator|->
name|flags
expr_stmt|;
break|break;
comment|/* Get node debug */
case|case
name|NGM_L2CAP_NODE_GET_DEBUG
case|:
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_debug_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_l2cap_node_debug_ep
operator|*
operator|)
operator|(
name|rsp
operator|->
name|data
operator|)
operator|)
operator|=
name|l2cap
operator|->
name|debug
expr_stmt|;
break|break;
comment|/* Set node debug */
case|case
name|NGM_L2CAP_NODE_SET_DEBUG
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_debug_ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
name|l2cap
operator|->
name|debug
operator|=
operator|*
operator|(
operator|(
name|ng_l2cap_node_debug_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
operator|)
expr_stmt|;
break|break;
comment|/* Get connection list */
case|case
name|NGM_L2CAP_NODE_GET_CON_LIST
case|:
block|{
name|ng_l2cap_con_p
name|con
init|=
name|NULL
decl_stmt|;
name|ng_l2cap_node_con_list_ep
modifier|*
name|e1
init|=
name|NULL
decl_stmt|;
name|ng_l2cap_node_con_ep
modifier|*
name|e2
init|=
name|NULL
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Count number of connections */
name|LIST_FOREACH
argument_list|(
argument|con
argument_list|,
argument|&l2cap->con_list
argument_list|,
argument|next
argument_list|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|NG_L2CAP_MAX_CON_NUM
condition|)
name|n
operator|=
name|NG_L2CAP_MAX_CON_NUM
expr_stmt|;
comment|/* Prepare response */
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|e1
argument_list|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|e2
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|e1
operator|=
operator|(
name|ng_l2cap_node_con_list_ep
operator|*
operator|)
operator|(
name|rsp
operator|->
name|data
operator|)
expr_stmt|;
name|e2
operator|=
operator|(
name|ng_l2cap_node_con_ep
operator|*
operator|)
operator|(
name|e1
operator|+
literal|1
operator|)
expr_stmt|;
name|e1
operator|->
name|num_connections
operator|=
name|n
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|con
argument_list|,
argument|&l2cap->con_list
argument_list|,
argument|next
argument_list|)
block|{
name|e2
operator|->
name|state
operator|=
name|con
operator|->
name|state
expr_stmt|;
name|e2
operator|->
name|flags
operator|=
name|con
operator|->
name|flags
expr_stmt|;
if|if
condition|(
name|con
operator|->
name|tx_pkt
operator|!=
name|NULL
condition|)
name|e2
operator|->
name|flags
operator||=
name|NG_L2CAP_CON_TX
expr_stmt|;
if|if
condition|(
name|con
operator|->
name|rx_pkt
operator|!=
name|NULL
condition|)
name|e2
operator|->
name|flags
operator||=
name|NG_L2CAP_CON_RX
expr_stmt|;
name|e2
operator|->
name|pending
operator|=
name|con
operator|->
name|pending
expr_stmt|;
name|e2
operator|->
name|con_handle
operator|=
name|con
operator|->
name|con_handle
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|con
operator|->
name|remote
argument_list|,
operator|&
name|e2
operator|->
name|remote
argument_list|,
sizeof|sizeof
argument_list|(
name|e2
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|e2
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
break|break;
comment|/* Get channel list */
case|case
name|NGM_L2CAP_NODE_GET_CHAN_LIST
case|:
block|{
name|ng_l2cap_chan_p
name|ch
init|=
name|NULL
decl_stmt|;
name|ng_l2cap_node_chan_list_ep
modifier|*
name|e1
init|=
name|NULL
decl_stmt|;
name|ng_l2cap_node_chan_ep
modifier|*
name|e2
init|=
name|NULL
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* Count number of channels */
name|LIST_FOREACH
argument_list|(
argument|ch
argument_list|,
argument|&l2cap->chan_list
argument_list|,
argument|next
argument_list|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|NG_L2CAP_MAX_CHAN_NUM
condition|)
name|n
operator|=
name|NG_L2CAP_MAX_CHAN_NUM
expr_stmt|;
comment|/* Prepare response */
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_chan_list_ep
argument_list|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_chan_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|e1
operator|=
operator|(
name|ng_l2cap_node_chan_list_ep
operator|*
operator|)
operator|(
name|rsp
operator|->
name|data
operator|)
expr_stmt|;
name|e2
operator|=
operator|(
name|ng_l2cap_node_chan_ep
operator|*
operator|)
operator|(
name|e1
operator|+
literal|1
operator|)
expr_stmt|;
name|e1
operator|->
name|num_channels
operator|=
name|n
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ch
argument_list|,
argument|&l2cap->chan_list
argument_list|,
argument|next
argument_list|)
block|{
name|e2
operator|->
name|state
operator|=
name|ch
operator|->
name|state
expr_stmt|;
name|e2
operator|->
name|scid
operator|=
name|ch
operator|->
name|scid
expr_stmt|;
name|e2
operator|->
name|dcid
operator|=
name|ch
operator|->
name|dcid
expr_stmt|;
name|e2
operator|->
name|imtu
operator|=
name|ch
operator|->
name|imtu
expr_stmt|;
name|e2
operator|->
name|omtu
operator|=
name|ch
operator|->
name|omtu
expr_stmt|;
name|e2
operator|->
name|psm
operator|=
name|ch
operator|->
name|psm
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ch
operator|->
name|con
operator|->
name|remote
argument_list|,
operator|&
name|e2
operator|->
name|remote
argument_list|,
sizeof|sizeof
argument_list|(
name|e2
operator|->
name|remote
argument_list|)
argument_list|)
expr_stmt|;
name|e2
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|<=
literal|0
condition|)
break|break;
block|}
block|}
break|break;
case|case
name|NGM_L2CAP_NODE_GET_AUTO_DISCON_TIMO
case|:
name|NG_MKRESPONSE
argument_list|(
name|rsp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_auto_discon_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_l2cap_node_auto_discon_ep
operator|*
operator|)
operator|(
name|rsp
operator|->
name|data
operator|)
operator|)
operator|=
name|l2cap
operator|->
name|discon_timo
expr_stmt|;
break|break;
case|case
name|NGM_L2CAP_NODE_SET_AUTO_DISCON_TIMO
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|ng_l2cap_node_auto_discon_ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
name|l2cap
operator|->
name|discon_timo
operator|=
operator|*
operator|(
operator|(
name|ng_l2cap_node_auto_discon_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
operator|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_rcvmsg */
end_comment

begin_comment
comment|/*  * Process data packet from one of our hooks.  *  * From the HCI hook we expect to receive ACL data packets. ACL data packets   * gets re-assembled into one L2CAP packet (according to length) and then gets   * processed.  *  * NOTE: We expect to receive L2CAP packet header in the first fragment.   *       Otherwise we WILL NOT be able to get length of the L2CAP packet.  *   * Signaling L2CAP packets (destination channel ID == 0x1) are processed within  * the node. Connectionless data packets (destination channel ID == 0x2) will   * be forwarded to appropriate upstream hook unless it is not connected or   * connectionless traffic for the specified PSM was disabled.  *  * From the upstream hooks we expect to receive data packets. These data   * packets will be converted into L2CAP data packets. The length of each  * L2CAP packet must not exceed channel's omtu (our peer's imtu). Then  * these L2CAP packets will be converted to ACL data packets (according to   * HCI layer MTU) and sent to lower layer.  *  * No data is expected from the control hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2cap_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|ng_l2cap_p
name|l2cap
init|=
operator|(
name|ng_l2cap_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Detach mbuf, discard item and process data */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|hci
condition|)
name|error
operator|=
name|ng_l2cap_lp_receive
argument_list|(
name|l2cap
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|l2cap
operator|->
name|l2c
condition|)
name|error
operator|=
name|ng_l2cap_l2ca_write_req
argument_list|(
name|l2cap
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_rcvdata */
end_comment

begin_comment
comment|/*  * Clean all connections, channels and commands for the L2CAP node  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2cap_cleanup
parameter_list|(
name|ng_l2cap_p
name|l2cap
parameter_list|)
block|{
name|ng_l2cap_con_p
name|con
init|=
name|NULL
decl_stmt|;
comment|/* Clean up connection and channels */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|l2cap
operator|->
name|con_list
argument_list|)
condition|)
block|{
name|con
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|l2cap
operator|->
name|con_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|con
operator|->
name|flags
operator|&
name|NG_L2CAP_CON_LP_TIMO
condition|)
name|ng_l2cap_lp_untimeout
argument_list|(
name|con
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|con
operator|->
name|flags
operator|&
name|NG_L2CAP_CON_AUTO_DISCON_TIMO
condition|)
name|ng_l2cap_discon_untimeout
argument_list|(
name|con
argument_list|)
expr_stmt|;
comment|/* Connection terminated by local host */
name|ng_l2cap_con_fail
argument_list|(
name|con
argument_list|,
literal|0x16
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ng_l2cap_cleanup */
end_comment

begin_comment
comment|/*  * Destroy all channels that use specified upstream hook  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2cap_destroy_channels
parameter_list|(
name|ng_l2cap_p
name|l2cap
parameter_list|)
block|{
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|l2cap
operator|->
name|chan_list
argument_list|)
condition|)
name|ng_l2cap_free_chan
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|l2cap
operator|->
name|chan_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_l2cap_destroy_channels_by_hook */
end_comment

end_unit

