begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_h4.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001-2002 Maksim Yevmenkin<m_evmenkin@yahoo.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: ng_h4.c,v 1.10 2005/10/31 17:57:43 max Exp $  * $FreeBSD$  *   * Based on:  * ---------  *  * FreeBSD: src/sys/netgraph/ng_tty.c  * Author: Archie Cobbs<archie@freebsd.org>  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_bluetooth.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_hci.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_h4.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/drivers/h4/ng_h4_var.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/drivers/h4/ng_h4_prse.h>
end_include

begin_comment
comment|/*****************************************************************************  *****************************************************************************  ** This node implements a Bluetooth HCI UART transport layer as per chapter  ** H4 of the Bluetooth Specification Book v1.1. It is a terminal line   ** discipline that is also a netgraph node. Installing this line discipline   ** on a terminal device instantiates a new netgraph node of this type, which   ** allows access to the device via the "hook" hook of the node.  **  ** Once the line discipline is installed, you can find out the name of the   ** corresponding netgraph node via a NGIOCGINFO ioctl().  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/* MALLOC define */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NG_SEPARATE_MALLOC
end_ifndef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_H4
argument_list|,
literal|"netgraph_h4"
argument_list|,
literal|"Netgraph Bluetooth H4 node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_H4
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NG_SEPARATE_MALLOC */
end_comment

begin_comment
comment|/* Line discipline methods */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_h4_open
parameter_list|(
name|struct
name|cdev
modifier|*
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_close
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_read
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_write
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_input
parameter_list|(
name|int
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_start
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Line discipline descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linesw
name|ng_h4_disc
init|=
block|{
name|ng_h4_open
block|,
comment|/* open */
name|ng_h4_close
block|,
comment|/* close */
name|ng_h4_read
block|,
comment|/* read */
name|ng_h4_write
block|,
comment|/* write */
name|ng_h4_ioctl
block|,
comment|/* ioctl */
name|ng_h4_input
block|,
comment|/* input */
name|ng_h4_start
block|,
comment|/* start */
name|ttymodem
comment|/* modem */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_h4_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_h4_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_h4_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_h4_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_h4_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_h4_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_h4_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other stuff */
end_comment

begin_function_decl
specifier|static
name|void
name|ng_h4_process_timeout
parameter_list|(
name|node_p
parameter_list|,
name|hook_p
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_h4_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_H4_NODE_TYPE
block|,
operator|.
name|mod_event
operator|=
name|ng_h4_mod_event
block|,
operator|.
name|constructor
operator|=
name|ng_h4_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_h4_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_h4_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_h4_newhook
block|,
operator|.
name|connect
operator|=
name|ng_h4_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_h4_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_h4_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_h4_cmdlist
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|h4
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ng_h4
argument_list|,
name|NG_BLUETOOTH_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ng_h4_node
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **			    Line discipline methods  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Set our line discipline on the tty.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|char
name|name
index|[
name|NG_NODESIZ
index|]
decl_stmt|;
name|ng_h4_info_p
name|sc
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Super-user only */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETGRAPH_TTY
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Initialize private struct */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_NETGRAPH_H4
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|tp
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|debug
operator|=
name|NG_H4_WARN_LEVEL
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|outq
operator|.
name|ifq_mtx
argument_list|,
literal|"ng_h4 node+queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|,
name|NG_H4_DEFAULTQLEN
argument_list|)
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|)
expr_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Setup netgraph node */
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: Unable to create new node!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|outq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH_H4
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Assign node its name */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|typestruct
operator|.
name|name
argument_list|,
name|ng_h4_node
operator|++
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: %s - node name exists?\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|outq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH_H4
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Set back pointers */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_lsc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
comment|/* The node has to be a WRITER because data can change node status */
name|NG_NODE_FORCE_WRITER
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * Pre-allocate cblocks to the an appropriate amount. 	 * I'm not sure what is appropriate. 	 */
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|MLEN
operator|+
name|NG_H4_HIWATER
argument_list|,
name|MLEN
operator|+
name|NG_H4_HIWATER
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_open */
end_comment

begin_comment
comment|/*  * Line specific close routine, called from device close routine  * and from ttioctl. This causes the node to be destroyed as well.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|)
condition|)
name|ng_uncallout
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|,
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_lsc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|dying
operator|=
literal|1
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ng_rmnode_self
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_close */
end_comment

begin_comment
comment|/*  * Once the device has been turned into a node, we don't allow reading.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_read
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_read */
end_comment

begin_comment
comment|/*  * Once the device has been turned into a node, we don't allow writing.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_write
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_write */
end_comment

begin_comment
comment|/*  * We implement the NGIOCGINFO ioctl() defined in ng_message.h.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|NGIOCGINFO
case|:
undef|#
directive|undef
name|NI
define|#
directive|define
name|NI
parameter_list|(
name|x
parameter_list|)
value|((struct nodeinfo *)(x))
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|NI
argument_list|(
name|data
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
condition|)
name|strncpy
argument_list|(
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|name
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|type
argument_list|,
name|sc
operator|->
name|node
operator|->
name|nd_type
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|type
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|id
operator|=
operator|(
name|u_int32_t
operator|)
name|ng_node2ID
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|NI
argument_list|(
name|data
argument_list|)
operator|->
name|hooks
operator|=
name|NG_NODE_NUMHOOKS
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_ioctl */
end_comment

begin_comment
comment|/*  * Receive data coming from the device. We get one character at a time, which   * is kindof silly.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_input
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
name|sc
operator|->
name|tp
operator|||
name|sc
operator|->
name|node
operator|==
name|NULL
operator|||
name|NG_NODE_NOT_VALID
argument_list|(
name|sc
operator|->
name|node
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check for error conditions */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - no carrier\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Loss of synchronization here! */
block|}
comment|/* Check for framing error or overrun on this char */
if|if
condition|(
name|c
operator|&
name|TTY_ERRORMASK
condition|)
block|{
name|NG_H4_ERR
argument_list|(
literal|"%s: %s - line error %#x, c=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|c
operator|&
name|TTY_ERRORMASK
argument_list|,
name|c
operator|&
name|TTY_CHARMASK
argument_list|)
expr_stmt|;
name|NG_H4_STAT_IERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Loss of synchronization here! */
block|}
name|NG_H4_STAT_BYTES_RECV
argument_list|(
name|sc
operator|->
name|stat
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Append char to mbuf */
if|if
condition|(
name|sc
operator|->
name|got
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ibuf
argument_list|)
condition|)
block|{
name|NG_H4_ALERT
argument_list|(
literal|"%s: %s - input buffer overflow, c=%#x, got=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|c
operator|&
name|TTY_CHARMASK
argument_list|,
name|sc
operator|->
name|got
argument_list|)
expr_stmt|;
name|NG_H4_STAT_IERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX Loss of synchronization here! */
block|}
name|sc
operator|->
name|ibuf
index|[
name|sc
operator|->
name|got
operator|++
index|]
operator|=
operator|(
name|c
operator|&
name|TTY_CHARMASK
operator|)
expr_stmt|;
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - got char %#x, want=%d, got=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|c
argument_list|,
name|sc
operator|->
name|want
argument_list|,
name|sc
operator|->
name|got
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|got
operator|<
name|sc
operator|->
name|want
condition|)
block|{
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Wait for more */
block|}
switch|switch
condition|(
name|sc
operator|->
name|state
condition|)
block|{
comment|/* Got packet indicator */
case|case
name|NG_H4_W4_PKT_IND
case|:
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - got packet indicator %#x\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_HDR
expr_stmt|;
comment|/* 		 * Since packet indicator included in the packet header 		 * just set sc->want to sizeof(packet header). 		 */
switch|switch
condition|(
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|NG_HCI_ACL_DATA_PKT
case|:
name|sc
operator|->
name|want
operator|=
sizeof|sizeof
argument_list|(
name|ng_hci_acldata_pkt_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NG_HCI_SCO_DATA_PKT
case|:
name|sc
operator|->
name|want
operator|=
sizeof|sizeof
argument_list|(
name|ng_hci_scodata_pkt_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|NG_HCI_EVENT_PKT
case|:
name|sc
operator|->
name|want
operator|=
sizeof|sizeof
argument_list|(
name|ng_hci_event_pkt_t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|NG_H4_WARN
argument_list|(
literal|"%s: %s - ignoring unknown packet "
expr|\
literal|"type=%#x\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|NG_H4_STAT_IERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
comment|/* Got packet header */
case|case
name|NG_H4_W4_PKT_HDR
case|:
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_DATA
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|NG_HCI_ACL_DATA_PKT
case|:
name|c
operator|=
name|le16toh
argument_list|(
operator|(
operator|(
name|ng_hci_acldata_pkt_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|ibuf
operator|)
operator|)
operator|->
name|length
argument_list|)
expr_stmt|;
break|break;
case|case
name|NG_HCI_SCO_DATA_PKT
case|:
name|c
operator|=
operator|(
operator|(
name|ng_hci_scodata_pkt_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|ibuf
operator|)
operator|)
operator|->
name|length
expr_stmt|;
break|break;
case|case
name|NG_HCI_EVENT_PKT
case|:
name|c
operator|=
operator|(
operator|(
name|ng_hci_event_pkt_t
operator|*
operator|)
operator|(
name|sc
operator|->
name|ibuf
operator|)
operator|)
operator|->
name|length
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
operator|(
literal|0
operator|)
argument_list|,
operator|(
literal|"Invalid packet type=%#x\n"
operator|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - got packet header, packet type=%#x, "
expr|\
literal|"packet size=%d, payload size=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|got
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|sc
operator|->
name|want
operator|+=
name|c
expr_stmt|;
comment|/*  			 * Try to prevent possible buffer overrun 			 * 			 * XXX I'm *really* confused here. It turns out 			 * that Xircom card sends us packets with length 			 * greater then 512 bytes! This is greater then 			 * our old receive buffer (ibuf) size. In the same 			 * time the card demands from us *not* to send  			 * packets greater then 192 bytes. Weird! How the  			 * hell i should know how big *receive* buffer  			 * should be? For now increase receiving buffer  			 * size to 1K and add the following check. 			 */
if|if
condition|(
name|sc
operator|->
name|want
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|ibuf
argument_list|)
condition|)
block|{
name|int
name|b
decl_stmt|;
name|NG_H4_ALERT
argument_list|(
literal|"%s: %s - packet too big for "
expr|\
literal|"buffer, type=%#x, got=%d, want=%d, "
expr|\
literal|"length=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|got
argument_list|,
name|sc
operator|->
name|want
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|NG_H4_ALERT
argument_list|(
literal|"Packet header:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|sc
operator|->
name|got
condition|;
name|b
operator|++
control|)
name|NG_H4_ALERT
argument_list|(
literal|"%#x "
argument_list|,
name|sc
operator|->
name|ibuf
index|[
name|b
index|]
argument_list|)
expr_stmt|;
name|NG_H4_ALERT
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Reset state */
name|NG_H4_STAT_IERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
comment|/* else FALLTHROUGH and deliver frame */
comment|/* XXX Is this true? Should we deliver empty frame? */
comment|/* Got packet data */
case|case
name|NG_H4_W4_PKT_DATA
case|:
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - got full packet, packet type=%#x, "
expr|\
literal|"packet size=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|sc
operator|->
name|ibuf
index|[
literal|0
index|]
argument_list|,
name|sc
operator|->
name|got
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hook
operator|!=
name|NULL
operator|&&
name|NG_HOOK_IS_VALID
argument_list|(
name|sc
operator|->
name|hook
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
comment|/* XXX m_copyback() is stupid */
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MHLEN
argument_list|,
name|sc
operator|->
name|got
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|got
argument_list|,
name|sc
operator|->
name|ibuf
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|c
argument_list|,
name|sc
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NG_H4_ERR
argument_list|(
literal|"%s: %s - could not get mbuf\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|NG_H4_STAT_IERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|NG_H4_STAT_PCKTS_RECV
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
operator|(
literal|0
operator|)
argument_list|,
operator|(
literal|"Invalid H4 node state=%d"
operator|,
name|sc
operator|->
name|state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_input */
end_comment

begin_comment
comment|/*  * This is called when the device driver is ready for more output. Called from   * tty system.   */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_start
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
name|sc
operator|->
name|tp
operator|||
name|sc
operator|->
name|node
operator|==
name|NULL
operator|||
name|NG_NODE_NOT_VALID
argument_list|(
name|sc
operator|->
name|node
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
block|while (tp->t_outq.c_cc< NG_H4_HIWATER) {
comment|/* XXX 2.2 specific ? */
else|#
directive|else
while|while
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
comment|/* Remove first mbuf from queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
comment|/* Send as much of it as possible */
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|m
operator|->
name|m_len
operator|-
name|b_to_q
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_H4_STAT_BYTES_SENT
argument_list|(
name|sc
operator|->
name|stat
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|size
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>
literal|0
condition|)
break|break;
comment|/* device can't take no more */
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Put remainder of mbuf chain (if any) back on queue */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|IF_PREPEND
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Full packet has been sent */
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_H4_STAT_PCKTS_SENT
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Call output process whether or not there is any output. We are 	 * being called in lieu of ttstart and must do what it would. 	 */
name|tt_oproc
argument_list|(
name|sc
operator|->
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * This timeout is needed for operation on a pseudo-tty, because the 	 * pty code doesn't call pppstart after it has drained the t_outq. 	 */
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
operator|&&
operator|!
name|callout_pending
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|)
condition|)
name|ng_callout
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|,
name|sc
operator|->
name|node
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
name|ng_h4_process_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_start */
end_comment

begin_comment
comment|/*****************************************************************************  *****************************************************************************  **			    Netgraph node methods  *****************************************************************************  *****************************************************************************/
end_comment

begin_comment
comment|/*  * Initialize a new node of this type. We only allow nodes to be created as   * a result of setting the line discipline on a tty, so always return an error  * if not.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_constructor */
end_comment

begin_comment
comment|/*  * Add a new hook. There can only be one.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_H4_HOOK
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|hook
operator|!=
name|NULL
condition|)
block|{
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISCONN
operator|)
return|;
block|}
name|sc
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_newhook */
end_comment

begin_comment
comment|/*  * Connect hook. Just say yes.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|hook
operator|!=
name|sc
operator|->
name|hook
condition|)
name|panic
argument_list|(
literal|"%s: hook != sc->hook\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_connect */
end_comment

begin_comment
comment|/*  * Disconnect the hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 	 * We need to check for sc != NULL because we can be called from 	 * ng_h4_close() via ng_rmnode_self() 	 */
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hook
operator|!=
name|sc
operator|->
name|hook
condition|)
name|panic
argument_list|(
literal|"%s: hook != sc->hook\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* XXX do we have to untimeout and drain out queue? */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|)
condition|)
name|ng_uncallout
argument_list|(
operator|&
name|sc
operator|->
name|timo
argument_list|,
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|_IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_disconnect */
end_comment

begin_comment
comment|/*  * Remove this node. The does the netgraph portion of the shutdown.  * This should only be called indirectly from ng_h4_close().  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|dying
condition|)
block|{
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_NODE_REVIVE
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* we will persist */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|outq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH_H4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_shutdown */
end_comment

begin_comment
comment|/*  * Receive incoming data from Netgraph system. Put it on our  * output queue and start output if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|qlen
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EHOSTDOWN
operator|)
return|;
if|if
condition|(
name|hook
operator|!=
name|sc
operator|->
name|hook
condition|)
name|panic
argument_list|(
literal|"%s: hook != sc->hook\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
condition|)
block|{
name|NG_H4_ERR
argument_list|(
literal|"%s: %s - dropping mbuf, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|NG_H4_STAT_OERROR
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NG_H4_INFO
argument_list|(
literal|"%s: %s - queue mbuf, len=%d\n"
argument_list|,
name|__func__
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|sc
operator|->
name|node
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|_IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|qlen
operator|=
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
expr_stmt|;
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If qlen> 1, then we should already have a scheduled callout 	 */
if|if
condition|(
name|qlen
operator|==
literal|1
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ng_h4_start
argument_list|(
name|sc
operator|->
name|tp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_rcvdata */
end_comment

begin_comment
comment|/*  * Receive control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NULL
decl_stmt|,
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EHOSTDOWN
operator|)
return|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|NG_H4_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|resp
operator|->
name|data
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
literal|"Hook: %s\n"
expr|\
literal|"Debug: %d\n"
expr|\
literal|"State: %d\n"
expr|\
literal|"Queue: [have:%d,max:%d]\n"
expr|\
literal|"Input: [got:%d,want:%d]"
argument_list|,
operator|(
name|sc
operator|->
name|hook
operator|!=
name|NULL
operator|)
condition|?
name|NG_H4_HOOK
else|:
literal|""
argument_list|,
name|sc
operator|->
name|debug
argument_list|,
name|sc
operator|->
name|state
argument_list|,
name|_IF_QLEN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
argument_list|,
name|sc
operator|->
name|outq
operator|.
name|ifq_maxlen
argument_list|,
name|sc
operator|->
name|got
argument_list|,
name|sc
operator|->
name|want
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_H4_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_H4_NODE_RESET
case|:
name|_IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|state
operator|=
name|NG_H4_W4_PKT_IND
expr_stmt|;
name|sc
operator|->
name|want
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|got
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_GET_STATE
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_h4_node_state_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_h4_node_state_ep
operator|*
operator|)
operator|(
name|resp
operator|->
name|data
operator|)
operator|)
operator|=
name|sc
operator|->
name|state
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_GET_DEBUG
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_h4_node_debug_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_h4_node_debug_ep
operator|*
operator|)
operator|(
name|resp
operator|->
name|data
operator|)
operator|)
operator|=
name|sc
operator|->
name|debug
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_SET_DEBUG
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|ng_h4_node_debug_ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
name|sc
operator|->
name|debug
operator|=
operator|*
operator|(
operator|(
name|ng_h4_node_debug_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_GET_QLEN
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_h4_node_qlen_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
operator|(
operator|(
name|ng_h4_node_qlen_ep
operator|*
operator|)
operator|(
name|resp
operator|->
name|data
operator|)
operator|)
operator|=
name|sc
operator|->
name|outq
operator|.
name|ifq_maxlen
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_SET_QLEN
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|ng_h4_node_qlen_ep
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|(
operator|(
name|ng_h4_node_qlen_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
operator|)
operator|<=
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|sc
operator|->
name|outq
argument_list|,
operator|*
operator|(
operator|(
name|ng_h4_node_qlen_ep
operator|*
operator|)
operator|(
name|msg
operator|->
name|data
operator|)
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_GET_STAT
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_h4_node_stat_ep
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|stat
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ng_h4_node_stat_ep
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_H4_NODE_RESET_STAT
case|:
name|NG_H4_STAT_RESET
argument_list|(
name|sc
operator|->
name|stat
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_H4_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_rcvmsg */
end_comment

begin_comment
comment|/*  * Timeout processing function.  * We still have data to output to the device, so try sending more.  */
end_comment

begin_function
specifier|static
name|void
name|ng_h4_process_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|ng_h4_info_p
name|sc
init|=
operator|(
name|ng_h4_info_p
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ng_h4_start
argument_list|(
name|sc
operator|->
name|tp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ng_h4_process_timeout */
end_comment

begin_comment
comment|/*  * Handle loading and unloading for this node type  */
end_comment

begin_function
specifier|static
name|int
name|ng_h4_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
specifier|static
name|int
name|ng_h4_ldisc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register line discipline */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ng_h4_ldisc
operator|=
name|ldisc_register
argument_list|(
name|H4DISC
argument_list|,
operator|&
name|ng_h4_disc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_h4_ldisc
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: can't register H4 line discipline\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIO
expr_stmt|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Unregister line discipline */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ldisc_deregister
argument_list|(
name|ng_h4_ldisc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ng_h4_mod_event */
end_comment

end_unit

