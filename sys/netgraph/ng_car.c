begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Nuno Antunes<nuno.antunes@gmail.com>  * Copyright (c) 2007 Alexander Motin<mav@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * ng_car - An implementation of commited access rate for netgraph  *  * TODO:  *	- Sanitize input config values (impose some limits)  *	- Implement internal packet painting (possibly using mbuf tags)  *	- Implement color-aware mode  *	- Implement DSCP marking for IPv4  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_car.h>
end_include

begin_define
define|#
directive|define
name|NG_CAR_QUEUE_SIZE
value|100
end_define

begin_comment
comment|/* Maximum queue size for SHAPE mode */
end_comment

begin_define
define|#
directive|define
name|NG_CAR_QUEUE_MIN_TH
value|8
end_define

begin_comment
comment|/* Minimum RED threshhold for SHAPE mode */
end_comment

begin_comment
comment|/* Hook private info */
end_comment

begin_struct
struct|struct
name|hookinfo
block|{
name|hook_p
name|hook
decl_stmt|;
comment|/* this (source) hook */
name|hook_p
name|dest
decl_stmt|;
comment|/* destination hook */
name|int64_t
name|tc
decl_stmt|;
comment|/* commited token bucket counter */
name|int64_t
name|te
decl_stmt|;
comment|/* exceeded/peak token bucket counter */
name|struct
name|timeval
name|lastRefill
decl_stmt|;
comment|/* last token refill time */
name|struct
name|ng_car_hookconf
name|conf
decl_stmt|;
comment|/* hook configuration */
name|struct
name|ng_car_hookstats
name|stats
decl_stmt|;
comment|/* hook stats */
name|struct
name|mbuf
modifier|*
name|q
index|[
name|NG_CAR_QUEUE_SIZE
index|]
decl_stmt|;
comment|/* circular packet queue */
name|int
name|q_first
decl_stmt|;
comment|/* first queue element */
name|int
name|q_last
decl_stmt|;
comment|/* last queue element */
name|struct
name|callout
name|q_callout
decl_stmt|;
comment|/* periodic queue processing routine */
name|struct
name|mtx
name|q_mtx
decl_stmt|;
comment|/* queue mutex */
block|}
struct|;
end_struct

begin_comment
comment|/* Private information for each node instance */
end_comment

begin_struct
struct|struct
name|privdata
block|{
name|node_p
name|node
decl_stmt|;
comment|/* the node itself */
name|struct
name|hookinfo
name|upper
decl_stmt|;
comment|/* hook to upper layers */
name|struct
name|hookinfo
name|lower
decl_stmt|;
comment|/* hook to lower layers */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|privdata
modifier|*
name|priv_p
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_car_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_car_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_car_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_car_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_car_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_car_disconnect
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ng_car_refillhook
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_car_schedule
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ng_car_q_event
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_car_enqueue
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|h
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse type for struct ng_car_hookstats */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_car_hookstats_type_fields
index|[]
init|=
name|NG_CAR_HOOKSTATS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_car_hookstats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_car_hookstats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_car_bulkstats */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_car_bulkstats_type_fields
index|[]
init|=
name|NG_CAR_BULKSTATS
argument_list|(
operator|&
name|ng_car_hookstats_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_car_bulkstats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_car_bulkstats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_car_hookconf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_car_hookconf_type_fields
index|[]
init|=
name|NG_CAR_HOOKCONF
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_car_hookconf_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_car_hookconf_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_car_bulkconf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_car_bulkconf_type_fields
index|[]
init|=
name|NG_CAR_BULKCONF
argument_list|(
operator|&
name|ng_car_hookconf_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_car_bulkconf_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_car_bulkconf_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command list */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_cmdlist
name|ng_car_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_CAR_COOKIE
block|,
name|NGM_CAR_GET_STATS
block|,
literal|"getstats"
block|,
name|NULL
block|,
operator|&
name|ng_car_bulkstats_type
block|, 	}
block|,
block|{
name|NGM_CAR_COOKIE
block|,
name|NGM_CAR_CLR_STATS
block|,
literal|"clrstats"
block|,
name|NULL
block|,
name|NULL
block|, 	}
block|,
block|{
name|NGM_CAR_COOKIE
block|,
name|NGM_CAR_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
name|NULL
block|,
operator|&
name|ng_car_bulkstats_type
block|, 	}
block|,
block|{
name|NGM_CAR_COOKIE
block|,
name|NGM_CAR_GET_CONF
block|,
literal|"getconf"
block|,
name|NULL
block|,
operator|&
name|ng_car_bulkconf_type
block|, 	}
block|,
block|{
name|NGM_CAR_COOKIE
block|,
name|NGM_CAR_SET_CONF
block|,
literal|"setconf"
block|,
operator|&
name|ng_car_bulkconf_type
block|,
name|NULL
block|, 	}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_car_typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_CAR_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_car_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_car_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_car_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_car_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_car_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_car_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_car_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|car
argument_list|,
operator|&
name|ng_car_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Node constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
comment|/* Initialize private descriptor. */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|node
expr_stmt|;
comment|/* 	 * Arbitrary default values 	 */
name|priv
operator|->
name|upper
operator|.
name|hook
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|dest
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|tc
operator|=
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|cbs
operator|=
name|NG_CAR_CBS_MIN
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|te
operator|=
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|ebs
operator|=
name|NG_CAR_EBS_MIN
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|cir
operator|=
name|NG_CAR_CIR_DFLT
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|green_action
operator|=
name|NG_CAR_ACTION_FORWARD
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|yellow_action
operator|=
name|NG_CAR_ACTION_FORWARD
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|red_action
operator|=
name|NG_CAR_ACTION_DROP
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|lastRefill
argument_list|)
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|q_first
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|q_last
operator|=
literal|0
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|q_callout
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|q_mtx
argument_list|,
literal|"ng_car_u"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|hook
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|dest
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|tc
operator|=
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|cbs
operator|=
name|NG_CAR_CBS_MIN
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|te
operator|=
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|ebs
operator|=
name|NG_CAR_EBS_MIN
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|cir
operator|=
name|NG_CAR_CIR_DFLT
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|green_action
operator|=
name|NG_CAR_ACTION_FORWARD
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|yellow_action
operator|=
name|NG_CAR_ACTION_FORWARD
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|red_action
operator|=
name|NG_CAR_ACTION_DROP
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|lastRefill
operator|=
name|priv
operator|->
name|upper
operator|.
name|lastRefill
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|q_first
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|q_last
operator|=
literal|0
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|q_callout
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|q_mtx
argument_list|,
literal|"ng_car_l"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CAR_HOOK_LOWER
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|lower
operator|.
name|hook
operator|=
name|hook
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|dest
operator|=
name|hook
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|lower
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|&
name|priv
operator|->
name|lower
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_CAR_HOOK_UPPER
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|upper
operator|.
name|hook
operator|=
name|hook
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|dest
operator|=
name|hook
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|upper
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|&
name|priv
operator|->
name|upper
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Data has arrived.  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|hookinfo
modifier|*
specifier|const
name|hinfo
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|hook_p
name|dest
init|=
name|hinfo
operator|->
name|dest
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Node is useless without destination hook. */
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|errors
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* If queue is not empty now then enqueue packet. */
if|if
condition|(
name|hinfo
operator|->
name|q_first
operator|!=
name|hinfo
operator|->
name|q_last
condition|)
block|{
name|ng_car_enqueue
argument_list|(
name|hinfo
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m
operator|=
name|NGI_M
argument_list|(
name|item
argument_list|)
expr_stmt|;
define|#
directive|define
name|NG_CAR_PERFORM_MATCH_ACTION
parameter_list|(
name|a
parameter_list|)
define|\
value|do {						\ 		switch (a) {				\ 		case NG_CAR_ACTION_FORWARD:		\
comment|/* Do nothing. */
value|\ 			break;				\ 		case NG_CAR_ACTION_MARK:		\
comment|/* XXX find a way to mark packets (mbuf tag?) */
value|\ 			++hinfo->stats.errors;		\ 			break;				\ 		case NG_CAR_ACTION_DROP:		\ 		default:				\
comment|/* Drop packet and return. */
value|\ 			NG_FREE_ITEM(item);		\ 			++hinfo->stats.droped_pkts;	\ 			return (0);			\ 		}					\ 	} while (0)
comment|/* Check commited token bucket. */
if|if
condition|(
name|hinfo
operator|->
name|tc
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|0
condition|)
block|{
comment|/* This packet is green. */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|green_pkts
expr_stmt|;
name|hinfo
operator|->
name|tc
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|green_action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Refill only if not green without it. */
name|ng_car_refillhook
argument_list|(
name|hinfo
argument_list|)
expr_stmt|;
comment|/* Check commited token bucket again after refill. */
if|if
condition|(
name|hinfo
operator|->
name|tc
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|0
condition|)
block|{
comment|/* This packet is green */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|green_pkts
expr_stmt|;
name|hinfo
operator|->
name|tc
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|green_action
argument_list|)
expr_stmt|;
comment|/* If not green and mode is SHAPE, enqueue packet. */
block|}
elseif|else
if|if
condition|(
name|hinfo
operator|->
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_SHAPE
condition|)
block|{
name|ng_car_enqueue
argument_list|(
name|hinfo
argument_list|,
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If not green and mode is RED, calculate probability. */
block|}
elseif|else
if|if
condition|(
name|hinfo
operator|->
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_RED
condition|)
block|{
comment|/* Is packet is bigger then extended burst? */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hinfo
operator|->
name|tc
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
operator|>
name|hinfo
operator|->
name|conf
operator|.
name|ebs
condition|)
block|{
comment|/* This packet is definitely red. */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|red_pkts
expr_stmt|;
name|hinfo
operator|->
name|te
operator|=
literal|0
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|red_action
argument_list|)
expr_stmt|;
comment|/* Use token bucket to simulate RED-like drop 			   probability. */
block|}
elseif|else
if|if
condition|(
name|hinfo
operator|->
name|te
operator|+
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|hinfo
operator|->
name|tc
operator|)
operator|<
name|hinfo
operator|->
name|conf
operator|.
name|ebs
condition|)
block|{
comment|/* This packet is yellow */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|yellow_pkts
expr_stmt|;
name|hinfo
operator|->
name|te
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|hinfo
operator|->
name|tc
expr_stmt|;
comment|/* Go to negative tokens. */
name|hinfo
operator|->
name|tc
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|yellow_action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This packet is probaly red. */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|red_pkts
expr_stmt|;
name|hinfo
operator|->
name|te
operator|=
literal|0
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|red_action
argument_list|)
expr_stmt|;
block|}
comment|/* If not green and mode is SINGLE/DOUBLE RATE. */
block|}
else|else
block|{
comment|/* Check extended token bucket. */
if|if
condition|(
name|hinfo
operator|->
name|te
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|0
condition|)
block|{
comment|/* This packet is yellow */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|yellow_pkts
expr_stmt|;
name|hinfo
operator|->
name|te
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|yellow_action
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This packet is red */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|red_pkts
expr_stmt|;
name|NG_CAR_PERFORM_MATCH_ACTION
argument_list|(
name|hinfo
operator|->
name|conf
operator|.
name|red_action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
undef|#
directive|undef
name|NG_CAR_PERFORM_MATCH_ACTION
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|errors
expr_stmt|;
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|passed_pkts
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_CAR_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_CAR_GET_STATS
case|:
case|case
name|NGM_CAR_GETCLR_STATS
case|:
block|{
name|struct
name|ng_car_bulkstats
modifier|*
name|bstats
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bstats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bstats
operator|=
operator|(
expr|struct
name|ng_car_bulkstats
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|stats
argument_list|,
operator|&
name|bstats
operator|->
name|downstream
argument_list|,
sizeof|sizeof
argument_list|(
name|bstats
operator|->
name|downstream
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|stats
argument_list|,
operator|&
name|bstats
operator|->
name|upstream
argument_list|,
sizeof|sizeof
argument_list|(
name|bstats
operator|->
name|upstream
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_CAR_GET_STATS
condition|)
break|break;
case|case
name|NGM_CAR_CLR_STATS
case|:
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|upper
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|lower
operator|.
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_CAR_GET_CONF
case|:
block|{
name|struct
name|ng_car_bulkconf
modifier|*
name|bconf
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bconf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bconf
operator|=
operator|(
expr|struct
name|ng_car_bulkconf
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|conf
argument_list|,
operator|&
name|bconf
operator|->
name|downstream
argument_list|,
sizeof|sizeof
argument_list|(
name|bconf
operator|->
name|downstream
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|conf
argument_list|,
operator|&
name|bconf
operator|->
name|upstream
argument_list|,
sizeof|sizeof
argument_list|(
name|bconf
operator|->
name|upstream
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NGM_CAR_SET_CONF
case|:
block|{
name|struct
name|ng_car_bulkconf
modifier|*
specifier|const
name|bconf
init|=
operator|(
expr|struct
name|ng_car_bulkconf
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
comment|/* Check for invalid or illegal config. */
if|if
condition|(
operator|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|bconf
argument_list|)
operator|)
operator|||
operator|(
name|bconf
operator|->
name|downstream
operator|.
name|cir
operator|>
literal|1000000000
operator|)
operator|||
operator|(
name|bconf
operator|->
name|downstream
operator|.
name|pir
operator|>
literal|1000000000
operator|)
operator|||
operator|(
name|bconf
operator|->
name|upstream
operator|.
name|cir
operator|>
literal|1000000000
operator|)
operator|||
operator|(
name|bconf
operator|->
name|upstream
operator|.
name|pir
operator|>
literal|1000000000
operator|)
operator|||
operator|(
name|bconf
operator|->
name|downstream
operator|.
name|cbs
operator|==
literal|0
operator|&&
name|bconf
operator|->
name|downstream
operator|.
name|ebs
operator|==
literal|0
operator|)
operator|||
operator|(
name|bconf
operator|->
name|upstream
operator|.
name|cbs
operator|==
literal|0
operator|&&
name|bconf
operator|->
name|upstream
operator|.
name|ebs
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Copy downstream config. */
name|bcopy
argument_list|(
operator|&
name|bconf
operator|->
name|downstream
argument_list|,
operator|&
name|priv
operator|->
name|upper
operator|.
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|upper
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|upper
operator|.
name|tc
operator|=
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|cbs
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_RED
operator|||
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_SHAPE
condition|)
block|{
name|priv
operator|->
name|upper
operator|.
name|te
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|upper
operator|.
name|te
operator|=
name|priv
operator|->
name|upper
operator|.
name|conf
operator|.
name|ebs
expr_stmt|;
block|}
comment|/* Copy upstream config. */
name|bcopy
argument_list|(
operator|&
name|bconf
operator|->
name|upstream
argument_list|,
operator|&
name|priv
operator|->
name|lower
operator|.
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|lower
operator|.
name|conf
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|lower
operator|.
name|tc
operator|=
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|cbs
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_RED
operator|||
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_SHAPE
condition|)
block|{
name|priv
operator|->
name|lower
operator|.
name|te
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|lower
operator|.
name|te
operator|=
name|priv
operator|->
name|lower
operator|.
name|conf
operator|.
name|ebs
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing.  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|q_callout
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|q_callout
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|priv
operator|->
name|upper
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|priv
operator|->
name|lower
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection.  *  * For this type, removal of the last link destroys the node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_car_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|struct
name|hookinfo
modifier|*
specifier|const
name|hinfo
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|hinfo
condition|)
block|{
comment|/* Purge queue if not empty. */
while|while
condition|(
name|hinfo
operator|->
name|q_first
operator|!=
name|hinfo
operator|->
name|q_last
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|hinfo
operator|->
name|q
index|[
name|hinfo
operator|->
name|q_first
index|]
argument_list|)
expr_stmt|;
name|hinfo
operator|->
name|q_first
operator|++
expr_stmt|;
if|if
condition|(
name|hinfo
operator|->
name|q_first
operator|>=
name|NG_CAR_QUEUE_SIZE
condition|)
name|hinfo
operator|->
name|q_first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove hook refs. */
if|if
condition|(
name|hinfo
operator|->
name|hook
operator|==
name|priv
operator|->
name|upper
operator|.
name|hook
condition|)
name|priv
operator|->
name|lower
operator|.
name|dest
operator|=
name|NULL
expr_stmt|;
else|else
name|priv
operator|->
name|upper
operator|.
name|dest
operator|=
name|NULL
expr_stmt|;
name|hinfo
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Already shutting down? */
if|if
condition|(
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook's token buckets refillment.  */
end_comment

begin_function
specifier|static
name|void
name|ng_car_refillhook
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|timeval
name|newt
decl_stmt|,
name|deltat
decl_stmt|;
name|int64_t
name|deltat_us
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
comment|/* Get current time. */
name|getmicrotime
argument_list|(
operator|&
name|newt
argument_list|)
expr_stmt|;
comment|/* Time must go forward. */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|newt
argument_list|,
operator|&
name|h
operator|->
name|lastRefill
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|h
operator|->
name|lastRefill
operator|=
name|newt
expr_stmt|;
return|return;
block|}
comment|/* Get time delta since last refill. */
name|deltat
operator|=
name|newt
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|deltat
argument_list|,
operator|&
name|h
operator|->
name|lastRefill
argument_list|)
expr_stmt|;
comment|/* Sanity check */
if|if
condition|(
name|deltat
operator|.
name|tv_sec
operator|>
literal|1000
condition|)
block|{
name|deltat_us
operator|=
literal|1000000000
expr_stmt|;
block|}
else|else
block|{
name|deltat_us
operator|=
operator|(
operator|(
name|int64_t
operator|)
name|deltat
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|deltat
operator|.
name|tv_usec
expr_stmt|;
block|}
if|if
condition|(
name|h
operator|->
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_SINGLE_RATE
condition|)
block|{
comment|/* Refill commited token bucket. */
name|h
operator|->
name|tc
operator|+=
name|h
operator|->
name|conf
operator|.
name|cir
operator|*
name|deltat_us
operator|/
literal|8000000
expr_stmt|;
name|delta
operator|=
name|h
operator|->
name|tc
operator|-
name|h
operator|->
name|conf
operator|.
name|cbs
expr_stmt|;
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
block|{
name|h
operator|->
name|tc
operator|=
name|h
operator|->
name|conf
operator|.
name|cbs
expr_stmt|;
comment|/* Refill exceeded token bucket. */
name|h
operator|->
name|te
operator|+=
name|delta
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|te
operator|>
name|h
operator|->
name|conf
operator|.
name|ebs
condition|)
name|h
operator|->
name|te
operator|=
name|h
operator|->
name|conf
operator|.
name|ebs
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|conf
operator|.
name|mode
operator|==
name|NG_CAR_DOUBLE_RATE
condition|)
block|{
comment|/* Refill commited token bucket. */
name|h
operator|->
name|tc
operator|+=
name|h
operator|->
name|conf
operator|.
name|cir
operator|*
name|deltat_us
operator|/
literal|8000000
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|tc
operator|>
name|h
operator|->
name|conf
operator|.
name|cbs
condition|)
name|h
operator|->
name|tc
operator|=
name|h
operator|->
name|conf
operator|.
name|cbs
expr_stmt|;
comment|/* Refill peak token bucket. */
name|h
operator|->
name|te
operator|+=
name|h
operator|->
name|conf
operator|.
name|pir
operator|*
name|deltat_us
operator|/
literal|8000000
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|te
operator|>
name|h
operator|->
name|conf
operator|.
name|ebs
condition|)
name|h
operator|->
name|te
operator|=
name|h
operator|->
name|conf
operator|.
name|ebs
expr_stmt|;
block|}
else|else
block|{
comment|/* RED or SHAPE mode. */
comment|/* Refill commited token bucket. */
name|h
operator|->
name|tc
operator|+=
name|h
operator|->
name|conf
operator|.
name|cir
operator|*
name|deltat_us
operator|/
literal|8000000
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|tc
operator|>
operator|(
operator|(
name|int64_t
operator|)
name|h
operator|->
name|conf
operator|.
name|cbs
operator|)
condition|)
name|h
operator|->
name|tc
operator|=
name|h
operator|->
name|conf
operator|.
name|cbs
expr_stmt|;
block|}
comment|/* Remember this moment. */
name|h
operator|->
name|lastRefill
operator|=
name|newt
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Schedule callout when we will have required tokens.  */
end_comment

begin_function
specifier|static
name|void
name|ng_car_schedule
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|hinfo
parameter_list|)
block|{
name|int
name|delay
decl_stmt|;
name|delay
operator|=
operator|(
operator|-
operator|(
name|hinfo
operator|->
name|tc
operator|)
operator|)
operator|*
name|hz
operator|*
literal|8
operator|/
name|hinfo
operator|->
name|conf
operator|.
name|cir
operator|+
literal|1
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|hinfo
operator|->
name|q_callout
argument_list|,
name|NG_HOOK_NODE
argument_list|(
name|hinfo
operator|->
name|hook
argument_list|)
argument_list|,
name|hinfo
operator|->
name|hook
argument_list|,
name|delay
argument_list|,
operator|&
name|ng_car_q_event
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue processing callout handler.  */
end_comment

begin_function
name|void
name|ng_car_q_event
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|struct
name|hookinfo
modifier|*
name|hinfo
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|item_p
name|item
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Refill tokens for time we have slept. */
name|ng_car_refillhook
argument_list|(
name|hinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|hinfo
operator|->
name|dest
operator|!=
name|NULL
condition|)
block|{
comment|/* If we have some tokens */
while|while
condition|(
name|hinfo
operator|->
name|tc
operator|>=
literal|0
condition|)
block|{
comment|/* Send packet. */
name|m
operator|=
name|hinfo
operator|->
name|q
index|[
name|hinfo
operator|->
name|q_first
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|NG_NOFLAGS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|hinfo
operator|->
name|dest
argument_list|)
expr_stmt|;
comment|/* Get next one. */
name|hinfo
operator|->
name|q_first
operator|++
expr_stmt|;
if|if
condition|(
name|hinfo
operator|->
name|q_first
operator|>=
name|NG_CAR_QUEUE_SIZE
condition|)
name|hinfo
operator|->
name|q_first
operator|=
literal|0
expr_stmt|;
comment|/* Stop if none left. */
if|if
condition|(
name|hinfo
operator|->
name|q_first
operator|==
name|hinfo
operator|->
name|q_last
condition|)
break|break;
comment|/* If we have more packet, try it. */
name|m
operator|=
name|hinfo
operator|->
name|q
index|[
name|hinfo
operator|->
name|q_first
index|]
expr_stmt|;
name|hinfo
operator|->
name|tc
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
block|}
comment|/* If something left */
if|if
condition|(
name|hinfo
operator|->
name|q_first
operator|!=
name|hinfo
operator|->
name|q_last
condition|)
comment|/* Schedule queue processing. */
name|ng_car_schedule
argument_list|(
name|hinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enqueue packet.  */
end_comment

begin_function
specifier|static
name|void
name|ng_car_enqueue
parameter_list|(
name|struct
name|hookinfo
modifier|*
name|hinfo
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Lock queue mutex. */
name|mtx_lock
argument_list|(
operator|&
name|hinfo
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
comment|/* Calculate used queue length. */
name|len
operator|=
name|hinfo
operator|->
name|q_last
operator|-
name|hinfo
operator|->
name|q_first
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|len
operator|+=
name|NG_CAR_QUEUE_SIZE
expr_stmt|;
comment|/* If queue is overflowed or we have no RED tokens. */
if|if
condition|(
operator|(
name|len
operator|>=
operator|(
name|NG_CAR_QUEUE_SIZE
operator|-
literal|1
operator|)
operator|)
operator|||
operator|(
name|hinfo
operator|->
name|te
operator|+
name|len
operator|>=
name|NG_CAR_QUEUE_SIZE
operator|)
condition|)
block|{
comment|/* Drop packet. */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|red_pkts
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|hinfo
operator|->
name|te
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* This packet is yellow. */
operator|++
name|hinfo
operator|->
name|stats
operator|.
name|yellow_pkts
expr_stmt|;
comment|/* Enqueue packet. */
name|hinfo
operator|->
name|q
index|[
name|hinfo
operator|->
name|q_last
index|]
operator|=
name|m
expr_stmt|;
name|hinfo
operator|->
name|q_last
operator|++
expr_stmt|;
if|if
condition|(
name|hinfo
operator|->
name|q_last
operator|>=
name|NG_CAR_QUEUE_SIZE
condition|)
name|hinfo
operator|->
name|q_last
operator|=
literal|0
expr_stmt|;
comment|/* Use RED tokens. */
if|if
condition|(
name|len
operator|>
name|NG_CAR_QUEUE_MIN_TH
condition|)
name|hinfo
operator|->
name|te
operator|+=
name|len
operator|-
name|NG_CAR_QUEUE_MIN_TH
expr_stmt|;
comment|/* If this is a first packet in the queue. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|hinfo
operator|->
name|tc
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Schedule queue processing. */
name|ng_car_schedule
argument_list|(
name|hinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Unlock queue mutex. */
name|mtx_unlock
argument_list|(
operator|&
name|hinfo
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

