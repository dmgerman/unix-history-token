begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_pptpgre.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_pptpgre.c,v 1.7 1999/12/08 00:10:06 archie Exp $  */
end_comment

begin_comment
comment|/*  * PPTP/GRE netgraph node type.  *  * This node type does the GRE encapsulation as specified for the PPTP  * protocol (RFC 2637, section 4).  This includes sequencing and  * retransmission of frames, but not the actual packet delivery nor  * any of the TCP control stream protocol.  *  * The "upper" hook of this node is suitable for attaching to a "ppp"  * node link hook.  The "lower" hook of this node is suitable for attaching  * to a "ksocket" node on hook "inet/raw/gre".  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_pptpgre.h>
end_include

begin_comment
comment|/* GRE packet format, as used by PPTP */
end_comment

begin_struct
struct|struct
name|greheader
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|u_char
name|recursion
range|:
literal|3
decl_stmt|;
comment|/* recursion control */
name|u_char
name|ssr
range|:
literal|1
decl_stmt|;
comment|/* strict source route */
name|u_char
name|hasSeq
range|:
literal|1
decl_stmt|;
comment|/* sequence number present */
name|u_char
name|hasKey
range|:
literal|1
decl_stmt|;
comment|/* key present */
name|u_char
name|hasRoute
range|:
literal|1
decl_stmt|;
comment|/* routing present */
name|u_char
name|hasSum
range|:
literal|1
decl_stmt|;
comment|/* checksum present */
name|u_char
name|vers
range|:
literal|3
decl_stmt|;
comment|/* version */
name|u_char
name|flags
range|:
literal|4
decl_stmt|;
comment|/* flags */
name|u_char
name|hasAck
range|:
literal|1
decl_stmt|;
comment|/* acknowlege number present */
elif|#
directive|elif
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|u_char
name|hasSum
range|:
literal|1
decl_stmt|;
comment|/* checksum present */
name|u_char
name|hasRoute
range|:
literal|1
decl_stmt|;
comment|/* routing present */
name|u_char
name|hasKey
range|:
literal|1
decl_stmt|;
comment|/* key present */
name|u_char
name|hasSeq
range|:
literal|1
decl_stmt|;
comment|/* sequence number present */
name|u_char
name|ssr
range|:
literal|1
decl_stmt|;
comment|/* strict source route */
name|u_char
name|recursion
range|:
literal|3
decl_stmt|;
comment|/* recursion control */
name|u_char
name|hasAck
range|:
literal|1
decl_stmt|;
comment|/* acknowlege number present */
name|u_char
name|flags
range|:
literal|4
decl_stmt|;
comment|/* flags */
name|u_char
name|vers
range|:
literal|3
decl_stmt|;
comment|/* version */
else|#
directive|else
error|#
directive|error
error|BYTE_ORDER is not defined properly
endif|#
directive|endif
name|u_int16_t
name|proto
decl_stmt|;
comment|/* protocol (ethertype) */
name|u_int16_t
name|length
decl_stmt|;
comment|/* payload length */
name|u_int16_t
name|cid
decl_stmt|;
comment|/* call id */
name|u_int32_t
name|data
index|[
literal|0
index|]
decl_stmt|;
comment|/* opt. seq, ack, then data */
block|}
struct|;
end_struct

begin_comment
comment|/* The PPTP protocol ID used in the GRE 'proto' field */
end_comment

begin_define
define|#
directive|define
name|PPTP_GRE_PROTO
value|0x880b
end_define

begin_comment
comment|/* Bits that must be set a certain way in all PPTP/GRE packets */
end_comment

begin_define
define|#
directive|define
name|PPTP_INIT_VALUE
value|((0x2001<< 16) | PPTP_GRE_PROTO)
end_define

begin_define
define|#
directive|define
name|PPTP_INIT_MASK
value|0xef7fffff
end_define

begin_comment
comment|/* Min and max packet length */
end_comment

begin_define
define|#
directive|define
name|PPTP_MAX_PAYLOAD
value|(0xffff - sizeof(struct greheader) - 8)
end_define

begin_comment
comment|/* All times are scaled by this (PPTP_TIME_SCALE time units = 1 sec.) */
end_comment

begin_define
define|#
directive|define
name|PPTP_TIME_SCALE
value|1000
end_define

begin_comment
comment|/* milliseconds */
end_comment

begin_typedef
typedef|typedef
name|u_int64_t
name|pptptime_t
typedef|;
end_typedef

begin_comment
comment|/* Acknowledgment timeout parameters and functions */
end_comment

begin_define
define|#
directive|define
name|PPTP_XMIT_WIN
value|16
end_define

begin_comment
comment|/* max xmit window */
end_comment

begin_define
define|#
directive|define
name|PPTP_MIN_RTT
value|(PPTP_TIME_SCALE / 10)
end_define

begin_comment
comment|/* 100 milliseconds */
end_comment

begin_define
define|#
directive|define
name|PPTP_MIN_TIMEOUT
value|(PPTP_TIME_SCALE / 83)
end_define

begin_comment
comment|/* 12 milliseconds */
end_comment

begin_define
define|#
directive|define
name|PPTP_MAX_TIMEOUT
value|(3 * PPTP_TIME_SCALE)
end_define

begin_comment
comment|/* 3 seconds */
end_comment

begin_comment
comment|/* When we recieve a packet, we wait to see if there's an outgoing packet    we can piggy-back the ACK off of. These parameters determine the mimimum    and maxmimum length of time we're willing to wait in order to do that.    These have no effect unless "enableDelayedAck" is turned on. */
end_comment

begin_define
define|#
directive|define
name|PPTP_MIN_ACK_DELAY
value|(PPTP_TIME_SCALE / 500)
end_define

begin_comment
comment|/* 2 milliseconds */
end_comment

begin_define
define|#
directive|define
name|PPTP_MAX_ACK_DELAY
value|(PPTP_TIME_SCALE / 2)
end_define

begin_comment
comment|/* 500 milliseconds */
end_comment

begin_comment
comment|/* See RFC 2637 section 4.4 */
end_comment

begin_define
define|#
directive|define
name|PPTP_ACK_ALPHA
parameter_list|(
name|x
parameter_list|)
value|((x)>> 3)
end_define

begin_comment
comment|/* alpha = 0.125 */
end_comment

begin_define
define|#
directive|define
name|PPTP_ACK_BETA
parameter_list|(
name|x
parameter_list|)
value|((x)>> 2)
end_define

begin_comment
comment|/* beta = 0.25 */
end_comment

begin_define
define|#
directive|define
name|PPTP_ACK_CHI
parameter_list|(
name|x
parameter_list|)
value|((x)<< 2)
end_define

begin_comment
comment|/* chi = 4 */
end_comment

begin_define
define|#
directive|define
name|PPTP_ACK_DELTA
parameter_list|(
name|x
parameter_list|)
value|((x)<< 1)
end_define

begin_comment
comment|/* delta = 2 */
end_comment

begin_define
define|#
directive|define
name|PPTP_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((int32_t)(x) - (int32_t)(y))
end_define

begin_comment
comment|/* We keep packet retransmit and acknowlegement state in this struct */
end_comment

begin_struct
struct|struct
name|ng_pptpgre_ackp
block|{
name|int32_t
name|ato
decl_stmt|;
comment|/* adaptive time-out value */
name|int32_t
name|rtt
decl_stmt|;
comment|/* round trip time estimate */
name|int32_t
name|dev
decl_stmt|;
comment|/* deviation estimate */
name|u_int16_t
name|xmitWin
decl_stmt|;
comment|/* size of xmit window */
name|struct
name|callout
name|sackTimer
decl_stmt|;
comment|/* send ack timer */
name|struct
name|callout
name|rackTimer
decl_stmt|;
comment|/* recv ack timer */
name|u_int32_t
name|winAck
decl_stmt|;
comment|/* seq when xmitWin will grow */
name|pptptime_t
name|timeSent
index|[
name|PPTP_XMIT_WIN
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RAT
name|pptptime_t
name|timerStart
decl_stmt|;
comment|/* when rackTimer started */
name|pptptime_t
name|timerLength
decl_stmt|;
comment|/* rackTimer duration */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Node private data */
end_comment

begin_struct
struct|struct
name|ng_pptpgre_private
block|{
name|hook_p
name|upper
decl_stmt|;
comment|/* hook to upper layers */
name|hook_p
name|lower
decl_stmt|;
comment|/* hook to lower layers */
name|struct
name|ng_pptpgre_conf
name|conf
decl_stmt|;
comment|/* configuration info */
name|struct
name|ng_pptpgre_ackp
name|ackp
decl_stmt|;
comment|/* packet transmit ack state */
name|u_int32_t
name|recvSeq
decl_stmt|;
comment|/* last seq # we rcv'd */
name|u_int32_t
name|xmitSeq
decl_stmt|;
comment|/* last seq # we sent */
name|u_int32_t
name|recvAck
decl_stmt|;
comment|/* last seq # peer ack'd */
name|u_int32_t
name|xmitAck
decl_stmt|;
comment|/* last seq # we ack'd */
name|struct
name|timeval
name|startTime
decl_stmt|;
comment|/* time node was created */
name|struct
name|ng_pptpgre_stats
name|stats
decl_stmt|;
comment|/* node statistics */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_pptpgre_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_pptpgre_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_pptpgre_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_pptpgre_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_pptpgre_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_pptpgre_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_pptpgre_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_pptpgre_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_pptpgre_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_start_send_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|ackTimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_stop_send_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_start_recv_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_stop_recv_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_recv_ack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_send_ack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_pptpgre_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pptptime_t
name|ng_pptpgre_time
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse type for struct ng_pptpgre_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_pptpgre_conf_type_fields
index|[]
init|=
name|NG_PPTPGRE_CONF_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_pptpgre_conf_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_pptpgre_conf_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_pptpgre_stats */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_pptpgre_stats_type_fields
index|[]
init|=
name|NG_PPTPGRE_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_pptp_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_pptpgre_stats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_pptpgre_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_PPTPGRE_COOKIE
block|,
name|NGM_PPTPGRE_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_pptpgre_conf_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPTPGRE_COOKIE
block|,
name|NGM_PPTPGRE_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_pptpgre_conf_type
block|}
block|,
block|{
name|NGM_PPTPGRE_COOKIE
block|,
name|NGM_PPTPGRE_GET_STATS
block|,
literal|"getstats"
block|,
name|NULL
block|,
operator|&
name|ng_pptp_stats_type
block|}
block|,
block|{
name|NGM_PPTPGRE_COOKIE
block|,
name|NGM_PPTPGRE_CLR_STATS
block|,
literal|"clrstats"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPTPGRE_COOKIE
block|,
name|NGM_PPTPGRE_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
name|NULL
block|,
operator|&
name|ng_pptp_stats_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_pptpgre_typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_PPTPGRE_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_pptpgre_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_pptpgre_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_pptpgre_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_pptpgre_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_pptpgre_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_pptpgre_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_pptpgre_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|pptpgre
argument_list|,
operator|&
name|ng_pptpgre_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Node type constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
comment|/* Allocate private structure */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
comment|/* Initialize state */
name|ng_callout_init
argument_list|(
operator|&
name|priv
operator|->
name|ackp
operator|.
name|sackTimer
argument_list|)
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|priv
operator|->
name|ackp
operator|.
name|rackTimer
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our OK for a hook to be added.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
modifier|*
name|hookPtr
decl_stmt|;
comment|/* Check hook name */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPTPGRE_HOOK_UPPER
argument_list|)
operator|==
literal|0
condition|)
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|upper
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_PPTPGRE_HOOK_LOWER
argument_list|)
operator|==
literal|0
condition|)
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|lower
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* See if already connected */
if|if
condition|(
operator|*
name|hookPtr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* OK */
operator|*
name|hookPtr
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPTPGRE_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPTPGRE_SET_CONFIG
case|:
block|{
name|struct
name|ng_pptpgre_conf
modifier|*
specifier|const
name|newConf
init|=
operator|(
expr|struct
name|ng_pptpgre_conf
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
comment|/* Check for invalid or illegal config */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|newConf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ng_pptpgre_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* reset on configure */
name|priv
operator|->
name|conf
operator|=
operator|*
name|newConf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPTPGRE_GET_CONFIG
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|conf
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPTPGRE_GET_STATS
case|:
case|case
name|NGM_PPTPGRE_CLR_STATS
case|:
case|case
name|NGM_PPTPGRE_GETCLR_STATS
case|:
block|{
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPTPGRE_CLR_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPTPGRE_GET_STATS
condition|)
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive incoming data on a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* If not configured, reject */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enabled
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Treat as xmit or recv data */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|upper
condition|)
return|return
name|ng_pptpgre_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
return|;
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|lower
condition|)
return|return
name|ng_pptpgre_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
return|;
name|panic
argument_list|(
literal|"%s: weird hook"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy node  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Reset node (stops timers) */
name|ng_pptpgre_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
comment|/* Decrement ref count */
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Zero out hook pointer */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|upper
condition|)
name|priv
operator|->
name|upper
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|lower
condition|)
name|priv
operator|->
name|lower
operator|=
name|NULL
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"%s: unknown hook"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Go away if no longer connected to anything */
if|if
condition|(
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* 		    TRANSMIT AND RECEIVE FUNCTIONS *************************************************************************/
end_comment

begin_comment
comment|/*  * Transmit an outgoing frame, or just an ack if m is NULL.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
name|u_char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|greheader
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
index|]
decl_stmt|;
name|struct
name|greheader
modifier|*
specifier|const
name|gre
init|=
operator|(
expr|struct
name|greheader
operator|*
operator|)
name|buf
decl_stmt|;
name|int
name|grelen
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|item
condition|)
block|{
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Check if there's data */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* Check if windowing is enabled */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableWindowing
condition|)
block|{
comment|/* Is our transmit window full? */
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|PPTP_SEQ_DIFF
argument_list|(
name|priv
operator|->
name|xmitSeq
argument_list|,
name|priv
operator|->
name|recvAck
argument_list|)
operator|>=
name|a
operator|->
name|xmitWin
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitDrops
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* Sanity check frame length */
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|PPTP_MAX_PAYLOAD
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitTooBig
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
block|}
else|else
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitLoneAcks
operator|++
expr_stmt|;
block|}
comment|/* Build GRE header */
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|gre
operator|)
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|PPTP_INIT_VALUE
argument_list|)
expr_stmt|;
name|gre
operator|->
name|length
operator|=
operator|(
name|m
operator|!=
name|NULL
operator|)
condition|?
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
else|:
literal|0
expr_stmt|;
name|gre
operator|->
name|cid
operator|=
name|htons
argument_list|(
name|priv
operator|->
name|conf
operator|.
name|peerCid
argument_list|)
expr_stmt|;
comment|/* Include sequence number if packet contains any data */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|gre
operator|->
name|hasSeq
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableWindowing
condition|)
block|{
name|a
operator|->
name|timeSent
index|[
name|priv
operator|->
name|xmitSeq
operator|-
name|priv
operator|->
name|recvAck
index|]
operator|=
name|ng_pptpgre_time
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|xmitSeq
operator|++
expr_stmt|;
name|gre
operator|->
name|data
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|priv
operator|->
name|xmitSeq
argument_list|)
expr_stmt|;
block|}
comment|/* Include acknowledgement (and stop send ack timer) if needed */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableAlwaysAck
operator|||
name|priv
operator|->
name|xmitAck
operator|!=
name|priv
operator|->
name|recvSeq
condition|)
block|{
name|gre
operator|->
name|hasAck
operator|=
literal|1
expr_stmt|;
name|gre
operator|->
name|data
index|[
name|gre
operator|->
name|hasSeq
index|]
operator|=
name|htonl
argument_list|(
name|priv
operator|->
name|recvSeq
argument_list|)
expr_stmt|;
name|priv
operator|->
name|xmitAck
operator|=
name|priv
operator|->
name|recvSeq
expr_stmt|;
name|ng_pptpgre_stop_send_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* Prepend GRE header to outgoing frame */
name|grelen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
operator|(
name|gre
operator|->
name|hasSeq
operator|+
name|gre
operator|->
name|hasAck
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
if|if
condition|(
name|item
condition|)
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|grelen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|grelen
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
name|grelen
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|grelen
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
if|if
condition|(
name|item
condition|)
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|bcopy
argument_list|(
name|gre
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|grelen
argument_list|)
expr_stmt|;
comment|/* Update stats */
name|priv
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Deliver packet */
if|if
condition|(
name|item
condition|)
block|{
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|lower
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|lower
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Start receive ACK timer if data was sent and not already running */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|gre
operator|->
name|hasSeq
operator|&&
name|priv
operator|->
name|xmitSeq
operator|==
name|priv
operator|->
name|recvAck
operator|+
literal|1
condition|)
name|ng_pptpgre_start_recv_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an incoming packet.  The packet includes the IP header.  */
end_comment

begin_function
specifier|static
name|int
name|ng_pptpgre_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|iphlen
decl_stmt|,
name|grelen
decl_stmt|,
name|extralen
decl_stmt|;
specifier|const
name|struct
name|greheader
modifier|*
name|gre
decl_stmt|;
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Update stats */
name|priv
operator|->
name|stats
operator|.
name|recvPackets
operator|++
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Sanity check packet length */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvRunts
operator|++
expr_stmt|;
name|bad
label|:
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Safely pull up the complete IP+GRE headers */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|gre
operator|=
operator|(
specifier|const
expr|struct
name|greheader
operator|*
operator|)
operator|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|grelen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gre
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|*
operator|(
name|gre
operator|->
name|hasSeq
operator|+
name|gre
operator|->
name|hasAck
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|iphlen
operator|+
name|grelen
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvRunts
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|iphlen
operator|+
name|grelen
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
name|grelen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|gre
operator|=
operator|(
specifier|const
expr|struct
name|greheader
operator|*
operator|)
operator|(
operator|(
specifier|const
name|u_char
operator|*
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
block|}
comment|/* Sanity check packet length and GRE header bits */
name|extralen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|iphlen
operator|+
name|grelen
operator|+
name|gre
operator|->
name|hasSeq
operator|*
operator|(
name|u_int16_t
operator|)
name|ntohs
argument_list|(
name|gre
operator|->
name|length
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extralen
operator|<
literal|0
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvBadGRE
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
specifier|const
name|u_int32_t
operator|*
operator|)
name|gre
operator|)
argument_list|)
operator|&
name|PPTP_INIT_MASK
operator|)
operator|!=
name|PPTP_INIT_VALUE
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvBadGRE
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|gre
operator|->
name|cid
argument_list|)
operator|!=
name|priv
operator|->
name|conf
operator|.
name|cid
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvBadCID
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Look for peer ack */
if|if
condition|(
name|gre
operator|->
name|hasAck
condition|)
block|{
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
specifier|const
name|u_int32_t
name|ack
init|=
name|ntohl
argument_list|(
name|gre
operator|->
name|data
index|[
name|gre
operator|->
name|hasSeq
index|]
argument_list|)
decl_stmt|;
specifier|const
name|int
name|index
init|=
name|ack
operator|-
name|priv
operator|->
name|recvAck
operator|-
literal|1
decl_stmt|;
name|long
name|sample
decl_stmt|;
name|long
name|diff
decl_stmt|;
comment|/* Sanity check ack value */
if|if
condition|(
name|PPTP_SEQ_DIFF
argument_list|(
name|ack
argument_list|,
name|priv
operator|->
name|xmitSeq
argument_list|)
operator|>
literal|0
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvBadAcks
operator|++
expr_stmt|;
goto|goto
name|badAck
goto|;
comment|/* we never sent it! */
block|}
if|if
condition|(
name|PPTP_SEQ_DIFF
argument_list|(
name|ack
argument_list|,
name|priv
operator|->
name|recvAck
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|badAck
goto|;
comment|/* ack already timed out */
name|priv
operator|->
name|recvAck
operator|=
name|ack
expr_stmt|;
comment|/* Update adaptive timeout stuff */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableWindowing
condition|)
block|{
name|sample
operator|=
name|ng_pptpgre_time
argument_list|(
name|node
argument_list|)
operator|-
name|a
operator|->
name|timeSent
index|[
name|index
index|]
expr_stmt|;
name|diff
operator|=
name|sample
operator|-
name|a
operator|->
name|rtt
expr_stmt|;
name|a
operator|->
name|rtt
operator|+=
name|PPTP_ACK_ALPHA
argument_list|(
name|diff
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|diff
operator|=
operator|-
name|diff
expr_stmt|;
name|a
operator|->
name|dev
operator|+=
name|PPTP_ACK_BETA
argument_list|(
name|diff
operator|-
name|a
operator|->
name|dev
argument_list|)
expr_stmt|;
name|a
operator|->
name|ato
operator|=
name|a
operator|->
name|rtt
operator|+
name|PPTP_ACK_CHI
argument_list|(
name|a
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ato
operator|>
name|PPTP_MAX_TIMEOUT
condition|)
name|a
operator|->
name|ato
operator|=
name|PPTP_MAX_TIMEOUT
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ato
operator|<
name|PPTP_MIN_TIMEOUT
condition|)
name|a
operator|->
name|ato
operator|=
name|PPTP_MIN_TIMEOUT
expr_stmt|;
comment|/* Shift packet transmit times in our transmit window */
name|bcopy
argument_list|(
name|a
operator|->
name|timeSent
operator|+
name|index
operator|+
literal|1
argument_list|,
name|a
operator|->
name|timeSent
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|a
operator|->
name|timeSent
argument_list|)
operator|*
operator|(
name|PPTP_XMIT_WIN
operator|-
operator|(
name|index
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* If we sent an entire window, increase window size */
if|if
condition|(
name|PPTP_SEQ_DIFF
argument_list|(
name|ack
argument_list|,
name|a
operator|->
name|winAck
argument_list|)
operator|>=
literal|0
operator|&&
name|a
operator|->
name|xmitWin
operator|<
name|PPTP_XMIT_WIN
condition|)
block|{
name|a
operator|->
name|xmitWin
operator|++
expr_stmt|;
name|a
operator|->
name|winAck
operator|=
name|ack
operator|+
name|a
operator|->
name|xmitWin
expr_stmt|;
block|}
comment|/* Stop/(re)start receive ACK timer as necessary */
name|ng_pptpgre_stop_recv_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|recvAck
operator|!=
name|priv
operator|->
name|xmitSeq
condition|)
name|ng_pptpgre_start_recv_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|badAck
label|:
comment|/* See if frame contains any data */
if|if
condition|(
name|gre
operator|->
name|hasSeq
condition|)
block|{
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
specifier|const
name|u_int32_t
name|seq
init|=
name|ntohl
argument_list|(
name|gre
operator|->
name|data
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* Sanity check sequence number */
if|if
condition|(
name|PPTP_SEQ_DIFF
argument_list|(
name|seq
argument_list|,
name|priv
operator|->
name|recvSeq
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|seq
operator|==
name|priv
operator|->
name|recvSeq
condition|)
name|priv
operator|->
name|stats
operator|.
name|recvDuplicates
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|stats
operator|.
name|recvOutOfOrder
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* out-of-order or dup */
block|}
name|priv
operator|->
name|recvSeq
operator|=
name|seq
expr_stmt|;
comment|/* We need to acknowledge this packet; do it soon... */
if|if
condition|(
operator|!
operator|(
name|a
operator|->
name|sackTimer
operator|.
name|c_flags
operator|&
name|CALLOUT_PENDING
operator|)
condition|)
block|{
name|int
name|maxWait
decl_stmt|;
comment|/* Take 1/4 of the estimated round trip time */
name|maxWait
operator|=
operator|(
name|a
operator|->
name|rtt
operator|>>
literal|2
operator|)
expr_stmt|;
comment|/* If delayed ACK is disabled, send it now */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDelayedAck
condition|)
comment|/* ack now */
name|ng_pptpgre_xmit
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* ack later */
if|if
condition|(
name|maxWait
operator|<
name|PPTP_MIN_ACK_DELAY
condition|)
name|maxWait
operator|=
name|PPTP_MIN_ACK_DELAY
expr_stmt|;
if|if
condition|(
name|maxWait
operator|>
name|PPTP_MAX_ACK_DELAY
condition|)
name|maxWait
operator|=
name|PPTP_MAX_ACK_DELAY
expr_stmt|;
name|ng_pptpgre_start_send_ack_timer
argument_list|(
name|node
argument_list|,
name|maxWait
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Trim mbuf down to internal payload */
name|m_adj
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
name|grelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|extralen
operator|>
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|extralen
argument_list|)
expr_stmt|;
comment|/* Deliver frame to upper layers */
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|upper
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|stats
operator|.
name|recvLoneAcks
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* no data to deliver */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* 		    TIMER RELATED FUNCTIONS *************************************************************************/
end_comment

begin_comment
comment|/*  * Start a timer for the peer's acknowledging our oldest unacknowledged  * sequence number.  If we get an ack for this sequence number before  * the timer goes off, we cancel the timer.  Resets currently running  * recv ack timer, if any.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_start_recv_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
name|int
name|remain
decl_stmt|,
name|ticks
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableWindowing
condition|)
return|return;
comment|/* Compute how long until oldest unack'd packet times out, 	   and reset the timer to that time. */
name|remain
operator|=
operator|(
name|a
operator|->
name|timeSent
index|[
literal|0
index|]
operator|+
name|a
operator|->
name|ato
operator|)
operator|-
name|ng_pptpgre_time
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|remain
operator|<
literal|0
condition|)
name|remain
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RAT
name|a
operator|->
name|timerLength
operator|=
name|remain
expr_stmt|;
name|a
operator|->
name|timerStart
operator|=
name|ng_pptpgre_time
argument_list|(
name|node
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Be conservative: timeout can happen up to 1 tick early */
name|ticks
operator|=
operator|(
operator|(
operator|(
name|remain
operator|*
name|hz
operator|)
operator|+
name|PPTP_TIME_SCALE
operator|-
literal|1
operator|)
operator|/
name|PPTP_TIME_SCALE
operator|)
operator|+
literal|1
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|a
operator|->
name|rackTimer
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|ticks
argument_list|,
name|ng_pptpgre_recv_ack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop receive ack timer.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_stop_recv_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableWindowing
condition|)
return|return;
name|ng_uncallout
argument_list|(
operator|&
name|a
operator|->
name|rackTimer
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The peer has failed to acknowledge the oldest unacknowledged sequence  * number within the time allotted.  Update our adaptive timeout parameters  * and reset/restart the recv ack timer.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_recv_ack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
comment|/* Update adaptive timeout stuff */
name|priv
operator|->
name|stats
operator|.
name|recvAckTimeouts
operator|++
expr_stmt|;
name|a
operator|->
name|rtt
operator|=
name|PPTP_ACK_DELTA
argument_list|(
name|a
operator|->
name|rtt
argument_list|)
expr_stmt|;
name|a
operator|->
name|ato
operator|=
name|a
operator|->
name|rtt
operator|+
name|PPTP_ACK_CHI
argument_list|(
name|a
operator|->
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ato
operator|>
name|PPTP_MAX_TIMEOUT
condition|)
name|a
operator|->
name|ato
operator|=
name|PPTP_MAX_TIMEOUT
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|ato
operator|<
name|PPTP_MIN_TIMEOUT
condition|)
name|a
operator|->
name|ato
operator|=
name|PPTP_MIN_TIMEOUT
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_RAT
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"RAT now=%d seq=0x%x sent=%d tstart=%d tlen=%d ato=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|ng_pptpgre_time
argument_list|(
name|node
argument_list|)
argument_list|,
name|priv
operator|->
name|recvAck
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|a
operator|->
name|timeSent
index|[
literal|0
index|]
argument_list|,
operator|(
name|int
operator|)
name|a
operator|->
name|timerStart
argument_list|,
operator|(
name|int
operator|)
name|a
operator|->
name|timerLength
argument_list|,
name|a
operator|->
name|ato
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reset ack and sliding window */
name|priv
operator|->
name|recvAck
operator|=
name|priv
operator|->
name|xmitSeq
expr_stmt|;
comment|/* pretend we got the ack */
name|a
operator|->
name|xmitWin
operator|=
operator|(
name|a
operator|->
name|xmitWin
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* shrink transmit window */
name|a
operator|->
name|winAck
operator|=
name|priv
operator|->
name|recvAck
operator|+
name|a
operator|->
name|xmitWin
expr_stmt|;
comment|/* reset win expand time */
block|}
end_function

begin_comment
comment|/*  * Start the send ack timer. This assumes the timer is not  * already running.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_start_send_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|ackTimeout
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
name|int
name|ticks
decl_stmt|;
comment|/* Be conservative: timeout can happen up to 1 tick early */
name|ticks
operator|=
operator|(
operator|(
operator|(
name|ackTimeout
operator|*
name|hz
operator|)
operator|+
name|PPTP_TIME_SCALE
operator|-
literal|1
operator|)
operator|/
name|PPTP_TIME_SCALE
operator|)
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|a
operator|->
name|sackTimer
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|ticks
argument_list|,
name|ng_pptpgre_send_ack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop send ack timer.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_stop_send_ack_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|a
operator|->
name|sackTimer
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've waited as long as we're willing to wait before sending an  * acknowledgement to the peer for received frames. We had hoped to  * be able to piggy back our acknowledgement on an outgoing data frame,  * but apparently there haven't been any since. So send the ack now.  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_send_ack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
comment|/* Send a frame with an ack but no payload */
name|ng_pptpgre_xmit
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************* 		    MISC FUNCTIONS *************************************************************************/
end_comment

begin_comment
comment|/*  * Reset state  */
end_comment

begin_function
specifier|static
name|void
name|ng_pptpgre_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_pptpgre_ackp
modifier|*
specifier|const
name|a
init|=
operator|&
name|priv
operator|->
name|ackp
decl_stmt|;
comment|/* Reset adaptive timeout state */
name|a
operator|->
name|ato
operator|=
name|PPTP_MAX_TIMEOUT
expr_stmt|;
name|a
operator|->
name|rtt
operator|=
name|priv
operator|->
name|conf
operator|.
name|peerPpd
operator|*
name|PPTP_TIME_SCALE
operator|/
literal|10
expr_stmt|;
comment|/* ppd in 10ths */
if|if
condition|(
name|a
operator|->
name|rtt
operator|<
name|PPTP_MIN_RTT
condition|)
name|a
operator|->
name|rtt
operator|=
name|PPTP_MIN_RTT
expr_stmt|;
name|a
operator|->
name|dev
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|xmitWin
operator|=
operator|(
name|priv
operator|->
name|conf
operator|.
name|recvWin
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|xmitWin
operator|<
literal|2
condition|)
comment|/* often the first packet is lost */
name|a
operator|->
name|xmitWin
operator|=
literal|2
expr_stmt|;
comment|/*   because the peer isn't ready */
if|if
condition|(
name|a
operator|->
name|xmitWin
operator|>
name|PPTP_XMIT_WIN
condition|)
name|a
operator|->
name|xmitWin
operator|=
name|PPTP_XMIT_WIN
expr_stmt|;
name|a
operator|->
name|winAck
operator|=
name|a
operator|->
name|xmitWin
expr_stmt|;
comment|/* Reset sequence numbers */
name|priv
operator|->
name|recvSeq
operator|=
operator|~
literal|0
expr_stmt|;
name|priv
operator|->
name|recvAck
operator|=
operator|~
literal|0
expr_stmt|;
name|priv
operator|->
name|xmitSeq
operator|=
operator|~
literal|0
expr_stmt|;
name|priv
operator|->
name|xmitAck
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* Reset start time */
name|getmicrouptime
argument_list|(
operator|&
name|priv
operator|->
name|startTime
argument_list|)
expr_stmt|;
comment|/* Reset stats */
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stop timers */
name|ng_pptpgre_stop_send_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_pptpgre_stop_recv_ack_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the current time scaled& translated to our internally used format.  */
end_comment

begin_function
specifier|static
name|pptptime_t
name|ng_pptpgre_time
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|pptptime_t
name|t
decl_stmt|;
name|microuptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
name|priv
operator|->
name|startTime
operator|.
name|tv_sec
operator|||
operator|(
name|tv
operator|.
name|tv_sec
operator|==
name|priv
operator|->
name|startTime
operator|.
name|tv_sec
operator|&&
name|tv
operator|.
name|tv_usec
operator|<
name|priv
operator|->
name|startTime
operator|.
name|tv_usec
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|timevalsub
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|priv
operator|->
name|startTime
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|pptptime_t
operator|)
name|tv
operator|.
name|tv_sec
operator|*
name|PPTP_TIME_SCALE
expr_stmt|;
name|t
operator|+=
operator|(
name|pptptime_t
operator|)
name|tv
operator|.
name|tv_usec
operator|/
operator|(
literal|1000000
operator|/
name|PPTP_TIME_SCALE
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

end_unit

