begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_base.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *  * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *  * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Authors: Julian Elischer<julian@freebsd.org>  *          Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_base.c,v 1.39 1999/01/28 23:54:53 julian Exp $  */
end_comment

begin_comment
comment|/*  * This file implements the base netgraph code.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|netgraph
argument_list|,
name|NG_ABI_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of all active nodes */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ng_nodelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_nodelist_mtx
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ng_allnodes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ng_freenodes
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* in debug, we never free() them */
end_comment

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|ng_hook
argument_list|)
name|ng_allhooks
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_hook
argument_list|)
name|ng_freehooks
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* in debug, we never free() them */
end_comment

begin_function_decl
specifier|static
name|void
name|ng_dumpitems
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_dumpnodes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_dumphooks
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETGRAPH_DEBUG */
end_comment

begin_comment
comment|/*  * DEAD versions of the structures.   * In order to avoid races, it is sometimes neccesary to point  * at SOMETHING even though theoretically, the current entity is   * INVALID. Use these to avoid these races.  */
end_comment

begin_decl_stmt
name|struct
name|ng_type
name|ng_deadtype
init|=
block|{
name|NG_ABI_VERSION
block|,
literal|"dead"
block|,
name|NULL
block|,
comment|/* modevent */
name|NULL
block|,
comment|/* constructor */
name|NULL
block|,
comment|/* rcvmsg */
name|NULL
block|,
comment|/* shutdown */
name|NULL
block|,
comment|/* newhook */
name|NULL
block|,
comment|/* findhook */
name|NULL
block|,
comment|/* connect */
name|NULL
block|,
comment|/* rcvdata */
name|NULL
block|,
comment|/* disconnect */
name|NULL
block|,
comment|/* cmdlist */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ng_node
name|ng_deadnode
init|=
block|{
literal|"dead"
block|,
operator|&
name|ng_deadtype
block|,
name|NG_INVALID
block|,
literal|1
block|,
comment|/* refs */
literal|0
block|,
comment|/* numhooks */
name|NULL
block|,
comment|/* private */
literal|0
block|,
comment|/* ID */
name|LIST_HEAD_INITIALIZER
argument_list|(
name|ng_deadnode
operator|.
name|hooks
argument_list|)
block|,
block|{}
block|,
comment|/* all_nodes list entry */
block|{}
block|,
comment|/* id hashtable list entry */
block|{}
block|,
comment|/* workqueue entry */
block|{
literal|0
block|,
block|{}
block|,
comment|/* should never use! (should hang) */
name|NULL
block|,
operator|&
name|ng_deadnode
operator|.
name|nd_input_queue
operator|.
name|queue
block|,
operator|&
name|ng_deadnode
block|}
block|,
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|ND_MAGIC
block|,
name|__FILE__
block|,
name|__LINE__
block|,
block|{
name|NULL
block|}
endif|#
directive|endif
comment|/* NETGRAPH_DEBUG */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ng_hook
name|ng_deadhook
init|=
block|{
literal|"dead"
block|,
name|NULL
block|,
comment|/* private */
name|HK_INVALID
operator||
name|HK_DEAD
block|,
literal|1
block|,
comment|/* refs always>= 1 */
operator|&
name|ng_deadhook
block|,
comment|/* Peer is self */
operator|&
name|ng_deadnode
block|,
comment|/* attached to deadnode */
block|{}
block|,
comment|/* hooks list */
name|NULL
block|,
comment|/* override rcvmsg() */
name|NULL
block|,
comment|/* override rcvdata() */
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|HK_MAGIC
block|,
name|__FILE__
block|,
name|__LINE__
block|,
block|{
name|NULL
block|}
endif|#
directive|endif
comment|/* NETGRAPH_DEBUG */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * END DEAD STRUCTURES  */
end_comment

begin_comment
comment|/* List nodes with unallocated work */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ng_worklist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ng_worklist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_worklist_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MUST LOCK NODE FIRST */
end_comment

begin_comment
comment|/* List of installed types */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_type
argument_list|)
name|ng_typelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_typelist_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash related definitions */
end_comment

begin_comment
comment|/* XXX Don't need to initialise them because it's a LIST */
end_comment

begin_define
define|#
directive|define
name|NG_ID_HASH_SIZE
value|32
end_define

begin_comment
comment|/* most systems wont need even this many */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ng_ID_hash
index|[
name|NG_ID_HASH_SIZE
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ng_idhash_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Method to find a node.. used twice so do it here */
end_comment

begin_define
define|#
directive|define
name|NG_IDHASH_FN
parameter_list|(
name|ID
parameter_list|)
value|((ID) % (NG_ID_HASH_SIZE))
end_define

begin_define
define|#
directive|define
name|NG_IDHASH_FIND
parameter_list|(
name|ID
parameter_list|,
name|node
parameter_list|)
define|\
value|do { 								\ 		LIST_FOREACH(node,&ng_ID_hash[NG_IDHASH_FN(ID)],	\ 						nd_idnodes) {		\ 			if (NG_NODE_IS_VALID(node)			\&& (NG_NODE_ID(node) == ID)) {			\ 				break;					\ 			}						\ 		}							\ 	} while (0)
end_define

begin_comment
comment|/* Mutex that protects the free queue item list */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|item_p
name|ngqfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free ones */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ngq_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_add_hook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hook_p
modifier|*
name|hookp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_generic_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_ID_t
name|ng_decodeidname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngb_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_worklist_remove
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngintr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_apply_item
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_flush_input_queue
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_setisr
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|node_p
name|ng_ID2noderef
parameter_list|(
name|ng_ID_t
name|ID
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_con_nodes
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|node_p
name|node2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_con_part2
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_con_part3
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_mkpeer
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* imported , these used to be externally visible, some may go back */
end_comment

begin_function_decl
name|int
name|ng_bypass
parameter_list|(
name|hook_p
name|hook1
parameter_list|,
name|hook_p
name|hook2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ng_destroy_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|node_p
name|ng_name2noderef
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ng_path2noderef
parameter_list|(
name|node_p
name|here
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|node_p
modifier|*
name|dest
parameter_list|,
name|hook_p
modifier|*
name|lasthook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ng_type
modifier|*
name|ng_findtype
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ng_make_node
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|node_p
modifier|*
name|nodepp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ng_path_parse
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
modifier|*
name|node
parameter_list|,
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|char
modifier|*
modifier|*
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ng_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|dummy1
parameter_list|,
name|void
modifier|*
name|dummy2
parameter_list|,
name|int
name|dummy3
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|ng_unname
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our own netgraph malloc type */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH
argument_list|,
literal|"netgraph"
argument_list|,
literal|"netgraph structures and ctrl messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_HOOK
argument_list|,
literal|"netgraph_hook"
argument_list|,
literal|"netgraph hook structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_NODE
argument_list|,
literal|"netgraph_node"
argument_list|,
literal|"netgraph node structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_ITEM
argument_list|,
literal|"netgraph_item"
argument_list|,
literal|"netgraph item structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_META
argument_list|,
literal|"netgraph_meta"
argument_list|,
literal|"netgraph name storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_MSG
argument_list|,
literal|"netgraph_msg"
argument_list|,
literal|"netgraph name storage"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Should not be visible outside this file */
end_comment

begin_define
define|#
directive|define
name|_NG_ALLOC_HOOK
parameter_list|(
name|hook
parameter_list|)
define|\
value|MALLOC(hook, hook_p, sizeof(*hook), M_NETGRAPH_HOOK, M_NOWAIT | M_ZERO)
end_define

begin_define
define|#
directive|define
name|_NG_ALLOC_NODE
parameter_list|(
name|node
parameter_list|)
define|\
value|MALLOC(node, node_p, sizeof(*node), M_NETGRAPH_NODE, M_NOWAIT | M_ZERO)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_comment
comment|/*----------------------------------------------*/
end_comment

begin_comment
comment|/*  * In debug mode:  * In an attempt to help track reference count screwups  * we do not free objects back to the malloc system, but keep them  * in a local cache where we can examine them and keep information safely  * after they have been freed.  * We use this scheme for nodes and hooks, and to some extent for items.  */
end_comment

begin_function
specifier|static
name|__inline
name|hook_p
name|ng_alloc_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|ng_hook
argument_list|)
name|temp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ng_freehooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|hook
argument_list|,
name|hk_hooks
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|hook
operator|->
name|hk_all
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hook
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_hook
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|hook
operator|->
name|hk_all
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|hook
operator|->
name|hk_magic
operator|=
name|HK_MAGIC
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|_NG_ALLOC_HOOK
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|hook
operator|->
name|hk_magic
operator|=
name|HK_MAGIC
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_allhooks
argument_list|,
name|hook
argument_list|,
name|hk_all
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|hook
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|node_p
name|ng_alloc_node
parameter_list|(
name|void
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|ng_node
argument_list|)
name|temp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ng_freenodes
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|nd_nodes
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|node
operator|->
name|nd_all
argument_list|,
operator|&
name|temp
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_node
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|temp
argument_list|,
operator|&
name|node
operator|->
name|nd_all
argument_list|,
sizeof|sizeof
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_magic
operator|=
name|ND_MAGIC
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|_NG_ALLOC_NODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
block|{
name|node
operator|->
name|nd_magic
operator|=
name|ND_MAGIC
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_allnodes
argument_list|,
name|node
argument_list|,
name|nd_all
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NG_ALLOC_HOOK
parameter_list|(
name|hook
parameter_list|)
value|do { (hook) = ng_alloc_hook(); } while (0)
end_define

begin_define
define|#
directive|define
name|NG_ALLOC_NODE
parameter_list|(
name|node
parameter_list|)
value|do { (node) = ng_alloc_node(); } while (0)
end_define

begin_define
define|#
directive|define
name|NG_FREE_HOOK
parameter_list|(
name|hook
parameter_list|)
define|\
value|do {								\ 		mtx_lock(&ng_nodelist_mtx);			\ 		LIST_INSERT_HEAD(&ng_freehooks, hook, hk_hooks);	\ 		hook->hk_magic = 0;					\ 		mtx_unlock(&ng_nodelist_mtx);			\ 	} while (0)
end_define

begin_define
define|#
directive|define
name|NG_FREE_NODE
parameter_list|(
name|node
parameter_list|)
define|\
value|do {								\ 		mtx_lock(&ng_nodelist_mtx);			\ 		LIST_INSERT_HEAD(&ng_freenodes, node, nd_nodes);	\ 		node->nd_magic = 0;					\ 		mtx_unlock(&ng_nodelist_mtx);			\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* NETGRAPH_DEBUG */
end_comment

begin_comment
comment|/*----------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|NG_ALLOC_HOOK
parameter_list|(
name|hook
parameter_list|)
value|_NG_ALLOC_HOOK(hook)
end_define

begin_define
define|#
directive|define
name|NG_ALLOC_NODE
parameter_list|(
name|node
parameter_list|)
value|_NG_ALLOC_NODE(node)
end_define

begin_define
define|#
directive|define
name|NG_FREE_HOOK
parameter_list|(
name|hook
parameter_list|)
value|do { FREE((hook), M_NETGRAPH_HOOK); } while (0)
end_define

begin_define
define|#
directive|define
name|NG_FREE_NODE
parameter_list|(
name|node
parameter_list|)
value|do { FREE((node), M_NETGRAPH_NODE); } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETGRAPH_DEBUG */
end_comment

begin_comment
comment|/*----------------------------------------------*/
end_comment

begin_comment
comment|/* Warning: Generally use NG_FREE_ITEM() instead */
end_comment

begin_define
define|#
directive|define
name|NG_FREE_ITEM_REAL
parameter_list|(
name|item
parameter_list|)
value|do { FREE((item), M_NETGRAPH_ITEM); } while (0)
end_define

begin_comment
comment|/* Set this to Debugger("X") to catch all errors as they occur */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRAP_ERROR
end_ifndef

begin_define
define|#
directive|define
name|TRAP_ERROR
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ng_ID_t
name|nextID
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|CHECK_DATA_MBUF
parameter_list|(
name|m
parameter_list|)
value|do {					\ 		struct mbuf *n;						\ 		int total;						\ 									\ 		if (((m)->m_flags& M_PKTHDR) == 0)			\ 			panic("%s: !PKTHDR", __func__);		\ 		for (total = 0, n = (m); n != NULL; n = n->m_next)	\ 			total += n->m_len;				\ 		if ((m)->m_pkthdr.len != total) {			\ 			panic("%s: %d != %d",				\ 			    __func__, (m)->m_pkthdr.len, total);	\ 		}							\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_DATA_MBUF
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************ 	Parse type definitions for generic messages ************************************************************************/
end_comment

begin_comment
comment|/* Handy structure parse type defining macro */
end_comment

begin_define
define|#
directive|define
name|DEFINE_PARSE_STRUCT_TYPE
parameter_list|(
name|lo
parameter_list|,
name|up
parameter_list|,
name|args
parameter_list|)
define|\
value|static const struct ng_parse_struct_field				\ 	ng_ ## lo ## _type_fields[] = NG_GENERIC_ ## up ## _INFO args;	\ static const struct ng_parse_type ng_generic_ ## lo ## _type = {	\&ng_parse_struct_type,						\&ng_ ## lo ## _type_fields					\ }
end_define

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|mkpeer
argument_list|,
name|MKPEER
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|connect
argument_list|,
name|CONNECT
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|name
argument_list|,
name|NAME
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|rmhook
argument_list|,
name|RMHOOK
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|nodeinfo
argument_list|,
name|NODEINFO
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|typeinfo
argument_list|,
name|TYPEINFO
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|linkinfo
argument_list|,
name|LINKINFO
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfo_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get length of an array when the length is stored as a 32 bit    value immediately preceding the array -- as with struct namelist    and struct typelist. */
end_comment

begin_function
specifier|static
name|int
name|ng_generic_list_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|*
operator|(
operator|(
specifier|const
name|u_int32_t
operator|*
operator|)
operator|(
name|buf
operator|-
literal|4
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get length of the array of struct linkinfo inside a struct hooklist */
end_comment

begin_function
specifier|static
name|int
name|ng_generic_linkinfo_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|hooklist
modifier|*
name|hl
init|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|start
decl_stmt|;
return|return
name|hl
operator|->
name|nodeinfo
operator|.
name|hooks
return|;
block|}
end_function

begin_comment
comment|/* Array type for a variable length array of struct namelist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_nodeinfoarray_type_info
init|=
block|{
operator|&
name|ng_generic_nodeinfo_type
block|,
operator|&
name|ng_generic_list_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_nodeinfoarray_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_nodeinfoarray_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type for a variable length array of struct typelist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_typeinfoarray_type_info
init|=
block|{
operator|&
name|ng_generic_typeinfo_type
block|,
operator|&
name|ng_generic_list_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_typeinfoarray_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_typeinfoarray_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type for array of struct linkinfo in struct hooklist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_generic_linkinfo_array_type_info
init|=
block|{
operator|&
name|ng_generic_linkinfo_type
block|,
operator|&
name|ng_generic_linkinfo_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_linkinfo_array_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_generic_linkinfo_array_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|typelist
argument_list|,
name|TYPELIST
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfoarray_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|hooklist
argument_list|,
name|HOOKLIST
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfo_type
operator|,
operator|&
name|ng_generic_linkinfo_array_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|listnodes
argument_list|,
name|LISTNODES
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfoarray_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_generic_cmds
index|[]
init|=
block|{
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_SHUTDOWN
block|,
literal|"shutdown"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_MKPEER
block|,
literal|"mkpeer"
block|,
operator|&
name|ng_generic_mkpeer_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_CONNECT
block|,
literal|"connect"
block|,
operator|&
name|ng_generic_connect_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_NAME
block|,
literal|"name"
block|,
operator|&
name|ng_generic_name_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_RMHOOK
block|,
literal|"rmhook"
block|,
operator|&
name|ng_generic_rmhook_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_NODEINFO
block|,
literal|"nodeinfo"
block|,
name|NULL
block|,
operator|&
name|ng_generic_nodeinfo_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTHOOKS
block|,
literal|"listhooks"
block|,
name|NULL
block|,
operator|&
name|ng_generic_hooklist_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTNAMES
block|,
literal|"listnames"
block|,
name|NULL
block|,
operator|&
name|ng_generic_listnodes_type
comment|/* same as NGM_LISTNODES */
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTNODES
block|,
literal|"listnodes"
block|,
name|NULL
block|,
operator|&
name|ng_generic_listnodes_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTTYPES
block|,
literal|"listtypes"
block|,
name|NULL
block|,
operator|&
name|ng_generic_typeinfo_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_TEXT_CONFIG
block|,
literal|"textconfig"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_TEXT_STATUS
block|,
literal|"textstatus"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_ASCII2BINARY
block|,
literal|"ascii2binary"
block|,
operator|&
name|ng_parse_ng_mesg_type
block|,
operator|&
name|ng_parse_ng_mesg_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_BINARY2ASCII
block|,
literal|"binary2ascii"
block|,
operator|&
name|ng_parse_ng_mesg_type
block|,
operator|&
name|ng_parse_ng_mesg_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			Node routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Instantiate a node of the requested type  */
end_comment

begin_function
name|int
name|ng_make_node
parameter_list|(
specifier|const
name|char
modifier|*
name|typename
parameter_list|,
name|node_p
modifier|*
name|nodepp
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check that the type makes sense */
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Locate the node type */
if|if
condition|(
operator|(
name|type
operator|=
name|ng_findtype
argument_list|(
name|typename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
name|filename
index|[
name|NG_TYPELEN
operator|+
literal|4
index|]
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Not found, try to load it as a loadable module */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ng_%s"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
name|error
operator|=
name|linker_load_module
argument_list|(
name|NULL
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|lf
operator|->
name|userrefs
operator|++
expr_stmt|;
comment|/* pretend loaded by the syscall */
comment|/* Try again, as now the type should have linked itself in */
if|if
condition|(
operator|(
name|type
operator|=
name|ng_findtype
argument_list|(
name|typename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * If we have a constructor, then make the node and 	 * call the constructor to do type specific initialisation. 	 */
if|if
condition|(
name|type
operator|->
name|constructor
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
name|type
argument_list|,
name|nodepp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
operator|(
call|(
modifier|*
name|type
operator|->
name|constructor
call|)
argument_list|(
operator|*
name|nodepp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
operator|*
name|nodepp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Node has no constructor. We cannot ask for one 		 * to be made. It must be brought into existance by 		 * some external agency. The external agency should 		 * call ng_make_node_common() directly to get the 		 * netgraph part initialised. 		 */
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic node creation. Called by node initialisation for externally  * instantiated nodes (e.g. hardware, sockets, etc ).  * The returned node has a reference count of 1.  */
end_comment

begin_function
name|int
name|ng_make_node_common
parameter_list|(
name|struct
name|ng_type
modifier|*
name|type
parameter_list|,
name|node_p
modifier|*
name|nodepp
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
comment|/* Require the node type to have been already installed */
if|if
condition|(
name|ng_findtype
argument_list|(
name|type
operator|->
name|name
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make a node and try attach it to the type */
name|NG_ALLOC_NODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|node
operator|->
name|nd_type
operator|=
name|type
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* note reference */
name|type
operator|->
name|refs
operator|++
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|q_mtx
argument_list|,
literal|"ng_node"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_input_queue
operator|.
name|queue
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|nd_input_queue
operator|.
name|last
operator|=
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|queue
expr_stmt|;
name|node
operator|->
name|nd_input_queue
operator|.
name|q_flags
operator|=
literal|0
expr_stmt|;
name|node
operator|->
name|nd_input_queue
operator|.
name|q_node
operator|=
name|node
expr_stmt|;
comment|/* Initialize hook list for new node */
name|LIST_INIT
argument_list|(
operator|&
name|node
operator|->
name|nd_hooks
argument_list|)
expr_stmt|;
comment|/* Link us into the node linked list */
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_nodelist
argument_list|,
name|node
argument_list|,
name|nd_nodes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
comment|/* get an ID and put us in the hash chain */
name|mtx_lock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* wrap protection, even if silly */
name|node_p
name|node2
init|=
name|NULL
decl_stmt|;
name|node
operator|->
name|nd_ID
operator|=
name|nextID
operator|++
expr_stmt|;
comment|/* 137/second for 1 year before wrap */
comment|/* Is there a problem with the new number? */
name|NG_IDHASH_FIND
argument_list|(
name|node
operator|->
name|nd_ID
argument_list|,
name|node2
argument_list|)
expr_stmt|;
comment|/* already taken? */
if|if
condition|(
operator|(
name|node
operator|->
name|nd_ID
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|node2
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_ID_hash
index|[
name|NG_IDHASH_FN
argument_list|(
name|node
operator|->
name|nd_ID
argument_list|)
index|]
argument_list|,
name|node
argument_list|,
name|nd_idnodes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
comment|/* Done */
operator|*
name|nodepp
operator|=
name|node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forceably start the shutdown process on a node. Either call  * it's shutdown method, or do the default shutdown if there is  * no type-specific method.  *  * We can only be called form a shutdown message, so we know we have  * a writer lock, and therefore exclusive access. It also means  * that we should not be on the work queue, but we check anyhow.  *  * Persistent node types must have a type-specific method which  * Allocates a new node in which case, this one is irretrievably going away,  * or cleans up anything it needs, and just makes the node valid again,  * in which case we allow the node to survive.   *  * XXX We need to think of how to tell a persistant node that we  * REALLY need to go away because the hardware has gone or we  * are rebooting.... etc.  */
end_comment

begin_function
name|void
name|ng_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|dummy1
parameter_list|,
name|void
modifier|*
name|dummy2
parameter_list|,
name|int
name|dummy3
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
comment|/* Check if it's already shutting down */
if|if
condition|(
operator|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_CLOSING
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|node
operator|==
operator|&
name|ng_deadnode
condition|)
block|{
name|printf
argument_list|(
literal|"shutdown called on deadnode\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add an extra reference so it doesn't go away during this */
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * Mark it invalid so any newcomers know not to try use it 	 * Also add our own mark so we can't recurse 	 * note that NG_INVALID does not do this as it's also set during 	 * creation 	 */
name|node
operator|->
name|nd_flags
operator||=
name|NG_INVALID
operator||
name|NG_CLOSING
expr_stmt|;
comment|/* Notify all remaining connected nodes to disconnect */
while|while
condition|(
operator|(
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|node
operator|->
name|nd_hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* 	 * Drain the input queue forceably. 	 * it has no hooks so what's it going to do, bleed on someone? 	 * Theoretically we came here from a queue entry that was added 	 * Just before the queue was closed, so it should be empty anyway. 	 * Also removes us from worklist if needed. 	 */
name|ng_flush_input_queue
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
argument_list|)
expr_stmt|;
comment|/* Ask the type if it has anything to do in this case */
if|if
condition|(
name|node
operator|->
name|nd_type
operator|&&
name|node
operator|->
name|nd_type
operator|->
name|shutdown
condition|)
block|{
call|(
modifier|*
name|node
operator|->
name|nd_type
operator|->
name|shutdown
call|)
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* 			 * Well, blow me down if the node code hasn't declared 			 * that it doesn't want to die. 			 * Presumably it is a persistant node. 			 * If we REALLY want it to go away, 			 *  e.g. hardware going away, 			 * Our caller should set NG_REALLY_DIE in nd_flags. 			 */
name|node
operator|->
name|nd_flags
operator|&=
operator|~
operator|(
name|NG_INVALID
operator||
name|NG_CLOSING
operator|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Assume they still have theirs */
return|return;
block|}
block|}
else|else
block|{
comment|/* do the default thing */
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* basically a NOP these days */
comment|/* 	 * Remove extra reference, possibly the last 	 * Possible other holders of references may include 	 * timeout callouts, but theoretically the node's supposed to 	 * have cancelled them. Possibly hardware dependencies may 	 * force a driver to 'linger' with a reference. 	 */
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_function
name|void
name|ng_ref_node
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|_NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Remove a reference to the node, possibly the last.  * deadnode always acts as it it were the last.  */
end_comment

begin_function
name|int
name|ng_unref_node
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
name|node
operator|==
operator|&
name|ng_deadnode
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|do
block|{
name|v
operator|=
name|node
operator|->
name|nd_refs
operator|-
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|node
operator|->
name|nd_refs
argument_list|,
name|v
operator|+
literal|1
argument_list|,
name|v
argument_list|)
condition|)
do|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
comment|/* we were the last */
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_type
operator|->
name|refs
operator|--
expr_stmt|;
comment|/* XXX maybe should get types lock? */
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|nd_nodes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|nd_idnodes
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
name|NG_FREE_NODE
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Node ID handling ************************************************************************/
end_comment

begin_function
specifier|static
name|node_p
name|ng_ID2noderef
parameter_list|(
name|ng_ID_t
name|ID
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
name|NG_IDHASH_FIND
argument_list|(
name|ID
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
condition|)
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
name|ng_ID_t
name|ng_node2ID
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
condition|?
name|NG_NODE_ID
argument_list|(
name|node
argument_list|)
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Node name handling ************************************************************************/
end_comment

begin_comment
comment|/*  * Assign a node a name. Once assigned, the name cannot be changed.  */
end_comment

begin_function
name|int
name|ng_name_node
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|node_p
name|node2
decl_stmt|;
comment|/* Check the name is valid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_NODELEN
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|name
index|[
name|i
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ng_decodeidname
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* valid IDs not allowed here */
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check the name isn't already being used */
if|if
condition|(
operator|(
name|node2
operator|=
name|ng_name2noderef
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
comment|/* copy it */
name|strncpy
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|name
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a node by absolute name. The name should NOT end with ':'  * The name "." means "this node" and "[xxx]" means "the node  * with ID (ie, at address) xxx".  *  * Returns the node if found, else NULL.  * Eventually should add something faster than a sequential search.  * Note it aquires a reference on the node so you can be sure it's still there.  */
end_comment

begin_function
name|node_p
name|ng_name2noderef
parameter_list|(
name|node_p
name|here
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
name|ng_ID_t
name|temp
decl_stmt|;
comment|/* "." means "this node" */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|NG_NODE_REF
argument_list|(
name|here
argument_list|)
expr_stmt|;
return|return
operator|(
name|here
operator|)
return|;
block|}
comment|/* Check for name-by-ID */
if|if
condition|(
operator|(
name|temp
operator|=
name|ng_decodeidname
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ng_ID2noderef
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
comment|/* Find node by name */
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&ng_nodelist
argument_list|,
argument|nd_nodes
argument_list|)
block|{
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|&&
name|NG_NODE_HAS_NAME
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|node
condition|)
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode an ID name, eg. "[f03034de]". Returns 0 if the  * string is not valid, otherwise returns the value.  */
end_comment

begin_function
specifier|static
name|ng_ID_t
name|ng_decodeidname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|u_long
name|val
decl_stmt|;
comment|/* Check for proper length, brackets, no leading junk */
if|if
condition|(
operator|(
name|len
operator|<
literal|3
operator|)
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'['
operator|)
operator|||
operator|(
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|']'
operator|)
operator|||
operator|(
operator|!
name|isxdigit
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|ng_ID_t
operator|)
literal|0
operator|)
return|;
block|}
comment|/* Decode number */
name|val
operator|=
name|strtoul
argument_list|(
name|name
operator|+
literal|1
argument_list|,
operator|&
name|eptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eptr
operator|-
name|name
operator|!=
name|len
operator|-
literal|1
operator|)
operator|||
operator|(
name|val
operator|==
name|ULONG_MAX
operator|)
operator|||
operator|(
name|val
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
operator|(
name|ng_ID_t
operator|)
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ng_ID_t
operator|)
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from a node. This should only be called  * when shutting down and removing the node.  * IF we allow name changing this may be more resurected.  */
end_comment

begin_function
name|void
name|ng_unname
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{ }
end_function

begin_comment
comment|/************************************************************************ 			Hook routines  Names are not optional. Hooks are always connected, except for a  brief moment within these routines. On invalidation or during creation  they are connected to the 'dead' hook. ************************************************************************/
end_comment

begin_comment
comment|/*  * Remove a hook reference  */
end_comment

begin_function
name|void
name|ng_unref_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
if|if
condition|(
name|hook
operator|==
operator|&
name|ng_deadhook
condition|)
block|{
return|return;
block|}
do|do
block|{
name|v
operator|=
name|hook
operator|->
name|hk_refs
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|hook
operator|->
name|hk_refs
argument_list|,
name|v
argument_list|,
name|v
operator|-
literal|1
argument_list|)
condition|)
do|;
if|if
condition|(
name|v
operator|==
literal|1
condition|)
block|{
comment|/* we were the last */
if|if
condition|(
name|_NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
condition|)
block|{
comment|/* it'll probably be ng_deadnode */
name|_NG_NODE_UNREF
argument_list|(
operator|(
name|_NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|hook
operator|->
name|hk_node
operator|=
name|NULL
expr_stmt|;
block|}
name|NG_FREE_HOOK
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add an unconnected hook to a node. Only used internally.  * Assumes node is locked. (XXX not yet true )  */
end_comment

begin_function
specifier|static
name|int
name|ng_add_hook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hook_p
modifier|*
name|hookp
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check that the given name is good */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* Allocate the hook and link it up */
name|NG_ALLOC_HOOK
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|hook
operator|->
name|hk_refs
operator|=
literal|1
expr_stmt|;
comment|/* add a reference for us to return */
name|hook
operator|->
name|hk_flags
operator|=
name|HK_INVALID
expr_stmt|;
name|hook
operator|->
name|hk_peer
operator|=
operator|&
name|ng_deadhook
expr_stmt|;
comment|/* start off this way */
name|hook
operator|->
name|hk_node
operator|=
name|node
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* each hook counts as a reference */
comment|/* Set hook name */
name|strncpy
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|name
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the node type code has something to say about it 	 * If it fails, the unref of the hook will also unref the node. 	 */
if|if
condition|(
name|node
operator|->
name|nd_type
operator|->
name|newhook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|node
operator|->
name|nd_type
operator|->
name|newhook
call|)
argument_list|(
name|node
argument_list|,
name|hook
argument_list|,
name|name
argument_list|)
operator|)
condition|)
block|{
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* this frees the hook */
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * The 'type' agrees so far, so go ahead and link it in. 	 * We'll ask again later when we actually connect the hooks. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|node
operator|->
name|nd_hooks
argument_list|,
name|hook
argument_list|,
name|hk_hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_numhooks
operator|++
expr_stmt|;
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* one for the node */
if|if
condition|(
name|hookp
condition|)
operator|*
name|hookp
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a hook  *  * Node types may supply their own optimized routines for finding  * hooks.  If none is supplied, we just do a linear search.  * XXX Possibly we should add a reference to the hook?  */
end_comment

begin_function
name|hook_p
name|ng_findhook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|nd_type
operator|->
name|findhook
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|node
operator|->
name|nd_type
operator|->
name|findhook
call|)
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
return|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
if|if
condition|(
name|NG_HOOK_IS_VALID
argument_list|(
name|hook
argument_list|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|hook
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a hook  *  * As hooks are always attached, this really destroys two hooks.  * The one given, and the one attached to it. Disconnect the hooks  * from each other first. We reconnect the peer hook to the 'dead'  * hook so that it can still exist after we depart. We then  * send the peer its own destroy message. This ensures that we only  * interact with the peer's structures when it is locked processing that   * message. We hold a reference to the peer hook so we are guaranteed that  * the peer hook and node are still going to exist until  * we are finished there as the hook holds a ref on the node.  * We run this same code again on the peer hook, but that time it is already   * attached to the 'dead' hook.   *  * This routine is called at all stages of hook creation   * on error detection and must be able to handle any such stage.  */
end_comment

begin_function
name|void
name|ng_destroy_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|hook_p
name|peer
init|=
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|hook
operator|==
operator|&
name|ng_deadhook
condition|)
block|{
comment|/* better safe than sorry */
name|printf
argument_list|(
literal|"ng_destroy_hook called on deadhook\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|hook
operator|->
name|hk_flags
operator||=
name|HK_INVALID
expr_stmt|;
comment|/* as soon as possible */
if|if
condition|(
name|peer
operator|&&
operator|(
name|peer
operator|!=
operator|&
name|ng_deadhook
operator|)
condition|)
block|{
comment|/* 		 * Set the peer to point to ng_deadhook 		 * from this moment on we are effectively independent it. 		 * send it an rmhook message of it's own. 		 */
name|peer
operator|->
name|hk_peer
operator|=
operator|&
name|ng_deadhook
expr_stmt|;
comment|/* They no longer know us */
name|hook
operator|->
name|hk_peer
operator|=
operator|&
name|ng_deadhook
expr_stmt|;
comment|/* Nor us, them */
if|if
condition|(
name|NG_HOOK_NODE
argument_list|(
name|peer
argument_list|)
operator|==
operator|&
name|ng_deadnode
condition|)
block|{
comment|/*  			 * If it's already divorced from a node, 			 * just free it. 			 */
comment|/* nothing */
block|}
else|else
block|{
name|ng_rmhook_self
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* Send it a surprise */
block|}
name|NG_HOOK_UNREF
argument_list|(
name|peer
argument_list|)
expr_stmt|;
comment|/* account for peer link */
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* account for peer link */
block|}
comment|/* 	 * Remove the hook from the node's list to avoid possible recursion 	 * in case the disconnection results in node shutdown. 	 */
if|if
condition|(
name|node
operator|==
operator|&
name|ng_deadnode
condition|)
block|{
comment|/* happens if called from ng_con_nodes() */
return|return;
block|}
name|LIST_REMOVE
argument_list|(
name|hook
argument_list|,
name|hk_hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_numhooks
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nd_type
operator|->
name|disconnect
condition|)
block|{
comment|/* 		 * The type handler may elect to destroy the node so don't 		 * trust its existance after this point. (except  		 * that we still hold a reference on it. (which we 		 * inherrited from the hook we are destroying) 		 */
call|(
modifier|*
name|node
operator|->
name|nd_type
operator|->
name|disconnect
call|)
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note that because we will point to ng_deadnode, the original node 	 * is not decremented automatically so we do that manually. 	 */
name|_NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
operator|=
operator|&
name|ng_deadnode
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* We no longer point to it so adjust count */
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* Account for linkage (in list) to node */
block|}
end_function

begin_comment
comment|/*  * Take two hooks on a node and merge the connection so that the given node  * is effectively bypassed.  */
end_comment

begin_function
name|int
name|ng_bypass
parameter_list|(
name|hook_p
name|hook1
parameter_list|,
name|hook_p
name|hook2
parameter_list|)
block|{
if|if
condition|(
name|hook1
operator|->
name|hk_node
operator|!=
name|hook2
operator|->
name|hk_node
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|hook1
operator|->
name|hk_peer
operator|->
name|hk_peer
operator|=
name|hook2
operator|->
name|hk_peer
expr_stmt|;
name|hook2
operator|->
name|hk_peer
operator|->
name|hk_peer
operator|=
name|hook1
operator|->
name|hk_peer
expr_stmt|;
name|hook1
operator|->
name|hk_peer
operator|=
operator|&
name|ng_deadhook
expr_stmt|;
name|hook2
operator|->
name|hk_peer
operator|=
operator|&
name|ng_deadhook
expr_stmt|;
comment|/* XXX If we ever cache methods on hooks update them as well */
name|ng_destroy_hook
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install a new netgraph type  */
end_comment

begin_function
name|int
name|ng_newtype
parameter_list|(
name|struct
name|ng_type
modifier|*
name|tp
parameter_list|)
block|{
specifier|const
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|tp
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* Check version and type name fields */
if|if
condition|(
operator|(
name|tp
operator|->
name|version
operator|!=
name|NG_ABI_VERSION
operator|)
operator|||
operator|(
name|namelen
operator|==
literal|0
operator|)
operator|||
operator|(
name|namelen
operator|>
name|NG_TYPELEN
operator|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check for name collision */
if|if
condition|(
name|ng_findtype
argument_list|(
name|tp
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* Link in new type */
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ng_typelist
argument_list|,
name|tp
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|tp
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
comment|/* first ref is linked list */
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unlink a netgraph type  * If no examples exist  */
end_comment

begin_function
name|int
name|ng_rmtype
parameter_list|(
name|struct
name|ng_type
modifier|*
name|tp
parameter_list|)
block|{
comment|/* Check for name collision */
if|if
condition|(
name|tp
operator|->
name|refs
operator|!=
literal|1
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* Unlink type */
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|tp
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for a type of the name given  */
end_comment

begin_function
name|struct
name|ng_type
modifier|*
name|ng_findtype
parameter_list|(
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&ng_typelist
argument_list|,
argument|types
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
operator|->
name|name
argument_list|,
name|typename
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Composite routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Connect two nodes using the specified hooks, using queued functions.  */
end_comment

begin_function
specifier|static
name|void
name|ng_con_part3
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
comment|/* 	 * When we run, we know that the node 'node' is locked for us. 	 * Our caller has a reference on the hook. 	 * Our caller has a reference on the node. 	 * (In this case our caller is ng_apply_item() ). 	 * The peer hook has a reference on the hook. 	 * We are all set up except for the final call to the node, and 	 * the clearing of the INVALID flag. 	 */
if|if
condition|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
operator|==
operator|&
name|ng_deadnode
condition|)
block|{
comment|/* 		 * The node must have been freed again since we last visited 		 * here. ng_destry_hook() has this effect but nothing else does. 		 * We should just release our references and 		 * free anything we can think of. 		 * Since we know it's been destroyed, and it's our caller 		 * that holds the references, just return. 		 */
return|return ;
block|}
if|if
condition|(
name|hook
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|hook
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
call|)
argument_list|(
name|hook
argument_list|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* also zaps peer */
name|printf
argument_list|(
literal|"failed in ng_con_part3()\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
block|}
comment|/* 	 *  XXX this is wrong for SMP. Possibly we need 	 * to separate out 'create' and 'invalid' flags. 	 * should only set flags on hooks we have locked under our node. 	 */
name|hook
operator|->
name|hk_flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
return|return ;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_con_part2
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
comment|/* 	 * When we run, we know that the node 'node' is locked for us. 	 * Our caller has a reference on the hook. 	 * Our caller has a reference on the node. 	 * (In this case our caller is ng_apply_item() ). 	 * The peer hook has a reference on the hook. 	 * our node pointer points to the 'dead' node. 	 * First check the hook name is unique. 	 * Should not happen because we checked before queueing this. 	 */
if|if
condition|(
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* should destroy peer too */
name|printf
argument_list|(
literal|"failed in ng_con_part2()\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
comment|/* 	 * Check if the node type code has something to say about it 	 * If it fails, the unref of the hook will also unref the attached node, 	 * however since that node is 'ng_deadnode' this will do nothing. 	 * The peer hook will also be destroyed. 	 */
if|if
condition|(
name|node
operator|->
name|nd_type
operator|->
name|newhook
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|node
operator|->
name|nd_type
operator|->
name|newhook
call|)
argument_list|(
name|node
argument_list|,
name|hook
argument_list|,
name|hook
operator|->
name|hk_name
argument_list|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* should destroy peer too */
name|printf
argument_list|(
literal|"failed in ng_con_part2()\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
block|}
comment|/* 	 * The 'type' agrees so far, so go ahead and link it in. 	 * We'll ask again later when we actually connect the hooks. 	 */
name|hook
operator|->
name|hk_node
operator|=
name|node
expr_stmt|;
comment|/* just overwrite ng_deadnode */
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* each hook counts as a reference */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|node
operator|->
name|nd_hooks
argument_list|,
name|hook
argument_list|,
name|hk_hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|nd_numhooks
operator|++
expr_stmt|;
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* one for the node */
comment|/* 	 * We now have a symetrical situation, where both hooks have been 	 * linked to their nodes, the newhook methods have been called 	 * And the references are all correct. The hooks are still marked 	 * as invalid, as we have not called the 'connect' methods 	 * yet. 	 * We can call the local one immediatly as we have the  	 * node locked, but we need to queue the remote one. 	 */
if|if
condition|(
name|hook
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|hook
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
call|)
argument_list|(
name|hook
argument_list|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* also zaps peer */
name|printf
argument_list|(
literal|"failed in ng_con_part2(A)\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
block|}
if|if
condition|(
name|ng_send_fn
argument_list|(
name|hook
operator|->
name|hk_peer
operator|->
name|hk_node
argument_list|,
name|hook
operator|->
name|hk_peer
argument_list|,
operator|&
name|ng_con_part3
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"failed in ng_con_part2(B)"
argument_list|)
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* also zaps peer */
return|return ;
block|}
name|hook
operator|->
name|hk_flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
comment|/* need both to be able to work */
return|return ;
block|}
end_function

begin_comment
comment|/*  * Connect this node with another node. We assume that this node is   * currently locked, as we are only called from an NGM_CONNECT message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_con_nodes
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|node_p
name|node2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|hook2
decl_stmt|;
if|if
condition|(
name|ng_findhook
argument_list|(
name|node2
argument_list|,
name|name2
argument_list|)
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|hook
argument_list|)
operator|)
condition|)
comment|/* gives us a ref */
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate the other hook and link it up */
name|NG_ALLOC_HOOK
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* XXX check ref counts so far */
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* including our ref */
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|hook2
operator|->
name|hk_refs
operator|=
literal|1
expr_stmt|;
comment|/* start with a reference for us. */
name|hook2
operator|->
name|hk_flags
operator|=
name|HK_INVALID
expr_stmt|;
name|hook2
operator|->
name|hk_peer
operator|=
name|hook
expr_stmt|;
comment|/* Link the two together */
name|hook
operator|->
name|hk_peer
operator|=
name|hook2
expr_stmt|;
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* Add a ref for the peer to each*/
name|NG_HOOK_REF
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
name|hook2
operator|->
name|hk_node
operator|=
operator|&
name|ng_deadnode
expr_stmt|;
name|strncpy
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook2
argument_list|)
argument_list|,
name|name2
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
comment|/* 	 * Queue the function above. 	 * Procesing continues in that function in the lock context of 	 * the other node. 	 */
name|ng_send_fn
argument_list|(
name|node2
argument_list|,
name|hook2
argument_list|,
operator|&
name|ng_con_part2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* Let each hook go if it wants to */
name|NG_HOOK_UNREF
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a peer and connect.  * We assume that the local node is locked.  * The new node probably doesn't need a lock until  * it has a hook, because it cannot really have any work until then,  * but we should think about it a bit more.  *  * The problem may come if the other node also fires up  * some hardware or a timer or some other source of activation,  * also it may already get a command msg via it's ID.  *  * We could use the same method as ng_con_nodes() but we'd have  * to add ability to remove the node when failing. (Not hard, just   * make arg1 point to the node to remove).  * Unless of course we just ignore failure to connect and leave  * an unconnected node?  */
end_comment

begin_function
specifier|static
name|int
name|ng_mkpeer
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|node_p
name|node2
decl_stmt|;
name|hook_p
name|hook1
decl_stmt|;
name|hook_p
name|hook2
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node
argument_list|(
name|type
argument_list|,
operator|&
name|node2
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|hook1
argument_list|)
operator|)
condition|)
block|{
comment|/* gives us a ref */
name|ng_rmnode
argument_list|(
name|node2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node2
argument_list|,
name|name2
argument_list|,
operator|&
name|hook2
argument_list|)
operator|)
condition|)
block|{
name|ng_rmnode
argument_list|(
name|node2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
name|NG_HOOK_UNREF
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Actually link the two hooks together. 	 */
name|hook1
operator|->
name|hk_peer
operator|=
name|hook2
expr_stmt|;
name|hook2
operator|->
name|hk_peer
operator|=
name|hook1
expr_stmt|;
comment|/* Each hook is referenced by the other */
name|NG_HOOK_REF
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
name|NG_HOOK_REF
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
comment|/* Give each node the opportunity to veto the pending connection */
if|if
condition|(
name|hook1
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|hook1
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
call|)
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
name|hook2
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|hook2
operator|->
name|hk_node
operator|->
name|nd_type
operator|->
name|connect
call|)
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * drop the references we were holding on the two hooks. 	 */
if|if
condition|(
name|error
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
comment|/* also zaps hook1 */
name|ng_rmnode
argument_list|(
name|node2
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* As a last act, allow the hooks to be used */
name|hook1
operator|->
name|hk_flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
name|hook2
operator|->
name|hk_flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
block|}
name|NG_HOOK_UNREF
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
name|NG_HOOK_UNREF
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 		Utility routines to send self messages ************************************************************************/
end_comment

begin_comment
comment|/* Shut this node down as soon as everyone is clear of it */
end_comment

begin_comment
comment|/* Should add arg "immediatly" to jump the queue */
end_comment

begin_function
name|int
name|ng_rmnode_self
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|node
operator|==
operator|&
name|ng_deadnode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|node
operator|->
name|nd_flags
operator||=
name|NG_INVALID
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_CLOSING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|ng_send_fn
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|ng_rmnode
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_rmhook_part2
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return ;
block|}
end_function

begin_function
name|int
name|ng_rmhook_self
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|==
operator|&
name|ng_deadnode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|ng_send_fn
argument_list|(
name|node
argument_list|,
name|hook
argument_list|,
operator|&
name|ng_rmhook_part2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * Parse and verify a string of the form:<NODE:><PATH>  *  * Such a string can refer to a specific node or a specific hook  * on a specific node, depending on how you look at it. In the  * latter case, the PATH component must not end in a dot.  *  * Both<NODE:> and<PATH> are optional. The<PATH> is a string  * of hook names separated by dots. This breaks out the original  * string, setting *nodep to "NODE" (or NULL if none) and *pathp  * to "PATH" (or NULL if degenerate). Also, *hookp will point to  * the final hook component of<PATH>, if any, otherwise NULL.  *  * This returns -1 if the path is malformed. The char ** are optional.  ***********************************************************************/
end_comment

begin_function
name|int
name|ng_path_parse
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
modifier|*
name|nodep
parameter_list|,
name|char
modifier|*
modifier|*
name|pathp
parameter_list|,
name|char
modifier|*
modifier|*
name|hookp
parameter_list|)
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|hook
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* 	 * Extract absolute NODE, if any 	 */
for|for
control|(
name|path
operator|=
name|addr
init|;
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|;
name|path
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|path
condition|)
block|{
name|node
operator|=
name|addr
expr_stmt|;
comment|/* Here's the NODE */
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Here's the PATH */
comment|/* Node name must not be empty */
if|if
condition|(
operator|!
operator|*
name|node
condition|)
return|return
operator|-
literal|1
return|;
comment|/* A name of "." is OK; otherwise '.' not allowed */
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|node
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|node
index|[
name|k
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* No absolute NODE */
name|path
operator|=
name|addr
expr_stmt|;
comment|/* Here's the PATH */
block|}
comment|/* Snoop for illegal characters in PATH */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|':'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check for no repeated dots in PATH */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|'.'
operator|&&
name|path
index|[
name|k
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Remove extra (degenerate) dots from beginning or end of PATH */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|path
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|&&
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If PATH has a dot, then we're not talking about a hook */
if|if
condition|(
operator|*
name|path
condition|)
block|{
for|for
control|(
name|hook
operator|=
name|path
operator|,
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|'.'
condition|)
block|{
name|hook
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|path
operator|=
name|hook
operator|=
name|NULL
expr_stmt|;
comment|/* Done */
if|if
condition|(
name|nodep
condition|)
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|pathp
condition|)
operator|*
name|pathp
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|hookp
condition|)
operator|*
name|hookp
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path, which may be absolute or relative, and a starting node,  * return the destination node.  */
end_comment

begin_function
name|int
name|ng_path2noderef
parameter_list|(
name|node_p
name|here
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|node_p
modifier|*
name|destp
parameter_list|,
name|hook_p
modifier|*
name|lasthook
parameter_list|)
block|{
name|char
name|fullpath
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|,
modifier|*
name|path
decl_stmt|,
name|pbuf
index|[
literal|2
index|]
decl_stmt|;
name|node_p
name|node
decl_stmt|,
name|oldnode
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
comment|/* Initialize */
if|if
condition|(
name|destp
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
operator|*
name|destp
operator|=
name|NULL
expr_stmt|;
comment|/* Make a writable copy of address for ng_path_parse() */
name|strncpy
argument_list|(
name|fullpath
argument_list|,
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|fullpath
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fullpath
index|[
sizeof|sizeof
argument_list|(
name|fullpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse out node and sequence of hooks */
if|if
condition|(
name|ng_path_parse
argument_list|(
name|fullpath
argument_list|,
operator|&
name|nodename
argument_list|,
operator|&
name|path
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|pbuf
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
comment|/* Needs to be writable */
name|pbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|pbuf
expr_stmt|;
block|}
comment|/* 	 * For an absolute address, jump to the starting node. 	 * Note that this holds a reference on the node for us. 	 * Don't forget to drop the reference if we don't need it. 	 */
if|if
condition|(
name|nodename
condition|)
block|{
name|node
operator|=
name|ng_name2noderef
argument_list|(
name|here
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|here
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|node
operator|=
name|here
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now follow the sequence of hooks  	 * XXX 	 * We actually cannot guarantee that the sequence 	 * is not being demolished as we crawl along it 	 * without extra-ordinary locking etc. 	 * So this is a bit dodgy to say the least. 	 * We can probably hold up some things by holding 	 * the nodelist mutex for the time of this 	 * crawl if we wanted.. At least that way we wouldn't have to 	 * worry about the nodes dissappearing, but the hooks would still 	 * be a problem. 	 */
for|for
control|(
name|cp
operator|=
name|path
init|;
name|node
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|char
modifier|*
name|segment
decl_stmt|;
comment|/* 		 * Break out the next path segment. Replace the dot we just 		 * found with a NUL; "cp" points to the next segment (or the 		 * NUL at the end). 		 */
for|for
control|(
name|segment
operator|=
name|cp
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Empty segment */
if|if
condition|(
operator|*
name|segment
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* We have a segment, so look for a hook by that name */
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|segment
argument_list|)
expr_stmt|;
comment|/* Can't get there from here... */
if|if
condition|(
name|hook
operator|==
name|NULL
operator|||
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
operator|==
name|NULL
operator|||
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
operator|||
name|NG_HOOK_NOT_VALID
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("hooknotvalid %s %s %d %d %d %d ", 					path, 					segment, 					hook == NULL, 		     			NG_HOOK_PEER(hook) == NULL, 		     			NG_HOOK_NOT_VALID(hook), 		     			NG_HOOK_NOT_VALID(NG_HOOK_PEER(hook)));
endif|#
directive|endif
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 		 * Hop on over to the next node  		 * XXX 		 * Big race conditions here as hooks and nodes go away  		 * *** Idea.. store an ng_ID_t in each hook and use that 		 * instead of the direct hook in this crawl? 		 */
name|oldnode
operator|=
name|node
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
operator|)
condition|)
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* XXX RACE */
name|NG_NODE_UNREF
argument_list|(
name|oldnode
argument_list|)
expr_stmt|;
comment|/* XXX another race */
if|if
condition|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* XXX more races */
name|node
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If node somehow missing, fail here (probably this is not needed) */
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Done */
operator|*
name|destp
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|lasthook
operator|!=
name|NULL
condition|)
operator|*
name|lasthook
operator|=
operator|(
name|hook
condition|?
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
else|:
name|NULL
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Input queue handling. * All activities are submitted to the node via the input queue * which implements a multiple-reader/single-writer gate. * Items which cannot be handled immeditly are queued. * * read-write queue locking inline functions			* \***************************************************************/
end_comment

begin_function_decl
specifier|static
name|__inline
name|item_p
name|ng_dequeue
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|item_p
name|ng_acquire_read
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|item_p
name|ng_acquire_write
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ng_leave_read
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ng_leave_write
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|ng_queue_rw
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|,
name|int
name|rw
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Definition of the bits fields in the ng_queue flag word.  * Defined here rather than in netgraph.h because no-one should fiddle  * with them.  *  * The ordering here may be important! don't shuffle these.  */
end_comment

begin_comment
comment|/*-  Safety Barrier--------+ (adjustable to suit taste) (not used yet)                        |                        V +-------+-------+-------+-------+-------+-------+-------+-------+ | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |A|c|t|i|v|e| |R|e|a|d|e|r| |C|o|u|n|t| | | | | | | | | |R|A|W| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |P|W|P| +-------+-------+-------+-------+-------+-------+-------+-------+ \___________________________ ____________________________/ | | |                             V                              | | |                   [active reader count]                    | | |                                                            | | |           Read Pending ------------------------------------+ | |                                                              | |           Active Writer -------------------------------------+ |                                                                |           Write Pending ---------------------------------------+   */
end_comment

begin_define
define|#
directive|define
name|WRITE_PENDING
value|0x00000001
end_define

begin_define
define|#
directive|define
name|WRITER_ACTIVE
value|0x00000002
end_define

begin_define
define|#
directive|define
name|READ_PENDING
value|0x00000004
end_define

begin_define
define|#
directive|define
name|READER_INCREMENT
value|0x00000008
end_define

begin_define
define|#
directive|define
name|READER_MASK
value|0xfffffff0
end_define

begin_comment
comment|/* Not valid if WRITER_ACTIVE is set */
end_comment

begin_define
define|#
directive|define
name|SAFETY_BARRIER
value|0x00100000
end_define

begin_comment
comment|/* 64K items queued should be enough */
end_comment

begin_comment
comment|/* Defines of more elaborate states on the queue */
end_comment

begin_comment
comment|/* Mask of bits a read cares about */
end_comment

begin_define
define|#
directive|define
name|NGQ_RMASK
value|(WRITE_PENDING|WRITER_ACTIVE|READ_PENDING)
end_define

begin_comment
comment|/* Mask of bits a write cares about */
end_comment

begin_define
define|#
directive|define
name|NGQ_WMASK
value|(NGQ_RMASK|READER_MASK)
end_define

begin_comment
comment|/* tests to decide if we could get a read or write off the queue */
end_comment

begin_define
define|#
directive|define
name|CAN_GET_READ
parameter_list|(
name|flag
parameter_list|)
value|((flag& NGQ_RMASK) == READ_PENDING)
end_define

begin_define
define|#
directive|define
name|CAN_GET_WRITE
parameter_list|(
name|flag
parameter_list|)
value|((flag& NGQ_WMASK) == WRITE_PENDING)
end_define

begin_comment
comment|/* Is there a chance of getting ANY work off the queue? */
end_comment

begin_define
define|#
directive|define
name|CAN_GET_WORK
parameter_list|(
name|flag
parameter_list|)
value|(CAN_GET_READ(flag) || CAN_GET_WRITE(flag))
end_define

begin_comment
comment|/*  * Taking into account the current state of the queue and node, possibly take  * the next entry off the queue and return it. Return NULL if there was  * nothing we could return, either because there really was nothing there, or  * because the node was in a state where it cannot yet process the next item  * on the queue.  *  * This MUST MUST MUST be called with the mutex held.  */
end_comment

begin_function
specifier|static
name|__inline
name|item_p
name|ng_dequeue
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
name|u_int
name|add_arg
decl_stmt|;
if|if
condition|(
name|CAN_GET_READ
argument_list|(
name|ngq
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* 		 * Head of queue is a reader and we have no write active. 		 * We don't care how many readers are already active.  		 * Adjust the flags for the item we are about to dequeue. 		 * Add the correct increment for the reader count as well. 		 */
name|add_arg
operator|=
operator|(
name|READER_INCREMENT
operator|-
name|READ_PENDING
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CAN_GET_WRITE
argument_list|(
name|ngq
operator|->
name|q_flags
argument_list|)
condition|)
block|{
comment|/* 		 * There is a pending write, no readers and no active writer. 		 * This means we can go ahead with the pending writer. Note 		 * the fact that we now have a writer, ready for when we take 		 * it off the queue. 		 * 		 * We don't need to worry about a possible collision with the 		 * fasttrack reader. 		 * 		 * The fasttrack thread may take a long time to discover that we 		 * are running so we would have an inconsistent state in the 		 * flags for a while. Since we ignore the reader count 		 * entirely when the WRITER_ACTIVE flag is set, this should 		 * not matter (in fact it is defined that way). If it tests 		 * the flag before this operation, the WRITE_PENDING flag 		 * will make it fail, and if it tests it later, the 		 * WRITER_ACTIVE flag will do the same. If it is SO slow that 		 * we have actually completed the operation, and neither flag 		 * is set (nor the READ_PENDING) by the time that it tests 		 * the flags, then it is actually ok for it to continue. If 		 * it completes and we've finished and the read pending is 		 * set it still fails. 		 * 		 * So we can just ignore it,  as long as we can ensure that the 		 * transition from WRITE_PENDING state to the WRITER_ACTIVE 		 * state is atomic. 		 * 		 * After failing, first it will be held back by the mutex, then 		 * when it can proceed, it will queue its request, then it 		 * would arrive at this function. Usually it will have to 		 * leave empty handed because the ACTIVE WRITER bit will be 		 * set. 		 * 		 * Adjust the flags for the item we are about to dequeue 		 * and for the new active writer. 		 */
name|add_arg
operator|=
operator|(
name|WRITER_ACTIVE
operator|-
name|WRITE_PENDING
operator|)
expr_stmt|;
comment|/* 		 * We want to write "active writer, no readers " Now go make 		 * it true. In fact there may be a number in the readers 		 * count but we know it is not true and will be fixed soon. 		 * We will fix the flags for the next pending entry in a 		 * moment. 		 */
block|}
else|else
block|{
comment|/* 		 * We can't dequeue anything.. return and say so. Probably we 		 * have a write pending and the readers count is non zero. If 		 * we got here because a reader hit us just at the wrong 		 * moment with the fasttrack code, and put us in a strange 		 * state, then it will be through in just a moment, (as soon 		 * as we release the mutex) and keep things moving. 		 * Make sure we remove ourselves from the work queue. 		 */
name|ng_worklist_remove
argument_list|(
name|ngq
operator|->
name|q_node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now we dequeue the request (whatever it may be) and correct the 	 * pending flags and the next and last pointers. 	 */
name|item
operator|=
name|ngq
operator|->
name|queue
expr_stmt|;
name|ngq
operator|->
name|queue
operator|=
name|item
operator|->
name|el_next
expr_stmt|;
if|if
condition|(
name|ngq
operator|->
name|last
operator|==
operator|&
operator|(
name|item
operator|->
name|el_next
operator|)
condition|)
block|{
comment|/* 		 * that was the last entry in the queue so set the 'last 		 * pointer up correctly and make sure the pending flags are 		 * clear. 		 */
name|ngq
operator|->
name|last
operator|=
operator|&
operator|(
name|ngq
operator|->
name|queue
operator|)
expr_stmt|;
comment|/* 		 * Whatever flag was set will be cleared and 		 * the new acive field will be set by the add as well, 		 * so we don't need to change add_arg. 		 * But we know we don't need to be on the work list. 		 */
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|add_arg
argument_list|)
expr_stmt|;
name|ng_worklist_remove
argument_list|(
name|ngq
operator|->
name|q_node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*  		 * Since there is something on the queue, note what it is 		 * in the flags word. 		 */
if|if
condition|(
operator|(
name|ngq
operator|->
name|queue
operator|->
name|el_flags
operator|&
name|NGQF_RW
operator|)
operator|==
name|NGQF_READER
condition|)
block|{
name|add_arg
operator|+=
name|READ_PENDING
expr_stmt|;
block|}
else|else
block|{
name|add_arg
operator|+=
name|WRITE_PENDING
expr_stmt|;
block|}
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|add_arg
argument_list|)
expr_stmt|;
comment|/* 		 * If we see more doable work, make sure we are 		 * on the work queue. 		 */
if|if
condition|(
name|CAN_GET_WORK
argument_list|(
name|ngq
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|ng_setisr
argument_list|(
name|ngq
operator|->
name|q_node
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We have successfully cleared the old pending flag, set the new one 	 * if it is needed, and incremented the appropriate active field. 	 * (all in one atomic addition.. ) 	 */
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet to be picked up by someone else.  * We really don't care who, but we can't or don't want to hang around  * to process it ourselves. We are probably an interrupt routine..  * 1 = writer, 0 = reader  */
end_comment

begin_define
define|#
directive|define
name|NGQRW_R
value|0
end_define

begin_define
define|#
directive|define
name|NGQRW_W
value|1
end_define

begin_function
specifier|static
name|__inline
name|void
name|ng_queue_rw
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|item
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
comment|/* maybe not needed */
operator|*
name|ngq
operator|->
name|last
operator|=
name|item
expr_stmt|;
comment|/* 	 * If it was the first item in the queue then we need to 	 * set the last pointer and the type flags. 	 */
if|if
condition|(
name|ngq
operator|->
name|last
operator|==
operator|&
operator|(
name|ngq
operator|->
name|queue
operator|)
condition|)
block|{
comment|/* 		 * When called with constants for rw, the optimiser will 		 * remove the unneeded branch below. 		 */
if|if
condition|(
name|rw
operator|==
name|NGQRW_W
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|WRITE_PENDING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|READ_PENDING
argument_list|)
expr_stmt|;
block|}
block|}
name|ngq
operator|->
name|last
operator|=
operator|&
operator|(
name|item
operator|->
name|el_next
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function 'cheats' in that it first tries to 'grab' the use of the  * node, without going through the mutex. We can do this becasue of the  * semantics of the lock. The semantics include a clause that says that the  * value of the readers count is invalid if the WRITER_ACTIVE flag is set. It  * also says that the WRITER_ACTIVE flag cannot be set if the readers count  * is not zero. Note that this talks about what is valid to SET the  * WRITER_ACTIVE flag, because from the moment it is set, the value if the  * reader count is immaterial, and not valid. The two 'pending' flags have a  * similar effect, in that If they are orthogonal to the two active fields in  * how they are set, but if either is set, the attempted 'grab' need to be  * backed out because there is earlier work, and we maintain ordering in the  * queue. The result of this is that the reader request can try obtain use of  * the node with only a single atomic addition, and without any of the mutex  * overhead. If this fails the operation degenerates to the same as for other  * cases.  *  */
end_comment

begin_function
specifier|static
name|__inline
name|item_p
name|ng_acquire_read
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
comment|/* ######### Hack alert ######### */
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|READER_INCREMENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ngq
operator|->
name|q_flags
operator|&
name|NGQ_RMASK
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Successfully grabbed node */
return|return
operator|(
name|item
operator|)
return|;
block|}
comment|/* undo the damage if we didn't succeed */
name|atomic_subtract_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|READER_INCREMENT
argument_list|)
expr_stmt|;
comment|/* ######### End Hack alert ######### */
name|mtx_lock_spin
argument_list|(
operator|(
operator|&
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try again. Another processor (or interrupt for that matter) may 	 * have removed the last queued item that was stopping us from 	 * running, between the previous test, and the moment that we took 	 * the mutex. (Or maybe a writer completed.) 	 */
if|if
condition|(
operator|(
name|ngq
operator|->
name|q_flags
operator|&
name|NGQ_RMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|READER_INCREMENT
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|(
operator|&
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
comment|/* 	 * and queue the request for later. 	 */
name|item
operator|->
name|el_flags
operator||=
name|NGQF_READER
expr_stmt|;
name|ng_queue_rw
argument_list|(
name|ngq
argument_list|,
name|item
argument_list|,
name|NGQRW_R
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, so that's the item successfully queued for later. So now we 	 * see if we can dequeue something to run instead. 	 */
name|item
operator|=
name|ng_dequeue
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
operator|(
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|item_p
name|ng_acquire_write
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|restart
label|:
name|mtx_lock_spin
argument_list|(
operator|&
operator|(
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no readers, no writer, and no pending packets, then 	 * we can just go ahead. In all other situations we need to queue the 	 * request 	 */
if|if
condition|(
operator|(
name|ngq
operator|->
name|q_flags
operator|&
name|NGQ_WMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|WRITER_ACTIVE
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|(
operator|&
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngq
operator|->
name|q_flags
operator|&
name|READER_MASK
condition|)
block|{
comment|/* Collision with fast-track reader */
name|atomic_subtract_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|WRITER_ACTIVE
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
comment|/* 	 * and queue the request for later. 	 */
name|item
operator|->
name|el_flags
operator|&=
operator|~
name|NGQF_RW
expr_stmt|;
name|ng_queue_rw
argument_list|(
name|ngq
argument_list|,
name|item
argument_list|,
name|NGQRW_W
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, so that's the item successfully queued for later. So now we 	 * see if we can dequeue something to run instead. 	 */
name|item
operator|=
name|ng_dequeue
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
operator|(
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ng_leave_read
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
block|{
name|atomic_subtract_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|READER_INCREMENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ng_leave_write
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
block|{
name|atomic_subtract_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|WRITER_ACTIVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_flush_input_queue
parameter_list|(
name|struct
name|ng_queue
modifier|*
name|ngq
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
name|u_int
name|add_arg
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Now take a look at what's on the queue */
if|if
condition|(
name|ngq
operator|->
name|q_flags
operator|&
name|READ_PENDING
condition|)
block|{
name|add_arg
operator|=
operator|-
name|READ_PENDING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ngq
operator|->
name|q_flags
operator|&
name|WRITE_PENDING
condition|)
block|{
name|add_arg
operator|=
operator|-
name|WRITE_PENDING
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|item
operator|=
name|ngq
operator|->
name|queue
expr_stmt|;
name|ngq
operator|->
name|queue
operator|=
name|item
operator|->
name|el_next
expr_stmt|;
if|if
condition|(
name|ngq
operator|->
name|last
operator|==
operator|&
operator|(
name|item
operator|->
name|el_next
operator|)
condition|)
block|{
name|ngq
operator|->
name|last
operator|=
operator|&
operator|(
name|ngq
operator|->
name|queue
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ngq
operator|->
name|queue
operator|->
name|el_flags
operator|&
name|NGQF_RW
operator|)
operator|==
name|NGQF_READER
condition|)
block|{
name|add_arg
operator|+=
name|READ_PENDING
expr_stmt|;
block|}
else|else
block|{
name|add_arg
operator|+=
name|WRITE_PENDING
expr_stmt|;
block|}
block|}
name|atomic_add_long
argument_list|(
operator|&
name|ngq
operator|->
name|q_flags
argument_list|,
name|add_arg
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Take us off the work queue if we are there. 	 * We definatly have no work to be done. 	 */
name|ng_worklist_remove
argument_list|(
name|ngq
operator|->
name|q_node
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************** * Externally visible method for sending or queueing messages or data. ***********************************************************************/
end_comment

begin_comment
comment|/*  * The module code should have filled out the item correctly by this stage:  * Common:  *    reference to destination node.  *    Reference to destination rcv hook if relevant.  * Data:  *    pointer to mbuf  *    pointer to metadata  * Control_Message:  *    pointer to msg.  *    ID of original sender node. (return address)  * Function:  *    Function pointer  *    void * argument  *    integer argument  *  * The nodes have several routines and macros to help with this task:  */
end_comment

begin_function
name|int
name|ng_snd_item
parameter_list|(
name|item_p
name|item
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|hook_p
name|hook
init|=
name|NGI_HOOK
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|node_p
name|node
init|=
name|NGI_NODE
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|int
name|rw
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|ierror
decl_stmt|;
name|item_p
name|oitem
decl_stmt|;
name|struct
name|ng_queue
modifier|*
name|ngq
init|=
operator|&
name|node
operator|->
name|nd_input_queue
decl_stmt|;
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|_ngi_check
argument_list|(
name|item
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* failed to get queue element */
block|}
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* No address */
block|}
switch|switch
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_TYPE
condition|)
block|{
case|case
name|NGQF_DATA
case|:
comment|/* 		 * DATA MESSAGE 		 * Delivered to a node via a non-optional hook. 		 * Both should be present in the item even though 		 * the node is derivable from the hook. 		 * References are held on both by the item. 		 */
name|CHECK_DATA_MBUF
argument_list|(
name|NGI_M
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
operator|)
operator|||
operator|(
name|NG_NODE_NOT_VALID
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hook
operator|->
name|hk_flags
operator|&
name|HK_QUEUE
operator|)
condition|)
block|{
name|queue
operator|=
literal|1
expr_stmt|;
block|}
comment|/* By default data is a reader in the locking scheme */
name|item
operator|->
name|el_flags
operator||=
name|NGQF_READER
expr_stmt|;
name|rw
operator|=
name|NGQRW_R
expr_stmt|;
break|break;
case|case
name|NGQF_MESG
case|:
comment|/* 		 * CONTROL MESSAGE 		 * Delivered to a node. 		 * Hook is optional. 		 * References are held by the item on the node and 		 * the hook if it is present. 		 */
if|if
condition|(
name|hook
operator|&&
operator|(
name|hook
operator|->
name|hk_flags
operator|&
name|HK_QUEUE
operator|)
condition|)
block|{
name|queue
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Data messages count as writers unles explicitly exempted */
if|if
condition|(
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|->
name|header
operator|.
name|cmd
operator|&
name|NGM_READONLY
condition|)
block|{
name|item
operator|->
name|el_flags
operator||=
name|NGQF_READER
expr_stmt|;
name|rw
operator|=
name|NGQRW_R
expr_stmt|;
block|}
else|else
block|{
name|item
operator|->
name|el_flags
operator|&=
operator|~
name|NGQF_RW
expr_stmt|;
name|rw
operator|=
name|NGQRW_W
expr_stmt|;
block|}
break|break;
case|case
name|NGQF_FN
case|:
name|item
operator|->
name|el_flags
operator|&=
operator|~
name|NGQF_RW
expr_stmt|;
name|rw
operator|=
name|NGQRW_W
expr_stmt|;
break|break;
default|default:
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If the node specifies single threading, force writer semantics 	 * Similarly the node may say one hook always produces writers. 	 * These are over-rides. 	 */
if|if
condition|(
operator|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_FORCE_WRITER
operator|)
operator|||
operator|(
name|hook
operator|&&
operator|(
name|hook
operator|->
name|hk_flags
operator|&
name|HK_FORCE_WRITER
operator|)
operator|)
condition|)
block|{
name|rw
operator|=
name|NGQRW_W
expr_stmt|;
name|item
operator|->
name|el_flags
operator|&=
operator|~
name|NGQF_READER
expr_stmt|;
block|}
if|if
condition|(
name|queue
condition|)
block|{
comment|/* Put it on the queue for that node*/
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|_ngi_check
argument_list|(
name|item
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
operator|(
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
name|ng_queue_rw
argument_list|(
name|ngq
argument_list|,
name|item
argument_list|,
name|rw
argument_list|)
expr_stmt|;
comment|/* 		 * If there are active elements then we can rely on 		 * them. if not we should not rely on another packet 		 * coming here by another path, 		 * so it is best to put us in the netisr list. 		 * We can take the worklist lock with the node locked 		 * BUT NOT THE REVERSE! 		 */
if|if
condition|(
name|CAN_GET_WORK
argument_list|(
name|ngq
operator|->
name|q_flags
argument_list|)
condition|)
block|{
name|ng_setisr
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
operator|(
name|ngq
operator|->
name|q_mtx
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Take a queue item and a node and see if we can apply the item to 	 * the node. We may end up getting a different item to apply instead. 	 * Will allow for a piggyback reply only in the case where 	 * there is no queueing. 	 */
name|oitem
operator|=
name|item
expr_stmt|;
comment|/* 	 * We already decided how we will be queueud or treated. 	 * Try get the appropriate operating permission. 	 */
if|if
condition|(
name|rw
operator|==
name|NGQRW_R
condition|)
block|{
name|item
operator|=
name|ng_acquire_read
argument_list|(
name|ngq
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|ng_acquire_write
argument_list|(
name|ngq
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * May have come back with a different item. 	 * or maybe none at all. The one we started with will 	 * have been queued in thises cases. 	 */
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|_ngi_check
argument_list|(
name|item
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Take over the reference frm the item. 	 * Hold it until the called function returns. 	 */
name|NGI_GET_NODE
argument_list|(
name|item
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* zaps stored node */
name|ierror
operator|=
name|ng_apply_item
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* drops r/w lock when done */
comment|/* only return an error if it was our initial item.. (compat hack) */
if|if
condition|(
name|oitem
operator|==
name|item
condition|)
block|{
name|error
operator|=
name|ierror
expr_stmt|;
block|}
comment|/* 	 * If the node goes away when we remove the reference,  	 * whatever we just did caused it.. whatever we do, DO NOT 	 * access the node again! 	 */
if|if
condition|(
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Now we've handled the packet we brought, (or a friend of it) let's 	 * look for any other packets that may have been queued up. We hold 	 * no locks, so if someone puts something in the queue after 	 * we check that it is empty, it is their problem 	 * to ensure it is processed. If we have the netisr thread cme in here 	 * while we still say we have stuff to do, we may get a boost 	 * in SMP systems. :-) 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * dequeue acquires and adjusts the input_queue as it dequeues 		 * packets. It acquires the rw lock as needed. 		 */
name|mtx_lock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
name|item
operator|=
name|ng_dequeue
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
comment|/* fixes worklist too*/
if|if
condition|(
operator|!
name|item
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|ngq
operator|->
name|q_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Take over the reference frm the item. 		 * Hold it until the called function returns. 		 */
name|NGI_GET_NODE
argument_list|(
name|item
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* zaps stored node */
comment|/* 		 * We have the appropriate lock, so run the item. 		 * When finished it will drop the lock accordingly 		 */
name|ierror
operator|=
name|ng_apply_item
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
comment|/* 		 * only return an error if it was our initial 		 * item.. (compat hack) 		 */
if|if
condition|(
name|oitem
operator|==
name|item
condition|)
block|{
name|error
operator|=
name|ierror
expr_stmt|;
block|}
comment|/* 		 * If the node goes away when we remove the reference,  		 * whatever we just did caused it.. whatever we do, DO NOT 		 * access the node again! 		 */
if|if
condition|(
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have an item that was possibly queued somewhere.  * It should contain all the information needed  * to run it on the appropriate node/hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_apply_item
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|int
name|was_reader
init|=
operator|(
operator|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_RW
operator|)
operator|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ng_rcvdata_t
modifier|*
name|rcvdata
decl_stmt|;
name|ng_rcvmsg_t
modifier|*
name|rcvmsg
decl_stmt|;
name|NGI_GET_HOOK
argument_list|(
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
comment|/* clears stored hook */
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|_ngi_check
argument_list|(
name|item
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_TYPE
condition|)
block|{
case|case
name|NGQF_DATA
case|:
comment|/* 		 * Check things are still ok as when we were queued. 		 */
if|if
condition|(
operator|(
name|hook
operator|==
name|NULL
operator|)
operator|||
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
operator|||
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If no receive method, just silently drop it. 		 * Give preference to the hook over-ride method 		 */
if|if
condition|(
operator|(
operator|!
operator|(
name|rcvdata
operator|=
name|hook
operator|->
name|hk_rcvdata
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rcvdata
operator|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
operator|->
name|nd_type
operator|->
name|rcvdata
operator|)
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|rcvdata
call|)
argument_list|(
name|hook
argument_list|,
name|item
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_MESG
case|:
if|if
condition|(
name|hook
condition|)
block|{
if|if
condition|(
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
condition|)
block|{
comment|/* 				 * The hook has been zapped then we can't 				 * use it. Immediatly drop its reference. 				 * The message may not need it. 				 */
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|hook
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 		 * Similarly, if the node is a zombie there is 		 * nothing we can do with it, drop everything. 		 */
if|if
condition|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Call the appropriate message handler for the object. 			 * It is up to the message handler to free the message. 			 * If it's a generic message, handle it generically, 			 * otherwise call the type's message handler 			 * (if it exists) 			 * XXX (race). Remember that a queued message may 			 * reference a node or hook that has just been 			 * invalidated. It will exist as the queue code 			 * is holding a reference, but.. 			 */
name|struct
name|ng_mesg
modifier|*
name|msg
init|=
name|NGI_MSG
argument_list|(
name|item
argument_list|)
decl_stmt|;
comment|/*  			 * check if the generic handler owns it. 			 */
if|if
condition|(
operator|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_GENERIC_COOKIE
operator|)
operator|&&
operator|(
operator|(
name|msg
operator|->
name|header
operator|.
name|flags
operator|&
name|NGF_RESP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ng_generic_msg
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Now see if there is a handler (hook or node specific) 			 * in the target node. If none, silently discard. 			 */
if|if
condition|(
operator|(
operator|(
operator|!
name|hook
operator|)
operator|||
operator|(
operator|!
operator|(
name|rcvmsg
operator|=
name|hook
operator|->
name|hk_rcvmsg
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
name|rcvmsg
operator|=
name|node
operator|->
name|nd_type
operator|->
name|rcvmsg
operator|)
operator|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|rcvmsg
call|)
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|NGQF_FN
case|:
comment|/* 		 *  We have to implicitly trust the hook, 		 * as some of these are used for system purposes 		 * where the hook is invalid. In the case of 		 * the shutdown message we allow it to hit 		 * even if the node is invalid. 		 */
if|if
condition|(
operator|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
operator|)
operator|&&
operator|(
name|NGI_FN
argument_list|(
name|item
argument_list|)
operator|!=
operator|&
name|ng_rmnode
operator|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
operator|(
operator|*
name|NGI_FN
argument_list|(
name|item
argument_list|)
operator|)
operator|(
name|node
operator|,
name|hook
operator|,
name|NGI_ARG1
argument_list|(
name|item
argument_list|)
operator|,
name|NGI_ARG2
argument_list|(
name|item
argument_list|)
operator|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * We held references on some of the resources 	 * that we took from the item. Now that we have 	 * finished doing everything, drop those references. 	 */
if|if
condition|(
name|hook
condition|)
block|{
name|NG_HOOK_UNREF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|was_reader
condition|)
block|{
name|ng_leave_read
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ng_leave_write
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/***********************************************************************  * Implement the 'generic' control messages  ***********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_generic_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|!=
name|NGM_GENERIC_COOKIE
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SHUTDOWN
case|:
name|ng_rmnode
argument_list|(
name|here
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_MKPEER
case|:
block|{
name|struct
name|ngm_mkpeer
modifier|*
specifier|const
name|mkp
init|=
operator|(
expr|struct
name|ngm_mkpeer
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|mkp
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|mkp
operator|->
name|type
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|type
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkp
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkp
operator|->
name|peerhook
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|peerhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ng_mkpeer
argument_list|(
name|here
argument_list|,
name|mkp
operator|->
name|ourhook
argument_list|,
name|mkp
operator|->
name|peerhook
argument_list|,
name|mkp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_CONNECT
case|:
block|{
name|struct
name|ngm_connect
modifier|*
specifier|const
name|con
init|=
operator|(
expr|struct
name|ngm_connect
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|node_p
name|node2
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|con
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|con
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|con
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|con
operator|->
name|peerhook
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|peerhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't forget we get a reference.. */
name|error
operator|=
name|ng_path2noderef
argument_list|(
name|here
argument_list|,
name|con
operator|->
name|path
argument_list|,
operator|&
name|node2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|ng_con_nodes
argument_list|(
name|here
argument_list|,
name|con
operator|->
name|ourhook
argument_list|,
name|node2
argument_list|,
name|con
operator|->
name|peerhook
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_NAME
case|:
block|{
name|struct
name|ngm_name
modifier|*
specifier|const
name|nam
init|=
operator|(
expr|struct
name|ngm_name
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|nam
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|nam
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|nam
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ng_name_node
argument_list|(
name|here
argument_list|,
name|nam
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_RMHOOK
case|:
block|{
name|struct
name|ngm_rmhook
modifier|*
specifier|const
name|rmh
init|=
operator|(
expr|struct
name|ngm_rmhook
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rmh
argument_list|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|rmh
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|rmh
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|here
argument_list|,
name|rmh
operator|->
name|ourhook
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_NODEINFO
case|:
block|{
name|struct
name|nodeinfo
modifier|*
name|ni
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ni
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* Fill in node info */
name|ni
operator|=
operator|(
expr|struct
name|nodeinfo
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|here
argument_list|)
condition|)
name|strncpy
argument_list|(
name|ni
operator|->
name|name
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|here
argument_list|)
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ni
operator|->
name|type
argument_list|,
name|here
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|ni
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
name|ni
operator|->
name|hooks
operator|=
name|here
operator|->
name|nd_numhooks
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LISTHOOKS
case|:
block|{
specifier|const
name|int
name|nhooks
init|=
name|here
operator|->
name|nd_numhooks
decl_stmt|;
name|struct
name|hooklist
modifier|*
name|hl
decl_stmt|;
name|struct
name|nodeinfo
modifier|*
name|ni
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Get response struct */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hl
argument_list|)
operator|+
operator|(
name|nhooks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linkinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|hl
operator|=
operator|(
expr|struct
name|hooklist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ni
operator|=
operator|&
name|hl
operator|->
name|nodeinfo
expr_stmt|;
comment|/* Fill in node info */
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|here
argument_list|)
condition|)
name|strncpy
argument_list|(
name|ni
operator|->
name|name
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|here
argument_list|)
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ni
operator|->
name|type
argument_list|,
name|here
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|ni
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
comment|/* Cycle through the linked list of hooks */
name|ni
operator|->
name|hooks
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&here->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|struct
name|linkinfo
modifier|*
specifier|const
name|link
init|=
operator|&
name|hl
operator|->
name|link
index|[
name|ni
operator|->
name|hooks
index|]
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|hooks
operator|>=
name|nhooks
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__func__
argument_list|,
literal|"hooks"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
condition|)
continue|continue;
name|strncpy
argument_list|(
name|link
operator|->
name|ourhook
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|link
operator|->
name|peerhook
argument_list|,
name|NG_PEER_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_PEER_NODE_NAME
argument_list|(
name|hook
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|strncpy
argument_list|(
name|link
operator|->
name|nodeinfo
operator|.
name|name
argument_list|,
name|NG_PEER_NODE_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|link
operator|->
name|nodeinfo
operator|.
name|type
argument_list|,
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|link
operator|->
name|nodeinfo
operator|.
name|id
operator|=
name|ng_node2ID
argument_list|(
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|nodeinfo
operator|.
name|hooks
operator|=
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
operator|->
name|nd_numhooks
expr_stmt|;
name|ni
operator|->
name|hooks
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NGM_LISTNAMES
case|:
case|case
name|NGM_LISTNODES
case|:
block|{
specifier|const
name|int
name|unnamed
init|=
operator|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_LISTNODES
operator|)
decl_stmt|;
name|struct
name|namelist
modifier|*
name|nl
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
comment|/* Count number of nodes */
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&ng_nodelist
argument_list|,
argument|nd_nodes
argument_list|)
block|{
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|&&
operator|(
name|unnamed
operator|||
name|NG_NODE_HAS_NAME
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|num
operator|++
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
comment|/* Get response struct */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nl
argument_list|)
operator|+
operator|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nodeinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|nl
operator|=
operator|(
expr|struct
name|namelist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
comment|/* Cycle through the linked list of nodes */
name|nl
operator|->
name|numnames
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&ng_nodelist
argument_list|,
argument|nd_nodes
argument_list|)
block|{
name|struct
name|nodeinfo
modifier|*
specifier|const
name|np
init|=
operator|&
name|nl
operator|->
name|nodeinfo
index|[
name|nl
operator|->
name|numnames
index|]
decl_stmt|;
if|if
condition|(
name|nl
operator|->
name|numnames
operator|>=
name|num
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__func__
argument_list|,
literal|"nodes"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|unnamed
operator|&&
operator|(
operator|!
name|NG_NODE_HAS_NAME
argument_list|(
name|node
argument_list|)
operator|)
condition|)
continue|continue;
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|strncpy
argument_list|(
name|np
operator|->
name|name
argument_list|,
name|NG_NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|node
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|np
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|np
operator|->
name|hooks
operator|=
name|node
operator|->
name|nd_numhooks
expr_stmt|;
name|nl
operator|->
name|numnames
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LISTTYPES
case|:
block|{
name|struct
name|typelist
modifier|*
name|tl
decl_stmt|;
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
comment|/* Count number of types */
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&ng_typelist
argument_list|,
argument|types
argument_list|)
block|{
name|num
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
comment|/* Get response struct */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tl
argument_list|)
operator|+
operator|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typeinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|tl
operator|=
operator|(
expr|struct
name|typelist
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
comment|/* Cycle through the linked list of types */
name|tl
operator|->
name|numtypes
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&ng_typelist
argument_list|,
argument|types
argument_list|)
block|{
name|struct
name|typeinfo
modifier|*
specifier|const
name|tp
init|=
operator|&
name|tl
operator|->
name|typeinfo
index|[
name|tl
operator|->
name|numtypes
index|]
decl_stmt|;
if|if
condition|(
name|tl
operator|->
name|numtypes
operator|>=
name|num
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__func__
argument_list|,
literal|"types"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|tp
operator|->
name|type_name
argument_list|,
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|tp
operator|->
name|numnodes
operator|=
name|type
operator|->
name|refs
operator|-
literal|1
expr_stmt|;
comment|/* don't count list */
name|tl
operator|->
name|numtypes
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_BINARY2ASCII
case|:
block|{
name|int
name|bufSize
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
comment|/* XXX hard coded constant */
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|argstype
decl_stmt|;
specifier|const
name|struct
name|ng_cmdlist
modifier|*
name|c
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|binary
decl_stmt|,
modifier|*
name|ascii
decl_stmt|;
comment|/* Data area must contain a valid netgraph message */
name|binary
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|||
operator|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|<
name|binary
operator|->
name|header
operator|.
name|arglen
operator|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Get a response message with lots of room */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|bufSize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|ascii
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
comment|/* Copy binary message header to response message payload */
name|bcopy
argument_list|(
name|binary
argument_list|,
name|ascii
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find command by matching typecookie and command number */
for|for
control|(
name|c
operator|=
name|here
operator|->
name|nd_type
operator|->
name|cmdlist
init|;
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|==
name|c
operator|->
name|cookie
operator|&&
name|binary
operator|->
name|header
operator|.
name|cmd
operator|==
name|c
operator|->
name|cmd
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|c
operator|=
name|ng_generic_cmds
init|;
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|==
name|c
operator|->
name|cookie
operator|&&
name|binary
operator|->
name|header
operator|.
name|cmd
operator|==
name|c
operator|->
name|cmd
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
block|}
comment|/* Convert command name to ASCII */
name|snprintf
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
sizeof|sizeof
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Convert command arguments to ASCII */
name|argstype
operator|=
operator|(
name|binary
operator|->
name|header
operator|.
name|flags
operator|&
name|NGF_RESP
operator|)
condition|?
name|c
operator|->
name|respType
else|:
name|c
operator|->
name|mesgType
expr_stmt|;
if|if
condition|(
name|argstype
operator|==
name|NULL
condition|)
block|{
operator|*
name|ascii
operator|->
name|data
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_unparse
argument_list|(
name|argstype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|binary
operator|->
name|data
argument_list|,
name|ascii
operator|->
name|data
argument_list|,
name|bufSize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|resp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Return the result as struct ng_mesg plus ASCII string */
name|bufSize
operator|=
name|strlen
argument_list|(
name|ascii
operator|->
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|=
name|bufSize
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|bufSize
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ASCII2BINARY
case|:
block|{
name|int
name|bufSize
init|=
literal|2000
decl_stmt|;
comment|/* XXX hard coded constant */
specifier|const
name|struct
name|ng_cmdlist
modifier|*
name|c
decl_stmt|;
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|argstype
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|ascii
decl_stmt|,
modifier|*
name|binary
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* Data area must contain at least a struct ng_mesg + '\0' */
name|ascii
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
literal|1
operator|)
operator|||
operator|(
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|<
literal|1
operator|)
operator|||
operator|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|)
condition|)
block|{
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ascii
operator|->
name|data
index|[
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get a response message with lots of room */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
operator|+
name|bufSize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|binary
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
comment|/* Copy ASCII message header to response message payload */
name|bcopy
argument_list|(
name|ascii
argument_list|,
name|binary
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find command by matching ASCII command string */
for|for
control|(
name|c
operator|=
name|here
operator|->
name|nd_type
operator|->
name|cmdlist
init|;
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|c
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|c
operator|=
name|ng_generic_cmds
init|;
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|c
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
block|}
comment|/* Convert command name to binary */
name|binary
operator|->
name|header
operator|.
name|cmd
operator|=
name|c
operator|->
name|cmd
expr_stmt|;
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|=
name|c
operator|->
name|cookie
expr_stmt|;
comment|/* Convert command arguments to binary */
name|argstype
operator|=
operator|(
name|binary
operator|->
name|header
operator|.
name|flags
operator|&
name|NGF_RESP
operator|)
condition|?
name|c
operator|->
name|respType
else|:
name|c
operator|->
name|mesgType
expr_stmt|;
if|if
condition|(
name|argstype
operator|==
name|NULL
condition|)
block|{
name|bufSize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_parse
argument_list|(
name|argstype
argument_list|,
name|ascii
operator|->
name|data
argument_list|,
operator|&
name|off
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|binary
operator|->
name|data
argument_list|,
operator|&
name|bufSize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|resp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Return the result */
name|binary
operator|->
name|header
operator|.
name|arglen
operator|=
name|bufSize
expr_stmt|;
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
operator|+
name|bufSize
expr_stmt|;
break|break;
block|}
case|case
name|NGM_TEXT_CONFIG
case|:
case|case
name|NGM_TEXT_STATUS
case|:
comment|/* 		 * This one is tricky as it passes the command down to the 		 * actual node, even though it is a generic type command. 		 * This means we must assume that the item/msg is already freed 		 * when control passes back to us. 		 */
if|if
condition|(
name|here
operator|->
name|nd_type
operator|->
name|rcvmsg
operator|!=
name|NULL
condition|)
block|{
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|=
name|msg
expr_stmt|;
comment|/* put it back as we found it */
return|return
operator|(
call|(
modifier|*
name|here
operator|->
name|nd_type
operator|->
name|rcvmsg
call|)
argument_list|(
name|here
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
operator|)
return|;
block|}
comment|/* Fall through if rcvmsg not supported */
default|default:
name|TRAP_ERROR
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
comment|/* 	 * Sometimes a generic message may be statically allocated 	 * to avoid problems with allocating when in tight memeory situations. 	 * Don't free it if it is so. 	 * I break them appart here, because erros may cause a free if the item 	 * in which case we'd be doing it twice. 	 * they are kept together above, to simplify freeing. 	 */
name|out
label|:
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|here
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a 'meta'.  *  * Returns new meta, or NULL if original meta is NULL or ENOMEM.  */
end_comment

begin_function
name|meta_p
name|ng_copy_meta
parameter_list|(
name|meta_p
name|meta
parameter_list|)
block|{
name|meta_p
name|meta2
decl_stmt|;
if|if
condition|(
name|meta
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MALLOC
argument_list|(
name|meta2
argument_list|,
name|meta_p
argument_list|,
name|meta
operator|->
name|used_len
argument_list|,
name|M_NETGRAPH_META
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|meta2
operator|->
name|allocated_len
operator|=
name|meta
operator|->
name|used_len
expr_stmt|;
name|bcopy
argument_list|(
name|meta
argument_list|,
name|meta2
argument_list|,
name|meta
operator|->
name|used_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|meta2
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Module routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Handle the loading/unloading of a netgraph node type module  */
end_comment

begin_function
name|int
name|ng_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
specifier|const
name|type
init|=
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register new netgraph node type */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_newtype
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Call type specific code */
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
operator|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|type
operator|->
name|refs
operator|--
expr_stmt|;
comment|/* undo it */
name|LIST_REMOVE
argument_list|(
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
comment|/* make sure no nodes exist! */
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|->
name|refs
operator|==
literal|0
condition|)
block|{
comment|/* failed load, nothing to undo */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
block|{
comment|/* check with type */
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* type refuses.. */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
comment|/* XXX ? */
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle loading and unloading for this code.  * The only thing we need to link into is the NETISR strucure.  */
end_comment

begin_function
specifier|static
name|int
name|ngb_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register line discipline */
name|mtx_init
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|,
literal|"ng_worklist"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ng_typelist_mtx
argument_list|,
literal|"netgraph types mutex"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ng_nodelist_mtx
argument_list|,
literal|"netgraph nodelist mutex"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ng_idhash_mtx
argument_list|,
literal|"netgraph idhash mutex"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ngq_mtx
argument_list|,
literal|"netgraph netisr mutex"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|netisr_register
argument_list|(
name|NETISR_NETGRAPH
argument_list|,
operator|(
name|netisr_t
operator|*
operator|)
name|ngintr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* You cant unload it because an interface may be using it.  */
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|netgraph_mod
init|=
block|{
literal|"netgraph"
block|,
name|ngb_mod_event
block|,
operator|(
name|NULL
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|netgraph
argument_list|,
name|netgraph_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|graph
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"netgraph Family"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|abi_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_ABI_VERSION
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|msg_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_VERSION
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************ 			Queue element get/free routines ************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|int
name|allocated
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of items malloc'd */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxalloc
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* limit the damage of a leak */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ngqfreemax
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache at most this many */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.graph.maxalloc"
argument_list|,
operator|&
name|maxalloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|maxalloc
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|maxalloc
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of queue items to allocate"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.graph.ngqfreemax"
argument_list|,
operator|&
name|ngqfreemax
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|ngqfreemax
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ngqfreemax
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of free queue items to cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|ngqfreelow
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* try malloc if free< this */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|ngqfreesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ng_item
argument_list|)
name|ng_itemlist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|ng_itemlist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get a queue entry  * This is usually called when a packet first enters netgraph.  * By definition, this is usually from an interrupt, or from a user.  * Users are not so important, but try be quick for the times that it's  * an interrupt. Use atomic operations to cope with collisions  * with interrupts and other processors. Assumes MALLOC is SMP safe.  * XXX If reserve is low, we should try to get 2 from malloc as this  * would indicate it often fails.  */
end_comment

begin_function
specifier|static
name|item_p
name|ng_getqblk
parameter_list|(
name|void
parameter_list|)
block|{
name|item_p
name|item
init|=
name|NULL
decl_stmt|;
comment|/* 	 * Try get a cached queue block, or else allocate a new one 	 * If we are less than our reserve, try malloc. If malloc 	 * fails, then that's what the reserve is for... 	 * Don't completely trust ngqfreesize, as it is subject 	 * to races.. (it'll eventually catch up but may be out by one or two 	 * for brief moments(under SMP or interrupts). 	 * ngqfree is the final arbiter. We have our little reserve 	 * because we use M_NOWAIT for malloc. This just helps us 	 * avoid dropping packets while not increasing the time 	 * we take to service the interrupt (on average) (I hope). 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|ngqfreesize
operator|<
name|ngqfreelow
operator|)
operator|||
operator|(
name|ngqfree
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|allocated
operator|<
name|maxalloc
condition|)
block|{
comment|/* don't leak forever */
name|MALLOC
argument_list|(
name|item
argument_list|,
name|item_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|,
name|M_NETGRAPH_ITEM
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
condition|)
block|{
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ng_itemlist
argument_list|,
name|item
argument_list|,
name|all
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETGRAPH_DEBUG */
name|atomic_add_int
argument_list|(
operator|&
name|allocated
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 * We didn't or couldn't malloc. 		 * try get one from our cache. 		 * item must be NULL to get here. 		 */
if|if
condition|(
operator|(
name|item
operator|=
name|ngqfree
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Atomically try grab the first item 			 * and put it's successor in its place. 			 * If we fail, just try again.. someone else 			 * beat us to this one or freed one. 			 * Don't worry about races with ngqfreesize. 			 * Close enough is good enough.. 			 */
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|ngqfree
argument_list|,
name|item
argument_list|,
name|item
operator|->
name|el_next
argument_list|)
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|ngqfreesize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|item
operator|->
name|el_flags
operator|&=
operator|~
name|NGQF_FREE
expr_stmt|;
break|break;
block|}
comment|/*  			 * something got there before we did.. try again 			 * (go around the loop again) 			 */
name|item
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We really ran out */
break|break;
block|}
block|}
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a queue entry  */
end_comment

begin_function
name|void
name|ng_free_item
parameter_list|(
name|item_p
name|item
parameter_list|)
block|{
comment|/* 	 * The item may hold resources on it's own. We need to free 	 * these before we can free the item. What they are depends upon 	 * what kind of item it is. it is important that nodes zero 	 * out pointers to resources that they remove from the item 	 * or we release them again here. 	 */
if|if
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_FREE
condition|)
block|{
name|panic
argument_list|(
literal|" Freeing free queue item"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_TYPE
condition|)
block|{
case|case
name|NGQF_DATA
case|:
comment|/* If we have an mbuf and metadata still attached.. */
name|NG_FREE_M
argument_list|(
name|_NGI_M
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|_NGI_META
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_MESG
case|:
name|_NGI_RETADDR
argument_list|(
name|item
argument_list|)
operator|=
literal|0
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|_NGI_MSG
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_FN
case|:
comment|/* nothing to free really, */
name|_NGI_FN
argument_list|(
name|item
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|_NGI_ARG1
argument_list|(
name|item
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|_NGI_ARG2
argument_list|(
name|item
argument_list|)
operator|=
literal|0
expr_stmt|;
case|case
name|NGQF_UNDEF
case|:
break|break;
block|}
comment|/* If we still have a node or hook referenced... */
name|_NGI_CLR_NODE
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|_NGI_CLR_HOOK
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|el_flags
operator||=
name|NGQF_FREE
expr_stmt|;
comment|/* 	 * We have freed any resources held by the item. 	 * now we can free the item itself. 	 */
if|if
condition|(
name|ngqfreesize
operator|<
name|ngqfreemax
condition|)
block|{
comment|/* don't worry about races */
for|for
control|(
init|;
condition|;
control|)
block|{
name|item
operator|->
name|el_next
operator|=
name|ngqfree
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_ptr
argument_list|(
operator|&
name|ngqfree
argument_list|,
name|item
operator|->
name|el_next
argument_list|,
name|item
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|ngqfreesize
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is the only place that should use this Macro */
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ng_itemlist
argument_list|,
name|item
argument_list|,
name|all
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NETGRAPH_DEBUG */
name|NG_FREE_ITEM_REAL
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|allocated
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_function
name|void
name|dumphook
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|printf
argument_list|(
literal|"hook: name %s, %d refs, Last touched:\n"
argument_list|,
name|_NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|hook
operator|->
name|hk_refs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	Last active @ %s, line %d\n"
argument_list|,
name|hook
operator|->
name|lastfile
argument_list|,
name|hook
operator|->
name|lastline
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
block|{
name|printf
argument_list|(
literal|" problem discovered at file %s, line %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dumpnode
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|printf
argument_list|(
literal|"node: ID [%x]: type '%s', %d hooks, flags 0x%x, %d refs, %s:\n"
argument_list|,
name|_NG_NODE_ID
argument_list|(
name|node
argument_list|)
argument_list|,
name|node
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|node
operator|->
name|nd_numhooks
argument_list|,
name|node
operator|->
name|nd_flags
argument_list|,
name|node
operator|->
name|nd_refs
argument_list|,
name|node
operator|->
name|nd_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	Last active @ %s, line %d\n"
argument_list|,
name|node
operator|->
name|lastfile
argument_list|,
name|node
operator|->
name|lastline
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
block|{
name|printf
argument_list|(
literal|" problem discovered at file %s, line %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dumpitem
parameter_list|(
name|item_p
name|item
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
if|if
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_FREE
condition|)
block|{
name|printf
argument_list|(
literal|" Free item, freed at %s, line %d\n"
argument_list|,
name|item
operator|->
name|lastfile
argument_list|,
name|item
operator|->
name|lastline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" ACTIVE item, last used at %s, line %d"
argument_list|,
name|item
operator|->
name|lastfile
argument_list|,
name|item
operator|->
name|lastline
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|item
operator|->
name|el_flags
operator|&
name|NGQF_TYPE
condition|)
block|{
case|case
name|NGQF_DATA
case|:
name|printf
argument_list|(
literal|" - [data]\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_MESG
case|:
name|printf
argument_list|(
literal|" - retaddr[%d]:\n"
argument_list|,
name|_NGI_RETADDR
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_FN
case|:
name|printf
argument_list|(
literal|" - fn@%p (%p, %p, %p, %d (%x))\n"
argument_list|,
name|item
operator|->
name|body
operator|.
name|fn
operator|.
name|fn_fn
argument_list|,
name|NGI_NODE
argument_list|(
name|item
argument_list|)
argument_list|,
name|NGI_HOOK
argument_list|(
name|item
argument_list|)
argument_list|,
name|item
operator|->
name|body
operator|.
name|fn
operator|.
name|fn_arg1
argument_list|,
name|item
operator|->
name|body
operator|.
name|fn
operator|.
name|fn_arg2
argument_list|,
name|item
operator|->
name|body
operator|.
name|fn
operator|.
name|fn_arg2
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_UNDEF
case|:
name|printf
argument_list|(
literal|" - UNDEFINED!\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line
condition|)
block|{
name|printf
argument_list|(
literal|" problem discovered at file %s, line %d\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|NGI_NODE
argument_list|(
name|item
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"node %p ([%x])\n"
argument_list|,
name|NGI_NODE
argument_list|(
name|item
argument_list|)
argument_list|,
name|ng_node2ID
argument_list|(
name|NGI_NODE
argument_list|(
name|item
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ng_dumpitems
parameter_list|(
name|void
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|item
argument_list|,
argument|&ng_itemlist
argument_list|,
argument|all
argument_list|)
block|{
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|dumpitem
argument_list|(
name|item
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ng_dumpnodes
parameter_list|(
name|void
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&ng_allnodes
argument_list|,
argument|nd_all
argument_list|)
block|{
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|dumpnode
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ng_dumphooks
parameter_list|(
name|void
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&ng_allhooks
argument_list|,
argument|hk_all
argument_list|)
block|{
name|printf
argument_list|(
literal|"[%d] "
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|dumphook
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_debug_ng_dump_items
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|val
operator|=
name|allocated
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|==
literal|42
condition|)
block|{
name|ng_dumpitems
argument_list|()
expr_stmt|;
name|ng_dumpnodes
argument_list|()
expr_stmt|;
name|ng_dumphooks
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ng_dump_items
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_debug_ng_dump_items
argument_list|,
literal|"I"
argument_list|,
literal|"Number of allocated items"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NETGRAPH_DEBUG */
end_comment

begin_comment
comment|/*********************************************************************** * Worklist routines **********************************************************************/
end_comment

begin_comment
comment|/* NETISR thread enters here */
end_comment

begin_comment
comment|/*  * Pick a node off the list of nodes with work,  * try get an item to process off it.  * If there are no more, remove the node from the list.  */
end_comment

begin_function
specifier|static
name|void
name|ngintr
parameter_list|(
name|void
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
name|node_p
name|node
init|=
name|NULL
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ng_worklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_WORKQ
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ng_worklist
argument_list|,
name|node
argument_list|,
name|nd_work
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * We have the node. We also take over the reference 		 * that the list had on it. 		 * Now process as much as you can, until it won't 		 * let you have another item off the queue. 		 * All this time, keep the reference 		 * that lets us be sure that the node still exists. 		 * Let the reference go at the last minute. 		 * ng_dequeue will put us back on the worklist 		 * if there is more too do. This may be of use if there 		 * are Multiple Processors and multiple Net threads in the  		 * future. 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
name|item
operator|=
name|ng_dequeue
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
break|break;
comment|/* go look for another node */
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|node
operator|->
name|nd_input_queue
operator|.
name|q_mtx
argument_list|)
expr_stmt|;
name|NGI_GET_NODE
argument_list|(
name|item
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* zaps stored node */
name|ng_apply_item
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ng_worklist_remove
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_WORKQ
condition|)
block|{
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_WORKQ
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ng_worklist
argument_list|,
name|node
argument_list|,
name|nd_work
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * XXX  * It's posible that a debugging NG_NODE_REF may need  * to be outside the mutex zone  */
end_comment

begin_function
specifier|static
name|void
name|ng_setisr
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_WORKQ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we are not already on the work queue, 		 * then put us on. 		 */
name|node
operator|->
name|nd_flags
operator||=
name|NG_WORKQ
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ng_worklist
argument_list|,
name|node
argument_list|,
name|nd_work
argument_list|)
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* XXX fafe in mutex? */
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|ng_worklist_mtx
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_NETGRAPH
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************** * Externally useable functions to set up a queue item ready for sending ***********************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NETGRAPH_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|ITEM_DEBUG_CHECKS
define|\
value|do {								\ 		if (NGI_NODE(item) ) {					\ 			printf("item already has node");		\ 			Debugger("has node");				\ 			NGI_CLR_NODE(item);				\ 		}							\ 		if (NGI_HOOK(item) ) {					\ 			printf("item already has hook");		\ 			Debugger("has hook");				\ 			NGI_CLR_HOOK(item);				\ 		}							\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ITEM_DEBUG_CHECKS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Put elements into the item.  * Hook and node references will be removed when the item is dequeued.  * (or equivalent)  * (XXX) Unsafe because no reference held by peer on remote node.  * remote node might go away in this timescale.  * We know the hooks can't go away because that would require getting  * a writer item on both nodes and we must have at least a  reader  * here to eb able to do this.  * Note that the hook loaded is the REMOTE hook.  *  * This is possibly in the critical path for new data.  */
end_comment

begin_function
name|item_p
name|ng_package_data
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ITEM_DEBUG_CHECKS
expr_stmt|;
name|item
operator|->
name|el_flags
operator|=
name|NGQF_DATA
expr_stmt|;
name|item
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
name|NGI_META
argument_list|(
name|item
argument_list|)
operator|=
name|meta
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a queue item and put items into it..  * Evaluate the address as this will be needed to queue it and  * to work out what some of the fields should be.  * Hook and node references will be removed when the item is dequeued.  * (or equivalent)  */
end_comment

begin_function
name|item_p
name|ng_package_msg
parameter_list|(
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ITEM_DEBUG_CHECKS
expr_stmt|;
name|item
operator|->
name|el_flags
operator|=
name|NGQF_MESG
expr_stmt|;
name|item
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Set the current lasthook into the queue item 	 */
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|=
name|msg
expr_stmt|;
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SET_RETADDR
parameter_list|(
name|item
parameter_list|,
name|here
parameter_list|,
name|retaddr
parameter_list|)
define|\
value|do {
comment|/* Data or fn items don't have retaddrs */
value|\ 		if ((item->el_flags& NGQF_TYPE) == NGQF_MESG) {	\ 			if (retaddr) {					\ 				NGI_RETADDR(item) = retaddr;		\ 			} else {					\
comment|/*					\ 				 * The old return address should be ok.	\ 				 * If there isn't one, use the address	\ 				 * here.				\ 				 */
value|\ 				if (NGI_RETADDR(item) == 0) {		\ 					NGI_RETADDR(item)		\ 						= ng_node2ID(here);	\ 				}					\ 			}						\ 		}							\ 	} while (0)
end_define

begin_function
name|int
name|ng_address_hook
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|ng_ID_t
name|retaddr
parameter_list|)
block|{
name|hook_p
name|peer
decl_stmt|;
name|node_p
name|peernode
decl_stmt|;
name|ITEM_DEBUG_CHECKS
expr_stmt|;
comment|/* 	 * Quick sanity check.. 	 * Since a hook holds a reference on it's node, once we know 	 * that the peer is still connected (even if invalid,) we know 	 * that the peer node is present, though maybe invalid. 	 */
if|if
condition|(
operator|(
name|hook
operator|==
name|NULL
operator|)
operator|||
name|NG_HOOK_NOT_VALID
argument_list|(
name|hook
argument_list|)
operator|||
operator|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
operator|==
name|NULL
operator|)
operator|||
name|NG_HOOK_NOT_VALID
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|||
name|NG_NODE_NOT_VALID
argument_list|(
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* 	 * Transfer our interest to the other (peer) end. 	 */
name|peer
operator|=
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|NG_HOOK_REF
argument_list|(
name|peer
argument_list|)
expr_stmt|;
name|NGI_SET_HOOK
argument_list|(
name|item
argument_list|,
name|peer
argument_list|)
expr_stmt|;
name|peernode
operator|=
name|NG_PEER_NODE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|peernode
argument_list|)
expr_stmt|;
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|peernode
argument_list|)
expr_stmt|;
name|SET_RETADDR
argument_list|(
name|item
argument_list|,
name|here
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ng_address_path
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|char
modifier|*
name|address
parameter_list|,
name|ng_ID_t
name|retaddr
parameter_list|)
block|{
name|node_p
name|dest
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ITEM_DEBUG_CHECKS
expr_stmt|;
comment|/* 	 * Note that ng_path2noderef increments the reference count 	 * on the node for us if it finds one. So we don't have to. 	 */
name|error
operator|=
name|ng_path2noderef
argument_list|(
name|here
argument_list|,
name|address
argument_list|,
operator|&
name|dest
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* don't let it go while on the queue */
name|NGI_SET_HOOK
argument_list|(
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
name|SET_RETADDR
argument_list|(
name|item
argument_list|,
name|here
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ng_address_ID
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|ng_ID_t
name|ID
parameter_list|,
name|ng_ID_t
name|retaddr
parameter_list|)
block|{
name|node_p
name|dest
decl_stmt|;
name|ITEM_DEBUG_CHECKS
expr_stmt|;
comment|/* 	 * Find the target node. 	 */
name|dest
operator|=
name|ng_ID2noderef
argument_list|(
name|ID
argument_list|)
expr_stmt|;
comment|/* GETS REFERENCE! */
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|TRAP_ERROR
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Fill out the contents */
name|item
operator|->
name|el_flags
operator|=
name|NGQF_MESG
expr_stmt|;
name|item
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|NGI_CLR_HOOK
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|SET_RETADDR
argument_list|(
name|item
argument_list|,
name|here
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * special case to send a message to self (e.g. destroy node)  * Possibly indicate an arrival hook too.  * Useful for removing that hook :-)  */
end_comment

begin_function
name|item_p
name|ng_package_msg_self
parameter_list|(
name|node_p
name|here
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
comment|/* 	 * Find the target node. 	 * If there is a HOOK argument, then use that in preference 	 * to the address. 	 */
if|if
condition|(
operator|(
name|item
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Fill out the contents */
name|item
operator|->
name|el_flags
operator|=
name|NGQF_MESG
expr_stmt|;
name|item
operator|->
name|el_next
operator|=
name|NULL
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|here
argument_list|)
expr_stmt|;
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|here
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|NGI_SET_HOOK
argument_list|(
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|=
name|msg
expr_stmt|;
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
return|return
operator|(
name|item
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ng_send_fn
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|ng_item_fn
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|item
operator|->
name|el_flags
operator|=
name|NGQF_FN
operator||
name|NGQF_WRITER
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* and one for the item */
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|NGI_SET_HOOK
argument_list|(
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
name|NGI_FN
argument_list|(
name|item
argument_list|)
operator|=
name|fn
expr_stmt|;
name|NGI_ARG1
argument_list|(
name|item
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|NGI_ARG2
argument_list|(
name|item
argument_list|)
operator|=
name|arg2
expr_stmt|;
return|return
operator|(
name|ng_snd_item
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Official timeout routines for Netgraph nodes.  */
end_comment

begin_function
specifier|static
name|void
name|ng_timeout_trapoline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|item_p
name|item
init|=
name|arg
decl_stmt|;
name|ng_snd_item
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|callout_handle
name|ng_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|int
name|ticks
parameter_list|,
name|ng_item_fn
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|callout_handle
name|handle
decl_stmt|;
name|handle
operator|.
name|callout
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|handle
operator|)
return|;
block|}
name|item
operator|->
name|el_flags
operator|=
name|NGQF_FN
operator||
name|NGQF_WRITER
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* and one for the item */
name|NGI_SET_NODE
argument_list|(
name|item
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
condition|)
block|{
name|NG_HOOK_REF
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|NGI_SET_HOOK
argument_list|(
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
name|NGI_FN
argument_list|(
name|item
argument_list|)
operator|=
name|fn
expr_stmt|;
name|NGI_ARG1
argument_list|(
name|item
argument_list|)
operator|=
name|arg1
expr_stmt|;
name|NGI_ARG2
argument_list|(
name|item
argument_list|)
operator|=
name|arg2
expr_stmt|;
return|return
operator|(
name|timeout
argument_list|(
operator|&
name|ng_timeout_trapoline
argument_list|,
name|item
argument_list|,
name|ticks
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A special modified version of untimeout() */
end_comment

begin_function
name|int
name|ng_untimeout
parameter_list|(
name|struct
name|callout_handle
name|handle
parameter_list|,
name|node_p
name|node
parameter_list|)
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
name|handle
operator|.
name|callout
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|callout_lock
argument_list|)
expr_stmt|;
name|item
operator|=
name|handle
operator|.
name|callout
operator|->
name|c_arg
expr_stmt|;
comment|/* should be an official way to do this */
if|if
condition|(
operator|(
name|handle
operator|.
name|callout
operator|->
name|c_func
operator|==
operator|&
name|ng_timeout_trapoline
operator|)
operator|&&
operator|(
name|NGI_NODE
argument_list|(
name|item
argument_list|)
operator|==
name|node
operator|)
operator|&&
operator|(
name|callout_stop
argument_list|(
name|handle
operator|.
name|callout
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We successfully removed it from the queue before it ran 		 * So now we need to unreference everything that was  		 * given extra references. (NG_FREE_ITEM does this). 		 */
name|mtx_unlock_spin
argument_list|(
operator|&
name|callout_lock
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|callout_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the address, if none given, give the node here.  */
end_comment

begin_function
name|void
name|ng_replace_retaddr
parameter_list|(
name|node_p
name|here
parameter_list|,
name|item_p
name|item
parameter_list|,
name|ng_ID_t
name|retaddr
parameter_list|)
block|{
if|if
condition|(
name|retaddr
condition|)
block|{
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
operator|=
name|retaddr
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The old return address should be ok. 		 * If there isn't one, use the address here. 		 */
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TESTING
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|TESTING
end_ifdef

begin_comment
comment|/* just test all the macros */
end_comment

begin_function_decl
name|void
name|ng_macro_test
parameter_list|(
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ng_macro_test
parameter_list|(
name|item_p
name|item
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|ng_ID_t
name|retaddr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|retaddr
operator|=
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|hook
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|msg
argument_list|,
name|hook
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_ID
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|msg
argument_list|,
name|retaddr
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_PATH
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|msg
argument_list|,
literal|".:"
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|NG_FWD_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|hook
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TESTING */
end_comment

end_unit

