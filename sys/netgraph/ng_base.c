begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_base.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Authors: Julian Elischer<julian@freebsd.org>  *          Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_base.c,v 1.39 1999/01/28 23:54:53 julian Exp $  */
end_comment

begin_comment
comment|/*  * This file implements the base netgraph code.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_comment
comment|/* List of all nodes */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|nodelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of installed types */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_type
argument_list|)
name|typelist
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hash releted definitions */
end_comment

begin_define
define|#
directive|define
name|ID_HASH_SIZE
value|32
end_define

begin_comment
comment|/* most systems wont need even this many */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ng_node
argument_list|)
name|ID_hash
index|[
name|ID_HASH_SIZE
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Don't nead to initialise them because it's a LIST */
end_comment

begin_comment
comment|/* Internal functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_add_hook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hook_p
modifier|*
name|hookp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_connect
parameter_list|(
name|hook_p
name|hook1
parameter_list|,
name|hook_p
name|hook2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_disconnect_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_generic_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|resp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_ID_t
name|ng_decodeidname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngb_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngintr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Our own netgraph malloc type */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH
argument_list|,
literal|"netgraph"
argument_list|,
literal|"netgraph structures and ctrl messages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Set this to Debugger("X") to catch all errors as they occur */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRAP_ERROR
end_ifndef

begin_define
define|#
directive|define
name|TRAP_ERROR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|ng_ID_t
name|nextID
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|CHECK_DATA_MBUF
parameter_list|(
name|m
parameter_list|)
value|do {					\ 		struct mbuf *n;						\ 		int total;						\ 									\ 		if (((m)->m_flags& M_PKTHDR) == 0)			\ 			panic("%s: !PKTHDR", __FUNCTION__);		\ 		for (total = 0, n = (m); n != NULL; n = n->m_next)	\ 			total += n->m_len;				\ 		if ((m)->m_pkthdr.len != total) {			\ 			panic("%s: %d != %d",				\ 			    __FUNCTION__, (m)->m_pkthdr.len, total);	\ 		}							\ 	} while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CHECK_DATA_MBUF
parameter_list|(
name|m
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************ 	Parse type definitions for generic messages ************************************************************************/
end_comment

begin_comment
comment|/* Handy structure parse type defining macro */
end_comment

begin_define
define|#
directive|define
name|DEFINE_PARSE_STRUCT_TYPE
parameter_list|(
name|lo
parameter_list|,
name|up
parameter_list|,
name|args
parameter_list|)
define|\
value|static const struct ng_parse_struct_info				\ 	ng_ ## lo ## _type_info = NG_GENERIC_ ## up ## _INFO args;	\ static const struct ng_parse_type ng_generic_ ## lo ## _type = {	\&ng_parse_struct_type,						\&ng_ ## lo ## _type_info					\ }
end_define

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|mkpeer
argument_list|,
name|MKPEER
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|connect
argument_list|,
name|CONNECT
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|name
argument_list|,
name|NAME
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|rmhook
argument_list|,
name|RMHOOK
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|nodeinfo
argument_list|,
name|NODEINFO
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|typeinfo
argument_list|,
name|TYPEINFO
argument_list|,
operator|(
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|linkinfo
argument_list|,
name|LINKINFO
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfo_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get length of an array when the length is stored as a 32 bit    value immediately preceeding the array -- as with struct namelist    and struct typelist. */
end_comment

begin_function
specifier|static
name|int
name|ng_generic_list_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
return|return
operator|*
operator|(
operator|(
specifier|const
name|u_int32_t
operator|*
operator|)
operator|(
name|buf
operator|-
literal|4
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get length of the array of struct linkinfo inside a struct hooklist */
end_comment

begin_function
specifier|static
name|int
name|ng_generic_linkinfo_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|hooklist
modifier|*
name|hl
init|=
operator|(
specifier|const
expr|struct
name|hooklist
operator|*
operator|)
name|start
decl_stmt|;
return|return
name|hl
operator|->
name|nodeinfo
operator|.
name|hooks
return|;
block|}
end_function

begin_comment
comment|/* Array type for a variable length array of struct namelist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_nodeinfoarray_type_info
init|=
block|{
operator|&
name|ng_generic_nodeinfo_type
block|,
operator|&
name|ng_generic_list_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_nodeinfoarray_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_nodeinfoarray_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type for a variable length array of struct typelist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_typeinfoarray_type_info
init|=
block|{
operator|&
name|ng_generic_typeinfo_type
block|,
operator|&
name|ng_generic_list_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_typeinfoarray_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_typeinfoarray_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array type for array of struct linkinfo in struct hooklist */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_generic_linkinfo_array_type_info
init|=
block|{
operator|&
name|ng_generic_linkinfo_type
block|,
operator|&
name|ng_generic_linkinfo_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_generic_linkinfo_array_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_generic_linkinfo_array_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|typelist
argument_list|,
name|TYPELIST
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfoarray_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|hooklist
argument_list|,
name|HOOKLIST
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfo_type
operator|,
operator|&
name|ng_generic_linkinfo_array_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_PARSE_STRUCT_TYPE
argument_list|(
name|listnodes
argument_list|,
name|LISTNODES
argument_list|,
operator|(
operator|&
name|ng_generic_nodeinfoarray_type
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_generic_cmds
index|[]
init|=
block|{
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_SHUTDOWN
block|,
literal|"shutdown"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_MKPEER
block|,
literal|"mkpeer"
block|,
operator|&
name|ng_generic_mkpeer_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_CONNECT
block|,
literal|"connect"
block|,
operator|&
name|ng_generic_connect_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_NAME
block|,
literal|"name"
block|,
operator|&
name|ng_generic_name_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_RMHOOK
block|,
literal|"rmhook"
block|,
operator|&
name|ng_generic_rmhook_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_NODEINFO
block|,
literal|"nodeinfo"
block|,
name|NULL
block|,
operator|&
name|ng_generic_nodeinfo_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTHOOKS
block|,
literal|"listhooks"
block|,
name|NULL
block|,
operator|&
name|ng_generic_hooklist_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTNAMES
block|,
literal|"listnames"
block|,
name|NULL
block|,
operator|&
name|ng_generic_listnodes_type
comment|/* same as NGM_LISTNODES */
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTNODES
block|,
literal|"listnodes"
block|,
name|NULL
block|,
operator|&
name|ng_generic_listnodes_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_LISTTYPES
block|,
literal|"listtypes"
block|,
name|NULL
block|,
operator|&
name|ng_generic_typeinfo_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_TEXT_CONFIG
block|,
literal|"textconfig"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_TEXT_STATUS
block|,
literal|"textstatus"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_ASCII2BINARY
block|,
literal|"ascii2binary"
block|,
operator|&
name|ng_parse_ng_mesg_type
block|,
operator|&
name|ng_parse_ng_mesg_type
block|}
block|,
block|{
name|NGM_GENERIC_COOKIE
block|,
name|NGM_BINARY2ASCII
block|,
literal|"binary2ascii"
block|,
operator|&
name|ng_parse_ng_mesg_type
block|,
operator|&
name|ng_parse_ng_mesg_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			Node routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Instantiate a node of the requested type  */
end_comment

begin_function
name|int
name|ng_make_node
parameter_list|(
specifier|const
name|char
modifier|*
name|typename
parameter_list|,
name|node_p
modifier|*
name|nodepp
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
comment|/* Check that the type makes sense */
if|if
condition|(
name|typename
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Locate the node type */
if|if
condition|(
operator|(
name|type
operator|=
name|ng_findtype
argument_list|(
name|typename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|path
decl_stmt|,
name|filename
index|[
name|NG_TYPELEN
operator|+
literal|4
index|]
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Not found, try to load it as a loadable module */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ng_%s.ko"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|linker_search_path
argument_list|(
name|filename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|linker_load_file
argument_list|(
name|path
argument_list|,
operator|&
name|lf
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|path
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|lf
operator|->
name|userrefs
operator|++
expr_stmt|;
comment|/* pretend loaded by the syscall */
comment|/* Try again, as now the type should have linked itself in */
if|if
condition|(
operator|(
name|type
operator|=
name|ng_findtype
argument_list|(
name|typename
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Call the constructor */
if|if
condition|(
name|type
operator|->
name|constructor
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|type
operator|->
name|constructor
call|)
argument_list|(
name|nodepp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|ng_make_node_common
argument_list|(
name|type
argument_list|,
name|nodepp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generic node creation. Called by node constructors.  * The returned node has a reference count of 1.  */
end_comment

begin_function
name|int
name|ng_make_node_common
parameter_list|(
name|struct
name|ng_type
modifier|*
name|type
parameter_list|,
name|node_p
modifier|*
name|nodepp
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
comment|/* Require the node type to have been already installed */
if|if
condition|(
name|ng_findtype
argument_list|(
name|type
operator|->
name|name
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Make a node and try attach it to the type */
name|MALLOC
argument_list|(
name|node
argument_list|,
name|node_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|node
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* note reference */
name|type
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* Link us into the node linked list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nodelist
argument_list|,
name|node
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
comment|/* Initialize hook list for new node */
name|LIST_INIT
argument_list|(
operator|&
name|node
operator|->
name|hooks
argument_list|)
expr_stmt|;
comment|/* get an ID and put us in the hash chain */
name|node
operator|->
name|ID
operator|=
name|nextID
operator|++
expr_stmt|;
comment|/* 137 per second for 1 year before wrap */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ID_hash
index|[
name|node
operator|->
name|ID
operator|%
name|ID_HASH_SIZE
index|]
argument_list|,
name|node
argument_list|,
name|idnodes
argument_list|)
expr_stmt|;
comment|/* Done */
operator|*
name|nodepp
operator|=
name|node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forceably start the shutdown process on a node. Either call  * it's shutdown method, or do the default shutdown if there is  * no type-specific method.  *  * Persistent nodes must have a type-specific method which  * resets the NG_INVALID flag.  */
end_comment

begin_function
name|void
name|ng_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
comment|/* Check if it's already shutting down */
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|!=
literal|0
condition|)
return|return;
comment|/* Add an extra reference so it doesn't go away during this */
name|node
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* Mark it invalid so any newcomers know not to try use it */
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
comment|/* Ask the type if it has anything to do in this case */
if|if
condition|(
name|node
operator|->
name|type
operator|&&
name|node
operator|->
name|type
operator|->
name|shutdown
condition|)
call|(
modifier|*
name|node
operator|->
name|type
operator|->
name|shutdown
call|)
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* do the default thing */
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* Remove extra reference, possibly the last */
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called by the destructor to remove any STANDARD external references  */
end_comment

begin_function
name|void
name|ng_cutlinks
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
comment|/* Make sure that this is set to stop infinite loops */
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
comment|/* If we have sleepers, wake them up; they'll see NG_INVALID */
if|if
condition|(
name|node
operator|->
name|sleepers
condition|)
name|wakeup
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Notify all remaining connected nodes to disconnect */
while|while
condition|(
operator|(
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|node
operator|->
name|hooks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference to the node, possibly the last  */
end_comment

begin_function
name|void
name|ng_unref
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|node
operator|->
name|refs
operator|<=
literal|0
condition|)
block|{
name|node
operator|->
name|type
operator|->
name|refs
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|nodes
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|idnodes
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|node
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for a node to come ready. Returns a node with a reference count;  * don't forget to drop it when we are done with it using ng_release_node().  */
end_comment

begin_function
name|int
name|ng_wait_node
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
name|msg
operator|=
literal|"netgraph"
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|node
operator|->
name|sleepers
operator|++
expr_stmt|;
name|node
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* the sleeping process counts as a reference */
while|while
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
operator|(
name|NG_BUSY
operator||
name|NG_INVALID
operator|)
operator|)
operator|==
name|NG_BUSY
condition|)
name|error
operator|=
name|tsleep
argument_list|(
name|node
argument_list|,
operator|(
name|PZERO
operator|+
literal|1
operator|)
operator||
name|PCATCH
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|node
operator|->
name|sleepers
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|node
operator|->
name|refs
operator|>
literal|1
argument_list|,
operator|(
literal|"%s: refs=%d"
operator|,
name|__FUNCTION__
operator|,
name|node
operator|->
name|refs
operator|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_BUSY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Release the reference we had on it */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Release a node acquired via ng_wait_node()  */
end_comment

begin_function
name|void
name|ng_release_node
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
comment|/* Declare that we don't want it */
name|node
operator|->
name|flags
operator|&=
operator|~
name|NG_BUSY
expr_stmt|;
comment|/* If we have sleepers, then wake them up */
if|if
condition|(
name|node
operator|->
name|sleepers
condition|)
name|wakeup
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* We also have a reference.. drop it too */
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Node ID handling ************************************************************************/
end_comment

begin_function
specifier|static
name|node_p
name|ng_ID2node
parameter_list|(
name|ng_ID_t
name|ID
parameter_list|)
block|{
name|node_p
name|np
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&ID_hash[ID % ID_HASH_SIZE]
argument_list|,
argument|idnodes
argument_list|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|==
literal|0
operator|&&
name|np
operator|->
name|ID
operator|==
name|ID
condition|)
break|break;
block|}
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
name|ng_ID_t
name|ng_node2ID
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|ID
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Node name handling ************************************************************************/
end_comment

begin_comment
comment|/*  * Assign a node a name. Once assigned, the name cannot be changed.  */
end_comment

begin_function
name|int
name|ng_name_node
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Check the name is valid */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_NODELEN
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|name
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|name
index|[
name|i
index|]
operator|==
literal|'.'
operator|||
name|name
index|[
name|i
index|]
operator|==
literal|':'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ng_decodeidname
argument_list|(
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* valid IDs not allowed here */
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check the node isn't already named */
if|if
condition|(
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EISCONN
operator|)
return|;
block|}
comment|/* Check the name isn't already being used */
if|if
condition|(
name|ng_findname
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
comment|/* Allocate space and copy it */
name|MALLOC
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* The name counts as a reference */
name|node
operator|->
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a node by absolute name. The name should NOT end with ':'  * The name "." means "this node" and "[xxx]" means "the node  * with ID (ie, at address) xxx".  *  * Returns the node if found, else NULL.  */
end_comment

begin_function
name|node_p
name|ng_findname
parameter_list|(
name|node_p
name|this
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|node_p
name|node
decl_stmt|;
name|ng_ID_t
name|temp
decl_stmt|;
comment|/* "." means "this node" */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|this
operator|)
return|;
comment|/* Check for name-by-ID */
if|if
condition|(
operator|(
name|temp
operator|=
name|ng_decodeidname
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ng_ID2node
argument_list|(
name|temp
argument_list|)
operator|)
return|;
block|}
comment|/* Find node by name */
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&nodelist
argument_list|,
argument|nodes
argument_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode a ID name, eg. "[f03034de]". Returns 0 if the  * string is not valid, otherwise returns the value.  */
end_comment

begin_function
specifier|static
name|ng_ID_t
name|ng_decodeidname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|u_long
name|val
decl_stmt|;
comment|/* Check for proper length, brackets, no leading junk */
if|if
condition|(
name|len
operator|<
literal|3
operator|||
name|name
index|[
literal|0
index|]
operator|!=
literal|'['
operator|||
name|name
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|']'
operator|||
operator|!
name|isxdigit
argument_list|(
name|name
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Decode number */
name|val
operator|=
name|strtoul
argument_list|(
name|name
operator|+
literal|1
argument_list|,
operator|&
name|eptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|-
name|name
operator|!=
name|len
operator|-
literal|1
operator|||
name|val
operator|==
name|ULONG_MAX
operator|||
name|val
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|ng_ID_t
operator|)
literal|0
operator|)
return|;
return|return
operator|(
name|ng_ID_t
operator|)
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a name from a node. This should only be called  * when shutting down and removing the node.  */
end_comment

begin_function
name|void
name|ng_unname
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|name
condition|)
block|{
name|FREE
argument_list|(
name|node
operator|->
name|name
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|node
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************ 			Hook routines   Names are not optional. Hooks are always connected, except for a  brief moment within these routines.  ************************************************************************/
end_comment

begin_comment
comment|/*  * Remove a hook reference  */
end_comment

begin_function
name|void
name|ng_unref_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|hook
operator|->
name|refs
operator|==
literal|0
condition|)
name|FREE
argument_list|(
name|hook
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an unconnected hook to a node. Only used internally.  */
end_comment

begin_function
specifier|static
name|int
name|ng_add_hook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|hook_p
modifier|*
name|hookp
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check that the given name is good */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* Allocate the hook and link it up */
name|MALLOC
argument_list|(
name|hook
argument_list|,
name|hook_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hook
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|hook
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|hook
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
name|hook
operator|->
name|flags
operator|=
name|HK_INVALID
expr_stmt|;
name|hook
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* each hook counts as a reference */
comment|/* Check if the node type code has something to say about it */
if|if
condition|(
name|node
operator|->
name|type
operator|->
name|newhook
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|node
operator|->
name|type
operator|->
name|newhook
call|)
argument_list|(
name|node
argument_list|,
name|hook
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * The 'type' agrees so far, so go ahead and link it in. 	 * We'll ask again later when we actually connect the hooks. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|node
operator|->
name|hooks
argument_list|,
name|hook
argument_list|,
name|hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|numhooks
operator|++
expr_stmt|;
comment|/* Set hook name */
name|MALLOC
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|hook
argument_list|,
name|hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|numhooks
operator|--
expr_stmt|;
name|fail
label|:
name|hook
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unref_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* this frees the hook */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|hookp
condition|)
operator|*
name|hookp
operator|=
name|hook
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Connect a pair of hooks. Only used internally.  */
end_comment

begin_function
specifier|static
name|int
name|ng_connect
parameter_list|(
name|hook_p
name|hook1
parameter_list|,
name|hook_p
name|hook2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|hook1
operator|->
name|peer
operator|=
name|hook2
expr_stmt|;
name|hook2
operator|->
name|peer
operator|=
name|hook1
expr_stmt|;
comment|/* Give each node the opportunity to veto the impending connection */
if|if
condition|(
name|hook1
operator|->
name|node
operator|->
name|type
operator|->
name|connect
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|hook1
operator|->
name|node
operator|->
name|type
operator|->
name|connect
call|)
argument_list|(
name|hook1
argument_list|)
operator|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
comment|/* also zaps hook2 */
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|hook2
operator|->
name|node
operator|->
name|type
operator|->
name|connect
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|hook2
operator|->
name|node
operator|->
name|type
operator|->
name|connect
call|)
argument_list|(
name|hook2
argument_list|)
operator|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
comment|/* also zaps hook1 */
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|hook1
operator|->
name|flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
name|hook2
operator|->
name|flags
operator|&=
operator|~
name|HK_INVALID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a hook  *  * Node types may supply their own optimized routines for finding  * hooks.  If none is supplied, we just do a linear search.  */
end_comment

begin_function
name|hook_p
name|ng_findhook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|->
name|findhook
operator|!=
name|NULL
condition|)
return|return
call|(
modifier|*
name|node
operator|->
name|type
operator|->
name|findhook
call|)
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
return|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
if|if
condition|(
name|hook
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|hook
operator|->
name|flags
operator|&
name|HK_INVALID
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|hook
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a hook  *  * As hooks are always attached, this really destroys two hooks.  * The one given, and the one attached to it. Disconnect the hooks  * from each other first.  */
end_comment

begin_function
name|void
name|ng_destroy_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|hook_p
name|peer
init|=
name|hook
operator|->
name|peer
decl_stmt|;
name|hook
operator|->
name|flags
operator||=
name|HK_INVALID
expr_stmt|;
comment|/* as soon as possible */
if|if
condition|(
name|peer
condition|)
block|{
name|peer
operator|->
name|flags
operator||=
name|HK_INVALID
expr_stmt|;
comment|/* as soon as possible */
name|hook
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|peer
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|ng_disconnect_hook
argument_list|(
name|peer
argument_list|)
expr_stmt|;
block|}
name|ng_disconnect_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notify the node of the hook's demise. This may result in more actions  * (e.g. shutdown) but we don't do that ourselves and don't know what  * happens there. If there is no appropriate handler, then just remove it  * (and decrement the reference count of it's node which in turn might  * make something happen).  */
end_comment

begin_function
specifier|static
name|void
name|ng_disconnect_hook
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
comment|/* 	 * Remove the hook from the node's list to avoid possible recursion 	 * in case the disconnection results in node shutdown. 	 */
name|LIST_REMOVE
argument_list|(
name|hook
argument_list|,
name|hooks
argument_list|)
expr_stmt|;
name|node
operator|->
name|numhooks
operator|--
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|type
operator|->
name|disconnect
condition|)
block|{
comment|/* 		 * The type handler may elect to destroy the peer so don't 		 * trust its existance after this point. 		 */
call|(
modifier|*
name|node
operator|->
name|type
operator|->
name|disconnect
call|)
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* might be the last reference */
if|if
condition|(
name|hook
operator|->
name|name
condition|)
name|FREE
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|hook
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* may still be referenced elsewhere */
name|ng_unref_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take two hooks on a node and merge the connection so that the given node  * is effectively bypassed.  */
end_comment

begin_function
name|int
name|ng_bypass
parameter_list|(
name|hook_p
name|hook1
parameter_list|,
name|hook_p
name|hook2
parameter_list|)
block|{
if|if
condition|(
name|hook1
operator|->
name|node
operator|!=
name|hook2
operator|->
name|node
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hook1
operator|->
name|peer
operator|->
name|peer
operator|=
name|hook2
operator|->
name|peer
expr_stmt|;
name|hook2
operator|->
name|peer
operator|->
name|peer
operator|=
name|hook1
operator|->
name|peer
expr_stmt|;
comment|/* XXX If we ever cache methods on hooks update them as well */
name|hook1
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|hook2
operator|->
name|peer
operator|=
name|NULL
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook1
argument_list|)
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Install a new netgraph type  */
end_comment

begin_function
name|int
name|ng_newtype
parameter_list|(
name|struct
name|ng_type
modifier|*
name|tp
parameter_list|)
block|{
specifier|const
name|size_t
name|namelen
init|=
name|strlen
argument_list|(
name|tp
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* Check version and type name fields */
if|if
condition|(
name|tp
operator|->
name|version
operator|!=
name|NG_VERSION
operator|||
name|namelen
operator|==
literal|0
operator|||
name|namelen
operator|>
name|NG_TYPELEN
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check for name collision */
if|if
condition|(
name|ng_findtype
argument_list|(
name|tp
operator|->
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* Link in new type */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|typelist
argument_list|,
name|tp
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|tp
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
comment|/* first ref is linked list */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for a type of the name given  */
end_comment

begin_function
name|struct
name|ng_type
modifier|*
name|ng_findtype
parameter_list|(
specifier|const
name|char
modifier|*
name|typename
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&typelist
argument_list|,
argument|types
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|type
operator|->
name|name
argument_list|,
name|typename
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Composite routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Make a peer and connect. The order is arranged to minimise  * the work needed to back out in case of error.  */
end_comment

begin_function
name|int
name|ng_mkpeer
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|,
name|char
modifier|*
name|type
parameter_list|)
block|{
name|node_p
name|node2
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|hook2
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|hook
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node
argument_list|(
name|type
argument_list|,
operator|&
name|node2
argument_list|)
operator|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node2
argument_list|,
name|name2
argument_list|,
operator|&
name|hook2
argument_list|)
operator|)
condition|)
block|{
name|ng_rmnode
argument_list|(
name|node2
argument_list|)
expr_stmt|;
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Actually link the two hooks together.. on failure they are 	 * destroyed so we don't have to do that here. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_connect
argument_list|(
name|hook
argument_list|,
name|hook2
argument_list|)
operator|)
condition|)
name|ng_rmnode
argument_list|(
name|node2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Connect two nodes using the specified hooks  */
end_comment

begin_function
name|int
name|ng_con_nodes
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|node_p
name|node2
parameter_list|,
specifier|const
name|char
modifier|*
name|name2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|hook_p
name|hook2
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node
argument_list|,
name|name
argument_list|,
operator|&
name|hook
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_add_hook
argument_list|(
name|node2
argument_list|,
name|name2
argument_list|,
operator|&
name|hook2
argument_list|)
operator|)
condition|)
block|{
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|ng_connect
argument_list|(
name|hook
argument_list|,
name|hook2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse and verify a string of the form:<NODE:><PATH>  *  * Such a string can refer to a specific node or a specific hook  * on a specific node, depending on how you look at it. In the  * latter case, the PATH component must not end in a dot.  *  * Both<NODE:> and<PATH> are optional. The<PATH> is a string  * of hook names separated by dots. This breaks out the original  * string, setting *nodep to "NODE" (or NULL if none) and *pathp  * to "PATH" (or NULL if degenerate). Also, *hookp will point to  * the final hook component of<PATH>, if any, otherwise NULL.  *  * This returns -1 if the path is malformed. The char ** are optional.  */
end_comment

begin_function
name|int
name|ng_path_parse
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|,
name|char
modifier|*
modifier|*
name|nodep
parameter_list|,
name|char
modifier|*
modifier|*
name|pathp
parameter_list|,
name|char
modifier|*
modifier|*
name|hookp
parameter_list|)
block|{
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|path
decl_stmt|,
modifier|*
name|hook
decl_stmt|;
name|int
name|k
decl_stmt|;
comment|/* 	 * Extract absolute NODE, if any 	 */
for|for
control|(
name|path
operator|=
name|addr
init|;
operator|*
name|path
operator|&&
operator|*
name|path
operator|!=
literal|':'
condition|;
name|path
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|path
condition|)
block|{
name|node
operator|=
name|addr
expr_stmt|;
comment|/* Here's the NODE */
operator|*
name|path
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Here's the PATH */
comment|/* Node name must not be empty */
if|if
condition|(
operator|!
operator|*
name|node
condition|)
return|return
operator|-
literal|1
return|;
comment|/* A name of "." is OK; otherwise '.' not allowed */
if|if
condition|(
name|strcmp
argument_list|(
name|node
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|node
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|node
index|[
name|k
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|node
operator|=
name|NULL
expr_stmt|;
comment|/* No absolute NODE */
name|path
operator|=
name|addr
expr_stmt|;
comment|/* Here's the PATH */
block|}
comment|/* Snoop for illegal characters in PATH */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|':'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check for no repeated dots in PATH */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|'.'
operator|&&
name|path
index|[
name|k
operator|+
literal|1
index|]
operator|==
literal|'.'
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Remove extra (degenerate) dots from beginning or end of PATH */
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
name|path
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|&&
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|path
index|[
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If PATH has a dot, then we're not talking about a hook */
if|if
condition|(
operator|*
name|path
condition|)
block|{
for|for
control|(
name|hook
operator|=
name|path
operator|,
name|k
operator|=
literal|0
init|;
name|path
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|path
index|[
name|k
index|]
operator|==
literal|'.'
condition|)
block|{
name|hook
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|path
operator|=
name|hook
operator|=
name|NULL
expr_stmt|;
comment|/* Done */
if|if
condition|(
name|nodep
condition|)
operator|*
name|nodep
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|pathp
condition|)
operator|*
name|pathp
operator|=
name|path
expr_stmt|;
if|if
condition|(
name|hookp
condition|)
operator|*
name|hookp
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a path, which may be absolute or relative, and a starting node,  * return the destination node. Compute the "return address" if desired.  */
end_comment

begin_function
name|int
name|ng_path2node
parameter_list|(
name|node_p
name|here
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|node_p
modifier|*
name|destp
parameter_list|,
name|char
modifier|*
modifier|*
name|rtnp
parameter_list|)
block|{
specifier|const
name|node_p
name|start
init|=
name|here
decl_stmt|;
name|char
name|fullpath
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|nodename
decl_stmt|,
modifier|*
name|path
decl_stmt|,
name|pbuf
index|[
literal|2
index|]
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Initialize */
if|if
condition|(
name|rtnp
condition|)
operator|*
name|rtnp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|destp
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
operator|*
name|destp
operator|=
name|NULL
expr_stmt|;
comment|/* Make a writable copy of address for ng_path_parse() */
name|strncpy
argument_list|(
name|fullpath
argument_list|,
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|fullpath
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fullpath
index|[
sizeof|sizeof
argument_list|(
name|fullpath
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Parse out node and sequence of hooks */
if|if
condition|(
name|ng_path_parse
argument_list|(
name|fullpath
argument_list|,
operator|&
name|nodename
argument_list|,
operator|&
name|path
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|pbuf
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
comment|/* Needs to be writable */
name|pbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|path
operator|=
name|pbuf
expr_stmt|;
block|}
comment|/* For an absolute address, jump to the starting node */
if|if
condition|(
name|nodename
condition|)
block|{
name|node
operator|=
name|ng_findname
argument_list|(
name|here
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
else|else
name|node
operator|=
name|here
expr_stmt|;
comment|/* Now follow the sequence of hooks */
for|for
control|(
name|cp
operator|=
name|path
init|;
name|node
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
control|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|char
modifier|*
name|segment
decl_stmt|;
comment|/* 		 * Break out the next path segment. Replace the dot we just 		 * found with a NUL; "cp" points to the next segment (or the 		 * NUL at the end). 		 */
for|for
control|(
name|segment
operator|=
name|cp
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
comment|/* Empty segment */
if|if
condition|(
operator|*
name|segment
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* We have a segment, so look for a hook by that name */
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|segment
argument_list|)
expr_stmt|;
comment|/* Can't get there from here... */
if|if
condition|(
name|hook
operator|==
name|NULL
operator|||
name|hook
operator|->
name|peer
operator|==
name|NULL
operator|||
operator|(
name|hook
operator|->
name|flags
operator|&
name|HK_INVALID
operator|)
operator|!=
literal|0
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* Hop on over to the next node */
name|node
operator|=
name|hook
operator|->
name|peer
operator|->
name|node
expr_stmt|;
block|}
comment|/* If node somehow missing, fail here (probably this is not needed) */
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Now compute return address, i.e., the path to the sender */
if|if
condition|(
name|rtnp
operator|!=
name|NULL
condition|)
block|{
name|MALLOC
argument_list|(
operator|*
name|rtnp
argument_list|,
name|char
operator|*
argument_list|,
name|NG_NODELEN
operator|+
literal|2
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rtnp
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|->
name|name
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
operator|*
name|rtnp
argument_list|,
literal|"%s:"
argument_list|,
name|start
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|*
name|rtnp
argument_list|,
literal|"[%x]:"
argument_list|,
name|ng_node2ID
argument_list|(
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Done */
operator|*
name|destp
operator|=
name|node
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Call the appropriate message handler for the object.  * It is up to the message handler to free the message.  * If it's a generic message, handle it generically, otherwise  * call the type's message handler (if it exists)  * XXX (race). Remember that a queued message may reference a node  * or hook that has just been invalidated. It will exist  * as the queue code is holding a reference, but..  */
end_comment

begin_define
define|#
directive|define
name|CALL_MSG_HANDLER
parameter_list|(
name|error
parameter_list|,
name|node
parameter_list|,
name|msg
parameter_list|,
name|retaddr
parameter_list|,
name|resp
parameter_list|)
define|\
value|do {									\ 	if((msg)->header.typecookie == NGM_GENERIC_COOKIE) {		\ 		(error) = ng_generic_msg((node), (msg),			\ 				(retaddr), (resp));			\ 	} else {							\ 		if ((node)->type->rcvmsg != NULL) {			\ 			(error) = (*(node)->type->rcvmsg)((node),	\ 					(msg), (retaddr), (resp));	\ 		} else {						\ 			TRAP_ERROR;					\ 			FREE((msg), M_NETGRAPH);			\ 			(error) = EINVAL;				\ 		}							\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * Send a control message to a node  */
end_comment

begin_function
name|int
name|ng_send_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
name|node_p
name|dest
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retaddr
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Find the target node */
name|error
operator|=
name|ng_path2node
argument_list|(
name|here
argument_list|,
name|address
argument_list|,
operator|&
name|dest
argument_list|,
operator|&
name|retaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Make sure the resp field is null before we start */
if|if
condition|(
name|rptr
operator|!=
name|NULL
condition|)
operator|*
name|rptr
operator|=
name|NULL
expr_stmt|;
name|CALL_MSG_HANDLER
argument_list|(
name|error
argument_list|,
name|dest
argument_list|,
name|msg
argument_list|,
name|retaddr
argument_list|,
name|rptr
argument_list|)
expr_stmt|;
comment|/* Make sure that if there is a response, it has the RESP bit set */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
name|rptr
operator|&&
operator|*
name|rptr
condition|)
operator|(
operator|*
name|rptr
operator|)
operator|->
name|header
operator|.
name|flags
operator||=
name|NGF_RESP
expr_stmt|;
comment|/* 	 * If we had a return address it is up to us to free it. They should 	 * have taken a copy if they needed to make a delayed response. 	 */
if|if
condition|(
name|retaddr
condition|)
name|FREE
argument_list|(
name|retaddr
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement the 'generic' control messages  */
end_comment

begin_function
specifier|static
name|int
name|ng_generic_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|!=
name|NGM_GENERIC_COOKIE
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SHUTDOWN
case|:
name|ng_rmnode
argument_list|(
name|here
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_MKPEER
case|:
block|{
name|struct
name|ngm_mkpeer
modifier|*
specifier|const
name|mkp
init|=
operator|(
expr|struct
name|ngm_mkpeer
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|mkp
argument_list|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|mkp
operator|->
name|type
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|type
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkp
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mkp
operator|->
name|peerhook
index|[
sizeof|sizeof
argument_list|(
name|mkp
operator|->
name|peerhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ng_mkpeer
argument_list|(
name|here
argument_list|,
name|mkp
operator|->
name|ourhook
argument_list|,
name|mkp
operator|->
name|peerhook
argument_list|,
name|mkp
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_CONNECT
case|:
block|{
name|struct
name|ngm_connect
modifier|*
specifier|const
name|con
init|=
operator|(
expr|struct
name|ngm_connect
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|node_p
name|node2
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|con
argument_list|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|con
operator|->
name|path
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|path
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|con
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|con
operator|->
name|peerhook
index|[
sizeof|sizeof
argument_list|(
name|con
operator|->
name|peerhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ng_path2node
argument_list|(
name|here
argument_list|,
name|con
operator|->
name|path
argument_list|,
operator|&
name|node2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|ng_con_nodes
argument_list|(
name|here
argument_list|,
name|con
operator|->
name|ourhook
argument_list|,
name|node2
argument_list|,
name|con
operator|->
name|peerhook
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_NAME
case|:
block|{
name|struct
name|ngm_name
modifier|*
specifier|const
name|nam
init|=
operator|(
expr|struct
name|ngm_name
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|nam
argument_list|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nam
operator|->
name|name
index|[
sizeof|sizeof
argument_list|(
name|nam
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|ng_name_node
argument_list|(
name|here
argument_list|,
name|nam
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_RMHOOK
case|:
block|{
name|struct
name|ngm_rmhook
modifier|*
specifier|const
name|rmh
init|=
operator|(
expr|struct
name|ngm_rmhook
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rmh
argument_list|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|rmh
operator|->
name|ourhook
index|[
sizeof|sizeof
argument_list|(
name|rmh
operator|->
name|ourhook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|here
argument_list|,
name|rmh
operator|->
name|ourhook
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ng_destroy_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_NODEINFO
case|:
block|{
name|struct
name|nodeinfo
modifier|*
name|ni
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|;
comment|/* Get response struct */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ni
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* Fill in node info */
name|ni
operator|=
operator|(
expr|struct
name|nodeinfo
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|here
operator|->
name|name
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|ni
operator|->
name|name
argument_list|,
name|here
operator|->
name|name
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ni
operator|->
name|type
argument_list|,
name|here
operator|->
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|ni
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
name|ni
operator|->
name|hooks
operator|=
name|here
operator|->
name|numhooks
expr_stmt|;
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LISTHOOKS
case|:
block|{
specifier|const
name|int
name|nhooks
init|=
name|here
operator|->
name|numhooks
decl_stmt|;
name|struct
name|hooklist
modifier|*
name|hl
decl_stmt|;
name|struct
name|nodeinfo
modifier|*
name|ni
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Get response struct */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hl
argument_list|)
operator|+
operator|(
name|nhooks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linkinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|hl
operator|=
operator|(
expr|struct
name|hooklist
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
name|ni
operator|=
operator|&
name|hl
operator|->
name|nodeinfo
expr_stmt|;
comment|/* Fill in node info */
if|if
condition|(
name|here
operator|->
name|name
condition|)
name|strncpy
argument_list|(
name|ni
operator|->
name|name
argument_list|,
name|here
operator|->
name|name
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|ni
operator|->
name|type
argument_list|,
name|here
operator|->
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|ni
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|here
argument_list|)
expr_stmt|;
comment|/* Cycle through the linked list of hooks */
name|ni
operator|->
name|hooks
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&here->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
name|struct
name|linkinfo
modifier|*
specifier|const
name|link
init|=
operator|&
name|hl
operator|->
name|link
index|[
name|ni
operator|->
name|hooks
index|]
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|hooks
operator|>=
name|nhooks
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__FUNCTION__
argument_list|,
literal|"hooks"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|hook
operator|->
name|flags
operator|&
name|HK_INVALID
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|strncpy
argument_list|(
name|link
operator|->
name|ourhook
argument_list|,
name|hook
operator|->
name|name
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|link
operator|->
name|peerhook
argument_list|,
name|hook
operator|->
name|peer
operator|->
name|name
argument_list|,
name|NG_HOOKLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|link
operator|->
name|nodeinfo
operator|.
name|name
argument_list|,
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|name
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|link
operator|->
name|nodeinfo
operator|.
name|type
argument_list|,
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|link
operator|->
name|nodeinfo
operator|.
name|id
operator|=
name|ng_node2ID
argument_list|(
name|hook
operator|->
name|peer
operator|->
name|node
argument_list|)
expr_stmt|;
name|link
operator|->
name|nodeinfo
operator|.
name|hooks
operator|=
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|numhooks
expr_stmt|;
name|ni
operator|->
name|hooks
operator|++
expr_stmt|;
block|}
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LISTNAMES
case|:
case|case
name|NGM_LISTNODES
case|:
block|{
specifier|const
name|int
name|unnamed
init|=
operator|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_LISTNODES
operator|)
decl_stmt|;
name|struct
name|namelist
modifier|*
name|nl
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Count number of nodes */
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&nodelist
argument_list|,
argument|nodes
argument_list|)
block|{
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|==
literal|0
operator|&&
operator|(
name|unnamed
operator|||
name|node
operator|->
name|name
operator|!=
name|NULL
operator|)
condition|)
name|num
operator|++
expr_stmt|;
block|}
comment|/* Get response struct */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nl
argument_list|)
operator|+
operator|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nodeinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|nl
operator|=
operator|(
expr|struct
name|namelist
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
comment|/* Cycle through the linked list of nodes */
name|nl
operator|->
name|numnames
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|node
argument_list|,
argument|&nodelist
argument_list|,
argument|nodes
argument_list|)
block|{
name|struct
name|nodeinfo
modifier|*
specifier|const
name|np
init|=
operator|&
name|nl
operator|->
name|nodeinfo
index|[
name|nl
operator|->
name|numnames
index|]
decl_stmt|;
if|if
condition|(
name|nl
operator|->
name|numnames
operator|>=
name|num
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__FUNCTION__
argument_list|,
literal|"nodes"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|unnamed
operator|&&
name|node
operator|->
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|np
operator|->
name|name
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|NG_NODELEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|np
operator|->
name|type
argument_list|,
name|node
operator|->
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|np
operator|->
name|id
operator|=
name|ng_node2ID
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|np
operator|->
name|hooks
operator|=
name|node
operator|->
name|numhooks
expr_stmt|;
name|nl
operator|->
name|numnames
operator|++
expr_stmt|;
block|}
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_LISTTYPES
case|:
block|{
name|struct
name|typelist
modifier|*
name|tl
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|;
name|struct
name|ng_type
modifier|*
name|type
decl_stmt|;
name|int
name|num
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Count number of types */
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&typelist
argument_list|,
argument|types
argument_list|)
name|num
operator|++
expr_stmt|;
comment|/* Get response struct */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tl
argument_list|)
operator|+
operator|(
name|num
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|typeinfo
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|tl
operator|=
operator|(
expr|struct
name|typelist
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
comment|/* Cycle through the linked list of types */
name|tl
operator|->
name|numtypes
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|type
argument_list|,
argument|&typelist
argument_list|,
argument|types
argument_list|)
block|{
name|struct
name|typeinfo
modifier|*
specifier|const
name|tp
init|=
operator|&
name|tl
operator|->
name|typeinfo
index|[
name|tl
operator|->
name|numtypes
index|]
decl_stmt|;
if|if
condition|(
name|tl
operator|->
name|numtypes
operator|>=
name|num
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: number of %s changed\n"
argument_list|,
name|__FUNCTION__
argument_list|,
literal|"types"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|tp
operator|->
name|type_name
argument_list|,
name|type
operator|->
name|name
argument_list|,
name|NG_TYPELEN
argument_list|)
expr_stmt|;
name|tp
operator|->
name|numnodes
operator|=
name|type
operator|->
name|refs
operator|-
literal|1
expr_stmt|;
comment|/* don't count list */
name|tl
operator|->
name|numtypes
operator|++
expr_stmt|;
block|}
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_BINARY2ASCII
case|:
block|{
name|int
name|bufSize
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
comment|/* XXX hard coded constant */
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|argstype
decl_stmt|;
specifier|const
name|struct
name|ng_cmdlist
modifier|*
name|c
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|,
modifier|*
name|binary
decl_stmt|,
modifier|*
name|ascii
decl_stmt|;
comment|/* Data area must contain a valid netgraph message */
name|binary
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|||
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|<
name|binary
operator|->
name|header
operator|.
name|arglen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Get a response message with lots of room */
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|bufSize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|ascii
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
comment|/* Copy binary message header to response message payload */
name|bcopy
argument_list|(
name|binary
argument_list|,
name|ascii
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find command by matching typecookie and command number */
for|for
control|(
name|c
operator|=
name|here
operator|->
name|type
operator|->
name|cmdlist
init|;
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|==
name|c
operator|->
name|cookie
operator|&&
name|binary
operator|->
name|header
operator|.
name|cmd
operator|==
name|c
operator|->
name|cmd
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|c
operator|=
name|ng_generic_cmds
init|;
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|==
name|c
operator|->
name|cookie
operator|&&
name|binary
operator|->
name|header
operator|.
name|cmd
operator|==
name|c
operator|->
name|cmd
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|rp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
block|}
comment|/* Convert command name to ASCII */
name|snprintf
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
sizeof|sizeof
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Convert command arguments to ASCII */
name|argstype
operator|=
operator|(
name|binary
operator|->
name|header
operator|.
name|flags
operator|&
name|NGF_RESP
operator|)
condition|?
name|c
operator|->
name|respType
else|:
name|c
operator|->
name|mesgType
expr_stmt|;
if|if
condition|(
name|argstype
operator|==
name|NULL
condition|)
operator|*
name|ascii
operator|->
name|data
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_unparse
argument_list|(
name|argstype
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|binary
operator|->
name|data
argument_list|,
name|ascii
operator|->
name|data
argument_list|,
name|bufSize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|rp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Return the result as struct ng_mesg plus ASCII string */
name|bufSize
operator|=
name|strlen
argument_list|(
name|ascii
operator|->
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|=
name|bufSize
expr_stmt|;
name|rp
operator|->
name|header
operator|.
name|arglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|bufSize
expr_stmt|;
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ASCII2BINARY
case|:
block|{
name|int
name|bufSize
init|=
literal|2000
decl_stmt|;
comment|/* XXX hard coded constant */
specifier|const
name|struct
name|ng_cmdlist
modifier|*
name|c
decl_stmt|;
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|argstype
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|rp
decl_stmt|,
modifier|*
name|ascii
decl_stmt|,
modifier|*
name|binary
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
comment|/* Data area must contain at least a struct ng_mesg + '\0' */
name|ascii
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
literal|1
operator|||
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|<
literal|1
operator|||
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
operator|+
name|ascii
operator|->
name|header
operator|.
name|arglen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ascii
operator|->
name|data
index|[
name|ascii
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Get a response message with lots of room */
name|NG_MKRESPONSE
argument_list|(
name|rp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
operator|+
name|bufSize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|binary
operator|=
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|rp
operator|->
name|data
expr_stmt|;
comment|/* Copy ASCII message header to response message payload */
name|bcopy
argument_list|(
name|ascii
argument_list|,
name|binary
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ascii
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find command by matching ASCII command string */
for|for
control|(
name|c
operator|=
name|here
operator|->
name|type
operator|->
name|cmdlist
init|;
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|c
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|c
operator|=
name|ng_generic_cmds
init|;
name|c
operator|->
name|name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ascii
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|c
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|rp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
block|}
comment|/* Convert command name to binary */
name|binary
operator|->
name|header
operator|.
name|cmd
operator|=
name|c
operator|->
name|cmd
expr_stmt|;
name|binary
operator|->
name|header
operator|.
name|typecookie
operator|=
name|c
operator|->
name|cookie
expr_stmt|;
comment|/* Convert command arguments to binary */
name|argstype
operator|=
operator|(
name|binary
operator|->
name|header
operator|.
name|flags
operator|&
name|NGF_RESP
operator|)
condition|?
name|c
operator|->
name|respType
else|:
name|c
operator|->
name|mesgType
expr_stmt|;
if|if
condition|(
name|argstype
operator|==
name|NULL
condition|)
name|bufSize
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_parse
argument_list|(
name|argstype
argument_list|,
name|ascii
operator|->
name|data
argument_list|,
operator|&
name|off
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|binary
operator|->
name|data
argument_list|,
operator|&
name|bufSize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|rp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Return the result */
name|binary
operator|->
name|header
operator|.
name|arglen
operator|=
name|bufSize
expr_stmt|;
name|rp
operator|->
name|header
operator|.
name|arglen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|binary
argument_list|)
operator|+
name|bufSize
expr_stmt|;
operator|*
name|resp
operator|=
name|rp
expr_stmt|;
break|break;
block|}
case|case
name|NGM_TEXT_CONFIG
case|:
case|case
name|NGM_TEXT_STATUS
case|:
comment|/* 		 * This one is tricky as it passes the command down to the 		 * actual node, even though it is a generic type command. 		 * This means we must assume that the msg is already freed 		 * when control passes back to us. 		 */
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|here
operator|->
name|type
operator|->
name|rcvmsg
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|here
operator|->
name|type
operator|->
name|rcvmsg
call|)
argument_list|(
name|here
argument_list|,
name|msg
argument_list|,
name|retaddr
argument_list|,
name|resp
argument_list|)
operator|)
return|;
comment|/* Fall through if rcvmsg not supported */
default|default:
name|TRAP_ERROR
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a data packet to a node. If the recipient has no  * 'receive data' method, then silently discard the packet.  */
end_comment

begin_function
name|int
name|ng_send_data
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|rcvdata
function_decl|)
parameter_list|(
name|hook_p
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|meta_p
parameter_list|)
function_decl|;
name|int
name|error
decl_stmt|;
name|CHECK_DATA_MBUF
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|&&
operator|(
name|hook
operator|->
name|flags
operator|&
name|HK_INVALID
operator|)
operator|==
literal|0
condition|)
block|{
name|rcvdata
operator|=
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|type
operator|->
name|rcvdata
expr_stmt|;
if|if
condition|(
name|rcvdata
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|rcvdata
call|)
argument_list|(
name|hook
operator|->
name|peer
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TRAP_ERROR
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a queued data packet to a node. If the recipient has no  * 'receive queued data' method, then try the 'receive data' method above.  */
end_comment

begin_function
name|int
name|ng_send_dataq
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|int
function_decl|(
modifier|*
name|rcvdataq
function_decl|)
parameter_list|(
name|hook_p
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|meta_p
parameter_list|)
function_decl|;
name|int
name|error
decl_stmt|;
name|CHECK_DATA_MBUF
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|&&
operator|(
name|hook
operator|->
name|flags
operator|&
name|HK_INVALID
operator|)
operator|==
literal|0
condition|)
block|{
name|rcvdataq
operator|=
name|hook
operator|->
name|peer
operator|->
name|node
operator|->
name|type
operator|->
name|rcvdataq
expr_stmt|;
if|if
condition|(
name|rcvdataq
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|rcvdataq
call|)
argument_list|(
name|hook
operator|->
name|peer
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|ng_send_data
argument_list|(
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TRAP_ERROR
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a 'meta'.  *  * Returns new meta, or NULL if original meta is NULL or ENOMEM.  */
end_comment

begin_function
name|meta_p
name|ng_copy_meta
parameter_list|(
name|meta_p
name|meta
parameter_list|)
block|{
name|meta_p
name|meta2
decl_stmt|;
if|if
condition|(
name|meta
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MALLOC
argument_list|(
name|meta2
argument_list|,
name|meta_p
argument_list|,
name|meta
operator|->
name|used_len
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta2
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|meta2
operator|->
name|allocated_len
operator|=
name|meta
operator|->
name|used_len
expr_stmt|;
name|bcopy
argument_list|(
name|meta
argument_list|,
name|meta2
argument_list|,
name|meta
operator|->
name|used_len
argument_list|)
expr_stmt|;
return|return
operator|(
name|meta2
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			Module routines ************************************************************************/
end_comment

begin_comment
comment|/*  * Handle the loading/unloading of a netgraph node type module  */
end_comment

begin_function
name|int
name|ng_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ng_type
modifier|*
specifier|const
name|type
init|=
name|data
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register new netgraph node type */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_newtype
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Call type specific code */
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
operator|)
condition|)
block|{
name|type
operator|->
name|refs
operator|--
expr_stmt|;
comment|/* undo it */
name|LIST_REMOVE
argument_list|(
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
comment|/* make sure no nodes exist! */
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|->
name|refs
operator|==
literal|0
condition|)
block|{
comment|/* failed load, nothing to undo */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
block|{
comment|/* check with type */
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* type refuses.. */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|LIST_REMOVE
argument_list|(
name|type
argument_list|,
name|types
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|type
operator|->
name|mod_event
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|type
operator|->
name|mod_event
call|)
argument_list|(
name|mod
argument_list|,
name|event
argument_list|,
name|data
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
comment|/* XXX ? */
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle loading and unloading for this code.  * The only thing we need to link into is the NETISR strucure.  */
end_comment

begin_function
specifier|static
name|int
name|ngb_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register line discipline */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|error
operator|=
name|register_netisr
argument_list|(
name|NETISR_NETGRAPH
argument_list|,
name|ngintr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* You cant unload it because an interface may be using it.  */
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|netgraph_mod
init|=
block|{
literal|"netgraph"
block|,
name|ngb_mod_event
block|,
operator|(
name|NULL
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|netgraph
argument_list|,
name|netgraph_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|graph
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"netgraph Family"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|abi_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_ABI_VERSION
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|msg_version
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_VERSION
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************ 			Queueing routines ************************************************************************/
end_comment

begin_comment
comment|/* The structure for queueing across ISR switches */
end_comment

begin_struct
struct|struct
name|ng_queue_entry
block|{
name|u_long
name|flags
decl_stmt|;
name|struct
name|ng_queue_entry
modifier|*
name|next
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|hook_p
name|da_hook
decl_stmt|;
comment|/*  target hook */
name|struct
name|mbuf
modifier|*
name|da_m
decl_stmt|;
name|meta_p
name|da_meta
decl_stmt|;
block|}
name|data
struct|;
struct|struct
block|{
name|struct
name|ng_mesg
modifier|*
name|msg_msg
decl_stmt|;
name|node_p
name|msg_node
decl_stmt|;
name|void
modifier|*
name|msg_retaddr
decl_stmt|;
block|}
name|msg
struct|;
block|}
name|body
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NGQF_DATA
value|0x01
end_define

begin_comment
comment|/* the queue element is data */
end_comment

begin_define
define|#
directive|define
name|NGQF_MESG
value|0x02
end_define

begin_comment
comment|/* the queue element is a message */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_queue_entry
modifier|*
name|ngqbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* items to be unqueued */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_queue_entry
modifier|*
name|ngqlast
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last item queued */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|ngqroom
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max items to queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ngqsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of items in queue */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_queue_entry
modifier|*
name|ngqfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* free ones */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|int
name|ngqfreemax
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cache at most this many */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ngqfreesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of cached entries */
end_comment

begin_comment
comment|/*  * Get a queue entry  */
end_comment

begin_function
specifier|static
name|struct
name|ng_queue_entry
modifier|*
name|ng_getqblk
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|ng_queue_entry
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Could be guarding against tty ints or whatever */
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* Try get a cached queue block, or else allocate a new one */
if|if
condition|(
operator|(
name|q
operator|=
name|ngqfree
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngqsize
operator|<
name|ngqroom
condition|)
block|{
comment|/* don't worry about races */
name|MALLOC
argument_list|(
name|q
argument_list|,
expr|struct
name|ng_queue_entry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|q
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ngqfree
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|ngqfreesize
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|q
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a queue entry  */
end_comment

begin_define
define|#
directive|define
name|RETURN_QBLK
parameter_list|(
name|q
parameter_list|)
define|\
value|do {									\ 	int s;								\ 	if (ngqfreesize< ngqfreemax) {
comment|/* don't worry about races */
value|\ 		s = splhigh();						\ 		(q)->next = ngqfree;					\ 		ngqfree = (q);						\ 		ngqfreesize++;						\ 		splx(s);						\ 	} else {							\ 		FREE((q), M_NETGRAPH);					\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * Running at a raised (but we don't know which) processor priority level,  * put the data onto a queue to be picked up by another PPL (probably splnet)  */
end_comment

begin_function
name|int
name|ng_queue_data
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|struct
name|ng_queue_entry
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Fill out the contents */
name|q
operator|->
name|flags
operator|=
name|NGQF_DATA
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|data
operator|.
name|da_hook
operator|=
name|hook
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|data
operator|.
name|da_m
operator|=
name|m
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|data
operator|.
name|da_meta
operator|=
name|meta
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* protect refs and queue */
name|hook
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* don't let it go away while on the queue */
comment|/* Put it on the queue */
if|if
condition|(
name|ngqbase
condition|)
block|{
name|ngqlast
operator|->
name|next
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
name|ngqbase
operator|=
name|q
expr_stmt|;
block|}
name|ngqlast
operator|=
name|q
expr_stmt|;
name|ngqsize
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Schedule software interrupt to handle it later */
name|schednetisr
argument_list|(
name|NETISR_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Running at a raised (but we don't know which) processor priority level,  * put the msg onto a queue to be picked up by another PPL (probably splnet)  */
end_comment

begin_function
name|int
name|ng_queue_msg
parameter_list|(
name|node_p
name|here
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|address
parameter_list|)
block|{
specifier|register
name|struct
name|ng_queue_entry
modifier|*
name|q
decl_stmt|;
name|int
name|s
decl_stmt|;
name|node_p
name|dest
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|retaddr
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Find the target node. */
name|error
operator|=
name|ng_path2node
argument_list|(
name|here
argument_list|,
name|address
argument_list|,
operator|&
name|dest
argument_list|,
operator|&
name|retaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|q
operator|=
name|ng_getqblk
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaddr
condition|)
name|FREE
argument_list|(
name|retaddr
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Fill out the contents */
name|q
operator|->
name|flags
operator|=
name|NGQF_MESG
expr_stmt|;
name|q
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_node
operator|=
name|dest
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_msg
operator|=
name|msg
expr_stmt|;
name|q
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_retaddr
operator|=
name|retaddr
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
comment|/* protect refs and queue */
name|dest
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* don't let it go away while on the queue */
comment|/* Put it on the queue */
if|if
condition|(
name|ngqbase
condition|)
block|{
name|ngqlast
operator|->
name|next
operator|=
name|q
expr_stmt|;
block|}
else|else
block|{
name|ngqbase
operator|=
name|q
expr_stmt|;
block|}
name|ngqlast
operator|=
name|q
expr_stmt|;
name|ngqsize
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Schedule software interrupt to handle it later */
name|schednetisr
argument_list|(
name|NETISR_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an item off the queue, process it, and dispose of the queue entry.  * Should be running at splnet.  */
end_comment

begin_function
specifier|static
name|void
name|ngintr
parameter_list|(
name|void
parameter_list|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|struct
name|ng_queue_entry
modifier|*
name|ngq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|void
modifier|*
name|retaddr
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ngq
operator|=
name|ngqbase
operator|)
condition|)
block|{
name|ngqbase
operator|=
name|ngq
operator|->
name|next
expr_stmt|;
name|ngqsize
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngq
operator|==
name|NULL
condition|)
return|return;
switch|switch
condition|(
name|ngq
operator|->
name|flags
condition|)
block|{
case|case
name|NGQF_DATA
case|:
name|hook
operator|=
name|ngq
operator|->
name|body
operator|.
name|data
operator|.
name|da_hook
expr_stmt|;
name|m
operator|=
name|ngq
operator|->
name|body
operator|.
name|data
operator|.
name|da_m
expr_stmt|;
name|meta
operator|=
name|ngq
operator|->
name|body
operator|.
name|data
operator|.
name|da_meta
expr_stmt|;
name|RETURN_QBLK
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
name|NG_SEND_DATAQ
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|ng_unref_hook
argument_list|(
name|hook
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGQF_MESG
case|:
name|node
operator|=
name|ngq
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_node
expr_stmt|;
name|msg
operator|=
name|ngq
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_msg
expr_stmt|;
name|retaddr
operator|=
name|ngq
operator|->
name|body
operator|.
name|msg
operator|.
name|msg_retaddr
expr_stmt|;
name|RETURN_QBLK
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
condition|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CALL_MSG_HANDLER
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|msg
argument_list|,
name|retaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaddr
condition|)
name|FREE
argument_list|(
name|retaddr
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
break|break;
default|default:
name|RETURN_QBLK
argument_list|(
name|ngq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

