begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_vjc.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_vjc.c,v 1.17 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * This node performs Van Jacobson IP header (de)compression.  * You must have included net/slcompress.c in your kernel compilation.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_vjc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_comment
comment|/* Check agreement with slcompress.c */
end_comment

begin_if
if|#
directive|if
name|MAX_STATES
operator|!=
name|NG_VJC_MAX_CHANNELS
end_if

begin_error
error|#
directive|error
error|NG_VJC_MAX_CHANNELS must be the same as MAX_STATES
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Maximum length of a compressed TCP VJ header */
end_comment

begin_define
define|#
directive|define
name|MAX_VJHEADER
value|19
end_define

begin_comment
comment|/* Node private data */
end_comment

begin_struct
struct|struct
name|ng_vjc_private
block|{
name|struct
name|ngm_vjc_config
name|conf
decl_stmt|;
name|struct
name|slcompress
name|slc
decl_stmt|;
name|hook_p
name|ip
decl_stmt|;
name|hook_p
name|vjcomp
decl_stmt|;
name|hook_p
name|vjuncomp
decl_stmt|;
name|hook_p
name|vjip
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_vjc_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_vjc_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_vjc_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_vjc_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_vjc_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_vjc_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_vjc_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper stuff */
end_comment

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_vjc_pulluphdrs
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|knownTCP
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse type for struct ngm_vjc_config */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_vjc_config_type_info
init|=
name|NG_VJC_CONFIG_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_vjc_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_vjc_config_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for the 'last_cs' and 'cs_next' fields in struct slcompress,    which are pointers converted to integer indices, so parse them that way. */
end_comment

begin_if
if|#
directive|if
name|_MACHINE_ARCH
operator|==
name|i386
end_if

begin_define
define|#
directive|define
name|NG_VJC_TSTATE_PTR_TYPE
value|&ng_parse_uint32_type
end_define

begin_elif
elif|#
directive|elif
name|_MACHINE_ARCH
operator|==
name|alpha
end_elif

begin_define
define|#
directive|define
name|NG_VJC_TSTATE_PTR_TYPE
value|&ng_parse_uint64_type
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Unspported _MACHINE_ARCH
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Parse type for the 'cs_hdr' field in a struct cstate. Ideally we would    like to use a 'struct ip' type instead of a simple array of bytes. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_vjc_cs_hdr_type_info
init|=
block|{
operator|&
name|ng_parse_hint8_type
block|,
name|MAX_HDR
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_vjc_cs_hdr_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_vjc_cs_hdr_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for a struct cstate */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_vjc_cstate_type_info
init|=
block|{
block|{
block|{
literal|"cs_next"
block|,
name|NG_VJC_TSTATE_PTR_TYPE
block|}
block|,
block|{
literal|"cs_hlen"
block|,
operator|&
name|ng_parse_uint16_type
block|}
block|,
block|{
literal|"cs_id"
block|,
operator|&
name|ng_parse_uint8_type
block|}
block|,
block|{
literal|"cs_filler"
block|,
operator|&
name|ng_parse_uint8_type
block|}
block|,
block|{
literal|"cs_hdr"
block|,
operator|&
name|ng_vjc_cs_hdr_type
block|}
block|,
block|{
name|NULL
block|}
block|,     }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_vjc_cstate_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_vjc_cstate_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for an array of MAX_STATES struct cstate's, ie, tstate& rstate */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_vjc_cstatearray_type_info
init|=
block|{
operator|&
name|ng_vjc_cstate_type
block|,
name|MAX_STATES
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_vjc_cstatearray_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_vjc_cstatearray_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct slcompress. Keep this in sync with the    definition of struct slcompress defined in<net/slcompress.h> */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_vjc_slcompress_type_info
init|=
block|{
block|{
block|{
literal|"last_cs"
block|,
name|NG_VJC_TSTATE_PTR_TYPE
block|}
block|,
block|{
literal|"last_recv"
block|,
operator|&
name|ng_parse_uint8_type
block|}
block|,
block|{
literal|"last_xmit"
block|,
operator|&
name|ng_parse_uint8_type
block|}
block|,
block|{
literal|"flags"
block|,
operator|&
name|ng_parse_hint16_type
block|}
block|,
ifndef|#
directive|ifndef
name|SL_NO_STATS
block|{
literal|"sls_packets"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_compressed"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_searches"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_misses"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_uncompressedin"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_compressedin"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_errorin"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
block|{
literal|"sls_tossed"
block|,
operator|&
name|ng_parse_uint32_type
block|}
block|,
endif|#
directive|endif
block|{
literal|"tstate"
block|,
operator|&
name|ng_vjc_cstatearray_type
block|}
block|,
block|{
literal|"rstate"
block|,
operator|&
name|ng_vjc_cstatearray_type
block|}
block|,
block|{
name|NULL
block|}
block|,     }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_vjc_slcompress_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_vjc_slcompress_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_vjc_cmds
index|[]
init|=
block|{
block|{
name|NGM_VJC_COOKIE
block|,
name|NGM_VJC_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_vjc_config_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_VJC_COOKIE
block|,
name|NGM_VJC_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_vjc_config_type
block|, 	}
block|,
block|{
name|NGM_VJC_COOKIE
block|,
name|NGM_VJC_GET_STATE
block|,
literal|"getstate"
block|,
name|NULL
block|,
operator|&
name|ng_vjc_slcompress_type
block|, 	}
block|,
block|{
name|NGM_VJC_COOKIE
block|,
name|NGM_VJC_CLR_STATS
block|,
literal|"clrstats"
block|,
name|NULL
block|,
name|NULL
block|, 	}
block|,
block|{
name|NGM_VJC_COOKIE
block|,
name|NGM_VJC_RECV_ERROR
block|,
literal|"recverror"
block|,
name|NULL
block|,
name|NULL
block|, 	}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_vjc_typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_VJC_NODE_TYPE
block|,
name|NULL
block|,
name|ng_vjc_constructor
block|,
name|ng_vjc_rcvmsg
block|,
name|ng_vjc_rmnode
block|,
name|ng_vjc_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_vjc_rcvdata
block|,
name|ng_vjc_rcvdata
block|,
name|ng_vjc_disconnect
block|,
name|ng_vjc_cmds
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|vjc
argument_list|,
operator|&
name|ng_vjc_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE METHODS  ************************************************************************/
end_comment

begin_comment
comment|/*  * Create a new node  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate private structure */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call generic node constructor */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_vjc_typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|priv
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
operator|(
name|priv_p
operator|)
name|node
operator|->
name|private
decl_stmt|;
name|hook_p
modifier|*
name|hookp
decl_stmt|;
comment|/* Get hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_VJC_HOOK_IP
argument_list|)
operator|==
literal|0
condition|)
name|hookp
operator|=
operator|&
name|priv
operator|->
name|ip
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_VJC_HOOK_VJCOMP
argument_list|)
operator|==
literal|0
condition|)
name|hookp
operator|=
operator|&
name|priv
operator|->
name|vjcomp
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_VJC_HOOK_VJUNCOMP
argument_list|)
operator|==
literal|0
condition|)
name|hookp
operator|=
operator|&
name|priv
operator|->
name|vjuncomp
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_VJC_HOOK_VJIP
argument_list|)
operator|==
literal|0
condition|)
name|hookp
operator|=
operator|&
name|priv
operator|->
name|vjip
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* See if already connected */
if|if
condition|(
operator|*
name|hookp
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* OK */
operator|*
name|hookp
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|raddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
operator|(
name|priv_p
operator|)
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Check type cookie */
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_VJC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_VJC_SET_CONFIG
case|:
block|{
name|struct
name|ngm_vjc_config
modifier|*
specifier|const
name|c
init|=
operator|(
expr|struct
name|ngm_vjc_config
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|c
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|conf
operator|.
name|enableComp
operator|||
name|priv
operator|->
name|conf
operator|.
name|enableDecomp
operator|)
operator|&&
operator|(
name|c
operator|->
name|enableComp
operator|||
name|c
operator|->
name|enableDecomp
operator|)
condition|)
name|ERROUT
argument_list|(
name|EALREADY
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|enableComp
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|maxChannel
operator|>
name|NG_VJC_MAX_CHANNELS
operator|-
literal|1
operator|||
name|c
operator|->
name|maxChannel
operator|<
name|NG_VJC_MIN_CHANNELS
operator|-
literal|1
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
name|c
operator|->
name|maxChannel
operator|=
name|NG_VJC_MAX_CHANNELS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|enableComp
operator|!=
literal|0
operator|||
name|c
operator|->
name|enableDecomp
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|slc
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|slc
argument_list|)
argument_list|)
expr_stmt|;
name|sl_compress_init
argument_list|(
operator|&
name|priv
operator|->
name|slc
argument_list|,
name|c
operator|->
name|maxChannel
argument_list|)
expr_stmt|;
block|}
name|priv
operator|->
name|conf
operator|=
operator|*
name|c
expr_stmt|;
break|break;
block|}
case|case
name|NGM_VJC_GET_CONFIG
case|:
block|{
name|struct
name|ngm_vjc_config
modifier|*
name|conf
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|conf
operator|=
operator|(
expr|struct
name|ngm_vjc_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|conf
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_VJC_GET_STATE
case|:
block|{
specifier|const
name|struct
name|slcompress
modifier|*
specifier|const
name|sl0
init|=
operator|&
name|priv
operator|->
name|slc
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|sl
decl_stmt|;
name|u_int16_t
name|index
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get response structure */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sl
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|sl
operator|=
operator|(
expr|struct
name|slcompress
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|sl
operator|=
operator|*
name|sl0
expr_stmt|;
comment|/* Replace pointers with integer indicies */
if|if
condition|(
name|sl
operator|->
name|last_cs
operator|!=
name|NULL
condition|)
block|{
name|index
operator|=
name|sl0
operator|->
name|last_cs
operator|-
name|sl0
operator|->
name|tstate
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sl
operator|->
name|last_cs
argument_list|,
sizeof|sizeof
argument_list|(
name|sl
operator|->
name|last_cs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|sl
operator|->
name|last_cs
operator|)
operator|=
name|index
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_STATES
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cstate
modifier|*
specifier|const
name|cs
init|=
operator|&
name|sl
operator|->
name|tstate
index|[
name|i
index|]
decl_stmt|;
name|index
operator|=
name|sl0
operator|->
name|tstate
index|[
name|i
index|]
operator|.
name|cs_next
operator|-
name|sl0
operator|->
name|tstate
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|cs
operator|->
name|cs_next
argument_list|,
sizeof|sizeof
argument_list|(
name|cs
operator|->
name|cs_next
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_next
operator|)
operator|=
name|index
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NGM_VJC_CLR_STATS
case|:
name|priv
operator|->
name|slc
operator|.
name|sls_packets
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_compressed
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_searches
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_misses
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_uncompressedin
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_compressedin
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_errorin
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_tossed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|NGM_VJC_RECV_ERROR
case|:
name|sl_uncompress_tcp
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|TYPE_ERROR
argument_list|,
operator|&
name|priv
operator|->
name|slc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rptr
condition|)
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
condition|)
name|FREE
argument_list|(
name|resp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|done
label|:
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
operator|(
name|priv_p
operator|)
name|node
operator|->
name|private
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|ip
condition|)
block|{
comment|/* outgoing packet */
name|u_int
name|type
init|=
name|TYPE_IP
decl_stmt|;
comment|/* Compress packet if enabled and proto is TCP */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableComp
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_vjc_pulluphdrs
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
specifier|const
name|int
name|origLen
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|type
operator|=
name|sl_compress_tcp
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
operator|&
name|priv
operator|->
name|slc
argument_list|,
name|priv
operator|->
name|conf
operator|.
name|compressCID
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_len
operator|-
name|origLen
expr_stmt|;
block|}
block|}
comment|/* Dispatch to the appropriate outgoing hook */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_IP
case|:
name|hook
operator|=
name|priv
operator|->
name|vjip
expr_stmt|;
break|break;
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|hook
operator|=
name|priv
operator|->
name|vjuncomp
expr_stmt|;
break|break;
case|case
name|TYPE_COMPRESSED_TCP
case|:
name|hook
operator|=
name|priv
operator|->
name|vjcomp
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: type=%d"
argument_list|,
name|__FUNCTION__
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjcomp
condition|)
block|{
comment|/* incoming compressed packet */
name|int
name|vjlen
decl_stmt|,
name|need2pullup
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|hm
decl_stmt|;
name|u_char
modifier|*
name|hdr
decl_stmt|;
name|u_int
name|hlen
decl_stmt|;
comment|/* Are we decompressing? */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecomp
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Pull up the necessary amount from the mbuf */
name|need2pullup
operator|=
name|MAX_VJHEADER
expr_stmt|;
if|if
condition|(
name|need2pullup
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
name|need2pullup
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|need2pullup
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|need2pullup
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|slc
operator|.
name|sls_errorin
operator|++
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Uncompress packet to reconstruct TCP/IP header */
name|vjlen
operator|=
name|sl_uncompress_tcp_core
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|TYPE_COMPRESSED_TCP
argument_list|,
operator|&
name|priv
operator|->
name|slc
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vjlen
operator|<=
literal|0
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|vjlen
argument_list|)
expr_stmt|;
comment|/* Copy the reconstructed TCP/IP headers into a new mbuf */
name|MGETHDR
argument_list|(
name|hm
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|hm
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|slc
operator|.
name|sls_errorin
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|hm
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|hm
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MHLEN
condition|)
block|{
comment|/* unlikely, but can happen */
name|MCLGET
argument_list|(
name|hm
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hm
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|priv
operator|->
name|slc
operator|.
name|sls_errorin
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
name|bcopy
argument_list|(
name|hdr
argument_list|,
name|mtod
argument_list|(
name|hm
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|hm
operator|->
name|m_len
operator|=
name|hlen
expr_stmt|;
comment|/* Glue TCP/IP headers and rest of packet together */
name|hm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|hm
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|hlen
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m
operator|=
name|hm
expr_stmt|;
name|hook
operator|=
name|priv
operator|->
name|ip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjuncomp
condition|)
block|{
comment|/* incoming uncompressed pkt */
name|u_char
modifier|*
name|hdr
decl_stmt|;
name|u_int
name|hlen
decl_stmt|;
comment|/* Are we decompressing? */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecomp
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Pull up IP+TCP headers */
if|if
condition|(
operator|(
name|m
operator|=
name|ng_vjc_pulluphdrs
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Run packet through uncompressor */
if|if
condition|(
name|sl_uncompress_tcp_core
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|TYPE_UNCOMPRESSED_TCP
argument_list|,
operator|&
name|priv
operator|->
name|slc
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|hlen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|hook
operator|=
name|priv
operator|->
name|ip
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjip
condition|)
comment|/* incoming regular packet (bypass) */
name|hook
operator|=
name|priv
operator|->
name|ip
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"%s: unknown hook"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Send result back out */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown node  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
operator|(
name|priv_p
operator|)
name|node
operator|->
name|private
decl_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_vjc_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
comment|/* Zero out hook pointer */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|ip
condition|)
name|priv
operator|->
name|ip
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjcomp
condition|)
name|priv
operator|->
name|vjcomp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjuncomp
condition|)
name|priv
operator|->
name|vjuncomp
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|vjip
condition|)
name|priv
operator|->
name|vjip
operator|=
name|NULL
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"%s: unknown hook"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
comment|/* Go away if no hooks left */
if|if
condition|(
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			HELPER STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Pull up the full IP and TCP headers of a packet. If packet is not  * a TCP packet, just pull up the IP header.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_vjc_pulluphdrs
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|knownTCP
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|tcp
decl_stmt|;
name|int
name|ihlen
decl_stmt|,
name|thlen
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knownTCP
operator|&&
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|ihlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ihlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ihlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|tcp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|tcp
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|+
name|ihlen
operator|)
expr_stmt|;
name|thlen
operator|=
name|tcp
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ihlen
operator|+
name|thlen
condition|)
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ihlen
operator|+
name|thlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

