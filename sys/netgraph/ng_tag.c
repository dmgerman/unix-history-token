begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Vadim Goncharov<vadimnuclight@tpu.ru>  * All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Portions Copyright (c) 1999 Whistle Communications, Inc.  * (ng_bpf by Archie Cobbs<archie@freebsd.org>)  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * TAG NETGRAPH NODE TYPE  *  * This node type accepts an arbitrary number of hooks. Each hook can be  * configured for an mbuf_tags(9) definition and two hook names: a hook  * for matched packets, and a hook for packets, that didn't match. Incoming  * packets are examined for configured tag, matched packets are delivered  * out via first hook, and not matched out via second. If corresponding hook  * is not configured, packets are dropped.  *  * A hook can also have an outgoing tag definition configured, so that  * all packets leaving the hook will be unconditionally appended with newly  * allocated tag.  *  * Both hooks can be set to null tag definitions (that is, with zeroed  * fields), so that packet tags are unmodified on output or all packets  * are unconditionally forwarded to non-matching hook on input.  There is  * also a possibility to replace tags by specifying strip flag on input  * and replacing tag on corresponding output tag (or simply remove tag if  * no tag specified on output).  *  * If compiled with NG_TAG_DEBUG, each hook also keeps statistics about  * how many packets have matched, etc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_tag.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_TAG
argument_list|,
literal|"netgraph_tag"
argument_list|,
literal|"netgraph tag node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_TAG
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/*  * Per hook private info.  *  * We've separated API and ABI here, to make easier changes in this node,  * if needed. If you want to change representation, please do not break API.  * We still keep API structures in memory to simplify access to them for  * GET* messages, but most of data is accessed in internal representation  * only.  The reason for this is to speed things up - if data will be  * accessed from API structures, there would be double pointer dereferencing  * in the code, which almost necessarily leads to CPU cache misses and  * reloads.  *  * We also do another optimization by using resolved pointers to  * destination hooks instead of expensive ng_findhook().  */
end_comment

begin_struct
struct|struct
name|ng_tag_hookinfo
block|{
name|hook_p
name|hi_match
decl_stmt|;
comment|/* matching hook pointer */
name|hook_p
name|hi_nonmatch
decl_stmt|;
comment|/* non-matching hook pointer */
name|uint32_t
name|in_tag_cookie
decl_stmt|;
name|uint32_t
name|out_tag_cookie
decl_stmt|;
name|uint16_t
name|in_tag_id
decl_stmt|;
name|uint16_t
name|in_tag_len
decl_stmt|;
name|uint16_t
name|out_tag_id
decl_stmt|;
name|uint16_t
name|out_tag_len
decl_stmt|;
name|uint8_t
name|strip
decl_stmt|;
name|void
modifier|*
name|in_tag_data
decl_stmt|;
name|void
modifier|*
name|out_tag_data
decl_stmt|;
name|struct
name|ng_tag_hookin
modifier|*
name|in
decl_stmt|;
name|struct
name|ng_tag_hookout
modifier|*
name|out
decl_stmt|;
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
name|struct
name|ng_tag_hookstat
name|stats
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_tag_hookinfo
modifier|*
name|hinfo_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph methods. */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_tag_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_tag_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_tag_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_tag_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_tag_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_tag_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal helper functions. */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_tag_setdata_in
parameter_list|(
name|hook_p
name|hook
parameter_list|,
specifier|const
name|struct
name|ng_tag_hookin
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_tag_setdata_out
parameter_list|(
name|hook_p
name|hook
parameter_list|,
specifier|const
name|struct
name|ng_tag_hookout
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse types for the field 'tag_data' in structs ng_tag_hookin and out. */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_hookinary_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|ng_tag_hookin
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
operator|(
specifier|const
expr|struct
name|ng_tag_hookin
operator|*
operator|)
operator|(
name|buf
operator|-
name|offsetof
argument_list|(
expr|struct
name|ng_tag_hookin
argument_list|,
name|tag_data
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|hp
operator|->
name|tag_len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_tag_hookoutary_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|ng_tag_hookout
modifier|*
name|hp
decl_stmt|;
name|hp
operator|=
operator|(
specifier|const
expr|struct
name|ng_tag_hookout
operator|*
operator|)
operator|(
name|buf
operator|-
name|offsetof
argument_list|(
expr|struct
name|ng_tag_hookout
argument_list|,
name|tag_data
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|hp
operator|->
name|tag_len
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_tag_hookinary_type
init|=
block|{
operator|&
name|ng_parse_bytearray_type
block|,
operator|&
name|ng_tag_hookinary_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_tag_hookoutary_type
init|=
block|{
operator|&
name|ng_parse_bytearray_type
block|,
operator|&
name|ng_tag_hookoutary_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_tag_hookin. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_tag_hookin_type_fields
index|[]
init|=
name|NG_TAG_HOOKIN_TYPE_INFO
argument_list|(
operator|&
name|ng_tag_hookinary_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_tag_hookin_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_tag_hookin_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_tag_hookout. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_tag_hookout_type_fields
index|[]
init|=
name|NG_TAG_HOOKOUT_TYPE_INFO
argument_list|(
operator|&
name|ng_tag_hookoutary_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_tag_hookout_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_tag_hookout_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
end_ifdef

begin_comment
comment|/* Parse type for struct ng_tag_hookstat. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_tag_hookstat_type_fields
index|[]
init|=
name|NG_TAG_HOOKSTAT_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_tag_hookstat_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_tag_hookstat_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_tag_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_SET_HOOKIN
block|,
literal|"sethookin"
block|,
operator|&
name|ng_tag_hookin_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_GET_HOOKIN
block|,
literal|"gethookin"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
operator|&
name|ng_tag_hookin_type
block|}
block|,
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_SET_HOOKOUT
block|,
literal|"sethookout"
block|,
operator|&
name|ng_tag_hookout_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_GET_HOOKOUT
block|,
literal|"gethookout"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
operator|&
name|ng_tag_hookout_type
block|}
block|,
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_GET_STATS
block|,
literal|"getstats"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
operator|&
name|ng_tag_hookstat_type
block|}
block|,
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_CLR_STATS
block|,
literal|"clrstats"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_TAG_COOKIE
block|,
name|NGM_TAG_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
operator|&
name|ng_tag_hookstat_type
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Netgraph type descriptor. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_TAG_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_tag_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_tag_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_tag_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_tag_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_tag_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_tag_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_tag_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|tag
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This are default API structures (initialized to zeroes) which are  * returned in response to GET* messages when no configuration was made.  * One could ask why to have this structures at all when we have  * ng_tag_hookinfo initialized to zero and don't need in and out structures  * at all to operate.  Unfortunatelly, we have to return thisHook field  * in response to messages so the fastest and simpliest way is to have  * this default structures and initialize thisHook once at hook creation  * rather than to do it on every response.  */
end_comment

begin_comment
comment|/* Default tag values for a hook that matches nothing. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_tag_hookin
name|ng_tag_default_in
init|=
block|{
block|{
literal|'\0'
block|}
block|,
comment|/* to be filled in at hook creation time */
block|{
literal|'\0'
block|}
block|,
block|{
literal|'\0'
block|}
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default tag values for a hook that adds nothing */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_tag_hookout
name|ng_tag_default_out
init|=
block|{
block|{
literal|'\0'
block|}
block|,
comment|/* to be filled in at hook creation time */
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Node constructor.  *  * We don't keep any per-node private data - we do it on per-hook basis.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hinfo_p
name|hip
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Create hook private structure. */
name|hip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hip
argument_list|)
argument_list|,
name|M_NETGRAPH_TAG
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|hip
argument_list|)
expr_stmt|;
comment|/* 	 * After M_ZERO both in and out hook pointers are set to NULL, 	 * as well as all members and pointers to in and out API 	 * structures, so we need to set explicitly only thisHook field 	 * in that structures (after allocating them, of course). 	 */
comment|/* Attach the default IN data. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_tag_setdata_in
argument_list|(
name|hook
argument_list|,
operator|&
name|ng_tag_default_in
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|hip
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Attach the default OUT data. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_tag_setdata_out
argument_list|(
name|hook
argument_list|,
operator|&
name|ng_tag_default_out
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|hip
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Set hook name.  This is done only once at hook creation time 	 * since hook name can't change, rather than to do it on every 	 * response to messages requesting API structures with data who 	 * we are etc. 	 */
name|strncpy
argument_list|(
name|hip
operator|->
name|in
operator|->
name|thisHook
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hip
operator|->
name|in
operator|->
name|thisHook
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hip
operator|->
name|in
operator|->
name|thisHook
index|[
sizeof|sizeof
argument_list|(
name|hip
operator|->
name|in
operator|->
name|thisHook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|hip
operator|->
name|out
operator|->
name|thisHook
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|hip
operator|->
name|out
operator|->
name|thisHook
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|hip
operator|->
name|out
operator|->
name|thisHook
index|[
sizeof|sizeof
argument_list|(
name|hip
operator|->
name|out
operator|->
name|thisHook
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_TAG_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TAG_SET_HOOKIN
case|:
block|{
name|struct
name|ng_tag_hookin
modifier|*
specifier|const
name|hp
init|=
operator|(
expr|struct
name|ng_tag_hookin
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
operator|||
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
name|NG_TAG_HOOKIN_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Find hook. */
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|hp
operator|->
name|thisHook
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Set new tag values. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_tag_setdata_in
argument_list|(
name|hook
argument_list|,
name|hp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ERROUT
argument_list|(
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_TAG_SET_HOOKOUT
case|:
block|{
name|struct
name|ng_tag_hookout
modifier|*
specifier|const
name|hp
init|=
operator|(
expr|struct
name|ng_tag_hookout
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
operator|||
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
name|NG_TAG_HOOKOUT_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Find hook. */
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|hp
operator|->
name|thisHook
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Set new tag values. */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_tag_setdata_out
argument_list|(
name|hook
argument_list|,
name|hp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ERROUT
argument_list|(
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_TAG_GET_HOOKIN
case|:
block|{
name|struct
name|ng_tag_hookin
modifier|*
name|hp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|==
literal|0
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
index|[
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find hook. */
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|msg
operator|->
name|data
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Build response. */
name|hp
operator|=
operator|(
operator|(
name|hinfo_p
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|)
operator|->
name|in
expr_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|NG_TAG_HOOKIN_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* M_WAITOK can't return NULL. */
name|bcopy
argument_list|(
name|hp
argument_list|,
name|resp
operator|->
name|data
argument_list|,
name|NG_TAG_HOOKIN_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_TAG_GET_HOOKOUT
case|:
block|{
name|struct
name|ng_tag_hookout
modifier|*
name|hp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|==
literal|0
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
index|[
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find hook. */
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|msg
operator|->
name|data
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* Build response. */
name|hp
operator|=
operator|(
operator|(
name|hinfo_p
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|)
operator|->
name|out
expr_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|NG_TAG_HOOKOUT_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* M_WAITOK can't return NULL. */
name|bcopy
argument_list|(
name|hp
argument_list|,
name|resp
operator|->
name|data
argument_list|,
name|NG_TAG_HOOKOUT_SIZE
argument_list|(
name|hp
operator|->
name|tag_len
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
case|case
name|NGM_TAG_GET_STATS
case|:
case|case
name|NGM_TAG_CLR_STATS
case|:
case|case
name|NGM_TAG_GETCLR_STATS
case|:
block|{
name|struct
name|ng_tag_hookstat
modifier|*
name|stats
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|==
literal|0
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|msg
operator|->
name|data
index|[
name|msg
operator|->
name|header
operator|.
name|arglen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find hook. */
if|if
condition|(
operator|(
name|hook
operator|=
name|ng_findhook
argument_list|(
name|node
argument_list|,
name|msg
operator|->
name|data
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|&
operator|(
operator|(
name|hinfo_p
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|)
operator|->
name|stats
expr_stmt|;
comment|/* Build response (if desired). */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_TAG_CLR_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* M_WAITOK can't return NULL. */
name|bcopy
argument_list|(
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Clear stats (if desired). */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_TAG_GET_STATS
condition|)
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* NG_TAG_DEBUG */
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook.  *  * Apply the filter, and then drop or forward packet as appropriate.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
specifier|const
name|hinfo_p
name|hip
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|uint16_t
name|type
decl_stmt|,
name|tag_len
decl_stmt|;
name|uint32_t
name|cookie
decl_stmt|;
name|hinfo_p
name|dhip
decl_stmt|;
name|hook_p
name|dest
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|m
operator|=
name|NGI_M
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* 'item' still owns it.. we are peeking */
name|totlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
name|hip
operator|->
name|stats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|hip
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|totlen
expr_stmt|;
endif|#
directive|endif
comment|/* Looking up incoming tag. */
name|cookie
operator|=
name|hip
operator|->
name|in_tag_cookie
expr_stmt|;
name|type
operator|=
name|hip
operator|->
name|in_tag_id
expr_stmt|;
name|tag_len
operator|=
name|hip
operator|->
name|in_tag_len
expr_stmt|;
comment|/* 	 * We treat case of all zeroes specially (that is, cookie and 	 * type are equal to zero), as we assume that such tag 	 * can never occur in the wild.  So we don't waste time trying 	 * to find such tag (for example, these are zeroes after hook 	 * creation in default structures). 	 */
if|if
condition|(
operator|(
name|cookie
operator|!=
literal|0
operator|)
operator|||
operator|(
name|type
operator|!=
literal|0
operator|)
condition|)
block|{
name|tag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|cookie
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|tag
operator|+
literal|1
operator|)
argument_list|,
name|hip
operator|->
name|in_tag_data
argument_list|,
name|tag_len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|tag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|cookie
argument_list|,
name|type
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* See if we got a match and find destination hook. */
if|if
condition|(
name|found
condition|)
block|{
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
name|hip
operator|->
name|stats
operator|.
name|recvMatchFrames
operator|++
expr_stmt|;
name|hip
operator|->
name|stats
operator|.
name|recvMatchOctets
operator|+=
name|totlen
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hip
operator|->
name|strip
condition|)
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dest
operator|=
name|hip
operator|->
name|hi_match
expr_stmt|;
block|}
else|else
name|dest
operator|=
name|hip
operator|->
name|hi_nonmatch
expr_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deliver frame out destination hook. */
name|dhip
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|dest
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NG_TAG_DEBUG
name|dhip
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|totlen
expr_stmt|;
name|dhip
operator|->
name|stats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
endif|#
directive|endif
name|cookie
operator|=
name|dhip
operator|->
name|out_tag_cookie
expr_stmt|;
name|type
operator|=
name|dhip
operator|->
name|out_tag_id
expr_stmt|;
name|tag_len
operator|=
name|dhip
operator|->
name|out_tag_len
expr_stmt|;
if|if
condition|(
operator|(
name|cookie
operator|!=
literal|0
operator|)
operator|||
operator|(
name|type
operator|!=
literal|0
operator|)
condition|)
block|{
name|tag
operator|=
name|m_tag_alloc
argument_list|(
name|cookie
argument_list|,
name|type
argument_list|,
name|tag_len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* XXX may be free the mbuf if tag allocation failed? */
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tag_len
operator|!=
literal|0
condition|)
block|{
comment|/* copy tag data to its place */
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|tag
operator|+
literal|1
operator|)
argument_list|,
name|dhip
operator|->
name|out_tag_data
argument_list|,
name|tag_len
argument_list|)
expr_stmt|;
block|}
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown processing.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection.  *  * We must check all hooks, since they may reference this one.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|hinfo_p
name|hip
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|hook_p
name|hook2
decl_stmt|;
name|KASSERT
argument_list|(
name|hip
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null info"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hook2
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|hinfo_p
name|priv
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook2
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|hi_match
operator|==
name|hook
condition|)
name|priv
operator|->
name|hi_match
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|hi_nonmatch
operator|==
name|hook
condition|)
name|priv
operator|->
name|hi_nonmatch
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|hip
operator|->
name|in
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hip
operator|->
name|out
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hip
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* for good measure */
if|if
condition|(
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			HELPER STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Set the IN tag values associated with a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_setdata_in
parameter_list|(
name|hook_p
name|hook
parameter_list|,
specifier|const
name|struct
name|ng_tag_hookin
modifier|*
name|hp0
parameter_list|)
block|{
specifier|const
name|hinfo_p
name|hip
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ng_tag_hookin
modifier|*
name|hp
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Make a copy of the tag values and data. */
name|size
operator|=
name|NG_TAG_HOOKIN_SIZE
argument_list|(
name|hp0
operator|->
name|tag_len
argument_list|)
expr_stmt|;
name|hp
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_NETGRAPH_TAG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* M_WAITOK can't return NULL. */
name|bcopy
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Free previous tag, if any, and assign new one. */
if|if
condition|(
name|hip
operator|->
name|in
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hip
operator|->
name|in
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
name|hip
operator|->
name|in
operator|=
name|hp
expr_stmt|;
comment|/* 	 * Resolve hook names to pointers. 	 * 	 * As ng_findhook() is expensive operation to do it on every packet 	 * after tag matching check, we do it here and use resolved pointers 	 * where appropriate. 	 * 	 * XXX The drawback is that user can configure a hook to use 	 * ifMatch/ifNotMatch hooks that do not yet exist and will be added 	 * by user later, so that resolved pointers will be NULL even 	 * if the hook already exists, causing node to drop packets and 	 * user to report bugs.  We could do check for this situation on 	 * every hook creation with pointers correction, but that involves 	 * re-resolving for all pointers in all hooks, up to O(n^2) operations, 	 * so we better document this in man page for user not to do 	 * configuration before creating all hooks. 	 */
name|hip
operator|->
name|hi_match
operator|=
name|ng_findhook
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|hip
operator|->
name|in
operator|->
name|ifMatch
argument_list|)
expr_stmt|;
name|hip
operator|->
name|hi_nonmatch
operator|=
name|ng_findhook
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|hip
operator|->
name|in
operator|->
name|ifNotMatch
argument_list|)
expr_stmt|;
comment|/* Fill internal values from API structures. */
name|hip
operator|->
name|in_tag_cookie
operator|=
name|hip
operator|->
name|in
operator|->
name|tag_cookie
expr_stmt|;
name|hip
operator|->
name|in_tag_id
operator|=
name|hip
operator|->
name|in
operator|->
name|tag_id
expr_stmt|;
name|hip
operator|->
name|in_tag_len
operator|=
name|hip
operator|->
name|in
operator|->
name|tag_len
expr_stmt|;
name|hip
operator|->
name|strip
operator|=
name|hip
operator|->
name|in
operator|->
name|strip
expr_stmt|;
name|hip
operator|->
name|in_tag_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|hip
operator|->
name|in
operator|->
name|tag_data
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the OUT tag values associated with a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_tag_setdata_out
parameter_list|(
name|hook_p
name|hook
parameter_list|,
specifier|const
name|struct
name|ng_tag_hookout
modifier|*
name|hp0
parameter_list|)
block|{
specifier|const
name|hinfo_p
name|hip
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ng_tag_hookout
modifier|*
name|hp
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Make a copy of the tag values and data. */
name|size
operator|=
name|NG_TAG_HOOKOUT_SIZE
argument_list|(
name|hp0
operator|->
name|tag_len
argument_list|)
expr_stmt|;
name|hp
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_NETGRAPH_TAG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* M_WAITOK can't return NULL. */
name|bcopy
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Free previous tag, if any, and assign new one. */
if|if
condition|(
name|hip
operator|->
name|out
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hip
operator|->
name|out
argument_list|,
name|M_NETGRAPH_TAG
argument_list|)
expr_stmt|;
name|hip
operator|->
name|out
operator|=
name|hp
expr_stmt|;
comment|/* Fill internal values from API structures. */
name|hip
operator|->
name|out_tag_cookie
operator|=
name|hip
operator|->
name|out
operator|->
name|tag_cookie
expr_stmt|;
name|hip
operator|->
name|out_tag_id
operator|=
name|hip
operator|->
name|out
operator|->
name|tag_id
expr_stmt|;
name|hip
operator|->
name|out_tag_len
operator|=
name|hip
operator|->
name|out
operator|->
name|tag_len
expr_stmt|;
name|hip
operator|->
name|out_tag_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|hip
operator|->
name|out
operator|->
name|tag_data
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

