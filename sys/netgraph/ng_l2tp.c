begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2002 Packet Design, LLC.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty,  * use and redistribution of this software, in source or object code  * forms, with or without modifications are expressly permitted by  * Packet Design; provided, however, that:  *   *    (i)  Any and all reproductions of the source or object code  *         must include the copyright notice above and the following  *         disclaimer of warranties; and  *    (ii) No rights are granted, in any manner or form, to use  *         Packet Design trademarks, including the mark "PACKET DESIGN"  *         on advertising, endorsements, or otherwise except as such  *         appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY PACKET DESIGN "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, PACKET DESIGN MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING  * THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED  * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,  * OR NON-INFRINGEMENT.  PACKET DESIGN DOES NOT WARRANT, GUARANTEE,  * OR MAKE ANY REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS  * OF THE USE OF THIS SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY,  * RELIABILITY OR OTHERWISE.  IN NO EVENT SHALL PACKET DESIGN BE  * LIABLE FOR ANY DAMAGES RESULTING FROM OR ARISING OUT OF ANY USE  * OF THIS SOFTWARE, INCLUDING WITHOUT LIMITATION, ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, PUNITIVE, OR CONSEQUENTIAL  * DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES, LOSS OF  * USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF  * THE USE OF THIS SOFTWARE, EVEN IF PACKET DESIGN IS ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  *   * Author: Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * L2TP netgraph node type.  *  * This node type implements the lower layer of the  * L2TP protocol as specified in RFC 2661.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_l2tp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_L2TP
argument_list|,
literal|"netgraph_l2tp"
argument_list|,
literal|"netgraph l2tp node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_L2TP
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* L2TP header format (first 2 bytes only) */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_CTRL
value|0x8000
end_define

begin_comment
comment|/* control packet */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_LEN
value|0x4000
end_define

begin_comment
comment|/* has length field */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_SEQ
value|0x0800
end_define

begin_comment
comment|/* has ns, nr fields */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_OFF
value|0x0200
end_define

begin_comment
comment|/* has offset field */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_PRIO
value|0x0100
end_define

begin_comment
comment|/* give priority */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_VERS_MASK
value|0x000f
end_define

begin_comment
comment|/* version field mask */
end_comment

begin_define
define|#
directive|define
name|L2TP_HDR_VERSION
value|0x0002
end_define

begin_comment
comment|/* version field */
end_comment

begin_comment
comment|/* Bits that must be zero or one in first two bytes of header */
end_comment

begin_define
define|#
directive|define
name|L2TP_CTRL_0BITS
value|0x030d
end_define

begin_comment
comment|/* ctrl: must be 0 */
end_comment

begin_define
define|#
directive|define
name|L2TP_CTRL_1BITS
value|0xc802
end_define

begin_comment
comment|/* ctrl: must be 1 */
end_comment

begin_define
define|#
directive|define
name|L2TP_DATA_0BITS
value|0x800d
end_define

begin_comment
comment|/* data: must be 0 */
end_comment

begin_define
define|#
directive|define
name|L2TP_DATA_1BITS
value|0x0002
end_define

begin_comment
comment|/* data: must be 1 */
end_comment

begin_comment
comment|/* Standard xmit ctrl and data header bits */
end_comment

begin_define
define|#
directive|define
name|L2TP_CTRL_HDR
value|(L2TP_HDR_CTRL | L2TP_HDR_LEN \ 				    | L2TP_HDR_SEQ | L2TP_HDR_VERSION)
end_define

begin_define
define|#
directive|define
name|L2TP_DATA_HDR
value|(L2TP_HDR_VERSION)
end_define

begin_comment
comment|/* optional: len, seq */
end_comment

begin_comment
comment|/* Some hard coded values */
end_comment

begin_define
define|#
directive|define
name|L2TP_MAX_XWIN
value|16
end_define

begin_comment
comment|/* my max xmit window */
end_comment

begin_define
define|#
directive|define
name|L2TP_MAX_REXMIT
value|5
end_define

begin_comment
comment|/* default max rexmit */
end_comment

begin_define
define|#
directive|define
name|L2TP_MAX_REXMIT_TO
value|30
end_define

begin_comment
comment|/* default rexmit to */
end_comment

begin_define
define|#
directive|define
name|L2TP_DELAYED_ACK
value|((hz + 19) / 20)
end_define

begin_comment
comment|/* delayed ack: 50 ms */
end_comment

begin_comment
comment|/* Default data sequence number configuration for new sessions */
end_comment

begin_define
define|#
directive|define
name|L2TP_CONTROL_DSEQ
value|1
end_define

begin_comment
comment|/* we are the lns */
end_comment

begin_define
define|#
directive|define
name|L2TP_ENABLE_DSEQ
value|1
end_define

begin_comment
comment|/* enable data seq # */
end_comment

begin_comment
comment|/* Compare sequence numbers using circular math */
end_comment

begin_define
define|#
directive|define
name|L2TP_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((int)((int16_t)(x) - (int16_t)(y)))
end_define

begin_comment
comment|/*  * Sequence number state  *  * Invariants:  *    - If cwnd< ssth, we're doing slow start, otherwise congestion avoidance  *    - The number of unacknowledged xmit packets is (ns - rack)<= seq->wmax  *    - The first (ns - rack) mbuf's in xwin[] array are copies of these  *	unacknowledged packets; the remainder of xwin[] consists first of  *	zero or more further untransmitted packets in the transmit queue  *    - We try to keep the peer's receive window as full as possible.  *	Therefore, (i< cwnd&& xwin[i] != NULL) implies (ns - rack)> i.  *    - rack_timer is running iff (ns - rack)> 0 (unack'd xmit'd pkts)  *    - If xack != nr, there are unacknowledged recv packet(s) (delayed ack)  *    - xack_timer is running iff xack != nr (unack'd rec'd pkts)  */
end_comment

begin_struct
struct|struct
name|l2tp_seq
block|{
name|u_int16_t
name|ns
decl_stmt|;
comment|/* next xmit seq we send */
name|u_int16_t
name|nr
decl_stmt|;
comment|/* next recv seq we expect */
name|u_int16_t
name|rack
decl_stmt|;
comment|/* last 'nr' we rec'd */
name|u_int16_t
name|xack
decl_stmt|;
comment|/* last 'nr' we sent */
name|u_int16_t
name|wmax
decl_stmt|;
comment|/* peer's max recv window */
name|u_int16_t
name|cwnd
decl_stmt|;
comment|/* current congestion window */
name|u_int16_t
name|ssth
decl_stmt|;
comment|/* slow start threshold */
name|u_int16_t
name|acks
decl_stmt|;
comment|/* # consecutive acks rec'd */
name|u_int16_t
name|rexmits
decl_stmt|;
comment|/* # retransmits sent */
name|u_int16_t
name|max_rexmits
decl_stmt|;
comment|/* max # retransmits sent */
name|u_int16_t
name|max_rexmit_to
decl_stmt|;
comment|/* max retransmit timeout */
name|struct
name|callout
name|rack_timer
decl_stmt|;
comment|/* retransmit timer */
name|struct
name|callout
name|xack_timer
decl_stmt|;
comment|/* delayed ack timer */
name|struct
name|mbuf
modifier|*
name|xwin
index|[
name|L2TP_MAX_XWIN
index|]
decl_stmt|;
comment|/* transmit window */
block|}
struct|;
end_struct

begin_comment
comment|/* Node private data */
end_comment

begin_struct
struct|struct
name|ng_l2tp_private
block|{
name|node_p
name|node
decl_stmt|;
comment|/* back pointer to node */
name|hook_p
name|ctrl
decl_stmt|;
comment|/* hook to upper layers */
name|hook_p
name|lower
decl_stmt|;
comment|/* hook to lower layers */
name|struct
name|ng_l2tp_config
name|conf
decl_stmt|;
comment|/* node configuration */
name|struct
name|ng_l2tp_stats
name|stats
decl_stmt|;
comment|/* node statistics */
name|struct
name|l2tp_seq
name|seq
decl_stmt|;
comment|/* ctrl sequence number state */
name|ng_ID_t
name|ftarget
decl_stmt|;
comment|/* failure message target */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_l2tp_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Hook private data (data session hooks only) */
end_comment

begin_struct
struct|struct
name|ng_l2tp_hook_private
block|{
name|struct
name|ng_l2tp_sess_config
name|conf
decl_stmt|;
comment|/* hook/session config */
name|struct
name|ng_l2tp_session_stats
name|stats
decl_stmt|;
comment|/* per sessions statistics */
name|u_int16_t
name|ns
decl_stmt|;
comment|/* data ns sequence number */
name|u_int16_t
name|nr
decl_stmt|;
comment|/* data nr sequence number */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_l2tp_hook_private
modifier|*
name|hookpriv_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_l2tp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_l2tp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_l2tp_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_l2tp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_l2tp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_l2tp_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_l2tp_recv_lower
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_recv_ctrl
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_recv_data
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hookpriv_p
name|hpriv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_xmit_ctrl
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int16_t
name|ns
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_init
parameter_list|(
name|priv_p
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_seq_set
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|struct
name|ng_l2tp_seq_config
modifier|*
name|conf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_seq_adjust
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|struct
name|ng_l2tp_config
modifier|*
name|conf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_reset
parameter_list|(
name|priv_p
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_failure
parameter_list|(
name|priv_p
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_recv_nr
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|u_int16_t
name|nr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_l2tp_seq_recv_ns
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|u_int16_t
name|ns
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_xack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_rack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ng_fn_eachhook
name|ng_l2tp_find_session
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_fn_eachhook
name|ng_l2tp_reset_session
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_function_decl
specifier|static
name|void
name|ng_l2tp_seq_check
parameter_list|(
name|struct
name|l2tp_seq
modifier|*
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Parse type for struct ng_l2tp_seq_config. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_l2tp_seq_config_fields
index|[]
init|=
name|NG_L2TP_SEQ_CONFIG_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_l2tp_seq_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_l2tp_seq_config_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_l2tp_config */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_l2tp_config_type_fields
index|[]
init|=
name|NG_L2TP_CONFIG_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_l2tp_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_l2tp_config_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_l2tp_sess_config */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_l2tp_sess_config_type_fields
index|[]
init|=
name|NG_L2TP_SESS_CONFIG_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_l2tp_sess_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_l2tp_sess_config_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_l2tp_stats */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_l2tp_stats_type_fields
index|[]
init|=
name|NG_L2TP_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_l2tp_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_l2tp_stats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_l2tp_session_stats. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_l2tp_session_stats_type_fields
index|[]
init|=
name|NG_L2TP_SESSION_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_l2tp_session_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_l2tp_session_stats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_l2tp_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_l2tp_config_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_l2tp_config_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_SET_SESS_CONFIG
block|,
literal|"setsessconfig"
block|,
operator|&
name|ng_l2tp_sess_config_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GET_SESS_CONFIG
block|,
literal|"getsessconfig"
block|,
operator|&
name|ng_parse_hint16_type
block|,
operator|&
name|ng_l2tp_sess_config_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GET_STATS
block|,
literal|"getstats"
block|,
name|NULL
block|,
operator|&
name|ng_l2tp_stats_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_CLR_STATS
block|,
literal|"clrstats"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
name|NULL
block|,
operator|&
name|ng_l2tp_stats_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GET_SESSION_STATS
block|,
literal|"getsessstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_l2tp_session_stats_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_CLR_SESSION_STATS
block|,
literal|"clrsessstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_GETCLR_SESSION_STATS
block|,
literal|"getclrsessstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_l2tp_session_stats_type
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_ACK_FAILURE
block|,
literal|"ackfailure"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_L2TP_COOKIE
block|,
name|NGM_L2TP_SET_SEQ
block|,
literal|"setsequence"
block|,
operator|&
name|ng_l2tp_seq_config_type
block|,
name|NULL
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_l2tp_typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_L2TP_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_l2tp_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_l2tp_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_l2tp_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_l2tp_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_l2tp_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_l2tp_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_l2tp_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|l2tp
argument_list|,
operator|&
name|ng_l2tp_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Sequence number state sanity checking */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|L2TP_SEQ_CHECK
parameter_list|(
name|seq
parameter_list|)
value|ng_l2tp_seq_check(seq)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|L2TP_SEQ_CHECK
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* memmove macro */
end_comment

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
value|bcopy(s, d, l)
end_define

begin_comment
comment|/* Whether to use m_copypacket() or m_dup() */
end_comment

begin_define
define|#
directive|define
name|L2TP_COPY_MBUF
value|m_copypacket
end_define

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF ************************************************************************/
end_comment

begin_comment
comment|/*  * Node type constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
comment|/* Allocate private structure */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_L2TP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|node
expr_stmt|;
comment|/* Apply a semi-reasonable default configuration */
name|priv
operator|->
name|conf
operator|.
name|peer_win
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|rexmit_max
operator|=
name|L2TP_MAX_REXMIT
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|rexmit_max_to
operator|=
name|L2TP_MAX_REXMIT_TO
expr_stmt|;
comment|/* Initialize sequence number state */
name|ng_l2tp_seq_init
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our OK for a hook to be added.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Check hook name */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_L2TP_HOOK_CTRL
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|ctrl
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
name|priv
operator|->
name|ctrl
operator|=
name|hook
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_L2TP_HOOK_LOWER
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|lower
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
name|priv
operator|->
name|lower
operator|=
name|hook
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
name|hexdig
index|[
literal|16
index|]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|u_int16_t
name|session_id
decl_stmt|;
name|hookpriv_p
name|hpriv
decl_stmt|;
specifier|const
name|char
modifier|*
name|hex
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Parse hook name to get session ID */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_L2TP_HOOK_SESSION_P
argument_list|,
sizeof|sizeof
argument_list|(
name|NG_L2TP_HOOK_SESSION_P
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hex
operator|=
name|name
operator|+
sizeof|sizeof
argument_list|(
name|NG_L2TP_HOOK_SESSION_P
argument_list|)
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|session_id
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
operator|&&
name|hex
index|[
name|i
index|]
operator|!=
name|hexdig
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|j
operator|==
literal|16
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|session_id
operator|=
operator|(
name|session_id
operator|<<
literal|4
operator|)
operator||
name|j
expr_stmt|;
block|}
if|if
condition|(
name|hex
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Create hook private structure */
name|MALLOC
argument_list|(
name|hpriv
argument_list|,
name|hookpriv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hpriv
argument_list|)
argument_list|,
name|M_NETGRAPH_L2TP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpriv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|hpriv
operator|->
name|conf
operator|.
name|session_id
operator|=
name|htons
argument_list|(
name|session_id
argument_list|)
expr_stmt|;
name|hpriv
operator|->
name|conf
operator|.
name|control_dseq
operator|=
name|L2TP_CONTROL_DSEQ
expr_stmt|;
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
operator|=
name|L2TP_ENABLE_DSEQ
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|hpriv
argument_list|)
expr_stmt|;
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_L2TP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_L2TP_SET_CONFIG
case|:
block|{
name|struct
name|ng_l2tp_config
modifier|*
specifier|const
name|conf
init|=
operator|(
expr|struct
name|ng_l2tp_config
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
comment|/* Check for invalid or illegal config */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|conf
operator|->
name|enabled
operator|=
operator|!
operator|!
name|conf
operator|->
name|enabled
expr_stmt|;
name|conf
operator|->
name|match_id
operator|=
operator|!
operator|!
name|conf
operator|->
name|match_id
expr_stmt|;
name|conf
operator|->
name|tunnel_id
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|tunnel_id
argument_list|)
expr_stmt|;
name|conf
operator|->
name|peer_id
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|peer_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enabled
operator|&&
operator|(
operator|(
name|priv
operator|->
name|conf
operator|.
name|tunnel_id
operator|!=
literal|0
operator|&&
name|conf
operator|->
name|tunnel_id
operator|!=
name|priv
operator|->
name|conf
operator|.
name|tunnel_id
operator|)
operator|||
operator|(
operator|(
name|priv
operator|->
name|conf
operator|.
name|peer_id
operator|!=
literal|0
operator|&&
name|conf
operator|->
name|peer_id
operator|!=
name|priv
operator|->
name|conf
operator|.
name|peer_id
operator|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* Save calling node as failure target */
name|priv
operator|->
name|ftarget
operator|=
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Adjust sequence number state */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_l2tp_seq_adjust
argument_list|(
name|priv
argument_list|,
name|conf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Update node's config */
name|priv
operator|->
name|conf
operator|=
operator|*
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_GET_CONFIG
case|:
block|{
name|struct
name|ng_l2tp_config
modifier|*
name|conf
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_l2tp_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|conf
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
comment|/* Put ID's in host order */
name|conf
operator|->
name|tunnel_id
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|tunnel_id
argument_list|)
expr_stmt|;
name|conf
operator|->
name|peer_id
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|peer_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_SET_SESS_CONFIG
case|:
block|{
name|struct
name|ng_l2tp_sess_config
modifier|*
specifier|const
name|conf
init|=
operator|(
expr|struct
name|ng_l2tp_sess_config
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|hookpriv_p
name|hpriv
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Check for invalid or illegal config. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Put ID's in network order */
name|conf
operator|->
name|session_id
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|session_id
argument_list|)
expr_stmt|;
name|conf
operator|->
name|peer_id
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|peer_id
argument_list|)
expr_stmt|;
comment|/* Find matching hook */
name|NG_NODE_FOREACH_HOOK
argument_list|(
name|node
argument_list|,
name|ng_l2tp_find_session
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|conf
operator|->
name|session_id
argument_list|,
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|hpriv
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* Update hook's config */
name|hpriv
operator|->
name|conf
operator|=
operator|*
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_GET_SESS_CONFIG
case|:
block|{
name|struct
name|ng_l2tp_sess_config
modifier|*
name|conf
decl_stmt|;
name|u_int16_t
name|session_id
decl_stmt|;
name|hookpriv_p
name|hpriv
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Get session ID */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
operator|&
name|session_id
argument_list|,
name|msg
operator|->
name|data
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|session_id
operator|=
name|htons
argument_list|(
name|session_id
argument_list|)
expr_stmt|;
comment|/* Find matching hook */
name|NG_NODE_FOREACH_HOOK
argument_list|(
name|node
argument_list|,
name|ng_l2tp_find_session
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|session_id
argument_list|,
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|hpriv
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
comment|/* Send response */
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|hpriv
operator|->
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_l2tp_sess_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|conf
operator|=
name|hpriv
operator|->
name|conf
expr_stmt|;
comment|/* Put ID's in host order */
name|conf
operator|->
name|session_id
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|session_id
argument_list|)
expr_stmt|;
name|conf
operator|->
name|peer_id
operator|=
name|ntohs
argument_list|(
name|conf
operator|->
name|peer_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_GET_STATS
case|:
case|case
name|NGM_L2TP_CLR_STATS
case|:
case|case
name|NGM_L2TP_GETCLR_STATS
case|:
block|{
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_L2TP_CLR_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|resp
operator|->
name|data
argument_list|,
operator|&
name|priv
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_L2TP_GET_STATS
condition|)
name|memset
argument_list|(
operator|&
name|priv
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_GET_SESSION_STATS
case|:
case|case
name|NGM_L2TP_CLR_SESSION_STATS
case|:
case|case
name|NGM_L2TP_GETCLR_SESSION_STATS
case|:
block|{
name|uint16_t
name|session_id
decl_stmt|;
name|hookpriv_p
name|hpriv
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
comment|/* Get session ID. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|session_id
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
name|msg
operator|->
name|data
argument_list|,
operator|&
name|session_id
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|session_id
operator|=
name|htons
argument_list|(
name|session_id
argument_list|)
expr_stmt|;
comment|/* Find matching hook. */
name|NG_NODE_FOREACH_HOOK
argument_list|(
name|node
argument_list|,
name|ng_l2tp_find_session
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|session_id
argument_list|,
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|hpriv
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_L2TP_CLR_SESSION_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|hpriv
operator|->
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|hpriv
operator|->
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|hpriv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_L2TP_GET_SESSION_STATS
condition|)
name|bzero
argument_list|(
operator|&
name|hpriv
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|hpriv
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_L2TP_SET_SEQ
case|:
block|{
name|struct
name|ng_l2tp_seq_config
modifier|*
specifier|const
name|conf
init|=
operator|(
expr|struct
name|ng_l2tp_seq_config
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
comment|/* Check for invalid or illegal seq config. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|conf
operator|->
name|ns
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|ns
argument_list|)
expr_stmt|;
name|conf
operator|->
name|nr
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|nr
argument_list|)
expr_stmt|;
name|conf
operator|->
name|rack
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|rack
argument_list|)
expr_stmt|;
name|conf
operator|->
name|xack
operator|=
name|htons
argument_list|(
name|conf
operator|->
name|xack
argument_list|)
expr_stmt|;
comment|/* Set sequence numbers. */
name|error
operator|=
name|ng_l2tp_seq_set
argument_list|(
name|priv
argument_list|,
name|conf
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Done */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive incoming data on a hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Sanity check */
name|L2TP_SEQ_CHECK
argument_list|(
operator|&
name|priv
operator|->
name|seq
argument_list|)
expr_stmt|;
comment|/* If not configured, reject */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enabled
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Handle incoming frame from below */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|lower
condition|)
block|{
name|error
operator|=
name|ng_l2tp_recv_lower
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Handle outgoing control frame */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|ctrl
condition|)
block|{
name|error
operator|=
name|ng_l2tp_recv_ctrl
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Handle outgoing data frame */
name|error
operator|=
name|ng_l2tp_recv_data
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Done */
name|L2TP_SEQ_CHECK
argument_list|(
operator|&
name|priv
operator|->
name|seq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy node  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
comment|/* Sanity check */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Reset sequence number state */
name|ng_l2tp_seq_reset
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Free private data if neither timer is running */
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_L2TP
argument_list|)
expr_stmt|;
comment|/* Unref node */
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Zero out hook pointer */
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|ctrl
condition|)
name|priv
operator|->
name|ctrl
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|lower
condition|)
name|priv
operator|->
name|lower
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|FREE
argument_list|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|M_NETGRAPH_L2TP
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Go away if no longer connected to anything */
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|&&
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************* 			INTERNAL FUNCTIONS *************************************************************************/
end_comment

begin_comment
comment|/*  * Find the hook with a given session ID.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_find_session
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|hookpriv_p
name|hpriv
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|u_int16_t
name|sid
init|=
operator|(
name|u_int16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|hpriv
operator|==
name|NULL
operator|||
name|hpriv
operator|->
name|conf
operator|.
name|session_id
operator|!=
name|sid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a hook's session state.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_reset_session
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|hookpriv_p
name|hpriv
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|hpriv
operator|!=
name|NULL
condition|)
block|{
name|hpriv
operator|->
name|conf
operator|.
name|control_dseq
operator|=
literal|0
expr_stmt|;
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|hpriv
operator|->
name|conf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_l2tp_session_stats
argument_list|)
argument_list|)
expr_stmt|;
name|hpriv
operator|->
name|nr
operator|=
literal|0
expr_stmt|;
name|hpriv
operator|->
name|ns
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an incoming frame from below.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_recv_lower
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|static
specifier|const
name|u_int16_t
name|req_bits
index|[
literal|2
index|]
index|[
literal|2
index|]
init|=
block|{
block|{
name|L2TP_DATA_0BITS
block|,
name|L2TP_DATA_1BITS
block|}
block|,
block|{
name|L2TP_CTRL_0BITS
block|,
name|L2TP_CTRL_1BITS
block|}
block|, 	}
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hookpriv_p
name|hpriv
init|=
name|NULL
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|u_int16_t
name|ids
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|hdr
decl_stmt|;
name|u_int16_t
name|ns
decl_stmt|;
name|u_int16_t
name|nr
decl_stmt|;
name|int
name|is_ctrl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|,
name|plen
decl_stmt|;
comment|/* Grab mbuf */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Remember full packet length; needed for per session accounting. */
name|plen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Update stats */
name|priv
operator|->
name|stats
operator|.
name|recvPackets
operator|++
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|plen
expr_stmt|;
comment|/* Get initial header */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|6
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvRunts
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|hdr
operator|=
name|ntohs
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Check required header bits and minimum length */
name|is_ctrl
operator|=
operator|(
name|hdr
operator|&
name|L2TP_HDR_CTRL
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|&
name|req_bits
index|[
name|is_ctrl
index|]
index|[
literal|0
index|]
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|~
name|hdr
operator|&
name|req_bits
index|[
name|is_ctrl
index|]
index|[
literal|1
index|]
operator|)
operator|!=
literal|0
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvInvalid
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
comment|/* tunnel, session id */
operator|+
operator|(
literal|2
operator|*
operator|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_LEN
operator|)
operator|!=
literal|0
operator|)
operator|)
comment|/* length field */
operator|+
operator|(
literal|4
operator|*
operator|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_SEQ
operator|)
operator|!=
literal|0
operator|)
operator|)
comment|/* seq # fields */
operator|+
operator|(
literal|2
operator|*
operator|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_OFF
operator|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* offset field */
name|priv
operator|->
name|stats
operator|.
name|recvRunts
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Get and validate length field if present */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_LEN
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|len
operator|=
operator|(
name|u_int16_t
operator|)
name|ntohs
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|)
operator|-
literal|4
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvInvalid
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|<
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
comment|/* trim extra bytes */
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|len
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get tunnel ID and session ID */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|ids
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Check tunnel ID */
if|if
condition|(
name|ids
index|[
literal|0
index|]
operator|!=
name|priv
operator|->
name|conf
operator|.
name|tunnel_id
operator|&&
operator|(
name|priv
operator|->
name|conf
operator|.
name|match_id
operator|||
name|ids
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvWrongTunnel
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
comment|/* Check session ID (for data packets only) */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_CTRL
operator|)
operator|==
literal|0
condition|)
block|{
name|NG_NODE_FOREACH_HOOK
argument_list|(
name|node
argument_list|,
name|ng_l2tp_find_session
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ids
index|[
literal|1
index|]
argument_list|,
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvUnknownSID
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|hpriv
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
block|}
comment|/* Get Ns, Nr fields if present */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_SEQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|ns
argument_list|,
operator|&
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ns
operator|=
name|ntohs
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|nr
argument_list|,
operator|&
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|nr
operator|=
name|ntohs
argument_list|(
name|nr
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Strip offset padding if present */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_OFF
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int16_t
name|offset
decl_stmt|;
comment|/* Get length of offset padding */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|offset
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ntohs
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* Trim offset padding */
if|if
condition|(
operator|(
literal|2
operator|+
name|offset
operator|)
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvInvalid
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* Handle control packets */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_CTRL
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Handle receive ack sequence number Nr */
name|ng_l2tp_seq_recv_nr
argument_list|(
name|priv
argument_list|,
name|nr
argument_list|)
expr_stmt|;
comment|/* Discard ZLB packets */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvZLBs
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * Prepend session ID to packet here: we don't want to accept 		 * the send sequence number Ns if we have to drop the packet 		 * later because of a memory error, because then the upper 		 * layer would never get the packet. 		 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|2
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|,
operator|&
name|ids
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Now handle send sequence number */
if|if
condition|(
name|ng_l2tp_seq_recv_ns
argument_list|(
name|priv
argument_list|,
name|ns
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deliver packet to upper layers */
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|ctrl
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Per session packet, account it. */
name|hpriv
operator|->
name|stats
operator|.
name|recvPackets
operator|++
expr_stmt|;
name|hpriv
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|plen
expr_stmt|;
comment|/* Follow peer's lead in data sequencing, if configured to do so */
if|if
condition|(
operator|!
name|hpriv
operator|->
name|conf
operator|.
name|control_dseq
condition|)
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
operator|=
operator|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_SEQ
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* Handle data sequence numbers if present and enabled */
if|if
condition|(
operator|(
name|hdr
operator|&
name|L2TP_HDR_SEQ
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
operator|&&
name|L2TP_SEQ_DIFF
argument_list|(
name|ns
argument_list|,
name|hpriv
operator|->
name|nr
argument_list|)
operator|<
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* duplicate or out of order */
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|recvDataDrops
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hpriv
operator|->
name|nr
operator|=
name|ns
operator|+
literal|1
expr_stmt|;
block|}
comment|/* Drop empty data packets */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deliver data */
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an outgoing control frame.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_recv_ctrl
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Grab mbuf and discard other stuff XXX */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Packet should have session ID prepended */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|2
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitInvalid
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check max length */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|0x10000
operator|-
literal|14
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitTooBig
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
comment|/* Find next empty slot in transmit queue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L2TP_MAX_XWIN
operator|&&
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|==
name|L2TP_MAX_XWIN
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitDrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
comment|/* Sanity check receive ack timer state */
name|KASSERT
argument_list|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|^
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
argument_list|,
operator|(
literal|"%s: xwin %d full but rack timer %s running"
operator|,
name|__func__
operator|,
name|i
operator|,
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
condition|?
literal|""
else|:
literal|"not "
operator|)
argument_list|)
expr_stmt|;
comment|/* If peer's receive window is already full, nothing else to do */
if|if
condition|(
name|i
operator|>=
name|seq
operator|->
name|cwnd
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Start retransmit timer if not already running */
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
condition|)
name|ng_callout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|,
name|ng_l2tp_seq_rack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Copy packet */
if|if
condition|(
operator|(
name|m
operator|=
name|L2TP_COPY_MBUF
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Send packet and increment xmit sequence number */
return|return
operator|(
name|ng_l2tp_xmit_ctrl
argument_list|(
name|priv
argument_list|,
name|m
argument_list|,
name|seq
operator|->
name|ns
operator|++
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an outgoing data frame.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_recv_data
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hookpriv_p
name|hpriv
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|hdr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* Get mbuf */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Check max length */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|0x10000
operator|-
literal|12
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|xmitDataTooBig
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
comment|/* Prepend L2TP header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|6
operator|+
operator|(
literal|2
operator|*
operator|(
name|hpriv
operator|->
name|conf
operator|.
name|include_length
operator|!=
literal|0
operator|)
operator|)
operator|+
operator|(
literal|4
operator|*
operator|(
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
operator|!=
literal|0
operator|)
operator|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|hdr
operator|=
name|L2TP_DATA_HDR
expr_stmt|;
if|if
condition|(
name|hpriv
operator|->
name|conf
operator|.
name|include_length
condition|)
block|{
name|hdr
operator||=
name|L2TP_HDR_LEN
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
name|i
operator|++
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
name|i
operator|++
index|]
operator|=
name|priv
operator|->
name|conf
operator|.
name|peer_id
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
name|i
operator|++
index|]
operator|=
name|hpriv
operator|->
name|conf
operator|.
name|peer_id
expr_stmt|;
if|if
condition|(
name|hpriv
operator|->
name|conf
operator|.
name|enable_dseq
condition|)
block|{
name|hdr
operator||=
name|L2TP_HDR_SEQ
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
name|i
operator|++
index|]
operator|=
name|htons
argument_list|(
name|hpriv
operator|->
name|ns
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
name|i
operator|++
index|]
operator|=
name|htons
argument_list|(
name|hpriv
operator|->
name|nr
argument_list|)
expr_stmt|;
name|hpriv
operator|->
name|ns
operator|++
expr_stmt|;
block|}
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
comment|/* Update per session stats. */
name|hpriv
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|hpriv
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* And the global one. */
name|priv
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Send packet */
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|lower
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a message to our controlling node that we've failed.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_failure
parameter_list|(
name|priv_p
name|priv
parameter_list|)
block|{
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_L2TP_COOKIE
argument_list|,
name|NGM_L2TP_ACK_FAILURE
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return;
name|NG_SEND_MSG_ID
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|node
argument_list|,
name|msg
argument_list|,
name|priv
operator|->
name|ftarget
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			SEQUENCE NUMBER HANDLING ************************************************************************/
end_comment

begin_comment
comment|/*  * Initialize sequence number state.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_init
parameter_list|(
name|priv_p
name|priv
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|KASSERT
argument_list|(
name|priv
operator|->
name|conf
operator|.
name|peer_win
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: peer_win is zero"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|->
name|cwnd
operator|=
literal|1
expr_stmt|;
name|seq
operator|->
name|wmax
operator|=
name|priv
operator|->
name|conf
operator|.
name|peer_win
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|wmax
operator|>
name|L2TP_MAX_XWIN
condition|)
name|seq
operator|->
name|wmax
operator|=
name|L2TP_MAX_XWIN
expr_stmt|;
name|seq
operator|->
name|ssth
operator|=
name|seq
operator|->
name|wmax
expr_stmt|;
name|seq
operator|->
name|max_rexmits
operator|=
name|priv
operator|->
name|conf
operator|.
name|rexmit_max
expr_stmt|;
name|seq
operator|->
name|max_rexmit_to
operator|=
name|priv
operator|->
name|conf
operator|.
name|rexmit_max_to
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|)
expr_stmt|;
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set sequence number state as given from user.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_seq_set
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|struct
name|ng_l2tp_seq_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
comment|/* If node is enabled, deny update to sequence numbers. */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enabled
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* We only can handle the simple cases. */
if|if
condition|(
name|conf
operator|->
name|xack
operator|!=
name|conf
operator|->
name|nr
operator|||
name|conf
operator|->
name|ns
operator|!=
name|conf
operator|->
name|rack
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Set ns,nr,rack,xack parameters. */
name|seq
operator|->
name|ns
operator|=
name|conf
operator|->
name|ns
expr_stmt|;
name|seq
operator|->
name|nr
operator|=
name|conf
operator|->
name|nr
expr_stmt|;
name|seq
operator|->
name|rack
operator|=
name|conf
operator|->
name|rack
expr_stmt|;
name|seq
operator|->
name|xack
operator|=
name|conf
operator|->
name|xack
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust sequence number state accordingly after reconfiguration.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_seq_adjust
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|struct
name|ng_l2tp_config
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|u_int16_t
name|new_wmax
decl_stmt|;
comment|/* If disabling node, reset state sequence number */
if|if
condition|(
operator|!
name|conf
operator|->
name|enabled
condition|)
block|{
name|ng_l2tp_seq_reset
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Adjust peer's max recv window; it can only increase */
name|new_wmax
operator|=
name|conf
operator|->
name|peer_win
expr_stmt|;
if|if
condition|(
name|new_wmax
operator|>
name|L2TP_MAX_XWIN
condition|)
name|new_wmax
operator|=
name|L2TP_MAX_XWIN
expr_stmt|;
if|if
condition|(
name|new_wmax
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|new_wmax
operator|<
name|seq
operator|->
name|wmax
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|seq
operator|->
name|wmax
operator|=
name|new_wmax
expr_stmt|;
comment|/* Update retransmit parameters */
name|seq
operator|->
name|max_rexmits
operator|=
name|conf
operator|->
name|rexmit_max
expr_stmt|;
name|seq
operator|->
name|max_rexmit_to
operator|=
name|conf
operator|->
name|rexmit_max_to
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset sequence number state.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_reset
parameter_list|(
name|priv_p
name|priv
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Sanity check */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Stop timers */
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Free retransmit queue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|L2TP_MAX_XWIN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Reset session hooks' sequence number states */
name|NG_NODE_FOREACH_HOOK
argument_list|(
name|priv
operator|->
name|node
argument_list|,
name|ng_l2tp_reset_session
argument_list|,
name|NULL
argument_list|,
name|hook
argument_list|)
expr_stmt|;
comment|/* Reset node's sequence number state */
name|memset
argument_list|(
name|seq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seq
argument_list|)
argument_list|)
expr_stmt|;
name|seq
operator|->
name|cwnd
operator|=
literal|1
expr_stmt|;
name|seq
operator|->
name|wmax
operator|=
name|L2TP_MAX_XWIN
expr_stmt|;
name|seq
operator|->
name|ssth
operator|=
name|seq
operator|->
name|wmax
expr_stmt|;
comment|/* Done */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle receipt of an acknowledgement value (Nr) from peer.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_recv_nr
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|u_int16_t
name|nr
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|nack
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Verify peer's ACK is in range */
if|if
condition|(
operator|(
name|nack
operator|=
name|L2TP_SEQ_DIFF
argument_list|(
name|nr
argument_list|,
name|seq
operator|->
name|rack
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return;
comment|/* duplicate ack */
if|if
condition|(
name|L2TP_SEQ_DIFF
argument_list|(
name|nr
argument_list|,
name|seq
operator|->
name|ns
argument_list|)
operator|>
literal|0
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|recvBadAcks
operator|++
expr_stmt|;
comment|/* ack for packet not sent */
return|return;
block|}
name|KASSERT
argument_list|(
name|nack
operator|<=
name|L2TP_MAX_XWIN
argument_list|,
operator|(
literal|"%s: nack=%d> %d"
operator|,
name|__func__
operator|,
name|nack
operator|,
name|L2TP_MAX_XWIN
operator|)
argument_list|)
expr_stmt|;
comment|/* Update receive ack stats */
name|seq
operator|->
name|rack
operator|=
name|nr
expr_stmt|;
name|seq
operator|->
name|rexmits
operator|=
literal|0
expr_stmt|;
comment|/* Free acknowledged packets and shift up packets in the xmit queue */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nack
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|seq
operator|->
name|xwin
argument_list|,
name|seq
operator|->
name|xwin
operator|+
name|nack
argument_list|,
operator|(
name|L2TP_MAX_XWIN
operator|-
name|nack
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|seq
operator|->
name|xwin
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|seq
operator|->
name|xwin
operator|+
operator|(
name|L2TP_MAX_XWIN
operator|-
name|nack
operator|)
argument_list|,
literal|0
argument_list|,
name|nack
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|seq
operator|->
name|xwin
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Do slow-start/congestion avoidance windowing algorithm described 	 * in RFC 2661, Appendix A. Here we handle a multiple ACK as if each 	 * ACK had arrived separately. 	 */
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|<
name|seq
operator|->
name|wmax
condition|)
block|{
comment|/* Handle slow start phase */
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|<
name|seq
operator|->
name|ssth
condition|)
block|{
name|seq
operator|->
name|cwnd
operator|+=
name|nack
expr_stmt|;
name|nack
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|>
name|seq
operator|->
name|ssth
condition|)
block|{
comment|/* into cg.av. phase */
name|nack
operator|=
name|seq
operator|->
name|cwnd
operator|-
name|seq
operator|->
name|ssth
expr_stmt|;
name|seq
operator|->
name|cwnd
operator|=
name|seq
operator|->
name|ssth
expr_stmt|;
block|}
block|}
comment|/* Handle congestion avoidance phase */
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|>=
name|seq
operator|->
name|ssth
condition|)
block|{
name|seq
operator|->
name|acks
operator|+=
name|nack
expr_stmt|;
while|while
condition|(
name|seq
operator|->
name|acks
operator|>=
name|seq
operator|->
name|cwnd
condition|)
block|{
name|seq
operator|->
name|acks
operator|-=
name|seq
operator|->
name|cwnd
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|<
name|seq
operator|->
name|wmax
condition|)
name|seq
operator|->
name|cwnd
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* Stop xmit timer */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
condition|)
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* If transmit queue is empty, we're done for now */
if|if
condition|(
name|seq
operator|->
name|xwin
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return;
comment|/* Start restransmit timer again */
name|ng_callout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|,
name|ng_l2tp_seq_rack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Send more packets, trying to keep peer's receive window full. 	 * If there is a memory error, pretend packet was sent, as it 	 * will get retransmitted later anyway. 	 */
while|while
condition|(
operator|(
name|i
operator|=
name|L2TP_SEQ_DIFF
argument_list|(
name|seq
operator|->
name|ns
argument_list|,
name|seq
operator|->
name|rack
argument_list|)
operator|)
operator|<
name|seq
operator|->
name|cwnd
operator|&&
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|L2TP_COPY_MBUF
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
else|else
name|ng_l2tp_xmit_ctrl
argument_list|(
name|priv
argument_list|,
name|m
argument_list|,
name|seq
operator|->
name|ns
argument_list|)
expr_stmt|;
name|seq
operator|->
name|ns
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle receipt of a sequence number value (Ns) from peer.  * We make no attempt to re-order out of order packets.  *  * This function should only be called for non-ZLB packets.  *  * Returns:  *	 0	Accept packet  *	-1	Drop packet  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_seq_recv_ns
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|u_int16_t
name|ns
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
comment|/* If not what we expect, drop packet and send an immediate ZLB ack */
if|if
condition|(
name|ns
operator|!=
name|seq
operator|->
name|nr
condition|)
block|{
if|if
condition|(
name|L2TP_SEQ_DIFF
argument_list|(
name|ns
argument_list|,
name|seq
operator|->
name|nr
argument_list|)
operator|<
literal|0
condition|)
name|priv
operator|->
name|stats
operator|.
name|recvDuplicates
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|stats
operator|.
name|recvOutOfOrder
operator|++
expr_stmt|;
name|ng_l2tp_xmit_ctrl
argument_list|(
name|priv
argument_list|,
name|NULL
argument_list|,
name|seq
operator|->
name|ns
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Update recv sequence number */
name|seq
operator|->
name|nr
operator|++
expr_stmt|;
comment|/* Start receive ack timer, if not already running */
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|)
condition|)
name|ng_callout
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|,
name|NULL
argument_list|,
name|L2TP_DELAYED_ACK
argument_list|,
name|ng_l2tp_seq_xack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Accept packet */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an ack timeout. We have an outstanding ack that we  * were hoping to piggy-back, but haven't, so send a ZLB.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_xack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
comment|/* Sanity check */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* If ack is still outstanding, send a ZLB */
if|if
condition|(
name|seq
operator|->
name|xack
operator|!=
name|seq
operator|->
name|nr
condition|)
name|ng_l2tp_xmit_ctrl
argument_list|(
name|priv
argument_list|,
name|NULL
argument_list|,
name|seq
operator|->
name|ns
argument_list|)
expr_stmt|;
comment|/* Done */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Handle a transmit timeout. The peer has failed to respond  * with an ack for our packet, so retransmit it.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_rack_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|delay
decl_stmt|;
comment|/* Sanity check */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* Make sure peer's ack is still outstanding before doing anything */
if|if
condition|(
name|seq
operator|->
name|rack
operator|==
name|seq
operator|->
name|ns
condition|)
goto|goto
name|done
goto|;
name|priv
operator|->
name|stats
operator|.
name|xmitRetransmits
operator|++
expr_stmt|;
comment|/* Have we reached the retransmit limit? If so, notify owner. */
if|if
condition|(
name|seq
operator|->
name|rexmits
operator|++
operator|>=
name|seq
operator|->
name|max_rexmits
condition|)
name|ng_l2tp_seq_failure
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Restart timer, this time with an increased delay */
name|delay
operator|=
operator|(
name|seq
operator|->
name|rexmits
operator|>
literal|12
operator|)
condition|?
operator|(
literal|1
operator|<<
literal|12
operator|)
else|:
operator|(
literal|1
operator|<<
name|seq
operator|->
name|rexmits
operator|)
expr_stmt|;
if|if
condition|(
name|delay
operator|>
name|seq
operator|->
name|max_rexmit_to
condition|)
name|delay
operator|=
name|seq
operator|->
name|max_rexmit_to
expr_stmt|;
name|ng_callout
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|hz
operator|*
name|delay
argument_list|,
name|ng_l2tp_seq_rack_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Do slow-start/congestion algorithm windowing algorithm */
name|seq
operator|->
name|ssth
operator|=
operator|(
name|seq
operator|->
name|cwnd
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|seq
operator|->
name|cwnd
operator|=
literal|1
expr_stmt|;
name|seq
operator|->
name|acks
operator|=
literal|0
expr_stmt|;
comment|/* Retransmit oldest unack'd packet */
if|if
condition|(
operator|(
name|m
operator|=
name|L2TP_COPY_MBUF
argument_list|(
name|seq
operator|->
name|xwin
index|[
literal|0
index|]
argument_list|,
name|M_DONTWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
else|else
name|ng_l2tp_xmit_ctrl
argument_list|(
name|priv
argument_list|,
name|m
argument_list|,
name|seq
operator|->
name|rack
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* Done */
name|L2TP_SEQ_CHECK
argument_list|(
name|seq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmit a control stream packet, payload optional.  * The transmit sequence number is not incremented.  */
end_comment

begin_function
specifier|static
name|int
name|ng_l2tp_xmit_ctrl
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int16_t
name|ns
parameter_list|)
block|{
name|struct
name|l2tp_seq
modifier|*
specifier|const
name|seq
init|=
operator|&
name|priv
operator|->
name|seq
decl_stmt|;
name|u_int16_t
name|session_id
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* If no mbuf passed, send an empty packet (ZLB) */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Create a new mbuf for ZLB packet */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|12
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|xmitZLBs
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Strip off session ID */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|session_id
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Make room for L2TP header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|12
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* Fill in L2TP header */
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|L2TP_CTRL_HDR
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|2
index|]
operator|=
name|priv
operator|->
name|conf
operator|.
name|peer_id
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|3
index|]
operator|=
name|session_id
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|4
index|]
operator|=
name|htons
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|5
index|]
operator|=
name|htons
argument_list|(
name|seq
operator|->
name|nr
argument_list|)
expr_stmt|;
comment|/* Update sequence number info and stats */
name|priv
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|priv
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Stop ack timer: we're sending an ack with this packet */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|)
condition|)
name|ng_uncallout
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|,
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
name|seq
operator|->
name|xack
operator|=
name|seq
operator|->
name|nr
expr_stmt|;
comment|/* Send packet */
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|lower
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_comment
comment|/*  * Sanity check sequence number state.  */
end_comment

begin_function
specifier|static
name|void
name|ng_l2tp_seq_check
parameter_list|(
name|struct
name|l2tp_seq
modifier|*
name|seq
parameter_list|)
block|{
specifier|const
name|int
name|self_unack
init|=
name|L2TP_SEQ_DIFF
argument_list|(
name|seq
operator|->
name|nr
argument_list|,
name|seq
operator|->
name|xack
argument_list|)
decl_stmt|;
specifier|const
name|int
name|peer_unack
init|=
name|L2TP_SEQ_DIFF
argument_list|(
name|seq
operator|->
name|ns
argument_list|,
name|seq
operator|->
name|rack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|CHECK
parameter_list|(
name|p
parameter_list|)
value|KASSERT((p), ("%s: not: %s", __func__, #p))
name|CHECK
argument_list|(
name|seq
operator|->
name|wmax
operator|<=
name|L2TP_MAX_XWIN
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|seq
operator|->
name|cwnd
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|seq
operator|->
name|cwnd
operator|<=
name|seq
operator|->
name|wmax
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|seq
operator|->
name|ssth
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|seq
operator|->
name|ssth
operator|<=
name|seq
operator|->
name|wmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|->
name|cwnd
operator|<
name|seq
operator|->
name|ssth
condition|)
name|CHECK
argument_list|(
name|seq
operator|->
name|acks
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|CHECK
argument_list|(
name|seq
operator|->
name|acks
operator|<=
name|seq
operator|->
name|cwnd
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|self_unack
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|peer_unack
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|peer_unack
operator|<=
name|seq
operator|->
name|wmax
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
operator|(
name|self_unack
operator|==
literal|0
operator|)
operator|^
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|xack_timer
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
operator|(
name|peer_unack
operator|==
literal|0
operator|)
operator|^
name|callout_pending
argument_list|(
operator|&
name|seq
operator|->
name|rack_timer
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peer_unack
condition|;
name|i
operator|++
control|)
name|CHECK
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|seq
operator|->
name|cwnd
condition|;
name|i
operator|++
control|)
comment|/* verify peer's recv window full */
name|CHECK
argument_list|(
name|seq
operator|->
name|xwin
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|CHECK
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANTS */
end_comment

end_unit

