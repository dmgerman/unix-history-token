begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_socket.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *  * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *  * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_socket.c,v 1.28 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * Netgraph socket nodes  *  * There are two types of netgraph sockets, control and data.  * Control sockets have a netgraph node, but data sockets are  * parasitic on control sockets, and have no node of their own.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PATH
argument_list|,
literal|"netgraph_path"
argument_list|,
literal|"netgraph path info "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_SOCK
argument_list|,
literal|"netgraph_sock"
argument_list|,
literal|"netgraph socket info "
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PATH
value|M_NETGRAPH
end_define

begin_define
define|#
directive|define
name|M_NETGRAPH_SOCK
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * It's Ascii-art time!  *   +-------------+   +-------------+  *   |socket  (ctl)|   |socket (data)|  *   +-------------+   +-------------+  *          ^                 ^  *          |                 |  *          v                 v  *    +-----------+     +-----------+  *    |pcb   (ctl)|     |pcb  (data)|  *    +-----------+     +-----------+  *          ^                 ^  *          |                 |  *          v                 v  *      +--------------------------+  *      |   Socket type private    |  *      |       data               |  *      +--------------------------+  *                   ^  *                   |  *                   v  *           +----------------+  *           | struct ng_node |  *           +----------------+  */
end_comment

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ngs_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ngs_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ngs_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ngs_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ngs_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ngs_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ngs_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal methods */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int	ng_internalize(struct mbuf *m, struct proc *p); */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ship_msg
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_ng
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_SOCKET_NODE_TYPE
block|,
name|ngs_mod_event
block|,
name|ngs_constructor
block|,
name|ngs_rcvmsg
block|,
name|ngs_shutdown
block|,
name|ngs_newhook
block|,
name|NULL
block|,
name|ngs_connect
block|,
name|ngs_rcvdata
block|,
name|ngs_disconnect
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|socket
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Buffer space */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_sendspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_recvspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all sockets */
end_comment

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ngpcb
argument_list|)
end_macro

begin_expr_stmt
name|ngsocklist
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|sotongpcb
parameter_list|(
name|so
parameter_list|)
value|((struct ngpcb *)(so)->so_pcb)
end_define

begin_comment
comment|/* If getting unexplained errors returned, set this to "Debugger("X"); */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRAP_ERROR
end_ifndef

begin_define
define|#
directive|define
name|TRAP_ERROR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************************************** 	Control sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|suser
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_cntl
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
name|control
operator|&&
operator|(
name|error
operator|=
name|ng_internalize
argument_list|(
name|control
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|#
directive|else
comment|/* NOTYET */
if|if
condition|(
name|control
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
endif|#
directive|endif
comment|/* NOTYET */
comment|/* Require destination as there may be>= 1 hooks on this node */
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Allocate an expendable buffer for the path, chop off 	 * the sockaddr header, and make sure it's NUL terminated */
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|-
literal|2
expr_stmt|;
name|MALLOC
argument_list|(
name|path
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH_PATH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Move the actual message out of mbufs into a linear buffer. 	 * Start by adding up the size of the data. (could use mh_len?) */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
name|NULL
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
comment|/* Move the data into a linear buffer as well. Messages are not 	 * delivered in mbufs. */
name|MALLOC
argument_list|(
name|msg
argument_list|,
expr|struct
name|ng_mesg
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE_MESSAGES
do|do
block|{
name|item_p
name|item
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|=
name|ng_package_msg
argument_list|(
name|msg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|msg
operator|)
operator|=
name|NULL
expr_stmt|;
operator|(
name|error
operator|)
operator|=
name|ENOMEM
expr_stmt|;
name|printf
argument_list|(
literal|"err=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|error
operator|)
operator|=
name|ng_address_path
argument_list|(
operator|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|)
argument_list|,
operator|(
name|item
operator|)
argument_list|,
operator|(
name|path
operator|)
argument_list|,
operator|(
name|NULL
operator|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"[%x]:<---------[socket]: c=<%d>cmd=%x(%s) f=%x #%d (%s)\n"
argument_list|,
name|item
operator|->
name|el_dest
operator|->
name|nd_ID
argument_list|,
name|msg
operator|->
name|header
operator|.
name|typecookie
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|flags
argument_list|,
name|msg
operator|->
name|header
operator|.
name|token
argument_list|,
name|item
operator|->
name|el_dest
operator|->
name|nd_type
operator|->
name|name
argument_list|)
expr_stmt|;
name|SAVE_LINE
argument_list|(
name|item
argument_list|)
expr_stmt|;
operator|(
name|error
operator|)
operator|=
name|ng_snd_item
argument_list|(
operator|(
name|item
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"errx=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
operator|(
name|msg
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
else|#
directive|else
comment|/* The callee will free the msg when done. The path is our business. */
name|NG_SEND_MSG_PATH
argument_list|(
name|error
argument_list|,
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|,
name|msg
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|release
label|:
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|path
argument_list|,
name|M_NETGRAPH_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_bind
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|printf
argument_list|(
literal|" program tried to connect control socket to remote node\n "
argument_list|)
expr_stmt|;
comment|/* 	 * At this time refuse to do this.. it used to 	 * do something but it was undocumented and not used. 	 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************** 	Data sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngd_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_data
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|char
name|hookname
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|control
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 	 * If the user used any of these ways to not specify an address 	 * then handle specially. 	 */
if|if
condition|(
operator|(
name|sap
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|)
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|*
name|sap
operator|->
name|sg_data
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * if exactly one hook exists, just use it. 		 * Special case to allow write(2) to work on an ng_socket. 		 */
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|nd_hooks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
name|NG_HOOKLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * chop off the sockaddr header, and make sure it's NUL 		 * terminated 		 */
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|hookname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hookname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the correct hook from 'hookname' */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&pcbp->sockdata->node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hookname
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
block|}
block|}
comment|/* Send data (OK if hook is NULL) */
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* makes m NULL */
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_connect_data
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used for both data and control sockets  */
end_comment

begin_function
specifier|static
name|int
name|ng_setsockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|sg
decl_stmt|;
name|int
name|sg_len
decl_stmt|,
name|namelen
decl_stmt|,
name|s
decl_stmt|;
comment|/* Why isn't sg_data a `char[1]' ? :-( */
name|sg_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ng
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|sg
operator|->
name|sg_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|namelen
operator|=
literal|0
expr_stmt|;
comment|/* silence compiler ! */
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
condition|)
name|sg_len
operator|+=
name|namelen
operator|=
name|strlen
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sg
argument_list|,
expr|struct
name|sockaddr_ng
operator|*
argument_list|,
name|sg_len
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
condition|)
name|bcopy
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
argument_list|,
name|sg
operator|->
name|sg_data
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_len
operator|=
name|sg_len
expr_stmt|;
name|sg
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a socket to it's protocol specific partner.  * For a control socket, actually create a netgraph node and attach  * to it as well.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|privdata
decl_stmt|;
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Setup protocol control block */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_CONTROL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Allocate node private info */
name|MALLOC
argument_list|(
name|privdata
argument_list|,
expr|struct
name|ngsock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|privdata
operator|==
name|NULL
condition|)
block|{
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Make the generic node components */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|privdata
operator|->
name|node
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|)
expr_stmt|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|privdata
operator|->
name|node
argument_list|,
name|privdata
argument_list|)
expr_stmt|;
comment|/* Link the pcb and the node private data */
name|privdata
operator|->
name|ctlsock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|privdata
expr_stmt|;
name|privdata
operator|->
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up a socket protocol control block.  * This code is shared between control and data sockets.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Standard socket setup stuff */
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|ngpdg_sendspace
argument_list|,
name|ngpdg_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate the pcb */
name|MALLOC
argument_list|(
name|pcbp
argument_list|,
expr|struct
name|ngpcb
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pcbp
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pcbp
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Link the pcb and the socket */
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|ng_socket
operator|=
name|so
expr_stmt|;
comment|/* Add the socket to linked list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ngsocklist
argument_list|,
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disassociate the socket from it's protocol specific  * partner. If it's attached to a node's private data structure,  * then unlink from that too. If we were the last socket attached to it,  * then shut down the entire node. Shared code for control and data sockets.  */
end_comment

begin_function
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|pcbp
operator|->
name|sockdata
condition|)
block|{
name|priv
operator|=
name|pcbp
operator|->
name|sockdata
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|NG_CONTROL
case|:
name|priv
operator|->
name|ctlsock
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NG_DATA
case|:
name|priv
operator|->
name|datasock
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|--
name|priv
operator|->
name|refs
operator|==
literal|0
operator|)
operator|&&
operator|(
name|priv
operator|->
name|node
operator|!=
name|NULL
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|pcbp
operator|->
name|ng_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|pcbp
operator|->
name|ng_socket
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcbp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_comment
comment|/*  * File descriptors can be passed into a AF_NETGRAPH socket.  * Note, that file descriptors cannot be passed OUT.  * Only character device descriptors are accepted.  * Character devices are useful to connect a graph to a device,  * which after all is the purpose of this whole system.  */
end_comment

begin_function
specifier|static
name|int
name|ng_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|int
name|oldfds
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_type
operator|!=
name|SCM_RIGHTS
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|!=
name|control
operator|->
name|m_len
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check there is only one FD. XXX what would more than one signify? */
name|oldfds
operator|=
operator|(
name|cm
operator|->
name|cmsg_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldfds
operator|!=
literal|1
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check that the FD given is legit. and change it to a pointer to a 	 * struct file. */
name|fd
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|cm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* Depending on what kind of resource it is, act differently. For 	 * devices, we treat it as a file. For a AF_NETGRAPH socket, 	 * shortcut straight to the node. */
switch|switch
condition|(
name|fp
operator|->
name|f_type
condition|)
block|{
case|case
name|DTYPE_VNODE
case|:
name|vn
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vn
operator|&&
operator|(
name|vn
operator|->
name|v_type
operator|==
name|VCHR
operator|)
condition|)
block|{
comment|/* for a VCHR, actually reference the FILE */
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
comment|/* XXX then what :) */
comment|/* how to pass on to other modules? */
block|}
else|else
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_comment
comment|/*  * Connect the data socket to a named control socket node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|sockaddr_ng
modifier|*
name|sap
decl_stmt|;
name|node_p
name|farnode
decl_stmt|;
name|struct
name|ngsock
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|item_p
name|item
decl_stmt|;
comment|/* If we are already connected, don't do it again */
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Find the target (victim) and check it doesn't already have a data 	 * socket. Also check it is a 'socket' type node. 	 * Use ng_package_data() and address_path() to do this. 	 */
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
expr_stmt|;
comment|/* The item will hold the node reference */
name|item
operator|=
name|ng_package_data
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ng_address_path
argument_list|(
name|NULL
argument_list|,
name|item
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* item is freed on failure */
comment|/* 	 * Extract node from item and free item. Remember we now have 	 * a reference on the node. The item holds it for us. 	 * when we free the item we release the reference. 	 */
name|farnode
operator|=
name|item
operator|->
name|el_dest
expr_stmt|;
comment|/* shortcut */
if|if
condition|(
name|strcmp
argument_list|(
name|farnode
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_SOCKET_NODE_TYPE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|farnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|datasock
operator|!=
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
comment|/* 	 * Link the PCB and the private data struct. and note the extra 	 * reference. Drop the extra reference on the node. 	 */
name|priv
operator|->
name|datasock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|refs
operator|++
expr_stmt|;
comment|/* XXX possible race if it's being freed */
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Binding a socket means giving the corresponding node a name  */
end_comment

begin_function
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|pcbp
operator|->
name|sockdata
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
decl_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sap
operator|->
name|sg_len
operator|<
literal|4
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_len
operator|>
operator|(
name|NG_NODELEN
operator|+
literal|3
operator|)
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_data
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_data
index|[
name|sap
operator|->
name|sg_len
operator|-
literal|3
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ng_name_node
argument_list|(
name|priv
operator|->
name|node
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a message and pass it up to the control socket associated  * with the node.  */
end_comment

begin_function
specifier|static
name|int
name|ship_msg
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_ng
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|socket
modifier|*
specifier|const
name|so
init|=
name|pcbp
operator|->
name|ng_socket
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|;
name|int
name|msglen
decl_stmt|;
comment|/* Copy the message itself into an mbuf chain */
name|msglen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|msg
operator|->
name|header
operator|.
name|arglen
expr_stmt|;
name|mdata
operator|=
name|m_devget
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Here we free the message, as we are the end of the line. 	 * We need to do that regardless of whether we got mbufs. */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdata
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Send it up to the socket */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|mdata
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
name|m_freem
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * You can only create new nodes from the socket end of things.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_constructor
parameter_list|(
name|node_p
name|nodep
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We allow any hook to be connected to the node.  * There is no per-hook private information though.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * if only one hook, allow read(2) and write(2) to work.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ngsock
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|datasock
operator|)
operator|&&
operator|(
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|1
condition|)
block|{
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incoming messages get passed up to the control socket.  * Unless they are for us specifically (socket_type)  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|priv
operator|->
name|ctlsock
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|ng_ID_t
name|retaddr
init|=
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|char
name|retabuf
index|[
literal|32
index|]
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* we have all we need */
comment|/* Only allow mesgs to be passed if we have the control socket. 	 * Data sockets can only support the generic messages. */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|TRACE_MESSAGES
name|printf
argument_list|(
literal|"[%x]:---------->[socket]: c=<%d>cmd=%x(%s) f=%x #%d\n"
argument_list|,
name|retaddr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|typecookie
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|flags
argument_list|,
name|msg
operator|->
name|header
operator|.
name|token
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_SOCKET_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SOCK_CMD_NOLINGER
case|:
name|priv
operator|->
name|flags
operator||=
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
case|case
name|NGM_SOCK_CMD_LINGER
case|:
name|priv
operator|->
name|flags
operator|&=
operator|~
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
block|}
comment|/* Free the message and return */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get the return address into a sockaddr */
name|sprintf
argument_list|(
name|retabuf
argument_list|,
literal|"[%x]:"
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|strlen
argument_list|(
name|retabuf
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|addr
argument_list|,
expr|struct
name|sockaddr_ng
operator|*
argument_list|,
name|addrlen
operator|+
literal|4
argument_list|,
name|M_NETGRAPH_PATH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|addr
operator|->
name|sg_len
operator|=
name|addrlen
operator|+
literal|3
expr_stmt|;
name|addr
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|bcopy
argument_list|(
name|retabuf
argument_list|,
name|addr
operator|->
name|sg_data
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sg_data
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Send it up */
name|error
operator|=
name|ship_msg
argument_list|(
name|pcbp
argument_list|,
name|msg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|addr
argument_list|,
name|M_NETGRAPH_PATH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|priv
operator|->
name|datasock
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|addrbuf
index|[
name|NG_HOOKLEN
operator|+
literal|1
operator|+
literal|4
index|]
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* If there is no data socket, black-hole it */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|so
operator|=
name|pcbp
operator|->
name|ng_socket
expr_stmt|;
comment|/* Get the return address into a sockaddr. */
name|addrlen
operator|=
name|strlen
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
comment|/*<= NG_HOOKLEN */
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addrbuf
expr_stmt|;
name|addr
operator|->
name|sg_len
operator|=
name|addrlen
operator|+
literal|3
expr_stmt|;
name|addr
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|bcopy
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|addr
operator|->
name|sg_data
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sg_data
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try to tell the socket which hook it came in on */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * For this type, removal of the last link destroys the node  * if the NOLINGER flag is set.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|datasock
operator|)
operator|&&
operator|(
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|1
condition|)
block|{
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|priv
operator|->
name|flags
operator|&
name|NGS_FLAG_NOLINGER
operator|)
operator|&&
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing.  * In this case, that involves making sure the socket  * knows we should be shutting down.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|dpcbp
init|=
name|priv
operator|->
name|datasock
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|priv
operator|->
name|ctlsock
decl_stmt|;
if|if
condition|(
name|dpcbp
operator|!=
name|NULL
condition|)
block|{
name|soisdisconnected
argument_list|(
name|dpcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
name|dpcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|datasock
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|refs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
block|{
name|soisdisconnected
argument_list|(
name|pcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|ctlsock
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|refs
operator|--
expr_stmt|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dummy_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Control and data socket type descriptors  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngc_usrreqs
init|=
block|{
name|NULL
block|,
comment|/* abort */
name|pru_accept_notsupp
block|,
name|ngc_attach
block|,
name|ngc_bind
block|,
name|ngc_connect
block|,
name|pru_connect2_notsupp
block|,
name|pru_control_notsupp
block|,
name|ngc_detach
block|,
name|dummy_disconnect
block|,
comment|/* disconnect */
name|pru_listen_notsupp
block|,
name|NULL
block|,
comment|/* setpeeraddr */
name|pru_rcvd_notsupp
block|,
name|pru_rcvoob_notsupp
block|,
name|ngc_send
block|,
name|pru_sense_null
block|,
name|NULL
block|,
comment|/* shutdown */
name|ng_setsockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngd_usrreqs
init|=
block|{
name|NULL
block|,
comment|/* abort */
name|pru_accept_notsupp
block|,
name|ngd_attach
block|,
name|NULL
block|,
comment|/* bind */
name|ngd_connect
block|,
name|pru_connect2_notsupp
block|,
name|pru_control_notsupp
block|,
name|ngd_detach
block|,
name|dummy_disconnect
block|,
comment|/* disconnect */
name|pru_listen_notsupp
block|,
name|NULL
block|,
comment|/* setpeeraddr */
name|pru_rcvd_notsupp
block|,
name|pru_rcvoob_notsupp
block|,
name|ngd_send
block|,
name|pru_sense_null
block|,
name|NULL
block|,
comment|/* shutdown */
name|ng_setsockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of protocols supported in the NETGRAPH domain.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|ngdomain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop compiler warnings */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ngsw
index|[]
init|=
block|{
block|{
name|SOCK_DGRAM
block|,
comment|/* protocol type */
operator|&
name|ngdomain
block|,
comment|/* backpointer to domain */
name|NG_CONTROL
block|,
name|PR_ATOMIC
operator||
name|PR_ADDR
comment|/* | PR_RIGHTS */
block|,
comment|/* flags */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* input, output, ctlinput, ctloutput */
name|NULL
block|,
comment|/* ousrreq */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* init, fasttimeo, slowtimo, drain */
operator|&
name|ngc_usrreqs
block|,
comment|/* usrreq table (above) */
comment|/*{NULL}*/
comment|/* pffh (protocol filter head?) */
block|}
block|,
block|{
name|SOCK_DGRAM
block|,
comment|/* protocol type */
operator|&
name|ngdomain
block|,
comment|/* backpointer to domain */
name|NG_DATA
block|,
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
comment|/* flags */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* input, output, ctlinput, ctloutput */
name|NULL
block|,
comment|/* ousrreq() */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* init, fasttimeo, slowtimo, drain */
operator|&
name|ngd_usrreqs
block|,
comment|/* usrreq table (above) */
comment|/*{NULL}*/
comment|/* pffh (protocol filter head?) */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain
name|ngdomain
init|=
block|{
name|AF_NETGRAPH
block|,
literal|"netgraph"
block|,
name|NULL
block|,
comment|/* init() */
name|NULL
block|,
comment|/* externalise() */
name|NULL
block|,
comment|/* dispose() */
name|ngsw
block|,
comment|/* protosw entry */
operator|&
name|ngsw
index|[
sizeof|sizeof
argument_list|(
name|ngsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ngsw
index|[
literal|0
index|]
argument_list|)
index|]
block|,
comment|/* Number of protosw entries */
name|NULL
block|,
comment|/* next domain in list */
name|NULL
block|,
comment|/* rtattach() */
literal|0
block|,
comment|/* arg to rtattach in bits */
literal|0
comment|/* maxrtkey */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle loading and unloading for this node type  * This is to handle auxiliary linkages (e.g protocol domain addition).  */
end_comment

begin_function
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register protocol domain */
name|net_add_domain
argument_list|(
operator|&
name|ngdomain
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Insure there are no open netgraph sockets */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|ngsocklist
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
operator|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ngsocklist
argument_list|)
operator|)
operator|&&
operator|(
name|typestruct
operator|.
name|refs
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Unregister protocol domain XXX can't do this yet.. */
if|if
condition|(
operator|(
name|error
operator|=
name|net_rm_domain
argument_list|(
operator|&
name|ngdomain
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|AF_NETGRAPH
argument_list|,
name|graph
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"netgraph Family"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|family
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|AF_NETGRAPH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|data
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_data
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_DATA
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|control
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"CONTROL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_control
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_CONTROL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

