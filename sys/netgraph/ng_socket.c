begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_socket.c  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *  * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *  * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_socket.c,v 1.28 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * Netgraph socket nodes  *  * There are two types of netgraph sockets, control and data.  * Control sockets have a netgraph node, but data sockets are  * parasitic on control sockets, and have no node of their own.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PATH
argument_list|,
literal|"netgraph_path"
argument_list|,
literal|"netgraph path info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_SOCK
argument_list|,
literal|"netgraph_sock"
argument_list|,
literal|"netgraph socket info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PATH
value|M_NETGRAPH
end_define

begin_define
define|#
directive|define
name|M_NETGRAPH_SOCK
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * It's Ascii-art time!  *   +-------------+   +-------------+  *   |socket  (ctl)|   |socket (data)|  *   +-------------+   +-------------+  *          ^                 ^  *          |                 |  *          v                 v  *    +-----------+     +-----------+  *    |pcb   (ctl)|     |pcb  (data)|  *    +-----------+     +-----------+  *          ^                 ^  *          |                 |  *          v                 v  *      +--------------------------+  *      |   Socket type private    |  *      |       data               |  *      +--------------------------+  *                   ^  *                   |  *                   v  *           +----------------+  *           | struct ng_node |  *           +----------------+  */
end_comment

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ngs_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ngs_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ngs_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ngs_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ngs_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_findhook_t
name|ngs_findhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ngs_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ngs_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal methods */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_socket_free_priv
parameter_list|(
name|struct
name|ngsock
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_socket_item_applied
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_SOCKET_NODE_TYPE
block|,
operator|.
name|mod_event
operator|=
name|ngs_mod_event
block|,
operator|.
name|constructor
operator|=
name|ngs_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ngs_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ngs_shutdown
block|,
operator|.
name|newhook
operator|=
name|ngs_newhook
block|,
operator|.
name|connect
operator|=
name|ngs_connect
block|,
operator|.
name|findhook
operator|=
name|ngs_findhook
block|,
operator|.
name|rcvdata
operator|=
name|ngs_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ngs_disconnect
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT_ORDERED
argument_list|(
name|socket
argument_list|,
operator|&
name|typestruct
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Buffer space */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_sendspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ngpdg_sendspace
argument_list|,
literal|0
argument_list|,
literal|"Maximum outgoing Netgraph datagram size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_recvspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ngpdg_recvspace
argument_list|,
literal|0
argument_list|,
literal|"Maximum space for incoming Netgraph datagrams"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* List of all sockets (for netstat -f netgraph) */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ngpcb
argument_list|)
name|ngsocklist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ngsocketlist_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|sotongpcb
parameter_list|(
name|so
parameter_list|)
value|((struct ngpcb *)(so)->so_pcb)
end_define

begin_comment
comment|/* If getting unexplained errors returned, set this to "kdb_enter("X"); */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRAP_ERROR
end_ifndef

begin_define
define|#
directive|define
name|TRAP_ERROR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|hookpriv
block|{
name|LIST_ENTRY
argument_list|(
argument|hookpriv
argument_list|)
name|next
expr_stmt|;
name|hook_p
name|hook
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|ngshash
argument_list|,
name|hookpriv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Per-node private data */
end_comment

begin_struct
struct|struct
name|ngsock
block|{
name|struct
name|ng_node
modifier|*
name|node
decl_stmt|;
comment|/* the associated netgraph node */
name|struct
name|ngpcb
modifier|*
name|datasock
decl_stmt|;
comment|/* optional data socket */
name|struct
name|ngpcb
modifier|*
name|ctlsock
decl_stmt|;
comment|/* optional control socket */
name|struct
name|ngshash
modifier|*
name|hash
decl_stmt|;
comment|/* hash for hook names */
name|u_long
name|hmask
decl_stmt|;
comment|/* hash mask */
name|int
name|flags
decl_stmt|;
name|int
name|refs
decl_stmt|;
name|struct
name|mtx
name|mtx
decl_stmt|;
comment|/* mtx to wait on */
name|int
name|error
decl_stmt|;
comment|/* place to store error */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NGS_FLAG_NOLINGER
value|1
end_define

begin_comment
comment|/* close with last hook */
end_comment

begin_comment
comment|/*************************************************************** 	Control sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETGRAPH_CONTROL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_cntl
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ngc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|pcbp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ngc_detach: pcbp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|item_p
name|item
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_apply_info
name|apply
decl_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Require destination as there may be>= 1 hooks on this node. */
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 	 * Allocate an expendable buffer for the path, chop off 	 * the sockaddr header, and make sure it's NUL terminated. 	 */
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|-
literal|2
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH_PATH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Move the actual message out of mbufs into a linear buffer. 	 * Start by adding up the size of the data. (could use mh_len?) 	 */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
name|NULL
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
comment|/* 	 * Move the data into a linear buffer as well. 	 * Messages are not delivered in mbufs. 	 */
name|msg
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|version
operator|!=
name|NG_VERSION
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH_MSG
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 	 * Hack alert! 	 * We look into the message and if it mkpeers a node of unknown type, we 	 * try to load it. We need to do this now, in syscall thread, because if 	 * message gets queued and applied later we will get panic. 	 */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_GENERIC_COOKIE
operator|&&
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_MKPEER
condition|)
block|{
name|struct
name|ngm_mkpeer
modifier|*
specifier|const
name|mkp
init|=
operator|(
expr|struct
name|ngm_mkpeer
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
if|if
condition|(
name|ng_findtype
argument_list|(
name|mkp
operator|->
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|char
name|filename
index|[
name|NG_TYPESIZ
operator|+
literal|3
index|]
decl_stmt|;
name|int
name|fileid
decl_stmt|;
comment|/* Not found, try to load it as a loadable module. */
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"ng_%s"
argument_list|,
name|mkp
operator|->
name|type
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_kldload
argument_list|(
name|curthread
argument_list|,
name|filename
argument_list|,
operator|&
name|fileid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH_MSG
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* See if type has been loaded successfully. */
if|if
condition|(
name|ng_findtype
argument_list|(
name|mkp
operator|->
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH_MSG
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|kern_kldunload
argument_list|(
name|curthread
argument_list|,
name|fileid
argument_list|,
name|LINKER_UNLOAD_NORMAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
block|}
name|item
operator|=
name|ng_package_msg
argument_list|(
name|msg
argument_list|,
name|NG_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_address_path
argument_list|(
operator|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|)
argument_list|,
name|item
argument_list|,
name|path
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|TRACE_MESSAGES
name|printf
argument_list|(
literal|"ng_address_path: errx=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|release
goto|;
block|}
ifdef|#
directive|ifdef
name|TRACE_MESSAGES
name|printf
argument_list|(
literal|"[%x]:<---------[socket]: c=<%d>cmd=%x(%s) f=%x #%d (%s)\n"
argument_list|,
name|item
operator|->
name|el_dest
operator|->
name|nd_ID
argument_list|,
name|msg
operator|->
name|header
operator|.
name|typecookie
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|flags
argument_list|,
name|msg
operator|->
name|header
operator|.
name|token
argument_list|,
name|item
operator|->
name|el_dest
operator|->
name|nd_type
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SAVE_LINE
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* 	 * We do not want to return from syscall until the item 	 * is processed by destination node. We register callback 	 * on the item, which will update priv->error when item 	 * was applied. 	 * If ng_snd_item() has queued item, we sleep until 	 * callback wakes us up. 	 */
name|bzero
argument_list|(
operator|&
name|apply
argument_list|,
sizeof|sizeof
argument_list|(
name|apply
argument_list|)
argument_list|)
expr_stmt|;
name|apply
operator|.
name|apply
operator|=
name|ng_socket_item_applied
expr_stmt|;
name|apply
operator|.
name|context
operator|=
name|priv
expr_stmt|;
name|item
operator|->
name|apply
operator|=
operator|&
name|apply
expr_stmt|;
name|priv
operator|->
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|error
operator|=
name|ng_snd_item
argument_list|(
name|item
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|error
operator|==
operator|-
literal|1
condition|)
name|msleep
argument_list|(
name|priv
argument_list|,
operator|&
name|priv
operator|->
name|mtx
argument_list|,
literal|0
argument_list|,
literal|"ngsock"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|priv
operator|->
name|error
operator|!=
operator|-
literal|1
argument_list|,
operator|(
literal|"ng_socket: priv->error wasn't updated"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|priv
operator|->
name|error
expr_stmt|;
name|release
label|:
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|path
argument_list|,
name|M_NETGRAPH_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_bind
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * At this time refuse to do this.. it used to 	 * do something but it was undocumented and not used. 	 */
name|printf
argument_list|(
literal|"program tried to connect control socket to remote node\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************** 	Data sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngd_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_data
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ngd_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|KASSERT
argument_list|(
name|pcbp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ngd_detach: pcbp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_DATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|char
name|hookname
index|[
name|NG_HOOKSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|control
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|sap
operator|==
name|NULL
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Make compiler happy. */
else|else
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|-
literal|2
expr_stmt|;
comment|/* 	 * If the user used any of these ways to not specify an address 	 * then handle specially. 	 */
if|if
condition|(
operator|(
name|sap
operator|==
name|NULL
operator|)
operator|||
operator|(
name|len
operator|<=
literal|0
operator|)
operator|||
operator|(
operator|*
name|sap
operator|->
name|sg_data
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * If exactly one hook exists, just use it. 		 * Special case to allow write(2) to work on an ng_socket. 		 */
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|nd_hooks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>=
name|NG_HOOKSIZ
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * chop off the sockaddr header, and make sure it's NUL 		 * terminated 		 */
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|hookname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hookname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the correct hook from 'hookname' */
name|hook
operator|=
name|ng_findhook
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|,
name|hookname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
comment|/* Send data. */
name|NG_SEND_DATA_FLAGS
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|,
name|NG_WAITOK
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_connect_data
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used for both data and control sockets  */
end_comment

begin_function
specifier|static
name|int
name|ng_getsockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|sg
decl_stmt|;
name|int
name|sg_len
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
operator|)
condition|)
comment|/* XXXGL: can this still happen? */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sg_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ng
argument_list|)
operator|+
name|NG_NODESIZ
operator|-
sizeof|sizeof
argument_list|(
name|sg
operator|->
name|sg_data
argument_list|)
expr_stmt|;
name|sg
operator|=
name|malloc
argument_list|(
name|sg_len
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|!=
name|NULL
condition|)
block|{
name|node_p
name|node
init|=
name|pcbp
operator|->
name|sockdata
operator|->
name|node
decl_stmt|;
if|if
condition|(
name|NG_NODE_HAS_NAME
argument_list|(
name|node
argument_list|)
condition|)
name|bcopy
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|,
name|sg
operator|->
name|sg_data
argument_list|,
name|strlen
argument_list|(
name|NG_NODE_NAME
argument_list|(
name|node
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_len
operator|=
name|sg_len
expr_stmt|;
name|sg
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sg
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a socket to it's protocol specific partner.  * For a control socket, actually create a netgraph node and attach  * to it as well.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|priv
decl_stmt|;
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Setup protocol control block */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_CONTROL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Make the generic node components */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|node
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Allocate node private info and hash. We start 	 * with 16 hash entries, however we may grow later 	 * in ngs_newhook(). We can't predict how much hooks 	 * does this node plan to have. 	 */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hash
operator|=
name|hashinit
argument_list|(
literal|16
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
operator|&
name|priv
operator|->
name|hmask
argument_list|)
expr_stmt|;
comment|/* Initialize mutex. */
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|,
literal|"ng_socket"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Link the pcb the private data. */
name|priv
operator|->
name|ctlsock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|refs
operator|++
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|pcbp
operator|->
name|node_id
operator|=
name|node
operator|->
name|nd_ID
expr_stmt|;
comment|/* hint for netstat(1) */
comment|/* Link the node and the private data. */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|priv
operator|->
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|priv
operator|->
name|node
argument_list|)
expr_stmt|;
name|priv
operator|->
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up a socket protocol control block.  * This code is shared between control and data sockets.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Standard socket setup stuff. */
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|ngpdg_sendspace
argument_list|,
name|ngpdg_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate the pcb. */
name|pcbp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ngpcb
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pcbp
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Link the pcb and the socket. */
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|ng_socket
operator|=
name|so
expr_stmt|;
comment|/* Add the socket to linked list */
name|mtx_lock
argument_list|(
operator|&
name|ngsocketlist_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ngsocklist
argument_list|,
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ngsocketlist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disassociate the socket from it's protocol specific  * partner. If it's attached to a node's private data structure,  * then unlink from that too. If we were the last socket attached to it,  * then shut down the entire node. Shared code for control and data sockets.  */
end_comment

begin_function
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|priv
init|=
name|pcbp
operator|->
name|sockdata
decl_stmt|;
if|if
condition|(
name|priv
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|NG_CONTROL
case|:
name|priv
operator|->
name|ctlsock
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NG_DATA
case|:
name|priv
operator|->
name|datasock
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|pcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
name|pcbp
operator|->
name|node_id
operator|=
literal|0
expr_stmt|;
name|ng_socket_free_priv
argument_list|(
name|priv
argument_list|)
expr_stmt|;
block|}
name|pcbp
operator|->
name|ng_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ngsocketlist_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ngsocketlist_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcbp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a reference from node private data.  */
end_comment

begin_function
specifier|static
name|void
name|ng_socket_free_priv
parameter_list|(
name|struct
name|ngsock
modifier|*
name|priv
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|priv
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|refs
operator|==
literal|0
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|priv
operator|->
name|hash
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
name|priv
operator|->
name|hmask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|priv
operator|->
name|refs
operator|==
literal|1
operator|)
operator|&&
operator|(
name|priv
operator|->
name|node
operator|!=
name|NULL
operator|)
condition|)
block|{
name|node_p
name|node
init|=
name|priv
operator|->
name|node
decl_stmt|;
name|priv
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Connect the data socket to a named control socket node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|sockaddr_ng
modifier|*
name|sap
decl_stmt|;
name|node_p
name|farnode
decl_stmt|;
name|struct
name|ngsock
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|item_p
name|item
decl_stmt|;
comment|/* If we are already connected, don't do it again. */
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* 	 * Find the target (victim) and check it doesn't already have 	 * a data socket. Also check it is a 'socket' type node. 	 * Use ng_package_data() and ng_address_path() to do this. 	 */
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
expr_stmt|;
comment|/* The item will hold the node reference. */
name|item
operator|=
name|ng_package_data
argument_list|(
name|NULL
argument_list|,
name|NG_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_address_path
argument_list|(
name|NULL
argument_list|,
name|item
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* item is freed on failure */
comment|/* 	 * Extract node from item and free item. Remember we now have 	 * a reference on the node. The item holds it for us. 	 * when we free the item we release the reference. 	 */
name|farnode
operator|=
name|item
operator|->
name|el_dest
expr_stmt|;
comment|/* shortcut */
if|if
condition|(
name|strcmp
argument_list|(
name|farnode
operator|->
name|nd_type
operator|->
name|name
argument_list|,
name|NG_SOCKET_NODE_TYPE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|farnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|datasock
operator|!=
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
comment|/* 	 * Link the PCB and the private data struct. and note the extra 	 * reference. Drop the extra reference on the node. 	 */
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|priv
operator|->
name|datasock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|priv
expr_stmt|;
name|pcbp
operator|->
name|node_id
operator|=
name|priv
operator|->
name|node
operator|->
name|nd_ID
expr_stmt|;
comment|/* hint for netstat(1) */
name|priv
operator|->
name|refs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* drop the reference to the node */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Binding a socket means giving the corresponding node a name  */
end_comment

begin_function
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|pcbp
operator|->
name|sockdata
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
decl_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sap
operator|->
name|sg_len
operator|<
literal|4
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_len
operator|>
operator|(
name|NG_NODESIZ
operator|+
literal|2
operator|)
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_data
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|sap
operator|->
name|sg_data
index|[
name|sap
operator|->
name|sg_len
operator|-
literal|3
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ng_name_node
argument_list|(
name|priv
operator|->
name|node
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************** 	Netgraph node ***************************************************************/
end_comment

begin_comment
comment|/*  * You can only create new nodes from the socket end of things.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_constructor
parameter_list|(
name|node_p
name|nodep
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ngs_rehash
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngshash
modifier|*
name|new
decl_stmt|;
name|struct
name|hookpriv
modifier|*
name|hp
decl_stmt|;
name|hook_p
name|hook
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|u_long
name|hmask
decl_stmt|;
name|new
operator|=
name|hashinit_flags
argument_list|(
operator|(
name|priv
operator|->
name|hmask
operator|+
literal|1
operator|)
operator|*
literal|2
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
operator|&
name|hmask
argument_list|,
name|HASH_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&node->nd_hooks
argument_list|,
argument|hk_hooks
argument_list|)
block|{
name|hp
operator|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|LIST_REMOVE
argument_list|(
name|hp
argument_list|,
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h
operator|=
name|hash32_str
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|HASHINIT
argument_list|)
operator|&
name|hmask
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new
index|[
name|h
index|]
argument_list|,
name|hp
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|hashdestroy
argument_list|(
name|priv
operator|->
name|hash
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
name|priv
operator|->
name|hmask
argument_list|)
expr_stmt|;
name|priv
operator|->
name|hash
operator|=
name|new
expr_stmt|;
name|priv
operator|->
name|hmask
operator|=
name|hmask
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We allow any hook to be connected to the node.  * There is no per-hook private information though.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|hookpriv
modifier|*
name|hp
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
name|hp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hp
argument_list|)
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|node
operator|->
name|nd_numhooks
operator|*
literal|2
operator|>
name|priv
operator|->
name|hmask
condition|)
name|ngs_rehash
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|hp
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|h
operator|=
name|hash32_str
argument_list|(
name|name
argument_list|,
name|HASHINIT
argument_list|)
operator|&
name|priv
operator|->
name|hmask
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|hash
index|[
name|h
index|]
argument_list|,
name|hp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|hp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If only one hook, allow read(2) and write(2) to work.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ngsock
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|datasock
operator|)
operator|&&
operator|(
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|1
condition|)
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
else|else
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look up hook by name */
end_comment

begin_function
specifier|static
name|hook_p
name|ngs_findhook
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|hookpriv
modifier|*
name|hp
decl_stmt|;
name|uint32_t
name|h
decl_stmt|;
comment|/* 	 * Microoptimisation for an ng_socket with 	 * a single hook, which is a common case. 	 */
if|if
condition|(
name|node
operator|->
name|nd_numhooks
operator|==
literal|1
condition|)
block|{
name|hook_p
name|hook
decl_stmt|;
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|node
operator|->
name|nd_hooks
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|hook
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|h
operator|=
name|hash32_str
argument_list|(
name|name
argument_list|,
name|HASHINIT
argument_list|)
operator|&
name|priv
operator|->
name|hmask
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|hp
argument_list|,
argument|&priv->hash[h]
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hp
operator|->
name|hook
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|hp
operator|->
name|hook
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incoming messages get passed up to the control socket.  * Unless they are for us specifically (socket_type)  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_ng
name|addr
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ng_ID_t
name|retaddr
init|=
name|NGI_RETADDR
argument_list|(
name|item
argument_list|)
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* 	 * Grab priv->mtx here to prevent destroying of control socket 	 * after checking that priv->ctlsock is not NULL. 	 */
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|pcbp
operator|=
name|priv
operator|->
name|ctlsock
expr_stmt|;
comment|/* 	 * Only allow mesgs to be passed if we have the control socket. 	 * Data sockets can only support the generic messages. 	 */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|so
operator|=
name|pcbp
operator|->
name|ng_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* As long as the race is handled, priv->mtx may be unlocked now. */
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE_MESSAGES
name|printf
argument_list|(
literal|"[%x]:---------->[socket]: c=<%d>cmd=%x(%s) f=%x #%d\n"
argument_list|,
name|retaddr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|typecookie
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmd
argument_list|,
name|msg
operator|->
name|header
operator|.
name|cmdstr
argument_list|,
name|msg
operator|->
name|header
operator|.
name|flags
argument_list|,
name|msg
operator|->
name|header
operator|.
name|token
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_SOCKET_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SOCK_CMD_NOLINGER
case|:
name|priv
operator|->
name|flags
operator||=
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
case|case
name|NGM_SOCK_CMD_LINGER
case|:
name|priv
operator|->
name|flags
operator|&=
operator|~
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Free the message and return. */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get the return address into a sockaddr. */
name|bzero
argument_list|(
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sg_len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|.
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|addrlen
operator|=
name|snprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|addr
operator|.
name|sg_data
argument_list|,
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sg_data
argument_list|)
argument_list|,
literal|"[%x]:"
argument_list|,
name|retaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrlen
operator|<
literal|0
operator|||
name|addrlen
operator|>
sizeof|sizeof
argument_list|(
name|addr
operator|.
name|sg_data
argument_list|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: snprintf([%x]) failed - %d\n"
argument_list|,
name|__func__
argument_list|,
name|retaddr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Copy the message itself into an mbuf chain. */
name|m
operator|=
name|m_devget
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|msg
operator|->
name|header
operator|.
name|arglen
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Here we free the message. We need to do that 	 * regardless of whether we got mbufs. 	 */
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Send it up to the socket. */
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|addr
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|priv
operator|->
name|datasock
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|addrbuf
index|[
name|NG_HOOKSIZ
operator|+
literal|4
index|]
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* If there is no data socket, black-hole it. */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|so
operator|=
name|pcbp
operator|->
name|ng_socket
expr_stmt|;
comment|/* Get the return address into a sockaddr. */
name|addrlen
operator|=
name|strlen
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
comment|/*<= NG_HOOKSIZ - 1 */
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addrbuf
expr_stmt|;
name|addr
operator|->
name|sg_len
operator|=
name|addrlen
operator|+
literal|3
expr_stmt|;
name|addr
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|bcopy
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|,
name|addr
operator|->
name|sg_data
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sg_data
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Try to tell the socket which hook it came in on. */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * For this type, removal of the last link destroys the node  * if the NOLINGER flag is set.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|hookpriv
modifier|*
name|hp
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|hp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hp
argument_list|,
name|M_NETGRAPH_SOCK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|priv
operator|->
name|datasock
operator|)
operator|&&
operator|(
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|)
condition|)
block|{
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|1
condition|)
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
else|else
name|priv
operator|->
name|datasock
operator|->
name|ng_socket
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|priv
operator|->
name|flags
operator|&
name|NGS_FLAG_NOLINGER
operator|)
operator|&&
operator|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
operator|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing.  * In this case, that involves making sure the socket  * knows we should be shutting down.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngpcb
modifier|*
name|dpcbp
decl_stmt|,
modifier|*
name|pcbp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|dpcbp
operator|=
name|priv
operator|->
name|datasock
expr_stmt|;
name|pcbp
operator|=
name|priv
operator|->
name|ctlsock
expr_stmt|;
if|if
condition|(
name|dpcbp
operator|!=
name|NULL
condition|)
name|soisdisconnected
argument_list|(
name|dpcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
name|soisdisconnected
argument_list|(
name|pcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ng_socket_free_priv
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ng_socket_item_applied
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|priv
init|=
operator|(
expr|struct
name|ngsock
operator|*
operator|)
name|context
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|priv
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|wakeup
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dummy_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Control and data socket type descriptors  *  * XXXRW: Perhaps _close should do something?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngc_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|NULL
block|,
operator|.
name|pru_attach
operator|=
name|ngc_attach
block|,
operator|.
name|pru_bind
operator|=
name|ngc_bind
block|,
operator|.
name|pru_connect
operator|=
name|ngc_connect
block|,
operator|.
name|pru_detach
operator|=
name|ngc_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|dummy_disconnect
block|,
operator|.
name|pru_peeraddr
operator|=
name|NULL
block|,
operator|.
name|pru_send
operator|=
name|ngc_send
block|,
operator|.
name|pru_shutdown
operator|=
name|NULL
block|,
operator|.
name|pru_sockaddr
operator|=
name|ng_getsockaddr
block|,
operator|.
name|pru_close
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngd_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|NULL
block|,
operator|.
name|pru_attach
operator|=
name|ngd_attach
block|,
operator|.
name|pru_bind
operator|=
name|NULL
block|,
operator|.
name|pru_connect
operator|=
name|ngd_connect
block|,
operator|.
name|pru_detach
operator|=
name|ngd_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|dummy_disconnect
block|,
operator|.
name|pru_peeraddr
operator|=
name|NULL
block|,
operator|.
name|pru_send
operator|=
name|ngd_send
block|,
operator|.
name|pru_shutdown
operator|=
name|NULL
block|,
operator|.
name|pru_sockaddr
operator|=
name|ng_getsockaddr
block|,
operator|.
name|pru_close
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of protocols supported in the NETGRAPH domain.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|ngdomain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop compiler warnings */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ngsw
index|[]
init|=
block|{
block|{
operator|.
name|pr_type
operator|=
name|SOCK_DGRAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|ngdomain
block|,
operator|.
name|pr_protocol
operator|=
name|NG_CONTROL
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
comment|/* | PR_RIGHTS */
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|ngc_usrreqs
block|}
block|,
block|{
operator|.
name|pr_type
operator|=
name|SOCK_DGRAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|ngdomain
block|,
operator|.
name|pr_protocol
operator|=
name|NG_DATA
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|ngd_usrreqs
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain
name|ngdomain
init|=
block|{
operator|.
name|dom_family
operator|=
name|AF_NETGRAPH
block|,
operator|.
name|dom_name
operator|=
literal|"netgraph"
block|,
operator|.
name|dom_protosw
operator|=
name|ngsw
block|,
operator|.
name|dom_protoswNPROTOSW
operator|=
operator|&
name|ngsw
index|[
sizeof|sizeof
argument_list|(
name|ngsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ngsw
index|[
literal|0
index|]
argument_list|)
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle loading and unloading for this node type.  * This is to handle auxiliary linkages (e.g protocol domain addition).  */
end_comment

begin_function
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|ngsocketlist_mtx
argument_list|,
literal|"ng_socketlist"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Ensure there are no open netgraph sockets. */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|ngsocklist
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|NOTYET
comment|/* Unregister protocol domain XXX can't do this yet.. */
endif|#
directive|endif
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|VNET_DOMAIN_SET
argument_list|(
name|ng
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|family
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|AF_NETGRAPH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|data
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_data
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|NG_DATA
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|control
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"CONTROL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_control
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|NG_CONTROL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

