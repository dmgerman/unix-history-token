begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_socket.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_socket.c,v 1.28 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * Netgraph socket nodes  *  * There are two types of netgraph sockets, control and data.  * Control sockets have a netgraph node, but data sockets are  * parasitic on control sockets, and have no node of their own.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_socket.h>
end_include

begin_comment
comment|/*  * It's Ascii-art time!  *   +-------------+   +-------------+  *   |socket  (ctl)|   |socket (data)|  *   +-------------+   +-------------+  *          ^                 ^  *          |                 |  *          v                 v  *    +-----------+     +-----------+  *    |pcb   (ctl)|     |pcb  (data)|  *    +-----------+     +-----------+  *          ^                 ^  *          |                 |  *          v                 v  *      +--------------------------+  *      |   Socket type private    |  *      |       data               |  *      +--------------------------+  *                   ^  *                   |  *                   v  *           +----------------+  *           | struct ng_node |  *           +----------------+  */
end_comment

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ngs_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ngs_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ngs_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ngs_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ngs_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ngs_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Internal methods */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int	ng_internalize(struct mbuf *m, struct proc *p); */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_connect_cntl
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ship_msg
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_ng
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_SOCKET_NODE_TYPE
block|,
name|ngs_mod_event
block|,
name|ngs_constructor
block|,
name|ngs_rcvmsg
block|,
name|ngs_rmnode
block|,
name|ngs_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ngs_rcvdata
block|,
name|ngs_rcvdata
block|,
name|ngs_disconnect
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|socket
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Buffer space */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_sendspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|ngpdg_recvspace
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of all sockets */
end_comment

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ngpcb
argument_list|)
end_macro

begin_expr_stmt
name|ngsocklist
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|sotongpcb
parameter_list|(
name|so
parameter_list|)
value|((struct ngpcb *)(so)->so_pcb)
end_define

begin_comment
comment|/* If getting unexplained errors returned, set this to "Debugger("X"); */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TRAP_ERROR
end_ifndef

begin_define
define|#
directive|define
name|TRAP_ERROR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*************************************************************** 	Control sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|suser
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_cntl
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
name|control
operator|&&
operator|(
name|error
operator|=
name|ng_internalize
argument_list|(
name|control
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|#
directive|else
comment|/* NOTYET */
if|if
condition|(
name|control
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
endif|#
directive|endif
comment|/* NOTYET */
comment|/* Require destination as there may be>= 1 hooks on this node */
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* Allocate an expendable buffer for the path, chop off 	 * the sockaddr header, and make sure it's NUL terminated */
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|-
literal|2
expr_stmt|;
name|MALLOC
argument_list|(
name|path
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Move the actual message out of mbufs into a linear buffer. 	 * Start by adding up the size of the data. (could use mh_len?) */
for|for
control|(
name|len
operator|=
literal|0
operator|,
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
name|NULL
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
name|len
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
comment|/* Move the data into a linear buffer as well. Messages are not 	 * delivered in mbufs. */
name|MALLOC
argument_list|(
name|msg
argument_list|,
name|char
operator|*
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* The callee will free the msg when done. The addr is our business. */
name|error
operator|=
name|ng_send_msg
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
argument_list|,
operator|(
expr|struct
name|ng_mesg
operator|*
operator|)
name|msg
argument_list|,
name|path
argument_list|,
operator|&
name|resp
argument_list|)
expr_stmt|;
comment|/* If the callee responded with a synchronous response, then put it 	 * back on the receive side of the socket; sap is source address. */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|resp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|ship_msg
argument_list|(
name|pcbp
argument_list|,
name|resp
argument_list|,
name|sap
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|path
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_bind
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_connect_cntl
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************************************************************** 	Data sockets ***************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ngd_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|ng_attach_data
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addr
decl_stmt|;
name|meta_p
name|mp
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|hook_p
name|hook
init|=
name|NULL
decl_stmt|;
name|char
name|hookname
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|control
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 	 * If the user used any of these ways to not specify an address 	 * then handle specially. 	 */
if|if
condition|(
operator|(
name|sap
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|len
operator|=
name|sap
operator|->
name|sg_len
operator|)
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|*
name|sap
operator|->
name|sg_data
operator|==
literal|'\0'
operator|)
condition|)
block|{
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|numhooks
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * if exactly one hook exists, just use it. 		 * Special case to allow write(2) to work on an ng_socket. 		 */
name|hook
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|hooks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|len
operator|>
name|NG_HOOKLEN
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * chop off the sockaddr header, and make sure it's NUL 		 * terminated 		 */
name|bcopy
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
name|hookname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|hookname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find the correct hook from 'hookname' */
name|LIST_FOREACH
argument_list|(
argument|hook
argument_list|,
argument|&pcbp->sockdata->node->hooks
argument_list|,
argument|hooks
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|hookname
argument_list|,
name|hook
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|hook
operator|==
name|NULL
condition|)
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
block|}
comment|/* Send data (OK if hook is NULL) */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|hook
argument_list|,
name|m
argument_list|,
name|mp
argument_list|)
expr_stmt|;
comment|/* makes m NULL */
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ngd_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|pcbp
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|ng_connect_data
argument_list|(
name|nam
argument_list|,
name|pcbp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used for both data and control sockets  */
end_comment

begin_function
specifier|static
name|int
name|ng_setsockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|sg
decl_stmt|;
name|int
name|sg_len
decl_stmt|,
name|namelen
decl_stmt|,
name|s
decl_stmt|;
comment|/* Why isn't sg_data a `char[1]' ? :-( */
name|sg_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_ng
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|sg
operator|->
name|sg_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcbp
operator|==
literal|0
operator|)
operator|||
operator|(
name|pcbp
operator|->
name|sockdata
operator|==
name|NULL
operator|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|namelen
operator|=
literal|0
expr_stmt|;
comment|/* silence compiler ! */
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
name|sg_len
operator|+=
name|namelen
operator|=
name|strlen
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|sg
argument_list|,
expr|struct
name|sockaddr_ng
operator|*
argument_list|,
name|sg_len
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sg
argument_list|,
name|sg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|pcbp
operator|->
name|sockdata
operator|->
name|node
operator|->
name|name
argument_list|,
name|sg
operator|->
name|sg_data
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_len
operator|=
name|sg_len
expr_stmt|;
name|sg
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a socket to it's protocol specific partner.  * For a control socket, actually create a netgraph node and attach  * to it as well.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_cntl
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|privdata
decl_stmt|;
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Setup protocol control block */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_CONTROL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pcbp
operator|=
name|sotongpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Allocate node private info */
name|MALLOC
argument_list|(
name|privdata
argument_list|,
expr|struct
name|ngsock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|privdata
operator|==
name|NULL
condition|)
block|{
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|privdata
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|privdata
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the generic node components */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|privdata
operator|->
name|node
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|privdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|ng_detach_common
argument_list|(
name|pcbp
argument_list|,
name|NG_CONTROL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|privdata
operator|->
name|node
operator|->
name|private
operator|=
name|privdata
expr_stmt|;
comment|/* Link the pcb and the node private data */
name|privdata
operator|->
name|ctlsock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|privdata
expr_stmt|;
name|privdata
operator|->
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_attach_data
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|ng_attach_common
argument_list|(
name|so
argument_list|,
name|NG_DATA
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up a socket protocol control block.  * This code is shared between control and data sockets.  */
end_comment

begin_function
specifier|static
name|int
name|ng_attach_common
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|ngpcb
modifier|*
name|pcbp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Standard socket setup stuff */
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|ngpdg_sendspace
argument_list|,
name|ngpdg_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate the pcb */
name|MALLOC
argument_list|(
name|pcbp
argument_list|,
expr|struct
name|ngpcb
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pcbp
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|pcbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pcbp
argument_list|)
argument_list|)
expr_stmt|;
name|pcbp
operator|->
name|type
operator|=
name|type
expr_stmt|;
comment|/* Link the pcb and the socket */
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|ng_socket
operator|=
name|so
expr_stmt|;
comment|/* Add the socket to linked list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ngsocklist
argument_list|,
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disassociate the socket from it's protocol specific  * partner. If it's attached to a node's private data structure,  * then unlink from that too. If we were the last socket attached to it,  * then shut down the entire node. Shared code for control and data sockets.  */
end_comment

begin_function
specifier|static
name|void
name|ng_detach_common
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
name|sockdata
decl_stmt|;
if|if
condition|(
name|pcbp
operator|->
name|sockdata
condition|)
block|{
name|sockdata
operator|=
name|pcbp
operator|->
name|sockdata
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|NG_CONTROL
case|:
name|sockdata
operator|->
name|ctlsock
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|NG_DATA
case|:
name|sockdata
operator|->
name|datasock
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|--
name|sockdata
operator|->
name|refs
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sockdata
operator|->
name|node
operator|!=
name|NULL
operator|)
condition|)
name|ng_rmnode
argument_list|(
name|sockdata
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
name|pcbp
operator|->
name|ng_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|pcbp
operator|->
name|ng_socket
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pcbp
argument_list|,
name|socks
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pcbp
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_comment
comment|/*  * File descriptors can be passed into a AF_NETGRAPH socket.  * Note, that file descriptors cannot be passed OUT.  * Only character device descriptors are accepted.  * Character devices are useful to connect a graph to a device,  * which after all is the purpose of this whole system.  */
end_comment

begin_function
specifier|static
name|int
name|ng_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vn
decl_stmt|;
name|int
name|oldfds
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_type
operator|!=
name|SCM_RIGHTS
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|!=
name|control
operator|->
name|m_len
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check there is only one FD. XXX what would more than one signify? */
name|oldfds
operator|=
operator|(
name|cm
operator|->
name|cmsg_len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldfds
operator|!=
literal|1
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check that the FD given is legit. and change it to a pointer to a 	 * struct file. */
name|fd
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|(
name|cm
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* Depending on what kind of resource it is, act differently. For 	 * devices, we treat it as a file. For a AF_NETGRAPH socket, 	 * shortcut straight to the node. */
switch|switch
condition|(
name|fp
operator|->
name|f_type
condition|)
block|{
case|case
name|DTYPE_VNODE
case|:
name|vn
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|vn
operator|&&
operator|(
name|vn
operator|->
name|v_type
operator|==
name|VCHR
operator|)
condition|)
block|{
comment|/* for a VCHR, actually reference the FILE */
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
comment|/* XXX then what :) */
comment|/* how to pass on to other modules? */
block|}
else|else
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
default|default:
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_comment
comment|/*  * Connect the data socket to a named control socket node.  */
end_comment

begin_function
specifier|static
name|int
name|ng_connect_data
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|sockaddr_ng
modifier|*
name|sap
decl_stmt|;
name|node_p
name|farnode
decl_stmt|;
name|struct
name|ngsock
modifier|*
name|sockdata
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* If we are already connected, don't do it again */
if|if
condition|(
name|pcbp
operator|->
name|sockdata
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Find the target (victim) and check it doesn't already have a data 	 * socket. Also check it is a 'socket' type node. */
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_path2node
argument_list|(
name|NULL
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|,
operator|&
name|farnode
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|farnode
operator|->
name|type
operator|->
name|name
argument_list|,
name|NG_SOCKET_NODE_TYPE
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sockdata
operator|=
name|farnode
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sockdata
operator|->
name|datasock
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
comment|/* Link the PCB and the private data struct. and note the extra 	 * reference */
name|sockdata
operator|->
name|datasock
operator|=
name|pcbp
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|sockdata
expr_stmt|;
name|sockdata
operator|->
name|refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Connect the existing control socket node to a named node:hook.  * The hook we use on this end is the same name as the remote node name.  */
end_comment

begin_function
specifier|static
name|int
name|ng_connect_cntl
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|pcbp
operator|->
name|sockdata
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|sap
decl_stmt|;
name|char
modifier|*
name|node
decl_stmt|,
modifier|*
name|hook
decl_stmt|;
name|node_p
name|farnode
decl_stmt|;
name|int
name|rtn
decl_stmt|,
name|error
decl_stmt|;
name|sap
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
expr_stmt|;
name|rtn
operator|=
name|ng_path_parse
argument_list|(
name|sap
operator|->
name|sg_data
argument_list|,
operator|&
name|node
argument_list|,
name|NULL
argument_list|,
operator|&
name|hook
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtn
operator|<
literal|0
operator|||
name|node
operator|==
name|NULL
operator|||
name|hook
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|farnode
operator|=
name|ng_findname
argument_list|(
name|sockdata
operator|->
name|node
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|farnode
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
comment|/* Connect, using a hook name the same as the far node name. */
name|error
operator|=
name|ng_con_nodes
argument_list|(
name|sockdata
operator|->
name|node
argument_list|,
name|node
argument_list|,
name|farnode
argument_list|,
name|hook
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Binding a socket means giving the corresponding node a name  */
end_comment

begin_function
specifier|static
name|int
name|ng_bind
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|pcbp
operator|->
name|sockdata
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
specifier|const
name|sap
init|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|nam
decl_stmt|;
if|if
condition|(
name|sockdata
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|sap
operator|->
name|sg_len
operator|<
literal|3
operator|||
name|sap
operator|->
name|sg_data
index|[
name|sap
operator|->
name|sg_len
operator|-
literal|3
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|ng_name_node
argument_list|(
name|sockdata
operator|->
name|node
argument_list|,
name|sap
operator|->
name|sg_data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a message and pass it up to the control socket associated  * with the node.  */
end_comment

begin_function
specifier|static
name|int
name|ship_msg
parameter_list|(
name|struct
name|ngpcb
modifier|*
name|pcbp
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_ng
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|socket
modifier|*
specifier|const
name|so
init|=
name|pcbp
operator|->
name|ng_socket
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mdata
decl_stmt|;
name|int
name|msglen
decl_stmt|;
comment|/* Copy the message itself into an mbuf chain */
name|msglen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_mesg
argument_list|)
operator|+
name|msg
operator|->
name|header
operator|.
name|arglen
expr_stmt|;
name|mdata
operator|=
name|m_devget
argument_list|(
operator|(
name|caddr_t
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Here we free the message, as we are the end of the line. 	 * We need to do that regardless of whether we got mbufs. */
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdata
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Send it up to the socket */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|mdata
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
name|m_freem
argument_list|(
name|mdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * You can only create new nodes from the socket end of things.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We allow any hook to be connected to the node.  * There is no per-hook private information though.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incoming messages get passed up to the control socket.  * Unless they are for us specifically (socket_type)  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|resp
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sockdata
operator|->
name|ctlsock
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Only allow mesgs to be passed if we have the control socket. 	 * Data sockets can only support the generic messages. */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
operator|==
name|NGM_SOCKET_COOKIE
condition|)
block|{
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_SOCK_CMD_NOLINGER
case|:
name|sockdata
operator|->
name|flags
operator||=
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
case|case
name|NGM_SOCK_CMD_LINGER
case|:
name|sockdata
operator|->
name|flags
operator|&=
operator|~
name|NGS_FLAG_NOLINGER
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* unknown command */
block|}
comment|/* Free the message and return */
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Get the return address into a sockaddr */
if|if
condition|(
operator|(
name|retaddr
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|*
name|retaddr
operator|==
literal|'\0'
operator|)
condition|)
name|retaddr
operator|=
literal|""
expr_stmt|;
name|addrlen
operator|=
name|strlen
argument_list|(
name|retaddr
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|addr
argument_list|,
expr|struct
name|sockaddr_ng
operator|*
argument_list|,
name|addrlen
operator|+
literal|4
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|addr
operator|->
name|sg_len
operator|=
name|addrlen
operator|+
literal|3
expr_stmt|;
name|addr
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|bcopy
argument_list|(
name|retaddr
argument_list|,
name|addr
operator|->
name|sg_data
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sg_data
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Send it up */
name|error
operator|=
name|ship_msg
argument_list|(
name|pcbp
argument_list|,
name|msg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|addr
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sockdata
operator|->
name|datasock
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_ng
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|addrbuf
index|[
name|NG_HOOKLEN
operator|+
literal|1
operator|+
literal|4
index|]
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
comment|/* If there is no data socket, black-hole it */
if|if
condition|(
name|pcbp
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|so
operator|=
name|pcbp
operator|->
name|ng_socket
expr_stmt|;
comment|/* Get the return address into a sockaddr. */
name|addrlen
operator|=
name|strlen
argument_list|(
name|hook
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/*<= NG_HOOKLEN */
name|addr
operator|=
operator|(
expr|struct
name|sockaddr_ng
operator|*
operator|)
name|addrbuf
expr_stmt|;
name|addr
operator|->
name|sg_len
operator|=
name|addrlen
operator|+
literal|3
expr_stmt|;
name|addr
operator|->
name|sg_family
operator|=
name|AF_NETGRAPH
expr_stmt|;
name|bcopy
argument_list|(
name|hook
operator|->
name|name
argument_list|,
name|addr
operator|->
name|sg_data
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|addr
operator|->
name|sg_data
index|[
name|addrlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* We have no use for the meta data, free/clear it now. */
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
comment|/* Try to tell the socket which hook it came in on */
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|TRAP_ERROR
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * For this type, removal of the last link destroys the node  * if the NOLINGER flag is set.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|(
name|sockdata
operator|->
name|flags
operator|&
name|NGS_FLAG_NOLINGER
operator|)
operator|&&
operator|(
name|hook
operator|->
name|node
operator|->
name|numhooks
operator|==
literal|0
operator|)
condition|)
block|{
name|ng_rmnode
argument_list|(
name|hook
operator|->
name|node
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing.  * In this case, that involves making sure the socket  * knows we should be shutting down.  */
end_comment

begin_function
specifier|static
name|int
name|ngs_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|ngsock
modifier|*
specifier|const
name|sockdata
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|dpcbp
init|=
name|sockdata
operator|->
name|datasock
decl_stmt|;
name|struct
name|ngpcb
modifier|*
specifier|const
name|pcbp
init|=
name|sockdata
operator|->
name|ctlsock
decl_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpcbp
operator|!=
name|NULL
condition|)
block|{
name|soisdisconnected
argument_list|(
name|dpcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
name|dpcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
name|sockdata
operator|->
name|datasock
operator|=
name|NULL
expr_stmt|;
name|sockdata
operator|->
name|refs
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|pcbp
operator|!=
name|NULL
condition|)
block|{
name|soisdisconnected
argument_list|(
name|pcbp
operator|->
name|ng_socket
argument_list|)
expr_stmt|;
name|pcbp
operator|->
name|sockdata
operator|=
name|NULL
expr_stmt|;
name|sockdata
operator|->
name|ctlsock
operator|=
name|NULL
expr_stmt|;
name|sockdata
operator|->
name|refs
operator|--
expr_stmt|;
block|}
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sockdata
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Control and data socket type descriptors  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngc_usrreqs
init|=
block|{
name|NULL
block|,
comment|/* abort */
name|pru_accept_notsupp
block|,
name|ngc_attach
block|,
name|ngc_bind
block|,
name|ngc_connect
block|,
name|pru_connect2_notsupp
block|,
name|pru_control_notsupp
block|,
name|ngc_detach
block|,
name|NULL
block|,
comment|/* disconnect */
name|pru_listen_notsupp
block|,
name|NULL
block|,
comment|/* setpeeraddr */
name|pru_rcvd_notsupp
block|,
name|pru_rcvoob_notsupp
block|,
name|ngc_send
block|,
name|pru_sense_null
block|,
name|NULL
block|,
comment|/* shutdown */
name|ng_setsockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|ngd_usrreqs
init|=
block|{
name|NULL
block|,
comment|/* abort */
name|pru_accept_notsupp
block|,
name|ngd_attach
block|,
name|NULL
block|,
comment|/* bind */
name|ngd_connect
block|,
name|pru_connect2_notsupp
block|,
name|pru_control_notsupp
block|,
name|ngd_detach
block|,
name|NULL
block|,
comment|/* disconnect */
name|pru_listen_notsupp
block|,
name|NULL
block|,
comment|/* setpeeraddr */
name|pru_rcvd_notsupp
block|,
name|pru_rcvoob_notsupp
block|,
name|ngd_send
block|,
name|pru_sense_null
block|,
name|NULL
block|,
comment|/* shutdown */
name|ng_setsockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Definitions of protocols supported in the NETGRAPH domain.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|ngdomain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stop compiler warnings */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|ngsw
index|[]
init|=
block|{
block|{
name|SOCK_DGRAM
block|,
operator|&
name|ngdomain
block|,
name|NG_CONTROL
block|,
name|PR_ATOMIC
operator||
name|PR_ADDR
comment|/* | PR_RIGHTS */
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|ngc_usrreqs
block|}
block|,
block|{
name|SOCK_DGRAM
block|,
operator|&
name|ngdomain
block|,
name|NG_DATA
block|,
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|ngd_usrreqs
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain
name|ngdomain
init|=
block|{
name|AF_NETGRAPH
block|,
literal|"netgraph"
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
name|ngsw
block|,
operator|&
name|ngsw
index|[
sizeof|sizeof
argument_list|(
name|ngsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ngsw
index|[
literal|0
index|]
argument_list|)
index|]
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle loading and unloading for this node type  * This is to handle auxiliary linkages (e.g protocol domain addition).  */
end_comment

begin_function
specifier|static
name|int
name|ngs_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Register protocol domain */
name|net_add_domain
argument_list|(
operator|&
name|ngdomain
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Insure there are no open netgraph sockets */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|ngsocklist
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|NOTYET
comment|/* Unregister protocol domain XXX can't do this yet.. */
if|if
condition|(
operator|(
name|error
operator|=
name|net_rm_domain
argument_list|(
operator|&
name|ngdomain
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
else|#
directive|else
name|error
operator|=
name|EBUSY
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|family
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|AF_NETGRAPH
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|data
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_data
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_DATA
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|control
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"CONTROL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_control
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|NG_CONTROL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

