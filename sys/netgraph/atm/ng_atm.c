begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001-2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  *  * Netgraph module to connect NATM interfaces to netgraph.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/atm/ng_atm.h>
end_include

begin_comment
comment|/*  * Hooks in the NATM code  */
end_comment

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ng_atm_attach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ng_atm_detach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|ng_atm_output_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ng_atm_input_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ng_atm_input_orphan_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|ng_atm_message_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Sysctl stuff.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_graph
argument_list|,
name|OID_AUTO
argument_list|,
name|atm
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"atm related stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NGATM_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|allow_shutdown
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_graph_atm
argument_list|,
name|OID_AUTO
argument_list|,
name|allow_shutdown
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|allow_shutdown
argument_list|,
literal|0
argument_list|,
literal|"allow ng_atm nodes to shutdown"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hook private data  */
end_comment

begin_struct
struct|struct
name|ngvcc
block|{
name|uint16_t
name|vpi
decl_stmt|;
comment|/* VPI of this hook */
name|uint16_t
name|vci
decl_stmt|;
comment|/* VCI of this hook, 0 if none */
name|uint32_t
name|flags
decl_stmt|;
comment|/* private flags */
name|hook_p
name|hook
decl_stmt|;
comment|/* the connected hook */
name|LIST_ENTRY
argument_list|(
argument|ngvcc
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VCC_OPEN
value|0x0001
end_define

begin_comment
comment|/* open */
end_comment

begin_comment
comment|/*  * Node private data  */
end_comment

begin_struct
struct|struct
name|priv
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* the ATM interface */
name|hook_p
name|input
decl_stmt|;
comment|/* raw input hook */
name|hook_p
name|orphans
decl_stmt|;
comment|/* packets to nowhere */
name|hook_p
name|output
decl_stmt|;
comment|/* catch output packets */
name|hook_p
name|manage
decl_stmt|;
comment|/* has also entry in vccs */
name|uint64_t
name|in_packets
decl_stmt|;
name|uint64_t
name|in_errors
decl_stmt|;
name|uint64_t
name|out_packets
decl_stmt|;
name|uint64_t
name|out_errors
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ngvcc
argument_list|)
name|vccs
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Parse carrier state  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_carrier_change_info
index|[]
init|=
name|NGM_ATM_CARRIER_CHANGE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_carrier_change_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_carrier_change_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse the configuration structure ng_atm_config  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_config_type_info
index|[]
init|=
name|NGM_ATM_CONFIG_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_config_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse a single vcc structure and a variable array of these ng_atm_vccs  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_tparam_type_info
index|[]
init|=
name|NGM_ATM_TPARAM_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_tparam_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_tparam_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_vcc_type_info
index|[]
init|=
name|NGM_ATM_VCC_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_vcc_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_vcc_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ng_atm_vccarray_getlen
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|atmio_vcctable
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
operator|(
specifier|const
expr|struct
name|atmio_vcctable
operator|*
operator|)
operator|(
name|buf
operator|-
name|offsetof
argument_list|(
expr|struct
name|atmio_vcctable
argument_list|,
name|vccs
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|vp
operator|->
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_atm_vccarray_info
init|=
name|NGM_ATM_VCCARRAY_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_vccarray_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_atm_vccarray_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_vcctable_type_info
index|[]
init|=
name|NGM_ATM_VCCTABLE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_vcctable_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_vcctable_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse CPCS INIT structure ng_atm_cpcs_init  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_cpcs_init_type_info
index|[]
init|=
name|NGM_ATM_CPCS_INIT_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_cpcs_init_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_cpcs_init_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse CPCS TERM structure ng_atm_cpcs_term  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_cpcs_term_type_info
index|[]
init|=
name|NGM_ATM_CPCS_TERM_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_cpcs_term_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_cpcs_term_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Parse statistic struct  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atm_stats_type_info
index|[]
init|=
name|NGM_ATM_STATS_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atm_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atm_stats_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_atm_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_IFNAME
block|,
literal|"getifname"
block|,
name|NULL
block|,
operator|&
name|ng_parse_string_type
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_atm_config_type
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_VCCS
block|,
literal|"getvccs"
block|,
name|NULL
block|,
operator|&
name|ng_atm_vcctable_type
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_CPCS_INIT
block|,
literal|"cpcsinit"
block|,
operator|&
name|ng_atm_cpcs_init_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_CPCS_TERM
block|,
literal|"cpcsterm"
block|,
operator|&
name|ng_atm_cpcs_term_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_CARRIER_CHANGE
block|,
literal|"carrier"
block|,
operator|&
name|ng_atm_carrier_change_type
block|,
operator|&
name|ng_atm_carrier_change_type
block|, 	}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_VCC
block|,
literal|"getvcc"
block|,
operator|&
name|ng_parse_hookbuf_type
block|,
operator|&
name|ng_atm_vcc_type
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_VCCID
block|,
literal|"getvccid"
block|,
operator|&
name|ng_atm_vcc_type
block|,
operator|&
name|ng_atm_vcc_type
block|}
block|,
block|{
name|NGM_ATM_COOKIE
block|,
name|NGM_ATM_GET_STATS
block|,
literal|"getstats"
block|,
name|NULL
block|,
operator|&
name|ng_atm_stats_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ng_atm_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_atm_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_atm_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_atm_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_atm_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_atm_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_atm_disconnect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_atm_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_atm_rcvdrop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_atm_typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_ATM_NODE_TYPE
block|,
name|ng_atm_mod_event
block|,
comment|/* Module event handler (optional) */
name|ng_atm_constructor
block|,
comment|/* Node constructor */
name|ng_atm_rcvmsg
block|,
comment|/* control messages come here */
name|ng_atm_shutdown
block|,
comment|/* reset, and free resources */
name|ng_atm_newhook
block|,
comment|/* first notification of new hook */
name|NULL
block|,
comment|/* findhook */
name|ng_atm_connect
block|,
comment|/* connect */
name|ng_atm_rcvdata
block|,
comment|/* rcvdata */
name|ng_atm_disconnect
block|,
comment|/* notify on disconnect */
name|ng_atm_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|atm
argument_list|,
operator|&
name|ng_atm_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|u_int
name|media
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|atmmedia
index|[]
init|=
name|IFM_SUBTYPE_ATM_DESCRIPTIONS
struct|;
end_struct

begin_define
define|#
directive|define
name|IFP2NG
parameter_list|(
name|IFP
parameter_list|)
value|((node_p)((struct ifatm *)(IFP))->ngpriv)
end_define

begin_define
define|#
directive|define
name|IFFLAGS
value|"\020\001UP\002BROADCAST\003DEBUG\004LOOPBACK" \ 		 "\005POINTOPOINT\006SMART\007RUNNING\010NOARP" \ 		 "\011PROMISC\012ALLMULTI\013OACTIVE\014SIMPLEX" \ 		 "\015LINK0\016LINK1\017LINK2\020MULTICAST"
end_define

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * INPUT  */
end_comment

begin_comment
comment|/*  * A packet is received from an interface.   * If we have an input hook, prepend the pseudoheader to the data and  * deliver it out to that hook. If not, look whether it is destined for  * use. If so locate the appropriate hook, deliver the packet without the  * header and we are done. If it is not for us, leave it alone.  */
end_comment

begin_function
specifier|static
name|void
name|ng_atm_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|rxhand
parameter_list|)
block|{
name|node_p
name|node
init|=
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|priv
modifier|*
name|priv
decl_stmt|;
specifier|const
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|input
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Prepend the atm_pseudoheader. 		 */
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
argument_list|,
name|ah
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|input
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|in_packets
operator|++
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NGATM_DEBUG
name|printf
argument_list|(
literal|"%s: error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|priv
operator|->
name|in_errors
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
operator|(
name|ATM_PH_FLAGS
argument_list|(
name|ah
argument_list|)
operator|&
name|ATMIO_FLAG_NG
operator|)
operator|==
literal|0
condition|)
return|return;
name|vcc
operator|=
operator|(
expr|struct
name|ngvcc
operator|*
operator|)
name|rxhand
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|vcc
operator|->
name|hook
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|in_packets
operator|++
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NGATM_DEBUG
name|printf
argument_list|(
literal|"%s: error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|priv
operator|->
name|in_errors
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ATM packet is about to be output. The atm_pseudohdr is already prepended.  * If the hook is set, reroute the packet to the hook.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|priv
modifier|*
name|priv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|output
condition|)
block|{
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|output
argument_list|,
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Well, this doesn't make much sense for ATM.  */
end_comment

begin_function
specifier|static
name|void
name|ng_atm_input_orphans
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|rxhand
parameter_list|)
block|{
name|node_p
name|node
init|=
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|priv
modifier|*
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|orphans
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Prepend the atm_pseudoheader. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
argument_list|,
name|ah
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ah
argument_list|)
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|orphans
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|priv
operator|->
name|in_packets
operator|++
expr_stmt|;
else|else
block|{
name|priv
operator|->
name|in_errors
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|NGATM_DEBUG
name|printf
argument_list|(
literal|"%s: error=%d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * OUTPUT  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ngvcc
modifier|*
name|vcc
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|aph
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vcc
operator|->
name|vci
operator|==
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* 	 * Prepend pseudo-hdr. Drivers don't care about the flags. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aph
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
name|ATM_PH_VPI
argument_list|(
name|aph
argument_list|)
operator|=
name|vcc
operator|->
name|vpi
expr_stmt|;
name|ATM_PH_SETVCI
argument_list|(
name|aph
argument_list|,
name|vcc
operator|->
name|vci
argument_list|)
expr_stmt|;
name|ATM_PH_FLAGS
argument_list|(
name|aph
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|atm_output
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|priv
operator|->
name|out_packets
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|out_errors
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_atm_rcvdrop
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************  *  * Message from driver.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|void
name|ng_atm_message_func
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
name|uint32_t
name|msg
init|=
operator|(
name|uintptr_t
operator|)
name|arg1
decl_stmt|;
name|uint32_t
name|arg
init|=
operator|(
name|uint32_t
operator|)
name|arg2
decl_stmt|;
specifier|const
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
name|u_int
name|vci
decl_stmt|,
name|vpi
decl_stmt|,
name|state
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|mesg
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|msg
condition|)
block|{
case|case
name|ATM_MSG_FLOW_CONTROL
case|:
block|{
name|struct
name|ngm_queue_state
modifier|*
name|qstate
decl_stmt|;
comment|/* find the connection */
name|vci
operator|=
name|arg
operator|&
literal|0xffff
expr_stmt|;
name|vpi
operator|=
operator|(
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|state
operator|=
operator|(
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vcc
argument_list|,
argument|&priv->vccs
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|vcc
operator|->
name|vci
operator|==
name|vci
operator|&&
name|vcc
operator|->
name|vpi
operator|==
name|vpi
condition|)
break|break;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
break|break;
comment|/* convert into a flow control message */
name|NG_MKMESSAGE
argument_list|(
name|mesg
argument_list|,
name|NGM_FLOW_COOKIE
argument_list|,
name|state
condition|?
name|NGM_HIGH_WATER_PASSED
else|:
name|NGM_LOW_WATER_PASSED
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngm_queue_state
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
operator|==
name|NULL
condition|)
break|break;
name|qstate
operator|=
operator|(
expr|struct
name|ngm_queue_state
operator|*
operator|)
name|mesg
operator|->
name|data
expr_stmt|;
comment|/* XXX have to figure out how to get that info */
name|NG_SEND_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|mesg
argument_list|,
name|vcc
operator|->
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ATM_MSG_VCC_CHANGED
case|:
block|{
name|struct
name|ngm_atm_vcc_change
modifier|*
name|chg
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|manage
operator|==
name|NULL
condition|)
break|break;
name|NG_MKMESSAGE
argument_list|(
name|mesg
argument_list|,
name|NGM_ATM_COOKIE
argument_list|,
name|NGM_ATM_VCC_CHANGE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngm_atm_vcc_change
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
operator|==
name|NULL
condition|)
break|break;
name|chg
operator|=
operator|(
expr|struct
name|ngm_atm_vcc_change
operator|*
operator|)
name|mesg
operator|->
name|data
expr_stmt|;
name|chg
operator|->
name|vci
operator|=
name|arg
operator|&
literal|0xffff
expr_stmt|;
name|chg
operator|->
name|vpi
operator|=
operator|(
name|arg
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|chg
operator|->
name|state
operator|=
operator|(
name|arg
operator|>>
literal|24
operator|)
operator|&
literal|1
expr_stmt|;
name|chg
operator|->
name|node
operator|=
name|NG_NODE_ID
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|mesg
argument_list|,
name|priv
operator|->
name|manage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|ATM_MSG_CARRIER_CHANGE
case|:
block|{
name|struct
name|ngm_atm_carrier_change
modifier|*
name|chg
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|manage
operator|==
name|NULL
condition|)
break|break;
name|NG_MKMESSAGE
argument_list|(
name|mesg
argument_list|,
name|NGM_ATM_COOKIE
argument_list|,
name|NGM_ATM_CARRIER_CHANGE
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngm_atm_carrier_change
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mesg
operator|==
name|NULL
condition|)
break|break;
name|chg
operator|=
operator|(
expr|struct
name|ngm_atm_carrier_change
operator|*
operator|)
name|mesg
operator|->
name|data
expr_stmt|;
name|chg
operator|->
name|state
operator|=
name|arg
operator|&
literal|1
expr_stmt|;
name|chg
operator|->
name|node
operator|=
name|NG_NODE_ID
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|NG_SEND_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|mesg
argument_list|,
name|priv
operator|->
name|manage
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Use send_fn to get the right lock  */
end_comment

begin_function
specifier|static
name|void
name|ng_atm_message
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|uint32_t
name|msg
parameter_list|,
name|uint32_t
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
specifier|const
name|node_p
name|node
init|=
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|ng_send_fn
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|,
name|ng_atm_message_func
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/************************************************************  *  * CPCS  */
end_comment

begin_comment
comment|/*  * Open a channel for the user  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_cpcs_init
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ngm_atm_cpcs_init
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ifatm_mib
modifier|*
name|mib
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
name|struct
name|atmio_openvcc
name|data
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mib
operator|=
operator|(
specifier|const
expr|struct
name|ifatm_mib
operator|*
operator|)
operator|(
name|priv
operator|->
name|ifp
operator|->
name|if_linkmib
operator|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vcc
argument_list|,
argument|&priv->vccs
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|vcc
operator|->
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vci
operator|!=
literal|0
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* 	 * Check user arguments and construct ioctl argument 	 */
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|.
name|rxhand
operator|=
name|vcc
expr_stmt|;
switch|switch
condition|(
name|data
operator|.
name|param
operator|.
name|aal
operator|=
name|arg
operator|->
name|aal
condition|)
block|{
case|case
name|ATMIO_AAL_34
case|:
case|case
name|ATMIO_AAL_5
case|:
case|case
name|ATMIO_AAL_0
case|:
case|case
name|ATMIO_AAL_RAW
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|arg
operator|->
name|vpi
operator|>
literal|0xff
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|vpi
operator|=
name|arg
operator|->
name|vpi
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|vci
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* allow 0.0 as catch all receive channel */
if|if
condition|(
name|arg
operator|->
name|vci
operator|==
literal|0
operator|&&
operator|(
name|arg
operator|->
name|vpi
operator|!=
literal|0
operator|||
operator|!
operator|(
name|arg
operator|->
name|flags
operator|&
name|ATMIO_FLAG_NOTX
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|vci
operator|=
name|arg
operator|->
name|vci
expr_stmt|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|pcr
operator|=
name|arg
operator|->
name|pcr
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|mcr
operator|>
name|arg
operator|->
name|pcr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|mcr
operator|=
name|arg
operator|->
name|mcr
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|arg
operator|->
name|flags
operator|&
name|ATMIO_FLAG_NOTX
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|tmtu
operator|==
literal|0
condition|)
name|data
operator|.
name|param
operator|.
name|tmtu
operator|=
name|priv
operator|->
name|ifp
operator|->
name|if_mtu
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|tmtu
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tmtu
operator|=
name|arg
operator|->
name|tmtu
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|arg
operator|->
name|flags
operator|&
name|ATMIO_FLAG_NORX
operator|)
condition|)
block|{
if|if
condition|(
name|arg
operator|->
name|rmtu
operator|==
literal|0
condition|)
name|data
operator|.
name|param
operator|.
name|rmtu
operator|=
name|priv
operator|->
name|ifp
operator|->
name|if_mtu
expr_stmt|;
else|else
block|{
if|if
condition|(
name|arg
operator|->
name|rmtu
operator|>
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|rmtu
operator|=
name|arg
operator|->
name|rmtu
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|data
operator|.
name|param
operator|.
name|traffic
operator|=
name|arg
operator|->
name|traffic
condition|)
block|{
case|case
name|ATMIO_TRAFFIC_UBR
case|:
case|case
name|ATMIO_TRAFFIC_CBR
case|:
break|break;
case|case
name|ATMIO_TRAFFIC_VBR
case|:
if|if
condition|(
name|arg
operator|->
name|scr
operator|>
name|arg
operator|->
name|pcr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|scr
operator|=
name|arg
operator|->
name|scr
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|mbs
operator|>
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|mbs
operator|=
name|arg
operator|->
name|mbs
expr_stmt|;
break|break;
case|case
name|ATMIO_TRAFFIC_ABR
case|:
if|if
condition|(
name|arg
operator|->
name|icr
operator|>
name|arg
operator|->
name|pcr
operator|||
name|arg
operator|->
name|icr
operator|<
name|arg
operator|->
name|mcr
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|icr
operator|=
name|arg
operator|->
name|icr
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|tbe
operator|==
literal|0
operator|||
name|arg
operator|->
name|tbe
operator|>
operator|(
literal|1
operator|<<
literal|24
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|tbe
operator|=
name|arg
operator|->
name|tbe
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|nrm
operator|>
literal|0x7
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|nrm
operator|=
name|arg
operator|->
name|nrm
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|trm
operator|>
literal|0x7
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|trm
operator|=
name|arg
operator|->
name|trm
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|adtf
operator|>
literal|0x3ff
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|adtf
operator|=
name|arg
operator|->
name|adtf
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|rif
operator|>
literal|0xf
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|rif
operator|=
name|arg
operator|->
name|rif
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|rdf
operator|>
literal|0xf
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|rdf
operator|=
name|arg
operator|->
name|rdf
expr_stmt|;
if|if
condition|(
name|arg
operator|->
name|cdf
operator|>
literal|0x7
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|tparam
operator|.
name|cdf
operator|=
name|arg
operator|->
name|cdf
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|arg
operator|->
name|flags
operator|&
name|ATMIO_FLAG_NORX
operator|)
operator|&&
operator|(
name|arg
operator|->
name|flags
operator|&
name|ATMIO_FLAG_NOTX
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|.
name|param
operator|.
name|flags
operator|=
name|arg
operator|->
name|flags
operator|&
operator|~
operator|(
name|ATM_PH_AAL5
operator||
name|ATM_PH_LLCSNAP
operator|)
expr_stmt|;
name|data
operator|.
name|param
operator|.
name|flags
operator||=
name|ATMIO_FLAG_NG
expr_stmt|;
name|err
operator|=
call|(
modifier|*
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|SIOCATMOPENVCC
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|vcc
operator|->
name|vci
operator|=
name|data
operator|.
name|param
operator|.
name|vci
expr_stmt|;
name|vcc
operator|->
name|vpi
operator|=
name|data
operator|.
name|param
operator|.
name|vpi
expr_stmt|;
name|vcc
operator|->
name|flags
operator|=
name|VCC_OPEN
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Issue the close command to the driver  */
end_comment

begin_function
specifier|static
name|int
name|cpcs_term
parameter_list|(
specifier|const
name|struct
name|priv
modifier|*
name|priv
parameter_list|,
name|u_int
name|vpi
parameter_list|,
name|u_int
name|vci
parameter_list|)
block|{
name|struct
name|atmio_closevcc
name|data
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
name|data
operator|.
name|vpi
operator|=
name|vpi
expr_stmt|;
name|data
operator|.
name|vci
operator|=
name|vci
expr_stmt|;
return|return
operator|(
call|(
modifier|*
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|SIOCATMCLOSEVCC
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a channel by request of the user  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_cpcs_term
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ngm_atm_cpcs_term
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vcc
argument_list|,
argument|&priv->vccs
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|vcc
operator|->
name|hook
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
if|if
condition|(
name|vcc
operator|->
name|vci
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
name|error
operator|=
name|cpcs_term
argument_list|(
name|priv
argument_list|,
name|vcc
operator|->
name|vpi
argument_list|,
name|vcc
operator|->
name|vci
argument_list|)
expr_stmt|;
name|vcc
operator|->
name|vci
operator|=
literal|0
expr_stmt|;
name|vcc
operator|->
name|vpi
operator|=
literal|0
expr_stmt|;
name|vcc
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * CONTROL MESSAGES  */
end_comment

begin_comment
comment|/*  * Produce a textual description of the current status  */
end_comment

begin_function
specifier|static
name|int
name|text_status
parameter_list|(
name|node_p
name|node
parameter_list|,
name|char
modifier|*
name|arg
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|ifatm_mib
modifier|*
name|mib
decl_stmt|;
name|struct
name|sbuf
name|sbuf
decl_stmt|;
name|u_int
name|i
decl_stmt|;
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|vendor
decl_stmt|;
block|}
name|devices
index|[]
init|=
block|{
name|ATM_DEVICE_NAMES
block|}
struct|;
name|mib
operator|=
operator|(
specifier|const
expr|struct
name|ifatm_mib
operator|*
operator|)
operator|(
name|priv
operator|->
name|ifp
operator|->
name|if_linkmib
operator|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sbuf
argument_list|,
name|arg
argument_list|,
name|len
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"interface: %s%d\n"
argument_list|,
name|priv
operator|->
name|ifp
operator|->
name|if_name
argument_list|,
name|priv
operator|->
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|mib
operator|->
name|device
operator|>=
sizeof|sizeof
argument_list|(
name|devices
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|devices
index|[
literal|0
index|]
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"device=unknown\nvendor=unknown\n"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"device=%s\nvendor=%s\n"
argument_list|,
name|devices
index|[
name|mib
operator|->
name|device
index|]
operator|.
name|name
argument_list|,
name|devices
index|[
name|mib
operator|->
name|device
index|]
operator|.
name|vendor
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|atmmedia
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mib
operator|->
name|media
operator|==
name|atmmedia
index|[
name|i
index|]
operator|.
name|media
condition|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"media=%s\n"
argument_list|,
name|atmmedia
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|atmmedia
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"media=unknown\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"serial=%u esi=%6D hardware=%u software=%u\n"
argument_list|,
name|mib
operator|->
name|serial
argument_list|,
name|mib
operator|->
name|esi
argument_list|,
literal|":"
argument_list|,
name|mib
operator|->
name|hw_version
argument_list|,
name|mib
operator|->
name|sw_version
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"pcr=%u vpi_bits=%u vci_bits=%u max_vpcs=%u "
literal|"max_vccs=%u\n"
argument_list|,
name|mib
operator|->
name|pcr
argument_list|,
name|mib
operator|->
name|vpi_bits
argument_list|,
name|mib
operator|->
name|vci_bits
argument_list|,
name|mib
operator|->
name|max_vpcs
argument_list|,
name|mib
operator|->
name|max_vccs
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sbuf
argument_list|,
literal|"ifflags=%b\n"
argument_list|,
name|priv
operator|->
name|ifp
operator|->
name|if_flags
argument_list|,
name|IFFLAGS
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|sbuf_len
argument_list|(
operator|&
name|sbuf
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ifatm_mib
modifier|*
name|mib
init|=
operator|(
expr|struct
name|ifatm_mib
operator|*
operator|)
operator|(
name|priv
operator|->
name|ifp
operator|->
name|if_linkmib
operator|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|resp
operator|->
name|header
operator|.
name|arglen
operator|=
name|text_status
argument_list|(
name|node
argument_list|,
operator|(
name|char
operator|*
operator|)
name|resp
operator|->
name|data
argument_list|,
name|resp
operator|->
name|header
operator|.
name|arglen
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_ATM_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_ATM_GET_IFNAME
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|IFNAMSIZ
operator|+
literal|1
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|snprintf
argument_list|(
name|resp
operator|->
name|data
argument_list|,
name|IFNAMSIZ
operator|+
literal|1
argument_list|,
literal|"%s%d"
argument_list|,
name|priv
operator|->
name|ifp
operator|->
name|if_name
argument_list|,
name|priv
operator|->
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_ATM_GET_CONFIG
case|:
block|{
name|struct
name|ngm_atm_config
modifier|*
name|config
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|config
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|config
operator|=
operator|(
expr|struct
name|ngm_atm_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|config
operator|->
name|pcr
operator|=
name|mib
operator|->
name|pcr
expr_stmt|;
name|config
operator|->
name|vpi_bits
operator|=
name|mib
operator|->
name|vpi_bits
expr_stmt|;
name|config
operator|->
name|vci_bits
operator|=
name|mib
operator|->
name|vci_bits
expr_stmt|;
name|config
operator|->
name|max_vpcs
operator|=
name|mib
operator|->
name|max_vpcs
expr_stmt|;
name|config
operator|->
name|max_vccs
operator|=
name|mib
operator|->
name|max_vccs
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATM_GET_VCCS
case|:
block|{
name|struct
name|atmio_vcctable
modifier|*
name|vccs
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|SIOCATMGETVCCS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|vccs
argument_list|)
operator|+
name|vccs
operator|->
name|count
operator|*
sizeof|sizeof
argument_list|(
name|vccs
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|resp
operator|->
name|data
argument_list|,
name|vccs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATM_GET_VCC
case|:
block|{
name|char
name|hook
index|[
name|NG_HOOKLEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|atmio_vcctable
modifier|*
name|vccs
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
name|NG_HOOKLEN
operator|+
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|hook
argument_list|,
name|msg
operator|->
name|data
argument_list|,
name|NG_HOOKLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hook
index|[
name|NG_HOOKLEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vcc
argument_list|,
argument|&priv->vccs
argument_list|,
argument|link
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|NG_HOOK_NAME
argument_list|(
name|vcc
operator|->
name|hook
argument_list|)
argument_list|,
name|hook
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|SIOCATMGETVCCS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vccs
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
operator|.
name|vpi
operator|==
name|vcc
operator|->
name|vpi
operator|&&
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
operator|.
name|vci
operator|==
name|vcc
operator|->
name|vci
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|vccs
operator|->
name|count
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|vccs
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|)
name|resp
operator|->
name|data
operator|=
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATM_GET_VCCID
case|:
block|{
name|struct
name|atmio_vcc
modifier|*
name|arg
decl_stmt|;
name|struct
name|atmio_vcctable
modifier|*
name|vccs
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|arg
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|arg
operator|=
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|priv
operator|->
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|priv
operator|->
name|ifp
argument_list|,
name|SIOCATMGETVCCS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vccs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vccs
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
operator|.
name|vpi
operator|==
name|arg
operator|->
name|vpi
operator|&&
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
operator|.
name|vci
operator|==
name|arg
operator|->
name|vci
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|vccs
operator|->
name|count
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|vccs
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
operator|(
expr|struct
name|atmio_vcc
operator|*
operator|)
name|resp
operator|->
name|data
operator|=
name|vccs
operator|->
name|vccs
index|[
name|i
index|]
expr_stmt|;
name|free
argument_list|(
name|vccs
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATM_CPCS_INIT
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ngm_atm_cpcs_init
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ng_atm_cpcs_init
argument_list|(
name|node
argument_list|,
operator|(
expr|struct
name|ngm_atm_cpcs_init
operator|*
operator|)
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_ATM_CPCS_TERM
case|:
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ngm_atm_cpcs_term
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ng_atm_cpcs_term
argument_list|(
name|node
argument_list|,
operator|(
expr|struct
name|ngm_atm_cpcs_term
operator|*
operator|)
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_ATM_GET_STATS
case|:
block|{
name|struct
name|ngm_atm_stats
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|p
operator|=
operator|(
expr|struct
name|ngm_atm_stats
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|p
operator|->
name|in_packets
operator|=
name|priv
operator|->
name|in_packets
expr_stmt|;
name|p
operator|->
name|out_packets
operator|=
name|priv
operator|->
name|out_packets
expr_stmt|;
name|p
operator|->
name|in_errors
operator|=
name|priv
operator|->
name|in_errors
expr_stmt|;
name|p
operator|->
name|out_errors
operator|=
name|priv
operator|->
name|out_errors
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * HOOK MANAGEMENT  */
end_comment

begin_comment
comment|/*  * A new hook is create that will be connected to the node.  * Check, whether the name is one of the predefined ones.  * If not, create a new entry into the vcc list.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"input"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|input
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_RCVDATA
argument_list|(
name|hook
argument_list|,
name|ng_atm_rcvdrop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"output"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|output
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_RCVDATA
argument_list|(
name|hook
argument_list|,
name|ng_atm_rcvdrop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"orphans"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|orphans
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_RCVDATA
argument_list|(
name|hook
argument_list|,
name|ng_atm_rcvdrop
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate a new entry 	 */
name|vcc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vcc
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|vcc
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|vcc
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|vccs
argument_list|,
name|vcc
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"manage"
argument_list|)
operator|==
literal|0
condition|)
name|priv
operator|->
name|manage
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Connect. Set the peer to queuing.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|if
condition|(
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
operator|!=
name|NULL
condition|)
name|NG_HOOK_FORCE_QUEUE
argument_list|(
name|NG_HOOK_PEER
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disconnect a HOOK  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ngvcc
modifier|*
name|vcc
init|=
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
if|if
condition|(
name|vcc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|output
condition|)
block|{
name|priv
operator|->
name|output
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|input
condition|)
block|{
name|priv
operator|->
name|input
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|orphans
condition|)
block|{
name|priv
operator|->
name|orphans
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ng_atm: bad hook '%s'"
argument_list|,
name|NG_HOOK_NAME
argument_list|(
name|hook
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* don't terminate if we are detaching from the interface */
if|if
condition|(
operator|(
name|vcc
operator|->
name|flags
operator|&
name|VCC_OPEN
operator|)
operator|&&
name|priv
operator|->
name|ifp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cpcs_term
argument_list|(
name|priv
argument_list|,
name|vcc
operator|->
name|vpi
argument_list|,
name|vcc
operator|->
name|vci
argument_list|)
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vcc
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vcc
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
if|if
condition|(
name|hook
operator|==
name|priv
operator|->
name|manage
condition|)
name|priv
operator|->
name|manage
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * NODE MANAGEMENT  */
end_comment

begin_comment
comment|/*  * ATM interface attached - create a node and name it like the interface.  */
end_comment

begin_function
specifier|static
name|void
name|ng_atm_attach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|char
name|name
index|[
name|IFNAMSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|node_p
name|node
decl_stmt|;
name|struct
name|priv
modifier|*
name|priv
decl_stmt|;
name|KASSERT
argument_list|(
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: node alreay exists?"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|ng_atm_typestruct
argument_list|,
operator|&
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: can't create node for %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: can't allocate memory for %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|priv
operator|->
name|vccs
argument_list|)
expr_stmt|;
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
operator|=
name|node
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|node
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%s: can't name node %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ATM interface detached - destroy node.  */
end_comment

begin_function
specifier|static
name|void
name|ng_atm_detach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|IFP2NG
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|priv
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return;
name|NG_NODE_REALLY_DIE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|priv
operator|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|IFP2NG
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|ifp
operator|=
name|NULL
expr_stmt|;
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Shutdown the node. This is called from the shutdown message processing.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|struct
name|priv
modifier|*
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|nd_flags
operator|&
name|NG_REALLY_DIE
condition|)
block|{
comment|/* 		 * We are called from unloading the ATM driver. Really, 		 * really need to shutdown this node. The ifp was 		 * already handled in the detach routine. 		 */
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|NGATM_DEBUG
if|if
condition|(
operator|!
name|allow_shutdown
condition|)
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
else|else
block|{
name|IFP2NG
argument_list|(
name|priv
operator|->
name|ifp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 	 * We are persistant - reinitialize 	 */
name|node
operator|->
name|nd_flags
operator|&=
operator|~
name|NG_INVALID
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Nodes are constructed only via interface attaches.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_constructor
parameter_list|(
name|node_p
name|nodep
parameter_list|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************/
end_comment

begin_comment
comment|/*  * INITIALISATION  */
end_comment

begin_comment
comment|/*  * Loading and unloading of node type  *  * The assignments to the globals for the hooks should be ok without  * a special hook. The use pattern is generally: check that the pointer  * is not NULL, call the function. In the attach case this is no problem.  * In the detach case we can detach only when no ATM node exists. That  * means that there is no ATM interface anymore. So we are sure that  * we are not in the code path in if_atmsubr.c. To prevent someone  * from adding an interface after we have started to unload the node, we  * take the iflist lock so an if_attach will be blocked until we are done.  * XXX: perhaps the function pointers should be 'volatile' for this to work  * properly.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atm_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* 		 * Register function hooks 		 */
if|if
condition|(
name|ng_atm_attach_p
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
break|break;
block|}
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
name|ng_atm_attach_p
operator|=
name|ng_atm_attach
expr_stmt|;
name|ng_atm_detach_p
operator|=
name|ng_atm_detach
expr_stmt|;
name|ng_atm_output_p
operator|=
name|ng_atm_output
expr_stmt|;
name|ng_atm_input_p
operator|=
name|ng_atm_input
expr_stmt|;
name|ng_atm_input_orphan_p
operator|=
name|ng_atm_input_orphans
expr_stmt|;
name|ng_atm_message_p
operator|=
name|ng_atm_message
expr_stmt|;
comment|/* Create nodes for existing ATM interfaces */
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|==
name|IFT_ATM
condition|)
name|ng_atm_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
name|ng_atm_attach_p
operator|=
name|NULL
expr_stmt|;
name|ng_atm_detach_p
operator|=
name|NULL
expr_stmt|;
name|ng_atm_output_p
operator|=
name|NULL
expr_stmt|;
name|ng_atm_input_p
operator|=
name|NULL
expr_stmt|;
name|ng_atm_input_orphan_p
operator|=
name|NULL
expr_stmt|;
name|ng_atm_message_p
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|==
name|IFT_ATM
condition|)
name|ng_atm_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

