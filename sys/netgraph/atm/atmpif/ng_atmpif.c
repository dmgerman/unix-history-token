begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2003 Harti Brandt  * Copyright 2003 Vincent Jardin  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ATM Virtal Adapter Support  * --------------------------  *  * Loadable kernel module and netgraph support  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/atm/ng_atmpif.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/atm/atmpif/ng_atmpif_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_ATMPIF
argument_list|,
literal|"netgraph_vatmpif"
argument_list|,
literal|"netgraph HARP virtual Physical Interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_ATMPIF
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Local definitions  */
end_comment

begin_comment
comment|/*  * Protocol header  */
end_comment

begin_struct
struct|struct
name|vatmpif_header
block|{
comment|/* The cell header (minus the HEC) is contained in the least-significant 	 * 32-bits of a word. 	 */
name|uint32_t
name|cellhdr
decl_stmt|;
comment|/* Stored in network order */
comment|/* Let's use cellhdr = htonl(ATM_HDR_SET(vpi, vci, pt, clp)) 	 * and vpi = ATM_HDR_GET_VPI(ntohl(cellhdr)) 	 *     vci = ATM_HDR_GET_VCI(ntohl(cellhdr)) 	 *     pt  = ATM_HDR_GET_PT (ntohl(cellhdr)) 	 *     clp = ATM_HDR_GET_CLP(ntohl(cellhdr)) 	 */
name|int32_t
name|seq
decl_stmt|;
comment|/* sequence number in network byte order */
name|uint64_t
name|cookie
decl_stmt|;
comment|/* optional field */
name|uint8_t
name|aal
decl_stmt|;
comment|/* AAL */
name|uint8_t
name|__pad
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Local functions  */
end_comment

begin_comment
comment|/* Parse type for a MAC address */
end_comment

begin_decl_stmt
specifier|static
name|ng_parse_t
name|ng_macaddr_parse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_unparse_t
name|ng_macaddr_unparse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_mac_addr_type
init|=
block|{
name|parse
operator|:
name|ng_macaddr_parse
block|,
name|unparse
operator|:
name|ng_macaddr_unparse
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_atmpif_config */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atmpif_config_type_fields
index|[]
init|=
name|NG_ATMPIF_CONFIG_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atmpif_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atmpif_config_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_atmpif_link_status */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atmpif_link_status_type_fields
index|[]
init|=
name|NG_ATMPIF_LINK_STATUS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atmpif_link_status_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atmpif_link_status_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_atmpif_stats */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_atmpif_stats_type_fields
index|[]
init|=
name|NG_ATMPIF_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_atmpif_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_atmpif_stats_type_fields
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_atmpif_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_SET_CONFIG
block|,
literal|"setconfig"
block|,
name|mesgType
operator|:
operator|&
name|ng_atmpif_config_type
block|,
name|respType
operator|:
name|NULL
block|}
block|,
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|mesgType
operator|:
name|NULL
block|,
name|respType
operator|:
operator|&
name|ng_atmpif_config_type
block|}
block|,
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_GET_LINK_STATUS
block|,
literal|"getlinkstatus"
block|,
name|mesgType
operator|:
name|NULL
block|,
name|respType
operator|:
operator|&
name|ng_atmpif_link_status_type
block|}
block|,
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_GET_STATS
block|,
literal|"getstats"
block|,
name|mesgType
operator|:
name|NULL
block|,
name|respType
operator|:
operator|&
name|ng_atmpif_stats_type
block|}
block|,
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_CLR_STATS
block|,
literal|"clrstats"
block|,
name|mesgType
operator|:
name|NULL
block|,
name|respType
operator|:
name|NULL
block|}
block|,
block|{
name|NGM_ATMPIF_COOKIE
block|,
name|NGM_ATMPIF_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
name|mesgType
operator|:
name|NULL
block|,
name|respType
operator|:
operator|&
name|ng_atmpif_stats_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|vatmpif_nif_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|vatmpif_vcc_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Netgraph node methods  */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_atmpif_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_atmpif_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_atmpif_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_atmpif_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_atmpif_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_atmpif_disconnect
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ng_atmpif_mod_event
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Node type descriptor  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_atmpif_typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
comment|/* version */
name|NG_ATMPIF_NODE_TYPE
block|,
comment|/* name */
name|ng_atmpif_mod_event
block|,
comment|/* mod_event */
name|ng_atmpif_constructor
block|,
comment|/* constructor */
name|ng_atmpif_rcvmsg
block|,
comment|/* rcvmsg */
name|ng_atmpif_rmnode
block|,
comment|/* shutdown */
name|ng_atmpif_newhook
block|,
comment|/* newhook */
name|NULL
block|,
comment|/* findhook */
name|NULL
block|,
comment|/* connect */
name|ng_atmpif_rcvdata
block|,
comment|/* rcvdata */
name|ng_atmpif_disconnect
block|,
comment|/* disconnect */
name|ng_atmpif_cmdlist
block|,
comment|/* cmdlist */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|atmpif
argument_list|,
operator|&
name|ng_atmpif_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************** 		    NETGRAPH NODE METHODS ******************************************************************/
end_comment

begin_comment
comment|/*  * Node constructor  *  * Called at splnet()  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_constructor
parameter_list|(
name|node_p
name|nodep
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
comment|/* 	 * Allocate and initialize private info 	 */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_ATMPIF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|priv
operator|->
name|conf
operator|.
name|debug
operator|=
literal|0x00
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|pcr
operator|=
name|ATM_PCR_OC3C
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
comment|/* XXX : non unique bit */
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|1
index|]
operator|=
literal|0x09
expr_stmt|;
comment|/* XXX */
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|2
index|]
operator|=
literal|0xc0
expr_stmt|;
comment|/* XXX */
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|3
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|random
argument_list|()
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|4
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|random
argument_list|()
operator|&
literal|0x00ff00
operator|)
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|macaddr
operator|.
name|ma_data
index|[
literal|5
index|]
operator|=
call|(
name|u_char
call|)
argument_list|(
operator|(
name|random
argument_list|()
operator|&
literal|0x0000ff
operator|)
operator|>>
literal|0
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|nodep
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|priv
operator|->
name|node
operator|=
name|nodep
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Method for attaching a new hook  * A hook is a virtual ATM link.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* 	 * Check for a link hook 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_ATMPIF_HOOK_LINK
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* 		 * Do not create twice a link hook 		 */
if|if
condition|(
name|priv
operator|->
name|link
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|priv
operator|->
name|link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
operator|->
name|link
argument_list|)
argument_list|,
name|M_NETGRAPH_ATMPIF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|link
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 		 * Register as an HARP device 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|vatmpif_harp_attach
argument_list|(
name|node
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|priv
operator|->
name|link
argument_list|,
name|M_NETGRAPH_ATMPIF
argument_list|)
expr_stmt|;
name|priv
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|priv
operator|->
name|link
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Unknown hook name */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message from ngctl or the netgraph's API  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_ATMPIF_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_ATMPIF_GET_CONFIG
case|:
block|{
name|struct
name|ng_vatmpif_config
modifier|*
name|conf
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_vatmpif_config
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_vatmpif_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|conf
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
comment|/* no sanity checking needed */
break|break;
block|}
case|case
name|NGM_ATMPIF_SET_CONFIG
case|:
block|{
name|struct
name|ng_vatmpif_config
modifier|*
name|conf
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_vatmpif_config
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|priv
operator|->
name|conf
operator|=
operator|*
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATMPIF_GET_LINK_STATUS
case|:
block|{
name|struct
name|ng_vatmpif_hook
modifier|*
name|link
decl_stmt|;
name|struct
name|ng_atmpif_link_status
modifier|*
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|priv
operator|->
name|link
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|status
operator|=
operator|(
expr|struct
name|ng_atmpif_link_status
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|status
operator|->
name|InSeq
operator|=
name|link
operator|->
name|InSeq
expr_stmt|;
name|status
operator|->
name|OutSeq
operator|=
name|link
operator|->
name|OutSeq
expr_stmt|;
name|status
operator|->
name|cur_pcr
operator|=
name|link
operator|->
name|cur_pcr
expr_stmt|;
break|break;
block|}
case|case
name|NGM_ATMPIF_GET_STATS
case|:
case|case
name|NGM_ATMPIF_CLR_STATS
case|:
case|case
name|NGM_ATMPIF_GETCLR_STATS
case|:
block|{
name|struct
name|ng_vatmpif_hook
modifier|*
name|link
decl_stmt|;
if|if
condition|(
operator|(
name|link
operator|=
name|priv
operator|->
name|link
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
comment|/* Get/clear stats */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_ATMPIF_CLR_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|link
operator|->
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_ATMPIF_GET_STATS
condition|)
name|bzero
argument_list|(
operator|&
name|link
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Done */
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection.  * It shutdown the virtual ATM link however the node is kept.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* 	 * Deregister from the HARP stack 	 */
name|vatmpif_harp_detach
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* 	 * Free associated link information 	 */
name|KASSERT
argument_list|(
name|priv
operator|->
name|link
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no link"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
operator|->
name|link
argument_list|,
name|M_NETGRAPH_ATMPIF
argument_list|)
expr_stmt|;
name|priv
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
comment|/* Shutdown the physical interface */
name|priv
operator|->
name|vu_pif
operator|.
name|pif_flags
operator|&=
operator|~
name|PIF_UP
expr_stmt|;
comment|/* No more hooks, however I prefer to keep the node 	 * instead of going away 	 * However, if we are interested in removing it, let's 	 * call ng_rmnode(hook->node); here. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown node  *  * Free the private data.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Free private data */
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_ATMPIF
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Unref node */
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data  *  * Then vatmpif_harp_recv_drain will schedule a call into the kernel  * to process the atm_intrq.  * It means that it should be processing at splimp() if  * the node was a regular hw driver.  */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|vatmpif_header
modifier|*
name|h
decl_stmt|;
name|struct
name|vatmpif_header
name|hdrbuf
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Is the Physical Interface UP ? */
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|vu_pif
operator|.
name|pif_flags
operator|&
name|PIF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: down while %s"
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_name
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_unit
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* Sanity check header length */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
condition|)
block|{
name|priv
operator|->
name|link
operator|->
name|stats
operator|.
name|hva_st_ng
operator|.
name|ng_badpdu
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* Get the Virtual ATM Physical Interface header */
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
condition|)
block|{
comment|/* the common case */
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vatmpif_header
operator|*
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|hdrbuf
argument_list|)
expr_stmt|;
name|h
operator|=
operator|&
name|hdrbuf
expr_stmt|;
comment|/* allocated on the stack */
block|}
comment|/* 	 * Consume the vatmpif header 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Parse the header h 	 */
comment|/* 	 * duplication and out of order test. 	 * 	 *  . let's SEQ_MAX be the highest sequence number 	 *  . let's assume that h->seq = SEQ_MAX, (1) 	 */
if|if
condition|(
name|ntohl
argument_list|(
name|h
operator|->
name|seq
argument_list|)
operator|<
name|priv
operator|->
name|link
operator|->
name|InSeq
condition|)
block|{
comment|/*  . is false due to (1) */
comment|/* duplicate or out of order */
name|priv
operator|->
name|link
operator|->
name|stats
operator|.
name|hva_st_ng
operator|.
name|ng_errseq
operator|++
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/*  . then the mbuf is not dropped */
comment|/* PDUs have been lost ?? */
if|if
condition|(
name|priv
operator|->
name|link
operator|->
name|InSeq
operator|<
name|ntohl
argument_list|(
name|h
operator|->
name|seq
argument_list|)
condition|)
block|{
comment|/*  . it is true only if a PDU has been lost, 		 *  . else due to (1) priv->link->InSeq is 		 *  . already equal to SEQ_MAX.  		 */
name|priv
operator|->
name|link
operator|->
name|stats
operator|.
name|hva_st_ng
operator|.
name|ng_lostpdu
operator|++
expr_stmt|;
name|priv
operator|->
name|link
operator|->
name|InSeq
operator|=
name|ntohl
argument_list|(
name|h
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
comment|/* Save the sequence number */
name|priv
operator|->
name|link
operator|->
name|InSeq
operator|=
name|ntohl
argument_list|(
name|h
operator|->
name|seq
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/*  . it leads to InSeq = SEQ_MAX + 1 = SEQ_MIN */
comment|/*  . it means that InSeq is always the next intended 	 *  . sequence number if none is lost, doesn't it ? 	 */
comment|/* 	 * Send the packet to the stack. 	 */
name|priv
operator|->
name|link
operator|->
name|stats
operator|.
name|hva_st_ng
operator|.
name|ng_rx_pdu
operator|++
expr_stmt|;
name|error
operator|=
name|vatmpif_harp_recv_drain
argument_list|(
name|priv
argument_list|,
name|m
argument_list|,
name|ATM_HDR_GET_VPI
argument_list|(
name|ntohl
argument_list|(
name|h
operator|->
name|cellhdr
argument_list|)
argument_list|)
argument_list|,
name|ATM_HDR_GET_VCI
argument_list|(
name|ntohl
argument_list|(
name|h
operator|->
name|cellhdr
argument_list|)
argument_list|)
argument_list|,
name|ATM_HDR_GET_PT
argument_list|(
name|ntohl
argument_list|(
name|h
operator|->
name|cellhdr
argument_list|)
argument_list|)
argument_list|,
name|ATM_HDR_GET_CLP
argument_list|(
name|ntohl
argument_list|(
name|h
operator|->
name|cellhdr
argument_list|)
argument_list|)
argument_list|,
name|h
operator|->
name|aal
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|drop
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit data. Called by the HARP's outpout function. You should  * notice that the return value is not returned upward by the HARP  * stack. It is only used in order to update the stats.  */
end_comment

begin_function
name|int
name|ng_atmpif_transmit
parameter_list|(
specifier|const
name|priv_p
name|priv
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|vpi
parameter_list|,
name|uint16_t
name|vci
parameter_list|,
name|uint8_t
name|pt
parameter_list|,
name|uint8_t
name|clp
parameter_list|,
name|Vatmpif_aal
name|aal
parameter_list|)
block|{
name|struct
name|vatmpif_header
modifier|*
name|h
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Is the Physical Interface UP ? */
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|vu_pif
operator|.
name|pif_flags
operator|&
name|PIF_UP
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: down while %s"
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_name
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_unit
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
comment|/* If the hook is not connected, free the mbuf */
if|if
condition|(
name|priv
operator|->
name|link
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: no hook while %s"
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_name
argument_list|,
name|priv
operator|->
name|vu_pif
operator|.
name|pif_unit
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vatmpif_header
operator|*
argument_list|)
expr_stmt|;
comment|/* htonl is linear */
name|h
operator|->
name|cellhdr
operator|=
name|htonl
argument_list|(
name|ATM_HDR_SET_VPI
argument_list|(
name|vpi
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|cellhdr
operator|+=
name|htonl
argument_list|(
name|ATM_HDR_SET_VCI
argument_list|(
name|vci
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|cellhdr
operator|+=
name|htonl
argument_list|(
name|ATM_HDR_SET_PT
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|cellhdr
operator|+=
name|htonl
argument_list|(
name|ATM_HDR_SET_CLP
argument_list|(
name|clp
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|aal
operator|=
name|aal
expr_stmt|;
name|priv
operator|->
name|link
operator|->
name|OutSeq
operator|++
expr_stmt|;
name|h
operator|->
name|seq
operator|=
name|htonl
argument_list|(
name|priv
operator|->
name|link
operator|->
name|OutSeq
argument_list|)
expr_stmt|;
name|h
operator|->
name|cookie
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IS_VATMPIF_DEBUG_PACKET
argument_list|(
name|priv
argument_list|)
condition|)
name|atm_pdu_print
argument_list|(
name|m
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Send it out to the "link" hook */
name|priv
operator|->
name|link
operator|->
name|stats
operator|.
name|hva_st_ng
operator|.
name|ng_tx_pdu
operator|++
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|link
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|drop
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************  			MAC Address parser  *****************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_macaddr_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
specifier|const
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
specifier|const
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|eptr
decl_stmt|;
name|u_long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
literal|6
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|=
name|strtoul
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|0xff
operator|||
name|eptr
operator|==
name|s
operator|+
operator|*
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|buf
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|val
expr_stmt|;
operator|*
name|off
operator|=
operator|(
name|eptr
operator|-
name|s
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|6
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|':'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
operator|*
name|off
operator|)
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|buflen
operator|=
literal|6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_macaddr_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|cbuf
argument_list|,
name|cbuflen
argument_list|,
literal|"%02x:%02x:%02x:%02x:%02x:%02x"
argument_list|,
name|data
index|[
operator|*
name|off
index|]
argument_list|,
name|data
index|[
operator|*
name|off
operator|+
literal|1
index|]
argument_list|,
name|data
index|[
operator|*
name|off
operator|+
literal|2
index|]
argument_list|,
name|data
index|[
operator|*
name|off
operator|+
literal|3
index|]
argument_list|,
name|data
index|[
operator|*
name|off
operator|+
literal|4
index|]
argument_list|,
name|data
index|[
operator|*
name|off
operator|+
literal|5
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|cbuflen
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
operator|*
name|off
operator|+=
literal|6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * this holds all the stuff that should be done at load time   */
end_comment

begin_function
specifier|static
name|int
name|ng_atmpif_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|vatmpif_nif_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"vatmpif nif"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atm_nif
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vatmpif_nif_zone
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|vatmpif_vcc_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"vatmpif vcc"
argument_list|,
sizeof|sizeof
argument_list|(
name|Vatmpif_vcc
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vatmpif_vcc_zone
operator|==
name|NULL
condition|)
block|{
name|uma_zdestroy
argument_list|(
name|vatmpif_nif_zone
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
name|uma_zdestroy
argument_list|(
name|vatmpif_nif_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|vatmpif_vcc_zone
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

