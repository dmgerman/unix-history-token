begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2003 Harti Brandt  * Copyright 2003 Vincent Jardin  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ATM Virtal Adapter Support  * --------------------------  *  * API between HARP and Netgraph  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/port.h>
end_include

begin_include
include|#
directive|include
file|<netatm/queue.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sys.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_cm.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_vc.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_if.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_sap.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_stack.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_var.h>
end_include

begin_include
include|#
directive|include
file|<netatm/atm_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/atm/ng_atmpif.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/atm/atmpif/ng_atmpif_var.h>
end_include

begin_comment
comment|/*  * Local definitions  */
end_comment

begin_comment
comment|/*  * Local methods  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vatmpif_nunits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ATM Interface services  *  * this virtual device does not use a soft SAR of the AAL5 PDU, neither  * of the AAL3/4 PDU.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|vatmpif_svaal5
init|=
block|{
name|sd_next
operator|:
name|NULL
block|,
name|sd_sap
operator|:
name|SAP_CPCS_AAL5
block|,
name|sd_flag
operator|:
name|SDF_TERM
block|,
comment|/* no soft SAR */
name|sd_inst
operator|:
name|atm_dev_inst
block|,
name|sd_lower
operator|:
name|atm_dev_lower
block|,
name|sd_upper
operator|:
name|NULL
block|,
name|sd_toku
operator|:
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|vatmpif_svaal4
init|=
block|{
name|sd_next
operator|:
operator|&
name|vatmpif_svaal5
block|,
name|sd_sap
operator|:
name|SAP_CPCS_AAL3_4
block|,
name|sd_flag
operator|:
name|SDF_TERM
block|,
comment|/* no soft SAR */
name|sd_inst
operator|:
name|atm_dev_inst
block|,
name|sd_lower
operator|:
name|atm_dev_lower
block|,
name|sd_upper
operator|:
name|NULL
block|,
name|sd_toku
operator|:
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
name|vatmpif_svaal0
init|=
block|{
name|sd_next
operator|:
operator|&
name|vatmpif_svaal4
block|,
name|sd_sap
operator|:
name|SAP_ATM
block|,
name|sd_flag
operator|:
name|SDF_TERM
block|,
comment|/* no soft SAR */
name|sd_inst
operator|:
name|atm_dev_inst
block|,
name|sd_lower
operator|:
name|atm_dev_lower
block|,
name|sd_upper
operator|:
name|NULL
block|,
name|sd_toku
operator|:
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|stack_defn
modifier|*
name|vatmpif_services
init|=
operator|&
name|vatmpif_svaal0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************************************************** 		    HARP API METHODS ******************************************************************/
end_comment

begin_comment
comment|/*  * Local methods  */
end_comment

begin_function_decl
specifier|static
name|int
name|vatmpif_harp_ioctl
parameter_list|(
name|int
name|code
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vatmpif_harp_instvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vatmpif_harp_openvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vatmpif_harp_closevcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vatmpif_harp_output
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|atm_intr_t
name|vatmpif_harp_recv_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach an virtual ATM physical inteface with the HARP stack  *  * Each virtual ATM device interface must register itself here  * upon completing the netgraph node constructor.  *  * Arguments:  * 	node	pointer on the netgraph node  *  * Returns:  * 	0	successful  * 	errno	failed - reason indicated  */
end_comment

begin_function
name|int
name|vatmpif_harp_attach
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
decl_stmt|;
specifier|static
name|int
name|unit
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Sanity check 	 */
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Get the virtual unit structure 	 */
name|vup
operator|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|vup
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Start initializing the HARP binding 	 */
name|vup
operator|->
name|vu_unit
operator|=
name|unit
expr_stmt|;
comment|/* 9188 bytes: Default ATM network interface MTU + LLC/SNAP header */
name|vup
operator|->
name|vu_mtu
operator|=
name|ATM_NIF_MTU
operator|+
literal|8
expr_stmt|;
name|vup
operator|->
name|vu_vcc_zone
operator|=
name|vatmpif_vcc_zone
expr_stmt|;
name|vup
operator|->
name|vu_nif_zone
operator|=
name|vatmpif_nif_zone
expr_stmt|;
name|vup
operator|->
name|vu_ioctl
operator|=
name|vatmpif_harp_ioctl
expr_stmt|;
name|vup
operator|->
name|vu_instvcc
operator|=
name|vatmpif_harp_instvcc
expr_stmt|;
name|vup
operator|->
name|vu_openvcc
operator|=
name|vatmpif_harp_openvcc
expr_stmt|;
name|vup
operator|->
name|vu_closevcc
operator|=
name|vatmpif_harp_closevcc
expr_stmt|;
name|vup
operator|->
name|vu_output
operator|=
name|vatmpif_harp_output
expr_stmt|;
name|vup
operator|->
name|vu_softc
operator|=
name|vup
expr_stmt|;
comment|/* 	 * Consider this virtual unit assigned 	 */
name|unit
operator|++
expr_stmt|;
comment|/* 	 * Get our device type and setup the adapter config info 	 * - at least as much as we can 	 */
name|vup
operator|->
name|vu_config
operator|.
name|ac_vendor
operator|=
name|VENDOR_NETGRAPH
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_vendapi
operator|=
name|VENDAPI_NETGRAPH_1
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_device
operator|=
name|DEV_VATMPIF
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_media
operator|=
name|MEDIA_VIRTUAL
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_serial
operator|=
operator|(
name|u_long
operator|)
name|node
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_bustype
operator|=
name|BUS_VIRTUAL
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_busslot
operator|=
name|NGM_ATMPIF_COOKIE
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_ram
operator|=
operator|(
name|u_long
operator|)
name|node
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_ramsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
expr_stmt|;
name|vup
operator|->
name|vu_config
operator|.
name|ac_macaddr
operator|=
name|vup
operator|->
name|conf
operator|.
name|macaddr
expr_stmt|;
name|snprintf
argument_list|(
name|vup
operator|->
name|vu_config
operator|.
name|ac_hard_vers
argument_list|,
sizeof|sizeof
argument_list|(
name|vup
operator|->
name|vu_config
operator|.
name|ac_hard_vers
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"Virt. ATM 1.0"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|vup
operator|->
name|vu_config
operator|.
name|ac_firm_vers
argument_list|,
sizeof|sizeof
argument_list|(
name|vup
operator|->
name|vu_config
operator|.
name|ac_firm_vers
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|__FreeBSD__
argument_list|)
expr_stmt|;
comment|/* 	 * Set the interface capabilities 	 */
name|vup
operator|->
name|vu_pif
operator|.
name|pif_maxvpi
operator|=
name|VATMPIF_MAX_VPI
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_maxvci
operator|=
name|VATMPIF_MAX_VCI
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_pcr
operator|=
name|vup
operator|->
name|conf
operator|.
name|pcr
expr_stmt|;
comment|/* 	 * Register this interface with ATM core services 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|atm_physif_register
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|vup
argument_list|,
name|VATMPIF_DEV_NAME
argument_list|,
name|vatmpif_services
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Registration failed - back everything out 		 * 		 * The netgraph node must not be created. 		 */
return|return
operator|(
name|err
operator|)
return|;
block|}
name|vatmpif_nunits
operator|++
expr_stmt|;
comment|/* 	 * Mark device initialization completed 	 */
name|vup
operator|->
name|vu_flags
operator||=
name|CUF_INITED
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Halt driver processing  *  * This will be called just prior the destruction of the Netgraph's node.  *  * Arguments:  * 	node	pointer on the netgraph node  *  * Returns:  * 	0	detach was successful  * 	errno	detach failed - reason indicated  */
end_comment

begin_function
name|int
name|vatmpif_harp_detach
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
init|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Deregister device from kernel services 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|atm_physif_deregister
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|vup
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|vatmpif_nunits
operator|--
expr_stmt|;
comment|/* 	 * Clear device initialized 	 */
name|vup
operator|->
name|vu_flags
operator|&=
operator|~
name|CUF_INITED
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle netatm core service interface ioctl requests  *  * Arguments:  * 	code		ioctl function (sub)code  * 	data		data to/from ioctl  * 	arg		optional code-specific argument  *  * Returns:  * 	0		request processed successfully  * 	errno		request failed - reason code  */
end_comment

begin_function
specifier|static
name|int
name|vatmpif_harp_ioctl
parameter_list|(
name|int
name|code
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|struct
name|atminfreq
modifier|*
name|aip
init|=
operator|(
expr|struct
name|atminfreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|atm_pif
modifier|*
name|pip
decl_stmt|;
name|Vatmpif_unit
modifier|*
name|vup
decl_stmt|;
name|caddr_t
name|buf
init|=
name|aip
operator|->
name|air_buf_addr
decl_stmt|;
name|struct
name|air_vinfo_rsp
modifier|*
name|avr
decl_stmt|;
name|size_t
name|count
decl_stmt|,
name|len
decl_stmt|,
name|buf_len
init|=
name|aip
operator|->
name|air_buf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|char
name|ifname
index|[
literal|2
operator|*
name|IFNAMSIZ
index|]
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"%s: code=%d, opcode=%d\n"
argument_list|,
name|__func__
argument_list|,
name|code
argument_list|,
name|aip
operator|->
name|air_opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|aip
operator|->
name|air_opcode
condition|)
block|{
case|case
name|AIOCS_INF_VST
case|:
comment|/* 		 * Get vendor statistics 		 */
name|pip
operator|=
operator|(
expr|struct
name|atm_pif
operator|*
operator|)
name|arg
expr_stmt|;
name|vup
operator|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|pip
expr_stmt|;
if|if
condition|(
name|pip
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|snprintf
argument_list|(
name|ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifname
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|pip
operator|->
name|pif_name
argument_list|,
name|pip
operator|->
name|pif_unit
argument_list|)
expr_stmt|;
comment|/* 		 * Cast response structure onto user's buffer 		 */
name|avr
operator|=
operator|(
expr|struct
name|air_vinfo_rsp
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* 		 * How lare is the response structure ? 		 */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|air_vinfo_rsp
argument_list|)
expr_stmt|;
comment|/* 		 * Sanity check - enough room for response structure 		 */
if|if
condition|(
name|buf_len
operator|<
name|len
condition|)
return|return
name|ENOSPC
return|;
comment|/* 		 * Copy interface name into response structure 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
name|ifname
argument_list|,
name|avr
operator|->
name|avsp_intf
argument_list|,
name|IFNAMSIZ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Advance the buffer address and decrement the size 		 */
name|buf
operator|+=
name|len
expr_stmt|;
name|buf_len
operator|-=
name|len
expr_stmt|;
comment|/* 		 * Get the vendor stats 		 */
comment|/* vup->vu_stats */
comment|/* 		 * Stick as much of it as we have room for 		 * into the response 		 */
name|count
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|Vatmpif_stats
argument_list|)
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
comment|/* 		 * Copy stats into user's buffer. Return value is 		 * amount of data copied. 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vup
operator|->
name|vu_stats
argument_list|,
name|buf
argument_list|,
name|buf_len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|buf
operator|+=
name|count
expr_stmt|;
name|buf_len
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|Vatmpif_stats
argument_list|)
condition|)
name|err
operator|=
name|ENOSPC
expr_stmt|;
comment|/* 		 * Record amount we are returning as vendor info... 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|count
argument_list|,
operator|&
name|avr
operator|->
name|avsp_len
argument_list|,
sizeof|sizeof
argument_list|(
name|count
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * Update the reply pointers and lengths 		 */
name|aip
operator|->
name|air_buf_addr
operator|=
name|buf
expr_stmt|;
name|aip
operator|->
name|air_buf_len
operator|=
name|buf_len
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get CBR/VBR/ABR/UBR from bearer attribute  *  * Arguments:  * 		bearer		T_ATM_BEARER_CAP option value structure  *  * Returns:  * 		Driver traffic class  */
end_comment

begin_function
specifier|static
name|Vatmpif_traffic_type
name|vatmpif_bearerclass
parameter_list|(
name|struct
name|attr_bearer
modifier|*
name|bearer
parameter_list|)
block|{
switch|switch
condition|(
name|bearer
operator|->
name|v
operator|.
name|bearer_class
condition|)
block|{
case|case
name|T_ATM_CLASS_A
case|:
return|return
operator|(
name|VATMPIF_TRAF_CBR
operator|)
return|;
case|case
name|T_ATM_CLASS_C
case|:
return|return
operator|(
name|VATMPIF_TRAF_VBR
operator|)
return|;
case|case
name|T_ATM_CLASS_X
case|:
switch|switch
condition|(
name|bearer
operator|->
name|v
operator|.
name|traffic_type
condition|)
block|{
case|case
name|T_ATM_CBR
case|:
return|return
operator|(
name|VATMPIF_TRAF_CBR
operator|)
return|;
case|case
name|T_ATM_VBR
case|:
return|return
operator|(
name|VATMPIF_TRAF_VBR
operator|)
return|;
case|case
name|T_ATM_ABR
case|:
return|return
operator|(
name|VATMPIF_TRAF_ABR
operator|)
return|;
case|case
name|T_ATM_NULL
case|:
case|case
name|T_ATM_UBR
case|:
return|return
operator|(
name|VATMPIF_TRAF_UBR
operator|)
return|;
block|}
break|break;
block|}
comment|/* never reached */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: could not determine the traffic type.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|VATMPIF_TRAF_UBR
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * VCC Stack Instantiation  *  * This function is called via the common driver code during a device VCC  * stack instantiation. The common code has already validated some of  * the request so we just need to check a few more VATMPIF-specific details.  *  * Arguments:  * 		cup		pointer to device common unit  * 		cvp		pointer to common VCC entry  *  * Returns:  * 		0		instantiation successful  * 		errno	instantiation failed - reason indicated  */
end_comment

begin_function
specifier|static
name|int
name|vatmpif_harp_instvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
init|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Vatmpif_vcc
modifier|*
name|vvp
init|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
init|=
operator|&
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_attr
decl_stmt|;
name|int32_t
name|pcr
init|=
literal|0
decl_stmt|;
name|int32_t
name|scr
init|=
literal|0
decl_stmt|;
name|Vatmpif_traffic_type
name|traffic
init|=
name|VATMPIF_TRAF_UBR
decl_stmt|;
name|ATM_DEBUG3
argument_list|(
literal|"%s: vup=%p, vvp=%p\n"
argument_list|,
name|__func__
argument_list|,
name|vup
argument_list|,
name|vvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|traffic
operator|.
name|tag
operator|==
name|T_ATM_PRESENT
condition|)
block|{
name|pcr
operator|=
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
name|scr
operator|=
name|ap
operator|->
name|traffic
operator|.
name|v
operator|.
name|forward
operator|.
name|SCR_all_traffic
expr_stmt|;
block|}
if|if
condition|(
name|pcr
operator|<
literal|0
condition|)
name|pcr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scr
operator|<
literal|0
condition|)
name|scr
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|ap
operator|->
name|bearer
operator|.
name|tag
operator|==
name|T_ATM_PRESENT
argument_list|,
operator|(
literal|"Bearer tag is required"
operator|)
argument_list|)
expr_stmt|;
name|traffic
operator|=
name|vatmpif_bearerclass
argument_list|(
operator|&
name|ap
operator|->
name|bearer
argument_list|)
expr_stmt|;
comment|/* Guarantee PCR of the PVC with CBR */
if|if
condition|(
name|traffic
operator|==
name|VATMPIF_TRAF_CBR
operator|&&
name|vup
operator|->
name|vu_cur_pcr
operator|+
name|pcr
operator|>
name|vup
operator|->
name|vu_pif
operator|.
name|pif_pcr
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Guarantee SCR of the PVC with VBR */
if|if
condition|(
name|traffic
operator|==
name|VATMPIF_TRAF_VBR
operator|&&
name|vup
operator|->
name|vu_cur_pcr
operator|+
name|scr
operator|>
name|vup
operator|->
name|vu_pif
operator|.
name|pif_pcr
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Validate requested AAL 	 */
name|KASSERT
argument_list|(
name|ap
operator|->
name|aal
operator|.
name|tag
operator|==
name|T_ATM_PRESENT
argument_list|,
operator|(
literal|"AAL tag is required"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|ATM_AAL0
case|:
break|break;
case|case
name|ATM_AAL1
case|:
break|break;
case|case
name|ATM_AAL2
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|ATM_AAL3_4
case|:
if|if
condition|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|forward_max_SDU_size
operator|>
name|vup
operator|->
name|vu_mtu
operator|||
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal4
operator|.
name|backward_max_SDU_size
operator|>
name|vup
operator|->
name|vu_mtu
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|ATM_AAL5
case|:
if|if
condition|(
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|forward_max_SDU_size
operator|>
name|vup
operator|->
name|vu_mtu
operator|||
name|ap
operator|->
name|aal
operator|.
name|v
operator|.
name|aal5
operator|.
name|backward_max_SDU_size
operator|>
name|vup
operator|->
name|vu_mtu
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a VCC  *  * This function is called via the common driver code after receiving a  * stack *_INIT command. The common has already validated most of  * the request so we just need to check a few more VATMPIF-specific details.  * Then we just forward to the Netgraph node.  *   * Called at splimp.  *  * Arguments:  * 	cup	pointer to device common unit  * 	cvp	pointer to common VCC entry  *  * Returns:  * 	0    	open successful  * 	errno	open failed - reason indicated  */
end_comment

begin_function
specifier|static
name|int
name|vatmpif_harp_openvcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
init|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Vatmpif_vcc
modifier|*
name|vvp
init|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
init|=
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_vcc
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
init|=
operator|&
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_attr
decl_stmt|;
name|ATM_DEBUG5
argument_list|(
literal|"%s: vup=%p, vvp=%p, vcc=(%d,%d)\n"
argument_list|,
name|__func__
argument_list|,
name|vup
argument_list|,
name|vvp
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|)
expr_stmt|;
comment|/* 	 * We only need to open incoming VC's so outbound VC's 	 * just get set to CVS_ACTIVE state. 	 */
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_IN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Set the state and return - nothing else needed 		 */
name|vvp
operator|->
name|vv_state
operator|=
name|CVS_ACTIVE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Set the AAL and traffic 	 */
switch|switch
condition|(
name|ap
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|ATM_AAL0
case|:
name|vvp
operator|->
name|vv_aal
operator|=
name|VATMPIF_AAL_0
expr_stmt|;
break|break;
case|case
name|ATM_AAL2
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|ATM_AAL3_4
case|:
name|vvp
operator|->
name|vv_aal
operator|=
name|VATMPIF_AAL_4
expr_stmt|;
break|break;
case|case
name|ATM_AAL5
case|:
name|vvp
operator|->
name|vv_aal
operator|=
name|VATMPIF_AAL_5
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vvp
operator|->
name|vv_traffic_type
operator|=
name|vatmpif_bearerclass
argument_list|(
operator|&
name|ap
operator|->
name|bearer
argument_list|)
expr_stmt|;
name|vvp
operator|->
name|vv_traffic
operator|=
name|ap
operator|->
name|traffic
operator|.
name|v
expr_stmt|;
switch|switch
condition|(
name|vvp
operator|->
name|vv_traffic_type
condition|)
block|{
case|case
name|VATMPIF_TRAF_ABR
case|:
comment|/* TODO */
case|case
name|VATMPIF_TRAF_UBR
case|:
break|break;
case|case
name|VATMPIF_TRAF_VBR
case|:
name|vup
operator|->
name|vu_cur_pcr
operator|+=
name|vvp
operator|->
name|vv_traffic
operator|.
name|forward
operator|.
name|SCR_all_traffic
expr_stmt|;
break|break;
case|case
name|VATMPIF_TRAF_CBR
case|:
name|vup
operator|->
name|vu_cur_pcr
operator|+=
name|vvp
operator|->
name|vv_traffic
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
break|break;
block|}
comment|/* 	 * Indicate VC active 	 */
name|vvp
operator|->
name|vv_state
operator|=
name|CVS_ACTIVE
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Close a VCC  *  * This function is called via the common driver code after receiving a  * stack *_TERM command. The common code has already validated most of  * the request so we just need to check a few more VATMPIF-specific detail.  * Then we just remove the entry from the list.  *  * Arguments:  * 	cup	pointer to device common unit  * 	cvp	pointer to common VCC entry  *  * Returns:  * 	0    	close successful  * 	errno	close failed - reason indicated  */
end_comment

begin_function
specifier|static
name|int
name|vatmpif_harp_closevcc
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
init|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Vatmpif_vcc
modifier|*
name|vvp
init|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
init|=
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_vcc
decl_stmt|;
comment|/*  	 * If this is an outbound only VCI, then we can close 	 * immediately. 	 */
if|if
condition|(
operator|(
name|vcp
operator|->
name|vc_type
operator|&
name|VCC_IN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The state will be set to TERM when we return 		 * to the *_TERM caller. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|vvp
operator|->
name|vv_traffic_type
condition|)
block|{
case|case
name|VATMPIF_TRAF_ABR
case|:
comment|/* TODO */
case|case
name|VATMPIF_TRAF_UBR
case|:
break|break;
case|case
name|VATMPIF_TRAF_VBR
case|:
name|vup
operator|->
name|vu_cur_pcr
operator|-=
name|vvp
operator|->
name|vv_traffic
operator|.
name|forward
operator|.
name|SCR_all_traffic
expr_stmt|;
break|break;
case|case
name|VATMPIF_TRAF_CBR
case|:
name|vup
operator|->
name|vu_cur_pcr
operator|-=
name|vvp
operator|->
name|vv_traffic
operator|.
name|forward
operator|.
name|PCR_all_traffic
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Output a PDU  *  * This function is called via the common driver code after receiving a  * stack *_DATA* command. The command code has already validated most of  * the request so we just need to check a few more VATMPIF-specific detail.  * Then we just forward the transmit mbuf to the Netgraph node.  *  * Arguments:  * 	cup	pointer to device common  * 	cvp	pointer to common VCC entry  * 	m	pointer to output PDU buffer chain head  *  * Returns:  * 	none  */
end_comment

begin_function
specifier|static
name|void
name|vatmpif_harp_output
parameter_list|(
name|Cmn_unit
modifier|*
name|cup
parameter_list|,
name|Cmn_vcc
modifier|*
name|cvp
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|)
block|{
name|Vatmpif_unit
modifier|*
name|vup
init|=
operator|(
name|Vatmpif_unit
operator|*
operator|)
name|cup
decl_stmt|;
name|Vatmpif_vcc
modifier|*
name|vvp
init|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|cvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
init|=
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_vcc
decl_stmt|;
name|Atm_attributes
modifier|*
name|ap
init|=
operator|&
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_attr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u_long
name|pdulen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_VATMPIF_DEBUG_PACKET
argument_list|(
name|vup
argument_list|)
condition|)
name|atm_dev_pdu_print
argument_list|(
name|cup
argument_list|,
name|cvp
argument_list|,
name|m
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Get packet PDU length 	 */
name|KB_PLENGET
argument_list|(
name|m
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
name|err
operator|=
name|ng_atmpif_transmit
argument_list|(
name|vup
argument_list|,
name|m
argument_list|,
name|vcp
operator|->
name|vc_vpi
argument_list|,
name|vcp
operator|->
name|vc_vci
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|aal
operator|.
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Now collect some statistics 	 */
if|if
condition|(
name|err
condition|)
block|{
name|vup
operator|->
name|vu_pif
operator|.
name|pif_oerrors
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_oerrors
operator|++
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
name|ANIF2IFP
argument_list|(
name|vcp
operator|->
name|vc_nif
argument_list|)
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/*    		 * Good transmission 		 */
switch|switch
condition|(
name|ap
operator|->
name|aal
operator|.
name|type
condition|)
block|{
case|case
name|VATMPIF_AAL_0
case|:
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_tx_rawcell
operator|++
expr_stmt|;
break|break;
case|case
name|VATMPIF_AAL_4
case|:
comment|/* TODO */
break|break;
case|case
name|VATMPIF_AAL_5
case|:
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_xmit
operator|+=
operator|(
name|pdulen
operator|+
literal|47
operator|)
operator|/
literal|48
expr_stmt|;
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_pdu_xmit
operator|++
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: unknown AAL while %s"
argument_list|,
name|vup
operator|->
name|vu_pif
operator|.
name|pif_name
argument_list|,
name|vup
operator|->
name|vu_pif
operator|.
name|pif_unit
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|vup
operator|->
name|vu_pif
operator|.
name|pif_opdus
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_obytes
operator|+=
name|pdulen
expr_stmt|;
if|if
condition|(
name|vvp
condition|)
block|{
name|vcp
operator|=
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
name|vcp
operator|->
name|vc_opdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_obytes
operator|+=
name|pdulen
expr_stmt|;
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_obytes
operator|+=
name|pdulen
expr_stmt|;
name|ANIF2IFP
argument_list|(
name|vcp
operator|->
name|vc_nif
argument_list|)
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ANIF2IFP
argument_list|(
name|vcp
operator|->
name|vc_nif
argument_list|)
operator|->
name|if_obytes
operator|+=
name|pdulen
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Pass Incoming PDU up to the HARP stack  *  * This function is called via the core ATM interrupt queue callback  * set in vatmpif_harp_recv_drain(). It will pass the supplied incoming  * PDU up the incoming VCC's stack.  *  * Arguments:  * 	tok	token to identify stack instantiation  * 	m  	pointer to incoming PDU buffer chain  *  * Returns:  * 	none  */
end_comment

begin_function
specifier|static
name|void
name|vatmpif_harp_recv_stack
parameter_list|(
name|void
modifier|*
name|tok
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|)
block|{
name|Vatmpif_vcc
modifier|*
name|vvp
init|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|tok
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Send the data up the stack 	 */
name|STACK_CALL
argument_list|(
name|CPCS_UNITDATA_SIG
argument_list|,
name|vvp
operator|->
name|vv_upper
argument_list|,
name|vvp
operator|->
name|vv_toku
argument_list|,
name|vvp
operator|->
name|vv_connvc
argument_list|,
operator|(
name|intptr_t
operator|)
name|m
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain Receive Queue  *  * The function will process all completed entries at the head of the  * receive queue. The received segments will be linked into a received  * PDU buffer cahin and it will then be passed up the PDU's VCC stack  * function processing by the next higher protocol layer.  *  * May be called in interrupt state.  * Must be called with interrupts locked out.  *  * Arguments:  * 	vup	pointer to the virtual device structure  * 	m	pointer to incoming PDU buffer chain  * 	vpi	Virtual Path Identifier  * 	vci	Virtual Channel Identifier (host order)  * 	pt	Payload Type Identifier (3 bit)  *	 		ATM_PT_USER_SDU0  * 			ATM_PT_USER_SDU1  * 			ATM_PT_USER_CONG_SDU0  *	 		ATM_PT_USER_CONG_SDU1  * 			ATM_PT_NONUSER  * 			ATM_PT_OAMF5_SEG  * 			ATM_PT_OAMF5_E2E  * 	clp	Cell Loss Priority (1 bit)  *  * Returns:  * 	0    	close successful  * 	errno	close failed - reason indicated  */
end_comment

begin_function
name|int
name|vatmpif_harp_recv_drain
parameter_list|(
name|Vatmpif_unit
modifier|*
name|vup
parameter_list|,
name|KBuffer
modifier|*
name|m
parameter_list|,
name|uint8_t
name|vpi
parameter_list|,
name|uint16_t
name|vci
parameter_list|,
name|uint8_t
name|pt
parameter_list|,
name|uint8_t
name|clp
parameter_list|,
name|Vatmpif_aal
name|aal
parameter_list|)
block|{
name|Vatmpif_vcc
modifier|*
name|vvp
decl_stmt|;
name|struct
name|vccb
modifier|*
name|vcp
decl_stmt|;
name|u_long
name|pdulen
init|=
literal|0
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * Locate incoming VCC for this PDU 	 */
name|vvp
operator|=
operator|(
name|Vatmpif_vcc
operator|*
operator|)
name|atm_dev_vcc_find
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|vup
argument_list|,
name|vpi
argument_list|,
name|vci
argument_list|,
name|VCC_IN
argument_list|)
expr_stmt|;
if|if
condition|(
name|vvp
operator|==
name|NULL
condition|)
block|{
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_rx_novcc
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
switch|switch
condition|(
name|aal
condition|)
block|{
case|case
name|VATMPIF_AAL_0
case|:
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_rx_rawcell
operator|++
expr_stmt|;
break|break;
case|case
name|VATMPIF_AAL_4
case|:
comment|/* TODO */
break|break;
case|case
name|VATMPIF_AAL_5
case|:
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_rcvd
operator|+=
operator|(
name|pdulen
operator|+
literal|47
operator|)
operator|/
literal|48
expr_stmt|;
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_pdu_rcvd
operator|++
expr_stmt|;
break|break;
default|default:
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_badpdu
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * TODO: 	 * For now, only user data PDUs are supported 	 */
if|if
condition|(
name|pt
operator|&
name|ATM_HDR_SET_PT
argument_list|(
name|ATM_PT_NONUSER
argument_list|)
condition|)
block|{
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_badpdu
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|aal
operator|==
name|VATMPIF_AAL_5
condition|)
block|{
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_drops
operator|+=
operator|(
name|pdulen
operator|+
literal|47
operator|)
operator|/
literal|48
expr_stmt|;
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_pdu_drops
operator|++
expr_stmt|;
block|}
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|IS_VATMPIF_DEBUG_PACKET
argument_list|(
name|vup
argument_list|)
condition|)
name|atm_dev_pdu_print
argument_list|(
operator|(
name|Cmn_unit
operator|*
operator|)
name|vup
argument_list|,
operator|(
name|Cmn_vcc
operator|*
operator|)
name|vvp
argument_list|,
name|m
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Get packet PDU length 	 */
name|KB_PLENGET
argument_list|(
name|m
argument_list|,
name|pdulen
argument_list|)
expr_stmt|;
comment|/* 	 * Only try queueing this if there is data 	 * to be handed up to the next layer. 	 */
if|if
condition|(
name|pdulen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Free zero-length buffer 		 */
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_badpdu
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
if|if
condition|(
name|aal
operator|==
name|VATMPIF_AAL_5
condition|)
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_aal5
operator|.
name|aal5_pdu_errs
operator|++
expr_stmt|;
name|err
operator|=
name|EIO
expr_stmt|;
name|KB_FREEALL
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* TODO: process the AAL4 CRC, AAL5 CRC,  	 * then update aal5_crc_len, aal5_drops, aal5_pdu_crc, 	 * aal5_pdu_errs, aal5_pdu_drops ... 	 */
comment|/* 	 * Quick count the PDU 	 */
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ipdus
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ibytes
operator|+=
name|pdulen
expr_stmt|;
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_rx_pdu
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_atm
operator|.
name|atm_rcvd
operator|+=
operator|(
name|pdulen
operator|+
literal|47
operator|)
operator|/
literal|48
expr_stmt|;
comment|/* 	 * Update the VCC statistics: 	 * XXX: This code should not be into the driver. 	 */
name|vcp
operator|=
name|vvp
operator|->
name|vv_connvc
operator|->
name|cvc_vcc
expr_stmt|;
if|if
condition|(
name|vcp
condition|)
block|{
name|vcp
operator|->
name|vc_ipdus
operator|++
expr_stmt|;
name|vcp
operator|->
name|vc_ibytes
operator|+=
name|pdulen
expr_stmt|;
comment|/* 		 * Update the NIF statistics if any 		 * XXX: beurk ! 		 */
if|if
condition|(
name|vcp
operator|->
name|vc_nif
condition|)
block|{
name|vcp
operator|->
name|vc_nif
operator|->
name|nif_ibytes
operator|+=
name|pdulen
expr_stmt|;
name|ANIF2IFP
argument_list|(
name|vcp
operator|->
name|vc_nif
argument_list|)
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ANIF2IFP
argument_list|(
name|vcp
operator|->
name|vc_nif
argument_list|)
operator|->
name|if_ibytes
operator|+=
name|pdulen
expr_stmt|;
block|}
block|}
comment|/* 	 * The STACK_CALL needs to happen at splnet() in order 	 * for the stack sequence processing to work. Schedule an 	 * interrupt queue callback at splnet(). 	 */
comment|/* 	 * Prepend callback function pointer and token value to buffer. 	 * We have already guaranteed that the space is available in the 	 * first buffer because the vatmpif_header structure is greater 	 * than our callback pointer. 	 * XXX  	 */
name|KB_HEADADJ
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|KB_DATASTART
argument_list|(
name|m
argument_list|,
name|cp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|atm_intr_func_t
operator|*
operator|)
name|cp
operator|)
operator|=
name|vatmpif_harp_recv_stack
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|atm_intr_func_t
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|void
operator|*
operator|*
operator|)
name|cp
operator|)
operator|=
operator|(
name|void
operator|*
operator|)
name|vvp
expr_stmt|;
comment|/* 	 * Schedule callback 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|netisr_queue
argument_list|(
name|NETISR_ATM
argument_list|,
name|m
argument_list|)
operator|)
condition|)
block|{
comment|/* (0) on success. */
comment|/* 		 * queue is full. Unable to pass up to the HARP stack 		 * Update the stats. 		 */
name|vup
operator|->
name|vu_stats
operator|.
name|hva_st_ng
operator|.
name|ng_rx_iqfull
operator|++
expr_stmt|;
name|vup
operator|->
name|vu_pif
operator|.
name|pif_ierrors
operator|++
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
name|failed
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

