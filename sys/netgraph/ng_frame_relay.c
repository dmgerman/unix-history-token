begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_frame_relay.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elisher<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_frame_relay.c,v 1.20 1999/11/01 09:24:51 julian Exp $  */
end_comment

begin_comment
comment|/*  * This node implements the frame relay protocol, not including  * the LMI line management. This means basically keeping track  * of which DLCI's are active, doing frame (de)multiplexing, etc.  *  * It has a 'downstream' hook that goes to the line, and a  * hook for each DLCI (eg, 'dlci16').  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_frame_relay.h>
end_include

begin_comment
comment|/*  * Line info, and status per channel.  */
end_comment

begin_struct
struct|struct
name|ctxinfo
block|{
comment|/* one per active hook */
name|u_int
name|flags
decl_stmt|;
define|#
directive|define
name|CHAN_VALID
value|0x01
comment|/* assigned to a channel */
define|#
directive|define
name|CHAN_ACTIVE
value|0x02
comment|/* bottom level active */
name|int
name|dlci
decl_stmt|;
comment|/* the dlci assigned to this context */
name|hook_p
name|hook
decl_stmt|;
comment|/* if there's a hook assigned.. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_CT
value|16
end_define

begin_comment
comment|/* # of dlci's active at a time (POWER OF 2!) */
end_comment

begin_struct
struct|struct
name|frmrel_softc
block|{
name|int
name|unit
decl_stmt|;
comment|/* which card are we? */
name|int
name|datahooks
decl_stmt|;
comment|/* number of data hooks attached */
name|node_p
name|node
decl_stmt|;
comment|/* netgraph node */
name|int
name|addrlen
decl_stmt|;
comment|/* address header length */
name|int
name|flags
decl_stmt|;
comment|/* state */
name|int
name|mtu
decl_stmt|;
comment|/* guess */
name|u_char
name|remote_seq
decl_stmt|;
comment|/* sequence number the remote sent */
name|u_char
name|local_seq
decl_stmt|;
comment|/* sequence number the remote rcvd */
name|u_short
name|ALT
index|[
literal|1024
index|]
decl_stmt|;
comment|/* map DLCIs to CTX */
define|#
directive|define
name|CTX_VALID
value|0x8000
comment|/* this bit means it's a valid CTX */
define|#
directive|define
name|CTX_VALUE
value|(MAX_CT - 1)
comment|/* mask for context part */
name|struct
name|ctxinfo
name|channel
index|[
name|MAX_CT
index|]
decl_stmt|;
name|struct
name|ctxinfo
name|downstream
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|frmrel_softc
modifier|*
name|sc_p
typedef|;
end_typedef

begin_define
define|#
directive|define
name|BYTEX_EA
value|0x01
end_define

begin_comment
comment|/* End Address. Always 0 on byte1 */
end_comment

begin_define
define|#
directive|define
name|BYTE1_C_R
value|0x02
end_define

begin_define
define|#
directive|define
name|BYTE2_FECN
value|0x08
end_define

begin_comment
comment|/* forwards congestion notification */
end_comment

begin_define
define|#
directive|define
name|BYTE2_BECN
value|0x04
end_define

begin_comment
comment|/* Backward congestion notification */
end_comment

begin_define
define|#
directive|define
name|BYTE2_DE
value|0x02
end_define

begin_comment
comment|/* Discard elligability */
end_comment

begin_define
define|#
directive|define
name|LASTBYTE_D_C
value|0x02
end_define

begin_comment
comment|/* last byte is dl_core or dlci info */
end_comment

begin_comment
comment|/* Used to do headers */
end_comment

begin_struct
specifier|static
struct|struct
name|segment
block|{
name|u_char
name|mask
decl_stmt|;
name|u_char
name|shift
decl_stmt|;
name|u_char
name|width
decl_stmt|;
block|}
name|makeup
index|[]
init|=
block|{
block|{
literal|0xfc
block|,
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|0xf0
block|,
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0xfe
block|,
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|0xfc
block|,
literal|2
block|,
literal|6
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SHIFTIN
parameter_list|(
name|segment
parameter_list|,
name|byte
parameter_list|,
name|dlci
parameter_list|)
define|\
value|{								     \ 		(dlci)<<= (segment)->width;				     \ 		(dlci) |=						     \ 			(((byte)& (segment)->mask)>> (segment)->shift);    \ 	}
end_define

begin_define
define|#
directive|define
name|SHIFTOUT
parameter_list|(
name|segment
parameter_list|,
name|byte
parameter_list|,
name|dlci
parameter_list|)
define|\
value|{								     \ 		(byte) |= (((dlci)<< (segment)->shift)& (segment)->mask);  \ 		(dlci)>>= (segment)->width;				     \ 	}
end_define

begin_comment
comment|/* Netgraph methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ngfrm_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ngfrm_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ngfrm_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ngfrm_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ngfrm_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other internal functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ngfrm_decode
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngfrm_addrlen
parameter_list|(
name|char
modifier|*
name|hdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ngfrm_allocate_CTX
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|int
name|dlci
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph type */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_FRAMERELAY_NODE_TYPE
block|,
name|NULL
block|,
name|ngfrm_constructor
block|,
name|NULL
block|,
name|ngfrm_rmnode
block|,
name|ngfrm_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ngfrm_rcvdata
block|,
name|ngfrm_rcvdata
block|,
name|ngfrm_disconnect
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|framerelay
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Given a DLCI, return the index of the  context table entry for it,  * Allocating a new one if needs be, or -1 if none available.  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_allocate_CTX
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|int
name|dlci
parameter_list|)
block|{
name|u_int
name|ctxnum
init|=
operator|-
literal|1
decl_stmt|;
comment|/* what ctx number we are using */
specifier|volatile
name|struct
name|ctxinfo
modifier|*
name|CTXp
init|=
name|NULL
decl_stmt|;
comment|/* Sanity check the dlci value */
if|if
condition|(
name|dlci
operator|>
literal|1023
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Check to see if we already have an entry for this DLCI */
if|if
condition|(
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|ctxnum
operator|=
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
operator|&
name|CTX_VALUE
operator|)
operator|<
name|MAX_CT
condition|)
block|{
name|CTXp
operator|=
name|sc
operator|->
name|channel
operator|+
name|ctxnum
expr_stmt|;
block|}
else|else
block|{
name|ctxnum
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
operator|=
literal|0
expr_stmt|;
comment|/* paranoid but... */
block|}
block|}
comment|/* 	 * If the index has no valid entry yet, then we need to allocate a 	 * CTX number to it 	 */
if|if
condition|(
name|CTXp
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|ctxnum
operator|=
literal|0
init|;
name|ctxnum
operator|<
name|MAX_CT
condition|;
name|ctxnum
operator|++
control|)
block|{
comment|/* 			 * If the VALID flag is empty it is unused 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|flags
operator|&
name|CHAN_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|sc
operator|->
name|channel
operator|+
name|ctxnum
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ctxinfo
argument_list|)
argument_list|)
expr_stmt|;
name|CTXp
operator|=
name|sc
operator|->
name|channel
operator|+
name|ctxnum
expr_stmt|;
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
operator|=
name|ctxnum
operator||
name|CTX_VALID
expr_stmt|;
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|dlci
operator|=
name|dlci
expr_stmt|;
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|flags
operator|=
name|CHAN_VALID
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If we still don't have a CTX pointer, then we never found a free 	 * spot so give up now.. 	 */
if|if
condition|(
operator|!
name|CTXp
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"No CTX available for dlci %d\n"
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ctxnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Node constructor  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|sc_p
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MALLOC
argument_list|(
name|sc
argument_list|,
name|sc_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|->
name|addrlen
operator|=
literal|2
expr_stmt|;
comment|/* default */
comment|/* Link the node and our private info */
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new hook  *  * We allow hooks called "debug", "downstream" and dlci[0-1023]  * The hook's private info points to our stash of info about that  * channel. A NULL pointer is debug and a DLCI of -1 means downstream.  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|int
name|dlci
init|=
literal|0
decl_stmt|;
name|int
name|ctxnum
decl_stmt|;
comment|/* Check if it's our friend the control hook */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_FRAMERELAY_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hook
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
comment|/* paranoid */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * All other hooks either start with 'dlci' and have a decimal 	 * trailing channel number up to 4 digits, or are the downstream 	 * hook. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_FRAMERELAY_HOOK_DLCI
argument_list|,
name|strlen
argument_list|(
name|NG_FRAMERELAY_HOOK_DLCI
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* It must be the downstream connection */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_FRAMERELAY_HOOK_DOWNSTREAM
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* Make sure we haven't already got one (paranoid) */
if|if
condition|(
name|sc
operator|->
name|downstream
operator|.
name|hook
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
comment|/* OK add it */
name|hook
operator|->
name|private
operator|=
operator|&
name|sc
operator|->
name|downstream
expr_stmt|;
name|sc
operator|->
name|downstream
operator|.
name|hook
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|downstream
operator|.
name|dlci
operator|=
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|downstream
operator|.
name|flags
operator||=
name|CHAN_ACTIVE
expr_stmt|;
name|sc
operator|->
name|datahooks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Must be a dlci hook at this point */
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|NG_FRAMERELAY_HOOK_DLCI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dlci
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|'\0'
operator|||
name|dlci
operator|<
literal|0
operator|||
name|dlci
operator|>
literal|1023
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We have a dlci, now either find it, or allocate it. It's possible 	 * that we might have seen packets for it already and made an entry 	 * for it. 	 */
name|ctxnum
operator|=
name|ngfrm_allocate_CTX
argument_list|(
name|sc
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctxnum
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * Be paranoid: if it's got a hook already, that dlci is in use . 	 * Generic code can not catch all the synonyms (e.g. dlci016 vs 	 * dlci16) 	 */
if|if
condition|(
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|hook
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
comment|/* 	 * Put our hooks into it (pun not intended) 	 */
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|flags
operator||=
name|CHAN_ACTIVE
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|sc
operator|->
name|channel
operator|+
name|ctxnum
expr_stmt|;
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|hook
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|datahooks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Count up the size of the address header if we don't already know  */
end_comment

begin_function
name|int
name|ngfrm_addrlen
parameter_list|(
name|char
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
name|hdr
index|[
literal|0
index|]
operator|&
name|BYTEX_EA
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|hdr
index|[
literal|1
index|]
operator|&
name|BYTEX_EA
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|hdr
index|[
literal|2
index|]
operator|&
name|BYTEX_EA
condition|)
return|return
literal|3
return|;
if|if
condition|(
name|hdr
index|[
literal|3
index|]
operator|&
name|BYTEX_EA
condition|)
return|return
literal|4
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data packet  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|struct
name|ctxinfo
modifier|*
specifier|const
name|ctxp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|dlci
decl_stmt|;
name|sc_p
name|sc
decl_stmt|;
name|int
name|alen
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
comment|/* Data doesn't come in from just anywhere (e.g debug hook) */
if|if
condition|(
name|ctxp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* If coming from downstream, decode it to a channel */
name|dlci
operator|=
name|ctxp
operator|->
name|dlci
expr_stmt|;
if|if
condition|(
name|dlci
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ngfrm_decode
argument_list|(
name|hook
operator|->
name|node
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
operator|)
return|;
comment|/* Derive the softc we will need */
name|sc
operator|=
name|hook
operator|->
name|node
operator|->
name|private
expr_stmt|;
comment|/* If there is no live channel, throw it away */
if|if
condition|(
operator|(
name|sc
operator|->
name|downstream
operator|.
name|hook
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|ctxp
operator|->
name|flags
operator|&
name|CHAN_ACTIVE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Store the DLCI on the front of the packet */
name|alen
operator|=
name|sc
operator|->
name|addrlen
expr_stmt|;
if|if
condition|(
name|alen
operator|==
literal|0
condition|)
name|alen
operator|=
literal|2
expr_stmt|;
comment|/* default value for transmit */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|alen
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Shift the lowest bits into the address field untill we are done. 	 * First byte is MSBits of addr so work backwards. 	 */
switch|switch
condition|(
name|alen
condition|)
block|{
case|case
literal|2
case|:
name|data
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|data
index|[
literal|1
index|]
operator||=
name|BYTEX_EA
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|data
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|3
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* 3 and 2 is correct */
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|data
index|[
literal|2
index|]
operator||=
name|BYTEX_EA
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|data
index|[
literal|0
index|]
operator|=
name|data
index|[
literal|1
index|]
operator|=
name|data
index|[
literal|2
index|]
operator|=
name|data
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|3
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|2
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTOUT
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|data
index|[
literal|3
index|]
operator||=
name|BYTEX_EA
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
comment|/* Send it */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|downstream
operator|.
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Decode an incoming frame coming from the switch  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_decode
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|alen
decl_stmt|;
name|u_int
name|dlci
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ctxnum
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alen
operator|=
name|sc
operator|->
name|addrlen
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|addrlen
operator|=
name|alen
operator|=
name|ngfrm_addrlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|alen
condition|)
block|{
case|case
literal|2
case|:
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|3
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
comment|/* 3 and 2 is correct */
break|break;
case|case
literal|4
case|:
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|0
argument_list|,
name|data
index|[
literal|0
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|1
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|2
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|SHIFTIN
argument_list|(
name|makeup
operator|+
literal|3
argument_list|,
name|data
index|[
literal|3
index|]
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dlci
operator|>
literal|1023
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctxnum
operator|=
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ctxnum
operator|&
name|CTX_VALID
operator|)
operator|&&
name|sc
operator|->
name|channel
index|[
name|ctxnum
operator|&=
name|CTX_VALUE
index|]
operator|.
name|hook
condition|)
block|{
comment|/* Send it */
name|m_adj
argument_list|(
name|m
argument_list|,
name|alen
argument_list|)
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|channel
index|[
name|ctxnum
index|]
operator|.
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
block|}
name|out
label|:
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown node  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  *  * Invalidate the private data associated with this dlci.  * For this type, removal of the last link resets tries to destroy the node.  */
end_comment

begin_function
specifier|static
name|int
name|ngfrm_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ctxinfo
modifier|*
specifier|const
name|cp
init|=
name|hook
operator|->
name|private
decl_stmt|;
name|int
name|dlci
decl_stmt|;
comment|/* If it's a regular dlci hook, then free resources etc.. */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
name|dlci
operator|=
name|cp
operator|->
name|dlci
expr_stmt|;
if|if
condition|(
name|dlci
operator|!=
operator|-
literal|1
condition|)
name|sc
operator|->
name|ALT
index|[
name|dlci
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|datahooks
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|hook
operator|->
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|hook
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

