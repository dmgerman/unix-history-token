begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_bridge.c  *  * Copyright (c) 2000 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * ng_bridge(4) netgraph node type  *  * The node performs standard intelligent Ethernet bridging over  * each of its connected hooks, or links.  A simple loop detection  * algorithm is included which disables a link for priv->conf.loopTimeout  * seconds when a host is seen to have jumped from one link to  * another within priv->conf.minStableAge seconds.  *  * We keep a hashtable that maps Ethernet addresses to host info,  * which is contained in struct ng_bridge_host's. These structures  * tell us on which link the host may be found. A host's entry will  * expire after priv->conf.maxStaleness seconds.  *  * This node is optimzed for stable networks, where machines jump  * from one port to the other only rarely.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_bridge.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ether.h>
end_include

begin_comment
comment|/* Per-link private data */
end_comment

begin_struct
struct|struct
name|ng_bridge_link
block|{
name|hook_p
name|hook
decl_stmt|;
comment|/* netgraph hook */
name|u_int16_t
name|loopCount
decl_stmt|;
comment|/* loop ignore timer */
name|struct
name|ng_bridge_link_stats
name|stats
decl_stmt|;
comment|/* link stats */
block|}
struct|;
end_struct

begin_comment
comment|/* Per-node private data */
end_comment

begin_struct
struct|struct
name|ng_bridge_private
block|{
name|struct
name|ng_bridge_bucket
modifier|*
name|tab
decl_stmt|;
comment|/* hash table bucket array */
name|struct
name|ng_bridge_link
modifier|*
name|links
index|[
name|NG_BRIDGE_MAX_LINKS
index|]
decl_stmt|;
name|struct
name|ng_bridge_config
name|conf
decl_stmt|;
comment|/* node configuration */
name|node_p
name|node
decl_stmt|;
comment|/* netgraph node */
name|u_int
name|numHosts
decl_stmt|;
comment|/* num entries in table */
name|u_int
name|numBuckets
decl_stmt|;
comment|/* num buckets in table */
name|u_int
name|hashMask
decl_stmt|;
comment|/* numBuckets - 1 */
name|int
name|numLinks
decl_stmt|;
comment|/* num connected links */
name|struct
name|callout
name|timer
decl_stmt|;
comment|/* one second periodic timer */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_bridge_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Information about a host, stored in a hash table entry */
end_comment

begin_struct
struct|struct
name|ng_bridge_hent
block|{
name|struct
name|ng_bridge_host
name|host
decl_stmt|;
comment|/* actual host info */
name|SLIST_ENTRY
argument_list|(
argument|ng_bridge_hent
argument_list|)
name|next
expr_stmt|;
comment|/* next entry in bucket */
block|}
struct|;
end_struct

begin_comment
comment|/* Hash table bucket declaration */
end_comment

begin_expr_stmt
name|SLIST_HEAD
argument_list|(
name|ng_bridge_bucket
argument_list|,
name|ng_bridge_hent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_bridge_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_bridge_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_bridge_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_bridge_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_bridge_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_bridge_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Other internal functions */
end_comment

begin_function_decl
specifier|static
name|struct
name|ng_bridge_host
modifier|*
name|ng_bridge_get
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|u_char
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_bridge_put
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|u_char
modifier|*
name|addr
parameter_list|,
name|int
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_bridge_rehash
parameter_list|(
name|priv_p
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_bridge_remove_hosts
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|int
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_bridge_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|ng_bridge_nodename
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Ethernet broadcast */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|ng_bridge_bcast_addr
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store each hook's link number in the private field */
end_comment

begin_define
define|#
directive|define
name|LINK_NUM
parameter_list|(
name|hook
parameter_list|)
value|(*(u_int16_t *)(&(hook)->private))
end_define

begin_comment
comment|/* Compare Ethernet addresses using 32 and 16 bit words instead of bytewise */
end_comment

begin_define
define|#
directive|define
name|ETHER_EQUAL
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((const u_int32_t *)(a))[0] \ 					== ((const u_int32_t *)(b))[0] \&& ((const u_int16_t *)(a))[2] \ 					== ((const u_int16_t *)(b))[2])
end_define

begin_comment
comment|/* Minimum and maximum number of hash buckets. Must be a power of two. */
end_comment

begin_define
define|#
directive|define
name|MIN_BUCKETS
value|(1<< 5)
end_define

begin_comment
comment|/* 32 */
end_comment

begin_define
define|#
directive|define
name|MAX_BUCKETS
value|(1<< 14)
end_define

begin_comment
comment|/* 16384 */
end_comment

begin_comment
comment|/* Configuration default values */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_LOOP_TIMEOUT
value|60
end_define

begin_define
define|#
directive|define
name|DEFAULT_MAX_STALENESS
value|(15 * 60)
end_define

begin_comment
comment|/* same as ARP timeout */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MIN_STABLE_AGE
value|1
end_define

begin_comment
comment|/****************************************************************** 		    NETGRAPH PARSE TYPES ******************************************************************/
end_comment

begin_comment
comment|/*  * How to determine the length of the table returned by NGM_BRIDGE_GET_TABLE  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_getTableLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|ng_bridge_host_ary
modifier|*
specifier|const
name|hary
init|=
operator|(
specifier|const
expr|struct
name|ng_bridge_host_ary
operator|*
operator|)
operator|(
name|buf
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|)
decl_stmt|;
return|return
name|hary
operator|->
name|numHosts
return|;
block|}
end_function

begin_comment
comment|/* Parse type for struct ng_bridge_host_ary */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_bridge_host_type_info
init|=
name|NG_BRIDGE_HOST_TYPE_INFO
argument_list|(
operator|&
name|ng_ether_enaddr_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_host_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_bridge_host_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_bridge_hary_type_info
init|=
block|{
operator|&
name|ng_bridge_host_type
block|,
name|ng_bridge_getTableLength
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_hary_type
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_bridge_hary_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_bridge_host_ary_type_info
init|=
name|NG_BRIDGE_HOST_ARY_TYPE_INFO
argument_list|(
operator|&
name|ng_bridge_hary_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_host_ary_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_bridge_host_ary_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_bridge_config */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_bridge_ipfwary_type_info
init|=
block|{
operator|&
name|ng_parse_uint8_type
block|,
name|NG_BRIDGE_MAX_LINKS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_ipfwary_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_bridge_ipfwary_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_bridge_config_type_info
init|=
name|NG_BRIDGE_CONFIG_TYPE_INFO
argument_list|(
operator|&
name|ng_bridge_ipfwary_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_config_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_bridge_config_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_bridge_link_stat */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_bridge_stats_type_info
init|=
name|NG_BRIDGE_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_bridge_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_bridge_stats_type_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_bridge_cmdlist
index|[]
init|=
block|{
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_bridge_config_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_bridge_config_type
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_RESET
block|,
literal|"reset"
block|,
name|NULL
block|,
name|NULL
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_GET_STATS
block|,
literal|"getstats"
block|,
operator|&
name|ng_parse_uint32_type
block|,
operator|&
name|ng_bridge_stats_type
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_CLR_STATS
block|,
literal|"clrstats"
block|,
operator|&
name|ng_parse_uint32_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_GETCLR_STATS
block|,
literal|"getclrstats"
block|,
operator|&
name|ng_parse_uint32_type
block|,
operator|&
name|ng_bridge_stats_type
block|}
block|,
block|{
name|NGM_BRIDGE_COOKIE
block|,
name|NGM_BRIDGE_GET_TABLE
block|,
literal|"gettable"
block|,
name|NULL
block|,
operator|&
name|ng_bridge_host_ary_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_bridge_typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_BRIDGE_NODE_TYPE
block|,
name|NULL
block|,
name|ng_bridge_constructor
block|,
name|ng_bridge_rcvmsg
block|,
name|ng_bridge_rmnode
block|,
name|ng_bridge_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_bridge_rcvdata
block|,
name|ng_bridge_rcvdata
block|,
name|ng_bridge_disconnect
block|,
name|ng_bridge_cmdlist
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|ether
argument_list|,
operator|&
name|ng_bridge_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Depend on ng_ether so we can use the Ethernet parse type */
end_comment

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ng_bridge
argument_list|,
name|ng_ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/****************************************************************** 		    NETGRAPH NODE METHODS ******************************************************************/
end_comment

begin_comment
comment|/*  * Node constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate and initialize private info */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|priv
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize hash table, etc. */
name|MALLOC
argument_list|(
name|priv
operator|->
name|tab
argument_list|,
expr|struct
name|ng_bridge_bucket
operator|*
argument_list|,
name|MIN_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|priv
operator|->
name|tab
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|tab
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bzero
argument_list|(
name|priv
operator|->
name|tab
argument_list|,
name|MIN_BUCKETS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|priv
operator|->
name|tab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init SLIST's */
name|priv
operator|->
name|numBuckets
operator|=
name|MIN_BUCKETS
expr_stmt|;
name|priv
operator|->
name|hashMask
operator|=
name|MIN_BUCKETS
operator|-
literal|1
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|debugLevel
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|loopTimeout
operator|=
name|DEFAULT_LOOP_TIMEOUT
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|maxStaleness
operator|=
name|DEFAULT_MAX_STALENESS
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|minStableAge
operator|=
name|DEFAULT_MIN_STABLE_AGE
expr_stmt|;
comment|/* Call superclass constructor */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_bridge_typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|priv
expr_stmt|;
name|priv
operator|->
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
comment|/* Start timer by faking a timeout event */
operator|(
operator|*
name|nodep
operator|)
operator|->
name|refs
operator|++
expr_stmt|;
name|ng_bridge_timeout
argument_list|(
operator|*
name|nodep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Method for attaching a new hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
comment|/* Check for a link hook */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_BRIDGE_HOOK_LINK_PREFIX
argument_list|,
name|strlen
argument_list|(
name|NG_BRIDGE_HOOK_LINK_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|u_long
name|linkNum
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|NG_BRIDGE_HOOK_LINK_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|linkNum
operator|=
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|'\0'
operator|||
name|linkNum
operator|>=
name|NG_BRIDGE_MAX_LINKS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
name|MALLOC
argument_list|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|,
expr|struct
name|ng_bridge_link
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|->
name|hook
operator|=
name|hook
expr_stmt|;
name|LINK_NUM
argument_list|(
name|hook
argument_list|)
operator|=
name|linkNum
expr_stmt|;
name|priv
operator|->
name|numLinks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Unknown hook name */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_BRIDGE_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_BRIDGE_GET_CONFIG
case|:
block|{
name|struct
name|ng_bridge_config
modifier|*
name|conf
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_bridge_config
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_bridge_config
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
operator|*
name|conf
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
comment|/* no sanity checking needed */
break|break;
block|}
case|case
name|NGM_BRIDGE_SET_CONFIG
case|:
block|{
name|struct
name|ng_bridge_config
modifier|*
name|conf
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ng_bridge_config
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|conf
operator|=
operator|(
expr|struct
name|ng_bridge_config
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|priv
operator|->
name|conf
operator|=
operator|*
name|conf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_BRIDGE_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|conf
operator|.
name|ipfw
index|[
name|i
index|]
operator|=
operator|!
operator|!
name|priv
operator|->
name|conf
operator|.
name|ipfw
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
case|case
name|NGM_BRIDGE_RESET
case|:
block|{
name|int
name|i
decl_stmt|;
comment|/* Flush all entries in the hash table */
name|ng_bridge_remove_hosts
argument_list|(
name|priv
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Reset all loop detection counters and stats */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_BRIDGE_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|->
name|loopCount
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|NGM_BRIDGE_GET_STATS
case|:
case|case
name|NGM_BRIDGE_CLR_STATS
case|:
case|case
name|NGM_BRIDGE_GETCLR_STATS
case|:
block|{
name|struct
name|ng_bridge_link
modifier|*
name|link
decl_stmt|;
name|int
name|linkNum
decl_stmt|;
comment|/* Get link number */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|linkNum
operator|=
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|<
literal|0
operator|||
name|linkNum
operator|>=
name|NG_BRIDGE_MAX_LINKS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|link
operator|=
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
comment|/* Get/clear stats */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_BRIDGE_CLR_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bcopy
argument_list|(
operator|&
name|link
operator|->
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_BRIDGE_GET_STATS
condition|)
name|bzero
argument_list|(
operator|&
name|link
operator|->
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_BRIDGE_GET_TABLE
case|:
block|{
name|struct
name|ng_bridge_host_ary
modifier|*
name|ary
decl_stmt|;
name|struct
name|ng_bridge_hent
modifier|*
name|hent
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|bucket
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ary
argument_list|)
operator|+
operator|(
name|priv
operator|->
name|numHosts
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ary
operator|->
name|hosts
argument_list|)
operator|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|ary
operator|=
operator|(
expr|struct
name|ng_bridge_host_ary
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|ary
operator|->
name|numHosts
operator|=
name|priv
operator|->
name|numHosts
expr_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|priv
operator|->
name|numBuckets
condition|;
name|bucket
operator|++
control|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|hent
argument_list|,
argument|&priv->tab[bucket]
argument_list|,
argument|next
argument_list|)
name|ary
operator|->
name|hosts
index|[
name|i
operator|++
index|]
operator|=
name|hent
operator|->
name|host
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Done */
if|if
condition|(
name|rptr
condition|)
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|resp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_bridge_host
modifier|*
name|host
decl_stmt|;
name|struct
name|ng_bridge_link
modifier|*
name|link
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|linkNum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|manycast
decl_stmt|;
comment|/* Get link number */
name|linkNum
operator|=
name|LINK_NUM
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|linkNum
operator|>=
literal|0
operator|&&
name|linkNum
operator|<
name|NG_BRIDGE_MAX_LINKS
argument_list|,
operator|(
literal|"%s: linkNum=%u"
operator|,
name|__FUNCTION__
operator|,
name|linkNum
operator|)
argument_list|)
expr_stmt|;
name|link
operator|=
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|link
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: link%d null"
operator|,
name|__FUNCTION__
operator|,
name|linkNum
operator|)
argument_list|)
expr_stmt|;
comment|/* Sanity check packet and pull up header */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|recvRunts
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
operator|&&
operator|!
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
operator|)
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eh
operator|->
name|ether_shost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|recvInvalid
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Is link disabled due to a loopback condition? */
if|if
condition|(
name|link
operator|->
name|loopCount
operator|!=
literal|0
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|loopDrops
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ELOOP
operator|)
return|;
comment|/* XXX is this an appropriate error? */
block|}
comment|/* Update stats */
name|link
operator|->
name|stats
operator|.
name|recvPackets
operator|++
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|manycast
operator|=
operator|(
name|eh
operator|->
name|ether_dhost
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ETHER_EQUAL
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ng_bridge_bcast_addr
argument_list|)
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|recvBroadcasts
operator|++
expr_stmt|;
name|manycast
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|link
operator|->
name|stats
operator|.
name|recvMulticasts
operator|++
expr_stmt|;
block|}
comment|/* Look up packet's source Ethernet address in hashtable */
if|if
condition|(
operator|(
name|host
operator|=
name|ng_bridge_get
argument_list|(
name|priv
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Update time since last heard from this host */
name|host
operator|->
name|staleness
operator|=
literal|0
expr_stmt|;
comment|/* Did host jump to a different link? */
if|if
condition|(
name|host
operator|->
name|linkNum
operator|!=
name|linkNum
condition|)
block|{
comment|/* 			 * If the host's old link was recently established 			 * on the old link and it's already jumped to a new 			 * link, declare a loopback condition. 			 */
if|if
condition|(
name|host
operator|->
name|age
operator|<
name|priv
operator|->
name|conf
operator|.
name|minStableAge
condition|)
block|{
comment|/* Log the problem */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|debugLevel
operator|>=
literal|2
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|char
name|suffix
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|suffix
argument_list|,
sizeof|sizeof
argument_list|(
name|suffix
argument_list|)
argument_list|,
literal|" (%s%d)"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
else|else
operator|*
name|suffix
operator|=
literal|'\0'
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ng_bridge: %s:"
literal|" loopback detected on %s%s\n"
argument_list|,
name|ng_bridge_nodename
argument_list|(
name|node
argument_list|)
argument_list|,
name|hook
operator|->
name|name
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
block|}
comment|/* Mark link as linka non grata */
name|link
operator|->
name|loopCount
operator|=
name|priv
operator|->
name|conf
operator|.
name|loopTimeout
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|loopDetects
operator|++
expr_stmt|;
comment|/* Forget all hosts on this link */
name|ng_bridge_remove_hosts
argument_list|(
name|priv
argument_list|,
name|linkNum
argument_list|)
expr_stmt|;
comment|/* Drop packet */
name|link
operator|->
name|stats
operator|.
name|loopDrops
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ELOOP
operator|)
return|;
comment|/* XXX appropriate? */
block|}
comment|/* Move host over to new link */
name|host
operator|->
name|linkNum
operator|=
name|linkNum
expr_stmt|;
name|host
operator|->
name|age
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|ng_bridge_put
argument_list|(
name|priv
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|linkNum
argument_list|)
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Run packet through ipfw processing, if enabled */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|ipfw
index|[
name|linkNum
index|]
operator|&&
name|fw_enable
operator|&&
name|ip_fw_chk_ptr
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX not implemented yet */
block|}
comment|/* 	 * If unicast and destination host known, deliver to host's link, 	 * unless it is the same link as the packet came in on. 	 */
if|if
condition|(
operator|!
name|manycast
condition|)
block|{
comment|/* Determine packet destination link */
if|if
condition|(
operator|(
name|host
operator|=
name|ng_bridge_get
argument_list|(
name|priv
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ng_bridge_link
modifier|*
specifier|const
name|destLink
init|=
name|priv
operator|->
name|links
index|[
name|host
operator|->
name|linkNum
index|]
decl_stmt|;
comment|/* If destination same as incoming link, do nothing */
name|KASSERT
argument_list|(
name|destLink
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: link%d null"
operator|,
name|__FUNCTION__
operator|,
name|host
operator|->
name|linkNum
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|destLink
operator|==
name|link
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deliver packet out the destination link */
name|destLink
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|destLink
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|destLink
operator|->
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Destination host is not known */
name|link
operator|->
name|stats
operator|.
name|recvUnknown
operator|++
expr_stmt|;
block|}
comment|/* Distribute unknown, multicast, broadcast pkts to all other links */
for|for
control|(
name|linkNum
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numLinks
operator|-
literal|1
condition|;
name|linkNum
operator|++
control|)
block|{
name|struct
name|ng_bridge_link
modifier|*
specifier|const
name|destLink
init|=
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
name|meta_p
name|meta2
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
comment|/* Skip incoming link and disconnected links */
if|if
condition|(
name|destLink
operator|==
name|NULL
operator|||
name|destLink
operator|==
name|link
condition|)
continue|continue;
comment|/* Copy mbuf and meta info */
if|if
condition|(
operator|++
name|i
operator|==
name|priv
operator|->
name|numLinks
operator|-
literal|1
condition|)
block|{
comment|/* last link */
name|m2
operator|=
name|m
expr_stmt|;
name|meta2
operator|=
name|meta
expr_stmt|;
block|}
else|else
block|{
name|m2
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* XXX m_dup()? */
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|meta
operator|!=
name|NULL
operator|&&
operator|(
name|meta2
operator|=
name|ng_copy_meta
argument_list|(
name|meta
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|memoryFailures
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
comment|/* Update stats */
name|destLink
operator|->
name|stats
operator|.
name|xmitPackets
operator|++
expr_stmt|;
name|destLink
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
switch|switch
condition|(
name|manycast
condition|)
block|{
case|case
literal|0
case|:
comment|/* unicast */
break|break;
case|case
literal|1
case|:
comment|/* multicast */
name|destLink
operator|->
name|stats
operator|.
name|xmitMulticasts
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* broadcast */
name|destLink
operator|->
name|stats
operator|.
name|xmitBroadcasts
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Send packet */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|destLink
operator|->
name|hook
argument_list|,
name|m2
argument_list|,
name|meta2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shutdown node  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* frees all link and host info */
name|KASSERT
argument_list|(
name|priv
operator|->
name|numLinks
operator|==
literal|0
operator|&&
name|priv
operator|->
name|numHosts
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: numLinks=%d numHosts=%d"
operator|,
name|__FUNCTION__
operator|,
name|priv
operator|->
name|numLinks
operator|,
name|priv
operator|->
name|numHosts
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
operator|->
name|tab
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection.  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|int
name|linkNum
decl_stmt|;
comment|/* Get link number */
name|linkNum
operator|=
name|LINK_NUM
argument_list|(
name|hook
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|linkNum
operator|>=
literal|0
operator|&&
name|linkNum
operator|<
name|NG_BRIDGE_MAX_LINKS
argument_list|,
operator|(
literal|"%s: linkNum=%u"
operator|,
name|__FUNCTION__
operator|,
name|linkNum
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove all hosts associated with this link */
name|ng_bridge_remove_hosts
argument_list|(
name|priv
argument_list|,
name|linkNum
argument_list|)
expr_stmt|;
comment|/* Free associated link information */
name|KASSERT
argument_list|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no link"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|=
name|NULL
expr_stmt|;
name|priv
operator|->
name|numLinks
operator|--
expr_stmt|;
comment|/* If no more hooks, go away */
if|if
condition|(
name|hook
operator|->
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|hook
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/****************************************************************** 		    HASH TABLE FUNCTIONS ******************************************************************/
end_comment

begin_comment
comment|/*  * Hash algorithm  *  * Only hashing bytes 3-6 of the Ethernet address is sufficient and fast.  */
end_comment

begin_define
define|#
directive|define
name|HASH
parameter_list|(
name|addr
parameter_list|,
name|mask
parameter_list|)
value|( (((const u_int16_t *)(addr))[0] 	\ 				 ^ ((const u_int16_t *)(addr))[1] 	\ 				 ^ ((const u_int16_t *)(addr))[2])& (mask) )
end_define

begin_comment
comment|/*  * Find a host entry in the table.  */
end_comment

begin_function
specifier|static
name|struct
name|ng_bridge_host
modifier|*
name|ng_bridge_get
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|u_char
modifier|*
name|addr
parameter_list|)
block|{
specifier|const
name|int
name|bucket
init|=
name|HASH
argument_list|(
name|addr
argument_list|,
name|priv
operator|->
name|hashMask
argument_list|)
decl_stmt|;
name|struct
name|ng_bridge_hent
modifier|*
name|hent
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|hent
argument_list|,
argument|&priv->tab[bucket]
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|ETHER_EQUAL
argument_list|(
name|hent
operator|->
name|host
operator|.
name|addr
argument_list|,
name|addr
argument_list|)
condition|)
return|return
operator|(
operator|&
name|hent
operator|->
name|host
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new host entry to the table. This assumes the host doesn't  * already exist in the table. Returns 1 on success, 0 if there  * was a memory allocation failure.  */
end_comment

begin_function
specifier|static
name|int
name|ng_bridge_put
parameter_list|(
name|priv_p
name|priv
parameter_list|,
specifier|const
name|u_char
modifier|*
name|addr
parameter_list|,
name|int
name|linkNum
parameter_list|)
block|{
specifier|const
name|int
name|bucket
init|=
name|HASH
argument_list|(
name|addr
argument_list|,
name|priv
operator|->
name|hashMask
argument_list|)
decl_stmt|;
name|struct
name|ng_bridge_hent
modifier|*
name|hent
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* Assert that entry does not already exist in hashtable */
name|SLIST_FOREACH
argument_list|(
argument|hent
argument_list|,
argument|&priv->tab[bucket]
argument_list|,
argument|next
argument_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|ETHER_EQUAL
argument_list|(
name|hent
operator|->
name|host
operator|.
name|addr
argument_list|,
name|addr
argument_list|)
argument_list|,
operator|(
literal|"%s: entry %6D exists in table"
operator|,
name|__FUNCTION__
operator|,
name|addr
operator|,
literal|":"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Allocate and initialize new hashtable entry */
name|MALLOC
argument_list|(
name|hent
argument_list|,
expr|struct
name|ng_bridge_hent
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hent
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hent
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|addr
argument_list|,
name|hent
operator|->
name|host
operator|.
name|addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|hent
operator|->
name|host
operator|.
name|linkNum
operator|=
name|linkNum
expr_stmt|;
name|hent
operator|->
name|host
operator|.
name|staleness
operator|=
literal|0
expr_stmt|;
name|hent
operator|->
name|host
operator|.
name|age
operator|=
literal|0
expr_stmt|;
comment|/* Add new element to hash bucket */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|tab
index|[
name|bucket
index|]
argument_list|,
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numHosts
operator|++
expr_stmt|;
comment|/* Resize table if necessary */
name|ng_bridge_rehash
argument_list|(
name|priv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resize the hash table. We try to maintain the number of buckets  * such that the load factor is in the range 0.25 to 1.0.  *  * If we can't get the new memory then we silently fail. This is OK  * because things will still work and we'll try again soon anyway.  */
end_comment

begin_function
specifier|static
name|void
name|ng_bridge_rehash
parameter_list|(
name|priv_p
name|priv
parameter_list|)
block|{
name|struct
name|ng_bridge_bucket
modifier|*
name|newTab
decl_stmt|;
name|int
name|oldBucket
decl_stmt|,
name|newBucket
decl_stmt|;
name|int
name|newNumBuckets
decl_stmt|;
name|u_int
name|newMask
decl_stmt|;
comment|/* Is table too full or too empty? */
if|if
condition|(
name|priv
operator|->
name|numHosts
operator|>
name|priv
operator|->
name|numBuckets
operator|&&
operator|(
name|priv
operator|->
name|numBuckets
operator|<<
literal|1
operator|)
operator|<=
name|MAX_BUCKETS
condition|)
name|newNumBuckets
operator|=
name|priv
operator|->
name|numBuckets
operator|<<
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|priv
operator|->
name|numHosts
operator|<
operator|(
name|priv
operator|->
name|numBuckets
operator|>>
literal|2
operator|)
operator|&&
operator|(
name|priv
operator|->
name|numBuckets
operator|>>
literal|2
operator|)
operator|>=
name|MIN_BUCKETS
condition|)
name|newNumBuckets
operator|=
name|priv
operator|->
name|numBuckets
operator|>>
literal|2
expr_stmt|;
else|else
return|return;
name|newMask
operator|=
name|newNumBuckets
operator|-
literal|1
expr_stmt|;
comment|/* Allocate and initialize new table */
name|MALLOC
argument_list|(
name|newTab
argument_list|,
expr|struct
name|ng_bridge_bucket
operator|*
argument_list|,
name|newNumBuckets
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newTab
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|newTab
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
name|newTab
argument_list|,
name|newNumBuckets
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newTab
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move all entries from old table to new table */
for|for
control|(
name|oldBucket
operator|=
literal|0
init|;
name|oldBucket
operator|<
name|priv
operator|->
name|numBuckets
condition|;
name|oldBucket
operator|++
control|)
block|{
name|struct
name|ng_bridge_bucket
modifier|*
specifier|const
name|oldList
init|=
operator|&
name|priv
operator|->
name|tab
index|[
name|oldBucket
index|]
decl_stmt|;
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|oldList
argument_list|)
condition|)
block|{
name|struct
name|ng_bridge_hent
modifier|*
specifier|const
name|hent
init|=
name|SLIST_FIRST
argument_list|(
name|oldList
argument_list|)
decl_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
name|oldList
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|newBucket
operator|=
name|HASH
argument_list|(
name|hent
operator|->
name|host
operator|.
name|addr
argument_list|,
name|newMask
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|newTab
index|[
name|newBucket
index|]
argument_list|,
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Replace old table with new one */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|debugLevel
operator|>=
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ng_bridge: %s: table size %d -> %d\n"
argument_list|,
name|ng_bridge_nodename
argument_list|(
name|priv
operator|->
name|node
argument_list|)
argument_list|,
name|priv
operator|->
name|numBuckets
argument_list|,
name|newNumBuckets
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|priv
operator|->
name|tab
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numBuckets
operator|=
name|newNumBuckets
expr_stmt|;
name|priv
operator|->
name|hashMask
operator|=
name|newMask
expr_stmt|;
name|priv
operator|->
name|tab
operator|=
name|newTab
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/****************************************************************** 		    MISC FUNCTIONS ******************************************************************/
end_comment

begin_comment
comment|/*  * Remove all hosts associated with a specific link from the hashtable.  * If linkNum == -1, then remove all hosts in the table.  */
end_comment

begin_function
specifier|static
name|void
name|ng_bridge_remove_hosts
parameter_list|(
name|priv_p
name|priv
parameter_list|,
name|int
name|linkNum
parameter_list|)
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|priv
operator|->
name|numBuckets
condition|;
name|bucket
operator|++
control|)
block|{
name|struct
name|ng_bridge_hent
modifier|*
modifier|*
name|hptr
init|=
operator|&
name|SLIST_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|tab
index|[
name|bucket
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|hptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ng_bridge_hent
modifier|*
specifier|const
name|hent
init|=
operator|*
name|hptr
decl_stmt|;
if|if
condition|(
name|linkNum
operator|==
operator|-
literal|1
operator|||
name|hent
operator|->
name|host
operator|.
name|linkNum
operator|==
name|linkNum
condition|)
block|{
operator|*
name|hptr
operator|=
name|SLIST_NEXT
argument_list|(
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hent
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numHosts
operator|--
expr_stmt|;
block|}
else|else
name|hptr
operator|=
operator|&
name|SLIST_NEXT
argument_list|(
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle our once-per-second timeout event. We do two things:  * we decrement link->loopCount for those links being muted due to  * a detected loopback condition, and we remove any hosts from  * the hashtable whom we haven't heard from in a long while.  */
end_comment

begin_function
specifier|static
name|void
name|ng_bridge_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|arg
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|s
decl_stmt|,
name|bucket
decl_stmt|;
name|int
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|linkNum
decl_stmt|;
comment|/* Avoid race condition with ng_bridge_shutdown() */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|flags
operator|&
name|NG_INVALID
operator|)
operator|!=
literal|0
operator|||
name|priv
operator|==
name|NULL
condition|)
block|{
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Register a new timeout, keeping the existing node reference */
name|callout_reset
argument_list|(
operator|&
name|priv
operator|->
name|timer
argument_list|,
name|hz
argument_list|,
name|ng_bridge_timeout
argument_list|,
name|node
argument_list|)
expr_stmt|;
comment|/* Update host time counters and remove stale entries */
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|priv
operator|->
name|numBuckets
condition|;
name|bucket
operator|++
control|)
block|{
name|struct
name|ng_bridge_hent
modifier|*
modifier|*
name|hptr
init|=
operator|&
name|SLIST_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|tab
index|[
name|bucket
index|]
argument_list|)
decl_stmt|;
while|while
condition|(
operator|*
name|hptr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ng_bridge_hent
modifier|*
specifier|const
name|hent
init|=
operator|*
name|hptr
decl_stmt|;
comment|/* Make sure host's link really exists */
name|KASSERT
argument_list|(
name|priv
operator|->
name|links
index|[
name|hent
operator|->
name|host
operator|.
name|linkNum
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: host %6D on nonexistent link %d\n"
operator|,
name|__FUNCTION__
operator|,
name|hent
operator|->
name|host
operator|.
name|addr
operator|,
literal|":"
operator|,
name|hent
operator|->
name|host
operator|.
name|linkNum
operator|)
argument_list|)
expr_stmt|;
comment|/* Remove hosts we haven't heard from in a while */
if|if
condition|(
operator|++
name|hent
operator|->
name|host
operator|.
name|staleness
operator|>=
name|priv
operator|->
name|conf
operator|.
name|maxStaleness
condition|)
block|{
operator|*
name|hptr
operator|=
name|SLIST_NEXT
argument_list|(
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|hent
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numHosts
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hent
operator|->
name|host
operator|.
name|age
operator|<
literal|0xffff
condition|)
name|hent
operator|->
name|host
operator|.
name|age
operator|++
expr_stmt|;
name|hptr
operator|=
operator|&
name|SLIST_NEXT
argument_list|(
name|hent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
block|}
block|}
name|KASSERT
argument_list|(
name|priv
operator|->
name|numHosts
operator|==
name|counter
argument_list|,
operator|(
literal|"%s: hosts: %d != %d"
operator|,
name|__FUNCTION__
operator|,
name|priv
operator|->
name|numHosts
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
comment|/* Decrease table size if necessary */
name|ng_bridge_rehash
argument_list|(
name|priv
argument_list|)
expr_stmt|;
comment|/* Decrease loop counter on muted looped back links */
for|for
control|(
name|counter
operator|=
name|linkNum
operator|=
literal|0
init|;
name|linkNum
operator|<
name|NG_BRIDGE_MAX_LINKS
condition|;
name|linkNum
operator|++
control|)
block|{
name|struct
name|ng_bridge_link
modifier|*
specifier|const
name|link
init|=
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
if|if
condition|(
name|link
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|link
operator|->
name|loopCount
operator|!=
literal|0
condition|)
block|{
name|link
operator|->
name|loopCount
operator|--
expr_stmt|;
if|if
condition|(
name|link
operator|->
name|loopCount
operator|==
literal|0
operator|&&
name|priv
operator|->
name|conf
operator|.
name|debugLevel
operator|>=
literal|2
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ng_bridge: %s:"
literal|" restoring looped back link%d\n"
argument_list|,
name|ng_bridge_nodename
argument_list|(
name|node
argument_list|)
argument_list|,
name|linkNum
argument_list|)
expr_stmt|;
block|}
block|}
name|counter
operator|++
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|priv
operator|->
name|numLinks
operator|==
name|counter
argument_list|,
operator|(
literal|"%s: links: %d != %d"
operator|,
name|__FUNCTION__
operator|,
name|priv
operator|->
name|numLinks
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
comment|/* Done */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return node's "name", even if it doesn't have one.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ng_bridge_nodename
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|static
name|char
name|name
index|[
name|NG_NODELEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|name
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"[%x]"
argument_list|,
name|ng_node2ID
argument_list|(
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

end_unit

