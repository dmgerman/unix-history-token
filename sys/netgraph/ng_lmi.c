begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_lmi.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Julian Elischer<julian@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_lmi.c,v 1.38 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * This node performs the frame relay LMI protocol. It knows how  * to do ITU Annex A, ANSI Annex D, and "Group-of-Four" variants  * of the protocol.  *  * A specific protocol can be forced by connecting the corresponding  * hook to DLCI 0 or 1023 (as appropriate) of a frame relay link.  *  * Alternately, this node can do auto-detection of the LMI protocol  * by connecting hook "auto0" to DLCI 0 and "auto1023" to DLCI 1023.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_lmi.h>
end_include

begin_comment
comment|/*  * Human readable names for LMI  */
end_comment

begin_define
define|#
directive|define
name|NAME_ANNEXA
value|NG_LMI_HOOK_ANNEXA
end_define

begin_define
define|#
directive|define
name|NAME_ANNEXD
value|NG_LMI_HOOK_ANNEXD
end_define

begin_define
define|#
directive|define
name|NAME_GROUP4
value|NG_LMI_HOOK_GROUPOF4
end_define

begin_define
define|#
directive|define
name|NAME_NONE
value|"None"
end_define

begin_define
define|#
directive|define
name|MAX_DLCIS
value|128
end_define

begin_define
define|#
directive|define
name|MAXDLCI
value|1023
end_define

begin_comment
comment|/*  * DLCI states  */
end_comment

begin_define
define|#
directive|define
name|DLCI_NULL
value|0
end_define

begin_define
define|#
directive|define
name|DLCI_UP
value|1
end_define

begin_define
define|#
directive|define
name|DLCI_DOWN
value|2
end_define

begin_comment
comment|/*  * Any received LMI frame should be at least this long  */
end_comment

begin_define
define|#
directive|define
name|LMI_MIN_LENGTH
value|8
end_define

begin_comment
comment|/* XXX verify */
end_comment

begin_comment
comment|/*  * Netgraph node methods and type descriptor  */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|nglmi_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|nglmi_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|nglmi_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|nglmi_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|nglmi_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|nglmi_disconnect
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nglmi_checkdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_LMI_NODE_TYPE
block|,
name|NULL
block|,
name|nglmi_constructor
block|,
name|nglmi_rcvmsg
block|,
name|nglmi_rmnode
block|,
name|nglmi_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|nglmi_rcvdata
block|,
name|nglmi_rcvdata
block|,
name|nglmi_disconnect
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|lmi
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Info and status per node  */
end_comment

begin_struct
struct|struct
name|nglmi_softc
block|{
name|node_p
name|node
decl_stmt|;
comment|/* netgraph node */
name|int
name|flags
decl_stmt|;
comment|/* state */
name|int
name|poll_count
decl_stmt|;
comment|/* the count of times for autolmi */
name|int
name|poll_state
decl_stmt|;
comment|/* state of auto detect machine */
name|u_char
name|remote_seq
decl_stmt|;
comment|/* sequence number the remote sent */
name|u_char
name|local_seq
decl_stmt|;
comment|/* last sequence number we sent */
name|u_char
name|protoID
decl_stmt|;
comment|/* 9 for group of 4, 8 otherwise */
name|u_long
name|seq_retries
decl_stmt|;
comment|/* sent this how many time so far */
name|struct
name|callout_handle
name|handle
decl_stmt|;
comment|/* see timeout(9) */
name|int
name|liv_per_full
decl_stmt|;
name|int
name|liv_rate
decl_stmt|;
name|int
name|livs
decl_stmt|;
name|int
name|need_full
decl_stmt|;
name|hook_p
name|lmi_channel
decl_stmt|;
comment|/* whatever we ended up using */
name|hook_p
name|lmi_annexA
decl_stmt|;
name|hook_p
name|lmi_annexD
decl_stmt|;
name|hook_p
name|lmi_group4
decl_stmt|;
name|hook_p
name|lmi_channel0
decl_stmt|;
comment|/* auto-detect on DLCI 0 */
name|hook_p
name|lmi_channel1023
decl_stmt|;
comment|/* auto-detect on DLCI 1023 */
name|char
modifier|*
name|protoname
decl_stmt|;
comment|/* cache protocol name */
name|u_char
name|dlci_state
index|[
name|MAXDLCI
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|invalidx
decl_stmt|;
comment|/* next dlci's to invalidate */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|nglmi_softc
modifier|*
name|sc_p
typedef|;
end_typedef

begin_comment
comment|/*  * Other internal functions  */
end_comment

begin_function_decl
specifier|static
name|void
name|LMI_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nglmi_startup_fixed
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|hook_p
name|hook
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nglmi_startup_auto
parameter_list|(
name|sc_p
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nglmi_startup
parameter_list|(
name|sc_p
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nglmi_inquire
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ngauto_state_machine
parameter_list|(
name|sc_p
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Values for 'flags' field  * NB: the SCF_CONNECTED flag is set if and only if the timer is running.  */
end_comment

begin_define
define|#
directive|define
name|SCF_CONNECTED
value|0x01
end_define

begin_comment
comment|/* connected to something */
end_comment

begin_define
define|#
directive|define
name|SCF_AUTO
value|0x02
end_define

begin_comment
comment|/* we are auto-detecting */
end_comment

begin_define
define|#
directive|define
name|SCF_FIXED
value|0x04
end_define

begin_comment
comment|/* we are fixed from the start */
end_comment

begin_define
define|#
directive|define
name|SCF_LMITYPE
value|0x18
end_define

begin_comment
comment|/* mask for determining Annex mode */
end_comment

begin_define
define|#
directive|define
name|SCF_NOLMI
value|0x00
end_define

begin_comment
comment|/* no LMI type selected yet */
end_comment

begin_define
define|#
directive|define
name|SCF_ANNEX_A
value|0x08
end_define

begin_comment
comment|/* running annex A mode */
end_comment

begin_define
define|#
directive|define
name|SCF_ANNEX_D
value|0x10
end_define

begin_comment
comment|/* running annex D mode */
end_comment

begin_define
define|#
directive|define
name|SCF_GROUP4
value|0x18
end_define

begin_comment
comment|/* running group of 4 */
end_comment

begin_define
define|#
directive|define
name|SETLMITYPE
parameter_list|(
name|sc
parameter_list|,
name|annex
parameter_list|)
define|\
value|do {									\ 	(sc)->flags&= ~SCF_LMITYPE;					\ 	(sc)->flags |= (annex);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|NOPROTO
parameter_list|(
name|sc
parameter_list|)
value|(((sc)->flags& SCF_LMITYPE) == SCF_NOLMI)
end_define

begin_define
define|#
directive|define
name|ANNEXA
parameter_list|(
name|sc
parameter_list|)
value|(((sc)->flags& SCF_LMITYPE) == SCF_ANNEX_A)
end_define

begin_define
define|#
directive|define
name|ANNEXD
parameter_list|(
name|sc
parameter_list|)
value|(((sc)->flags& SCF_LMITYPE) == SCF_ANNEX_D)
end_define

begin_define
define|#
directive|define
name|GROUP4
parameter_list|(
name|sc
parameter_list|)
value|(((sc)->flags& SCF_LMITYPE) == SCF_GROUP4)
end_define

begin_define
define|#
directive|define
name|LMIPOLLSIZE
value|3
end_define

begin_define
define|#
directive|define
name|LMI_PATIENCE
value|8
end_define

begin_comment
comment|/* declare all DLCI DOWN after N LMI failures */
end_comment

begin_comment
comment|/*  * Node constructor  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|sc_p
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|MALLOC
argument_list|(
name|sc
argument_list|,
name|sc_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|sc
operator|->
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_NONE
expr_stmt|;
name|sc
operator|->
name|node
operator|=
operator|*
name|nodep
expr_stmt|;
name|sc
operator|->
name|liv_per_full
operator|=
name|NG_LMI_SEQ_PER_FULL
expr_stmt|;
comment|/* make this dynamic */
name|sc
operator|->
name|liv_rate
operator|=
name|NG_LMI_KEEPALIVE_RATE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The LMI channel has a private pointer which is the same as the  * node private pointer. The debug channel has a NULL private pointer.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_DEBUG
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hook
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_CONNECTED
condition|)
block|{
comment|/* already connected, return an error */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_ANNEXA
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|lmi_annexA
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
name|sc
operator|->
name|protoID
operator|=
literal|8
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_A
argument_list|)
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_ANNEXA
expr_stmt|;
name|nglmi_startup_fixed
argument_list|(
name|sc
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_ANNEXD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|lmi_annexD
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
name|sc
operator|->
name|protoID
operator|=
literal|8
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_D
argument_list|)
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_ANNEXD
expr_stmt|;
name|nglmi_startup_fixed
argument_list|(
name|sc
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_GROUPOF4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|lmi_group4
operator|=
name|hook
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
name|sc
operator|->
name|protoID
operator|=
literal|9
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_GROUP4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_GROUP4
expr_stmt|;
name|nglmi_startup_fixed
argument_list|(
name|sc
argument_list|,
name|hook
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_AUTO0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Note this, and if B is already installed, we're complete */
name|sc
operator|->
name|lmi_channel0
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_NONE
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmi_channel1023
condition|)
name|nglmi_startup_auto
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|NG_LMI_HOOK_AUTO1023
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Note this, and if A is already installed, we're complete */
name|sc
operator|->
name|lmi_channel1023
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|protoname
operator|=
name|NAME_NONE
expr_stmt|;
name|hook
operator|->
name|private
operator|=
name|node
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmi_channel0
condition|)
name|nglmi_startup_auto
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* unknown hook */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have just attached to a live (we hope) node.  * Fire out a LMI inquiry, and then start up the timers.  */
end_comment

begin_function
specifier|static
name|void
name|LMI_ticker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sc_p
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
condition|)
block|{
name|ngauto_state_machine
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|handle
operator|=
name|timeout
argument_list|(
name|LMI_ticker
argument_list|,
name|sc
argument_list|,
name|NG_LMI_POLL_RATE
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|livs
operator|++
operator|>=
name|sc
operator|->
name|liv_per_full
condition|)
block|{
name|nglmi_inquire
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* sc->livs = 0; */
comment|/* do this when we get the answer! */
block|}
else|else
block|{
name|nglmi_inquire
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|handle
operator|=
name|timeout
argument_list|(
name|LMI_ticker
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|liv_rate
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nglmi_startup_fixed
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|hook_p
name|hook
parameter_list|)
block|{
name|sc
operator|->
name|flags
operator||=
operator|(
name|SCF_FIXED
operator||
name|SCF_CONNECTED
operator|)
expr_stmt|;
name|sc
operator|->
name|lmi_channel
operator|=
name|hook
expr_stmt|;
name|nglmi_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nglmi_startup_auto
parameter_list|(
name|sc_p
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|flags
operator||=
operator|(
name|SCF_AUTO
operator||
name|SCF_CONNECTED
operator|)
expr_stmt|;
name|sc
operator|->
name|poll_state
operator|=
literal|0
expr_stmt|;
comment|/* reset state machine */
name|sc
operator|->
name|poll_count
operator|=
literal|0
expr_stmt|;
name|nglmi_startup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nglmi_startup
parameter_list|(
name|sc_p
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|remote_seq
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|local_seq
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|seq_retries
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|livs
operator|=
name|sc
operator|->
name|liv_per_full
operator|-
literal|1
expr_stmt|;
comment|/* start off the ticker in 1 sec */
name|sc
operator|->
name|handle
operator|=
name|timeout
argument_list|(
name|LMI_ticker
argument_list|,
name|sc
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|META_PAD
value|16
end_define

begin_function
specifier|static
name|void
name|nglmi_inquire
parameter_list|(
name|sc_p
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|start
decl_stmt|;
name|int
name|error
decl_stmt|;
name|meta_p
name|meta
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|lmi_channel
operator|==
name|NULL
condition|)
return|return;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nglmi: unable to start up LMI processing\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate a meta struct (and leave some slop for options to be 	 * added by other modules). */
comment|/* MALLOC(meta, meta_p, sizeof( struct ng_meta) + META_PAD, 	 * M_NETGRAPH, M_NOWAIT); */
name|MALLOC
argument_list|(
name|meta
argument_list|,
name|meta_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
operator|+
name|META_PAD
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta
operator|!=
name|NULL
condition|)
block|{
comment|/* if it failed, well, it was optional anyhow */
name|meta
operator|->
name|used_len
operator|=
operator|(
name|u_short
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ng_meta
argument_list|)
expr_stmt|;
name|meta
operator|->
name|allocated_len
operator|=
operator|(
name|u_short
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|ng_meta
argument_list|)
operator|+
name|META_PAD
expr_stmt|;
name|meta
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|meta
operator|->
name|priority
operator|=
name|NG_LMI_LMI_PRIORITY
expr_stmt|;
name|meta
operator|->
name|discardability
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|m
operator|->
name|m_data
operator|+=
literal|4
expr_stmt|;
comment|/* leave some room for a header */
name|cptr
operator|=
name|start
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* add in the header for an LMI inquiry. */
operator|*
name|cptr
operator|++
operator|=
literal|0x03
expr_stmt|;
comment|/* UI frame */
if|if
condition|(
name|GROUP4
argument_list|(
name|sc
argument_list|)
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|0x09
expr_stmt|;
comment|/* proto discriminator */
else|else
operator|*
name|cptr
operator|++
operator|=
literal|0x08
expr_stmt|;
comment|/* proto discriminator */
operator|*
name|cptr
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* call reference */
operator|*
name|cptr
operator|++
operator|=
literal|0x75
expr_stmt|;
comment|/* inquiry */
comment|/* If we are Annex-D, there is this extra thing.. */
if|if
condition|(
name|ANNEXD
argument_list|(
name|sc
argument_list|)
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|0x95
expr_stmt|;
comment|/* ??? */
comment|/* Add a request type */
if|if
condition|(
name|ANNEXA
argument_list|(
name|sc
argument_list|)
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|0x51
expr_stmt|;
comment|/* report type */
else|else
operator|*
name|cptr
operator|++
operator|=
literal|0x01
expr_stmt|;
comment|/* report type */
operator|*
name|cptr
operator|++
operator|=
literal|0x01
expr_stmt|;
comment|/* size = 1 */
if|if
condition|(
name|full
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|0x00
expr_stmt|;
comment|/* full */
else|else
operator|*
name|cptr
operator|++
operator|=
literal|0x01
expr_stmt|;
comment|/* partial */
comment|/* Add a link verification IE */
if|if
condition|(
name|ANNEXA
argument_list|(
name|sc
argument_list|)
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|0x53
expr_stmt|;
comment|/* verification IE */
else|else
operator|*
name|cptr
operator|++
operator|=
literal|0x03
expr_stmt|;
comment|/* verification IE */
operator|*
name|cptr
operator|++
operator|=
literal|0x02
expr_stmt|;
comment|/* 2 extra bytes */
operator|*
name|cptr
operator|++
operator|=
name|sc
operator|->
name|local_seq
expr_stmt|;
operator|*
name|cptr
operator|++
operator|=
name|sc
operator|->
name|remote_seq
expr_stmt|;
name|sc
operator|->
name|seq_retries
operator|++
expr_stmt|;
comment|/* Send it */
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|cptr
operator|-
name|start
expr_stmt|;
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|lmi_channel
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|/* If we've been sending requests for long enough, and there has 	 * been no response, then mark as DOWN, any DLCIs that are UP. */
if|if
condition|(
name|sc
operator|->
name|seq_retries
operator|==
name|LMI_PATIENCE
condition|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|MAXDLCI
condition|;
name|count
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|count
index|]
operator|==
name|DLCI_UP
condition|)
name|sc
operator|->
name|dlci_state
index|[
name|count
index|]
operator|=
name|DLCI_DOWN
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * State machine for LMI auto-detect. The transitions are ordered  * to try the more likely possibilities first.  */
end_comment

begin_function
specifier|static
name|void
name|ngauto_state_machine
parameter_list|(
name|sc_p
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|poll_count
operator|<=
literal|0
operator|)
operator|||
operator|(
name|sc
operator|->
name|poll_count
operator|>
name|LMIPOLLSIZE
operator|)
condition|)
block|{
comment|/* time to change states in the auto probe machine */
comment|/* capture wild values of poll_count while we are at it */
name|sc
operator|->
name|poll_count
operator|=
name|LMIPOLLSIZE
expr_stmt|;
name|sc
operator|->
name|poll_state
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|sc
operator|->
name|poll_state
condition|)
block|{
case|case
literal|7
case|:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: no response from exchange\n"
argument_list|)
expr_stmt|;
default|default:
comment|/* capture bad states */
name|sc
operator|->
name|poll_state
operator|=
literal|1
expr_stmt|;
case|case
literal|1
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel0
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_D
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel1023
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_D
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel0
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_A
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel1023
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_GROUP4
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel1023
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_A
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|sc
operator|->
name|lmi_channel
operator|=
name|sc
operator|->
name|lmi_channel0
expr_stmt|;
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_GROUP4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* send an inquirey encoded appropriatly */
name|nglmi_inquire
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|poll_count
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Receive a netgraph control message.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|retaddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|resp
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_GENERIC_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_TEXT_STATUS
case|:
block|{
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|pos
decl_stmt|,
name|count
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
operator|*
name|resp
argument_list|,
name|msg
argument_list|,
name|NG_TEXTRESPONSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|resp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|arg
operator|=
operator|(
operator|*
name|resp
operator|)
operator|->
name|data
expr_stmt|;
name|pos
operator|=
name|sprintf
argument_list|(
name|arg
argument_list|,
literal|"protocol %s "
argument_list|,
name|sc
operator|->
name|protoname
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_FIXED
condition|)
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"fixed\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
condition|)
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"auto-detecting\n"
argument_list|)
expr_stmt|;
else|else
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"auto on dlci %d\n"
argument_list|,
operator|(
name|sc
operator|->
name|lmi_channel
operator|==
name|sc
operator|->
name|lmi_channel0
operator|)
condition|?
literal|0
else|:
literal|1023
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"keepalive period: %d seconds\n"
argument_list|,
name|sc
operator|->
name|liv_rate
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"unacknowledged keepalives: %ld\n"
argument_list|,
name|sc
operator|->
name|seq_retries
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
operator|(
operator|(
name|count
operator|<=
name|MAXDLCI
operator|)
operator|&&
operator|(
name|pos
operator|<
operator|(
name|NG_TEXTRESPONSE
operator|-
literal|20
operator|)
operator|)
operator|)
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|count
index|]
condition|)
block|{
name|pos
operator|+=
name|sprintf
argument_list|(
name|arg
operator|+
name|pos
argument_list|,
literal|"dlci %d %s\n"
argument_list|,
name|count
argument_list|,
operator|(
name|sc
operator|->
name|dlci_state
index|[
name|count
index|]
operator|==
name|DLCI_UP
operator|)
condition|?
literal|"up"
else|:
literal|"down"
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
operator|*
name|resp
operator|)
operator|->
name|header
operator|.
name|arglen
operator|=
name|pos
operator|+
literal|1
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_LMI_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_LMI_GET_STATUS
case|:
block|{
name|struct
name|nglmistat
modifier|*
name|stat
decl_stmt|;
name|int
name|k
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
operator|*
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stat
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|resp
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|stat
operator|=
operator|(
expr|struct
name|nglmistat
operator|*
operator|)
operator|(
operator|*
name|resp
operator|)
operator|->
name|data
expr_stmt|;
name|strncpy
argument_list|(
name|stat
operator|->
name|proto
argument_list|,
name|sc
operator|->
name|protoname
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
operator|->
name|proto
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|stat
operator|->
name|hook
argument_list|,
name|sc
operator|->
name|protoname
argument_list|,
sizeof|sizeof
argument_list|(
name|stat
operator|->
name|hook
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|stat
operator|->
name|autod
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
operator|)
expr_stmt|;
name|stat
operator|->
name|fixed
operator|=
operator|!
operator|!
operator|(
name|sc
operator|->
name|flags
operator|&
name|SCF_FIXED
operator|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|MAXDLCI
condition|;
name|k
operator|++
control|)
block|{
switch|switch
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|k
index|]
condition|)
block|{
case|case
name|DLCI_UP
case|:
name|stat
operator|->
name|up
index|[
name|k
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|k
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
comment|/* fall through */
case|case
name|DLCI_DOWN
case|:
name|stat
operator|->
name|seen
index|[
name|k
operator|/
literal|8
index|]
operator||=
operator|(
literal|1
operator|<<
operator|(
name|k
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
break|break;
block|}
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|STEPBY
parameter_list|(
name|stepsize
parameter_list|)
define|\
value|do {					\ 		packetlen -= (stepsize);	\ 		data += (stepsize);		\ 	} while (0)
end_define

begin_comment
comment|/*  * receive data, and use it to update our status.  * Anything coming in on the debug port is discarded.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|ret_m
parameter_list|,
name|meta_p
modifier|*
name|ret_meta
parameter_list|)
block|{
name|sc_p
name|sc
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|short
name|dlci
decl_stmt|;
name|u_short
name|packetlen
decl_stmt|;
name|int
name|resptype_seen
init|=
literal|0
decl_stmt|;
name|int
name|seq_seen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hook
operator|->
name|private
operator|==
name|NULL
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
name|packetlen
operator|=
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
expr_stmt|;
comment|/* XXX what if it's more than 1 mbuf? */
if|if
condition|(
operator|(
name|packetlen
operator|>
name|MHLEN
operator|)
operator|&&
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: packetlen (%d) too big\n"
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|packetlen
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|packetlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: m_pullup failed for %d bytes\n"
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nglmi_checkdata
argument_list|(
name|hook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pass the first 4 bytes (already checked in the nglmi_checkdata()) */
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|STEPBY
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* Now check if there is a 'locking shift'. This is only seen in 	 * Annex D frames. don't bother checking, we already did that. Don't 	 * increment immediatly as it might not be there. */
if|if
condition|(
name|ANNEXD
argument_list|(
name|sc
argument_list|)
condition|)
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we get this far we should consider that it is a legitimate 	 * frame and we know what it is. */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
condition|)
block|{
comment|/* note the hook that this valid channel came from and drop 		 * out of auto probe mode. */
if|if
condition|(
name|ANNEXA
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|protoname
operator|=
name|NAME_ANNEXA
expr_stmt|;
elseif|else
if|if
condition|(
name|ANNEXD
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|protoname
operator|=
name|NAME_ANNEXD
expr_stmt|;
elseif|else
if|if
condition|(
name|GROUP4
argument_list|(
name|sc
argument_list|)
condition|)
name|sc
operator|->
name|protoname
operator|=
name|NAME_GROUP4
expr_stmt|;
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nglmi: No known type\n"
argument_list|)
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|sc
operator|->
name|lmi_channel
operator|=
name|hook
expr_stmt|;
name|sc
operator|->
name|flags
operator|&=
operator|~
name|SCF_AUTO
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nglmi: auto-detected %s LMI on DLCI %d\n"
argument_list|,
name|sc
operator|->
name|protoname
argument_list|,
name|hook
operator|==
name|sc
operator|->
name|lmi_channel0
condition|?
literal|0
else|:
literal|1023
argument_list|)
expr_stmt|;
block|}
comment|/* While there is more data in the status packet, keep processing 	 * status items. First make sure there is enough data for the 	 * segment descriptor's length field. */
while|while
condition|(
name|packetlen
operator|>=
literal|2
condition|)
block|{
name|u_int
name|segtype
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
name|u_int
name|segsize
init|=
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* Now that we know how long it claims to be, make sure 		 * there is enough data for the next seg. */
if|if
condition|(
name|packetlen
operator|<
name|segsize
operator|+
literal|2
condition|)
break|break;
switch|switch
condition|(
name|segtype
condition|)
block|{
case|case
literal|0x01
case|:
case|case
literal|0x51
case|:
if|if
condition|(
name|resptype_seen
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: dup MSGTYPE\n"
argument_list|)
expr_stmt|;
goto|goto
name|nextIE
goto|;
block|}
name|resptype_seen
operator|++
expr_stmt|;
comment|/* The remote end tells us what kind of response 			 * this is. Only expect a type 0 or 1. if we are a 			 * full status, invalidate a few DLCIs just to see 			 * that they are still ok. */
if|if
condition|(
name|segsize
operator|!=
literal|1
condition|)
goto|goto
name|nextIE
goto|;
switch|switch
condition|(
name|data
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|1
case|:
comment|/* partial status, do no extra processing */
break|break;
case|case
literal|0
case|:
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|idx
init|=
name|sc
operator|->
name|invalidx
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|10
condition|;
name|count
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|>
name|MAXDLCI
condition|)
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|idx
index|]
operator|==
name|DLCI_UP
condition|)
name|sc
operator|->
name|dlci_state
index|[
name|idx
index|]
operator|=
name|DLCI_DOWN
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|invalidx
operator|=
name|idx
expr_stmt|;
comment|/* we got and we wanted one. relax 				 * now.. but don't reset to 0 if it 				 * was unrequested. */
if|if
condition|(
name|sc
operator|->
name|livs
operator|>
name|sc
operator|->
name|liv_per_full
condition|)
name|sc
operator|->
name|livs
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
literal|0x03
case|:
case|case
literal|0x53
case|:
comment|/* The remote tells us what it thinks the sequence 			 * numbers are. If it's not size 2, it must be a 			 * duplicate to have gotten this far, skip it. */
if|if
condition|(
name|seq_seen
operator|!=
literal|0
condition|)
comment|/* already seen seq numbers */
goto|goto
name|nextIE
goto|;
if|if
condition|(
name|segsize
operator|!=
literal|2
condition|)
goto|goto
name|nextIE
goto|;
name|sc
operator|->
name|remote_seq
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|local_seq
operator|==
name|data
index|[
literal|3
index|]
condition|)
block|{
name|sc
operator|->
name|local_seq
operator|++
expr_stmt|;
name|sc
operator|->
name|seq_retries
operator|=
literal|0
expr_stmt|;
comment|/* Note that all 3 Frame protocols seem to 				 * not like 0 as a sequence number. */
if|if
condition|(
name|sc
operator|->
name|local_seq
operator|==
literal|0
condition|)
name|sc
operator|->
name|local_seq
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|0x07
case|:
case|case
literal|0x57
case|:
comment|/* The remote tells us about a DLCI that it knows 			 * about. There may be many of these in a single 			 * status response */
switch|switch
condition|(
name|segsize
condition|)
block|{
case|case
literal|6
case|:
comment|/* only on 'group of 4' */
name|dlci
operator|=
operator|(
operator|(
name|u_short
operator|)
name|data
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
name|dlci
operator||=
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dlci
operator|<
literal|1024
operator|)
operator|&&
operator|(
name|dlci
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* XXX */
block|}
break|break;
case|case
literal|3
case|:
name|dlci
operator|=
operator|(
operator|(
name|u_short
operator|)
name|data
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|4
expr_stmt|;
name|dlci
operator||=
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0x78
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|dlci
operator|<
literal|1024
operator|)
operator|&&
operator|(
name|dlci
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* set up the bottom half of the 					 * support for that dlci if it's not 					 * already been done */
comment|/* store this information somewhere */
block|}
break|break;
default|default:
goto|goto
name|nextIE
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|dlci
index|]
operator|!=
name|DLCI_UP
condition|)
block|{
comment|/* bring new DLCI to life */
comment|/* may do more here some day */
if|if
condition|(
name|sc
operator|->
name|dlci_state
index|[
name|dlci
index|]
operator|!=
name|DLCI_DOWN
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nglmi: DLCI %d became active\n"
argument_list|,
name|dlci
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dlci_state
index|[
name|dlci
index|]
operator|=
name|DLCI_UP
expr_stmt|;
block|}
break|break;
block|}
name|nextIE
label|:
name|STEPBY
argument_list|(
name|segsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|drop
label|:
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that a packet is entirely kosha.  * return 1 of ok, and 0 if not.  * All data is discarded if a 0 is returned.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_checkdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
name|sc_p
name|sc
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_short
name|packetlen
decl_stmt|;
name|unsigned
name|short
name|dlci
decl_stmt|;
name|u_char
name|type
decl_stmt|;
name|u_char
name|nextbyte
decl_stmt|;
name|int
name|seq_seen
init|=
literal|0
decl_stmt|;
name|int
name|resptype_seen
init|=
literal|0
decl_stmt|;
comment|/* 0 , 1 (partial) or 2 (full) */
name|int
name|highest_dlci
init|=
literal|0
decl_stmt|;
name|packetlen
operator|=
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
expr_stmt|;
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|data
operator|!=
literal|0x03
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected value in LMI(%d)\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* look at the protocol ID */
name|nextbyte
operator|=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
condition|)
block|{
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_NOLMI
argument_list|)
expr_stmt|;
comment|/* start with a clean slate */
switch|switch
condition|(
name|nextbyte
condition|)
block|{
case|case
literal|0x8
case|:
name|sc
operator|->
name|protoID
operator|=
literal|8
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_GROUP4
argument_list|)
expr_stmt|;
name|sc
operator|->
name|protoID
operator|=
literal|9
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: bad Protocol ID(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|nextbyte
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|nextbyte
operator|!=
name|sc
operator|->
name|protoID
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected Protocol ID(%d)\n"
argument_list|,
operator|(
name|int
operator|)
name|nextbyte
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* check call reference (always null in non ISDN frame relay) */
if|if
condition|(
operator|*
name|data
operator|!=
literal|0x00
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected Call Reference (0x%x)\n"
argument_list|,
name|data
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* check message type */
switch|switch
condition|(
operator|(
name|type
operator|=
operator|*
name|data
operator|)
condition|)
block|{
case|case
literal|0x75
case|:
comment|/* Status enquiry */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected message type(0x%x)\n"
argument_list|,
name|data
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
case|case
literal|0x7D
case|:
comment|/* Status message */
break|break;
default|default:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected msg type(0x%x) \n"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Now check if there is a 'locking shift'. This is only seen in 	 * Annex D frames. Don't increment immediately as it might not be 	 * there. */
name|nextbyte
operator|=
operator|*
name|data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_AUTO
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|GROUP4
argument_list|(
name|sc
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|nextbyte
operator|==
literal|0x95
condition|)
block|{
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_D
argument_list|)
expr_stmt|;
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|SETLMITYPE
argument_list|(
name|sc
argument_list|,
name|SCF_ANNEX_A
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextbyte
operator|==
literal|0x95
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: locking shift seen in G4\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ANNEXD
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|data
operator|==
literal|0x95
condition|)
name|STEPBY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: locking shift missing\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|data
operator|==
literal|0x95
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: locking shift seen\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
block|}
comment|/* While there is more data in the status packet, keep processing 	 * status items. First make sure there is enough data for the 	 * segment descriptor's length field. */
while|while
condition|(
name|packetlen
operator|>=
literal|2
condition|)
block|{
name|u_int
name|segtype
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
name|u_int
name|segsize
init|=
name|data
index|[
literal|1
index|]
decl_stmt|;
comment|/* Now that we know how long it claims to be, make sure 		 * there is enough data for the next seg. */
if|if
condition|(
name|packetlen
operator|<
operator|(
name|segsize
operator|+
literal|2
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: IE longer than packet\n"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|segtype
condition|)
block|{
case|case
literal|0x01
case|:
case|case
literal|0x51
case|:
comment|/* According to MCI's HP analyser, we should just 			 * ignore if there is mor ethan one of these (?). */
if|if
condition|(
name|resptype_seen
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: dup MSGTYPE\n"
argument_list|)
expr_stmt|;
goto|goto
name|nextIE
goto|;
block|}
if|if
condition|(
name|segsize
operator|!=
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: MSGTYPE wrong size\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
comment|/* The remote end tells us what kind of response 			 * this is. Only expect a type 0 or 1. if it was a 			 * full (type 0) check we just asked for a type 			 * full. */
switch|switch
condition|(
name|data
index|[
literal|2
index|]
condition|)
block|{
case|case
literal|1
case|:
comment|/* partial */
if|if
condition|(
name|sc
operator|->
name|livs
operator|>
name|sc
operator|->
name|liv_per_full
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: LIV when FULL expected\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
comment|/* need full */
block|}
name|resptype_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* full */
comment|/* Full response is always acceptable */
name|resptype_seen
operator|=
literal|2
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: Unknown report type %d\n"
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
break|break;
case|case
literal|0x03
case|:
case|case
literal|0x53
case|:
comment|/* The remote tells us what it thinks the sequence 			 * numbers are. I would have thought that there 			 * needs to be one and only one of these, but MCI 			 * want us to just ignore extras. (?) */
if|if
condition|(
name|resptype_seen
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: no TYPE before SEQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
if|if
condition|(
name|seq_seen
operator|!=
literal|0
condition|)
comment|/* already seen seq numbers */
goto|goto
name|nextIE
goto|;
if|if
condition|(
name|segsize
operator|!=
literal|2
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: bad SEQ sts size\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|local_seq
operator|!=
name|data
index|[
literal|3
index|]
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unexpected SEQ\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|seq_seen
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x07
case|:
case|case
literal|0x57
case|:
comment|/* The remote tells us about a DLCI that it knows 			 * about. There may be many of these in a single 			 * status response */
if|if
condition|(
name|seq_seen
operator|!=
literal|1
condition|)
block|{
comment|/* already seen seq numbers? */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: No sequence before DLCI\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
if|if
condition|(
name|resptype_seen
operator|!=
literal|2
condition|)
block|{
comment|/* must be full */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: No resp type before DLCI\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
if|if
condition|(
name|GROUP4
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|segsize
operator|!=
literal|6
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: wrong IE segsize\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|dlci
operator|=
operator|(
operator|(
name|u_short
operator|)
name|data
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
operator|<<
literal|8
expr_stmt|;
name|dlci
operator||=
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|segsize
operator|!=
literal|3
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: DLCI headersize of %d"
literal|" not supported\n"
argument_list|,
name|segsize
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|dlci
operator|=
operator|(
operator|(
name|u_short
operator|)
name|data
index|[
literal|2
index|]
operator|&
literal|0x3f
operator|)
operator|<<
literal|4
expr_stmt|;
name|dlci
operator||=
operator|(
operator|(
name|data
index|[
literal|3
index|]
operator|&
literal|0x78
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
block|}
comment|/* async can only have one of these */
if|#
directive|if
literal|0
comment|/* async not yet accepted */
block|if (async&& highest_dlci) { 				log(LOG_WARNING, 				    "nglmi: Async with> 1 DLCI\n"); 				goto reject; 			}
endif|#
directive|endif
comment|/* Annex D says these will always be Ascending, but 			 * the HP test for G4 says we should accept 			 * duplicates, so for now allow that. (<= vs.< ) */
if|#
directive|if
literal|0
comment|/* MCI tests want us to accept out of order for AnxD */
block|if ((!GROUP4(sc))&& (dlci< highest_dlci)) {
comment|/* duplicate or mis-ordered dlci */
comment|/* (spec says they will increase in number) */
block|log(LOG_WARNING, "nglmi: DLCI out of order\n"); 				goto reject; 			}
endif|#
directive|endif
if|if
condition|(
name|dlci
operator|>
literal|1023
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: DLCI out of range\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
block|}
name|highest_dlci
operator|=
name|dlci
expr_stmt|;
break|break;
default|default:
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: unknown LMI segment type %d\n"
argument_list|,
name|segtype
argument_list|)
expr_stmt|;
block|}
name|nextIE
label|:
name|STEPBY
argument_list|(
name|segsize
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|packetlen
operator|!=
literal|0
condition|)
block|{
comment|/* partial junk at end? */
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: %d bytes extra at end of packet\n"
argument_list|,
name|packetlen
argument_list|)
expr_stmt|;
goto|goto
name|print
goto|;
block|}
if|if
condition|(
name|resptype_seen
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: No response type seen\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
comment|/* had no response type */
block|}
if|if
condition|(
name|seq_seen
operator|==
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: No sequence numbers seen\n"
argument_list|)
expr_stmt|;
goto|goto
name|reject
goto|;
comment|/* had no sequence numbers */
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|print
label|:
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|pos
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|loc
decl_stmt|;
name|u_char
modifier|*
name|bp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|;
name|k
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
operator|-
name|packetlen
operator|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: error at location %d\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|<
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|++
operator|<
literal|16
operator|)
operator|&&
name|k
operator|<
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
condition|)
block|{
name|pos
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
literal|"%c%02x"
argument_list|,
operator|(
operator|(
name|loc
operator|==
name|k
operator|)
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: packet data:%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%04d              :%s\n"
argument_list|,
name|k
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|reject
label|:
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|pos
decl_stmt|;
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|loc
decl_stmt|;
name|u_char
modifier|*
name|bp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|;
name|k
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|loc
operator|=
operator|(
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
operator|-
name|packetlen
operator|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: error at location %d\n"
argument_list|,
name|loc
argument_list|)
expr_stmt|;
while|while
condition|(
name|k
operator|<
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
condition|)
block|{
name|pos
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|++
operator|<
literal|16
operator|)
operator|&&
name|k
operator|<
name|m
operator|->
name|m_hdr
operator|.
name|mh_len
condition|)
block|{
name|pos
operator|+=
name|sprintf
argument_list|(
name|buf
operator|+
name|pos
argument_list|,
literal|"%c%02x"
argument_list|,
operator|(
operator|(
name|loc
operator|==
name|k
operator|)
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
name|bp
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"nglmi: packet data:%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"%04d              :%s\n"
argument_list|,
name|k
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do local shutdown processing..  * Cut any remaining links and free our local resources.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|node
operator|->
name|private
decl_stmt|;
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sc
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  * For this type, removal of any link except "debug" destroys the node.  */
end_comment

begin_function
specifier|static
name|int
name|nglmi_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|sc_p
name|sc
init|=
name|hook
operator|->
name|node
operator|->
name|private
decl_stmt|;
comment|/* OK to remove debug hook(s) */
if|if
condition|(
name|hook
operator|->
name|private
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Stop timer if it's currently active */
if|if
condition|(
name|sc
operator|->
name|flags
operator|&
name|SCF_CONNECTED
condition|)
name|untimeout
argument_list|(
name|LMI_ticker
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|handle
argument_list|)
expr_stmt|;
comment|/* Self-destruct */
name|ng_rmnode
argument_list|(
name|hook
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

