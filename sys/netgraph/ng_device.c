begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 Mark Santcroos<marks@ripe.net>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Netgraph "device" node  *  * This node presents a /dev/ngd%d device that interfaces to an other   * netgraph node.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioccom.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|"ng_device.h"
end_include

begin_comment
comment|/* turn this on for verbose messages */
end_comment

begin_define
define|#
directive|define
name|NGD_DEBUG
end_define

begin_comment
comment|/* Netgraph methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_device_cons
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_device_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_device_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_connect_t
name|ng_device_connect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_device_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_device_disconnect
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ng_device_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_device_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_free_unit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netgraph type */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_DEVICE_NODE_TYPE
block|,
operator|.
name|mod_event
operator|=
name|ng_device_mod_event
block|,
operator|.
name|constructor
operator|=
name|ng_device_cons
block|,
operator|.
name|rcvmsg
operator|=
name|ng_device_rcvmsg
block|,
operator|.
name|newhook
operator|=
name|ng_device_newhook
block|,
operator|.
name|connect
operator|=
name|ng_device_connect
block|,
operator|.
name|rcvdata
operator|=
name|ng_device_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_device_disconnect
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|device
argument_list|,
operator|&
name|typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* per hook data */
end_comment

begin_struct
struct|struct
name|ngd_connection
block|{
name|SLIST_ENTRY
argument_list|(
argument|ngd_connection
argument_list|)
name|links
expr_stmt|;
name|struct
name|cdev
modifier|*
name|ngddev
decl_stmt|;
name|struct
name|ng_hook
modifier|*
name|active_hook
decl_stmt|;
name|char
modifier|*
name|readq
decl_stmt|;
name|int
name|loc
decl_stmt|;
name|int
name|unit
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* global data */
end_comment

begin_struct
struct|struct
name|ngd_softc
block|{
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|ngd_connection
argument_list|)
name|head
expr_stmt|;
name|node_p
name|node
decl_stmt|;
name|char
name|nodename
index|[
name|NG_NODESIZ
index|]
decl_stmt|;
block|}
name|ngd_softc
struct|;
end_struct

begin_comment
comment|/* the per connection receiving queue maximum */
end_comment

begin_define
define|#
directive|define
name|NGD_QUEUE_SIZE
value|(1024*10)
end_define

begin_comment
comment|/* Maximum number of NGD devices */
end_comment

begin_define
define|#
directive|define
name|MAX_NGD
value|25
end_define

begin_comment
comment|/* should be more than enough for now */
end_comment

begin_decl_stmt
specifier|static
name|d_close_t
name|ngdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|ngdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|ngdread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|ngdwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|ngdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|ngdpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ngd_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_open
operator|=
name|ngdopen
block|,
operator|.
name|d_close
operator|=
name|ngdclose
block|,
operator|.
name|d_read
operator|=
name|ngdread
block|,
operator|.
name|d_write
operator|=
name|ngdwrite
block|,
operator|.
name|d_ioctl
operator|=
name|ngdioctl
block|,
operator|.
name|d_poll
operator|=
name|ngdpoll
block|,
operator|.
name|d_name
operator|=
literal|"ngd"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   * this holds all the stuff that should be done at load time   */
end_comment

begin_function
specifier|static
name|int
name|ng_device_mod_event
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|ng_device_init
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* XXX do we need to do something specific ? */
comment|/* ng_device_breakdown */
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_device_init
parameter_list|()
block|{
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_make_node_common
argument_list|(
operator|&
name|typestruct
argument_list|,
operator|&
name|sc
operator|->
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): ng_make_node_common failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|sc
operator|->
name|nodename
argument_list|,
literal|"%s"
argument_list|,
name|NG_DEVICE_NODE_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_name_node
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
operator|->
name|nodename
argument_list|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|sc
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* make it go away again */
name|printf
argument_list|(
literal|"%s(): ng_name_node failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|NG_NODE_SET_PRIVATE
argument_list|(
name|sc
operator|->
name|node
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * don't allow to be created, only the device can do that   */
end_comment

begin_function
specifier|static
name|int
name|ng_device_cons
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive control message. We just bounce it back as a reply.  */
end_comment

begin_function
specifier|static
name|int
name|ng_device_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|active_hook
operator|==
name|lasthook
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no hook found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_free_unit
parameter_list|()
block|{
name|struct
name|ngd_connection
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|int
name|unit
init|=
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
comment|/* When there is no list yet, the first device unit is always 0. */
if|if SLIST_EMPTY
condition|(
operator|&
name|sc
operator|->
name|head
condition|)
block|{
name|unit
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|unit
operator|)
return|;
block|}
comment|/* Just do a brute force loop to find the first free unit that is 	 * smaller than MAX_NGD. 	 * Set MAX_NGD to a large value, doesn't impact performance. 	 */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|MAX_NGD
operator|&&
name|unit
operator|==
operator|-
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|unit
operator|==
name|n
condition|)
block|{
name|unit
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|unit
operator|=
name|n
expr_stmt|;
block|}
block|}
return|return
operator|(
name|unit
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * incoming hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_device_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|new_connection
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|new_connection
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ngd_connection
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): ERROR: new_connection == NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new_connection
operator|->
name|unit
operator|=
name|get_free_unit
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_connection
operator|->
name|unit
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: No free unit found by get_free_unit(), "
literal|"increas MAX_NGD\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new_connection
operator|->
name|ngddev
operator|=
name|make_dev
argument_list|(
operator|&
name|ngd_cdevsw
argument_list|,
name|new_connection
operator|->
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"ngd%d"
argument_list|,
name|new_connection
operator|->
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_connection
operator|->
name|ngddev
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): make_dev failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|new_connection
operator|->
name|readq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|NGD_QUEUE_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_connection
operator|->
name|readq
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): readq malloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* point to begin of buffer */
name|new_connection
operator|->
name|loc
operator|=
literal|0
expr_stmt|;
name|new_connection
operator|->
name|active_hook
operator|=
name|hook
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|head
argument_list|,
name|new_connection
argument_list|,
name|links
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * we gave ok to a new hook  * now connect  */
end_comment

begin_function
specifier|static
name|int
name|ng_device_connect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data from hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_device_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|active_hook
operator|==
name|hook
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no hook found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): ERROR: m_pullup failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buffer
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|m
operator|->
name|m_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): ERROR: buffer malloc failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buffer
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|connection
operator|->
name|loc
operator|+
name|m
operator|->
name|m_len
operator|)
operator|<
name|NGD_QUEUE_SIZE
condition|)
block|{
name|memcpy
argument_list|(
name|connection
operator|->
name|readq
operator|+
name|connection
operator|->
name|loc
argument_list|,
name|buffer
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|connection
operator|->
name|loc
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s(): queue full, first read out a bit\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removal of the last link destroys the node  */
end_comment

begin_function
specifier|static
name|int
name|ng_device_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|active_hook
operator|==
name|hook
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no hook found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|free
argument_list|(
name|connection
operator|->
name|readq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|destroy_dev
argument_list|(
name|connection
operator|->
name|ngddev
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|head
argument_list|,
name|connection
argument_list|,
name|ngd_connection
argument_list|,
name|links
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the device is opened   */
end_comment

begin_function
specifier|static
name|int
name|ngdopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * the device is closed   */
end_comment

begin_function
specifier|static
name|int
name|ngdclose
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process ioctl  *  * they are translated into netgraph messages and passed on  *   */
end_comment

begin_function
specifier|static
name|int
name|ngdioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|struct
name|ngd_param_s
modifier|*
name|datap
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|ngddev
operator|==
name|dev
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no dev found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* NG_MKMESSAGE(msg, cookie, cmdid, len, how) */
name|NG_MKMESSAGE
argument_list|(
name|msg
argument_list|,
name|NGM_DEVICE_COOKIE
argument_list|,
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ngd_param_s
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): msg == NULL\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|nomsg
goto|;
block|}
comment|/* pass the ioctl data into the ->data area */
name|datap
operator|=
operator|(
expr|struct
name|ngd_param_s
operator|*
operator|)
name|msg
operator|->
name|data
expr_stmt|;
name|datap
operator|->
name|p
operator|=
name|addr
expr_stmt|;
comment|/* NG_SEND_MSG_HOOK(error, here, msg, hook, retaddr) */
name|NG_SEND_MSG_HOOK
argument_list|(
name|error
argument_list|,
name|sc
operator|->
name|node
argument_list|,
name|msg
argument_list|,
name|connection
operator|->
name|active_hook
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s(): NG_SEND_MSG_HOOK error: %d\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|nomsg
label|:
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a read(2) is done to our device.  * We pass the data available in kernelspace on into userland using  * uiomove.  */
end_comment

begin_function
specifier|static
name|int
name|ngdread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|amnt
decl_stmt|;
name|char
name|buffer
index|[
name|uio
operator|->
name|uio_resid
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|ngddev
operator|==
name|dev
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no dev found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|&&
operator|(
name|connection
operator|->
name|loc
operator|>
literal|0
operator|)
condition|)
block|{
name|amnt
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|connection
operator|->
name|loc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|connection
operator|->
name|readq
argument_list|,
name|amnt
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|connection
operator|->
name|readq
argument_list|,
name|connection
operator|->
name|readq
operator|+
name|amnt
argument_list|,
name|connection
operator|->
name|loc
operator|-
name|amnt
argument_list|)
expr_stmt|;
name|connection
operator|->
name|loc
operator|-=
name|amnt
expr_stmt|;
name|ret
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buffer
argument_list|,
name|amnt
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|printf
argument_list|(
literal|"%s(): uiomove returns error %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* do error cleanup here */
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * This function is called when our device is written to.  * We read the data from userland into our local buffer and pass it on  * into the remote hook.  *  */
end_comment

begin_function
specifier|static
name|int
name|ngdwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|char
name|buffer
index|[
name|uio
operator|->
name|uio_resid
index|]
decl_stmt|;
name|int
name|len
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|NGD_DEBUG
name|printf
argument_list|(
literal|"%s()\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* NGD_DEBUG */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|ngddev
operator|==
name|dev
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): connection is still NULL, no dev found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|buffer
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
else|else
name|printf
argument_list|(
literal|"%s(): len<= 0 : is this supposed to happen?!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_devget
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_SEND_DATA_ONLY
argument_list|(
name|error
argument_list|,
name|connection
operator|->
name|active_hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
comment|/* do error cleanup here */
name|printf
argument_list|(
literal|"%s(): uiomove returned err: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * we are being polled/selected  * check if there is data available for read  */
end_comment

begin_function
specifier|static
name|int
name|ngdpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|struct
name|ngd_softc
modifier|*
name|sc
init|=
operator|&
name|ngd_softc
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|struct
name|ngd_connection
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
comment|/* get the connection we have to know the loc from */
name|SLIST_FOREACH
argument_list|(
argument|tmp
argument_list|,
argument|&sc->head
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|tmp
operator|->
name|ngddev
operator|==
name|dev
condition|)
block|{
name|connection
operator|=
name|tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|connection
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s(): ERROR: connection is still NULL,"
literal|"no dev found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|connection
operator|->
name|loc
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

end_unit

