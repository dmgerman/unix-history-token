begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_parse.c  *  * Copyright (c) 1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@freebsd.org>  *  * $Whistle: ng_parse.c,v 1.3 1999/11/29 01:43:48 archie Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PARSE
argument_list|,
literal|"netgraph_parse"
argument_list|,
literal|"netgraph parse info"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PARSE
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compute alignment for primitive integral types */
end_comment

begin_struct
struct|struct
name|int16_temp
block|{
name|char
name|x
decl_stmt|;
name|int16_t
name|y
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|int32_temp
block|{
name|char
name|x
decl_stmt|;
name|int32_t
name|y
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|int64_temp
block|{
name|char
name|x
decl_stmt|;
name|int64_t
name|y
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|INT8_ALIGNMENT
value|1
end_define

begin_define
define|#
directive|define
name|INT16_ALIGNMENT
value|((int)&((struct int16_temp *)0)->y)
end_define

begin_define
define|#
directive|define
name|INT32_ALIGNMENT
value|((int)&((struct int32_temp *)0)->y)
end_define

begin_define
define|#
directive|define
name|INT64_ALIGNMENT
value|((int)&((struct int64_temp *)0)->y)
end_define

begin_comment
comment|/* Output format for integral types */
end_comment

begin_define
define|#
directive|define
name|INT_UNSIGNED
value|0
end_define

begin_define
define|#
directive|define
name|INT_SIGNED
value|1
end_define

begin_define
define|#
directive|define
name|INT_HEX
value|2
end_define

begin_comment
comment|/* Type of composite object: struct, array, or fixedarray */
end_comment

begin_enum
enum|enum
name|comptype
block|{
name|CT_STRUCT
block|,
name|CT_ARRAY
block|,
name|CT_FIXEDARRAY
block|, }
enum|;
end_enum

begin_comment
comment|/* Composite types helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_parse_composite
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_unparse_composite
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_get_composite_elem_default
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_get_composite_len
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|ng_get_composite_etype
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_parse_get_elem_pad
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|,
name|int
name|posn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parsing helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_parse_skip_value
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|off
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Poor man's virtual method calls */
end_comment

begin_define
define|#
directive|define
name|METHOD
parameter_list|(
name|t
parameter_list|,
name|m
parameter_list|)
value|(ng_get_ ## m ## _method(t))
end_define

begin_define
define|#
directive|define
name|INVOKE
parameter_list|(
name|t
parameter_list|,
name|m
parameter_list|)
value|(*METHOD(t,m))
end_define

begin_function_decl
specifier|static
name|ng_parse_t
modifier|*
name|ng_get_parse_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_unparse_t
modifier|*
name|ng_get_unparse_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_getDefault_t
modifier|*
name|ng_get_getDefault_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ng_getAlign_t
modifier|*
name|ng_get_getAlign_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ALIGNMENT
parameter_list|(
name|t
parameter_list|)
value|(METHOD(t, getAlign) == NULL ? \ 				0 : INVOKE(t, getAlign)(t))
end_define

begin_comment
comment|/* For converting binary to string */
end_comment

begin_define
define|#
directive|define
name|NG_PARSE_APPEND
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do {						\ 			int len;				\ 								\ 			len = snprintf((cbuf), (cbuflen),	\ 				fmt , ## args);			\ 			if (len>= (cbuflen))			\ 				return (ERANGE);		\ 			(cbuf) += len;				\ 			(cbuflen) -= len;			\ 		} while (0)
end_define

begin_comment
comment|/************************************************************************ 			PUBLIC FUNCTIONS  ************************************************************************/
end_comment

begin_comment
comment|/*  * Convert an ASCII string to binary according to the supplied type descriptor  */
end_comment

begin_function
name|int
name|ng_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
return|return
name|INVOKE
argument_list|(
name|type
argument_list|,
name|parse
argument_list|)
argument_list|(
name|type
argument_list|,
name|string
argument_list|,
name|off
argument_list|,
name|buf
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert binary to an ASCII string according to the supplied type descriptor  */
end_comment

begin_function
name|int
name|ng_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
return|return
name|INVOKE
argument_list|(
name|type
argument_list|,
name|unparse
argument_list|)
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
operator|&
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the default value according to the supplied type descriptor  */
end_comment

begin_function
name|int
name|ng_parse_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|ng_getDefault_t
modifier|*
specifier|const
name|func
init|=
name|METHOD
argument_list|(
name|type
argument_list|,
name|getDefault
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			STRUCTURE TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_struct_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_STRUCT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_struct_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
return|return
name|ng_unparse_composite
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|,
name|CT_STRUCT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_struct_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
literal|"{}"
argument_list|,
operator|&
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_STRUCT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_struct_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
specifier|const
name|struct
name|ng_parse_struct_field
modifier|*
name|field
decl_stmt|;
name|int
name|align
init|=
literal|0
decl_stmt|;
for|for
control|(
name|field
operator|=
name|si
operator|->
name|fields
init|;
name|field
operator|->
name|name
operator|!=
name|NULL
condition|;
name|field
operator|++
control|)
block|{
name|int
name|falign
init|=
name|ALIGNMENT
argument_list|(
name|field
operator|->
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|falign
operator|>
name|align
condition|)
name|align
operator|=
name|falign
expr_stmt|;
block|}
return|return
name|align
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_struct_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_struct_parse
block|,
name|ng_struct_unparse
block|,
name|ng_struct_getDefault
block|,
name|ng_struct_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			FIXED LENGTH ARRAY TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_fixedarray_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_FIXEDARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_fixedarray_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
return|return
name|ng_unparse_composite
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|,
name|CT_FIXEDARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_fixedarray_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
literal|"[]"
argument_list|,
operator|&
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_FIXEDARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_fixedarray_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_fixedarray_info
modifier|*
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
return|return
name|ALIGNMENT
argument_list|(
name|fi
operator|->
name|elementType
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_fixedarray_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_fixedarray_parse
block|,
name|ng_fixedarray_unparse
block|,
name|ng_fixedarray_getDefault
block|,
name|ng_fixedarray_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			VARIABLE LENGTH ARRAY TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_array_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_ARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_array_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
return|return
name|ng_unparse_composite
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|,
name|CT_ARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_array_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
return|return
name|ng_parse_composite
argument_list|(
name|type
argument_list|,
literal|"[]"
argument_list|,
operator|&
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|CT_ARRAY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_array_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_array_info
modifier|*
name|ai
init|=
name|type
operator|->
name|info
decl_stmt|;
return|return
name|ALIGNMENT
argument_list|(
name|ai
operator|->
name|elementType
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_array_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_array_parse
block|,
name|ng_array_unparse
block|,
name|ng_array_getDefault
block|,
name|ng_array_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 				INT8 TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_int8_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|int8_t
name|val8
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|val
operator|=
name|strtol
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|(
name|int8_t
operator|)
literal|0x80
operator|||
name|val
operator|>
operator|(
name|u_int8_t
operator|)
literal|0xff
operator|||
name|eptr
operator|==
name|s
operator|+
operator|*
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|=
name|eptr
operator|-
name|s
expr_stmt|;
name|val8
operator|=
operator|(
name|int8_t
operator|)
name|val
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val8
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int8_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|fval
decl_stmt|;
name|int8_t
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
operator|*
name|off
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
operator|->
name|info
condition|)
block|{
case|case
name|INT_SIGNED
case|:
name|fmt
operator|=
literal|"%d"
expr_stmt|;
name|fval
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INT_UNSIGNED
case|:
name|fmt
operator|=
literal|"%u"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int8_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|INT_HEX
case|:
name|fmt
operator|=
literal|"0x%x"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int8_t
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RESTARTABLE_PANICS
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|NG_PARSE_APPEND
argument_list|(
name|fmt
argument_list|,
name|fval
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int8_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int8_t
name|val
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int8_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int8_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|INT8_ALIGNMENT
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_int8_type
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|INT_SIGNED
block|,
name|NULL
block|,
name|ng_int8_parse
block|,
name|ng_int8_unparse
block|,
name|ng_int8_getDefault
block|,
name|ng_int8_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_uint8_type
init|=
block|{
operator|&
name|ng_parse_int8_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_UNSIGNED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_hint8_type
init|=
block|{
operator|&
name|ng_parse_int8_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_HEX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 				INT16 TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_int16_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|int16_t
name|val16
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|val
operator|=
name|strtol
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|(
name|int16_t
operator|)
literal|0x8000
operator|||
name|val
operator|>
operator|(
name|u_int16_t
operator|)
literal|0xffff
operator|||
name|eptr
operator|==
name|s
operator|+
operator|*
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|=
name|eptr
operator|-
name|s
expr_stmt|;
name|val16
operator|=
operator|(
name|int16_t
operator|)
name|val
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val16
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int16_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|fval
decl_stmt|;
name|int16_t
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
operator|*
name|off
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
operator|->
name|info
condition|)
block|{
case|case
name|INT_SIGNED
case|:
name|fmt
operator|=
literal|"%d"
expr_stmt|;
name|fval
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INT_UNSIGNED
case|:
name|fmt
operator|=
literal|"%u"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int16_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|INT_HEX
case|:
name|fmt
operator|=
literal|"0x%x"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int16_t
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RESTARTABLE_PANICS
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|NG_PARSE_APPEND
argument_list|(
name|fmt
argument_list|,
name|fval
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int16_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int16_t
name|val
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int16_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int16_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|INT16_ALIGNMENT
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_int16_type
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|INT_SIGNED
block|,
name|NULL
block|,
name|ng_int16_parse
block|,
name|ng_int16_unparse
block|,
name|ng_int16_getDefault
block|,
name|ng_int16_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_uint16_type
init|=
block|{
operator|&
name|ng_parse_int16_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_UNSIGNED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_hint16_type
init|=
block|{
operator|&
name|ng_parse_int16_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_HEX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 				INT32 TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_int32_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
comment|/* assumes long is at least 32 bits */
name|int32_t
name|val32
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|val
operator|=
name|strtol
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
operator|(
name|int32_t
operator|)
literal|0x80000000
operator|||
name|val
operator|>
operator|(
name|u_int32_t
operator|)
literal|0xffffffff
operator|||
name|eptr
operator|==
name|s
operator|+
operator|*
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|=
name|eptr
operator|-
name|s
expr_stmt|;
name|val32
operator|=
operator|(
name|int32_t
operator|)
name|val
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val32
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int32_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|long
name|fval
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
operator|*
name|off
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
operator|->
name|info
condition|)
block|{
case|case
name|INT_SIGNED
case|:
name|fmt
operator|=
literal|"%ld"
expr_stmt|;
name|fval
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INT_UNSIGNED
case|:
name|fmt
operator|=
literal|"%lu"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int32_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|INT_HEX
case|:
name|fmt
operator|=
literal|"0x%lx"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int32_t
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RESTARTABLE_PANICS
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|NG_PARSE_APPEND
argument_list|(
name|fmt
argument_list|,
name|fval
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int32_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int32_t
name|val
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int32_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|INT32_ALIGNMENT
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_int32_type
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|INT_SIGNED
block|,
name|NULL
block|,
name|ng_int32_parse
block|,
name|ng_int32_unparse
block|,
name|ng_int32_getDefault
block|,
name|ng_int32_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_uint32_type
init|=
block|{
operator|&
name|ng_parse_int32_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_UNSIGNED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_hint32_type
init|=
block|{
operator|&
name|ng_parse_int32_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_HEX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 				INT64 TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_int64_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|quad_t
name|val
decl_stmt|;
name|int64_t
name|val64
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|val
operator|=
name|strtoq
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|eptr
operator|==
name|s
operator|+
operator|*
name|off
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|=
name|eptr
operator|-
name|s
expr_stmt|;
name|val64
operator|=
operator|(
name|int64_t
operator|)
name|val
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val64
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int64_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|long
name|long
name|fval
decl_stmt|;
name|int64_t
name|val
decl_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
operator|*
name|off
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
operator|->
name|info
condition|)
block|{
case|case
name|INT_SIGNED
case|:
name|fmt
operator|=
literal|"%lld"
expr_stmt|;
name|fval
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|INT_UNSIGNED
case|:
name|fmt
operator|=
literal|"%llu"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int64_t
operator|)
name|val
expr_stmt|;
break|break;
case|case
name|INT_HEX
case|:
name|fmt
operator|=
literal|"0x%llx"
expr_stmt|;
name|fval
operator|=
operator|(
name|u_int64_t
operator|)
name|val
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: unknown type"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RESTARTABLE_PANICS
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
name|NG_PARSE_APPEND
argument_list|(
name|fmt
argument_list|,
name|fval
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int64_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int64_t
name|val
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|val
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_int64_getAlign
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|INT64_ALIGNMENT
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_int64_type
init|=
block|{
name|NULL
block|,
operator|(
name|void
operator|*
operator|)
name|INT_SIGNED
block|,
name|NULL
block|,
name|ng_int64_parse
block|,
name|ng_int64_unparse
block|,
name|ng_int64_getDefault
block|,
name|ng_int64_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_uint64_type
init|=
block|{
operator|&
name|ng_parse_int64_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_UNSIGNED
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_hint64_type
init|=
block|{
operator|&
name|ng_parse_int64_type
block|,
operator|(
name|void
operator|*
operator|)
name|INT_HEX
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 				STRING TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_string_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|sval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|slen
decl_stmt|;
if|if
condition|(
operator|(
name|sval
operator|=
name|ng_get_string_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|+=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sval
argument_list|,
name|buf
argument_list|,
name|slen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sval
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
name|slen
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_string_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|raw
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
operator|*
name|off
decl_stmt|;
name|char
modifier|*
specifier|const
name|s
init|=
name|ng_encode_string
argument_list|(
name|raw
argument_list|,
name|strlen
argument_list|(
name|raw
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_PARSE_APPEND
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|strlen
argument_list|(
name|raw
argument_list|)
operator|+
literal|1
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_string_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buflen
operator|<
literal|1
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|u_char
operator|)
literal|'\0'
expr_stmt|;
operator|*
name|buflen
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_string_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_string_parse
block|,
name|ng_string_unparse
block|,
name|ng_string_getDefault
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			FIXED BUFFER STRING TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_fixedstring_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_fixedstring_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
name|char
modifier|*
name|sval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|slen
decl_stmt|;
if|if
condition|(
operator|(
name|sval
operator|=
name|ng_get_string_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|slen
operator|+
literal|1
operator|>
name|fi
operator|->
name|bufSize
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
operator|*
name|off
operator|+=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|sval
argument_list|,
name|buf
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sval
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
operator|+
name|slen
argument_list|,
name|fi
operator|->
name|bufSize
operator|-
name|slen
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
name|fi
operator|->
name|bufSize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_fixedstring_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_fixedstring_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
name|int
name|error
decl_stmt|,
name|temp
init|=
operator|*
name|off
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_string_unparse
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
operator|&
name|temp
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|off
operator|+=
name|fi
operator|->
name|bufSize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_fixedstring_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_fixedstring_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
name|fi
operator|->
name|bufSize
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|bzero
argument_list|(
name|buf
argument_list|,
name|fi
operator|->
name|bufSize
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
name|fi
operator|->
name|bufSize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_fixedstring_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_fixedstring_parse
block|,
name|ng_fixedstring_unparse
block|,
name|ng_fixedstring_getDefault
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_fixedstring_info
name|ng_parse_nodebuf_info
init|=
block|{
name|NG_NODELEN
operator|+
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_nodebuf_type
init|=
block|{
operator|&
name|ng_parse_fixedstring_type
block|,
operator|&
name|ng_parse_nodebuf_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_fixedstring_info
name|ng_parse_hookbuf_info
init|=
block|{
name|NG_HOOKLEN
operator|+
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_hookbuf_type
init|=
block|{
operator|&
name|ng_parse_fixedstring_type
block|,
operator|&
name|ng_parse_hookbuf_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_fixedstring_info
name|ng_parse_pathbuf_info
init|=
block|{
name|NG_PATHLEN
operator|+
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_pathbuf_type
init|=
block|{
operator|&
name|ng_parse_fixedstring_type
block|,
operator|&
name|ng_parse_pathbuf_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_fixedstring_info
name|ng_parse_typebuf_info
init|=
block|{
name|NG_TYPELEN
operator|+
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_typebuf_type
init|=
block|{
operator|&
name|ng_parse_fixedstring_type
block|,
operator|&
name|ng_parse_typebuf_info
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_fixedstring_info
name|ng_parse_cmdbuf_info
init|=
block|{
name|NG_CMDSTRLEN
operator|+
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_cmdbuf_type
init|=
block|{
operator|&
name|ng_parse_fixedstring_type
block|,
operator|&
name|ng_parse_cmdbuf_info
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			EXPLICITLY SIZED STRING TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_sizedstring_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|sval
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|slen
decl_stmt|;
if|if
condition|(
operator|(
name|sval
operator|=
name|ng_get_string_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|slen
operator|>
literal|0xffff
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|off
operator|+=
name|len
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|buf
operator|)
operator|=
operator|(
name|u_int16_t
operator|)
name|slen
expr_stmt|;
name|bcopy
argument_list|(
name|sval
argument_list|,
name|buf
operator|+
literal|2
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|sval
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
literal|2
operator|+
name|slen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_sizedstring_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|raw
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
operator|*
name|off
operator|+
literal|2
decl_stmt|;
specifier|const
name|int
name|slen
init|=
operator|*
operator|(
operator|(
specifier|const
name|u_int16_t
operator|*
operator|)
operator|(
name|data
operator|+
operator|*
name|off
operator|)
operator|)
decl_stmt|;
name|char
modifier|*
specifier|const
name|s
init|=
name|ng_encode_string
argument_list|(
name|raw
argument_list|,
name|slen
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_PARSE_APPEND
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|s
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|slen
operator|+
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_sizedstring_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buflen
operator|<
literal|2
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|bzero
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_sizedstring_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_sizedstring_parse
block|,
name|ng_sizedstring_unparse
block|,
name|ng_sizedstring_getDefault
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			IP ADDRESS TYPE  ************************************************************************/
end_comment

begin_function
specifier|static
name|int
name|ng_ipaddr_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|ng_int8_parse
argument_list|(
operator|&
name|ng_parse_int8_type
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|buflen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|i
operator|<
literal|3
operator|&&
name|s
index|[
operator|*
name|off
index|]
operator|!=
literal|'.'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
operator|*
name|off
operator|)
operator|++
expr_stmt|;
block|}
operator|*
name|buflen
operator|=
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ipaddr_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
name|struct
name|in_addr
name|ip
decl_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
operator|*
name|off
argument_list|,
operator|&
name|ip
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|NG_PARSE_APPEND
argument_list|(
literal|"%d.%d.%d.%d"
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ip
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ip
operator|)
index|[
literal|1
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ip
operator|)
index|[
literal|2
index|]
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ip
operator|)
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ipaddr_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|struct
name|in_addr
name|ip
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|*
name|buflen
operator|<
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|ip
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_ipaddr_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_ipaddr_parse
block|,
name|ng_ipaddr_unparse
block|,
name|ng_ipaddr_getDefault
block|,
name|ng_int32_getAlign
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			BYTE ARRAY TYPE  ************************************************************************/
end_comment

begin_comment
comment|/* Get the length of a byte array */
end_comment

begin_function
specifier|static
name|int
name|ng_parse_bytearray_subtype_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|ng_parse_array_getLength_t
modifier|*
specifier|const
name|getLength
init|=
name|type
operator|->
name|private
decl_stmt|;
return|return
call|(
modifier|*
name|getLength
call|)
argument_list|(
name|type
argument_list|,
name|start
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Byte array element type is hex int8 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_array_info
name|ng_parse_bytearray_subtype_info
init|=
block|{
operator|&
name|ng_parse_hint8_type
block|,
operator|&
name|ng_parse_bytearray_subtype_getLength
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_bytearray_subtype
init|=
block|{
operator|&
name|ng_parse_array_type
block|,
operator|&
name|ng_parse_bytearray_subtype_info
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ng_bytearray_parse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|toklen
decl_stmt|;
name|int
name|slen
decl_stmt|;
comment|/* We accept either an array of bytes or a string constant */
if|if
condition|(
operator|(
name|str
operator|=
name|ng_get_string_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|toklen
argument_list|,
operator|&
name|slen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ng_parse_array_getLength_t
modifier|*
specifier|const
name|getLength
init|=
name|type
operator|->
name|info
decl_stmt|;
name|int
name|arraylen
decl_stmt|;
name|arraylen
operator|=
call|(
modifier|*
name|getLength
call|)
argument_list|(
name|type
argument_list|,
name|start
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|arraylen
operator|>
operator|*
name|buflen
condition|)
block|{
name|FREE
argument_list|(
name|str
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
if|if
condition|(
name|slen
operator|>
name|arraylen
condition|)
block|{
name|FREE
argument_list|(
name|str
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
name|slen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
operator|+
name|slen
argument_list|,
name|arraylen
operator|-
name|slen
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|str
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|toklen
expr_stmt|;
operator|*
name|buflen
operator|=
name|arraylen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|struct
name|ng_parse_type
name|subtype
decl_stmt|;
name|subtype
operator|=
name|ng_parse_bytearray_subtype
expr_stmt|;
operator|(
specifier|const
name|void
operator|*
operator|)
name|subtype
operator|.
name|private
operator|=
name|type
operator|->
name|info
expr_stmt|;
return|return
name|ng_array_parse
argument_list|(
operator|&
name|subtype
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ng_bytearray_unparse
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|)
block|{
name|struct
name|ng_parse_type
name|subtype
decl_stmt|;
name|subtype
operator|=
name|ng_parse_bytearray_subtype
expr_stmt|;
operator|(
specifier|const
name|void
operator|*
operator|)
name|subtype
operator|.
name|private
operator|=
name|type
operator|->
name|info
expr_stmt|;
return|return
name|ng_array_unparse
argument_list|(
operator|&
name|subtype
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_bytearray_getDefault
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|)
block|{
name|struct
name|ng_parse_type
name|subtype
decl_stmt|;
name|subtype
operator|=
name|ng_parse_bytearray_subtype
expr_stmt|;
operator|(
specifier|const
name|void
operator|*
operator|)
name|subtype
operator|.
name|private
operator|=
name|type
operator|->
name|info
expr_stmt|;
return|return
name|ng_array_getDefault
argument_list|(
operator|&
name|subtype
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_bytearray_type
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_bytearray_parse
block|,
name|ng_bytearray_unparse
block|,
name|ng_bytearray_getDefault
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			STRUCT NG_MESG TYPE  ************************************************************************/
end_comment

begin_comment
comment|/* Get msg->header.arglen when "buf" is pointing to msg->data */
end_comment

begin_function
specifier|static
name|int
name|ng_parse_ng_mesg_getLength
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
specifier|const
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|msg
operator|=
operator|(
specifier|const
expr|struct
name|ng_mesg
operator|*
operator|)
operator|(
name|buf
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
operator|)
expr_stmt|;
return|return
name|msg
operator|->
name|header
operator|.
name|arglen
return|;
block|}
end_function

begin_comment
comment|/* Type for the variable length data portion of a struct ng_mesg */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_msg_data_type
init|=
block|{
operator|&
name|ng_parse_bytearray_type
block|,
operator|&
name|ng_parse_ng_mesg_getLength
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Type for the entire struct ng_mesg header with data section */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_info
name|ng_parse_ng_mesg_type_info
init|=
name|NG_GENERIC_NG_MESG_INFO
argument_list|(
operator|&
name|ng_msg_data_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|ng_parse_type
name|ng_parse_ng_mesg_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_parse_ng_mesg_type_info
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/************************************************************************ 			COMPOSITE HELPER ROUTINES  ************************************************************************/
end_comment

begin_comment
comment|/*  * Convert a structure or array from ASCII to binary  */
end_comment

begin_function
specifier|static
name|int
name|ng_parse_composite
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
specifier|const
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|,
specifier|const
name|enum
name|comptype
name|ctype
parameter_list|)
block|{
specifier|const
name|int
name|num
init|=
name|ng_get_composite_len
argument_list|(
name|type
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|ctype
argument_list|)
decl_stmt|;
name|int
name|nextIndex
init|=
literal|0
decl_stmt|;
comment|/* next implicit array index */
name|u_int
name|index
decl_stmt|;
comment|/* field or element index */
name|int
modifier|*
name|foff
decl_stmt|;
comment|/* field value offsets in string */
name|int
name|align
decl_stmt|,
name|len
decl_stmt|,
name|blen
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
comment|/* Initialize */
name|MALLOC
argument_list|(
name|foff
argument_list|,
name|int
operator|*
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|foff
argument_list|)
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|foff
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Get opening brace/bracket */
if|if
condition|(
name|ng_parse_get_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
operator|(
name|ctype
operator|==
name|CT_STRUCT
condition|?
name|T_LBRACE
else|:
name|T_LBRACKET
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|off
operator|+=
name|len
expr_stmt|;
comment|/* Get individual element value positions in the string */
for|for
control|(
init|;
condition|;
control|)
block|{
name|enum
name|ng_parse_token
name|tok
decl_stmt|;
comment|/* Check for closing brace/bracket */
name|tok
operator|=
name|ng_parse_get_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
operator|(
name|ctype
operator|==
name|CT_STRUCT
condition|?
name|T_RBRACE
else|:
name|T_RBRACKET
operator|)
condition|)
block|{
operator|*
name|off
operator|+=
name|len
expr_stmt|;
break|break;
block|}
comment|/* For arrays, the 'name' (ie, index) is optional, so 		   distinguish name from values by seeing if the next 		   token is an equals sign */
if|if
condition|(
name|ctype
operator|!=
name|CT_STRUCT
condition|)
block|{
name|int
name|len2
decl_stmt|,
name|off2
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
comment|/* If an opening brace/bracket, index is implied */
if|if
condition|(
name|tok
operator|==
name|T_LBRACE
operator|||
name|tok
operator|==
name|T_LBRACKET
condition|)
block|{
name|index
operator|=
name|nextIndex
operator|++
expr_stmt|;
goto|goto
name|gotIndex
goto|;
block|}
comment|/* Might be an index, might be a value, either way... */
if|if
condition|(
name|tok
operator|!=
name|T_WORD
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If no equals sign follows, index is implied */
name|off2
operator|=
operator|*
name|off
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|ng_parse_get_token
argument_list|(
name|s
argument_list|,
operator|&
name|off2
argument_list|,
operator|&
name|len2
argument_list|)
operator|!=
name|T_EQUALS
condition|)
block|{
name|index
operator|=
name|nextIndex
operator|++
expr_stmt|;
goto|goto
name|gotIndex
goto|;
block|}
comment|/* Index was specified explicitly; parse it */
name|index
operator|=
operator|(
name|u_int
operator|)
name|strtoul
argument_list|(
name|s
operator|+
operator|*
name|off
argument_list|,
operator|&
name|eptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|eptr
operator|-
operator|(
name|s
operator|+
operator|*
name|off
operator|)
operator|!=
name|len
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|nextIndex
operator|=
name|index
operator|+
literal|1
expr_stmt|;
operator|*
name|off
operator|+=
name|len
operator|+
name|len2
expr_stmt|;
name|gotIndex
label|:
block|}
else|else
block|{
comment|/* a structure field */
specifier|const
name|struct
name|ng_parse_struct_field
modifier|*
name|field
init|=
name|NULL
decl_stmt|;
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
comment|/* Find the field by name (required) in field list */
if|if
condition|(
name|tok
operator|!=
name|T_WORD
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num
condition|;
name|index
operator|++
control|)
block|{
name|field
operator|=
operator|&
name|si
operator|->
name|fields
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|&
name|s
index|[
operator|*
name|off
index|]
argument_list|,
name|field
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|field
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
if|if
condition|(
name|index
operator|==
name|num
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|off
operator|+=
name|len
expr_stmt|;
comment|/* Get equals sign */
if|if
condition|(
name|ng_parse_get_token
argument_list|(
name|s
argument_list|,
name|off
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
name|T_EQUALS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|*
name|off
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Check array index */
if|if
condition|(
name|index
operator|>=
name|num
condition|)
block|{
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Save value's position and skip over it for now */
if|if
condition|(
name|foff
index|[
name|index
index|]
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EALREADY
expr_stmt|;
comment|/* duplicate */
goto|goto
name|done
goto|;
block|}
while|while
condition|(
name|isspace
argument_list|(
name|s
index|[
operator|*
name|off
index|]
argument_list|)
condition|)
operator|(
operator|*
name|off
operator|)
operator|++
expr_stmt|;
name|foff
index|[
name|index
index|]
operator|=
operator|*
name|off
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_parse_skip_value
argument_list|(
name|s
argument_list|,
operator|*
name|off
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
operator|*
name|off
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Now build binary structure from supplied values and defaults */
for|for
control|(
name|blen
operator|=
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num
condition|;
name|index
operator|++
control|)
block|{
specifier|const
name|struct
name|ng_parse_type
modifier|*
specifier|const
name|etype
init|=
name|ng_get_composite_etype
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|,
name|pad
decl_stmt|,
name|vlen
decl_stmt|;
comment|/* Zero-pad any alignment bytes */
name|pad
operator|=
name|ng_parse_get_elem_pad
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|,
name|blen
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|pad
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|blen
operator|>=
operator|*
name|buflen
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|buf
index|[
name|blen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get value */
name|vlen
operator|=
operator|*
name|buflen
operator|-
name|blen
expr_stmt|;
if|if
condition|(
name|foff
index|[
name|index
index|]
operator|==
literal|0
condition|)
block|{
comment|/* use default value */
name|error
operator|=
name|ng_get_composite_elem_default
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|start
argument_list|,
name|buf
operator|+
name|blen
argument_list|,
operator|&
name|vlen
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* parse given value */
operator|*
name|off
operator|=
name|foff
index|[
name|index
index|]
expr_stmt|;
name|error
operator|=
name|INVOKE
argument_list|(
name|etype
argument_list|,
name|parse
argument_list|)
argument_list|(
name|etype
argument_list|,
name|s
argument_list|,
name|off
argument_list|,
name|start
argument_list|,
name|buf
operator|+
name|blen
argument_list|,
operator|&
name|vlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|blen
operator|+=
name|vlen
expr_stmt|;
block|}
comment|/* Make total composite structure size a multiple of its alignment */
if|if
condition|(
operator|(
name|align
operator|=
name|ALIGNMENT
argument_list|(
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|blen
operator|%
name|align
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|blen
operator|>=
operator|*
name|buflen
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|buf
index|[
name|blen
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Done */
operator|*
name|buflen
operator|=
name|blen
expr_stmt|;
name|done
label|:
if|if
condition|(
name|foff
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|foff
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an array or structure from binary to ASCII  */
end_comment

begin_function
specifier|static
name|int
name|ng_unparse_composite
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|int
modifier|*
name|off
parameter_list|,
name|char
modifier|*
name|cbuf
parameter_list|,
name|int
name|cbuflen
parameter_list|,
specifier|const
name|enum
name|comptype
name|ctype
parameter_list|)
block|{
specifier|const
name|struct
name|ng_mesg
modifier|*
specifier|const
name|hdr
init|=
operator|(
specifier|const
expr|struct
name|ng_mesg
operator|*
operator|)
operator|(
name|data
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|)
decl_stmt|;
specifier|const
name|int
name|num
init|=
name|ng_get_composite_len
argument_list|(
name|type
argument_list|,
name|data
argument_list|,
name|data
operator|+
operator|*
name|off
argument_list|,
name|ctype
argument_list|)
decl_stmt|;
specifier|const
name|int
name|workSize
init|=
literal|20
operator|*
literal|1024
decl_stmt|;
comment|/* XXX hard coded constant */
name|int
name|nextIndex
init|=
literal|0
decl_stmt|,
name|didOne
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|u_char
modifier|*
name|workBuf
decl_stmt|;
comment|/* Get workspace for checking default values */
name|MALLOC
argument_list|(
name|workBuf
argument_list|,
name|u_char
operator|*
argument_list|,
name|workSize
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|workBuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Opening brace/bracket */
name|NG_PARSE_APPEND
argument_list|(
literal|"%c"
argument_list|,
operator|(
name|ctype
operator|==
name|CT_STRUCT
operator|)
condition|?
literal|'{'
else|:
literal|'['
argument_list|)
expr_stmt|;
comment|/* Do each item */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num
condition|;
name|index
operator|++
control|)
block|{
specifier|const
name|struct
name|ng_parse_type
modifier|*
specifier|const
name|etype
init|=
name|ng_get_composite_etype
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|)
decl_stmt|;
comment|/* Skip any alignment pad bytes */
operator|*
name|off
operator|+=
name|ng_parse_get_elem_pad
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|,
operator|*
name|off
argument_list|)
expr_stmt|;
comment|/* 		 * See if element is equal to its default value; skip if so. 		 * Copy struct ng_mesg header for types that peek into it. 		 */
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
operator|*
name|off
operator|<
name|workSize
condition|)
block|{
name|int
name|tempsize
init|=
name|workSize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|-
operator|*
name|off
decl_stmt|;
name|bcopy
argument_list|(
name|hdr
argument_list|,
name|workBuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
operator|*
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_get_composite_elem_default
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|workBuf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|workBuf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
operator|*
name|off
argument_list|,
operator|&
name|tempsize
argument_list|,
name|ctype
argument_list|)
operator|==
literal|0
operator|&&
name|bcmp
argument_list|(
name|workBuf
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
operator|+
operator|*
name|off
argument_list|,
name|data
operator|+
operator|*
name|off
argument_list|,
name|tempsize
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|off
operator|+=
name|tempsize
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* Print name= */
name|NG_PARSE_APPEND
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|!=
name|CT_STRUCT
condition|)
block|{
if|if
condition|(
name|index
operator|!=
name|nextIndex
condition|)
block|{
name|nextIndex
operator|=
name|index
expr_stmt|;
name|NG_PARSE_APPEND
argument_list|(
literal|"%d="
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
name|nextIndex
operator|++
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
name|NG_PARSE_APPEND
argument_list|(
literal|"%s="
argument_list|,
name|si
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* Print value */
if|if
condition|(
operator|(
name|error
operator|=
name|INVOKE
argument_list|(
name|etype
argument_list|,
name|unparse
argument_list|)
argument_list|(
name|etype
argument_list|,
name|data
argument_list|,
name|off
argument_list|,
name|cbuf
argument_list|,
name|cbuflen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|FREE
argument_list|(
name|workBuf
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cbuflen
operator|-=
name|strlen
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|cbuf
operator|+=
name|strlen
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|didOne
operator|=
literal|1
expr_stmt|;
block|}
name|FREE
argument_list|(
name|workBuf
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
comment|/* Closing brace/bracket */
name|NG_PARSE_APPEND
argument_list|(
literal|"%s%c"
argument_list|,
name|didOne
condition|?
literal|" "
else|:
literal|""
argument_list|,
operator|(
name|ctype
operator|==
name|CT_STRUCT
operator|)
condition|?
literal|'}'
else|:
literal|']'
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate the default value for an element of an array or structure  * Returns EOPNOTSUPP if default value is unspecified.  */
end_comment

begin_function
specifier|static
name|int
name|ng_get_composite_elem_default
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|buflen
parameter_list|,
specifier|const
name|enum
name|comptype
name|ctype
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|etype
decl_stmt|;
name|ng_getDefault_t
modifier|*
name|func
decl_stmt|;
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|CT_STRUCT
case|:
break|break;
case|case
name|CT_ARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_array_info
modifier|*
specifier|const
name|ai
init|=
name|type
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|ai
operator|->
name|getDefault
operator|!=
name|NULL
condition|)
block|{
return|return
call|(
modifier|*
name|ai
operator|->
name|getDefault
call|)
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
break|break;
block|}
case|case
name|CT_FIXEDARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_fixedarray_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
if|if
condition|(
operator|*
name|fi
operator|->
name|getDefault
operator|!=
name|NULL
condition|)
block|{
return|return
call|(
modifier|*
name|fi
operator|->
name|getDefault
call|)
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
comment|/* Default to element type default */
name|etype
operator|=
name|ng_get_composite_etype
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|func
operator|=
name|METHOD
argument_list|(
name|etype
argument_list|,
name|getDefault
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|etype
argument_list|,
name|start
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the number of elements in a struct, variable or fixed array.  */
end_comment

begin_function
specifier|static
name|int
name|ng_get_composite_len
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
specifier|const
name|u_char
modifier|*
specifier|const
name|start
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
specifier|const
name|enum
name|comptype
name|ctype
parameter_list|)
block|{
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|CT_STRUCT
case|:
block|{
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
specifier|const
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
name|int
name|numFields
init|=
literal|0
decl_stmt|;
for|for
control|(
name|numFields
operator|=
literal|0
init|;
condition|;
name|numFields
operator|++
control|)
block|{
specifier|const
name|struct
name|ng_parse_struct_field
modifier|*
specifier|const
name|fi
init|=
operator|&
name|si
operator|->
name|fields
index|[
name|numFields
index|]
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|name
operator|==
name|NULL
condition|)
break|break;
block|}
return|return
operator|(
name|numFields
operator|)
return|;
block|}
case|case
name|CT_ARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_array_info
modifier|*
specifier|const
name|ai
init|=
name|type
operator|->
name|info
decl_stmt|;
return|return
call|(
modifier|*
name|ai
operator|->
name|getLength
call|)
argument_list|(
name|type
argument_list|,
name|start
argument_list|,
name|buf
argument_list|)
return|;
block|}
case|case
name|CT_FIXEDARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_fixedarray_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
return|return
name|fi
operator|->
name|length
return|;
block|}
default|default:
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the type of the index'th element of a composite structure  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|ng_get_composite_etype
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
specifier|const
name|enum
name|comptype
name|ctype
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|etype
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|ctype
condition|)
block|{
case|case
name|CT_STRUCT
case|:
block|{
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
specifier|const
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
name|etype
operator|=
name|si
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|type
expr_stmt|;
break|break;
block|}
case|case
name|CT_ARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_array_info
modifier|*
specifier|const
name|ai
init|=
name|type
operator|->
name|info
decl_stmt|;
name|etype
operator|=
name|ai
operator|->
name|elementType
expr_stmt|;
break|break;
block|}
case|case
name|CT_FIXEDARRAY
case|:
block|{
specifier|const
name|struct
name|ng_parse_fixedarray_info
modifier|*
specifier|const
name|fi
init|=
name|type
operator|->
name|info
decl_stmt|;
name|etype
operator|=
name|fi
operator|->
name|elementType
expr_stmt|;
break|break;
block|}
default|default:
name|panic
argument_list|(
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|etype
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the number of bytes to skip to align for the next  * element in a composite structure.  */
end_comment

begin_function
specifier|static
name|int
name|ng_parse_get_elem_pad
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|comptype
name|ctype
parameter_list|,
name|int
name|posn
parameter_list|)
block|{
specifier|const
name|struct
name|ng_parse_type
modifier|*
specifier|const
name|etype
init|=
name|ng_get_composite_etype
argument_list|(
name|type
argument_list|,
name|index
argument_list|,
name|ctype
argument_list|)
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Get element's alignment, and possibly override */
name|align
operator|=
name|ALIGNMENT
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctype
operator|==
name|CT_STRUCT
condition|)
block|{
specifier|const
name|struct
name|ng_parse_struct_info
modifier|*
name|si
init|=
name|type
operator|->
name|info
decl_stmt|;
if|if
condition|(
name|si
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|alignment
operator|!=
literal|0
condition|)
name|align
operator|=
name|si
operator|->
name|fields
index|[
name|index
index|]
operator|.
name|alignment
expr_stmt|;
block|}
comment|/* Return number of bytes to skip to align */
return|return
operator|(
name|align
condition|?
operator|(
name|align
operator|-
operator|(
name|posn
operator|%
name|align
operator|)
operator|)
operator|%
name|align
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			PARSING HELPER ROUTINES  ************************************************************************/
end_comment

begin_comment
comment|/*  * Skip over a value  */
end_comment

begin_function
specifier|static
name|int
name|ng_parse_skip_value
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|off0
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|nbracket
decl_stmt|,
name|nbrace
decl_stmt|;
name|int
name|off
init|=
name|off0
decl_stmt|;
name|len
operator|=
name|nbracket
operator|=
name|nbrace
operator|=
literal|0
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|ng_parse_get_token
argument_list|(
name|s
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|len
argument_list|)
condition|)
block|{
case|case
name|T_LBRACKET
case|:
name|nbracket
operator|++
expr_stmt|;
break|break;
case|case
name|T_LBRACE
case|:
name|nbrace
operator|++
expr_stmt|;
break|break;
case|case
name|T_RBRACKET
case|:
if|if
condition|(
name|nbracket
operator|--
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|T_RBRACE
case|:
if|if
condition|(
name|nbrace
operator|--
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|T_EOF
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
default|default:
break|break;
block|}
name|off
operator|+=
name|len
expr_stmt|;
block|}
do|while
condition|(
name|nbracket
operator|>
literal|0
operator|||
name|nbrace
operator|>
literal|0
condition|)
do|;
operator|*
name|lenp
operator|=
name|off
operator|-
name|off0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next token in the string, starting at offset *startp.  * Returns the token type, with *startp pointing to the first char  * and *lenp the length.  */
end_comment

begin_function
name|enum
name|ng_parse_token
name|ng_parse_get_token
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|startp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|s
index|[
operator|*
name|startp
index|]
argument_list|)
condition|)
operator|(
operator|*
name|startp
operator|)
operator|++
expr_stmt|;
switch|switch
condition|(
name|s
index|[
operator|*
name|startp
index|]
condition|)
block|{
case|case
literal|'\0'
case|:
operator|*
name|lenp
operator|=
literal|0
expr_stmt|;
return|return
name|T_EOF
return|;
case|case
literal|'{'
case|:
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
name|T_LBRACE
return|;
case|case
literal|'}'
case|:
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
name|T_RBRACE
return|;
case|case
literal|'['
case|:
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
name|T_LBRACKET
return|;
case|case
literal|']'
case|:
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
name|T_RBRACKET
return|;
case|case
literal|'='
case|:
operator|*
name|lenp
operator|=
literal|1
expr_stmt|;
return|return
name|T_EQUALS
return|;
case|case
literal|'"'
case|:
if|if
condition|(
operator|(
name|t
operator|=
name|ng_get_string_token
argument_list|(
name|s
argument_list|,
name|startp
argument_list|,
name|lenp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|T_ERROR
return|;
name|FREE
argument_list|(
name|t
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|)
expr_stmt|;
return|return
name|T_STRING
return|;
default|default:
for|for
control|(
name|i
operator|=
operator|*
name|startp
operator|+
literal|1
init|;
name|s
index|[
name|i
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'{'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'}'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'['
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|']'
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'='
operator|&&
name|s
index|[
name|i
index|]
operator|!=
literal|'"'
condition|;
name|i
operator|++
control|)
empty_stmt|;
operator|*
name|lenp
operator|=
name|i
operator|-
operator|*
name|startp
expr_stmt|;
return|return
name|T_WORD
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a string token, which must be enclosed in double quotes.  * The normal C backslash escapes are recognized.  */
end_comment

begin_function
name|char
modifier|*
name|ng_get_string_token
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|startp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|,
name|int
modifier|*
name|slenp
parameter_list|)
block|{
name|char
modifier|*
name|cbuf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|start
decl_stmt|,
name|off
decl_stmt|;
name|int
name|slen
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
name|s
index|[
operator|*
name|startp
index|]
argument_list|)
condition|)
operator|(
operator|*
name|startp
operator|)
operator|++
expr_stmt|;
name|start
operator|=
operator|*
name|startp
expr_stmt|;
if|if
condition|(
name|s
index|[
operator|*
name|startp
index|]
operator|!=
literal|'"'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MALLOC
argument_list|(
name|cbuf
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|s
operator|+
name|start
argument_list|)
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|strcpy
argument_list|(
name|cbuf
argument_list|,
name|s
operator|+
name|start
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|slen
operator|=
literal|0
operator|,
name|off
operator|=
literal|1
operator|,
name|p
operator|=
name|cbuf
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|slen
operator|++
operator|,
name|off
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|lenp
operator|=
name|off
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|slenp
operator|!=
name|NULL
condition|)
operator|*
name|slenp
operator|=
name|slen
expr_stmt|;
return|return
operator|(
name|cbuf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|x
decl_stmt|,
name|k
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'t'
case|:
operator|*
name|v
operator|=
literal|'\t'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
operator|*
name|v
operator|=
literal|'\n'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'r'
case|:
operator|*
name|v
operator|=
literal|'\r'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'v'
case|:
operator|*
name|v
operator|=
literal|'\v'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
operator|*
name|v
operator|=
literal|'\f'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'"'
case|:
operator|*
name|v
operator|=
literal|'"'
expr_stmt|;
name|off
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
for|for
control|(
name|x
operator|=
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|3
operator|&&
operator|*
name|v
operator|>=
literal|'0'
operator|&&
operator|*
name|v
operator|<=
literal|'7'
condition|;
name|v
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|3
operator|)
operator|+
operator|(
operator|*
name|v
operator|-
literal|'0'
operator|)
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
operator|*
operator|--
name|v
operator|=
operator|(
name|char
operator|)
name|x
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
for|for
control|(
name|v
operator|++
operator|,
name|x
operator|=
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|2
operator|&&
name|isxdigit
argument_list|(
operator|*
name|v
argument_list|)
condition|;
name|v
operator|++
control|)
block|{
name|x
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator|+
operator|(
name|isdigit
argument_list|(
operator|*
name|v
argument_list|)
condition|?
operator|(
operator|*
name|v
operator|-
literal|'0'
operator|)
else|:
operator|(
name|tolower
argument_list|(
operator|*
name|v
argument_list|)
operator|-
literal|'a'
operator|+
literal|10
operator|)
operator|)
expr_stmt|;
name|off
operator|++
expr_stmt|;
block|}
operator|*
operator|--
name|v
operator|=
operator|(
name|char
operator|)
name|x
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|strcpy
argument_list|(
name|p
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no closing quote */
block|}
end_function

begin_comment
comment|/*  * Encode a string so it can be safely put in double quotes.  * Caller must free the result. Exactly "slen" characters  * are encoded.  */
end_comment

begin_function
name|char
modifier|*
name|ng_encode_string
parameter_list|(
specifier|const
name|char
modifier|*
name|raw
parameter_list|,
name|int
name|slen
parameter_list|)
block|{
name|char
modifier|*
name|cbuf
decl_stmt|;
name|int
name|off
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MALLOC
argument_list|(
name|cbuf
argument_list|,
name|char
operator|*
argument_list|,
name|strlen
argument_list|(
name|raw
argument_list|)
operator|*
literal|4
operator|+
literal|3
argument_list|,
name|M_NETGRAPH_PARSE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'"'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|slen
condition|;
name|i
operator|++
operator|,
name|raw
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|raw
condition|)
block|{
case|case
literal|'\t'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'t'
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'f'
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'n'
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'r'
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'v'
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
case|case
literal|'\\'
case|:
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
operator|*
name|raw
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|raw
operator|<
literal|0x20
operator|||
operator|*
name|raw
operator|>
literal|0x7e
condition|)
block|{
name|off
operator|+=
name|sprintf
argument_list|(
name|cbuf
operator|+
name|off
argument_list|,
literal|"\\x%02x"
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|raw
argument_list|)
expr_stmt|;
break|break;
block|}
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
operator|*
name|raw
expr_stmt|;
break|break;
block|}
block|}
name|cbuf
index|[
name|off
operator|++
index|]
operator|=
literal|'"'
expr_stmt|;
name|cbuf
index|[
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|cbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			VIRTUAL METHOD LOOKUP  ************************************************************************/
end_comment

begin_function
specifier|static
name|ng_parse_t
modifier|*
name|ng_get_parse_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|parse
operator|==
name|NULL
condition|)
name|t
operator|=
name|t
operator|->
name|supertype
expr_stmt|;
return|return
operator|(
name|t
condition|?
name|t
operator|->
name|parse
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ng_unparse_t
modifier|*
name|ng_get_unparse_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|unparse
operator|==
name|NULL
condition|)
name|t
operator|=
name|t
operator|->
name|supertype
expr_stmt|;
return|return
operator|(
name|t
condition|?
name|t
operator|->
name|unparse
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ng_getDefault_t
modifier|*
name|ng_get_getDefault_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|getDefault
operator|==
name|NULL
condition|)
name|t
operator|=
name|t
operator|->
name|supertype
expr_stmt|;
return|return
operator|(
name|t
condition|?
name|t
operator|->
name|getDefault
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ng_getAlign_t
modifier|*
name|ng_get_getAlign_method
parameter_list|(
specifier|const
name|struct
name|ng_parse_type
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|getAlign
operator|==
name|NULL
condition|)
name|t
operator|=
name|t
operator|->
name|supertype
expr_stmt|;
return|return
operator|(
name|t
condition|?
name|t
operator|->
name|getAlign
else|:
name|NULL
operator|)
return|;
block|}
end_function

end_unit

