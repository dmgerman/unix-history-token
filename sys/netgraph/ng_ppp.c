begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996-2000 Whistle Communications, Inc.  * All rights reserved.  *  * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *  * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Copyright (c) 2007 Alexander Motin<mav@alkar.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Authors: Archie Cobbs<archie@freebsd.org>, Alexander Motin<mav@alkar.net>  *  * $FreeBSD$  * $Whistle: ng_ppp.c,v 1.24 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * PPP node type data-flow.  *  *       hook      xmit        layer         recv      hook  *              ------------------------------------  *       inet ->                                    -> inet  *       ipv6 ->                                    -> ipv6  *        ipx ->               proto                -> ipx  *      atalk ->                                    -> atalk  *     bypass ->                                    -> bypass  *              -hcomp_xmit()----------proto_recv()-  *     vjc_ip<-<- vjc_ip  *   vjc_comp ->         header compression         -> vjc_comp  * vjc_uncomp ->                                    -> vjc_uncomp  *   vjc_vjip ->  *              -comp_xmit()-----------hcomp_recv()-  *   compress<-            compression<- decompress  *   compress ->                                    -> decompress  *              -crypt_xmit()-----------comp_recv()-  *    encrypt<-             encryption<- decrypt  *    encrypt ->                                    -> decrypt  *              -ml_xmit()-------------crypt_recv()-  *                           multilink  *              -link_xmit()--------------ml_recv()-  *      linkX<-               link<- linkX  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ppp.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_vjc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PPP
argument_list|,
literal|"netgraph_ppp"
argument_list|,
literal|"netgraph ppp node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PPP
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROT_VALID
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0x0101) == 0x0001)
end_define

begin_define
define|#
directive|define
name|PROT_COMPRESSABLE
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0xff00) == 0x0000)
end_define

begin_comment
comment|/* Some PPP protocol numbers we're interested in */
end_comment

begin_define
define|#
directive|define
name|PROT_ATALK
value|0x0029
end_define

begin_define
define|#
directive|define
name|PROT_COMPD
value|0x00fd
end_define

begin_define
define|#
directive|define
name|PROT_CRYPTD
value|0x0053
end_define

begin_define
define|#
directive|define
name|PROT_IP
value|0x0021
end_define

begin_define
define|#
directive|define
name|PROT_IPV6
value|0x0057
end_define

begin_define
define|#
directive|define
name|PROT_IPX
value|0x002b
end_define

begin_define
define|#
directive|define
name|PROT_LCP
value|0xc021
end_define

begin_define
define|#
directive|define
name|PROT_MP
value|0x003d
end_define

begin_define
define|#
directive|define
name|PROT_VJCOMP
value|0x002d
end_define

begin_define
define|#
directive|define
name|PROT_VJUNCOMP
value|0x002f
end_define

begin_comment
comment|/* Multilink PPP definitions */
end_comment

begin_define
define|#
directive|define
name|MP_INITIAL_SEQ
value|0
end_define

begin_comment
comment|/* per RFC 1990 */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_LINK_MRU
value|32
end_define

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_MASK
value|0x00000fff
end_define

begin_comment
comment|/* short seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_HIBIT
value|0x00000800
end_define

begin_comment
comment|/* short seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_FIRST_FLAG
value|0x00008000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_LAST_FLAG
value|0x00004000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_MASK
value|0x00ffffff
end_define

begin_comment
comment|/* long seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_HIBIT
value|0x00800000
end_define

begin_comment
comment|/* long seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_FIRST_FLAG
value|0x80000000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_LAST_FLAG
value|0x40000000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_NOSEQ
value|0x7fffffff
end_define

begin_comment
comment|/* impossible sequence number */
end_comment

begin_comment
comment|/* Sign extension of MP sequence numbers */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_SHORT_SEQ_HIBIT) ?		\ 				    ((s) | ~MP_SHORT_SEQ_MASK)		\ 				    : ((s)& MP_SHORT_SEQ_MASK))
end_define

begin_define
define|#
directive|define
name|MP_LONG_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_LONG_SEQ_HIBIT) ?		\ 				    ((s) | ~MP_LONG_SEQ_MASK)		\ 				    : ((s)& MP_LONG_SEQ_MASK))
end_define

begin_comment
comment|/* Comparision of MP sequence numbers. Note: all sequence numbers    except priv->xseq are stored with the sign bit extended. */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|MP_SHORT_EXTEND((x) - (y))
end_define

begin_define
define|#
directive|define
name|MP_LONG_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|MP_LONG_EXTEND((x) - (y))
end_define

begin_define
define|#
directive|define
name|MP_RECV_SEQ_DIFF
parameter_list|(
name|priv
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|((priv)->conf.recvShortSeq ?		\ 				    MP_SHORT_SEQ_DIFF((x), (y)) :	\ 				    MP_LONG_SEQ_DIFF((x), (y)))
end_define

begin_comment
comment|/* Increment receive sequence number */
end_comment

begin_define
define|#
directive|define
name|MP_NEXT_RECV_SEQ
parameter_list|(
name|priv
parameter_list|,
name|seq
parameter_list|)
define|\
value|((priv)->conf.recvShortSeq ?		\ 				    MP_SHORT_EXTEND((seq) + 1) :	\ 				    MP_LONG_EXTEND((seq) + 1))
end_define

begin_comment
comment|/* Don't fragment transmitted packets to parts smaller than this */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_FRAG_LEN
value|32
end_define

begin_comment
comment|/* Maximum fragment reasssembly queue length */
end_comment

begin_define
define|#
directive|define
name|MP_MAX_QUEUE_LEN
value|128
end_define

begin_comment
comment|/* Fragment queue scanner period */
end_comment

begin_define
define|#
directive|define
name|MP_FRAGTIMER_INTERVAL
value|(hz/2)
end_define

begin_comment
comment|/* Average link overhead. XXX: Should be given by user-level */
end_comment

begin_define
define|#
directive|define
name|MP_AVERAGE_LINK_OVERHEAD
value|16
end_define

begin_comment
comment|/* Keep this equal to ng_ppp_hook_names lower! */
end_comment

begin_define
define|#
directive|define
name|HOOK_INDEX_MAX
value|13
end_define

begin_comment
comment|/* We store incoming fragments this way */
end_comment

begin_struct
struct|struct
name|ng_ppp_frag
block|{
name|int
name|seq
decl_stmt|;
comment|/* fragment seq# */
name|uint8_t
name|first
decl_stmt|;
comment|/* First in packet? */
name|uint8_t
name|last
decl_stmt|;
comment|/* Last in packet? */
name|struct
name|timeval
name|timestamp
decl_stmt|;
comment|/* time of reception */
name|struct
name|mbuf
modifier|*
name|data
decl_stmt|;
comment|/* Fragment data */
name|TAILQ_ENTRY
argument_list|(
argument|ng_ppp_frag
argument_list|)
name|f_qent
expr_stmt|;
comment|/* Fragment queue */
block|}
struct|;
end_struct

begin_comment
comment|/* Per-link private information */
end_comment

begin_struct
struct|struct
name|ng_ppp_link
block|{
name|struct
name|ng_ppp_link_conf
name|conf
decl_stmt|;
comment|/* link configuration */
name|struct
name|ng_ppp_link_stat64
name|stats
decl_stmt|;
comment|/* link stats */
name|hook_p
name|hook
decl_stmt|;
comment|/* connection to link data */
name|int32_t
name|seq
decl_stmt|;
comment|/* highest rec'd seq# - MSEQ */
name|uint32_t
name|latency
decl_stmt|;
comment|/* calculated link latency */
name|struct
name|timeval
name|lastWrite
decl_stmt|;
comment|/* time of last write for MP */
name|int
name|bytesInQueue
decl_stmt|;
comment|/* bytes in the output queue for MP */
block|}
struct|;
end_struct

begin_comment
comment|/* Total per-node private information */
end_comment

begin_struct
struct|struct
name|ng_ppp_private
block|{
name|struct
name|ng_ppp_bund_conf
name|conf
decl_stmt|;
comment|/* bundle config */
name|struct
name|ng_ppp_link_stat64
name|bundleStats
decl_stmt|;
comment|/* bundle stats */
name|struct
name|ng_ppp_link
name|links
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
comment|/* per-link info */
name|int32_t
name|xseq
decl_stmt|;
comment|/* next out MP seq # */
name|int32_t
name|mseq
decl_stmt|;
comment|/* min links[i].seq */
name|uint16_t
name|activeLinks
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
comment|/* indicies */
name|uint16_t
name|numActiveLinks
decl_stmt|;
comment|/* how many links up */
name|uint16_t
name|lastLink
decl_stmt|;
comment|/* for round robin */
name|uint8_t
name|vjCompHooked
decl_stmt|;
comment|/* VJ comp hooked up? */
name|uint8_t
name|allLinksEqual
decl_stmt|;
comment|/* all xmit the same? */
name|hook_p
name|hooks
index|[
name|HOOK_INDEX_MAX
index|]
decl_stmt|;
comment|/* non-link hooks */
name|struct
name|ng_ppp_frag
name|fragsmem
index|[
name|MP_MAX_QUEUE_LEN
index|]
decl_stmt|;
comment|/* fragments storage */
name|TAILQ_HEAD
argument_list|(
argument|ng_ppp_fraglist
argument_list|,
argument|ng_ppp_frag
argument_list|)
comment|/* fragment queue */
name|frags
expr_stmt|;
name|TAILQ_HEAD
argument_list|(
argument|ng_ppp_fragfreelist
argument_list|,
argument|ng_ppp_frag
argument_list|)
comment|/* free fragment queue */
name|fragsfree
expr_stmt|;
name|struct
name|callout
name|fragTimer
decl_stmt|;
comment|/* fraq queue check */
name|struct
name|mtx
name|rmtx
decl_stmt|;
comment|/* recv mutex */
name|struct
name|mtx
name|xmtx
decl_stmt|;
comment|/* xmit mutex */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_ppp_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_ppp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_ppp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_ppp_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_ppp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_ppp_disconnect
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_inet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_ipv6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_ipx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_atalk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_bypass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_vjc_ip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_vjc_comp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_vjc_uncomp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_vjc_vjip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_compress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_decompress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_encrypt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata_decrypt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We use integer indicies to refer to the non-link hooks. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|char
modifier|*
specifier|const
name|name
decl_stmt|;
name|ng_rcvdata_t
modifier|*
name|fn
decl_stmt|;
block|}
name|ng_ppp_hook_names
index|[]
init|=
block|{
define|#
directive|define
name|HOOK_INDEX_ATALK
value|0
block|{
name|NG_PPP_HOOK_ATALK
block|,
name|ng_ppp_rcvdata_atalk
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_BYPASS
value|1
block|{
name|NG_PPP_HOOK_BYPASS
block|,
name|ng_ppp_rcvdata_bypass
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_COMPRESS
value|2
block|{
name|NG_PPP_HOOK_COMPRESS
block|,
name|ng_ppp_rcvdata_compress
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_ENCRYPT
value|3
block|{
name|NG_PPP_HOOK_ENCRYPT
block|,
name|ng_ppp_rcvdata_encrypt
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_DECOMPRESS
value|4
block|{
name|NG_PPP_HOOK_DECOMPRESS
block|,
name|ng_ppp_rcvdata_decompress
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_DECRYPT
value|5
block|{
name|NG_PPP_HOOK_DECRYPT
block|,
name|ng_ppp_rcvdata_decrypt
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_INET
value|6
block|{
name|NG_PPP_HOOK_INET
block|,
name|ng_ppp_rcvdata_inet
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_IPX
value|7
block|{
name|NG_PPP_HOOK_IPX
block|,
name|ng_ppp_rcvdata_ipx
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_COMP
value|8
block|{
name|NG_PPP_HOOK_VJC_COMP
block|,
name|ng_ppp_rcvdata_vjc_comp
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_IP
value|9
block|{
name|NG_PPP_HOOK_VJC_IP
block|,
name|ng_ppp_rcvdata_vjc_ip
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_UNCOMP
value|10
block|{
name|NG_PPP_HOOK_VJC_UNCOMP
block|,
name|ng_ppp_rcvdata_vjc_uncomp
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_VJIP
value|11
block|{
name|NG_PPP_HOOK_VJC_VJIP
block|,
name|ng_ppp_rcvdata_vjc_vjip
block|}
block|,
define|#
directive|define
name|HOOK_INDEX_IPV6
value|12
block|{
name|NG_PPP_HOOK_IPV6
block|,
name|ng_ppp_rcvdata_ipv6
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_ppp_proto_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_hcomp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_hcomp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_comp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_comp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_crypt_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_crypt_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_link_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|,
name|int
name|plen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_bypass
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_bump_mseq
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int32_t
name|new_mseq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_frag_drop
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_check_packet
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_get_packet
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_frag_process
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|oitem
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_frag_trim
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_checkstale
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
name|void
modifier|*
name|latency
parameter_list|,
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_cutproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
modifier|*
name|proto
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_conf
modifier|*
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_start_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_stop_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse type for struct ng_ppp_mp_state_type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_ppp_rseq_array_info
init|=
block|{
operator|&
name|ng_parse_hint32_type
block|,
name|NG_PPP_MAX_LINKS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_rseq_array_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_ppp_rseq_array_info
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_mp_state_type_fields
index|[]
init|=
name|NG_PPP_MP_STATE_TYPE_INFO
argument_list|(
operator|&
name|ng_ppp_rseq_array_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_mp_state_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_mp_state_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_link_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_link_type_fields
index|[]
init|=
name|NG_PPP_LINK_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_link_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_link_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_bund_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_bund_type_fields
index|[]
init|=
name|NG_PPP_BUND_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_bund_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_bund_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_node_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_ppp_array_info
init|=
block|{
operator|&
name|ng_ppp_link_type
block|,
name|NG_PPP_MAX_LINKS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_link_array_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_ppp_array_info
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_conf_type_fields
index|[]
init|=
name|NG_PPP_CONFIG_TYPE_INFO
argument_list|(
operator|&
name|ng_ppp_bund_type
argument_list|,
operator|&
name|ng_ppp_link_array_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_conf_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_conf_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_link_stat */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_stats_type_fields
index|[]
init|=
name|NG_PPP_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_stats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_link_stat64 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_stats64_type_fields
index|[]
init|=
name|NG_PPP_STATS64_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_stats64_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_stats64_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_ppp_cmds
index|[]
init|=
block|{
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_ppp_conf_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_ppp_conf_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_MP_STATE
block|,
literal|"getmpstate"
block|,
name|NULL
block|,
operator|&
name|ng_ppp_mp_state_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_LINK_STATS
block|,
literal|"getstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_CLR_LINK_STATS
block|,
literal|"clrstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GETCLR_LINK_STATS
block|,
literal|"getclrstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_LINK_STATS64
block|,
literal|"getstats64"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats64_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GETCLR_LINK_STATS64
block|,
literal|"getclrstats64"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats64_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_ppp_typestruct
init|=
block|{
operator|.
name|version
operator|=
name|NG_ABI_VERSION
block|,
operator|.
name|name
operator|=
name|NG_PPP_NODE_TYPE
block|,
operator|.
name|constructor
operator|=
name|ng_ppp_constructor
block|,
operator|.
name|rcvmsg
operator|=
name|ng_ppp_rcvmsg
block|,
operator|.
name|shutdown
operator|=
name|ng_ppp_shutdown
block|,
operator|.
name|newhook
operator|=
name|ng_ppp_newhook
block|,
operator|.
name|rcvdata
operator|=
name|ng_ppp_rcvdata
block|,
operator|.
name|disconnect
operator|=
name|ng_ppp_disconnect
block|,
operator|.
name|cmdlist
operator|=
name|ng_ppp_cmds
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|ppp
argument_list|,
operator|&
name|ng_ppp_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Address and control field header */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|ng_ppp_acf
index|[
literal|2
index|]
init|=
block|{
literal|0xff
block|,
literal|0x03
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum time we'll let a complete incoming packet sit in the queue */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|timeval
name|ng_ppp_max_staleness
init|=
block|{
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 seconds */
end_comment

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Node type constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate private structure */
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_PPP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
comment|/* Initialize state */
name|TAILQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MP_MAX_QUEUE_LEN
condition|;
name|i
operator|++
control|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
operator|&
name|priv
operator|->
name|fragsmem
index|[
name|i
index|]
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
name|ng_callout_init
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|,
literal|"ng_ppp_recv"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|,
literal|"ng_ppp_xmit"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our OK for a hook to be added  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
modifier|*
name|hookPtr
init|=
name|NULL
decl_stmt|;
name|int
name|linkNum
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hookIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Figure out which hook it is */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|,
comment|/* a link hook? */
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|linkNum
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|'\0'
operator|||
name|linkNum
operator|<
literal|0
operator|||
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|hook
expr_stmt|;
name|hookIndex
operator|=
operator|~
name|linkNum
expr_stmt|;
comment|/* See if hook is already connected. */
if|if
condition|(
operator|*
name|hookPtr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Disallow more than one link unless multilink is enabled. */
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|conf
operator|.
name|enableLink
operator|&&
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|priv
operator|->
name|numActiveLinks
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
else|else
block|{
comment|/* must be a non-link hook */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|hooks
index|[
name|i
index|]
expr_stmt|;
name|hookIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* no such hook */
comment|/* See if hook is already connected */
if|if
condition|(
operator|*
name|hookPtr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Every non-linkX hook have it's own function. */
name|NG_HOOK_SET_RCVDATA
argument_list|(
name|hook
argument_list|,
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|.
name|fn
argument_list|)
expr_stmt|;
block|}
comment|/* OK */
operator|*
name|hookPtr
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|hookIndex
argument_list|)
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPP_SET_CONFIG
case|:
block|{
name|struct
name|ng_ppp_node_conf
modifier|*
specifier|const
name|conf
init|=
operator|(
expr|struct
name|ng_ppp_node_conf
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for invalid or illegal config */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ng_ppp_config_valid
argument_list|(
name|node
argument_list|,
name|conf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Copy config */
name|priv
operator|->
name|conf
operator|=
name|conf
operator|->
name|bund
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|=
name|conf
operator|->
name|links
index|[
name|i
index|]
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_CONFIG
case|:
block|{
name|struct
name|ng_ppp_node_conf
modifier|*
name|conf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|conf
operator|=
operator|(
expr|struct
name|ng_ppp_node_conf
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|conf
operator|->
name|bund
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|conf
operator|->
name|links
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_MP_STATE
case|:
block|{
name|struct
name|ng_ppp_mp_state
modifier|*
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|ng_ppp_mp_state
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
operator|!=
name|MP_NOSEQ
condition|)
name|info
operator|->
name|rseq
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
expr_stmt|;
block|}
name|info
operator|->
name|mseq
operator|=
name|priv
operator|->
name|mseq
expr_stmt|;
name|info
operator|->
name|xseq
operator|=
name|priv
operator|->
name|xseq
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_LINK_STATS
case|:
case|case
name|NGM_PPP_CLR_LINK_STATS
case|:
case|case
name|NGM_PPP_GETCLR_LINK_STATS
case|:
case|case
name|NGM_PPP_GET_LINK_STATS64
case|:
case|case
name|NGM_PPP_GETCLR_LINK_STATS64
case|:
block|{
name|struct
name|ng_ppp_link_stat64
modifier|*
name|stats
decl_stmt|;
name|uint16_t
name|linkNum
decl_stmt|;
comment|/* Process request. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|linkNum
operator|=
operator|*
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|)
condition|?
operator|&
name|priv
operator|->
name|bundleStats
else|:
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|stats
expr_stmt|;
comment|/* Make 64bit reply. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPP_GET_LINK_STATS64
operator|||
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPP_GETCLR_LINK_STATS64
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_ppp_link_stat64
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
comment|/* Make 32bit reply. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPP_GET_LINK_STATS
operator|||
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPP_GETCLR_LINK_STATS
condition|)
block|{
name|struct
name|ng_ppp_link_stat
modifier|*
name|rs
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_ppp_link_stat
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|(
expr|struct
name|ng_ppp_link_stat
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
comment|/* Truncate 64->32 bits. */
name|rs
operator|->
name|xmitFrames
operator|=
name|stats
operator|->
name|xmitFrames
expr_stmt|;
name|rs
operator|->
name|xmitOctets
operator|=
name|stats
operator|->
name|xmitOctets
expr_stmt|;
name|rs
operator|->
name|recvFrames
operator|=
name|stats
operator|->
name|recvFrames
expr_stmt|;
name|rs
operator|->
name|recvOctets
operator|=
name|stats
operator|->
name|recvOctets
expr_stmt|;
name|rs
operator|->
name|badProtos
operator|=
name|stats
operator|->
name|badProtos
expr_stmt|;
name|rs
operator|->
name|runts
operator|=
name|stats
operator|->
name|runts
expr_stmt|;
name|rs
operator|->
name|dupFragments
operator|=
name|stats
operator|->
name|dupFragments
expr_stmt|;
name|rs
operator|->
name|dropFragments
operator|=
name|stats
operator|->
name|dropFragments
expr_stmt|;
block|}
comment|/* Clear stats. */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPP_GET_LINK_STATS
operator|&&
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPP_GET_LINK_STATS64
condition|)
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_VJC_COOKIE
case|:
block|{
comment|/* 		 * Forward it to the vjc node. leave the 		 * old return address alone. 		 * If we have no hook, let NG_RESPOND_MSG 		 * clean up any remaining resources. 		 * Because we have no resp, the item will be freed 		 * along with anything it references. Don't 		 * let msg be freed twice. 		 */
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|=
name|msg
expr_stmt|;
comment|/* put it back in the item */
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|lasthook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
operator|)
condition|)
block|{
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy node  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Stop fragment queue timer */
name|ng_ppp_stop_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Take down netgraph node */
name|ng_ppp_frag_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* let the node escape */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|index
init|=
operator|(
name|intptr_t
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
comment|/* Zero out hook pointer */
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|priv
operator|->
name|links
index|[
operator|~
name|index
index|]
operator|.
name|hook
operator|=
name|NULL
expr_stmt|;
else|else
name|priv
operator|->
name|hooks
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Update derived info (or go away if no hooks left). */
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|>
literal|0
condition|)
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
condition|)
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Proto layer  */
end_comment

begin_comment
comment|/*  * Receive data on a hook inet.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_inet
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|PROT_IP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook ipv6.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_ipv6
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIPv6
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|PROT_IPV6
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook atalk.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_atalk
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|PROT_ATALK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook ipx  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_ipx
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|PROT_IPX
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook bypass  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_bypass
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
name|uint16_t
name|linkNum
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|linkNum
operator|=
name|be16dec
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|proto
operator|=
name|be16dec
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
return|return
operator|(
name|ng_ppp_hcomp_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|proto
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|ng_ppp_link_xmit
argument_list|(
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ppp_bypass
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|uint16_t
name|hdr
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_BYPASS
index|]
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Add 4-byte bypass header. */
name|hdr
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|linkNum
argument_list|)
expr_stmt|;
name|hdr
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|hdr
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_BYPASS
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ppp_proto_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ALIGNED_POINTER
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ALIGNED_POINTER
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|uint32_t
argument_list|)
condition|)
block|{
name|n
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|=
name|n
expr_stmt|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
endif|#
directive|endif
comment|/* ALIGNED_POINTER */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PROT_IP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_INET
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IPV6
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIPv6
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_IPV6
index|]
expr_stmt|;
break|break;
case|case
name|PROT_ATALK
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ATALK
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IPX
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_IPX
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|outHook
operator|==
name|NULL
condition|)
return|return
operator|(
name|ng_ppp_bypass
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|outHook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Header compression layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_hcomp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|==
name|PROT_IP
operator|&&
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_comp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook vjc_comp.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_vjc_comp
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_comp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_VJCOMP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook vjc_uncomp.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_vjc_uncomp
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_comp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_VJUNCOMP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook vjc_vjip.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_vjc_vjip
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_comp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_IP
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ppp_hcomp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
block|{
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PROT_VJCOMP
case|:
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
expr_stmt|;
break|break;
case|case
name|PROT_VJUNCOMP
case|:
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|outHook
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|outHook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ng_ppp_proto_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook vjc_ip.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_vjc_ip
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_proto_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_IP
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compression layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_comp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableCompression
operator|&&
name|proto
operator|<
literal|0x4000
operator|&&
name|proto
operator|!=
name|PROT_COMPD
operator|&&
name|proto
operator|!=
name|PROT_CRYPTD
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_crypt_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook compress.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_compress
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
switch|switch
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableCompression
condition|)
block|{
case|case
name|NG_PPP_COMPRESS_NONE
case|:
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
case|case
name|NG_PPP_COMPRESS_FULL
case|:
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
break|break;
default|default:
name|proto
operator|=
name|PROT_COMPD
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ng_ppp_crypt_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ppp_comp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|<
literal|0x4000
operator|&&
operator|(
operator|(
name|proto
operator|==
name|PROT_COMPD
operator|&&
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
operator|)
operator|||
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
operator|==
name|NG_PPP_DECOMPRESS_FULL
operator|)
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECOMPRESS
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
operator|==
name|NG_PPP_DECOMPRESS_FULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
block|}
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECOMPRESS
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|==
name|PROT_COMPD
condition|)
block|{
comment|/* Disabled protos MUST be silently discarded, but 		 * unsupported MUST not. Let user-level decide this. */
return|return
operator|(
name|ng_ppp_bypass
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook decompress.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_decompress
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_hcomp_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encryption layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_crypt_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
operator|&&
name|proto
operator|<
literal|0x4000
operator|&&
name|proto
operator|!=
name|PROT_CRYPTD
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_mp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook encrypt.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_encrypt
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_mp_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_CRYPTD
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ng_ppp_crypt_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|proto
operator|==
name|PROT_CRYPTD
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Send packet out hook. */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECRYPT
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* Disabled protos MUST be silently discarded, but 			 * unsupported MUST not. Let user-level decide this. */
return|return
operator|(
name|ng_ppp_bypass
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ng_ppp_comp_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook decrypt.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata_decrypt
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|ng_ppp_comp_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link layer  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_link_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|,
name|int
name|plen
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
name|link
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|mru
decl_stmt|;
comment|/* Check if link correct. */
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
condition|)
block|{
name|ERROUT
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
block|}
comment|/* Get link pointer (optimization). */
name|link
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
expr_stmt|;
comment|/* Check link status (if real). */
if|if
condition|(
name|link
operator|->
name|hook
operator|==
name|NULL
condition|)
block|{
name|ERROUT
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
block|}
comment|/* Extract mbuf. */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Check peer's MRU for this link. */
name|mru
operator|=
name|link
operator|->
name|conf
operator|.
name|mru
expr_stmt|;
if|if
condition|(
name|mru
operator|!=
literal|0
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|mru
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Prepend protocol number, possibly compressed. */
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
name|link
operator|->
name|conf
operator|.
name|enableProtoComp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
comment|/* Prepend address and control field (unless compressed). */
if|if
condition|(
name|proto
operator|==
name|PROT_LCP
operator|||
operator|!
name|link
operator|->
name|conf
operator|.
name|enableACFComp
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|ng_ppp_acf
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
comment|/* Deliver frame. */
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|link
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|)
expr_stmt|;
comment|/* Update link stats. */
name|link
operator|->
name|stats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|len
expr_stmt|;
comment|/* Update bundle stats. */
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|priv
operator|->
name|bundleStats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|xmitOctets
operator|+=
name|plen
expr_stmt|;
block|}
comment|/* Update 'bytes in queue' counter. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* bytesInQueue and lastWrite required only for mp_strategy. */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
operator|!
name|priv
operator|->
name|allLinksEqual
operator|&&
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableRoundRobin
condition|)
block|{
comment|/* If queue was empty, then mark this time. */
if|if
condition|(
name|link
operator|->
name|bytesInQueue
operator|==
literal|0
condition|)
name|getmicrouptime
argument_list|(
operator|&
name|link
operator|->
name|lastWrite
argument_list|)
expr_stmt|;
name|link
operator|->
name|bytesInQueue
operator|+=
name|len
operator|+
name|MP_AVERAGE_LINK_OVERHEAD
expr_stmt|;
comment|/* Limit max queue length to 50 pkts. BW can be defined 		    	   incorrectly and link may not signal overload. */
if|if
condition|(
name|link
operator|->
name|bytesInQueue
operator|>
literal|50
operator|*
literal|1600
condition|)
name|link
operator|->
name|bytesInQueue
operator|=
literal|50
operator|*
literal|1600
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|done
label|:
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook linkX.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|index
init|=
operator|(
name|intptr_t
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|uint16_t
name|linkNum
init|=
operator|(
name|uint16_t
operator|)
operator|~
name|index
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|linkNum
operator|<
name|NG_PPP_MAX_LINKS
argument_list|,
operator|(
literal|"%s: bogus index 0x%x"
operator|,
name|__func__
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
comment|/* Stats */
name|link
operator|->
name|stats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Strip address and control fields, if present. */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
index|[
literal|1
index|]
operator|==
literal|0x03
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Get protocol number */
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* Put changed m back into item. */
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|ERROUT
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
comment|/* LCP packets must go directly to bypass. */
if|if
condition|(
name|proto
operator|>=
literal|0xB000
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ng_ppp_bypass
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
comment|/* Other packets are denied on a disabled link. */
if|if
condition|(
operator|!
name|link
operator|->
name|conf
operator|.
name|enableLink
condition|)
name|ERROUT
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
comment|/* Proceed to multilink layer. Mutex will be unlocked inside. */
name|error
operator|=
name|ng_ppp_mp_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Multilink layer  */
end_comment

begin_comment
comment|/*  * Handle an incoming multi-link fragment  *  * The fragment reassembly algorithm is somewhat complex. This is mainly  * because we are required not to reorder the reconstructed packets, yet  * fragments are only guaranteed to arrive in order on a per-link basis.  * In other words, when we have a complete packet ready, but the previous  * packet is still incomplete, we have to decide between delivering the  * complete packet and throwing away the incomplete one, or waiting to  * see if the remainder of the incomplete one arrives, at which time we  * can deliver both packets, in order.  *  * This problem is exacerbated by "sequence number slew", which is when  * the sequence numbers coming in from different links are far apart from  * each other. In particular, certain unnamed equipment (*cough* Ascend)  * has been seen to generate sequence number slew of up to 10 on an ISDN  * 2B-channel MP link. There is nothing invalid about sequence number slew  * but it makes the reasssembly process have to work harder.  *  * However, the peer is required to transmit fragments in order on each  * link. That means if we define MSEQ as the minimum over all links of  * the highest sequence number received on that link, then we can always  * give up any hope of receiving a fragment with sequence number< MSEQ in  * the future (all of this using 'wraparound' sequence number space).  * Therefore we can always immediately throw away incomplete packets  * missing fragments with sequence numbers< MSEQ.  *  * Here is an overview of our algorithm:  *  *    o Received fragments are inserted into a queue, for which we  *	maintain these invariants between calls to this function:  *  *	- Fragments are ordered in the queue by sequence number  *	- If a complete packet is at the head of the queue, then  *	  the first fragment in the packet has seq#> MSEQ + 1  *	  (otherwise, we could deliver it immediately)  *	- If any fragments have seq#< MSEQ, then they are necessarily  *	  part of a packet whose missing seq#'s are all> MSEQ (otherwise,  *	  we can throw them away because they'll never be completed)  *	- The queue contains at most MP_MAX_QUEUE_LEN fragments  *  *    o We have a periodic timer that checks the queue for the first  *	complete packet that has been sitting in the queue "too long".  *	When one is detected, all previous (incomplete) fragments are  *	discarded, their missing fragments are declared lost and MSEQ  *	is increased.  *  *    o If we recieve a fragment with seq#< MSEQ, we throw it away  *	because we've already delcared it lost.  *  * This assumes linkNum != NG_PPP_BUNDLE_LINKNUM.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_recv
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|uint16_t
name|linkNum
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|frag
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diff
decl_stmt|,
name|inserted
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|)
operator|||
name|proto
operator|!=
name|PROT_MP
condition|)
block|{
comment|/* Stats */
name|priv
operator|->
name|bundleStats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|recvOctets
operator|+=
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ng_ppp_crypt_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|)
operator|)
return|;
block|}
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Get a new frag struct from the free queue */
if|if
condition|(
operator|(
name|frag
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No free fragments headers in ng_ppp!\n"
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
comment|/* Extract fragment information from MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
condition|)
block|{
name|uint16_t
name|shdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|2
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|runts
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|shdr
operator|=
name|be16dec
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|MP_SHORT_EXTEND
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|diff
operator|=
name|MP_SHORT_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|lhdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|runts
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|lhdr
operator|=
name|be32dec
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|MP_LONG_EXTEND
argument_list|(
name|lhdr
argument_list|)
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|diff
operator|=
name|MP_LONG_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|frag
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|/* If sequence number is< MSEQ, we've already declared this 	   fragment as lost, so we have no choice now but to drop it */
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Update highest received sequence number on this link and MSEQ */
name|priv
operator|->
name|mseq
operator|=
name|link
operator|->
name|seq
operator|=
name|frag
operator|->
name|seq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|alink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|alink
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|<
literal|0
condition|)
name|priv
operator|->
name|mseq
operator|=
name|alink
operator|->
name|seq
expr_stmt|;
block|}
comment|/* Remove frag struct from free queue. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
comment|/* Add fragment to queue, which is sorted by sequence number */
name|inserted
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|ng_ppp_fraglist
argument_list|,
argument|f_qent
argument_list|)
block|{
name|diff
operator|=
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|frag
operator|->
name|seq
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
comment|/* should never happen! */
name|link
operator|->
name|stats
operator|.
name|dupFragments
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|frag
operator|->
name|data
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|process
label|:
comment|/* Process the queue */
comment|/* NOTE: rmtx will be unlocked for sending time! */
name|error
operator|=
name|ng_ppp_frag_process
argument_list|(
name|node
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			HELPER STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * If new mseq> current then set it and update all active links  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_bump_mseq
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int32_t
name|new_mseq
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|mseq
argument_list|,
name|new_mseq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|priv
operator|->
name|mseq
operator|=
name|new_mseq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|alink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|alink
operator|->
name|seq
argument_list|,
name|new_mseq
argument_list|)
operator|<
literal|0
condition|)
name|alink
operator|->
name|seq
operator|=
name|new_mseq
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Examine our list of fragments, and determine if there is a  * complete and deliverable packet at the head of the list.  * Return 1 if so, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_check_packet
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
comment|/* Check for empty queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check first fragment is the start of a deliverable packet */
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qent
operator|->
name|first
operator|||
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check that all the fragments are there */
while|while
condition|(
operator|!
name|qent
operator|->
name|last
condition|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|==
name|NULL
condition|)
comment|/* end of queue */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qnext
operator|->
name|seq
operator|!=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qent
operator|=
name|qnext
expr_stmt|;
block|}
comment|/* Got one */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull a completed packet off the head of the incoming fragment queue.  * This assumes there is a completed packet there to pull off.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_get_packet
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|&&
name|qent
operator|->
name|first
argument_list|,
operator|(
literal|"%s: no packet"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|NULL
init|;
name|qent
operator|!=
name|NULL
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
name|tail
operator|=
name|m
operator|=
name|qent
operator|->
name|data
expr_stmt|;
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|qent
operator|->
name|data
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tail
operator|->
name|m_next
operator|=
name|qent
operator|->
name|data
expr_stmt|;
block|}
while|while
condition|(
name|tail
operator|->
name|m_next
operator|!=
name|NULL
condition|)
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|qent
operator|->
name|last
condition|)
block|{
name|qnext
operator|=
name|NULL
expr_stmt|;
comment|/* Bump MSEQ if necessary */
name|ng_ppp_bump_mseq
argument_list|(
name|node
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trim fragments from the queue whose packets can never be completed.  * This assumes a complete packet is NOT at the beginning of the queue.  * Returns 1 if fragments were removed, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_frag_trim
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
init|=
name|NULL
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
comment|/* Scan for "dead" fragments and remove them */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|dead
init|=
literal|0
decl_stmt|;
comment|/* If queue is empty, we're done */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
break|break;
comment|/* Determine whether first fragment can ever be completed */
name|TAILQ_FOREACH
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|f_qent
argument_list|)
block|{
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|qnext
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: last frag< MSEQ?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|->
name|seq
operator|!=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
operator|||
name|qent
operator|->
name|last
operator|||
name|qnext
operator|->
name|first
condition|)
block|{
name|dead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dead
condition|)
break|break;
comment|/* Remove fragment and all others in the same packet */
while|while
condition|(
operator|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|)
operator|!=
name|qnext
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|removed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop fragments on queue overflow.  * Returns 1 if fragments were removed, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_frag_drop
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Check queue length */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|)
condition|)
block|{
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|;
comment|/* Get oldest fragment */
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
comment|/* Bump MSEQ if necessary */
name|ng_ppp_bump_mseq
argument_list|(
name|node
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
expr_stmt|;
comment|/* Drop it */
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the queue, restoring the queue invariants  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_frag_process
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|oitem
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|item_p
name|item
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
do|do
block|{
comment|/* Deliver any deliverable packets */
while|while
condition|(
name|ng_ppp_check_packet
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ng_ppp_get_packet
argument_list|(
name|node
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|oitem
condition|)
block|{
comment|/* If original item present - reuse it. */
name|item
operator|=
name|oitem
expr_stmt|;
name|oitem
operator|=
name|NULL
expr_stmt|;
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|NG_NOFLAGS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
comment|/* Stats */
name|priv
operator|->
name|bundleStats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|recvOctets
operator|+=
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Drop mutex for the sending time. 				 * Priv may change, but we are ready! 				 */
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
name|ng_ppp_crypt_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|rmtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Delete dead fragments and try again */
block|}
do|while
condition|(
name|ng_ppp_frag_trim
argument_list|(
name|node
argument_list|)
operator|||
name|ng_ppp_frag_drop
argument_list|(
name|node
argument_list|)
condition|)
do|;
comment|/* If we haven't reused original item - free it. */
if|if
condition|(
name|oitem
condition|)
name|NG_FREE_ITEM
argument_list|(
name|oitem
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for 'stale' completed packets that need to be delivered  *  * If a link goes down or has a temporary failure, MSEQ can get  * "stuck", because no new incoming fragments appear on that link.  * This can cause completed packets to never get delivered if  * their sequence numbers are all> MSEQ + 1.  *  * This routine checks how long all of the completed packets have  * been sitting in the queue, and if too long, removes fragments  * from the queue and increments MSEQ to allow them to be delivered.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_checkstale
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|age
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|seq
decl_stmt|;
name|item_p
name|item
decl_stmt|;
name|int
name|endseq
decl_stmt|;
name|uint16_t
name|proto
decl_stmt|;
name|now
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* uninitialized state */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If queue is empty, we're done */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
break|break;
comment|/* Find the first complete packet in the queue */
name|beg
operator|=
name|end
operator|=
name|NULL
expr_stmt|;
name|seq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|->
name|seq
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|f_qent
argument_list|)
block|{
if|if
condition|(
name|qent
operator|->
name|first
condition|)
name|beg
operator|=
name|qent
expr_stmt|;
elseif|else
if|if
condition|(
name|qent
operator|->
name|seq
operator|!=
name|seq
condition|)
name|beg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|beg
operator|!=
name|NULL
operator|&&
name|qent
operator|->
name|last
condition|)
block|{
name|end
operator|=
name|qent
expr_stmt|;
break|break;
block|}
name|seq
operator|=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
comment|/* If none found, exit */
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
comment|/* Get current time (we assume we've been up for>= 1 second) */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Check if packet has been queued too long */
name|age
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|age
argument_list|,
operator|&
name|beg
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|age
argument_list|,
operator|&
name|ng_ppp_max_staleness
argument_list|,
operator|<
argument_list|)
condition|)
break|break;
comment|/* Throw away junk fragments in front of the completed packet */
while|while
condition|(
operator|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|)
operator|!=
name|beg
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
block|}
comment|/* Extract completed packet */
name|endseq
operator|=
name|end
operator|->
name|seq
expr_stmt|;
name|ng_ppp_get_packet
argument_list|(
name|node
argument_list|,
operator|&
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_cutproto
argument_list|(
name|m
argument_list|,
operator|&
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Deliver packet */
if|if
condition|(
operator|(
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|NG_NOFLAGS
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Stats */
name|priv
operator|->
name|bundleStats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|recvOctets
operator|+=
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ng_ppp_crypt_recv
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Periodically call ng_ppp_frag_checkstale()  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_timeout
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
name|void
modifier|*
name|arg1
parameter_list|,
name|int
name|arg2
parameter_list|)
block|{
comment|/* XXX: is this needed? */
if|if
condition|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
return|return;
comment|/* Scan the fragment queue */
name|ng_ppp_frag_checkstale
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Start timer again */
name|ng_ppp_start_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deliver a frame out on the bundle, i.e., figure out how to fragment  * the frame across the individual PPP links and do so.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_xmit
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|uint16_t
name|proto
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|hdr_len
init|=
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|?
literal|2
else|:
literal|4
decl_stmt|;
name|int
name|distrib
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|firstFragment
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|plen
decl_stmt|;
name|int
name|frags
decl_stmt|;
name|int32_t
name|seq
decl_stmt|;
comment|/* At least one link must be active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|0
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Save length for later stats. */
name|plen
operator|=
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
condition|)
block|{
return|return
operator|(
name|ng_ppp_link_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|proto
argument_list|,
name|priv
operator|->
name|activeLinks
index|[
literal|0
index|]
argument_list|,
name|plen
argument_list|)
operator|)
return|;
block|}
comment|/* Check peer's MRRU for this bundle. */
if|if
condition|(
name|plen
operator|>
name|priv
operator|->
name|conf
operator|.
name|mrru
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* Extract mbuf. */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Prepend protocol number, possibly compressed. */
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Clear distribution plan */
name|bzero
argument_list|(
operator|&
name|distrib
argument_list|,
name|priv
operator|->
name|numActiveLinks
operator|*
sizeof|sizeof
argument_list|(
name|distrib
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|)
expr_stmt|;
comment|/* Round-robin strategy */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableRoundRobin
condition|)
block|{
name|activeLinkNum
operator|=
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are equivalent (optimize the common case) */
if|if
condition|(
name|priv
operator|->
name|allLinksEqual
condition|)
block|{
name|int
name|numFrags
decl_stmt|,
name|fraction
decl_stmt|,
name|remain
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Calculate optimal fragment count */
name|numFrags
operator|=
name|priv
operator|->
name|numActiveLinks
expr_stmt|;
if|if
condition|(
name|numFrags
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|MP_MIN_FRAG_LEN
condition|)
name|numFrags
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|MP_MIN_FRAG_LEN
expr_stmt|;
if|if
condition|(
name|numFrags
operator|==
literal|0
condition|)
name|numFrags
operator|=
literal|1
expr_stmt|;
name|fraction
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|numFrags
expr_stmt|;
name|remain
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|fraction
operator|*
name|numFrags
operator|)
expr_stmt|;
comment|/* Assign distribution */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFrags
condition|;
name|i
operator|++
control|)
block|{
name|distrib
index|[
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
index|]
operator|=
name|fraction
operator|+
operator|(
operator|(
operator|(
name|remain
operator|--
operator|)
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
block|}
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are not equivalent */
name|ng_ppp_mp_strategy
argument_list|(
name|node
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|distrib
argument_list|)
expr_stmt|;
name|deliver
label|:
comment|/* Estimate fragments count */
name|frags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|activeLinkNum
operator|=
name|priv
operator|->
name|numActiveLinks
operator|-
literal|1
init|;
name|activeLinkNum
operator|>=
literal|0
condition|;
name|activeLinkNum
operator|--
control|)
block|{
specifier|const
name|uint16_t
name|linkNum
init|=
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
name|frags
operator|+=
operator|(
name|distrib
index|[
name|activeLinkNum
index|]
operator|+
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
operator|-
literal|1
operator|)
operator|/
operator|(
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
operator|)
expr_stmt|;
block|}
comment|/* Get out initial sequence number */
name|seq
operator|=
name|priv
operator|->
name|xseq
expr_stmt|;
comment|/* Update next sequence number */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|)
block|{
name|priv
operator|->
name|xseq
operator|=
operator|(
name|seq
operator|+
name|frags
operator|)
operator|&
name|MP_SHORT_SEQ_MASK
expr_stmt|;
block|}
else|else
block|{
name|priv
operator|->
name|xseq
operator|=
operator|(
name|seq
operator|+
name|frags
operator|)
operator|&
name|MP_LONG_SEQ_MASK
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|priv
operator|->
name|xmtx
argument_list|)
expr_stmt|;
comment|/* Send alloted portions of frame out on the link(s) */
for|for
control|(
name|firstFragment
operator|=
literal|1
operator|,
name|activeLinkNum
operator|=
name|priv
operator|->
name|numActiveLinks
operator|-
literal|1
init|;
name|activeLinkNum
operator|>=
literal|0
condition|;
name|activeLinkNum
operator|--
control|)
block|{
specifier|const
name|uint16_t
name|linkNum
init|=
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
comment|/* Deliver fragment(s) out the next link */
for|for
control|(
init|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|>
literal|0
condition|;
name|firstFragment
operator|=
literal|0
control|)
block|{
name|int
name|len
decl_stmt|,
name|lastFragment
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
comment|/* Calculate fragment length; don't exceed link MTU */
name|len
operator|=
name|distrib
index|[
name|activeLinkNum
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
condition|)
name|len
operator|=
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|-=
name|len
expr_stmt|;
name|lastFragment
operator|=
operator|(
name|len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
expr_stmt|;
comment|/* Split off next fragment as "m2" */
name|m2
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|lastFragment
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_split
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_DONTWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|m_tag_copy_chain
argument_list|(
name|n
argument_list|,
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* Prepend MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|)
block|{
name|uint16_t
name|shdr
decl_stmt|;
name|shdr
operator|=
name|seq
expr_stmt|;
name|seq
operator|=
operator|(
name|seq
operator|+
literal|1
operator|)
operator|&
name|MP_SHORT_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_LAST_FLAG
expr_stmt|;
name|shdr
operator|=
name|htons
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ng_ppp_prepend
argument_list|(
name|m2
argument_list|,
operator|&
name|shdr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|lhdr
decl_stmt|;
name|lhdr
operator|=
name|seq
expr_stmt|;
name|seq
operator|=
operator|(
name|seq
operator|+
literal|1
operator|)
operator|&
name|MP_LONG_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_LAST_FLAG
expr_stmt|;
name|lhdr
operator|=
name|htonl
argument_list|(
name|lhdr
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ng_ppp_prepend
argument_list|(
name|m2
argument_list|,
operator|&
name|lhdr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Send fragment */
if|if
condition|(
name|firstFragment
condition|)
block|{
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m2
expr_stmt|;
comment|/* Reuse original item. */
block|}
else|else
block|{
name|item
operator|=
name|ng_package_data
argument_list|(
name|m2
argument_list|,
name|NG_NOFLAGS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ng_ppp_link_xmit
argument_list|(
name|node
argument_list|,
name|item
argument_list|,
name|PROT_MP
argument_list|,
name|linkNum
argument_list|,
operator|(
name|firstFragment
condition|?
name|plen
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Computing the optimal fragmentation  * -----------------------------------  *  * This routine tries to compute the optimal fragmentation pattern based  * on each link's latency, bandwidth, and calculated additional latency.  * The latter quantity is the additional latency caused by previously  * written data that has not been transmitted yet.  *  * This algorithm is only useful when not all of the links have the  * same latency and bandwidth values.  *  * The essential idea is to make the last bit of each fragment of the  * frame arrive at the opposite end at the exact same time. This greedy  * algorithm is optimal, in that no other scheduling could result in any  * packet arriving any sooner unless packets are delivered out of order.  *  * Suppose link i has bandwidth b_i (in tens of bytes per milisecond) and  * latency l_i (in miliseconds). Consider the function function f_i(t)  * which is equal to the number of bytes that will have arrived at  * the peer after t miliseconds if we start writing continuously at  * time t = 0. Then f_i(t) = b_i * (t - l_i) = ((b_i * t) - (l_i * b_i).  * That is, f_i(t) is a line with slope b_i and y-intersect -(l_i * b_i).  * Note that the y-intersect is always<= zero because latency can't be  * negative.  Note also that really the function is f_i(t) except when  * f_i(t) is negative, in which case the function is zero.  To take  * care of this, let Q_i(t) = { if (f_i(t)> 0) return 1; else return 0; }.  * So the actual number of bytes that will have arrived at the peer after  * t miliseconds is f_i(t) * Q_i(t).  *  * At any given time, each link has some additional latency a_i>= 0  * due to previously written fragment(s) which are still in the queue.  * This value is easily computed from the time since last transmission,  * the previous latency value, the number of bytes written, and the  * link's bandwidth.  *  * Assume that l_i includes any a_i already, and that the links are  * sorted by latency, so that l_i<= l_{i+1}.  *  * Let N be the total number of bytes in the current frame we are sending.  *  * Suppose we were to start writing bytes at time t = 0 on all links  * simultaneously, which is the most we can possibly do.  Then let  * F(t) be equal to the total number of bytes received by the peer  * after t miliseconds. Then F(t) = Sum_i (f_i(t) * Q_i(t)).  *  * Our goal is simply this: fragment the frame across the links such  * that the peer is able to reconstruct the completed frame as soon as  * possible, i.e., at the least possible value of t. Call this value t_0.  *  * Then it follows that F(t_0) = N. Our strategy is first to find the value  * of t_0, and then deduce how many bytes to write to each link.  *  * Rewriting F(t_0):  *  *   t_0 = ( N + Sum_i ( l_i * b_i * Q_i(t_0) ) ) / Sum_i ( b_i * Q_i(t_0) )  *  * Now, we note that Q_i(t) is constant for l_i<= t<= l_{i+1}. t_0 will  * lie in one of these ranges.  To find it, we just need to find the i such  * that F(l_i)<= N<= F(l_{i+1}).  Then we compute all the constant values  * for Q_i() in this range, plug in the remaining values, solving for t_0.  *  * Once t_0 is known, then the number of bytes to send on link i is  * just f_i(t_0) * Q_i(t_0).  *  * In other words, we start allocating bytes to the links one at a time.  * We keep adding links until the frame is completely sent.  Some links  * may not get any bytes because their latency is too high.  *  * Is all this work really worth the trouble?  Depends on the situation.  * The bigger the ratio of computer speed to link speed, and the more  * important total bundle latency is (e.g., for interactive response time),  * the more it's worth it.  There is however the cost of calling this  * function for every frame.  The running time is O(n^2) where n is the  * number of links that receive a non-zero number of bytes.  *  * Since latency is measured in miliseconds, the "resolution" of this  * algorithm is one milisecond.  *  * To avoid this algorithm altogether, configure all links to have the  * same latency and bandwidth.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|latency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|sortByLatency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|total
decl_stmt|,
name|topSum
decl_stmt|,
name|botSum
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numFragments
decl_stmt|;
comment|/* If only one link, this gets real easy */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|1
condition|)
block|{
name|distrib
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
return|return;
block|}
comment|/* Get current time */
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Compute latencies for each link at this point in time */
for|for
control|(
name|activeLinkNum
operator|=
literal|0
init|;
name|activeLinkNum
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|activeLinkNum
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|alink
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|int
name|xmitBytes
decl_stmt|;
comment|/* Start with base latency value */
name|alink
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
index|]
expr_stmt|;
name|latency
index|[
name|activeLinkNum
index|]
operator|=
name|alink
operator|->
name|latency
expr_stmt|;
name|sortByLatency
index|[
name|activeLinkNum
index|]
operator|=
name|activeLinkNum
expr_stmt|;
comment|/* see below */
comment|/* Any additional latency? */
if|if
condition|(
name|alink
operator|->
name|bytesInQueue
operator|==
literal|0
condition|)
continue|continue;
comment|/* Compute time delta since last write */
name|diff
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|alink
operator|->
name|lastWrite
argument_list|)
expr_stmt|;
comment|/* alink->bytesInQueue will be changed, mark change time. */
name|alink
operator|->
name|lastWrite
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|diff
operator|.
name|tv_sec
operator|>=
literal|10
condition|)
block|{
comment|/* sanity */
name|alink
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* How many bytes could have transmitted since last write? */
name|xmitBytes
operator|=
operator|(
name|alink
operator|->
name|conf
operator|.
name|bandwidth
operator|*
literal|10
operator|*
name|diff
operator|.
name|tv_sec
operator|)
operator|+
operator|(
name|alink
operator|->
name|conf
operator|.
name|bandwidth
operator|*
operator|(
name|diff
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|)
operator|/
literal|100
expr_stmt|;
name|alink
operator|->
name|bytesInQueue
operator|-=
name|xmitBytes
expr_stmt|;
if|if
condition|(
name|alink
operator|->
name|bytesInQueue
operator|<
literal|0
condition|)
name|alink
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
else|else
name|latency
index|[
name|activeLinkNum
index|]
operator|+=
operator|(
literal|100
operator|*
name|alink
operator|->
name|bytesInQueue
operator|)
operator|/
name|alink
operator|->
name|conf
operator|.
name|bandwidth
expr_stmt|;
block|}
comment|/* Sort active links by latency */
name|qsort_r
argument_list|(
name|sortByLatency
argument_list|,
name|priv
operator|->
name|numActiveLinks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sortByLatency
argument_list|)
argument_list|,
name|latency
argument_list|,
name|ng_ppp_intcmp
argument_list|)
expr_stmt|;
comment|/* Find the interval we need (add links in sortByLatency[] order) */
for|for
control|(
name|numFragments
operator|=
literal|1
init|;
name|numFragments
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|numFragments
operator|++
control|)
block|{
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flowTime
decl_stmt|;
name|flowTime
operator|=
name|latency
index|[
name|sortByLatency
index|[
name|numFragments
index|]
index|]
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
name|total
operator|+=
operator|(
operator|(
name|flowTime
operator|*
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
operator|)
operator|+
literal|99
operator|)
operator|/
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|>=
name|len
condition|)
break|break;
block|}
comment|/* Solve for t_0 in that interval */
for|for
control|(
name|topSum
operator|=
name|botSum
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
decl_stmt|;
name|topSum
operator|+=
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|*
name|bw
expr_stmt|;
comment|/* / 100 */
name|botSum
operator|+=
name|bw
expr_stmt|;
comment|/* / 100 */
block|}
name|t0
operator|=
operator|(
operator|(
name|len
operator|*
literal|100
operator|)
operator|+
name|topSum
operator|+
name|botSum
operator|/
literal|2
operator|)
operator|/
name|botSum
expr_stmt|;
comment|/* Compute f_i(t_0) all i */
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
decl_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|=
operator|(
name|bw
operator|*
operator|(
name|t0
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|total
operator|+=
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* Deal with any rounding error */
if|if
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|fastLink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
literal|0
index|]
index|]
index|]
decl_stmt|;
name|int
name|fast
init|=
literal|0
decl_stmt|;
comment|/* Find the fastest link */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
decl_stmt|;
if|if
condition|(
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|>
name|fastLink
operator|->
name|conf
operator|.
name|bandwidth
condition|)
block|{
name|fast
operator|=
name|i
expr_stmt|;
name|fastLink
operator|=
name|link
expr_stmt|;
block|}
block|}
name|distrib
index|[
name|sortByLatency
index|[
name|fast
index|]
index|]
operator|+=
name|len
operator|-
name|total
expr_stmt|;
block|}
else|else
while|while
condition|(
name|total
operator|>
name|len
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|slowLink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
literal|0
index|]
index|]
index|]
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|slow
init|=
literal|0
decl_stmt|;
comment|/* Find the slowest link that still has bytes to remove */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
decl_stmt|;
if|if
condition|(
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|>
literal|0
operator|&&
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|<
name|slowLink
operator|->
name|conf
operator|.
name|bandwidth
operator|)
condition|)
block|{
name|slow
operator|=
name|i
expr_stmt|;
name|slowLink
operator|=
name|link
expr_stmt|;
block|}
block|}
name|delta
operator|=
name|total
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
condition|)
name|delta
operator|=
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
expr_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|-=
name|delta
expr_stmt|;
name|total
operator|-=
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two integers  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
name|void
modifier|*
name|latency
parameter_list|,
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|int
name|index1
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v1
operator|)
decl_stmt|;
specifier|const
name|int
name|index2
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v2
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|int
operator|*
operator|)
name|latency
operator|)
index|[
name|index1
index|]
operator|-
operator|(
operator|(
name|int
operator|*
operator|)
name|latency
operator|)
index|[
name|index2
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend a possibly compressed PPP protocol number in front of a frame  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
block|{
if|if
condition|(
name|compOK
operator|&&
name|PROT_COMPRESSABLE
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|uint8_t
name|pbyte
init|=
operator|(
name|uint8_t
operator|)
name|proto
decl_stmt|;
return|return
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|pbyte
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|uint16_t
name|pword
init|=
name|htons
argument_list|(
operator|(
name|uint16_t
operator|)
name|proto
argument_list|)
decl_stmt|;
return|return
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|pword
argument_list|,
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cut a possibly compressed PPP protocol number from the front of a frame.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_cutproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
modifier|*
name|proto
parameter_list|)
block|{
operator|*
name|proto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|1
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|proto
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
operator|*
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|1
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|proto
operator|=
operator|(
operator|*
name|proto
operator|<<
literal|8
operator|)
operator|+
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend some bytes to an mbuf.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
name|len
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update private information that is derived from other private information  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update active status for VJ Compression */
name|priv
operator|->
name|vjCompHooked
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_VJIP
index|]
operator|!=
name|NULL
expr_stmt|;
comment|/* Increase latency for each link an amount equal to one MP header */
if|if
condition|(
name|newConf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hdrBytes
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|bandwidth
operator|==
literal|0
condition|)
continue|continue;
name|hdrBytes
operator|=
name|MP_AVERAGE_LINK_OVERHEAD
operator|+
operator|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|enableACFComp
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
operator|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|enableProtoComp
condition|?
literal|1
else|:
literal|2
operator|)
operator|+
operator|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|=
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|latency
operator|+
operator|(
name|hdrBytes
operator|/
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|bandwidth
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
block|}
block|}
comment|/* Update list of active links */
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|activeLinks
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|activeLinks
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numActiveLinks
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|allLinksEqual
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|i
index|]
decl_stmt|;
comment|/* Is link active? */
if|if
condition|(
name|link
operator|->
name|conf
operator|.
name|enableLink
operator|&&
name|link
operator|->
name|hook
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|link0
decl_stmt|;
comment|/* Add link to list of active links */
name|priv
operator|->
name|activeLinks
index|[
name|priv
operator|->
name|numActiveLinks
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|link0
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* Determine if all links are still equal */
if|if
condition|(
name|link
operator|->
name|latency
operator|!=
name|link0
operator|->
name|latency
operator|||
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|!=
name|link0
operator|->
name|conf
operator|.
name|bandwidth
condition|)
name|priv
operator|->
name|allLinksEqual
operator|=
literal|0
expr_stmt|;
comment|/* Initialize rec'd sequence number */
if|if
condition|(
name|link
operator|->
name|seq
operator|==
name|MP_NOSEQ
condition|)
block|{
name|link
operator|->
name|seq
operator|=
operator|(
name|link
operator|==
name|link0
operator|)
condition|?
name|MP_INITIAL_SEQ
else|:
name|link0
operator|->
name|seq
expr_stmt|;
block|}
block|}
else|else
name|link
operator|->
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
block|}
comment|/* Update MP state as multi-link is active or not */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|priv
operator|->
name|numActiveLinks
operator|>
literal|0
condition|)
name|ng_ppp_start_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|ng_ppp_stop_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_ppp_frag_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|priv
operator|->
name|xseq
operator|=
name|MP_INITIAL_SEQ
expr_stmt|;
name|priv
operator|->
name|mseq
operator|=
name|MP_INITIAL_SEQ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|i
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|link
operator|->
name|lastWrite
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|lastWrite
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine if a new configuration would represent a valid change  * from the current configuration and link activity status.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_conf
modifier|*
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newNumLinksActive
decl_stmt|;
comment|/* Check per-link config and count how many links would be active */
for|for
control|(
name|newNumLinksActive
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|enableLink
operator|&&
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|hook
operator|!=
name|NULL
condition|)
name|newNumLinksActive
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|enableLink
condition|)
continue|continue;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|mru
operator|<
name|MP_MIN_LINK_MRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|>
name|NG_PPP_MAX_BANDWIDTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|>
name|NG_PPP_MAX_LATENCY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Disallow changes to multi-link configuration while MP is active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|>
literal|0
operator|&&
name|newNumLinksActive
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|enableMultilink
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|xmitShortSeq
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|recvShortSeq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At most one link can be active unless multi-link is enabled */
if|if
condition|(
operator|!
name|newConf
operator|->
name|bund
operator|.
name|enableMultilink
operator|&&
name|newNumLinksActive
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Configuration change would be valid */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all entries in the fragment queue  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
for|for
control|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
init|;
name|qent
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|fragsfree
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start fragment queue timer  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_start_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|callout_pending
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|)
operator|)
condition|)
name|ng_callout
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|,
name|node
argument_list|,
name|NULL
argument_list|,
name|MP_FRAGTIMER_INTERVAL
argument_list|,
name|ng_ppp_frag_timeout
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop fragment queue timer  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_stop_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|)
condition|)
name|ng_uncallout
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

