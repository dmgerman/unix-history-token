begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_ppp.c  *  * Copyright (c) 1996-1999 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@whistle.com>  *  * $FreeBSD$  * $Whistle: ng_ppp.c,v 1.24 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * PPP node type.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ppp.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_vjc.h>
end_include

begin_define
define|#
directive|define
name|PROT_VALID
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0x0101) == 0x0001)
end_define

begin_define
define|#
directive|define
name|PROT_COMPRESSIBLE
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0xff00) == 0x0000)
end_define

begin_comment
comment|/* Some PPP protocol numbers we're interested in */
end_comment

begin_define
define|#
directive|define
name|PROT_APPLETALK
value|0x0029
end_define

begin_define
define|#
directive|define
name|PROT_COMPD
value|0x00fd
end_define

begin_define
define|#
directive|define
name|PROT_CRYPTD
value|0x0053
end_define

begin_define
define|#
directive|define
name|PROT_IP
value|0x0021
end_define

begin_define
define|#
directive|define
name|PROT_IPX
value|0x002B
end_define

begin_define
define|#
directive|define
name|PROT_MP
value|0x003d
end_define

begin_define
define|#
directive|define
name|PROT_VJCOMP
value|0x002d
end_define

begin_define
define|#
directive|define
name|PROT_VJUNCOMP
value|0x002f
end_define

begin_comment
comment|/* Multilink PPP definitions */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_MRRU
value|1500
end_define

begin_comment
comment|/* per RFC 1990 */
end_comment

begin_define
define|#
directive|define
name|MP_INITIAL_SEQ
value|0
end_define

begin_comment
comment|/* per RFC 1990 */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_LINK_MRU
value|32
end_define

begin_define
define|#
directive|define
name|MP_MAX_SEQ_LINGER
value|64
end_define

begin_comment
comment|/* max frags we will hold */
end_comment

begin_define
define|#
directive|define
name|MP_INSANE_SEQ_JUMP
value|128
end_define

begin_comment
comment|/* a sequence # jump too far */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_FRAG_LEN
value|6
end_define

begin_comment
comment|/* don't frag smaller frames */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_MASK
value|0x00000fff
end_define

begin_comment
comment|/* short seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_HIBIT
value|0x00000800
end_define

begin_comment
comment|/* short seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_FIRST_FLAG
value|0x00008000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_LAST_FLAG
value|0x00004000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_MASK
value|0x00ffffff
end_define

begin_comment
comment|/* long seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_HIBIT
value|0x00800000
end_define

begin_comment
comment|/* long seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_FIRST_FLAG
value|0x80000000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_LAST_FLAG
value|0x40000000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_SEQ_MASK
value|(priv->conf.recvShortSeq ? \ 				    MP_SHORT_SEQ_MASK : MP_LONG_SEQ_MASK)
end_define

begin_comment
comment|/* Sign extension of MP sequence numbers */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_SHORT_SEQ_HIBIT) ? \ 				    ((s) | ~MP_SHORT_SEQ_MASK) : (s))
end_define

begin_define
define|#
directive|define
name|MP_LONG_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_LONG_SEQ_HIBIT) ? \ 				    ((s) | ~MP_LONG_SEQ_MASK) : (s))
end_define

begin_comment
comment|/* Comparision of MP sequence numbers */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(MP_SHORT_EXTEND(x) - MP_SHORT_EXTEND(y))
end_define

begin_define
define|#
directive|define
name|MP_LONG_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(MP_LONG_EXTEND(x) - MP_LONG_EXTEND(y))
end_define

begin_define
define|#
directive|define
name|MP_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(priv->conf.recvShortSeq ? \ 				    MP_SHORT_SEQ_DIFF((x), (y)) : \ 				    MP_LONG_SEQ_DIFF((x), (y)))
end_define

begin_comment
comment|/* We store incoming fragments this way */
end_comment

begin_struct
struct|struct
name|ng_ppp_frag
block|{
name|int
name|seq
decl_stmt|;
name|u_char
name|first
decl_stmt|;
name|u_char
name|last
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|data
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|CIRCLEQ_ENTRY
argument_list|(
argument|ng_ppp_frag
argument_list|)
name|f_qent
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We keep track of link queue status this way */
end_comment

begin_struct
struct|struct
name|ng_ppp_link_qstat
block|{
name|struct
name|timeval
name|lastWrite
decl_stmt|;
comment|/* time of last write */
name|int
name|bytesInQueue
decl_stmt|;
comment|/* bytes in the queue then */
block|}
struct|;
end_struct

begin_comment
comment|/* We use integer indicies to refer to the non-link hooks */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ng_ppp_hook_names
index|[]
init|=
block|{
name|NG_PPP_HOOK_ATALK
block|,
define|#
directive|define
name|HOOK_INDEX_ATALK
value|0
name|NG_PPP_HOOK_BYPASS
block|,
define|#
directive|define
name|HOOK_INDEX_BYPASS
value|1
name|NG_PPP_HOOK_COMPRESS
block|,
define|#
directive|define
name|HOOK_INDEX_COMPRESS
value|2
name|NG_PPP_HOOK_ENCRYPT
block|,
define|#
directive|define
name|HOOK_INDEX_ENCRYPT
value|3
name|NG_PPP_HOOK_DECOMPRESS
block|,
define|#
directive|define
name|HOOK_INDEX_DECOMPRESS
value|4
name|NG_PPP_HOOK_DECRYPT
block|,
define|#
directive|define
name|HOOK_INDEX_DECRYPT
value|5
name|NG_PPP_HOOK_INET
block|,
define|#
directive|define
name|HOOK_INDEX_INET
value|6
name|NG_PPP_HOOK_IPX
block|,
define|#
directive|define
name|HOOK_INDEX_IPX
value|7
name|NG_PPP_HOOK_VJC_COMP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_COMP
value|8
name|NG_PPP_HOOK_VJC_IP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_IP
value|9
name|NG_PPP_HOOK_VJC_UNCOMP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_UNCOMP
value|10
name|NG_PPP_HOOK_VJC_VJIP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_VJIP
value|11
name|NULL
define|#
directive|define
name|HOOK_INDEX_MAX
value|12
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We store index numbers in the hook private pointer. The HOOK_INDEX()    for a hook is either the index (above) for normal hooks, or the ones    complement of the link number for link hooks. */
end_comment

begin_define
define|#
directive|define
name|HOOK_INDEX
parameter_list|(
name|hook
parameter_list|)
value|(*((int16_t *)&(hook)->private))
end_define

begin_comment
comment|/* Node private data */
end_comment

begin_struct
struct|struct
name|private
block|{
name|struct
name|ng_ppp_node_config
name|conf
decl_stmt|;
name|struct
name|ng_ppp_link_stat
name|bundleStats
decl_stmt|;
name|struct
name|ng_ppp_link_stat
name|linkStats
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|hook_p
name|links
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|hook_p
name|hooks
index|[
name|HOOK_INDEX_MAX
index|]
decl_stmt|;
name|u_char
name|vjCompHooked
decl_stmt|;
name|u_char
name|allLinksEqual
decl_stmt|;
name|u_short
name|activeLinks
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|u_int
name|numActiveLinks
decl_stmt|;
name|u_int
name|lastLink
decl_stmt|;
comment|/* for round robin */
name|struct
name|ng_ppp_link_qstat
name|qstat
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|CIRCLEQ_HEAD
argument_list|(
argument|ng_ppp_fraglist
argument_list|,
argument|ng_ppp_frag
argument_list|)
name|frags
expr_stmt|;
comment|/* incoming fragments */
name|int
name|mpSeqOut
decl_stmt|;
comment|/* next out MP seq # */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_ppp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_ppp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_ppp_rmnode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_ppp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_ppp_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_ppp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|ln
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|ln
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_input
parameter_list|(
name|node_p
name|nd
parameter_list|,
name|int
name|ln
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_config
modifier|*
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_free_frags
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_ppp_typestruct
init|=
block|{
name|NG_VERSION
block|,
name|NG_PPP_NODE_TYPE
block|,
name|NULL
block|,
name|ng_ppp_constructor
block|,
name|ng_ppp_rcvmsg
block|,
name|ng_ppp_rmnode
block|,
name|ng_ppp_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_ppp_rcvdata
block|,
name|ng_ppp_rcvdata
block|,
name|ng_ppp_disconnect
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|ppp
argument_list|,
operator|&
name|ng_ppp_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|compareLatencies
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hack for ng_ppp_intcmp() */
end_comment

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Node type constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_constructor
parameter_list|(
name|node_p
modifier|*
name|nodep
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allocate private structure */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call generic node constructor */
if|if
condition|(
operator|(
name|error
operator|=
name|ng_make_node_common
argument_list|(
operator|&
name|ng_ppp_typestruct
argument_list|,
name|nodep
argument_list|)
operator|)
condition|)
block|{
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|nodep
operator|)
operator|->
name|private
operator|=
name|priv
expr_stmt|;
comment|/* Initialize state */
name|CIRCLEQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our OK for a hook to be added  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|linkNum
init|=
operator|-
literal|1
decl_stmt|;
name|hook_p
modifier|*
name|hookPtr
init|=
name|NULL
decl_stmt|;
name|int
name|hookIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Figure out which hook it is */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|,
comment|/* a link hook? */
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|gotDigit
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
init|;
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'9'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|gotDigit
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'0'
condition|)
comment|/* no leading zeros */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|linkNum
operator|=
operator|*
name|cp
operator|-
literal|'0'
expr_stmt|;
name|gotDigit
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|linkNum
operator|=
operator|(
name|linkNum
operator|*
literal|10
operator|)
operator|+
operator|(
operator|*
name|cp
operator|-
literal|'0'
operator|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|gotDigit
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
expr_stmt|;
name|hookIndex
operator|=
operator|~
name|linkNum
expr_stmt|;
block|}
else|else
block|{
comment|/* must be a non-link hook */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ng_ppp_hook_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|hooks
index|[
name|i
index|]
expr_stmt|;
name|hookIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* no such hook */
block|}
comment|/* See if hook is already connected */
if|if
condition|(
operator|*
name|hookPtr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Disallow more than one link unless multilink is enabled */
if|if
condition|(
name|linkNum
operator|!=
operator|-
literal|1
operator|&&
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|enableLink
operator|&&
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|priv
operator|->
name|numActiveLinks
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* OK */
operator|*
name|hookPtr
operator|=
name|hook
expr_stmt|;
name|HOOK_INDEX
argument_list|(
name|hook
argument_list|)
operator|=
name|hookIndex
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|ng_mesg
modifier|*
name|msg
parameter_list|,
specifier|const
name|char
modifier|*
name|raddr
parameter_list|,
name|struct
name|ng_mesg
modifier|*
modifier|*
name|rptr
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPP_SET_CONFIG
case|:
block|{
name|struct
name|ng_ppp_node_config
modifier|*
specifier|const
name|newConf
init|=
operator|(
expr|struct
name|ng_ppp_node_config
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
comment|/* Check for invalid or illegal config */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|newConf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ng_ppp_config_valid
argument_list|(
name|node
argument_list|,
name|newConf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|priv
operator|->
name|conf
operator|=
operator|*
name|newConf
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_CONFIG
case|:
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|priv
operator|->
name|conf
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|conf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NGM_PPP_GET_LINK_STATS
case|:
case|case
name|NGM_PPP_CLR_LINK_STATS
case|:
block|{
name|struct
name|ng_ppp_link_stat
modifier|*
name|stats
decl_stmt|;
name|u_int16_t
name|linkNum
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|linkNum
operator|=
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|)
condition|?
operator|&
name|priv
operator|->
name|bundleStats
else|:
operator|&
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|==
name|NGM_PPP_GET_LINK_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_ppp_link_stat
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_VJC_COOKIE
case|:
block|{
name|char
name|path
index|[
name|NG_PATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|node_p
name|origNode
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ng_path2node
argument_list|(
name|node
argument_list|,
name|raddr
argument_list|,
operator|&
name|origNode
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|ERROUT
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"[%lx]:%s"
argument_list|,
operator|(
name|long
operator|)
name|node
argument_list|,
name|NG_PPP_HOOK_VJC_IP
argument_list|)
expr_stmt|;
return|return
name|ng_send_msg
argument_list|(
name|origNode
argument_list|,
name|msg
argument_list|,
name|path
argument_list|,
name|rptr
argument_list|)
return|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rptr
condition|)
operator|*
name|rptr
operator|=
name|resp
expr_stmt|;
elseif|else
if|if
condition|(
name|resp
condition|)
name|FREE
argument_list|(
name|resp
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|done
label|:
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|hook
operator|->
name|node
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
specifier|const
name|int
name|index
init|=
name|HOOK_INDEX
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|u_int16_t
name|linkNum
init|=
name|NG_PPP_BUNDLE_LINKNUM
decl_stmt|;
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
name|int
name|proto
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
comment|/* Did it come from a link hook? */
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
comment|/* Is link active? */
name|linkNum
operator|=
operator|(
name|u_int16_t
operator|)
operator|~
name|index
expr_stmt|;
name|KASSERT
argument_list|(
name|linkNum
operator|<
name|NG_PPP_MAX_LINKS
argument_list|,
operator|(
literal|"%s: bogus index 0x%x"
operator|,
name|__FUNCTION__
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|enableLink
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Stats */
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Dispatch incoming frame */
return|return
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
name|linkNum
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
block|}
comment|/* Get protocol& check if data allowed from this hook */
switch|switch
condition|(
name|index
condition|)
block|{
comment|/* Downwards flowing data */
case|case
name|HOOK_INDEX_ATALK
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_APPLETALK
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_IPX
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_IPX
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_INET
case|:
case|case
name|HOOK_INDEX_VJC_VJIP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_IP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_VJC_COMP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_VJCOMP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_VJC_UNCOMP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_VJUNCOMP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_COMPRESS
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableCompression
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_COMPD
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_ENCRYPT
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_CRYPTD
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_BYPASS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|linkNum
operator|=
name|ntohs
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
comment|/* Upwards flowing data */
case|case
name|HOOK_INDEX_VJC_IP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
case|case
name|HOOK_INDEX_DECOMPRESS
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
case|case
name|HOOK_INDEX_DECRYPT
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"%s: bogus index 0x%x"
operator|,
name|__FUNCTION__
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now figure out what to do with the frame */
switch|switch
condition|(
name|index
condition|)
block|{
case|case
name|HOOK_INDEX_INET
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
block|{
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_ATALK
case|:
case|case
name|HOOK_INDEX_IPX
case|:
case|case
name|HOOK_INDEX_VJC_COMP
case|:
case|case
name|HOOK_INDEX_VJC_UNCOMP
case|:
case|case
name|HOOK_INDEX_VJC_VJIP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableCompression
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_COMPRESS
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_ENCRYPT
case|:
case|case
name|HOOK_INDEX_BYPASS
case|:
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|||
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|enableProtoComp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
return|return
name|ng_ppp_output
argument_list|(
name|node
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
comment|/* Incoming data */
case|case
name|HOOK_INDEX_DECRYPT
case|:
case|case
name|HOOK_INDEX_DECOMPRESS
case|:
case|case
name|HOOK_INDEX_VJC_IP
case|:
return|return
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
block|}
comment|/* Send packet out hook */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|outHook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy node  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rmnode
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
comment|/* Take down netgraph node */
name|node
operator|->
name|flags
operator||=
name|NG_INVALID
expr_stmt|;
name|ng_cutlinks
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_unname
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
name|node
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
name|ng_unref
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* let the node escape */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
if|if
condition|(
name|hook
operator|->
name|node
operator|->
name|numhooks
operator|==
literal|0
condition|)
name|ng_rmnode
argument_list|(
name|hook
operator|->
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			HELPER STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Handle an incoming frame.  Extract the PPP protocol number  * and dispatch accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|error
decl_stmt|;
comment|/* Extract protocol number */
for|for
control|(
name|proto
operator|=
literal|0
init|;
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|1
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|proto
operator|=
operator|(
name|proto
operator|<<
literal|8
operator|)
operator|+
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Check protocol */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PROT_COMPD
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECOMPRESS
index|]
expr_stmt|;
break|break;
case|case
name|PROT_CRYPTD
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECRYPT
index|]
expr_stmt|;
break|break;
case|case
name|PROT_VJCOMP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
expr_stmt|;
break|break;
case|case
name|PROT_VJUNCOMP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
expr_stmt|;
break|break;
case|case
name|PROT_MP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
name|ng_ppp_mp_input
argument_list|(
name|node
argument_list|,
name|linkNum
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
block|}
break|break;
case|case
name|PROT_APPLETALK
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ATALK
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IPX
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_IPX
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_INET
index|]
expr_stmt|;
break|break;
block|}
comment|/* For unknown/inactive protocols, forward out the bypass hook */
if|if
condition|(
name|outHook
operator|==
name|NULL
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|4
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|linkNum
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_BYPASS
index|]
expr_stmt|;
block|}
comment|/* Forward frame */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|outHook
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver a frame out a link, either a real one or NG_PPP_BUNDLE_LINKNUM  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Check for bundle virtual link */
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
condition|)
return|return
name|ng_ppp_mp_output
argument_list|(
name|node
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
name|linkNum
operator|=
name|priv
operator|->
name|activeLinks
index|[
literal|0
index|]
expr_stmt|;
block|}
comment|/* Check link status */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|enableLink
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Deliver frame */
name|NG_SEND_DATA
argument_list|(
name|error
argument_list|,
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
comment|/* Update stats and 'bytes in queue' counter */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|priv
operator|->
name|qstat
index|[
name|linkNum
index|]
operator|.
name|bytesInQueue
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|priv
operator|->
name|qstat
index|[
name|linkNum
index|]
operator|.
name|lastWrite
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an incoming multi-link fragment  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_ppp_frag
name|frag0
decl_stmt|,
modifier|*
name|frag
init|=
operator|&
name|frag0
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|first
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|int
name|diff
decl_stmt|,
name|highSeq
decl_stmt|,
name|nextSeq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tail
decl_stmt|;
comment|/* Extract fragment information from MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
condition|)
block|{
name|u_int16_t
name|shdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|2
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|shdr
operator|=
name|ntohs
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|shdr
operator|&
name|MP_SHORT_SEQ_MASK
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|highSeq
operator|=
name|CIRCLEQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|?
name|frag
operator|->
name|seq
else|:
name|CIRCLEQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|->
name|seq
expr_stmt|;
name|diff
operator|=
name|MP_SHORT_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|highSeq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|lhdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|lhdr
operator|=
name|ntohl
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|lhdr
operator|&
name|MP_LONG_SEQ_MASK
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|highSeq
operator|=
name|CIRCLEQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|?
name|frag
operator|->
name|seq
else|:
name|CIRCLEQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|->
name|seq
expr_stmt|;
name|diff
operator|=
name|MP_LONG_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|highSeq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|frag
operator|->
name|meta
operator|=
name|meta
expr_stmt|;
comment|/* If the sequence number makes a large jump, empty the queue */
if|if
condition|(
name|diff
operator|<=
operator|-
name|MP_INSANE_SEQ_JUMP
operator|||
name|diff
operator|>=
name|MP_INSANE_SEQ_JUMP
condition|)
name|ng_ppp_free_frags
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Optimization: handle a frame that's all in one fragment */
if|if
condition|(
name|frag
operator|->
name|first
operator|&&
name|frag
operator|->
name|last
condition|)
return|return
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
comment|/* Allocate a new frag struct for the queue */
name|MALLOC
argument_list|(
name|frag
argument_list|,
expr|struct
name|ng_ppp_frag
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|frag
operator|=
name|frag0
expr_stmt|;
name|meta
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* Add fragment to queue, which is reverse sorted by sequence number */
name|CIRCLEQ_FOREACH
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|f_qent
argument_list|)
block|{
name|diff
operator|=
name|MP_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|CIRCLEQ_INSERT_BEFORE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
comment|/* should never happen! */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: rec'd dup MP fragment\n"
argument_list|,
name|node
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|priv
operator|->
name|linkStats
index|[
name|linkNum
index|]
operator|.
name|dupFragments
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|bundleStats
operator|.
name|dupFragments
operator|++
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|frag
operator|->
name|data
argument_list|,
name|frag
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|frag
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|qent
operator|==
name|NULL
condition|)
name|CIRCLEQ_INSERT_TAIL
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
comment|/* Find the first fragment in the possibly newly completed frame */
for|for
control|(
name|nextSeq
operator|=
name|frag
operator|->
name|seq
operator|,
name|qent
operator|=
name|frag
init|;
name|qent
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
operator|->
name|frags
condition|;
name|qent
operator|=
name|CIRCLEQ_PREV
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
control|)
block|{
if|if
condition|(
name|qent
operator|->
name|seq
operator|!=
name|nextSeq
condition|)
goto|goto
name|pruneQueue
goto|;
if|if
condition|(
name|qent
operator|->
name|first
condition|)
block|{
name|first
operator|=
name|qent
expr_stmt|;
break|break;
block|}
name|nextSeq
operator|=
operator|(
name|nextSeq
operator|+
literal|1
operator|)
operator|&
name|MP_SEQ_MASK
expr_stmt|;
block|}
comment|/* Find the last fragment in the possibly newly completed frame */
for|for
control|(
name|nextSeq
operator|=
name|frag
operator|->
name|seq
operator|,
name|qent
operator|=
name|frag
init|;
name|qent
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
operator|->
name|frags
condition|;
name|qent
operator|=
name|CIRCLEQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
control|)
block|{
if|if
condition|(
name|qent
operator|->
name|seq
operator|!=
name|nextSeq
condition|)
goto|goto
name|pruneQueue
goto|;
if|if
condition|(
name|qent
operator|->
name|last
condition|)
block|{
name|last
operator|=
name|qent
expr_stmt|;
break|break;
block|}
name|nextSeq
operator|=
operator|(
name|nextSeq
operator|-
literal|1
operator|)
operator|&
name|MP_SEQ_MASK
expr_stmt|;
block|}
comment|/* We have a complete frame, extract it from the queue */
for|for
control|(
name|tail
operator|=
name|NULL
operator|,
name|qent
operator|=
name|first
init|;
name|qent
operator|!=
name|NULL
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
name|qnext
operator|=
name|CIRCLEQ_PREV
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|tail
operator|=
name|m
operator|=
name|qent
operator|->
name|data
expr_stmt|;
name|meta
operator|=
name|qent
operator|->
name|meta
expr_stmt|;
comment|/* inherit first frag's meta */
block|}
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|qent
operator|->
name|data
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tail
operator|->
name|m_next
operator|=
name|qent
operator|->
name|data
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
comment|/* drop other frag's metas */
block|}
while|while
condition|(
name|tail
operator|->
name|m_next
operator|!=
name|NULL
condition|)
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|qent
operator|==
name|last
condition|)
name|qnext
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
name|pruneQueue
label|:
comment|/* Prune out stale entries in the queue */
for|for
control|(
name|qent
operator|=
name|CIRCLEQ_LAST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
init|;
name|qent
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
operator|->
name|frags
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
if|if
condition|(
name|MP_SEQ_DIFF
argument_list|(
name|highSeq
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
operator|<=
name|MP_MAX_SEQ_LINGER
condition|)
break|break;
name|qnext
operator|=
name|CIRCLEQ_PREV
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|CIRCLEQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|qent
operator|->
name|data
argument_list|,
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
comment|/* Deliver newly completed frame, if any */
return|return
name|m
condition|?
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver a frame out on the bundle, i.e., figure out how to fragment  * the frame across the individual PPP links and do so.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|distrib
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|firstFragment
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|;
comment|/* At least one link must be active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|0
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Round-robin strategy */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableRoundRobin
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MP_MIN_FRAG_LEN
condition|)
block|{
name|activeLinkNum
operator|=
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|distrib
argument_list|,
name|priv
operator|->
name|numActiveLinks
operator|*
sizeof|sizeof
argument_list|(
name|distrib
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are equivalent (optimize the common case) */
if|if
condition|(
name|priv
operator|->
name|allLinksEqual
condition|)
block|{
specifier|const
name|int
name|fraction
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|priv
operator|->
name|numActiveLinks
decl_stmt|;
name|int
name|i
decl_stmt|,
name|remain
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
name|distrib
index|[
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
index|]
operator|=
name|fraction
expr_stmt|;
name|remain
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|fraction
operator|*
name|priv
operator|->
name|numActiveLinks
operator|)
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|distrib
index|[
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
index|]
operator|++
expr_stmt|;
name|remain
operator|--
expr_stmt|;
block|}
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are not equivalent */
name|ng_ppp_mp_strategy
argument_list|(
name|node
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|distrib
argument_list|)
expr_stmt|;
name|deliver
label|:
comment|/* Update stats */
name|priv
operator|->
name|bundleStats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Send alloted portions of frame out on the link(s) */
for|for
control|(
name|firstFragment
operator|=
literal|1
operator|,
name|activeLinkNum
operator|=
name|priv
operator|->
name|numActiveLinks
operator|-
literal|1
init|;
name|activeLinkNum
operator|>=
literal|0
condition|;
name|activeLinkNum
operator|--
control|)
block|{
specifier|const
name|int
name|linkNum
init|=
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
decl_stmt|;
comment|/* Deliver fragment(s) out the next link */
for|for
control|(
init|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|>
literal|0
condition|;
name|firstFragment
operator|=
literal|0
control|)
block|{
name|int
name|len
decl_stmt|,
name|lastFragment
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|meta_p
name|meta2
decl_stmt|;
comment|/* Calculate fragment length; don't exceed link MTU */
name|len
operator|=
name|distrib
index|[
name|activeLinkNum
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|mru
condition|)
name|len
operator|=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|mru
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|-=
name|len
expr_stmt|;
name|lastFragment
operator|=
operator|(
name|len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
expr_stmt|;
comment|/* Split off next fragment as "m2" */
name|m2
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|lastFragment
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_split
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* Prepend MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|)
block|{
name|u_int16_t
name|shdr
decl_stmt|;
name|M_PREPEND
argument_list|(
name|m2
argument_list|,
literal|2
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
operator|||
operator|(
name|m2
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m2
operator|=
name|m_pullup
argument_list|(
name|m2
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|shdr
operator|=
name|priv
operator|->
name|mpSeqOut
expr_stmt|;
name|priv
operator|->
name|mpSeqOut
operator|=
operator|(
name|priv
operator|->
name|mpSeqOut
operator|+
literal|1
operator|)
operator|%
name|MP_SHORT_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_LAST_FLAG
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m2
argument_list|,
name|u_int16_t
operator|*
argument_list|)
operator|=
name|htons
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|lhdr
decl_stmt|;
name|M_PREPEND
argument_list|(
name|m2
argument_list|,
literal|4
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
operator|||
operator|(
name|m2
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m2
operator|=
name|m_pullup
argument_list|(
name|m2
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|lhdr
operator|=
name|priv
operator|->
name|mpSeqOut
expr_stmt|;
name|priv
operator|->
name|mpSeqOut
operator|=
operator|(
name|priv
operator|->
name|mpSeqOut
operator|+
literal|1
operator|)
operator|%
name|MP_LONG_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_LAST_FLAG
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m2
argument_list|,
name|u_int32_t
operator|*
argument_list|)
operator|=
name|htonl
argument_list|(
name|lhdr
argument_list|)
expr_stmt|;
block|}
comment|/* Add MP protocol number */
name|m2
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|PROT_MP
argument_list|,
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|enableProtoComp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Copy the meta information, if any */
if|if
condition|(
name|meta
operator|!=
name|NULL
operator|&&
operator|!
name|lastFragment
condition|)
block|{
name|MALLOC
argument_list|(
name|meta2
argument_list|,
name|meta_p
argument_list|,
name|meta
operator|->
name|used_len
argument_list|,
name|M_NETGRAPH
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|meta2
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|meta2
operator|->
name|allocated_len
operator|=
name|meta
operator|->
name|used_len
expr_stmt|;
name|bcopy
argument_list|(
name|meta
argument_list|,
name|meta2
argument_list|,
name|meta
operator|->
name|used_len
argument_list|)
expr_stmt|;
block|}
else|else
name|meta2
operator|=
name|meta
expr_stmt|;
comment|/* Send fragment */
name|error
operator|=
name|ng_ppp_output
argument_list|(
name|node
argument_list|,
name|linkNum
argument_list|,
name|m2
argument_list|,
name|meta2
argument_list|)
expr_stmt|;
comment|/* Abort for error */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|NG_FREE_DATA
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Computing the optimal fragmentation  * -----------------------------------  *  * This routine tries to compute the optimal fragmentation pattern based  * on each link's latency, bandwidth, and calculated additional latency.  * The latter quantity is the additional latency caused by previously  * written data that has not been transmitted yet.  *  * This algorithm is only useful when not all of the links have the  * same latency and bandwidth values.  *  * The essential idea is to make the last bit of each fragment of the  * frame arrive at the opposite end at the exact same time. This greedy  * algorithm is optimal, in that no other scheduling could result in any  * packet arriving any sooner unless packets are delivered out of order.  *  * Suppose link i has bandwidth b_i (in tens of bytes per milisecond) and  * latency l_i (in miliseconds). Consider the function function f_i(t)  * which is equal to the number of bytes that will have arrived at  * the peer after t miliseconds if we start writing continuously at  * time t = 0. Then f_i(t) = b_i * (t - l_i) = ((b_i * t) - (l_i * b_i).  * That is, f_i(t) is a line with slope b_i and y-intersect -(l_i * b_i).  * Note that the y-intersect is always<= zero because latency can't be  * negative.  Note also that really the function is f_i(t) except when  * f_i(t) is negative, in which case the function is zero.  To take  * care of this, let Q_i(t) = { if (f_i(t)> 0) return 1; else return 0; }.  * So the actual number of bytes that will have arrived at the peer after  * t miliseconds is f_i(t) * Q_i(t).  *  * At any given time, each link has some additional latency a_i>= 0  * due to previously written fragment(s) which are still in the queue.  * This value is easily computed from the time since last transmission,  * the previous latency value, the number of bytes written, and the  * link's bandwidth.  *  * Assume that l_i includes any a_i already, and that the links are  * sorted by latency, so that l_i<= l_{i+1}.  *  * Let N be the total number of bytes in the current frame we are sending.  *  * Suppose we were to start writing bytes at time t = 0 on all links  * simultaneously, which is the most we can possibly do.  Then let  * F(t) be equal to the total number of bytes received by the peer  * after t miliseconds. Then F(t) = Sum_i (f_i(t) * Q_i(t)).  *  * Our goal is simply this: fragment the frame across the links such  * that the peer is able to reconstruct the completed frame as soon as  * possible, i.e., at the least possible value of t. Call this value t_0.  *  * Then it follows that F(t_0) = N. Our strategy is first to find the value  * of t_0, and then deduce how many bytes to write to each link.  *  * Rewriting F(t_0):  *  *   t_0 = ( N + Sum_i ( l_i * b_i * Q_i(t_0) ) ) / Sum_i ( b_i * Q_i(t_0) )  *  * Now, we note that Q_i(t) is constant for l_i<= t<= l_{i+1}. t_0 will  * lie in one of these ranges.  To find it, we just need to find the i such  * that F(l_i)<= N<= F(l_{i+1}).  Then we compute all the constant values  * for Q_i() in this range, plug in the remaining values, solving for t_0.  *  * Once t_0 is known, then the number of bytes to send on link i is  * just f_i(t_0) * Q_i(t_0).  *  * In other words, we start allocating bytes to the links one at a time.  * We keep adding links until the frame is completely sent.  Some links  * may not get any bytes because their latency is too high.  *  * Is all this work really worth the trouble?  Depends on the situation.  * The bigger the ratio of computer speed to link speed, and the more  * important total bundle latency is (e.g., for interactive response time),  * the more it's worth it.  There is however the cost of calling this  * function for every frame.  The running time is O(n^2) where n is the  * number of links that receive a non-zero number of bytes.  *  * Since latency is measured in miliseconds, the "resolution" of this  * algorithm is one milisecond.  *  * To avoid this algorithm altogether, configure all links to have the  * same latency and bandwidth.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|latency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|sortByLatency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|,
name|linkNum
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|total
decl_stmt|,
name|topSum
decl_stmt|,
name|botSum
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numFragments
decl_stmt|;
comment|/* If only one link, this gets real easy */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|1
condition|)
block|{
name|distrib
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
return|return;
block|}
comment|/* Get current time */
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Compute latencies for each link at this point in time */
for|for
control|(
name|activeLinkNum
operator|=
literal|0
init|;
name|activeLinkNum
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|activeLinkNum
operator|++
control|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|int
name|xmitBytes
decl_stmt|;
comment|/* Start with base latency value */
name|linkNum
operator|=
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
expr_stmt|;
name|latency
index|[
name|activeLinkNum
index|]
operator|=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|latency
expr_stmt|;
name|sortByLatency
index|[
name|activeLinkNum
index|]
operator|=
name|activeLinkNum
expr_stmt|;
comment|/* see below */
comment|/* Any additional latency? */
if|if
condition|(
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|==
literal|0
condition|)
continue|continue;
comment|/* Compute time delta since last write */
name|diff
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|lastWrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|diff
operator|.
name|tv_sec
operator|>=
literal|10
condition|)
block|{
comment|/* sanity */
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* How many bytes could have transmitted since last write? */
name|xmitBytes
operator|=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|bandwidth
operator|*
name|diff
operator|.
name|tv_sec
operator|+
operator|(
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|bandwidth
operator|*
operator|(
name|diff
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|)
operator|/
literal|100
expr_stmt|;
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|-=
name|xmitBytes
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|<
literal|0
condition|)
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
else|else
name|latency
index|[
name|activeLinkNum
index|]
operator|+=
operator|(
literal|100
operator|*
name|priv
operator|->
name|qstat
index|[
name|activeLinkNum
index|]
operator|.
name|bytesInQueue
operator|)
operator|/
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|linkNum
index|]
operator|.
name|bandwidth
expr_stmt|;
block|}
comment|/* Sort links by latency */
name|compareLatencies
operator|=
name|latency
expr_stmt|;
name|qsort
argument_list|(
name|sortByLatency
argument_list|,
name|priv
operator|->
name|numActiveLinks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sortByLatency
argument_list|)
argument_list|,
name|ng_ppp_intcmp
argument_list|)
expr_stmt|;
name|compareLatencies
operator|=
name|NULL
expr_stmt|;
comment|/* Find the interval we need (add links in sortByLatency[] order) */
for|for
control|(
name|numFragments
operator|=
literal|1
init|;
name|numFragments
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|numFragments
operator|++
control|)
block|{
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flowTime
decl_stmt|;
name|flowTime
operator|=
name|latency
index|[
name|sortByLatency
index|[
name|numFragments
index|]
index|]
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
name|total
operator|+=
operator|(
operator|(
name|flowTime
operator|*
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|bandwidth
operator|)
operator|+
literal|99
operator|)
operator|/
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|>=
name|len
condition|)
break|break;
block|}
comment|/* Solve for t_0 in that interval */
for|for
control|(
name|topSum
operator|=
name|botSum
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|bandwidth
decl_stmt|;
name|topSum
operator|+=
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|*
name|bw
expr_stmt|;
comment|/* / 100 */
name|botSum
operator|+=
name|bw
expr_stmt|;
comment|/* / 100 */
block|}
name|t0
operator|=
operator|(
operator|(
name|len
operator|*
literal|100
operator|)
operator|+
name|topSum
operator|+
name|botSum
operator|/
literal|2
operator|)
operator|/
name|botSum
expr_stmt|;
comment|/* Compute f_i(t_0) all i */
name|bzero
argument_list|(
name|distrib
argument_list|,
name|priv
operator|->
name|numActiveLinks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|distrib
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|bandwidth
decl_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|=
operator|(
name|bw
operator|*
operator|(
name|t0
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|total
operator|+=
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* Deal with any rounding error */
if|if
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|int
name|fast
init|=
literal|0
decl_stmt|;
comment|/* Find the fastest link */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|bandwidth
operator|>
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|fast
index|]
index|]
index|]
operator|.
name|bandwidth
condition|)
name|fast
operator|=
name|i
expr_stmt|;
block|}
name|distrib
index|[
name|sortByLatency
index|[
name|fast
index|]
index|]
operator|+=
name|len
operator|-
name|total
expr_stmt|;
block|}
else|else
while|while
condition|(
name|total
operator|>
name|len
condition|)
block|{
name|int
name|delta
decl_stmt|,
name|slow
init|=
literal|0
decl_stmt|;
comment|/* Find the slowest link that still has bytes to remove */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|>
literal|0
operator|&&
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|bandwidth
operator|<
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
index|]
operator|.
name|bandwidth
operator|)
condition|)
name|slow
operator|=
name|i
expr_stmt|;
block|}
name|delta
operator|=
name|total
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
condition|)
name|delta
operator|=
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
expr_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|-=
name|delta
expr_stmt|;
name|total
operator|-=
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two integers  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|int
name|index1
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v1
operator|)
decl_stmt|;
specifier|const
name|int
name|index2
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v2
operator|)
decl_stmt|;
return|return
name|compareLatencies
index|[
name|index1
index|]
operator|-
name|compareLatencies
index|[
name|index2
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend a possibly compressed PPP protocol number in front of a frame  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
block|{
name|int
name|psize
init|=
operator|(
name|PROT_COMPRESSIBLE
argument_list|(
name|proto
argument_list|)
operator|&&
name|compOK
operator|)
condition|?
literal|1
else|:
literal|2
decl_stmt|;
comment|/* Add protocol number */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|psize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
name|psize
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|psize
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|psize
operator|==
literal|1
condition|)
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
operator|(
name|u_char
operator|)
name|proto
expr_stmt|;
else|else
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update private information that is derived from other private information  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update active status for VJ Compression */
name|priv
operator|->
name|vjCompHooked
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_VJIP
index|]
operator|!=
name|NULL
expr_stmt|;
comment|/* Increase latency for each link an amount equal to one MP header */
if|if
condition|(
name|newConf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hdrBytes
decl_stmt|;
name|hdrBytes
operator|=
operator|(
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|enableProtoComp
condition|?
literal|1
else|:
literal|2
operator|)
operator|+
operator|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|+=
operator|(
operator|(
name|hdrBytes
operator|*
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
block|}
block|}
comment|/* Update list of active links */
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|activeLinks
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|activeLinks
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numActiveLinks
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|allLinksEqual
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|enableLink
operator|&&
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|priv
operator|->
name|activeLinks
index|[
name|priv
operator|->
name|numActiveLinks
operator|++
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|!=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
literal|0
index|]
operator|.
name|latency
operator|||
name|priv
operator|->
name|conf
operator|.
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|!=
name|priv
operator|->
name|conf
operator|.
name|links
index|[
literal|0
index|]
operator|.
name|bandwidth
condition|)
name|priv
operator|->
name|allLinksEqual
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Reset MP state if no longer active */
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|||
name|priv
operator|->
name|numActiveLinks
operator|==
literal|0
condition|)
block|{
name|ng_ppp_free_frags
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|priv
operator|->
name|mpSeqOut
operator|=
name|MP_INITIAL_SEQ
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|qstat
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|qstat
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Determine if a new configuration would represent a valid change  * from the current configuration and link activity status.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_config
modifier|*
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newNumLinksActive
decl_stmt|;
comment|/* Check per-link config and count how many links would be active */
for|for
control|(
name|newNumLinksActive
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|mru
operator|<
name|MP_MIN_LINK_MRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|>
name|NG_PPP_MAX_BANDWIDTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|>
name|NG_PPP_MAX_LATENCY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|enableLink
operator|&&
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|newNumLinksActive
operator|++
expr_stmt|;
block|}
comment|/* Check bundle parameters */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|newConf
operator|->
name|mrru
operator|<
name|MP_MIN_MRRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* At most one link can be active unless multi-link is enabled */
if|if
condition|(
operator|!
name|newConf
operator|->
name|enableMultilink
operator|&&
name|newNumLinksActive
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Disallow changes to multi-link configuration while MP is active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|>
literal|0
operator|&&
name|newNumLinksActive
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|!=
operator|!
name|newConf
operator|->
name|enableMultilink
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|xmitShortSeq
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|recvShortSeq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Configuration change is valid */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all entries in the fragment queue  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_free_frags
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|node
operator|->
name|private
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|qent
operator|=
name|CIRCLEQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
init|;
name|qent
operator|!=
operator|(
name|void
operator|*
operator|)
operator|&
name|priv
operator|->
name|frags
condition|;
name|qent
operator|=
name|next
control|)
block|{
name|next
operator|=
name|CIRCLEQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_DATA
argument_list|(
name|qent
operator|->
name|data
argument_list|,
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH
argument_list|)
expr_stmt|;
block|}
name|CIRCLEQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

