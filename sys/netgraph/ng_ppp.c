begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ng_ppp.c  *  * Copyright (c) 1996-2000 Whistle Communications, Inc.  * All rights reserved.  *   * Subject to the following obligations and disclaimer of warranty, use and  * redistribution of this software, in source or object code forms, with or  * without modifications are expressly permitted by Whistle Communications;  * provided, however, that:  * 1. Any and all reproductions of the source or object code must include the  *    copyright notice above and the following disclaimer of warranties; and  * 2. No rights are granted, in any manner or form, to use Whistle  *    Communications, Inc. trademarks, including the mark "WHISTLE  *    COMMUNICATIONS" on advertising, endorsements, or otherwise except as  *    such appears in the above copyright notice or in the software.  *   * THIS SOFTWARE IS BEING PROVIDED BY WHISTLE COMMUNICATIONS "AS IS", AND  * TO THE MAXIMUM EXTENT PERMITTED BY LAW, WHISTLE COMMUNICATIONS MAKES NO  * REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, REGARDING THIS SOFTWARE,  * INCLUDING WITHOUT LIMITATION, ANY AND ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, OR NON-INFRINGEMENT.  * WHISTLE COMMUNICATIONS DOES NOT WARRANT, GUARANTEE, OR MAKE ANY  * REPRESENTATIONS REGARDING THE USE OF, OR THE RESULTS OF THE USE OF THIS  * SOFTWARE IN TERMS OF ITS CORRECTNESS, ACCURACY, RELIABILITY OR OTHERWISE.  * IN NO EVENT SHALL WHISTLE COMMUNICATIONS BE LIABLE FOR ANY DAMAGES  * RESULTING FROM OR ARISING OUT OF ANY USE OF THIS SOFTWARE, INCLUDING  * WITHOUT LIMITATION, ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,  * PUNITIVE, OR CONSEQUENTIAL DAMAGES, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES, LOSS OF USE, DATA OR PROFITS, HOWEVER CAUSED AND UNDER ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF WHISTLE COMMUNICATIONS IS ADVISED OF THE POSSIBILITY  * OF SUCH DAMAGE.  *  * Author: Archie Cobbs<archie@freebsd.org>  *  * $FreeBSD$  * $Whistle: ng_ppp.c,v 1.24 1999/11/01 09:24:52 julian Exp $  */
end_comment

begin_comment
comment|/*  * PPP node type.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_message.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/netgraph.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_parse.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_ppp.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/ng_vjc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NG_SEPARATE_MALLOC
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NETGRAPH_PPP
argument_list|,
literal|"netgraph_ppp"
argument_list|,
literal|"netgraph ppp node"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|M_NETGRAPH_PPP
value|M_NETGRAPH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROT_VALID
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0x0101) == 0x0001)
end_define

begin_define
define|#
directive|define
name|PROT_COMPRESSABLE
parameter_list|(
name|p
parameter_list|)
value|(((p)& 0xff00) == 0x0000)
end_define

begin_comment
comment|/* Some PPP protocol numbers we're interested in */
end_comment

begin_define
define|#
directive|define
name|PROT_APPLETALK
value|0x0029
end_define

begin_define
define|#
directive|define
name|PROT_COMPD
value|0x00fd
end_define

begin_define
define|#
directive|define
name|PROT_CRYPTD
value|0x0053
end_define

begin_define
define|#
directive|define
name|PROT_IP
value|0x0021
end_define

begin_define
define|#
directive|define
name|PROT_IPV6
value|0x0057
end_define

begin_define
define|#
directive|define
name|PROT_IPX
value|0x002b
end_define

begin_define
define|#
directive|define
name|PROT_LCP
value|0xc021
end_define

begin_define
define|#
directive|define
name|PROT_MP
value|0x003d
end_define

begin_define
define|#
directive|define
name|PROT_VJCOMP
value|0x002d
end_define

begin_define
define|#
directive|define
name|PROT_VJUNCOMP
value|0x002f
end_define

begin_comment
comment|/* Multilink PPP definitions */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_MRRU
value|1500
end_define

begin_comment
comment|/* per RFC 1990 */
end_comment

begin_define
define|#
directive|define
name|MP_INITIAL_SEQ
value|0
end_define

begin_comment
comment|/* per RFC 1990 */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_LINK_MRU
value|32
end_define

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_MASK
value|0x00000fff
end_define

begin_comment
comment|/* short seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_HIBIT
value|0x00000800
end_define

begin_comment
comment|/* short seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_FIRST_FLAG
value|0x00008000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_LAST_FLAG
value|0x00004000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_MASK
value|0x00ffffff
end_define

begin_comment
comment|/* long seq # mask */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_SEQ_HIBIT
value|0x00800000
end_define

begin_comment
comment|/* long seq # high bit */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_FIRST_FLAG
value|0x80000000
end_define

begin_comment
comment|/* first fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_LONG_LAST_FLAG
value|0x40000000
end_define

begin_comment
comment|/* last fragment in frame */
end_comment

begin_define
define|#
directive|define
name|MP_NOSEQ
value|0x7fffffff
end_define

begin_comment
comment|/* impossible sequence number */
end_comment

begin_comment
comment|/* Sign extension of MP sequence numbers */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_SHORT_SEQ_HIBIT) ?		\ 				    ((s) | ~MP_SHORT_SEQ_MASK)		\ 				    : ((s)& MP_SHORT_SEQ_MASK))
end_define

begin_define
define|#
directive|define
name|MP_LONG_EXTEND
parameter_list|(
name|s
parameter_list|)
value|(((s)& MP_LONG_SEQ_HIBIT) ?		\ 				    ((s) | ~MP_LONG_SEQ_MASK)		\ 				    : ((s)& MP_LONG_SEQ_MASK))
end_define

begin_comment
comment|/* Comparision of MP sequence numbers. Note: all sequence numbers    except priv->xseq are stored with the sign bit extended. */
end_comment

begin_define
define|#
directive|define
name|MP_SHORT_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|MP_SHORT_EXTEND((x) - (y))
end_define

begin_define
define|#
directive|define
name|MP_LONG_SEQ_DIFF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|MP_LONG_EXTEND((x) - (y))
end_define

begin_define
define|#
directive|define
name|MP_RECV_SEQ_DIFF
parameter_list|(
name|priv
parameter_list|,
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|((priv)->conf.recvShortSeq ?		\ 				    MP_SHORT_SEQ_DIFF((x), (y)) :	\ 				    MP_LONG_SEQ_DIFF((x), (y)))
end_define

begin_comment
comment|/* Increment receive sequence number */
end_comment

begin_define
define|#
directive|define
name|MP_NEXT_RECV_SEQ
parameter_list|(
name|priv
parameter_list|,
name|seq
parameter_list|)
define|\
value|((priv)->conf.recvShortSeq ?		\ 				    MP_SHORT_EXTEND((seq) + 1) :	\ 				    MP_LONG_EXTEND((seq) + 1))
end_define

begin_comment
comment|/* Don't fragment transmitted packets smaller than this */
end_comment

begin_define
define|#
directive|define
name|MP_MIN_FRAG_LEN
value|6
end_define

begin_comment
comment|/* Maximum fragment reasssembly queue length */
end_comment

begin_define
define|#
directive|define
name|MP_MAX_QUEUE_LEN
value|128
end_define

begin_comment
comment|/* Fragment queue scanner period */
end_comment

begin_define
define|#
directive|define
name|MP_FRAGTIMER_INTERVAL
value|(hz/2)
end_define

begin_comment
comment|/* We store incoming fragments this way */
end_comment

begin_struct
struct|struct
name|ng_ppp_frag
block|{
name|int
name|seq
decl_stmt|;
comment|/* fragment seq# */
name|u_char
name|first
decl_stmt|;
comment|/* First in packet? */
name|u_char
name|last
decl_stmt|;
comment|/* Last in packet? */
name|struct
name|timeval
name|timestamp
decl_stmt|;
comment|/* time of reception */
name|struct
name|mbuf
modifier|*
name|data
decl_stmt|;
comment|/* Fragment data */
name|meta_p
name|meta
decl_stmt|;
comment|/* Fragment meta */
name|TAILQ_ENTRY
argument_list|(
argument|ng_ppp_frag
argument_list|)
name|f_qent
expr_stmt|;
comment|/* Fragment queue */
block|}
struct|;
end_struct

begin_comment
comment|/* We use integer indicies to refer to the non-link hooks */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|ng_ppp_hook_names
index|[]
init|=
block|{
name|NG_PPP_HOOK_ATALK
block|,
define|#
directive|define
name|HOOK_INDEX_ATALK
value|0
name|NG_PPP_HOOK_BYPASS
block|,
define|#
directive|define
name|HOOK_INDEX_BYPASS
value|1
name|NG_PPP_HOOK_COMPRESS
block|,
define|#
directive|define
name|HOOK_INDEX_COMPRESS
value|2
name|NG_PPP_HOOK_ENCRYPT
block|,
define|#
directive|define
name|HOOK_INDEX_ENCRYPT
value|3
name|NG_PPP_HOOK_DECOMPRESS
block|,
define|#
directive|define
name|HOOK_INDEX_DECOMPRESS
value|4
name|NG_PPP_HOOK_DECRYPT
block|,
define|#
directive|define
name|HOOK_INDEX_DECRYPT
value|5
name|NG_PPP_HOOK_INET
block|,
define|#
directive|define
name|HOOK_INDEX_INET
value|6
name|NG_PPP_HOOK_IPX
block|,
define|#
directive|define
name|HOOK_INDEX_IPX
value|7
name|NG_PPP_HOOK_VJC_COMP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_COMP
value|8
name|NG_PPP_HOOK_VJC_IP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_IP
value|9
name|NG_PPP_HOOK_VJC_UNCOMP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_UNCOMP
value|10
name|NG_PPP_HOOK_VJC_VJIP
block|,
define|#
directive|define
name|HOOK_INDEX_VJC_VJIP
value|11
name|NG_PPP_HOOK_IPV6
block|,
define|#
directive|define
name|HOOK_INDEX_IPV6
value|12
name|NULL
define|#
directive|define
name|HOOK_INDEX_MAX
value|13
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We store index numbers in the hook private pointer. The HOOK_INDEX()    for a hook is either the index (above) for normal hooks, or the ones    complement of the link number for link hooks. XXX Not any more.. (what a hack) #define HOOK_INDEX(hook)	(*((int16_t *)&(hook)->private)) */
end_comment

begin_comment
comment|/* Per-link private information */
end_comment

begin_struct
struct|struct
name|ng_ppp_link
block|{
name|struct
name|ng_ppp_link_conf
name|conf
decl_stmt|;
comment|/* link configuration */
name|hook_p
name|hook
decl_stmt|;
comment|/* connection to link data */
name|int32_t
name|seq
decl_stmt|;
comment|/* highest rec'd seq# - MSEQ */
name|struct
name|timeval
name|lastWrite
decl_stmt|;
comment|/* time of last write */
name|int
name|bytesInQueue
decl_stmt|;
comment|/* bytes in the output queue */
name|struct
name|ng_ppp_link_stat
name|stats
decl_stmt|;
comment|/* Link stats */
block|}
struct|;
end_struct

begin_comment
comment|/* Total per-node private information */
end_comment

begin_struct
struct|struct
name|ng_ppp_private
block|{
name|struct
name|ng_ppp_bund_conf
name|conf
decl_stmt|;
comment|/* bundle config */
name|struct
name|ng_ppp_link_stat
name|bundleStats
decl_stmt|;
comment|/* bundle stats */
name|struct
name|ng_ppp_link
name|links
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
comment|/* per-link info */
name|int32_t
name|xseq
decl_stmt|;
comment|/* next out MP seq # */
name|int32_t
name|mseq
decl_stmt|;
comment|/* min links[i].seq */
name|u_char
name|vjCompHooked
decl_stmt|;
comment|/* VJ comp hooked up? */
name|u_char
name|allLinksEqual
decl_stmt|;
comment|/* all xmit the same? */
name|u_char
name|timerActive
decl_stmt|;
comment|/* frag timer active? */
name|u_int
name|numActiveLinks
decl_stmt|;
comment|/* how many links up */
name|int
name|activeLinks
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
comment|/* indicies */
name|u_int
name|lastLink
decl_stmt|;
comment|/* for round robin */
name|hook_p
name|hooks
index|[
name|HOOK_INDEX_MAX
index|]
decl_stmt|;
comment|/* non-link hooks */
name|TAILQ_HEAD
argument_list|(
argument|ng_ppp_fraglist
argument_list|,
argument|ng_ppp_frag
argument_list|)
comment|/* fragment queue */
name|frags
expr_stmt|;
name|int
name|qlen
decl_stmt|;
comment|/* fraq queue length */
name|struct
name|callout_handle
name|fragTimer
decl_stmt|;
comment|/* fraq queue check */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|ng_ppp_private
modifier|*
name|priv_p
typedef|;
end_typedef

begin_comment
comment|/* Netgraph node methods */
end_comment

begin_decl_stmt
specifier|static
name|ng_constructor_t
name|ng_ppp_constructor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvmsg_t
name|ng_ppp_rcvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_shutdown_t
name|ng_ppp_shutdown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_newhook_t
name|ng_ppp_newhook
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_rcvdata_t
name|ng_ppp_rcvdata
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ng_disconnect_t
name|ng_ppp_disconnect
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Helper functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ng_ppp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|bypass
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|bypass
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_check_packet
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_get_packet
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|meta_p
modifier|*
name|metap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_frag_process
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_frag_trim
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_checkstale
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_frag_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_mp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_conf
modifier|*
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_start_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ng_ppp_stop_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Parse type for struct ng_ppp_mp_state_type */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_ppp_rseq_array_info
init|=
block|{
operator|&
name|ng_parse_hint32_type
block|,
name|NG_PPP_MAX_LINKS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_rseq_array_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_ppp_rseq_array_info
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_mp_state_type_fields
index|[]
init|=
name|NG_PPP_MP_STATE_TYPE_INFO
argument_list|(
operator|&
name|ng_ppp_rseq_array_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_mp_state_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_mp_state_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_link_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_link_type_fields
index|[]
init|=
name|NG_PPP_LINK_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_link_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_link_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_bund_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_bund_type_fields
index|[]
init|=
name|NG_PPP_BUND_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_bund_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_bund_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_node_conf */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_fixedarray_info
name|ng_ppp_array_info
init|=
block|{
operator|&
name|ng_ppp_link_type
block|,
name|NG_PPP_MAX_LINKS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_link_array_type
init|=
block|{
operator|&
name|ng_parse_fixedarray_type
block|,
operator|&
name|ng_ppp_array_info
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_conf_type_fields
index|[]
init|=
name|NG_PPP_CONFIG_TYPE_INFO
argument_list|(
operator|&
name|ng_ppp_bund_type
argument_list|,
operator|&
name|ng_ppp_link_array_type
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_conf_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_conf_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Parse type for struct ng_ppp_link_stat */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_struct_field
name|ng_ppp_stats_type_fields
index|[]
init|=
name|NG_PPP_STATS_TYPE_INFO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_parse_type
name|ng_ppp_stats_type
init|=
block|{
operator|&
name|ng_parse_struct_type
block|,
operator|&
name|ng_ppp_stats_type_fields
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of commands and how to convert arguments to/from ASCII */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ng_cmdlist
name|ng_ppp_cmds
index|[]
init|=
block|{
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_SET_CONFIG
block|,
literal|"setconfig"
block|,
operator|&
name|ng_ppp_conf_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_CONFIG
block|,
literal|"getconfig"
block|,
name|NULL
block|,
operator|&
name|ng_ppp_conf_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_MP_STATE
block|,
literal|"getmpstate"
block|,
name|NULL
block|,
operator|&
name|ng_ppp_mp_state_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GET_LINK_STATS
block|,
literal|"getstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats_type
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_CLR_LINK_STATS
block|,
literal|"clrstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
name|NULL
block|}
block|,
block|{
name|NGM_PPP_COOKIE
block|,
name|NGM_PPP_GETCLR_LINK_STATS
block|,
literal|"getclrstats"
block|,
operator|&
name|ng_parse_int16_type
block|,
operator|&
name|ng_ppp_stats_type
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Node type descriptor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ng_type
name|ng_ppp_typestruct
init|=
block|{
name|NG_ABI_VERSION
block|,
name|NG_PPP_NODE_TYPE
block|,
name|NULL
block|,
name|ng_ppp_constructor
block|,
name|ng_ppp_rcvmsg
block|,
name|ng_ppp_shutdown
block|,
name|ng_ppp_newhook
block|,
name|NULL
block|,
name|NULL
block|,
name|ng_ppp_rcvdata
block|,
name|ng_ppp_disconnect
block|,
name|ng_ppp_cmds
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NETGRAPH_INIT
argument_list|(
name|ppp
argument_list|,
operator|&
name|ng_ppp_typestruct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|compareLatencies
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hack for ng_ppp_intcmp() */
end_comment

begin_comment
comment|/* Address and control field header */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|ng_ppp_acf
index|[
literal|2
index|]
init|=
block|{
literal|0xff
block|,
literal|0x03
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum time we'll let a complete incoming packet sit in the queue */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|timeval
name|ng_ppp_max_staleness
init|=
block|{
literal|2
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 seconds */
end_comment

begin_define
define|#
directive|define
name|ERROUT
parameter_list|(
name|x
parameter_list|)
value|do { error = (x); goto done; } while (0)
end_define

begin_comment
comment|/************************************************************************ 			NETGRAPH NODE STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Node type constructor  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_constructor
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
name|priv_p
name|priv
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Allocate private structure */
name|MALLOC
argument_list|(
name|priv
argument_list|,
name|priv_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|,
name|M_NETGRAPH_PPP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|priv
argument_list|)
expr_stmt|;
comment|/* Initialize state */
name|TAILQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|priv
operator|->
name|fragTimer
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give our OK for a hook to be added  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_newhook
parameter_list|(
name|node_p
name|node
parameter_list|,
name|hook_p
name|hook
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|linkNum
init|=
operator|-
literal|1
decl_stmt|;
name|hook_p
modifier|*
name|hookPtr
init|=
name|NULL
decl_stmt|;
name|int
name|hookIndex
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Figure out which hook it is */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|,
comment|/* a link hook? */
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|eptr
decl_stmt|;
name|cp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|NG_PPP_HOOK_LINK_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
operator|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
name|cp
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|linkNum
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|cp
argument_list|,
operator|&
name|eptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|eptr
operator|!=
literal|'\0'
operator|||
name|linkNum
operator|<
literal|0
operator|||
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|hook
expr_stmt|;
name|hookIndex
operator|=
operator|~
name|linkNum
expr_stmt|;
block|}
else|else
block|{
comment|/* must be a non-link hook */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ng_ppp_hook_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|hookPtr
operator|=
operator|&
name|priv
operator|->
name|hooks
index|[
name|i
index|]
expr_stmt|;
name|hookIndex
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ng_ppp_hook_names
index|[
name|i
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* no such hook */
block|}
comment|/* See if hook is already connected */
if|if
condition|(
operator|*
name|hookPtr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
comment|/* Disallow more than one link unless multilink is enabled */
if|if
condition|(
name|linkNum
operator|!=
operator|-
literal|1
operator|&&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|conf
operator|.
name|enableLink
operator|&&
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|priv
operator|->
name|numActiveLinks
operator|>=
literal|1
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* OK */
operator|*
name|hookPtr
operator|=
name|hook
expr_stmt|;
name|NG_HOOK_SET_PRIVATE
argument_list|(
name|hook
argument_list|,
operator|(
name|void
operator|*
operator|)
name|hookIndex
argument_list|)
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive a control message  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvmsg
parameter_list|(
name|node_p
name|node
parameter_list|,
name|item_p
name|item
parameter_list|,
name|hook_p
name|lasthook
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ng_mesg
modifier|*
name|msg
decl_stmt|;
name|NGI_GET_MSG
argument_list|(
name|item
argument_list|,
name|msg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|typecookie
condition|)
block|{
case|case
name|NGM_PPP_COOKIE
case|:
switch|switch
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
condition|)
block|{
case|case
name|NGM_PPP_SET_CONFIG
case|:
block|{
name|struct
name|ng_ppp_node_conf
modifier|*
specifier|const
name|conf
init|=
operator|(
expr|struct
name|ng_ppp_node_conf
operator|*
operator|)
name|msg
operator|->
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check for invalid or illegal config */
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ng_ppp_config_valid
argument_list|(
name|node
argument_list|,
name|conf
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* Copy config */
name|priv
operator|->
name|conf
operator|=
name|conf
operator|->
name|bund
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|=
name|conf
operator|->
name|links
index|[
name|i
index|]
expr_stmt|;
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_CONFIG
case|:
block|{
name|struct
name|ng_ppp_node_conf
modifier|*
name|conf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conf
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|conf
operator|=
operator|(
expr|struct
name|ng_ppp_node_conf
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|conf
operator|->
name|bund
operator|=
name|priv
operator|->
name|conf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
name|conf
operator|->
name|links
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_MP_STATE
case|:
block|{
name|struct
name|ng_ppp_mp_state
modifier|*
name|info
decl_stmt|;
name|int
name|i
decl_stmt|;
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|info
operator|=
operator|(
expr|struct
name|ng_ppp_mp_state
operator|*
operator|)
name|resp
operator|->
name|data
expr_stmt|;
name|bzero
argument_list|(
name|info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
operator|!=
name|MP_NOSEQ
condition|)
name|info
operator|->
name|rseq
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|seq
expr_stmt|;
block|}
name|info
operator|->
name|mseq
operator|=
name|priv
operator|->
name|mseq
expr_stmt|;
name|info
operator|->
name|xseq
operator|=
name|priv
operator|->
name|xseq
expr_stmt|;
break|break;
block|}
case|case
name|NGM_PPP_GET_LINK_STATS
case|:
case|case
name|NGM_PPP_CLR_LINK_STATS
case|:
case|case
name|NGM_PPP_GETCLR_LINK_STATS
case|:
block|{
name|struct
name|ng_ppp_link_stat
modifier|*
name|stats
decl_stmt|;
name|u_int16_t
name|linkNum
decl_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|arglen
operator|!=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|linkNum
operator|=
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|msg
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|ERROUT
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|stats
operator|=
operator|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|)
condition|?
operator|&
name|priv
operator|->
name|bundleStats
else|:
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|stats
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPP_CLR_LINK_STATS
condition|)
block|{
name|NG_MKRESPONSE
argument_list|(
name|resp
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ng_ppp_link_stat
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|resp
operator|==
name|NULL
condition|)
name|ERROUT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stats
argument_list|,
name|resp
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|->
name|header
operator|.
name|cmd
operator|!=
name|NGM_PPP_GET_LINK_STATS
condition|)
name|bzero
argument_list|(
name|stats
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|NGM_VJC_COOKIE
case|:
block|{
comment|/* 		 * Forward it to the vjc node. leave the  		 * old return address alone. 		 * If we have no hook, let NG_RESPOND_MSG 		 * clean up any remaining resources. 		 * Because we have no resp, the item will be freed 		 * along with anything it references. Don't 		 * let msg be freed twice. 		 */
name|NGI_MSG
argument_list|(
name|item
argument_list|)
operator|=
name|msg
expr_stmt|;
comment|/* put it back in the item */
name|msg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|lasthook
operator|=
name|priv
operator|->
name|links
index|[
name|HOOK_INDEX_VJC_IP
index|]
operator|.
name|hook
operator|)
condition|)
block|{
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|lasthook
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done
label|:
name|NG_RESPOND_MSG
argument_list|(
name|error
argument_list|,
name|node
argument_list|,
name|item
argument_list|,
name|resp
argument_list|)
expr_stmt|;
name|NG_FREE_MSG
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive data on a hook  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_rcvdata
parameter_list|(
name|hook_p
name|hook
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|index
init|=
operator|(
name|int
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
name|u_int16_t
name|linkNum
init|=
name|NG_PPP_BUNDLE_LINKNUM
decl_stmt|;
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
name|int
name|proto
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Did it come from a link hook? */
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|link
decl_stmt|;
comment|/* Convert index into a link number */
name|linkNum
operator|=
operator|(
name|u_int16_t
operator|)
operator|~
name|index
expr_stmt|;
name|KASSERT
argument_list|(
name|linkNum
operator|<
name|NG_PPP_MAX_LINKS
argument_list|,
operator|(
literal|"%s: bogus index 0x%x"
operator|,
name|__func__
operator|,
name|index
operator|)
argument_list|)
expr_stmt|;
name|link
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
expr_stmt|;
comment|/* Stats */
name|link
operator|->
name|stats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Strip address and control fields, if present */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
operator|&
name|ng_ppp_acf
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* Dispatch incoming frame (if not enabled, to bypass) */
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* put changed m back in item */
return|return
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
operator|!
name|link
operator|->
name|conf
operator|.
name|enableLink
argument_list|,
name|linkNum
argument_list|,
name|item
argument_list|)
return|;
block|}
comment|/* Get protocol& check if data allowed from this hook */
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* put possibly changed m back in item */
switch|switch
condition|(
name|index
condition|)
block|{
comment|/* Outgoing data */
case|case
name|HOOK_INDEX_ATALK
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_APPLETALK
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_IPX
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_IPX
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_IPV6
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIPv6
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_IPV6
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_INET
case|:
case|case
name|HOOK_INDEX_VJC_VJIP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_IP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_VJC_COMP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_VJCOMP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_VJC_UNCOMP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_VJUNCOMP
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_COMPRESS
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableCompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_COMPD
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_ENCRYPT
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|proto
operator|=
name|PROT_CRYPTD
expr_stmt|;
break|break;
case|case
name|HOOK_INDEX_BYPASS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* don't free twice */
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* m may have changed */
name|linkNum
operator|=
name|ntohs
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkNum
operator|>=
name|NG_PPP_MAX_LINKS
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
comment|/* Incoming data */
case|case
name|HOOK_INDEX_VJC_IP
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableIP
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
case|case
name|HOOK_INDEX_DECOMPRESS
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
case|case
name|HOOK_INDEX_DECRYPT
case|:
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: bogus index 0x%x"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
comment|/* Now figure out what to do with the frame */
switch|switch
condition|(
name|index
condition|)
block|{
comment|/* Outgoing data */
case|case
name|HOOK_INDEX_INET
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJCompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
block|{
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_ATALK
case|:
case|case
name|HOOK_INDEX_IPV6
case|:
case|case
name|HOOK_INDEX_IPX
case|:
case|case
name|HOOK_INDEX_VJC_COMP
case|:
case|case
name|HOOK_INDEX_VJC_UNCOMP
case|:
case|case
name|HOOK_INDEX_VJC_VJIP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableCompression
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* m may have changed */
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_COMPRESS
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_COMPRESS
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableEncryption
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
comment|/* m may have changed */
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ENCRYPT
index|]
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|HOOK_INDEX_ENCRYPT
case|:
return|return
name|ng_ppp_output
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|proto
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|item
argument_list|)
return|;
case|case
name|HOOK_INDEX_BYPASS
case|:
return|return
name|ng_ppp_output
argument_list|(
name|node
argument_list|,
literal|1
argument_list|,
name|proto
argument_list|,
name|linkNum
argument_list|,
name|item
argument_list|)
return|;
comment|/* Incoming data */
case|case
name|HOOK_INDEX_DECRYPT
case|:
case|case
name|HOOK_INDEX_DECOMPRESS
case|:
return|return
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|item
argument_list|)
return|;
case|case
name|HOOK_INDEX_VJC_IP
case|:
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_INET
index|]
expr_stmt|;
break|break;
block|}
comment|/* Send packet out hook */
name|NG_FWD_ITEM_HOOK
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|outHook
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy node  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_shutdown
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
comment|/* Stop fragment queue timer */
name|ng_ppp_stop_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Take down netgraph node */
name|ng_ppp_frag_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|priv
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|NG_NODE_SET_PRIVATE
argument_list|(
name|node
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* let the node escape */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hook disconnection  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_disconnect
parameter_list|(
name|hook_p
name|hook
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|NG_HOOK_NODE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|index
init|=
operator|(
name|int
operator|)
name|NG_HOOK_PRIVATE
argument_list|(
name|hook
argument_list|)
decl_stmt|;
comment|/* Zero out hook pointer */
if|if
condition|(
name|index
operator|<
literal|0
condition|)
name|priv
operator|->
name|links
index|[
operator|~
name|index
index|]
operator|.
name|hook
operator|=
name|NULL
expr_stmt|;
else|else
name|priv
operator|->
name|hooks
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Update derived info (or go away if no hooks left) */
if|if
condition|(
name|NG_NODE_NUMHOOKS
argument_list|(
name|node
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ng_ppp_update
argument_list|(
name|node
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|NG_NODE_IS_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ng_rmnode_self
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************ 			HELPER STUFF  ************************************************************************/
end_comment

begin_comment
comment|/*  * Handle an incoming frame.  Extract the PPP protocol number  * and dispatch accordingly.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|bypass
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|hook_p
name|outHook
init|=
name|NULL
decl_stmt|;
name|int
name|proto
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Extract protocol number */
for|for
control|(
name|proto
operator|=
literal|0
init|;
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|1
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|proto
operator|=
operator|(
name|proto
operator|<<
literal|8
operator|)
operator|+
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|PROT_VALID
argument_list|(
name|proto
argument_list|)
condition|)
block|{
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
name|priv
operator|->
name|bundleStats
operator|.
name|badProtos
operator|++
expr_stmt|;
else|else
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
operator|.
name|stats
operator|.
name|badProtos
operator|++
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Bypass frame? */
if|if
condition|(
name|bypass
condition|)
goto|goto
name|bypass
goto|;
comment|/* Check protocol */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|PROT_COMPD
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecompression
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECOMPRESS
index|]
expr_stmt|;
break|break;
case|case
name|PROT_CRYPTD
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableDecryption
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_DECRYPT
index|]
expr_stmt|;
break|break;
case|case
name|PROT_VJCOMP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
expr_stmt|;
break|break;
case|case
name|PROT_VJUNCOMP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableVJDecompression
operator|&&
name|priv
operator|->
name|vjCompHooked
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
expr_stmt|;
break|break;
case|case
name|PROT_MP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
block|{
name|NGI_M
argument_list|(
name|item
argument_list|)
operator|=
name|m
expr_stmt|;
return|return
name|ng_ppp_mp_input
argument_list|(
name|node
argument_list|,
name|linkNum
argument_list|,
name|item
argument_list|)
return|;
block|}
break|break;
case|case
name|PROT_APPLETALK
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableAtalk
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_ATALK
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IPX
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIPX
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_IPX
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IP
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIP
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_INET
index|]
expr_stmt|;
break|break;
case|case
name|PROT_IPV6
case|:
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableIPv6
condition|)
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_IPV6
index|]
expr_stmt|;
break|break;
block|}
name|bypass
label|:
comment|/* For unknown/inactive protocols, forward out the bypass hook */
if|if
condition|(
name|outHook
operator|==
name|NULL
condition|)
block|{
name|u_int16_t
name|hdr
index|[
literal|2
index|]
decl_stmt|;
name|hdr
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|linkNum
argument_list|)
expr_stmt|;
name|hdr
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|hdr
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|outHook
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_BYPASS
index|]
expr_stmt|;
block|}
comment|/* Forward frame */
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|outHook
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deliver a frame out a link, either a real one or NG_PPP_BUNDLE_LINKNUM.  * If the link is not enabled then ENXIO is returned, unless "bypass" is != 0.  *  * If the frame is too big for the particular link, return EMSGSIZE.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|bypass
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
name|link
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int16_t
name|mru
decl_stmt|;
comment|/* Extract mbuf */
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* If not doing MP, map bundle virtual link to (the only) link */
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|&&
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
condition|)
name|linkNum
operator|=
name|priv
operator|->
name|activeLinks
index|[
literal|0
index|]
expr_stmt|;
comment|/* Get link pointer (optimization) */
name|link
operator|=
operator|(
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
operator|)
condition|?
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
else|:
name|NULL
expr_stmt|;
comment|/* Check link status (if real) */
if|if
condition|(
name|linkNum
operator|!=
name|NG_PPP_BUNDLE_LINKNUM
condition|)
block|{
if|if
condition|(
operator|!
name|bypass
operator|&&
operator|!
name|link
operator|->
name|conf
operator|.
name|enableLink
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|link
operator|->
name|hook
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
block|}
comment|/* Check peer's MRU for this link */
name|mru
operator|=
operator|(
name|link
operator|!=
name|NULL
operator|)
condition|?
name|link
operator|->
name|conf
operator|.
name|mru
else|:
name|priv
operator|->
name|conf
operator|.
name|mrru
expr_stmt|;
if|if
condition|(
name|mru
operator|!=
literal|0
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|mru
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
comment|/* Prepend protocol number, possibly compressed */
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_addproto
argument_list|(
name|m
argument_list|,
name|proto
argument_list|,
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
operator|||
name|link
operator|->
name|conf
operator|.
name|enableProtoComp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Special handling for the MP virtual link */
if|if
condition|(
name|linkNum
operator|==
name|NG_PPP_BUNDLE_LINKNUM
condition|)
block|{
name|meta_p
name|meta
decl_stmt|;
comment|/* strip off and discard the queue item */
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
name|ng_ppp_mp_output
argument_list|(
name|node
argument_list|,
name|m
argument_list|,
name|meta
argument_list|)
return|;
block|}
comment|/* Prepend address and control field (unless compressed) */
if|if
condition|(
name|proto
operator|==
name|PROT_LCP
operator|||
operator|!
name|link
operator|->
name|conf
operator|.
name|enableACFComp
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|ng_ppp_acf
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* Deliver frame */
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|NG_FWD_NEW_DATA
argument_list|(
name|error
argument_list|,
name|item
argument_list|,
name|link
operator|->
name|hook
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Update stats and 'bytes in queue' counter */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|link
operator|->
name|stats
operator|.
name|xmitOctets
operator|+=
name|len
expr_stmt|;
name|link
operator|->
name|bytesInQueue
operator|+=
name|len
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|link
operator|->
name|lastWrite
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an incoming multi-link fragment  *  * The fragment reassembly algorithm is somewhat complex. This is mainly  * because we are required not to reorder the reconstructed packets, yet  * fragments are only guaranteed to arrive in order on a per-link basis.  * In other words, when we have a complete packet ready, but the previous  * packet is still incomplete, we have to decide between delivering the  * complete packet and throwing away the incomplete one, or waiting to  * see if the remainder of the incomplete one arrives, at which time we  * can deliver both packets, in order.  *  * This problem is exacerbated by "sequence number slew", which is when  * the sequence numbers coming in from different links are far apart from  * each other. In particular, certain unnamed equipment (*cough* Ascend)  * has been seen to generate sequence number slew of up to 10 on an ISDN  * 2B-channel MP link. There is nothing invalid about sequence number slew  * but it makes the reasssembly process have to work harder.  *  * However, the peer is required to transmit fragments in order on each  * link. That means if we define MSEQ as the minimum over all links of  * the highest sequence number received on that link, then we can always  * give up any hope of receiving a fragment with sequence number< MSEQ in  * the future (all of this using 'wraparound' sequence number space).  * Therefore we can always immediately throw away incomplete packets  * missing fragments with sequence numbers< MSEQ.  *  * Here is an overview of our algorithm:  *  *    o Received fragments are inserted into a queue, for which we  *	maintain these invariants between calls to this function:  *  *	- Fragments are ordered in the queue by sequence number  *	- If a complete packet is at the head of the queue, then  *	  the first fragment in the packet has seq#> MSEQ + 1  *	  (otherwise, we could deliver it immediately)  *	- If any fragments have seq#< MSEQ, then they are necessarily  *	  part of a packet whose missing seq#'s are all> MSEQ (otherwise,  *	  we can throw them away because they'll never be completed)  *	- The queue contains at most MP_MAX_QUEUE_LEN fragments  *  *    o We have a periodic timer that checks the queue for the first  *	complete packet that has been sitting in the queue "too long".  *	When one is detected, all previous (incomplete) fragments are  *	discarded, their missing fragments are declared lost and MSEQ  *	is increased.  *  *    o If we recieve a fragment with seq#< MSEQ, we throw it away  *	because we've already delcared it lost.  *  * This assumes linkNum != NG_PPP_BUNDLE_LINKNUM.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_input
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|linkNum
parameter_list|,
name|item_p
name|item
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
name|struct
name|ng_ppp_frag
name|frag0
decl_stmt|,
modifier|*
name|frag
init|=
operator|&
name|frag0
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diff
decl_stmt|,
name|inserted
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|NGI_GET_M
argument_list|(
name|item
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|NGI_GET_META
argument_list|(
name|item
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|NG_FREE_ITEM
argument_list|(
name|item
argument_list|)
expr_stmt|;
comment|/* Stats */
name|priv
operator|->
name|bundleStats
operator|.
name|recvFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|recvOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Extract fragment information from MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
condition|)
block|{
name|u_int16_t
name|shdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|2
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|runts
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|shdr
operator|=
name|ntohs
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|MP_SHORT_EXTEND
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|shdr
operator|&
name|MP_SHORT_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|diff
operator|=
name|MP_SHORT_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|lhdr
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|4
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|runts
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|4
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|lhdr
operator|=
name|ntohl
argument_list|(
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int32_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|frag
operator|->
name|seq
operator|=
name|MP_LONG_EXTEND
argument_list|(
name|lhdr
argument_list|)
expr_stmt|;
name|frag
operator|->
name|first
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_FIRST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|frag
operator|->
name|last
operator|=
operator|(
name|lhdr
operator|&
name|MP_LONG_LAST_FLAG
operator|)
operator|!=
literal|0
expr_stmt|;
name|diff
operator|=
name|MP_LONG_SEQ_DIFF
argument_list|(
name|frag
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|frag
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|frag
operator|->
name|meta
operator|=
name|meta
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|frag
operator|->
name|timestamp
argument_list|)
expr_stmt|;
comment|/* If sequence number is< MSEQ, we've already declared this 	   fragment as lost, so we have no choice now but to drop it */
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
name|link
operator|->
name|stats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Update highest received sequence number on this link and MSEQ */
name|priv
operator|->
name|mseq
operator|=
name|link
operator|->
name|seq
operator|=
name|frag
operator|->
name|seq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|alink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|alink
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|<
literal|0
condition|)
name|priv
operator|->
name|mseq
operator|=
name|alink
operator|->
name|seq
expr_stmt|;
block|}
comment|/* Allocate a new frag struct for the queue */
name|MALLOC
argument_list|(
name|frag
argument_list|,
expr|struct
name|ng_ppp_frag
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frag
argument_list|)
argument_list|,
name|M_NETGRAPH_PPP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|ng_ppp_frag_process
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|frag
operator|=
name|frag0
expr_stmt|;
comment|/* Add fragment to queue, which is sorted by sequence number */
name|inserted
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|ng_ppp_fraglist
argument_list|,
argument|f_qent
argument_list|)
block|{
name|diff
operator|=
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|frag
operator|->
name|seq
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
comment|/* should never happen! */
name|link
operator|->
name|stats
operator|.
name|dupFragments
operator|++
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|frag
operator|->
name|data
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|frag
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|frag
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|inserted
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|frag
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|++
expr_stmt|;
comment|/* Process the queue */
return|return
name|ng_ppp_frag_process
argument_list|(
name|node
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Examine our list of fragments, and determine if there is a  * complete and deliverable packet at the head of the list.  * Return 1 if so, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_check_packet
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
comment|/* Check for empty queue */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check first fragment is the start of a deliverable packet */
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qent
operator|->
name|first
operator|||
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Check that all the fragments are there */
while|while
condition|(
operator|!
name|qent
operator|->
name|last
condition|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|==
name|NULL
condition|)
comment|/* end of queue */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qnext
operator|->
name|seq
operator|!=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|qent
operator|=
name|qnext
expr_stmt|;
block|}
comment|/* Got one */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pull a completed packet off the head of the incoming fragment queue.  * This assumes there is a completed packet there to pull off.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_get_packet
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|meta_p
modifier|*
name|metap
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|&&
name|qent
operator|->
name|first
argument_list|,
operator|(
literal|"%s: no packet"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tail
operator|=
name|NULL
init|;
name|qent
operator|!=
name|NULL
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|tail
operator|=
name|m
operator|=
name|qent
operator|->
name|data
expr_stmt|;
operator|*
name|metap
operator|=
name|qent
operator|->
name|meta
expr_stmt|;
comment|/* inherit first frag's meta */
block|}
else|else
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|qent
operator|->
name|data
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|tail
operator|->
name|m_next
operator|=
name|qent
operator|->
name|data
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
comment|/* drop other frags' metas */
block|}
while|while
condition|(
name|tail
operator|->
name|m_next
operator|!=
name|NULL
condition|)
name|tail
operator|=
name|tail
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|qent
operator|->
name|last
condition|)
name|qnext
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|--
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Trim fragments from the queue whose packets can never be completed.  * This assumes a complete packet is NOT at the beginning of the queue.  * Returns 1 if fragments were removed, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_frag_trim
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
init|=
name|NULL
decl_stmt|;
name|int
name|removed
init|=
literal|0
decl_stmt|;
comment|/* Scan for "dead" fragments and remove them */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|dead
init|=
literal|0
decl_stmt|;
comment|/* If queue is empty, we're done */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
break|break;
comment|/* Determine whether first fragment can ever be completed */
name|TAILQ_FOREACH
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|f_qent
argument_list|)
block|{
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|>=
literal|0
condition|)
break|break;
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|qnext
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: last frag< MSEQ?"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qnext
operator|->
name|seq
operator|!=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
operator|||
name|qent
operator|->
name|last
operator|||
name|qnext
operator|->
name|first
condition|)
block|{
name|dead
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|dead
condition|)
break|break;
comment|/* Remove fragment and all others in the same packet */
while|while
condition|(
operator|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|)
operator|!=
name|qnext
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|--
expr_stmt|;
name|removed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|removed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the queue, restoring the queue invariants  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_frag_process
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|item_p
name|item
decl_stmt|;
comment|/* Deliver any deliverable packets */
while|while
condition|(
name|ng_ppp_check_packet
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ng_ppp_get_packet
argument_list|(
name|node
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|meta
argument_list|)
expr_stmt|;
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
comment|/* Delete dead fragments and try again */
if|if
condition|(
name|ng_ppp_frag_trim
argument_list|(
name|node
argument_list|)
condition|)
block|{
while|while
condition|(
name|ng_ppp_check_packet
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|ng_ppp_get_packet
argument_list|(
name|node
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|meta
argument_list|)
expr_stmt|;
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check for stale fragments while we're here */
name|ng_ppp_frag_checkstale
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check queue length */
if|if
condition|(
name|priv
operator|->
name|qlen
operator|>
name|MP_MAX_QUEUE_LEN
condition|)
block|{
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get oldest fragment */
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
comment|/* Bump MSEQ if necessary */
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|mseq
argument_list|,
name|qent
operator|->
name|seq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|priv
operator|->
name|mseq
operator|=
name|qent
operator|->
name|seq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|alink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|alink
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|<
literal|0
condition|)
name|alink
operator|->
name|seq
operator|=
name|priv
operator|->
name|mseq
expr_stmt|;
block|}
block|}
comment|/* Drop it */
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|--
expr_stmt|;
comment|/* Process queue again */
return|return
name|ng_ppp_frag_process
argument_list|(
name|node
argument_list|)
return|;
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for 'stale' completed packets that need to be delivered  *  * If a link goes down or has a temporary failure, MSEQ can get  * "stuck", because no new incoming fragments appear on that link.  * This can cause completed packets to never get delivered if  * their sequence numbers are all> MSEQ + 1.  *  * This routine checks how long all of the completed packets have  * been sitting in the queue, and if too long, removes fragments  * from the queue and increments MSEQ to allow them to be delivered.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_checkstale
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|beg
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|age
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|meta_p
name|meta
decl_stmt|;
name|int
name|i
decl_stmt|,
name|seq
decl_stmt|;
name|item_p
name|item
decl_stmt|;
name|now
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
comment|/* uninitialized state */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* If queue is empty, we're done */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
condition|)
break|break;
comment|/* Find the first complete packet in the queue */
name|beg
operator|=
name|end
operator|=
name|NULL
expr_stmt|;
name|seq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|->
name|seq
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|qent
argument_list|,
argument|&priv->frags
argument_list|,
argument|f_qent
argument_list|)
block|{
if|if
condition|(
name|qent
operator|->
name|first
condition|)
name|beg
operator|=
name|qent
expr_stmt|;
elseif|else
if|if
condition|(
name|qent
operator|->
name|seq
operator|!=
name|seq
condition|)
name|beg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|beg
operator|!=
name|NULL
operator|&&
name|qent
operator|->
name|last
condition|)
block|{
name|end
operator|=
name|qent
expr_stmt|;
break|break;
block|}
name|seq
operator|=
name|MP_NEXT_RECV_SEQ
argument_list|(
name|priv
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
comment|/* If none found, exit */
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
break|break;
comment|/* Get current time (we assume we've been up for>= 1 second) */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Check if packet has been queued too long */
name|age
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|age
argument_list|,
operator|&
name|beg
operator|->
name|timestamp
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|age
argument_list|,
operator|&
name|ng_ppp_max_staleness
argument_list|,
operator|<
argument_list|)
condition|)
break|break;
comment|/* Throw away junk fragments in front of the completed packet */
while|while
condition|(
operator|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
operator|)
operator|!=
name|beg
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
argument_list|,
operator|(
literal|"%s: empty q"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|dropFragments
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|,
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|--
expr_stmt|;
block|}
comment|/* Extract completed packet */
name|ng_ppp_get_packet
argument_list|(
name|node
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|meta
argument_list|)
expr_stmt|;
comment|/* Bump MSEQ if necessary */
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|mseq
argument_list|,
name|end
operator|->
name|seq
argument_list|)
operator|<
literal|0
condition|)
block|{
name|priv
operator|->
name|mseq
operator|=
name|end
operator|->
name|seq
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|alink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|i
index|]
index|]
decl_stmt|;
if|if
condition|(
name|MP_RECV_SEQ_DIFF
argument_list|(
name|priv
argument_list|,
name|alink
operator|->
name|seq
argument_list|,
name|priv
operator|->
name|mseq
argument_list|)
operator|<
literal|0
condition|)
name|alink
operator|->
name|seq
operator|=
name|priv
operator|->
name|mseq
expr_stmt|;
block|}
block|}
comment|/* Deliver packet */
name|item
operator|=
name|ng_package_data
argument_list|(
name|m
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|ng_ppp_input
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|NG_PPP_BUNDLE_LINKNUM
argument_list|,
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Periodically call ng_ppp_frag_checkstale()  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|const
name|node_p
name|node
init|=
name|arg
decl_stmt|;
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* Handle the race where shutdown happens just before splnet() above */
if|if
condition|(
name|NG_NODE_NOT_VALID
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Reset timer state after timeout */
name|KASSERT
argument_list|(
name|priv
operator|->
name|timerActive
argument_list|,
operator|(
literal|"%s: !timerActive"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|timerActive
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|node
operator|->
name|nd_refs
operator|>
literal|1
argument_list|,
operator|(
literal|"%s: nd_refs=%d"
operator|,
name|__func__
operator|,
name|node
operator|->
name|nd_refs
operator|)
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Start timer again */
name|ng_ppp_start_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Scan the fragment queue */
name|ng_ppp_frag_checkstale
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deliver a frame out on the bundle, i.e., figure out how to fragment  * the frame across the individual PPP links and do so.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_mp_output
parameter_list|(
name|node_p
name|node
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|meta_p
name|meta
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
specifier|const
name|int
name|hdr_len
init|=
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|?
literal|2
else|:
literal|4
decl_stmt|;
name|int
name|distrib
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|firstFragment
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|;
name|item_p
name|item
decl_stmt|;
comment|/* At least one link must be active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|0
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Round-robin strategy */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableRoundRobin
operator|||
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|MP_MIN_FRAG_LEN
condition|)
block|{
name|activeLinkNum
operator|=
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|distrib
argument_list|,
name|priv
operator|->
name|numActiveLinks
operator|*
sizeof|sizeof
argument_list|(
name|distrib
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are equivalent (optimize the common case) */
if|if
condition|(
name|priv
operator|->
name|allLinksEqual
condition|)
block|{
specifier|const
name|int
name|fraction
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|/
name|priv
operator|->
name|numActiveLinks
decl_stmt|;
name|int
name|i
decl_stmt|,
name|remain
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|i
operator|++
control|)
name|distrib
index|[
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
index|]
operator|=
name|fraction
expr_stmt|;
name|remain
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|fraction
operator|*
name|priv
operator|->
name|numActiveLinks
operator|)
expr_stmt|;
while|while
condition|(
name|remain
operator|>
literal|0
condition|)
block|{
name|distrib
index|[
name|priv
operator|->
name|lastLink
operator|++
operator|%
name|priv
operator|->
name|numActiveLinks
index|]
operator|++
expr_stmt|;
name|remain
operator|--
expr_stmt|;
block|}
goto|goto
name|deliver
goto|;
block|}
comment|/* Strategy when all links are not equivalent */
name|ng_ppp_mp_strategy
argument_list|(
name|node
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|distrib
argument_list|)
expr_stmt|;
name|deliver
label|:
comment|/* Update stats */
name|priv
operator|->
name|bundleStats
operator|.
name|xmitFrames
operator|++
expr_stmt|;
name|priv
operator|->
name|bundleStats
operator|.
name|xmitOctets
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Send alloted portions of frame out on the link(s) */
for|for
control|(
name|firstFragment
operator|=
literal|1
operator|,
name|activeLinkNum
operator|=
name|priv
operator|->
name|numActiveLinks
operator|-
literal|1
init|;
name|activeLinkNum
operator|>=
literal|0
condition|;
name|activeLinkNum
operator|--
control|)
block|{
specifier|const
name|int
name|linkNum
init|=
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
decl_stmt|;
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|linkNum
index|]
decl_stmt|;
comment|/* Deliver fragment(s) out the next link */
for|for
control|(
init|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|>
literal|0
condition|;
name|firstFragment
operator|=
literal|0
control|)
block|{
name|int
name|len
decl_stmt|,
name|lastFragment
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|meta_p
name|meta2
decl_stmt|;
comment|/* Calculate fragment length; don't exceed link MTU */
name|len
operator|=
name|distrib
index|[
name|activeLinkNum
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
condition|)
name|len
operator|=
name|link
operator|->
name|conf
operator|.
name|mru
operator|-
name|hdr_len
expr_stmt|;
name|distrib
index|[
name|activeLinkNum
index|]
operator|-=
name|len
expr_stmt|;
name|lastFragment
operator|=
operator|(
name|len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|)
expr_stmt|;
comment|/* Split off next fragment as "m2" */
name|m2
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|lastFragment
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_split
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|m
operator|=
name|n
expr_stmt|;
block|}
comment|/* Prepend MP header */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|)
block|{
name|u_int16_t
name|shdr
decl_stmt|;
name|shdr
operator|=
name|priv
operator|->
name|xseq
expr_stmt|;
name|priv
operator|->
name|xseq
operator|=
operator|(
name|priv
operator|->
name|xseq
operator|+
literal|1
operator|)
operator|&
name|MP_SHORT_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|shdr
operator||=
name|MP_SHORT_LAST_FLAG
expr_stmt|;
name|shdr
operator|=
name|htons
argument_list|(
name|shdr
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ng_ppp_prepend
argument_list|(
name|m2
argument_list|,
operator|&
name|shdr
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
name|lhdr
decl_stmt|;
name|lhdr
operator|=
name|priv
operator|->
name|xseq
expr_stmt|;
name|priv
operator|->
name|xseq
operator|=
operator|(
name|priv
operator|->
name|xseq
operator|+
literal|1
operator|)
operator|&
name|MP_LONG_SEQ_MASK
expr_stmt|;
if|if
condition|(
name|firstFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_FIRST_FLAG
expr_stmt|;
if|if
condition|(
name|lastFragment
condition|)
name|lhdr
operator||=
name|MP_LONG_LAST_FLAG
expr_stmt|;
name|lhdr
operator|=
name|htonl
argument_list|(
name|lhdr
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ng_ppp_prepend
argument_list|(
name|m2
argument_list|,
operator|&
name|lhdr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* Copy the meta information, if any */
name|meta2
operator|=
name|lastFragment
condition|?
name|meta
else|:
name|ng_copy_meta
argument_list|(
name|meta
argument_list|)
expr_stmt|;
comment|/* Send fragment */
name|item
operator|=
name|ng_package_data
argument_list|(
name|m2
argument_list|,
name|meta2
argument_list|)
expr_stmt|;
name|error
operator|=
name|ng_ppp_output
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
name|PROT_MP
argument_list|,
name|linkNum
argument_list|,
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|lastFragment
condition|)
block|{
name|NG_FREE_M
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|meta
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
comment|/* Done */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Computing the optimal fragmentation  * -----------------------------------  *  * This routine tries to compute the optimal fragmentation pattern based  * on each link's latency, bandwidth, and calculated additional latency.  * The latter quantity is the additional latency caused by previously  * written data that has not been transmitted yet.  *  * This algorithm is only useful when not all of the links have the  * same latency and bandwidth values.  *  * The essential idea is to make the last bit of each fragment of the  * frame arrive at the opposite end at the exact same time. This greedy  * algorithm is optimal, in that no other scheduling could result in any  * packet arriving any sooner unless packets are delivered out of order.  *  * Suppose link i has bandwidth b_i (in tens of bytes per milisecond) and  * latency l_i (in miliseconds). Consider the function function f_i(t)  * which is equal to the number of bytes that will have arrived at  * the peer after t miliseconds if we start writing continuously at  * time t = 0. Then f_i(t) = b_i * (t - l_i) = ((b_i * t) - (l_i * b_i).  * That is, f_i(t) is a line with slope b_i and y-intersect -(l_i * b_i).  * Note that the y-intersect is always<= zero because latency can't be  * negative.  Note also that really the function is f_i(t) except when  * f_i(t) is negative, in which case the function is zero.  To take  * care of this, let Q_i(t) = { if (f_i(t)> 0) return 1; else return 0; }.  * So the actual number of bytes that will have arrived at the peer after  * t miliseconds is f_i(t) * Q_i(t).  *  * At any given time, each link has some additional latency a_i>= 0  * due to previously written fragment(s) which are still in the queue.  * This value is easily computed from the time since last transmission,  * the previous latency value, the number of bytes written, and the  * link's bandwidth.  *  * Assume that l_i includes any a_i already, and that the links are  * sorted by latency, so that l_i<= l_{i+1}.  *  * Let N be the total number of bytes in the current frame we are sending.  *  * Suppose we were to start writing bytes at time t = 0 on all links  * simultaneously, which is the most we can possibly do.  Then let  * F(t) be equal to the total number of bytes received by the peer  * after t miliseconds. Then F(t) = Sum_i (f_i(t) * Q_i(t)).  *  * Our goal is simply this: fragment the frame across the links such  * that the peer is able to reconstruct the completed frame as soon as  * possible, i.e., at the least possible value of t. Call this value t_0.  *  * Then it follows that F(t_0) = N. Our strategy is first to find the value  * of t_0, and then deduce how many bytes to write to each link.  *  * Rewriting F(t_0):  *  *   t_0 = ( N + Sum_i ( l_i * b_i * Q_i(t_0) ) ) / Sum_i ( b_i * Q_i(t_0) )  *  * Now, we note that Q_i(t) is constant for l_i<= t<= l_{i+1}. t_0 will  * lie in one of these ranges.  To find it, we just need to find the i such  * that F(l_i)<= N<= F(l_{i+1}).  Then we compute all the constant values  * for Q_i() in this range, plug in the remaining values, solving for t_0.  *  * Once t_0 is known, then the number of bytes to send on link i is  * just f_i(t_0) * Q_i(t_0).  *  * In other words, we start allocating bytes to the links one at a time.  * We keep adding links until the frame is completely sent.  Some links  * may not get any bytes because their latency is too high.  *  * Is all this work really worth the trouble?  Depends on the situation.  * The bigger the ratio of computer speed to link speed, and the more  * important total bundle latency is (e.g., for interactive response time),  * the more it's worth it.  There is however the cost of calling this  * function for every frame.  The running time is O(n^2) where n is the  * number of links that receive a non-zero number of bytes.  *  * Since latency is measured in miliseconds, the "resolution" of this  * algorithm is one milisecond.  *  * To avoid this algorithm altogether, configure all links to have the  * same latency and bandwidth.  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_mp_strategy
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|distrib
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|latency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|sortByLatency
index|[
name|NG_PPP_MAX_LINKS
index|]
decl_stmt|;
name|int
name|activeLinkNum
decl_stmt|;
name|int
name|t0
decl_stmt|,
name|total
decl_stmt|,
name|topSum
decl_stmt|,
name|botSum
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|i
decl_stmt|,
name|numFragments
decl_stmt|;
comment|/* If only one link, this gets real easy */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|==
literal|1
condition|)
block|{
name|distrib
index|[
literal|0
index|]
operator|=
name|len
expr_stmt|;
return|return;
block|}
comment|/* Get current time */
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Compute latencies for each link at this point in time */
for|for
control|(
name|activeLinkNum
operator|=
literal|0
init|;
name|activeLinkNum
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|activeLinkNum
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|alink
decl_stmt|;
name|struct
name|timeval
name|diff
decl_stmt|;
name|int
name|xmitBytes
decl_stmt|;
comment|/* Start with base latency value */
name|alink
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|activeLinkNum
index|]
index|]
expr_stmt|;
name|latency
index|[
name|activeLinkNum
index|]
operator|=
name|alink
operator|->
name|conf
operator|.
name|latency
expr_stmt|;
name|sortByLatency
index|[
name|activeLinkNum
index|]
operator|=
name|activeLinkNum
expr_stmt|;
comment|/* see below */
comment|/* Any additional latency? */
if|if
condition|(
name|alink
operator|->
name|bytesInQueue
operator|==
literal|0
condition|)
continue|continue;
comment|/* Compute time delta since last write */
name|diff
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|alink
operator|->
name|lastWrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|diff
operator|.
name|tv_sec
operator|>=
literal|10
condition|)
block|{
comment|/* sanity */
name|alink
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* How many bytes could have transmitted since last write? */
name|xmitBytes
operator|=
operator|(
name|alink
operator|->
name|conf
operator|.
name|bandwidth
operator|*
name|diff
operator|.
name|tv_sec
operator|)
operator|+
operator|(
name|alink
operator|->
name|conf
operator|.
name|bandwidth
operator|*
operator|(
name|diff
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
operator|)
operator|/
literal|100
expr_stmt|;
name|alink
operator|->
name|bytesInQueue
operator|-=
name|xmitBytes
expr_stmt|;
if|if
condition|(
name|alink
operator|->
name|bytesInQueue
operator|<
literal|0
condition|)
name|alink
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
else|else
name|latency
index|[
name|activeLinkNum
index|]
operator|+=
operator|(
literal|100
operator|*
name|alink
operator|->
name|bytesInQueue
operator|)
operator|/
name|alink
operator|->
name|conf
operator|.
name|bandwidth
expr_stmt|;
block|}
comment|/* Sort active links by latency */
name|compareLatencies
operator|=
name|latency
expr_stmt|;
name|qsort
argument_list|(
name|sortByLatency
argument_list|,
name|priv
operator|->
name|numActiveLinks
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sortByLatency
argument_list|)
argument_list|,
name|ng_ppp_intcmp
argument_list|)
expr_stmt|;
name|compareLatencies
operator|=
name|NULL
expr_stmt|;
comment|/* Find the interval we need (add links in sortByLatency[] order) */
for|for
control|(
name|numFragments
operator|=
literal|1
init|;
name|numFragments
operator|<
name|priv
operator|->
name|numActiveLinks
condition|;
name|numFragments
operator|++
control|)
block|{
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|flowTime
decl_stmt|;
name|flowTime
operator|=
name|latency
index|[
name|sortByLatency
index|[
name|numFragments
index|]
index|]
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
name|total
operator|+=
operator|(
operator|(
name|flowTime
operator|*
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
operator|)
operator|+
literal|99
operator|)
operator|/
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|total
operator|>=
name|len
condition|)
break|break;
block|}
comment|/* Solve for t_0 in that interval */
for|for
control|(
name|topSum
operator|=
name|botSum
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
decl_stmt|;
name|topSum
operator|+=
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|*
name|bw
expr_stmt|;
comment|/* / 100 */
name|botSum
operator|+=
name|bw
expr_stmt|;
comment|/* / 100 */
block|}
name|t0
operator|=
operator|(
operator|(
name|len
operator|*
literal|100
operator|)
operator|+
name|topSum
operator|+
name|botSum
operator|/
literal|2
operator|)
operator|/
name|botSum
expr_stmt|;
comment|/* Compute f_i(t_0) all i */
name|bzero
argument_list|(
name|distrib
argument_list|,
name|priv
operator|->
name|numActiveLinks
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|distrib
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|total
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bw
init|=
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
operator|.
name|conf
operator|.
name|bandwidth
decl_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|=
operator|(
name|bw
operator|*
operator|(
name|t0
operator|-
name|latency
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
name|total
operator|+=
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
comment|/* Deal with any rounding error */
if|if
condition|(
name|total
operator|<
name|len
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|fastLink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
literal|0
index|]
index|]
index|]
decl_stmt|;
name|int
name|fast
init|=
literal|0
decl_stmt|;
comment|/* Find the fastest link */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
decl_stmt|;
if|if
condition|(
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|>
name|fastLink
operator|->
name|conf
operator|.
name|bandwidth
condition|)
block|{
name|fast
operator|=
name|i
expr_stmt|;
name|fastLink
operator|=
name|link
expr_stmt|;
block|}
block|}
name|distrib
index|[
name|sortByLatency
index|[
name|fast
index|]
index|]
operator|+=
name|len
operator|-
name|total
expr_stmt|;
block|}
else|else
while|while
condition|(
name|total
operator|>
name|len
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|slowLink
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
literal|0
index|]
index|]
index|]
decl_stmt|;
name|int
name|delta
decl_stmt|,
name|slow
init|=
literal|0
decl_stmt|;
comment|/* Find the slowest link that still has bytes to remove */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numFragments
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
index|]
decl_stmt|;
if|if
condition|(
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|==
literal|0
operator|||
operator|(
name|distrib
index|[
name|sortByLatency
index|[
name|i
index|]
index|]
operator|>
literal|0
operator|&&
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|<
name|slowLink
operator|->
name|conf
operator|.
name|bandwidth
operator|)
condition|)
block|{
name|slow
operator|=
name|i
expr_stmt|;
name|slowLink
operator|=
name|link
expr_stmt|;
block|}
block|}
name|delta
operator|=
name|total
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
condition|)
name|delta
operator|=
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
expr_stmt|;
name|distrib
index|[
name|sortByLatency
index|[
name|slow
index|]
index|]
operator|-=
name|delta
expr_stmt|;
name|total
operator|-=
name|delta
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare two integers  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_intcmp
parameter_list|(
specifier|const
name|void
modifier|*
name|v1
parameter_list|,
specifier|const
name|void
modifier|*
name|v2
parameter_list|)
block|{
specifier|const
name|int
name|index1
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v1
operator|)
decl_stmt|;
specifier|const
name|int
name|index2
init|=
operator|*
operator|(
operator|(
specifier|const
name|int
operator|*
operator|)
name|v2
operator|)
decl_stmt|;
return|return
name|compareLatencies
index|[
name|index1
index|]
operator|-
name|compareLatencies
index|[
name|index2
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Prepend a possibly compressed PPP protocol number in front of a frame  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_addproto
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|compOK
parameter_list|)
block|{
if|if
condition|(
name|compOK
operator|&&
name|PROT_COMPRESSABLE
argument_list|(
name|proto
argument_list|)
condition|)
block|{
name|u_char
name|pbyte
init|=
operator|(
name|u_char
operator|)
name|proto
decl_stmt|;
return|return
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|pbyte
argument_list|,
literal|1
argument_list|)
return|;
block|}
else|else
block|{
name|u_int16_t
name|pword
init|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|proto
argument_list|)
decl_stmt|;
return|return
name|ng_ppp_prepend
argument_list|(
name|m
argument_list|,
operator|&
name|pword
argument_list|,
literal|2
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Prepend some bytes to an mbuf  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ng_ppp_prepend
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_len
operator|<
name|len
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update private information that is derived from other private information  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_update
parameter_list|(
name|node_p
name|node
parameter_list|,
name|int
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Update active status for VJ Compression */
name|priv
operator|->
name|vjCompHooked
operator|=
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_IP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_COMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_UNCOMP
index|]
operator|!=
name|NULL
operator|&&
name|priv
operator|->
name|hooks
index|[
name|HOOK_INDEX_VJC_VJIP
index|]
operator|!=
name|NULL
expr_stmt|;
comment|/* Increase latency for each link an amount equal to one MP header */
if|if
condition|(
name|newConf
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|int
name|hdrBytes
decl_stmt|;
name|hdrBytes
operator|=
operator|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|enableACFComp
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
operator|(
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|enableProtoComp
condition|?
literal|1
else|:
literal|2
operator|)
operator|+
operator|(
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
condition|?
literal|2
else|:
literal|4
operator|)
expr_stmt|;
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|latency
operator|+=
operator|(
operator|(
name|hdrBytes
operator|*
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|conf
operator|.
name|bandwidth
operator|)
operator|+
literal|50
operator|)
operator|/
literal|100
expr_stmt|;
block|}
block|}
comment|/* Update list of active links */
name|bzero
argument_list|(
operator|&
name|priv
operator|->
name|activeLinks
argument_list|,
sizeof|sizeof
argument_list|(
name|priv
operator|->
name|activeLinks
argument_list|)
argument_list|)
expr_stmt|;
name|priv
operator|->
name|numActiveLinks
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|allLinksEqual
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|i
index|]
decl_stmt|;
comment|/* Is link active? */
if|if
condition|(
name|link
operator|->
name|conf
operator|.
name|enableLink
operator|&&
name|link
operator|->
name|hook
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ng_ppp_link
modifier|*
name|link0
decl_stmt|;
comment|/* Add link to list of active links */
name|priv
operator|->
name|activeLinks
index|[
name|priv
operator|->
name|numActiveLinks
operator|++
index|]
operator|=
name|i
expr_stmt|;
name|link0
operator|=
operator|&
name|priv
operator|->
name|links
index|[
name|priv
operator|->
name|activeLinks
index|[
literal|0
index|]
index|]
expr_stmt|;
comment|/* Determine if all links are still equal */
if|if
condition|(
name|link
operator|->
name|conf
operator|.
name|latency
operator|!=
name|link0
operator|->
name|conf
operator|.
name|latency
operator|||
name|link
operator|->
name|conf
operator|.
name|bandwidth
operator|!=
name|link0
operator|->
name|conf
operator|.
name|bandwidth
condition|)
name|priv
operator|->
name|allLinksEqual
operator|=
literal|0
expr_stmt|;
comment|/* Initialize rec'd sequence number */
if|if
condition|(
name|link
operator|->
name|seq
operator|==
name|MP_NOSEQ
condition|)
block|{
name|link
operator|->
name|seq
operator|=
operator|(
name|link
operator|==
name|link0
operator|)
condition|?
name|MP_INITIAL_SEQ
else|:
name|link0
operator|->
name|seq
expr_stmt|;
block|}
block|}
else|else
name|link
operator|->
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
block|}
comment|/* Update MP state as multi-link is active or not */
if|if
condition|(
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|&&
name|priv
operator|->
name|numActiveLinks
operator|>
literal|0
condition|)
name|ng_ppp_start_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
else|else
block|{
name|ng_ppp_stop_frag_timer
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ng_ppp_frag_reset
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|priv
operator|->
name|xseq
operator|=
name|MP_INITIAL_SEQ
expr_stmt|;
name|priv
operator|->
name|mseq
operator|=
name|MP_INITIAL_SEQ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ng_ppp_link
modifier|*
specifier|const
name|link
init|=
operator|&
name|priv
operator|->
name|links
index|[
name|i
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|link
operator|->
name|lastWrite
argument_list|,
sizeof|sizeof
argument_list|(
name|link
operator|->
name|lastWrite
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|bytesInQueue
operator|=
literal|0
expr_stmt|;
name|link
operator|->
name|seq
operator|=
name|MP_NOSEQ
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine if a new configuration would represent a valid change  * from the current configuration and link activity status.  */
end_comment

begin_function
specifier|static
name|int
name|ng_ppp_config_valid
parameter_list|(
name|node_p
name|node
parameter_list|,
specifier|const
name|struct
name|ng_ppp_node_conf
modifier|*
name|newConf
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|newNumLinksActive
decl_stmt|;
comment|/* Check per-link config and count how many links would be active */
for|for
control|(
name|newNumLinksActive
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NG_PPP_MAX_LINKS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|enableLink
operator|&&
name|priv
operator|->
name|links
index|[
name|i
index|]
operator|.
name|hook
operator|!=
name|NULL
condition|)
name|newNumLinksActive
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|enableLink
condition|)
continue|continue;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|mru
operator|<
name|MP_MIN_LINK_MRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|bandwidth
operator|>
name|NG_PPP_MAX_BANDWIDTH
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|newConf
operator|->
name|links
index|[
name|i
index|]
operator|.
name|latency
operator|>
name|NG_PPP_MAX_LATENCY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check bundle parameters */
if|if
condition|(
name|newConf
operator|->
name|bund
operator|.
name|enableMultilink
operator|&&
name|newConf
operator|->
name|bund
operator|.
name|mrru
operator|<
name|MP_MIN_MRRU
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Disallow changes to multi-link configuration while MP is active */
if|if
condition|(
name|priv
operator|->
name|numActiveLinks
operator|>
literal|0
operator|&&
name|newNumLinksActive
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|priv
operator|->
name|conf
operator|.
name|enableMultilink
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|enableMultilink
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|xmitShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|xmitShortSeq
operator|||
operator|!
name|priv
operator|->
name|conf
operator|.
name|recvShortSeq
operator|!=
operator|!
name|newConf
operator|->
name|bund
operator|.
name|recvShortSeq
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* At most one link can be active unless multi-link is enabled */
if|if
condition|(
operator|!
name|newConf
operator|->
name|bund
operator|.
name|enableMultilink
operator|&&
name|newNumLinksActive
operator|>
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Configuration change would be valid */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free all entries in the fragment queue  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_frag_reset
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|struct
name|ng_ppp_frag
modifier|*
name|qent
decl_stmt|,
modifier|*
name|qnext
decl_stmt|;
for|for
control|(
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
init|;
name|qent
condition|;
name|qent
operator|=
name|qnext
control|)
block|{
name|qnext
operator|=
name|TAILQ_NEXT
argument_list|(
name|qent
argument_list|,
name|f_qent
argument_list|)
expr_stmt|;
name|NG_FREE_M
argument_list|(
name|qent
operator|->
name|data
argument_list|)
expr_stmt|;
name|NG_FREE_META
argument_list|(
name|qent
operator|->
name|meta
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|qent
argument_list|,
name|M_NETGRAPH_PPP
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|priv
operator|->
name|frags
argument_list|)
expr_stmt|;
name|priv
operator|->
name|qlen
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start fragment queue timer  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_start_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|timerActive
condition|)
block|{
name|priv
operator|->
name|fragTimer
operator|=
name|timeout
argument_list|(
name|ng_ppp_frag_timeout
argument_list|,
name|node
argument_list|,
name|MP_FRAGTIMER_INTERVAL
argument_list|)
expr_stmt|;
name|priv
operator|->
name|timerActive
operator|=
literal|1
expr_stmt|;
name|NG_NODE_REF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stop fragment queue timer  */
end_comment

begin_function
specifier|static
name|void
name|ng_ppp_stop_frag_timer
parameter_list|(
name|node_p
name|node
parameter_list|)
block|{
specifier|const
name|priv_p
name|priv
init|=
name|NG_NODE_PRIVATE
argument_list|(
name|node
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|timerActive
condition|)
block|{
name|untimeout
argument_list|(
name|ng_ppp_frag_timeout
argument_list|,
name|node
argument_list|,
name|priv
operator|->
name|fragTimer
argument_list|)
expr_stmt|;
name|priv
operator|->
name|timerActive
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|node
operator|->
name|nd_refs
operator|>
literal|1
argument_list|,
operator|(
literal|"%s: nd_refs=%d"
operator|,
name|__func__
operator|,
name|node
operator|->
name|nd_refs
operator|)
argument_list|)
expr_stmt|;
name|NG_NODE_UNREF
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

