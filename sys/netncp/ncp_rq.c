begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999, Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Routines to prepare request and fetch reply  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_conn.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_rq.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_subr.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_nls.h>
end_include

begin_function
name|int
name|ncp_rq_head
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int32_t
name|ptype
parameter_list|,
name|u_int8_t
name|fn
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ncp_rqhdr
modifier|*
name|rq
decl_stmt|;
name|struct
name|ncp_bursthdr
modifier|*
name|brq
decl_stmt|;
name|caddr_t
name|pstart
decl_stmt|;
name|bzero
argument_list|(
name|rqp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rqp
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|p
operator|=
name|p
expr_stmt|;
name|rqp
operator|->
name|cred
operator|=
name|cred
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
comment|/* if M_WAIT ? */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|rqp
operator|->
name|rq
operator|=
name|rqp
operator|->
name|mrq
operator|=
name|m
expr_stmt|;
name|rqp
operator|->
name|rp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
case|case
name|NCP_PACKET_BURST
case|:
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|brq
argument_list|)
operator|+
literal|24
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|brq
argument_list|)
expr_stmt|;
name|brq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ncp_bursthdr
operator|*
argument_list|)
expr_stmt|;
name|brq
operator|->
name|bh_type
operator|=
name|ptype
expr_stmt|;
name|brq
operator|->
name|bh_streamtype
operator|=
literal|0x2
expr_stmt|;
name|pstart
operator|=
operator|(
name|caddr_t
operator|)
name|brq
expr_stmt|;
break|break;
default|default:
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rq
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* possible len field in some functions */
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rq
argument_list|)
expr_stmt|;
name|rq
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ncp_rqhdr
operator|*
argument_list|)
expr_stmt|;
name|rq
operator|->
name|type
operator|=
name|ptype
expr_stmt|;
name|rq
operator|->
name|seq
operator|=
literal|0
expr_stmt|;
comment|/* filled later */
name|rq
operator|->
name|fn
operator|=
name|fn
expr_stmt|;
name|pstart
operator|=
operator|(
name|caddr_t
operator|)
name|rq
expr_stmt|;
break|break;
block|}
name|rqp
operator|->
name|bpos
operator|=
name|pstart
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ncp_rq_done
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|m_freem
argument_list|(
name|rqp
operator|->
name|rq
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|rp
condition|)
name|m_freem
argument_list|(
name|rqp
operator|->
name|rp
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines to fill the request  */
end_comment

begin_function_decl
specifier|static
name|caddr_t
name|ncp_mchecksize
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|NCP_RQADD
parameter_list|(
name|t
parameter_list|)
value|((t*)(ncp_mchecksize(rqp,sizeof(t))))
end_define

begin_function
name|caddr_t
name|ncp_mchecksize
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|caddr_t
name|bpos1
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|MLEN
condition|)
name|panic
argument_list|(
literal|"ncp_mchecksize\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|rqp
operator|->
name|mrq
argument_list|)
operator|<
operator|(
name|size
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|mrq
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|rqp
operator|->
name|mrq
operator|=
name|m
expr_stmt|;
block|}
name|rqp
operator|->
name|mrq
operator|->
name|m_len
operator|+=
name|size
expr_stmt|;
name|bpos1
operator|=
name|rqp
operator|->
name|bpos
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|+=
name|size
expr_stmt|;
return|return
name|bpos1
return|;
block|}
end_function

begin_function
name|void
name|ncp_rq_byte
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int8_t
name|x
parameter_list|)
block|{
operator|*
name|NCP_RQADD
argument_list|(
name|u_int8_t
argument_list|)
operator|=
name|x
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ncp_rq_word_hl
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int16_t
name|x
parameter_list|)
block|{
name|setwbe
argument_list|(
name|NCP_RQADD
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ncp_rq_word_lh
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int16_t
name|x
parameter_list|)
block|{
name|setwle
argument_list|(
name|NCP_RQADD
argument_list|(
name|u_int16_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ncp_rq_dword_lh
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int32_t
name|x
parameter_list|)
block|{
name|setdle
argument_list|(
name|NCP_RQADD
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ncp_rq_pathstring
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
name|size
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ncp_nlstables
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|cplen
decl_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|m
operator|=
name|rqp
operator|->
name|mrq
expr_stmt|;
name|cplen
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplen
condition|)
block|{
name|ncp_pathcopy
argument_list|(
name|name
argument_list|,
name|rqp
operator|->
name|bpos
argument_list|,
name|cplen
argument_list|,
name|nt
argument_list|)
expr_stmt|;
name|size
operator|-=
name|cplen
expr_stmt|;
name|name
operator|+=
name|cplen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|cplen
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
name|m
operator|=
name|m_getm
argument_list|(
name|m
argument_list|,
name|size
argument_list|,
name|MT_DATA
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|cplen
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|ncp_pathcopy
argument_list|(
name|name
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|cplen
argument_list|,
name|nt
argument_list|)
expr_stmt|;
name|size
operator|-=
name|cplen
expr_stmt|;
name|name
operator|+=
name|cplen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|cplen
expr_stmt|;
block|}
block|}
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|rqp
operator|->
name|mrq
operator|=
name|m
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ncp_rq_putanymem
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|caddr_t
name|source
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|cplen
decl_stmt|,
name|error
decl_stmt|;
name|m
operator|=
name|rqp
operator|->
name|mrq
expr_stmt|;
name|cplen
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplen
condition|)
block|{
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|source
argument_list|,
name|rqp
operator|->
name|bpos
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
name|bcopy
argument_list|(
name|source
argument_list|,
name|rqp
operator|->
name|bpos
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
name|size
operator|-=
name|cplen
expr_stmt|;
name|source
operator|+=
name|cplen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|cplen
expr_stmt|;
block|}
if|if
condition|(
name|size
condition|)
block|{
name|m
operator|=
name|m_getm
argument_list|(
name|m
argument_list|,
name|size
argument_list|,
name|MT_DATA
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|cplen
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|1
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|source
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
name|bcopy
argument_list|(
name|source
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
argument_list|,
name|cplen
argument_list|)
expr_stmt|;
name|size
operator|-=
name|cplen
expr_stmt|;
name|source
operator|+=
name|cplen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|cplen
expr_stmt|;
block|}
block|}
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|rqp
operator|->
name|mrq
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ncp_rq_mbuf
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|rqp
operator|->
name|mrq
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|M_COPYALL
condition|)
name|m
operator|->
name|m_len
operator|=
name|size
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|rqp
operator|->
name|mrq
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ncp_rq_pstring
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|255
condition|)
block|{
name|nwfs_printf
argument_list|(
literal|"string too long: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|len
operator|=
literal|255
expr_stmt|;
block|}
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ncp_rq_mem
argument_list|(
name|rqp
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ncp_rq_dbase_path
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|u_int8_t
name|vol_num
parameter_list|,
name|u_int32_t
name|dir_base
parameter_list|,
name|int
name|namelen
parameter_list|,
name|u_char
modifier|*
name|path
parameter_list|,
name|struct
name|ncp_nlstables
modifier|*
name|nt
parameter_list|)
block|{
name|int
name|complen
decl_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|vol_num
argument_list|)
expr_stmt|;
name|ncp_rq_dword
argument_list|(
name|rqp
argument_list|,
name|dir_base
argument_list|)
expr_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* with dirbase */
if|if
condition|(
name|path
operator|!=
name|NULL
operator|&&
name|path
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|namelen
operator|<
literal|0
condition|)
block|{
name|namelen
operator|=
operator|*
name|path
operator|++
expr_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|namelen
condition|;
name|namelen
operator|--
control|)
block|{
name|complen
operator|=
operator|*
name|path
operator|++
expr_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|complen
argument_list|)
expr_stmt|;
name|ncp_rq_mem
argument_list|(
name|rqp
argument_list|,
name|path
argument_list|,
name|complen
argument_list|)
expr_stmt|;
name|path
operator|+=
name|complen
expr_stmt|;
block|}
block|}
else|else
block|{
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 1 component */
name|ncp_rq_pathstring
argument_list|(
name|rqp
argument_list|,
name|namelen
argument_list|,
name|path
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * fetch reply routines  */
end_comment

begin_define
define|#
directive|define
name|ncp_mspaceleft
value|(mtod(rqp->mrp,caddr_t)+rqp->mrp->m_len-rqp->bpos)
end_define

begin_function
name|u_int8_t
name|ncp_rp_byte
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ncp_mspaceleft
operator|<
literal|1
condition|)
block|{
name|rqp
operator|->
name|mrp
operator|=
name|rqp
operator|->
name|mrp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|mrp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
block|}
name|rqp
operator|->
name|bpos
operator|+=
literal|1
expr_stmt|;
return|return
name|rqp
operator|->
name|bpos
index|[
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ncp_rp_word_lh
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|caddr_t
name|prev
init|=
name|rqp
operator|->
name|bpos
decl_stmt|;
name|u_int16_t
name|t
decl_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ncp_mspaceleft
operator|>=
literal|2
condition|)
block|{
name|rqp
operator|->
name|bpos
operator|+=
literal|2
expr_stmt|;
return|return
name|getwle
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|t
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|rqp
operator|->
name|bpos
operator|)
operator|)
expr_stmt|;
name|rqp
operator|->
name|mrp
operator|=
name|rqp
operator|->
name|mrp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|t
operator|)
index|[
literal|1
index|]
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|mrp
argument_list|,
name|caddr_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|+=
literal|2
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|u_int16_t
name|ncp_rp_word_hl
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
return|return
operator|(
name|ntohs
argument_list|(
name|ncp_rp_word_lh
argument_list|(
name|rqp
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|ncp_rp_dword_hl
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|int
name|togo
decl_stmt|,
name|rest
decl_stmt|;
name|caddr_t
name|prev
init|=
name|rqp
operator|->
name|bpos
decl_stmt|;
name|u_int32_t
name|t
decl_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|rest
operator|=
name|ncp_mspaceleft
expr_stmt|;
if|if
condition|(
name|rest
operator|>=
literal|4
condition|)
block|{
name|rqp
operator|->
name|bpos
operator|+=
literal|4
expr_stmt|;
return|return
name|getdbe
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|togo
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rest
operator|--
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|t
operator|)
index|[
name|togo
operator|++
index|]
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|prev
operator|++
operator|)
operator|)
expr_stmt|;
block|}
name|rqp
operator|->
name|mrp
operator|=
name|rqp
operator|->
name|mrp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|prev
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|mrp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|prev
operator|+
literal|4
operator|-
name|togo
expr_stmt|;
comment|/* XXX possible low than togo bytes in next mbuf */
while|while
condition|(
name|togo
operator|<
literal|4
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|t
operator|)
index|[
name|togo
operator|++
index|]
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|prev
operator|++
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|getdbe
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|ncp_rp_dword_lh
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|int
name|rest
decl_stmt|,
name|togo
decl_stmt|;
name|caddr_t
name|prev
init|=
name|rqp
operator|->
name|bpos
decl_stmt|;
name|u_int32_t
name|t
decl_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|rest
operator|=
name|ncp_mspaceleft
expr_stmt|;
if|if
condition|(
name|rest
operator|>=
literal|4
condition|)
block|{
name|rqp
operator|->
name|bpos
operator|+=
literal|4
expr_stmt|;
return|return
name|getdle
argument_list|(
name|prev
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|togo
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rest
operator|--
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|t
operator|)
index|[
name|togo
operator|++
index|]
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|prev
operator|++
operator|)
operator|)
expr_stmt|;
block|}
name|rqp
operator|->
name|mrp
operator|=
name|rqp
operator|->
name|mrp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|mrp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|prev
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|mrp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|prev
operator|+
literal|4
operator|-
name|togo
expr_stmt|;
comment|/* XXX possible low than togo bytes in next mbuf */
while|while
condition|(
name|togo
operator|<
literal|4
condition|)
block|{
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|t
operator|)
index|[
name|togo
operator|++
index|]
operator|=
operator|*
operator|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|(
name|prev
operator|++
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|getdle
argument_list|(
operator|&
name|t
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ncp_rp_mem
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|caddr_t
name|target
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rqp
operator|->
name|mrp
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* should be panic */
name|printf
argument_list|(
literal|"ncp_rp_mem: incomplete copy\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|count
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
name|rqp
operator|->
name|bpos
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rqp
operator|->
name|bpos
argument_list|,
name|target
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|size
operator|-=
name|count
expr_stmt|;
name|target
operator|+=
name|count
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|+=
name|count
expr_stmt|;
block|}
name|rqp
operator|->
name|mrp
operator|=
name|m
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ncp_rp_usermem
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|caddr_t
name|target
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rqp
operator|->
name|mrp
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
comment|/* should be panic */
name|printf
argument_list|(
literal|"ncp_rp_mem: incomplete copy\n"
argument_list|)
expr_stmt|;
return|return
name|EFAULT
return|;
block|}
name|count
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
name|rqp
operator|->
name|bpos
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|rqp
operator|->
name|bpos
argument_list|,
name|target
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|size
operator|-=
name|count
expr_stmt|;
name|target
operator|+=
name|count
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|+=
name|count
expr_stmt|;
block|}
name|rqp
operator|->
name|mrp
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|ncp_rp_mbuf
parameter_list|(
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|rqp
operator|->
name|mrp
decl_stmt|,
modifier|*
name|rm
decl_stmt|;
specifier|register
name|unsigned
name|count
decl_stmt|;
name|rm
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
name|rqp
operator|->
name|bpos
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|size
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ncp_rp_mbuf: can't advance\n"
argument_list|)
expr_stmt|;
return|return
name|rm
return|;
block|}
name|count
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
name|rqp
operator|->
name|bpos
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|-=
name|count
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|+=
name|count
expr_stmt|;
block|}
name|rqp
operator|->
name|mrp
operator|=
name|m
expr_stmt|;
return|return
name|rm
return|;
block|}
end_function

begin_function
name|int
name|nwfs_mbuftouio
parameter_list|(
name|mrep
parameter_list|,
name|uiop
parameter_list|,
name|siz
parameter_list|,
name|dpos
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mrep
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|caddr_t
modifier|*
name|dpos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|mbufcp
decl_stmt|,
modifier|*
name|uiocp
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|long
name|uiosiz
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mp
operator|=
operator|*
name|mrep
expr_stmt|;
if|if
condition|(
operator|!
name|mp
condition|)
return|return
literal|0
return|;
name|mbufcp
operator|=
operator|*
name|dpos
expr_stmt|;
name|len
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
operator|-
name|mbufcp
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|<=
literal|0
operator|||
name|uiop
operator|->
name|uio_iov
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|left
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|uiocp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|siz
condition|)
name|left
operator|=
name|siz
expr_stmt|;
name|uiosiz
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADRPC
operator|)
return|;
name|mbufcp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|len
operator|=
name|mp
operator|->
name|m_len
expr_stmt|;
block|}
name|xfer
operator|=
operator|(
name|left
operator|>
name|len
operator|)
condition|?
name|len
else|:
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet.. */
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|)
operator|)
operator|(
name|mbufcp
operator|,
name|uiocp
operator|,
name|xfer
operator|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|uiop
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|bcopy
argument_list|(
name|mbufcp
argument_list|,
name|uiocp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|else
name|copyout
argument_list|(
name|mbufcp
argument_list|,
name|uiocp
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
name|len
operator|-=
name|xfer
expr_stmt|;
name|mbufcp
operator|+=
name|xfer
expr_stmt|;
name|uiocp
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|xfer
expr_stmt|;
block|}
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
name|siz
condition|)
block|{
name|uiop
operator|->
name|uio_iovcnt
operator|--
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|++
expr_stmt|;
block|}
else|else
block|{
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|uiosiz
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|uiosiz
expr_stmt|;
block|}
name|siz
operator|-=
name|uiosiz
expr_stmt|;
block|}
operator|*
name|dpos
operator|=
name|mbufcp
expr_stmt|;
operator|*
name|mrep
operator|=
name|mp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * copies a uio scatter/gather list to an mbuf chain.  * NOTE: can ony handle iovcnt == 1  */
end_comment

begin_function
name|int
name|nwfs_uiotombuf
parameter_list|(
name|uiop
parameter_list|,
name|mq
parameter_list|,
name|siz
parameter_list|,
name|bpos
parameter_list|)
specifier|register
name|struct
name|uio
modifier|*
name|uiop
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mq
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|caddr_t
modifier|*
name|bpos
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|uiocp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|mp2
decl_stmt|;
specifier|register
name|int
name|xfer
decl_stmt|,
name|left
decl_stmt|,
name|mlen
decl_stmt|;
name|int
name|uiosiz
decl_stmt|,
name|clflg
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|uiop
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"nfsm_uiotombuf: iovcnt != 1"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|siz
operator|>
name|MLEN
condition|)
comment|/* or should it>= MCLBYTES ?? */
name|clflg
operator|=
literal|1
expr_stmt|;
else|else
name|clflg
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|mp2
operator|=
operator|*
name|mq
expr_stmt|;
while|while
condition|(
name|siz
operator|>
literal|0
condition|)
block|{
name|left
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
expr_stmt|;
name|uiocp
operator|=
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
expr_stmt|;
if|if
condition|(
name|left
operator|>
name|siz
condition|)
name|left
operator|=
name|siz
expr_stmt|;
name|uiosiz
operator|=
name|left
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|==
literal|0
condition|)
block|{
name|MGET
argument_list|(
name|mp
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|clflg
condition|)
name|MCLGET
argument_list|(
name|mp
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mp2
operator|->
name|m_next
operator|=
name|mp
expr_stmt|;
name|mp2
operator|=
name|mp
expr_stmt|;
name|mlen
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|xfer
operator|=
operator|(
name|left
operator|>
name|mlen
operator|)
condition|?
name|mlen
else|:
name|left
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
comment|/* Not Yet.. */
if|if
condition|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|!=
name|NULL
condition|)
operator|(
operator|*
operator|(
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_op
operator|)
operator|)
operator|(
name|uiocp
operator|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
operator|,
name|xfer
operator|)
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|uiop
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
condition|)
name|bcopy
argument_list|(
name|uiocp
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
else|else
name|copyin
argument_list|(
name|uiocp
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
argument_list|,
name|xfer
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|+=
name|xfer
expr_stmt|;
name|left
operator|-=
name|xfer
expr_stmt|;
name|uiocp
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_offset
operator|+=
name|xfer
expr_stmt|;
name|uiop
operator|->
name|uio_resid
operator|-=
name|xfer
expr_stmt|;
block|}
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_base
operator|+=
name|uiosiz
expr_stmt|;
name|uiop
operator|->
name|uio_iov
operator|->
name|iov_len
operator|-=
name|uiosiz
expr_stmt|;
name|siz
operator|-=
name|uiosiz
expr_stmt|;
block|}
operator|*
name|bpos
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|mp
operator|->
name|m_len
expr_stmt|;
operator|*
name|mq
operator|=
name|mp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

