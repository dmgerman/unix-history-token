begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999, Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  * Core of NCP protocol  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPX
end_ifdef

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netncp/ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_conn.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_sock.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_subr.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_ncp.h>
end_include

begin_include
include|#
directive|include
file|<netncp/ncp_rq.h>
end_include

begin_include
include|#
directive|include
file|<netncp/nwerror.h>
end_include

begin_function_decl
specifier|static
name|int
name|ncp_do_request
parameter_list|(
name|struct
name|ncp_conn
modifier|*
parameter_list|,
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncp_negotiate_buffersize
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ncp_renegotiate_connparam
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|int
name|buffsize
parameter_list|,
name|int
name|in_options
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ncp_sign_packet
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NCP_DATA_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|m_dumpm
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|printf
argument_list|(
literal|"d="
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|printf
argument_list|(
literal|"(%d)"
argument_list|,
name|len
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
operator|(
name|int
operator|)
operator|*
operator|(
name|p
operator|++
operator|)
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
empty_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NCP_DATA_DEBUG */
end_comment

begin_function
name|int
name|ncp_chkintr
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|sigset_t
name|tmpset
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|tmpset
operator|=
name|p
operator|->
name|p_siglist
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigmask
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|tmpset
argument_list|,
name|p
operator|->
name|p_sigignore
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGNOTEMPTY
argument_list|(
name|p
operator|->
name|p_siglist
argument_list|)
operator|&&
name|NCP_SIGMASK
argument_list|(
name|tmpset
argument_list|)
condition|)
return|return
name|EINTR
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process initial NCP handshake (attach)  * NOTE: Since all functions below may change conn attributes, they  * should be called with LOCKED connection, also they use procp& ucred  */
end_comment

begin_function
name|int
name|ncp_ncp_connect
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ncp_rphdr
modifier|*
name|rp
decl_stmt|;
name|DECLARE_RQ
expr_stmt|;
name|conn
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NCPFL_INVALID
operator||
name|NCPFL_SIGNACTIVE
operator||
name|NCPFL_SIGNWANTED
operator|)
expr_stmt|;
name|conn
operator|->
name|seq
operator|=
literal|0
expr_stmt|;
name|checkbad
argument_list|(
name|ncp_rq_head
argument_list|(
name|rqp
argument_list|,
name|NCP_ALLOC_SLOT
argument_list|,
literal|0
argument_list|,
name|conn
operator|->
name|procp
argument_list|,
name|conn
operator|->
name|ucred
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncp_do_request
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|rp
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|rp
argument_list|,
expr|struct
name|ncp_rphdr
operator|*
argument_list|)
expr_stmt|;
name|conn
operator|->
name|connid
operator|=
name|rp
operator|->
name|conn_low
operator|+
operator|(
name|rp
operator|->
name|conn_high
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
name|ncp_rq_done
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|conn
operator|->
name|flags
operator||=
name|NCPFL_ATTACHED
expr_stmt|;
name|error
operator|=
name|ncp_renegotiate_connparam
argument_list|(
name|conn
argument_list|,
name|NCP_DEFAULT_BUFSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NWE_SIGNATURE_LEVEL_CONFLICT
condition|)
block|{
name|printf
argument_list|(
literal|"Unable to negotiate requested security level\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|ncp_ncp_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
ifdef|#
directive|ifdef
name|NCPBURST
name|ncp_burst_connect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bad
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ncp_ncp_disconnect
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ncp_rqhdr
modifier|*
name|ncprq
decl_stmt|;
name|DECLARE_RQ
expr_stmt|;
name|NCPSDEBUG
argument_list|(
literal|"for connid=%d\n"
argument_list|,
name|conn
operator|->
name|nc_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NCPBURST
name|ncp_burst_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ncp_rq_head
argument_list|(
name|rqp
argument_list|,
name|NCP_FREE_SLOT
argument_list|,
literal|0
argument_list|,
name|conn
operator|->
name|procp
argument_list|,
name|conn
operator|->
name|ucred
argument_list|)
expr_stmt|;
name|ncprq
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|rq
argument_list|,
expr|struct
name|ncp_rqhdr
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncp_do_request
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|)
expr_stmt|;
name|ncp_rq_done
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|ncp_conn_invalidate
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|ncp_sock_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Make a signature for the current packet and add it at the end of the  * packet.  */
end_comment

begin_function
specifier|static
name|void
name|ncp_sign_packet
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
name|u_char
name|data
index|[
literal|64
index|]
decl_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|conn
operator|->
name|sign_root
argument_list|,
name|data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|setdle
argument_list|(
name|data
argument_list|,
literal|8
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|rqp
operator|->
name|rq
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ncp_rqhdr
argument_list|)
operator|-
literal|1
argument_list|,
name|min
argument_list|(
operator|(
operator|*
name|size
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ncp_rqhdr
argument_list|)
operator|+
literal|1
argument_list|,
literal|52
argument_list|)
argument_list|,
name|data
operator|+
literal|12
argument_list|)
expr_stmt|;
name|ncp_sign
argument_list|(
name|conn
operator|->
name|sign_state
argument_list|,
name|data
argument_list|,
name|conn
operator|->
name|sign_state
argument_list|)
expr_stmt|;
name|ncp_rq_mem
argument_list|(
name|rqp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|conn
operator|->
name|sign_state
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|(
operator|*
name|size
operator|)
operator|+=
literal|8
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Low level send rpc, here we do not attempt to restore any connection,  * Connection expected to be locked  */
end_comment

begin_function
specifier|static
name|int
name|ncp_do_request
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|int
name|error
init|=
name|EIO
decl_stmt|,
name|len
decl_stmt|,
name|dosend
decl_stmt|,
name|plen
init|=
literal|0
decl_stmt|,
name|gotpacket
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|conn
operator|->
name|procp
decl_stmt|;
name|struct
name|ncp_rqhdr
modifier|*
name|rq
decl_stmt|;
name|struct
name|ncp_rphdr
modifier|*
name|rp
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mreply
init|=
name|NULL
decl_stmt|;
name|conn
operator|->
name|nc_rq
operator|=
name|rqp
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|curproc
expr_stmt|;
comment|/* XXX maybe procpage ? */
if|if
condition|(
operator|!
name|ncp_conn_valid
argument_list|(
name|conn
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: conn not valid\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|so
operator|=
name|conn
operator|->
name|ncp_so
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ncp_so is NULL !\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|ncp_conn_invalidate
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* wow ! how we do that ? */
return|return
name|EBADF
return|;
block|}
comment|/* 	 * Flush out replies on previous reqs 	 */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
comment|/*so->so_rcv.sb_cc*/
condition|)
block|{
if|if
condition|(
name|ncp_poll
argument_list|(
name|so
argument_list|,
name|POLLIN
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ncp_sock_recv
argument_list|(
name|so
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|len
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|rq
operator|=
name|mtod
argument_list|(
name|rqp
operator|->
name|rq
argument_list|,
expr|struct
name|ncp_rqhdr
operator|*
argument_list|)
expr_stmt|;
name|rq
operator|->
name|seq
operator|=
name|conn
operator|->
name|seq
expr_stmt|;
name|m
operator|=
name|rqp
operator|->
name|rq
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|rqp
operator|->
name|rq
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
switch|switch
condition|(
name|rq
operator|->
name|fn
condition|)
block|{
case|case
literal|0x15
case|:
case|case
literal|0x16
case|:
case|case
literal|0x17
case|:
case|case
literal|0x23
case|:
name|m
operator|=
name|rqp
operator|->
name|rq
expr_stmt|;
operator|*
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rq
argument_list|)
operator|)
operator|)
operator|=
name|htons
argument_list|(
name|len
operator|-
literal|2
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|rq
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|conn
operator|->
name|flags
operator|&
name|NCPFL_SIGNACTIVE
condition|)
block|{
name|ncp_sign_packet
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
block|}
name|rq
operator|->
name|conn_low
operator|=
name|conn
operator|->
name|connid
operator|&
literal|0xff
expr_stmt|;
comment|/* rq->task = p->p_pgrp->pg_id& 0xff; */
comment|/*p->p_pid*/
comment|/* XXX: this is temporary fix till I find a better solution */
name|rq
operator|->
name|task
operator|=
name|rq
operator|->
name|conn_low
expr_stmt|;
name|rq
operator|->
name|conn_high
operator|=
name|conn
operator|->
name|connid
operator|>>
literal|8
expr_stmt|;
name|rqp
operator|->
name|rexmit
operator|=
name|conn
operator|->
name|li
operator|.
name|retry_count
expr_stmt|;
for|for
control|(
name|dosend
operator|=
literal|1
init|;
condition|;
control|)
block|{
if|if
condition|(
name|rqp
operator|->
name|rexmit
operator|--
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dosend
condition|)
block|{
name|NCPSDEBUG
argument_list|(
literal|"send:%04x f=%02x c=%d l=%d s=%d t=%d\n"
argument_list|,
name|rq
operator|->
name|type
argument_list|,
name|rq
operator|->
name|fn
argument_list|,
operator|(
name|rq
operator|->
name|conn_high
operator|<<
literal|8
operator|)
operator|+
name|rq
operator|->
name|conn_low
argument_list|,
name|rqp
operator|->
name|rq
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|rq
operator|->
name|seq
argument_list|,
name|rq
operator|->
name|task
argument_list|)
expr_stmt|;
name|error
operator|=
name|ncp_sock_send
argument_list|(
name|so
argument_list|,
name|rqp
operator|->
name|rq
argument_list|,
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|conn
operator|->
name|li
operator|.
name|timeout
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ncp_sock_rselect
argument_list|(
name|so
argument_list|,
name|p
argument_list|,
operator|&
name|tv
argument_list|,
name|POLLIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
comment|/* timeout expired */
continue|continue;
name|error
operator|=
name|ncp_chkintr
argument_list|(
name|conn
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
comment|/* we dont restart */
break|break;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * At this point it is possible to get more than one 		 * reply from server. In general, last reply should be for 		 * current request, but not always. So, we loop through 		 * all replies to find the right answer and flush others. 		 */
name|gotpacket
operator|=
literal|0
expr_stmt|;
comment|/* nothing good found */
name|dosend
operator|=
literal|1
expr_stmt|;
comment|/* resend rq if error */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ncp_poll
argument_list|(
name|so
argument_list|,
name|POLLIN
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/*			if (so->so_rcv.sb_cc == 0) { 				break; 			}*/
name|error
operator|=
name|ncp_sock_recv
argument_list|(
name|so
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* must be more checks !!! */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: reply too short\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|rp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ncp_rphdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
operator|&&
name|rp
operator|->
name|type
operator|==
name|NCP_POSITIVE_ACK
condition|)
block|{
name|NCPSDEBUG
argument_list|(
literal|"got positive acknowledge\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rexmit
operator|=
name|conn
operator|->
name|li
operator|.
name|retry_count
expr_stmt|;
name|dosend
operator|=
literal|0
expr_stmt|;
comment|/* server just busy and will reply ASAP */
continue|continue;
block|}
name|NCPSDEBUG
argument_list|(
literal|"recv:%04x c=%d l=%d s=%d t=%d cc=%02x cs=%02x\n"
argument_list|,
name|rp
operator|->
name|type
argument_list|,
operator|(
name|rp
operator|->
name|conn_high
operator|<<
literal|8
operator|)
operator|+
name|rp
operator|->
name|conn_low
argument_list|,
name|len
argument_list|,
name|rp
operator|->
name|seq
argument_list|,
name|rp
operator|->
name|task
argument_list|,
name|rp
operator|->
name|completion_code
argument_list|,
name|rp
operator|->
name|connection_state
argument_list|)
expr_stmt|;
name|NCPDDEBUG
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rp
operator|->
name|type
operator|==
name|NCP_REPLY
operator|)
operator|&&
operator|(
operator|(
name|rq
operator|->
name|type
operator|==
name|NCP_ALLOC_SLOT
operator|)
operator|||
operator|(
operator|(
name|rp
operator|->
name|conn_low
operator|==
name|rq
operator|->
name|conn_low
operator|)
operator|&&
operator|(
name|rp
operator|->
name|conn_high
operator|==
name|rq
operator|->
name|conn_high
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|rq
operator|->
name|seq
operator|>
name|rp
operator|->
name|seq
operator|||
operator|(
name|rq
operator|->
name|seq
operator|==
literal|0
operator|&&
name|rp
operator|->
name|seq
operator|==
literal|0xff
operator|)
condition|)
block|{
name|dosend
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rp
operator|->
name|seq
operator|==
name|rq
operator|->
name|seq
condition|)
block|{
if|if
condition|(
name|gotpacket
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|gotpacket
operator|=
literal|1
expr_stmt|;
name|mreply
operator|=
name|m
expr_stmt|;
name|plen
operator|=
name|len
expr_stmt|;
block|}
continue|continue;
comment|/* look up other for other packets */
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NCPSDEBUG
argument_list|(
literal|"reply mismatch\n"
argument_list|)
expr_stmt|;
block|}
comment|/* for receive */
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|gotpacket
condition|)
break|break;
comment|/* try to resend, or just wait */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|conn
operator|->
name|seq
operator|++
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NCPSDEBUG
argument_list|(
literal|"error=%d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EINTR
condition|)
comment|/* if not just interrupt */
name|ncp_conn_invalidate
argument_list|(
name|conn
argument_list|)
expr_stmt|;
comment|/* only reconnect to restore */
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|conn
operator|->
name|flags
operator|&
name|NCPFL_SIGNACTIVE
condition|)
block|{
comment|/* XXX: check reply signature */
name|m_adj
argument_list|(
name|mreply
argument_list|,
operator|-
literal|8
argument_list|)
expr_stmt|;
name|plen
operator|-=
literal|8
expr_stmt|;
block|}
name|len
operator|=
name|plen
expr_stmt|;
name|m
operator|=
name|mreply
expr_stmt|;
name|rp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ncp_rphdr
operator|*
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rpsize
operator|=
name|len
expr_stmt|;
name|rqp
operator|->
name|cc
operator|=
name|error
operator|=
name|rp
operator|->
name|completion_code
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|error
operator||=
literal|0x8900
expr_stmt|;
comment|/* server error */
name|rqp
operator|->
name|cs
operator|=
name|rp
operator|->
name|connection_state
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|cs
operator|&
operator|(
name|NCP_CS_BAD_CONN
operator||
name|NCP_CS_SERVER_DOWN
operator|)
condition|)
block|{
name|NCPSDEBUG
argument_list|(
literal|"server drop us\n"
argument_list|)
expr_stmt|;
name|ncp_conn_invalidate
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
name|rqp
operator|->
name|rp
operator|=
name|m
expr_stmt|;
name|rqp
operator|->
name|mrp
operator|=
name|m
expr_stmt|;
name|rqp
operator|->
name|bpos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|rp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Here we will try to restore any loggedin& dropped connection,  * connection should be locked on entry  */
end_comment

begin_function_decl
name|int
name|ncp_restore_login
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|ncp_restore_login
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|oldflags
decl_stmt|;
if|if
condition|(
name|conn
operator|->
name|flags
operator|&
name|NCPFL_RESTORING
condition|)
block|{
name|printf
argument_list|(
literal|"Hey, ncp_restore_login called twise !!!\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|oldflags
operator|=
name|conn
operator|->
name|flags
expr_stmt|;
name|printf
argument_list|(
literal|"Restoring connection, flags = %d\n"
argument_list|,
name|oldflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|NCPFL_LOGGED
operator|)
operator|==
literal|0
condition|)
block|{
return|return
name|ECONNRESET
return|;
comment|/* no need to restore empty conn */
block|}
name|conn
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NCPFL_LOGGED
operator||
name|NCPFL_ATTACHED
operator|)
expr_stmt|;
name|conn
operator|->
name|flags
operator||=
name|NCPFL_RESTORING
expr_stmt|;
do|do
block|{
comment|/* not a loop */
name|error
operator|=
name|ncp_reconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|conn
operator|->
name|li
operator|.
name|user
condition|)
name|error
operator|=
name|ncp_login_object
argument_list|(
name|conn
argument_list|,
name|conn
operator|->
name|li
operator|.
name|user
argument_list|,
name|conn
operator|->
name|li
operator|.
name|objtype
argument_list|,
name|conn
operator|->
name|li
operator|.
name|password
argument_list|,
name|conn
operator|->
name|procp
argument_list|,
name|conn
operator|->
name|ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|conn
operator|->
name|flags
operator||=
name|NCPFL_LOGGED
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|error
condition|)
block|{
name|conn
operator|->
name|flags
operator|=
name|oldflags
operator||
name|NCPFL_INVALID
expr_stmt|;
block|}
name|conn
operator|->
name|flags
operator|&=
operator|~
name|NCPFL_RESTORING
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|ncp_request
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|struct
name|ncp_rq
modifier|*
name|rqp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|rcnt
decl_stmt|;
comment|/*	struct ncp_rqhdr *rq = mtod(rqp->rq,struct ncp_rqhdr*);*/
name|error
operator|=
name|ncp_conn_lock
argument_list|(
name|conn
argument_list|,
name|rqp
operator|->
name|p
argument_list|,
name|rqp
operator|->
name|cred
argument_list|,
name|NCPM_EXECUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|rcnt
operator|=
name|NCP_RESTORE_COUNT
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|ncp_conn_valid
argument_list|(
name|conn
argument_list|)
condition|)
block|{
if|if
condition|(
name|rcnt
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
break|break;
block|}
name|rcnt
operator|--
expr_stmt|;
name|error
operator|=
name|ncp_restore_login
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
block|}
name|error
operator|=
name|ncp_do_request
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncp_conn_valid
argument_list|(
name|conn
argument_list|)
condition|)
comment|/* not just error ! */
break|break;
block|}
name|ncp_conn_unlock
argument_list|(
name|conn
argument_list|,
name|rqp
operator|->
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * All negotiation functions expect a locked connection  */
end_comment

begin_function
specifier|static
name|int
name|ncp_negotiate_buffersize
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|int
name|size
parameter_list|,
name|int
modifier|*
name|target
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|DECLARE_RQ
expr_stmt|;
name|NCP_RQ_HEAD
argument_list|(
literal|0x21
argument_list|,
name|conn
operator|->
name|procp
argument_list|,
name|conn
operator|->
name|ucred
argument_list|)
expr_stmt|;
name|ncp_rq_word_hl
argument_list|(
name|rqp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|checkbad
argument_list|(
name|ncp_request
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target
operator|=
name|min
argument_list|(
name|ncp_rp_word_hl
argument_list|(
name|rqp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|NCP_RQ_EXIT
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ncp_negotiate_size_and_options
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|options
parameter_list|,
name|int
modifier|*
name|ret_size
parameter_list|,
name|int
modifier|*
name|ret_options
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|rs
decl_stmt|;
name|DECLARE_RQ
expr_stmt|;
name|NCP_RQ_HEAD
argument_list|(
literal|0x61
argument_list|,
name|conn
operator|->
name|procp
argument_list|,
name|conn
operator|->
name|ucred
argument_list|)
expr_stmt|;
name|ncp_rq_word_hl
argument_list|(
name|rqp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ncp_rq_byte
argument_list|(
name|rqp
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|checkbad
argument_list|(
name|ncp_request
argument_list|(
name|conn
argument_list|,
name|rqp
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ncp_rp_word_hl
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
operator|*
name|ret_size
operator|=
operator|(
name|rs
operator|==
literal|0
operator|)
condition|?
name|size
else|:
name|min
argument_list|(
name|rs
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ncp_rp_word_hl
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
comment|/* skip echo socket */
operator|*
name|ret_options
operator|=
name|ncp_rp_byte
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|NCP_RQ_EXIT
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ncp_renegotiate_connparam
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|,
name|int
name|buffsize
parameter_list|,
name|int
name|in_options
parameter_list|)
block|{
name|int
name|neg_buffsize
decl_stmt|,
name|error
decl_stmt|,
name|options
decl_stmt|,
name|sl
decl_stmt|;
name|sl
operator|=
name|conn
operator|->
name|li
operator|.
name|sig_level
expr_stmt|;
if|if
condition|(
name|sl
operator|>=
literal|2
condition|)
name|in_options
operator||=
name|NCP_SECURITY_LEVEL_SIGN_HEADERS
expr_stmt|;
ifdef|#
directive|ifdef
name|IPX
if|if
condition|(
name|ipxcksum
operator|==
literal|2
condition|)
name|in_options
operator||=
name|NCP_IPX_CHECKSUM
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ncp_negotiate_size_and_options
argument_list|(
name|conn
argument_list|,
name|buffsize
argument_list|,
name|in_options
argument_list|,
operator|&
name|neg_buffsize
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|IPX
if|if
condition|(
operator|(
name|options
operator|^
name|in_options
operator|)
operator|&
name|NCP_IPX_CHECKSUM
condition|)
block|{
if|if
condition|(
name|ipxcksum
operator|==
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"Server refuses to support IPX checksums\n"
argument_list|)
expr_stmt|;
return|return
name|NWE_REQUESTER_FAILURE
return|;
block|}
name|in_options
operator||=
name|NCP_IPX_CHECKSUM
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPX */
if|if
condition|(
operator|(
name|options
operator|^
name|in_options
operator|)
operator|&
literal|2
condition|)
block|{
if|if
condition|(
name|sl
operator|==
literal|0
operator|||
name|sl
operator|==
literal|3
condition|)
return|return
name|NWE_SIGNATURE_LEVEL_CONFLICT
return|;
if|if
condition|(
name|sl
operator|==
literal|1
condition|)
block|{
name|in_options
operator||=
name|NCP_SECURITY_LEVEL_SIGN_HEADERS
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|ncp_negotiate_size_and_options
argument_list|(
name|conn
argument_list|,
name|buffsize
argument_list|,
name|in_options
argument_list|,
operator|&
name|neg_buffsize
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|^
name|in_options
operator|)
operator|&
literal|3
condition|)
block|{
return|return
name|NWE_SIGNATURE_LEVEL_CONFLICT
return|;
block|}
block|}
block|}
else|else
block|{
name|in_options
operator|&=
operator|~
name|NCP_SECURITY_LEVEL_SIGN_HEADERS
expr_stmt|;
name|error
operator|=
name|ncp_negotiate_buffersize
argument_list|(
name|conn
argument_list|,
name|NCP_DEFAULT_BUFSIZE
argument_list|,
operator|&
name|neg_buffsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|neg_buffsize
operator|<
literal|512
operator|)
operator|||
operator|(
name|neg_buffsize
operator|>
name|NCP_MAX_BUFSIZE
operator|)
condition|)
return|return
name|EINVAL
return|;
name|conn
operator|->
name|buffer_size
operator|=
name|neg_buffsize
expr_stmt|;
if|if
condition|(
name|in_options
operator|&
name|NCP_SECURITY_LEVEL_SIGN_HEADERS
condition|)
name|conn
operator|->
name|flags
operator||=
name|NCPFL_SIGNWANTED
expr_stmt|;
ifdef|#
directive|ifdef
name|IPX
name|ncp_sock_checksum
argument_list|(
name|conn
argument_list|,
name|in_options
operator|&
name|NCP_IPX_CHECKSUM
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ncp_reconnect
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* close any open sockets */
name|ncp_sock_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|conn
operator|->
name|li
operator|.
name|saddr
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|IPX
case|case
name|AF_IPX
case|:
name|error
operator|=
name|ncp_sock_connect_ipx
argument_list|(
name|conn
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|error
operator|=
name|ncp_sock_connect_in
argument_list|(
name|conn
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|EPROTONOSUPPORT
return|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|ncp_ncp_connect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Create conn structure and try to do low level connect  * Server addr should be filled in.  */
end_comment

begin_function
name|int
name|ncp_connect
parameter_list|(
name|struct
name|ncp_conn_args
modifier|*
name|li
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|ncp_conn
modifier|*
modifier|*
name|aconn
parameter_list|)
block|{
name|struct
name|ncp_conn
modifier|*
name|conn
decl_stmt|;
name|struct
name|ucred
modifier|*
name|owner
decl_stmt|;
name|int
name|error
decl_stmt|,
name|isroot
decl_stmt|;
if|if
condition|(
name|li
operator|->
name|saddr
operator|.
name|sa_family
operator|!=
name|AF_INET
operator|&&
name|li
operator|->
name|saddr
operator|.
name|sa_family
operator|!=
name|AF_IPX
condition|)
return|return
name|EPROTONOSUPPORT
return|;
name|isroot
operator|=
name|ncp_suser
argument_list|(
name|cred
argument_list|)
operator|==
literal|0
expr_stmt|;
comment|/* 	 * Only root can change ownership 	 */
if|if
condition|(
name|li
operator|->
name|owner
operator|!=
name|NCP_DEFAULT_OWNER
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|li
operator|->
name|group
operator|!=
name|NCP_DEFAULT_GROUP
operator|&&
operator|!
name|groupmember
argument_list|(
name|li
operator|->
name|group
argument_list|,
name|cred
argument_list|)
operator|&&
operator|!
name|isroot
condition|)
return|return
name|EPERM
return|;
if|if
condition|(
name|li
operator|->
name|owner
operator|!=
name|NCP_DEFAULT_OWNER
condition|)
block|{
name|owner
operator|=
name|crget
argument_list|()
expr_stmt|;
name|owner
operator|->
name|cr_uid
operator|=
name|li
operator|->
name|owner
expr_stmt|;
block|}
else|else
block|{
name|owner
operator|=
name|cred
expr_stmt|;
name|crhold
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ncp_conn_alloc
argument_list|(
name|p
argument_list|,
name|owner
argument_list|,
operator|&
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|ncp_conn_free
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|conn
operator|->
name|li
operator|=
operator|*
name|li
expr_stmt|;
name|conn
operator|->
name|nc_group
operator|=
operator|(
name|li
operator|->
name|group
operator|!=
name|NCP_DEFAULT_GROUP
operator|)
condition|?
name|li
operator|->
name|group
else|:
name|cred
operator|->
name|cr_groups
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|retry_count
operator|==
literal|0
condition|)
name|conn
operator|->
name|li
operator|.
name|retry_count
operator|=
name|NCP_RETRY_COUNT
expr_stmt|;
if|if
condition|(
name|li
operator|->
name|timeout
operator|==
literal|0
condition|)
name|conn
operator|->
name|li
operator|.
name|timeout
operator|=
name|NCP_RETRY_TIMEOUT
expr_stmt|;
name|error
operator|=
name|ncp_reconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ncp_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|aconn
operator|=
name|conn
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Break connection and deallocate memory  */
end_comment

begin_function
name|int
name|ncp_disconnect
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
if|if
condition|(
name|ncp_conn_access
argument_list|(
name|conn
argument_list|,
name|conn
operator|->
name|ucred
argument_list|,
name|NCPM_WRITE
argument_list|)
condition|)
return|return
name|EACCES
return|;
if|if
condition|(
name|conn
operator|->
name|ref_cnt
operator|!=
literal|0
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|conn
operator|->
name|flags
operator|&
name|NCPFL_PERMANENT
condition|)
return|return
name|EBUSY
return|;
if|if
condition|(
name|ncp_conn_valid
argument_list|(
name|conn
argument_list|)
condition|)
block|{
name|ncp_ncp_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
block|}
name|ncp_sock_disconnect
argument_list|(
name|conn
argument_list|)
expr_stmt|;
name|ncp_conn_free
argument_list|(
name|conn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ncp_check_rq
parameter_list|(
name|struct
name|ncp_conn
modifier|*
name|conn
parameter_list|)
block|{
return|return;
if|if
condition|(
name|conn
operator|->
name|flags
operator|&
name|NCPFL_INTR
condition|)
return|return;
comment|/* first, check for signals */
if|if
condition|(
name|ncp_chkintr
argument_list|(
name|conn
argument_list|,
name|conn
operator|->
name|procp
argument_list|)
condition|)
block|{
name|conn
operator|->
name|flags
operator||=
name|NCPFL_INTR
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

