begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: installboot.c,v 1.5 1997/11/01 06:49:50 lukem Exp $	 */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994 Paul Kranenburg  * All rights reserved.  * Copyright (c) 1996, 1997  * 	Matthias Drochner.  All rights reserved.  * Copyright (c) 1996, 1997  * 	Perry E. Metzger.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Paul Kranenburg.  *	This product includes software developed for the NetBSD Project  *	by Matthias Drochner.  *	This product includes software developed for the NetBSD Project  *	by Perry E. Metzger.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_comment
comment|/* #include<sys/dkio.h> */
end_comment

begin_include
include|#
directive|include
file|<ufs/ufs/dinode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/dir.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ffs/fs.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"installboot.h"
end_include

begin_include
include|#
directive|include
file|"bbinfo.h"
end_include

begin_define
define|#
directive|define
name|DEFBBLKNAME
value|"boot"
end_define

begin_decl_stmt
name|struct
name|fraglist
modifier|*
name|fraglist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nlist
name|nl
index|[]
init|=
block|{
define|#
directive|define
name|X_fraglist
value|0
block|{
block|{
literal|"_fraglist"
block|}
block|}
block|,
block|{
block|{
name|NULL
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|verbose
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|loadprotoblocks
parameter_list|(
name|fname
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|long
modifier|*
name|size
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|;
name|size_t
name|tdsize
decl_stmt|;
comment|/* text+data size */
name|size_t
name|bbsize
decl_stmt|;
comment|/* boot block size (block aligned) */
name|char
modifier|*
name|bp
decl_stmt|;
name|struct
name|nlist
modifier|*
name|nlp
decl_stmt|;
name|struct
name|exec
name|eh
decl_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
comment|/* Locate block number array in proto file */
if|if
condition|(
name|nlist
argument_list|(
name|fname
argument_list|,
name|nl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"nlist: %s: symbols not found"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Validate symbol types (global text!). */
for|for
control|(
name|nlp
operator|=
name|nl
init|;
name|nlp
operator|->
name|n_un
operator|.
name|n_name
condition|;
name|nlp
operator|++
control|)
block|{
if|if
condition|(
name|nlp
operator|->
name|n_type
operator|!=
operator|(
name|N_TEXT
operator||
name|N_EXT
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"nlist: %s: wrong type"
argument_list|,
name|nlp
operator|->
name|n_un
operator|.
name|n_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|eh
argument_list|,
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"read: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|N_GETMAGIC
argument_list|(
name|eh
argument_list|)
operator|!=
name|OMAGIC
condition|)
block|{
name|warn
argument_list|(
literal|"bad magic: 0x%lx"
argument_list|,
name|eh
operator|.
name|a_midmag
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * We need only text and data. 	 */
name|tdsize
operator|=
name|eh
operator|.
name|a_text
operator|+
name|eh
operator|.
name|a_data
expr_stmt|;
name|bbsize
operator|=
name|roundup
argument_list|(
name|tdsize
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|calloc
argument_list|(
name|bbsize
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"malloc: %s: no memory"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* read the rest of the file. */
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|bp
argument_list|,
name|tdsize
argument_list|)
operator|!=
name|tdsize
condition|)
block|{
name|warn
argument_list|(
literal|"read: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|*
name|size
operator|=
name|bbsize
expr_stmt|;
comment|/* aligned to DEV_BSIZE */
name|fraglist
operator|=
operator|(
expr|struct
name|fraglist
operator|*
operator|)
operator|(
name|bp
operator|+
name|nl
index|[
name|X_fraglist
index|]
operator|.
name|n_value
operator|)
expr_stmt|;
if|if
condition|(
name|fraglist
operator|->
name|magic
operator|!=
name|FRAGLISTMAGIC
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid bootblock version"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: entry point %#lx\n"
argument_list|,
name|fname
argument_list|,
name|eh
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"proto bootblock size %ld\n"
argument_list|,
operator|*
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"room for %d filesystem blocks at %#lx\n"
argument_list|,
name|fraglist
operator|->
name|maxentries
argument_list|,
name|nl
index|[
name|X_fraglist
index|]
operator|.
name|n_value
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
name|bad
label|:
if|if
condition|(
name|bp
condition|)
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|devread
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|blk
parameter_list|,
name|size
parameter_list|,
name|msg
parameter_list|)
name|int
name|fd
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
block|{
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|dbtob
argument_list|(
name|blk
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
name|dbtob
argument_list|(
name|blk
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"%s: devread: lseek"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|warn
argument_list|(
literal|"%s: devread: read"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* add file system blocks to fraglist */
end_comment

begin_function
specifier|static
name|int
name|add_fsblk
parameter_list|(
name|fs
parameter_list|,
name|blk
parameter_list|,
name|blcnt
parameter_list|)
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|;
name|int
name|blcnt
decl_stmt|;
block|{
name|int
name|nblk
decl_stmt|;
comment|/* convert to disk blocks */
name|blk
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blk
argument_list|)
expr_stmt|;
name|nblk
operator|=
name|fs
operator|->
name|fs_bsize
operator|/
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|nblk
operator|>
name|blcnt
condition|)
name|nblk
operator|=
name|blcnt
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dblk: %d, num: %d\n"
argument_list|,
name|blk
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
comment|/* start new entry or append to previous? */
if|if
condition|(
operator|!
name|fraglist
operator|->
name|numentries
operator|||
operator|(
name|fraglist
operator|->
name|entries
index|[
name|fraglist
operator|->
name|numentries
operator|-
literal|1
index|]
operator|.
name|offset
operator|+
name|fraglist
operator|->
name|entries
index|[
name|fraglist
operator|->
name|numentries
operator|-
literal|1
index|]
operator|.
name|num
operator|!=
name|blk
operator|)
condition|)
block|{
comment|/* need new entry */
if|if
condition|(
name|fraglist
operator|->
name|numentries
operator|>
name|fraglist
operator|->
name|maxentries
operator|-
literal|1
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"not enough fragment space in bootcode\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fraglist
operator|->
name|entries
index|[
name|fraglist
operator|->
name|numentries
index|]
operator|.
name|offset
operator|=
name|blk
expr_stmt|;
name|fraglist
operator|->
name|entries
index|[
name|fraglist
operator|->
name|numentries
operator|++
index|]
operator|.
name|num
operator|=
literal|0
expr_stmt|;
block|}
name|fraglist
operator|->
name|entries
index|[
name|fraglist
operator|->
name|numentries
operator|-
literal|1
index|]
operator|.
name|num
operator|+=
name|nblk
expr_stmt|;
return|return
operator|(
name|blcnt
operator|-
name|nblk
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|sblock
index|[
name|SBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|loadblocknums
parameter_list|(
name|diskdev
parameter_list|,
name|inode
parameter_list|)
name|char
modifier|*
name|diskdev
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
block|{
name|int
name|devfd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|fs
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|buf
init|=
literal|0
decl_stmt|;
name|daddr_t
name|blk
decl_stmt|,
modifier|*
name|ap
decl_stmt|;
name|struct
name|dinode
modifier|*
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ndb
decl_stmt|;
name|int
name|allok
init|=
literal|0
decl_stmt|;
name|devfd
operator|=
name|open
argument_list|(
name|diskdev
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open raw partition"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Read superblock */
if|if
condition|(
name|devread
argument_list|(
name|devfd
argument_list|,
name|sblock
argument_list|,
name|SBLOCK
argument_list|,
name|SBSIZE
argument_list|,
literal|"superblock"
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|fs
operator|=
operator|(
expr|struct
name|fs
operator|*
operator|)
name|sblock
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_magic
operator|!=
name|FS_MAGIC
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid super block"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Read inode */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|fs
operator|->
name|fs_bsize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"No memory for filesystem block"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|blk
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ino_to_fsba
argument_list|(
name|fs
argument_list|,
name|inode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devread
argument_list|(
name|devfd
argument_list|,
name|buf
argument_list|,
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|"inode"
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ip
operator|=
operator|(
expr|struct
name|dinode
operator|*
operator|)
operator|(
name|buf
operator|)
operator|+
name|ino_to_fsbo
argument_list|(
name|fs
argument_list|,
name|inode
argument_list|)
expr_stmt|;
comment|/* 	 * Have the inode.  Figure out how many blocks we need. 	 */
name|ndb
operator|=
name|ip
operator|->
name|di_size
operator|/
name|DEV_BSIZE
expr_stmt|;
comment|/* size is rounded! */
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Will load %d blocks.\n"
argument_list|,
name|ndb
argument_list|)
expr_stmt|;
comment|/* 	 * Get the block numbers, first direct blocks 	 */
name|ap
operator|=
name|ip
operator|->
name|di_db
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
operator|&&
operator|*
name|ap
operator|&&
name|ndb
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
name|ndb
operator|=
name|add_fsblk
argument_list|(
name|fs
argument_list|,
operator|*
name|ap
argument_list|,
name|ndb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndb
operator|>
literal|0
condition|)
block|{
comment|/* 	         * Just one level of indirections; there isn't much room 	         * for more in the 1st-level bootblocks anyway. 	         */
name|blk
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|ip
operator|->
name|di_ib
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|devread
argument_list|(
name|devfd
argument_list|,
name|buf
argument_list|,
name|blk
argument_list|,
name|fs
operator|->
name|fs_bsize
argument_list|,
literal|"indirect block"
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|ap
operator|=
operator|(
name|daddr_t
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|NINDIR
argument_list|(
name|fs
argument_list|)
operator|&&
operator|*
name|ap
operator|&&
name|ndb
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|ap
operator|++
control|)
block|{
name|ndb
operator|=
name|add_fsblk
argument_list|(
name|fs
argument_list|,
operator|*
name|ap
argument_list|,
name|ndb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|ndb
condition|)
name|allok
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ndb
operator|>
literal|0
condition|)
name|warnx
argument_list|(
literal|"too many fs blocks"
argument_list|)
expr_stmt|;
comment|/* else, ie ndb< 0, add_fsblk returned error */
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|devfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|allok
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: installboot [-n] [-v] [-f]<boot><device>\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
name|long
name|size
decl_stmt|;
name|ino_t
name|inode
init|=
operator|(
name|ino_t
operator|)
operator|-
literal|1
decl_stmt|;
name|int
name|devfd
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|disklabel
name|dl
decl_stmt|;
name|int
name|bsdoffs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
decl_stmt|;
name|int
name|forceifnolabel
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bootblkname
init|=
name|DEFBBLKNAME
decl_stmt|;
name|int
name|nowrite
init|=
literal|0
decl_stmt|;
name|int
name|allok
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vnf"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'n'
case|:
comment|/* Do not actually write the bootblock to disk */
name|nowrite
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
comment|/* Chat */
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* assume zero offset if no disklabel */
name|forceifnolabel
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|argc
operator|-
name|optind
operator|!=
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|bp
operator|=
name|loadprotoblocks
argument_list|(
name|argv
index|[
name|optind
index|]
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"error reading bootblocks"
argument_list|)
expr_stmt|;
name|fraglist
operator|->
name|numentries
operator|=
literal|0
expr_stmt|;
comment|/* do we need the fraglist? */
if|if
condition|(
name|size
operator|>
name|fraglist
operator|->
name|loadsz
operator|*
name|DEV_BSIZE
condition|)
block|{
name|inode
operator|=
name|createfileondev
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|bootblkname
argument_list|,
name|bp
operator|+
name|fraglist
operator|->
name|loadsz
operator|*
name|DEV_BSIZE
argument_list|,
name|size
operator|-
name|fraglist
operator|->
name|loadsz
operator|*
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|==
operator|(
name|ino_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
comment|/* paranoia */
name|sync
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|loadblocknums
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|inode
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|size
operator|=
name|fraglist
operator|->
name|loadsz
operator|*
name|DEV_BSIZE
expr_stmt|;
comment|/* size to be written to bootsect */
block|}
name|devfd
operator|=
name|open
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devfd
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"open raw partition RW"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|devfd
argument_list|,
name|DIOCGDINFO
argument_list|,
operator|&
name|dl
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
operator|||
operator|(
name|errno
operator|==
name|ENOTTY
operator|)
condition|)
block|{
if|if
condition|(
name|forceifnolabel
condition|)
name|bsdoffs
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|warnx
argument_list|(
literal|"no disklabel, use -f to install anyway"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|warn
argument_list|(
literal|"get disklabel"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|char
name|c
init|=
name|argv
index|[
name|optind
operator|+
literal|1
index|]
index|[
name|strlen
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
operator|-
literal|1
index|]
decl_stmt|;
define|#
directive|define
name|isvalidpart
parameter_list|(
name|c
parameter_list|)
value|((c)>= 'a'&& (c)<= 'z')
if|if
condition|(
operator|!
name|isvalidpart
argument_list|(
name|c
argument_list|)
operator|||
operator|(
name|c
operator|-
literal|'a'
operator|)
operator|>=
name|dl
operator|.
name|d_npartitions
condition|)
block|{
name|warnx
argument_list|(
literal|"invalid partition"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bsdoffs
operator|=
name|dl
operator|.
name|d_partitions
index|[
name|c
operator|-
literal|'a'
index|]
operator|.
name|p_offset
expr_stmt|;
block|}
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BSD partition starts at sector %d\n"
argument_list|,
name|bsdoffs
argument_list|)
expr_stmt|;
comment|/*          * add offset of BSD partition to fraglist entries          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fraglist
operator|->
name|numentries
condition|;
name|i
operator|++
control|)
name|fraglist
operator|->
name|entries
index|[
name|i
index|]
operator|.
name|offset
operator|+=
name|bsdoffs
expr_stmt|;
if|if
condition|(
operator|!
name|nowrite
condition|)
block|{
comment|/* 	         * write first blocks (max loadsz) to start of BSD partition, 	         * skip disklabel (in second disk block) 	         */
name|lseek
argument_list|(
name|devfd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|res
operator|=
name|write
argument_list|(
name|devfd
argument_list|,
name|bp
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"final write1"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lseek
argument_list|(
name|devfd
argument_list|,
literal|2
operator|*
name|DEV_BSIZE
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|res
operator|=
name|write
argument_list|(
name|devfd
argument_list|,
name|bp
operator|+
literal|2
operator|*
name|DEV_BSIZE
argument_list|,
name|size
operator|-
literal|2
operator|*
name|DEV_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"final write2"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|allok
operator|=
literal|1
expr_stmt|;
name|out
label|:
if|if
condition|(
name|devfd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|devfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|!=
operator|(
name|ino_t
operator|)
operator|-
literal|1
condition|)
block|{
name|cleanupfileondev
argument_list|(
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
name|bootblkname
argument_list|,
operator|!
name|allok
operator|||
name|nowrite
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|allok
operator|)
return|;
block|}
end_function

end_unit

