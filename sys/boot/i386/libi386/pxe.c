begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000 Alfred Perlstein<alfred@freebsd.org>  * All rights reserved.  * Copyright (c) 2000 Paul Saab<ps@freebsd.org>  * All rights reserved.  * Copyright (c) 2000 John Baldwin<jhb@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * The typedefs and structures declared in this file  * clearly violate style(9), the reason for this is to conform to the  * typedefs/structure-names used in the Intel literature to avoid confusion.  *  * It's for your own good. :)  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<arpa/tftp.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<bootstrap.h>
end_include

begin_include
include|#
directive|include
file|"btxv86.h"
end_include

begin_define
define|#
directive|define
name|PXENV_GET_CACHED_INFO
value|0x0071
end_define

begin_define
define|#
directive|define
name|PXENV_TFTP_OPEN
value|0x0020
end_define

begin_define
define|#
directive|define
name|PXENV_TFTP_CLOSE
value|0x0021
end_define

begin_define
define|#
directive|define
name|PXENV_TFTP_READ
value|0x0022
end_define

begin_comment
comment|/*  * Allocate the PXE buffers statically instead of sticking grimy fingers into  * BTX's private data area.  The scratch buffer is used to send information to  * the PXE BIOS, and the data buffer is used to receive data from the PXE BIOS.  */
end_comment

begin_define
define|#
directive|define
name|PXE_BUFFER_SIZE
value|0x2000
end_define

begin_define
define|#
directive|define
name|PXE_TFTP_BUFFER_SIZE
value|512
end_define

begin_decl_stmt
name|char
name|scratch_buffer
index|[
name|PXE_BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|data_buffer
index|[
name|PXE_BUFFER_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|S_SIZE
parameter_list|(
name|s
parameter_list|)
value|s, sizeof(s) - 1
end_define

begin_define
define|#
directive|define
name|IP_STR
value|"%d.%d.%d.%d"
end_define

begin_define
define|#
directive|define
name|IP_ARGS
parameter_list|(
name|ip
parameter_list|)
define|\
value|(int)(ip>> 24)& 0xff, (int)(ip>> 16)& 0xff, \ 	(int)(ip>> 8)& 0xff, (int)ip& 0xff
end_define

begin_define
define|#
directive|define
name|MAC_STR
value|"%02x:%02x:%02x:%02x:%02x:%02x"
end_define

begin_define
define|#
directive|define
name|MAC_ARGS
parameter_list|(
name|mac
parameter_list|)
define|\
value|mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint16_t
name|offset
decl_stmt|;
name|uint16_t
name|segment
decl_stmt|;
block|}
name|SEGOFF16_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|PXENV_STATUS
typedef|;
end_typedef

begin_struct
struct|struct
name|pxenv
block|{
name|char
name|Signature
index|[
literal|6
index|]
decl_stmt|;
comment|/* 'PXENV+' */
name|uint16_t
name|Version
decl_stmt|;
comment|/* MSB = major, LSB = minor */
name|uint8_t
name|Length
decl_stmt|;
comment|/* structure length */
name|uint8_t
name|Checksum
decl_stmt|;
comment|/* checksum pad */
name|SEGOFF16_t
name|RMEntry
decl_stmt|;
comment|/* SEG:OFF to PXE entry point */
comment|/* don't use PMOffset and PMSelector (from the 2.1 PXE manual) */
name|uint32_t
name|PMOffset
decl_stmt|;
comment|/* Protected mode entry */
name|uint16_t
name|PMSelector
decl_stmt|;
comment|/* Protected mode selector */
name|uint16_t
name|StackSeg
decl_stmt|;
comment|/* Stack segment address */
name|uint16_t
name|StackSize
decl_stmt|;
comment|/* Stack segment size (bytes) */
name|uint16_t
name|BC_CodeSeg
decl_stmt|;
comment|/* BC Code segment address */
name|uint16_t
name|BC_CodeSize
decl_stmt|;
comment|/* BC Code segment size (bytes) */
name|uint16_t
name|BC_DataSeg
decl_stmt|;
comment|/* BC Data segment address */
name|uint16_t
name|BC_DataSize
decl_stmt|;
comment|/* BC Data segment size (bytes) */
name|uint16_t
name|UNDIDataSeg
decl_stmt|;
comment|/* UNDI Data segment address */
name|uint16_t
name|UNDIDataSize
decl_stmt|;
comment|/* UNDI Data segment size (bytes) */
name|uint16_t
name|UNDICodeSeg
decl_stmt|;
comment|/* UNDI Code segment address */
name|uint16_t
name|UNDICodeSize
decl_stmt|;
comment|/* UNDI Code segment size (bytes) */
name|SEGOFF16_t
name|PXEPtr
decl_stmt|;
comment|/* SEG:OFF to !PXE struct,  						   only present when Version> 2.1 */
block|}
modifier|*
name|pxenv_p
init|=
name|NULL
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uint32_t
name|myip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* my IP address */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|serverip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where I got my initial bootstrap from */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|secondip
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where I should go to get the rest of my boot files */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|servername
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of server I DHCP'd from */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bootfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file that I booted with */
end_comment

begin_decl_stmt
specifier|static
name|uint16_t
name|pxe_return_status
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint16_t
name|pxe_open_status
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PACKED
value|__attribute__ ((packed))
end_define

begin_define
define|#
directive|define
name|MAC_ADDR_LEN
value|16
end_define

begin_typedef
typedef|typedef
name|uint8_t
name|MAC_ADDR
index|[
name|MAC_ADDR_LEN
index|]
typedef|;
end_typedef

begin_comment
comment|/* PXENV_GET_CACHED_INFO request */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|PXENV_STATUS
name|Status
decl_stmt|;
name|uint16_t
name|PacketType
decl_stmt|;
comment|/* type (defined right here) */
define|#
directive|define
name|PXENV_PACKET_TYPE_DHCP_DISCOVER
value|1
define|#
directive|define
name|PXENV_PACKET_TYPE_DHCP_ACK
value|2
define|#
directive|define
name|PXENV_PACKET_TYPE_BINL_REPLY
value|3
name|uint16_t
name|BufferSize
decl_stmt|;
comment|/* max to copy, leave at 0 for pointer */
name|SEGOFF16_t
name|Buffer
decl_stmt|;
comment|/* copy to, leave at 0 for pointer */
name|uint16_t
name|BufferLimit
decl_stmt|;
comment|/* max size of buffer in BC dataseg ? */
block|}
name|PACKED
name|t_PXENV_GET_CACHED_INFO
typedef|;
end_typedef

begin_comment
comment|/*  * structure filled in by PXENV_GET_CACHED_INFO   * (how we determine which IP we downloaded the initial bootstrap from)  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint8_t
name|opcode
decl_stmt|;
define|#
directive|define
name|BOOTP_REQ
value|1
define|#
directive|define
name|BOOTP_REP
value|2
name|uint8_t
name|Hardware
decl_stmt|;
comment|/* hardware type */
name|uint8_t
name|Hardlen
decl_stmt|;
comment|/* hardware addr len */
name|uint8_t
name|Gatehops
decl_stmt|;
comment|/* zero it */
name|uint32_t
name|ident
decl_stmt|;
comment|/* random number chosen by client */
name|uint16_t
name|seconds
decl_stmt|;
comment|/* seconds since did initial bootstrap */
name|uint16_t
name|flags
decl_stmt|;
comment|/* seconds since did initial bootstrap */
define|#
directive|define
name|BOOTP_BCAST
value|0x8000
comment|/* ? */
name|uint32_t
name|cip
decl_stmt|;
comment|/* Client IP */
name|uint32_t
name|yip
decl_stmt|;
comment|/* Your IP */
name|uint32_t
name|sip
decl_stmt|;
comment|/* IP to use for next boot stage */
name|uint32_t
name|gip
decl_stmt|;
comment|/* Relay IP ? */
name|MAC_ADDR
name|CAddr
decl_stmt|;
comment|/* Client hardware address */
name|char
name|Sname
index|[
literal|64
index|]
decl_stmt|;
comment|/* Server's hostname (Optional) */
name|char
name|bootfile
index|[
literal|128
index|]
decl_stmt|;
comment|/* boot filename */
union|union
block|{
if|#
directive|if
literal|1
define|#
directive|define
name|BOOTP_DHCPVEND
value|1024
comment|/* DHCP extended vendor field size */
else|#
directive|else
define|#
directive|define
name|BOOTP_DHCPVEND
value|312
comment|/* DHCP standard vendor field size */
endif|#
directive|endif
name|uint8_t
name|d
index|[
name|BOOTP_DHCPVEND
index|]
decl_stmt|;
comment|/* raw array of vendor/dhcp options */
struct|struct
block|{
name|uint8_t
name|magic
index|[
literal|4
index|]
decl_stmt|;
comment|/* DHCP magic cookie */
define|#
directive|define
name|VM_RFC1048
value|0x63825363L
comment|/* ? */
name|uint32_t
name|flags
decl_stmt|;
comment|/* bootp flags/opcodes */
name|uint8_t
name|pad
index|[
literal|56
index|]
decl_stmt|;
comment|/* I don't think Intel knows what a 							   union does... */
block|}
name|v
struct|;
block|}
name|vendor
union|;
block|}
name|PACKED
name|BOOTPLAYER
typedef|;
end_typedef

begin_comment
comment|/* tftp open */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint16_t
name|status
decl_stmt|;
name|uint32_t
name|src_ip
decl_stmt|;
name|uint32_t
name|gw_ip
decl_stmt|;
name|uint8_t
name|filename
index|[
literal|128
index|]
decl_stmt|;
name|uint16_t
name|tftpport
decl_stmt|;
name|uint16_t
name|packetsize
decl_stmt|;
block|}
name|PACKED
name|t_PXENV_TFTP_OPEN
typedef|;
end_typedef

begin_comment
comment|/* tftp close */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint16_t
name|status
decl_stmt|;
block|}
name|PACKED
name|t_PXENV_TFTP_CLOSE
typedef|;
end_typedef

begin_comment
comment|/* tftp read */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|uint16_t
name|status
decl_stmt|;
name|uint16_t
name|packetnumber
decl_stmt|;
name|uint16_t
name|buffer_size
decl_stmt|;
name|SEGOFF16_t
name|buffer
decl_stmt|;
block|}
name|PACKED
name|t_PXENV_TFTP_READ
typedef|;
end_typedef

begin_function_decl
name|void
name|pxe_enable
parameter_list|(
name|void
modifier|*
name|pxeinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_strategy
parameter_list|(
name|void
modifier|*
name|devdata
parameter_list|,
name|int
name|flag
parameter_list|,
name|daddr_t
name|dblk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_open
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pxe_print
parameter_list|(
name|int
name|verbose
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pxe_perror
parameter_list|(
name|int
name|error
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pxe_call
parameter_list|(
name|int
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_fs_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_fs_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_fs_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_fs_write
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|off_t
name|pxe_fs_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|where
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pxe_fs_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|devsw
name|pxedisk
init|=
block|{
literal|"pxe"
block|,
name|DEVT_NET
block|,
name|pxe_init
block|,
name|pxe_strategy
block|,
name|pxe_open
block|,
name|pxe_close
block|,
name|noioctl
block|,
name|pxe_print
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|fs_ops
name|pxe_fsops
init|=
block|{
literal|"pxe"
block|,
name|pxe_fs_open
block|,
name|pxe_fs_close
block|,
name|pxe_fs_read
block|,
name|pxe_fs_write
block|,
name|pxe_fs_seek
block|,
name|pxe_fs_stat
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function is called by the loader to enable PXE support if we  * are booted by PXE.  The passed in pointer is a pointer to the  * PXENV+ structure.  */
end_comment

begin_function
name|void
name|pxe_enable
parameter_list|(
name|void
modifier|*
name|pxeinfo
parameter_list|)
block|{
name|pxenv_p
operator|=
operator|(
expr|struct
name|pxenv
operator|*
operator|)
name|pxeinfo
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * return true if pxe structures are found/initialized,  * also figures out our IP information via the pxe cached info struct   */
end_comment

begin_function
specifier|static
name|int
name|pxe_init
parameter_list|(
name|void
parameter_list|)
block|{
name|t_PXENV_GET_CACHED_INFO
modifier|*
name|gci_p
decl_stmt|;
name|BOOTPLAYER
modifier|*
name|bootplayer
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|uint8_t
name|checksum
decl_stmt|;
name|uint8_t
modifier|*
name|checkptr
decl_stmt|;
if|if
condition|(
name|pxenv_p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  look for "PXENV+" */
if|if
condition|(
name|bcmp
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pxenv_p
operator|->
name|Signature
argument_list|,
name|S_SIZE
argument_list|(
literal|"PXENV+"
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make sure the size is something we can handle */
if|if
condition|(
name|pxenv_p
operator|->
name|Length
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|pxenv_p
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"PXENV+ structure too large, ignoring\n"
argument_list|)
expr_stmt|;
name|pxenv_p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  	 * do byte checksum: 	 * add up each byte in the structure, the total should be 0 	 */
name|checksum
operator|=
literal|0
expr_stmt|;
name|checkptr
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|pxenv_p
expr_stmt|;
for|for
control|(
name|counter
operator|=
literal|0
init|;
name|counter
operator|<
name|pxenv_p
operator|->
name|Length
condition|;
name|counter
operator|++
control|)
name|checksum
operator|+=
operator|*
name|checkptr
operator|++
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"PXENV+ structure failed checksum, ignoring\n"
argument_list|)
expr_stmt|;
name|pxenv_p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"\nPXENV+ version %d.%d, real mode entry point @%04x:%04x\n"
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|pxenv_p
operator|->
name|Version
operator|>>
literal|8
argument_list|)
argument_list|,
call|(
name|uint8_t
call|)
argument_list|(
name|pxenv_p
operator|->
name|Version
operator|&
literal|0xFF
argument_list|)
argument_list|,
name|pxenv_p
operator|->
name|RMEntry
operator|.
name|segment
argument_list|,
name|pxenv_p
operator|->
name|RMEntry
operator|.
name|offset
argument_list|)
expr_stmt|;
name|gci_p
operator|=
operator|(
name|t_PXENV_GET_CACHED_INFO
operator|*
operator|)
name|scratch_buffer
expr_stmt|;
name|bzero
argument_list|(
name|gci_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gci_p
argument_list|)
argument_list|)
expr_stmt|;
name|gci_p
operator|->
name|PacketType
operator|=
name|PXENV_PACKET_TYPE_BINL_REPLY
expr_stmt|;
name|pxe_call
argument_list|(
name|PXENV_GET_CACHED_INFO
argument_list|)
expr_stmt|;
if|if
condition|(
name|gci_p
operator|->
name|Status
operator|!=
literal|0
condition|)
block|{
name|pxe_perror
argument_list|(
name|gci_p
operator|->
name|Status
argument_list|)
expr_stmt|;
name|pxenv_p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bootplayer
operator|=
operator|(
name|BOOTPLAYER
operator|*
operator|)
name|PTOV
argument_list|(
operator|(
name|gci_p
operator|->
name|Buffer
operator|.
name|segment
operator|<<
literal|4
operator|)
operator|+
name|gci_p
operator|->
name|Buffer
operator|.
name|offset
argument_list|)
expr_stmt|;
name|serverip
operator|=
name|bootplayer
operator|->
name|sip
expr_stmt|;
name|servername
operator|=
name|strdup
argument_list|(
name|bootplayer
operator|->
name|Sname
argument_list|)
expr_stmt|;
name|bootfile
operator|=
name|strdup
argument_list|(
name|bootplayer
operator|->
name|bootfile
argument_list|)
expr_stmt|;
name|myip
operator|=
name|bootplayer
operator|->
name|yip
expr_stmt|;
name|secondip
operator|=
name|bootplayer
operator|->
name|sip
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pxe_tftpopen
parameter_list|(
name|uint32_t
name|srcip
parameter_list|,
name|uint32_t
name|gateip
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|uint16_t
name|port
parameter_list|,
name|uint16_t
name|pktsize
parameter_list|)
block|{
name|t_PXENV_TFTP_OPEN
modifier|*
name|tftpo_p
decl_stmt|;
name|tftpo_p
operator|=
operator|(
name|t_PXENV_TFTP_OPEN
operator|*
operator|)
name|scratch_buffer
expr_stmt|;
name|bzero
argument_list|(
name|tftpo_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tftpo_p
argument_list|)
argument_list|)
expr_stmt|;
name|tftpo_p
operator|->
name|src_ip
operator|=
name|srcip
expr_stmt|;
name|tftpo_p
operator|->
name|gw_ip
operator|=
name|gateip
expr_stmt|;
name|bcopy
argument_list|(
name|filename
argument_list|,
name|tftpo_p
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|tftpo_p
operator|->
name|tftpport
operator|=
name|port
expr_stmt|;
name|tftpo_p
operator|->
name|packetsize
operator|=
name|pktsize
expr_stmt|;
name|pxe_call
argument_list|(
name|PXENV_TFTP_OPEN
argument_list|)
expr_stmt|;
name|pxe_return_status
operator|=
name|tftpo_p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|tftpo_p
operator|->
name|status
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|tftpo_p
operator|->
name|packetsize
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pxe_tftpclose
parameter_list|(
name|void
parameter_list|)
block|{
name|t_PXENV_TFTP_CLOSE
modifier|*
name|tftpc_p
decl_stmt|;
name|tftpc_p
operator|=
operator|(
name|t_PXENV_TFTP_CLOSE
operator|*
operator|)
name|scratch_buffer
expr_stmt|;
name|bzero
argument_list|(
name|tftpc_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tftpc_p
argument_list|)
argument_list|)
expr_stmt|;
name|pxe_call
argument_list|(
name|PXENV_TFTP_CLOSE
argument_list|)
expr_stmt|;
name|pxe_return_status
operator|=
name|tftpc_p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|tftpc_p
operator|->
name|status
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pxe_tftpread
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|t_PXENV_TFTP_READ
modifier|*
name|tftpr_p
decl_stmt|;
name|tftpr_p
operator|=
operator|(
name|t_PXENV_TFTP_READ
operator|*
operator|)
name|scratch_buffer
expr_stmt|;
name|bzero
argument_list|(
name|tftpr_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tftpr_p
argument_list|)
argument_list|)
expr_stmt|;
name|tftpr_p
operator|->
name|buffer
operator|.
name|segment
operator|=
name|VTOPSEG
argument_list|(
name|data_buffer
argument_list|)
expr_stmt|;
name|tftpr_p
operator|->
name|buffer
operator|.
name|offset
operator|=
name|VTOPOFF
argument_list|(
name|data_buffer
argument_list|)
expr_stmt|;
name|pxe_call
argument_list|(
name|PXENV_TFTP_READ
argument_list|)
expr_stmt|;
comment|/* XXX - I don't know why we need this. */
name|delay
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|pxe_return_status
operator|=
name|tftpr_p
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|tftpr_p
operator|->
name|status
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bcopy
argument_list|(
name|data_buffer
argument_list|,
name|buf
argument_list|,
name|tftpr_p
operator|->
name|buffer_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|tftpr_p
operator|->
name|buffer_size
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pxe_perror
parameter_list|(
name|int
name|err
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|pxe_call
parameter_list|(
name|int
name|func
parameter_list|)
block|{
name|bzero
argument_list|(
operator|&
name|v86
argument_list|,
sizeof|sizeof
argument_list|(
name|v86
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|data_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|data_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|v86
operator|.
name|ctl
operator|=
name|V86_ADDR
operator||
name|V86_CALLF
operator||
name|V86_FLAGS
expr_stmt|;
comment|/* high 16 == segment, low 16 == offset, shift and or */
name|v86
operator|.
name|addr
operator|=
operator|(
operator|(
name|uint32_t
operator|)
name|pxenv_p
operator|->
name|RMEntry
operator|.
name|segment
operator|<<
literal|16
operator|)
operator||
name|pxenv_p
operator|->
name|RMEntry
operator|.
name|offset
expr_stmt|;
name|v86
operator|.
name|es
operator|=
name|VTOPSEG
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|v86
operator|.
name|edi
operator|=
name|VTOPOFF
argument_list|(
name|scratch_buffer
argument_list|)
expr_stmt|;
name|v86
operator|.
name|ebx
operator|=
name|func
expr_stmt|;
name|v86int
argument_list|()
expr_stmt|;
name|v86
operator|.
name|ctl
operator|=
name|V86_FLAGS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_strategy
parameter_list|(
name|void
modifier|*
name|devdata
parameter_list|,
name|int
name|flag
parameter_list|,
name|daddr_t
name|dblk
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
modifier|*
name|rsize
parameter_list|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_open
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pxe_print
parameter_list|(
name|int
name|verbose
parameter_list|)
block|{
if|if
condition|(
name|pxenv_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|servername
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"      "
name|IP_STR
literal|":/%s\n"
argument_list|,
name|IP_ARGS
argument_list|(
name|htonl
argument_list|(
name|serverip
argument_list|)
argument_list|)
argument_list|,
name|bootfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"      %s:/%s\n"
argument_list|,
name|servername
argument_list|,
name|bootfile
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Most of this code was ripped from libstand/tftp.c and  * modified to work with pxe. :)  */
end_comment

begin_define
define|#
directive|define
name|RSPACE
value|520
end_define

begin_comment
comment|/* max data packet, rounded up */
end_comment

begin_struct
struct|struct
name|tftp_handle
block|{
name|int
name|currblock
decl_stmt|;
comment|/* contents of lastdata */
name|int
name|islastblock
decl_stmt|;
comment|/* flag */
name|int
name|validsize
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|opened
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
comment|/* saved for re-requests */
name|u_char
name|space
index|[
name|RSPACE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|tftp_makereq
parameter_list|(
name|h
parameter_list|)
name|struct
name|tftp_handle
modifier|*
name|h
decl_stmt|;
block|{
name|ssize_t
name|res
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|h
operator|->
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|opened
condition|)
name|pxe_tftpclose
argument_list|()
expr_stmt|;
if|if
condition|(
name|pxe_tftpopen
argument_list|(
name|serverip
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|htons
argument_list|(
literal|69
argument_list|)
argument_list|,
name|PXE_TFTP_BUFFER_SIZE
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|pxe_open_status
operator|=
name|pxe_return_status
expr_stmt|;
name|res
operator|=
name|pxe_tftpread
argument_list|(
name|h
operator|->
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|errno
operator|)
return|;
name|h
operator|->
name|currblock
operator|=
literal|1
expr_stmt|;
name|h
operator|->
name|validsize
operator|=
name|res
expr_stmt|;
name|h
operator|->
name|islastblock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|SEGSIZE
condition|)
name|h
operator|->
name|islastblock
operator|=
literal|1
expr_stmt|;
comment|/* very short file */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ack block, expect next */
end_comment

begin_function
specifier|static
name|int
name|tftp_getnextblock
parameter_list|(
name|h
parameter_list|)
name|struct
name|tftp_handle
modifier|*
name|h
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|pxe_tftpread
argument_list|(
name|h
operator|->
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
comment|/* 0 is OK! */
return|return
operator|(
name|errno
operator|)
return|;
name|h
operator|->
name|currblock
operator|++
expr_stmt|;
name|h
operator|->
name|validsize
operator|=
name|res
expr_stmt|;
if|if
condition|(
name|res
operator|<
name|SEGSIZE
condition|)
name|h
operator|->
name|islastblock
operator|=
literal|1
expr_stmt|;
comment|/* EOF */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_fs_open
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|tftp_handle
modifier|*
name|tftpfile
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* make sure the device is a PXE device */
if|if
condition|(
name|f
operator|->
name|f_dev
operator|!=
operator|&
name|pxedisk
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tftpfile
operator|=
operator|(
expr|struct
name|tftp_handle
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tftpfile
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tftpfile
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|tftpfile
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|tftpfile
operator|->
name|path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|tftpfile
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|res
operator|=
name|tftp_makereq
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|free
argument_list|(
name|tftpfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
name|tftpfile
operator|->
name|opened
operator|=
literal|1
expr_stmt|;
name|f
operator|->
name|f_fsdata
operator|=
operator|(
name|void
operator|*
operator|)
name|tftpfile
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_fs_close
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|)
block|{
name|struct
name|tftp_handle
modifier|*
name|tftpfile
decl_stmt|;
name|tftpfile
operator|=
operator|(
expr|struct
name|tftp_handle
operator|*
operator|)
name|f
operator|->
name|f_fsdata
expr_stmt|;
if|if
condition|(
name|tftpfile
condition|)
block|{
if|if
condition|(
name|tftpfile
operator|->
name|opened
condition|)
name|pxe_tftpclose
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|tftpfile
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_fs_read
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
block|{
name|struct
name|tftp_handle
modifier|*
name|tftpfile
decl_stmt|;
specifier|static
name|int
name|tc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|dest
init|=
operator|(
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|tftpfile
operator|=
operator|(
expr|struct
name|tftp_handle
operator|*
operator|)
name|f
operator|->
name|f_fsdata
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|int
name|needblock
decl_stmt|,
name|count
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|tc
operator|++
operator|%
literal|16
operator|)
condition|)
name|twiddle
argument_list|()
expr_stmt|;
name|needblock
operator|=
name|tftpfile
operator|->
name|off
operator|/
name|SEGSIZE
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tftpfile
operator|->
name|currblock
operator|>
name|needblock
condition|)
comment|/* seek backwards */
name|tftp_makereq
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
comment|/* no error check, it worked                                                  * for open */
while|while
condition|(
name|tftpfile
operator|->
name|currblock
operator|<
name|needblock
condition|)
block|{
name|int
name|res
decl_stmt|;
name|res
operator|=
name|tftp_getnextblock
argument_list|(
name|tftpfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
comment|/* no answer */
return|return
operator|(
name|res
operator|)
return|;
block|}
if|if
condition|(
name|tftpfile
operator|->
name|islastblock
condition|)
break|break;
block|}
if|if
condition|(
name|tftpfile
operator|->
name|currblock
operator|==
name|needblock
condition|)
block|{
name|int
name|offinblock
decl_stmt|,
name|inbuffer
decl_stmt|;
name|offinblock
operator|=
name|tftpfile
operator|->
name|off
operator|%
name|SEGSIZE
expr_stmt|;
name|inbuffer
operator|=
name|tftpfile
operator|->
name|validsize
operator|-
name|offinblock
expr_stmt|;
if|if
condition|(
name|inbuffer
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|count
operator|=
operator|(
name|size
operator|<
name|inbuffer
condition|?
name|size
else|:
name|inbuffer
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|tftpfile
operator|->
name|space
operator|+
name|offinblock
argument_list|,
name|dest
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|count
expr_stmt|;
name|tftpfile
operator|->
name|off
operator|+=
name|count
expr_stmt|;
name|size
operator|-=
name|count
expr_stmt|;
if|if
condition|(
operator|(
name|tftpfile
operator|->
name|islastblock
operator|)
operator|&&
operator|(
name|count
operator|==
name|inbuffer
operator|)
condition|)
break|break;
comment|/* EOF */
block|}
else|else
block|{
name|printf
argument_list|(
literal|"tftp: block %d not found\n"
argument_list|,
name|needblock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|resid
condition|)
operator|*
name|resid
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_fs_write
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
modifier|*
name|resid
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|pxe_fs_seek
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|struct
name|tftp_handle
modifier|*
name|tftpfile
decl_stmt|;
name|tftpfile
operator|=
operator|(
expr|struct
name|tftp_handle
operator|*
operator|)
name|f
operator|->
name|f_fsdata
expr_stmt|;
switch|switch
condition|(
name|where
condition|)
block|{
case|case
name|SEEK_SET
case|:
name|tftpfile
operator|->
name|off
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
name|tftpfile
operator|->
name|off
operator|+=
name|offset
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EOFFSET
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|tftpfile
operator|->
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pxe_fs_stat
parameter_list|(
name|struct
name|open_file
modifier|*
name|f
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
if|if
condition|(
name|pxe_open_status
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|sb
operator|->
name|st_mode
operator|=
literal|0444
operator||
name|S_IFREG
expr_stmt|;
name|sb
operator|->
name|st_nlink
operator|=
literal|1
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
literal|0
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
literal|0
expr_stmt|;
name|sb
operator|->
name|st_size
operator|=
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

