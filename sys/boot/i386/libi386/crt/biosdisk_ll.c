begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id$  * From: $NetBSD: biosdisk_ll.c,v 1.3 1997/06/13 13:36:06 drochner Exp $  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996  * 	Matthias Drochner.  All rights reserved.  * Copyright (c) 1996  * 	Perry E. Metzger.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgements:  *	This product includes software developed for the NetBSD Project  *	by Matthias Drochner.  *	This product includes software developed for the NetBSD Project  *	by Perry E. Metzger.  * 4. The names of the authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * shared by bootsector startup (bootsectmain) and biosdisk.c  * needs lowlevel parts from bios_disk.S  */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|"biosdisk_ll.h"
end_include

begin_include
include|#
directive|include
file|"diskbuf.h"
end_include

begin_comment
comment|/* XXX prototypes from export header? */
end_comment

begin_function_decl
specifier|extern
name|int
name|get_diskinfo
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|biosread
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|SPT
parameter_list|(
name|di
parameter_list|)
value|((di)&0xff)
end_define

begin_define
define|#
directive|define
name|HEADS
parameter_list|(
name|di
parameter_list|)
value|((((di)>>8)&0xff)+1)
end_define

begin_function
name|int
name|set_geometry
parameter_list|(
name|d
parameter_list|)
name|struct
name|biosdisk_ll
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|diskinfo
decl_stmt|;
name|diskinfo
operator|=
name|get_diskinfo
argument_list|(
name|d
operator|->
name|dev
argument_list|)
expr_stmt|;
name|d
operator|->
name|spc
operator|=
operator|(
name|d
operator|->
name|spt
operator|=
name|SPT
argument_list|(
name|diskinfo
argument_list|)
operator|)
operator|*
name|HEADS
argument_list|(
name|diskinfo
argument_list|)
expr_stmt|;
comment|/* 	 * get_diskinfo assumes floppy if BIOS call fails. Check at least 	 * "valid" geometry. 	 */
return|return
operator|(
operator|!
name|d
operator|->
name|spc
operator|||
operator|!
name|d
operator|->
name|spt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Global shared "diskbuf" is used as read ahead buffer.  For reading from  * floppies, the bootstrap has to be loaded on a 64K boundary to ensure that  * this buffer doesn't cross a 64K DMA boundary.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ra_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ra_first
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|readsects
parameter_list|(
name|d
parameter_list|,
name|dblk
parameter_list|,
name|num
parameter_list|,
name|buf
parameter_list|,
name|cold
parameter_list|)
comment|/* reads ahead if (!cold) */
name|struct
name|biosdisk_ll
modifier|*
name|d
decl_stmt|;
name|int
name|dblk
decl_stmt|,
name|num
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|cold
decl_stmt|;
comment|/* don't use data segment or bss, don't call 				 * library functions */
block|{
while|while
condition|(
name|num
condition|)
block|{
name|int
name|nsec
decl_stmt|;
comment|/* check for usable data in read-ahead buffer */
if|if
condition|(
name|cold
operator|||
name|diskbuf_user
operator|!=
operator|&
name|ra_dev
operator|||
name|d
operator|->
name|dev
operator|!=
name|ra_dev
operator|||
name|dblk
operator|<
name|ra_first
operator|||
name|dblk
operator|>=
name|ra_end
condition|)
block|{
comment|/* no, read from disk */
name|int
name|cyl
decl_stmt|,
name|head
decl_stmt|,
name|sec
decl_stmt|;
name|char
modifier|*
name|trbuf
decl_stmt|;
name|cyl
operator|=
name|dblk
operator|/
name|d
operator|->
name|spc
expr_stmt|;
name|head
operator|=
operator|(
name|dblk
operator|%
name|d
operator|->
name|spc
operator|)
operator|/
name|d
operator|->
name|spt
expr_stmt|;
name|sec
operator|=
name|dblk
operator|%
name|d
operator|->
name|spt
expr_stmt|;
name|nsec
operator|=
name|d
operator|->
name|spt
operator|-
name|sec
expr_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
comment|/* transfer directly to buffer */
name|trbuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|num
condition|)
name|nsec
operator|=
name|num
expr_stmt|;
block|}
else|else
block|{
comment|/* fill read-ahead buffer */
name|trbuf
operator|=
name|diskbuf
expr_stmt|;
if|if
condition|(
name|nsec
operator|>
name|diskbuf_size
condition|)
name|nsec
operator|=
name|diskbuf_size
expr_stmt|;
name|ra_dev
operator|=
name|d
operator|->
name|dev
expr_stmt|;
name|ra_first
operator|=
name|dblk
expr_stmt|;
name|ra_end
operator|=
name|dblk
operator|+
name|nsec
expr_stmt|;
name|diskbuf_user
operator|=
operator|&
name|ra_dev
expr_stmt|;
block|}
if|if
condition|(
name|biosread
argument_list|(
name|d
operator|->
name|dev
argument_list|,
name|cyl
argument_list|,
name|head
argument_list|,
name|sec
argument_list|,
name|nsec
argument_list|,
name|trbuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|cold
condition|)
name|diskbuf_user
operator|=
literal|0
expr_stmt|;
comment|/* mark invalid */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* XXX cannot output here if 						 * (cold) */
block|}
block|}
else|else
comment|/* can take blocks from end of read-ahead 				 * buffer */
name|nsec
operator|=
name|ra_end
operator|-
name|dblk
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
block|{
comment|/* copy data from read-ahead to user buffer */
if|if
condition|(
name|nsec
operator|>
name|num
condition|)
name|nsec
operator|=
name|num
expr_stmt|;
name|bcopy
argument_list|(
name|diskbuf
operator|+
operator|(
name|dblk
operator|-
name|ra_first
operator|)
operator|*
name|BIOSDISK_SECSIZE
argument_list|,
name|buf
argument_list|,
name|nsec
operator|*
name|BIOSDISK_SECSIZE
argument_list|)
expr_stmt|;
block|}
name|buf
operator|+=
name|nsec
operator|*
name|BIOSDISK_SECSIZE
expr_stmt|;
name|num
operator|-=
name|nsec
expr_stmt|;
name|dblk
operator|+=
name|nsec
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

