begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2010 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Semihalf under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<fdt.h>
end_include

begin_include
include|#
directive|include
file|<libfdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|"bootstrap.h"
end_include

begin_include
include|#
directive|include
file|"fdt_platform.h"
end_include

begin_include
include|#
directive|include
file|"fdt_overlay.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
value|do { printf("%s(): ", __func__);	\     printf(fmt,##args); } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|debugf
parameter_list|(
name|fmt
parameter_list|,
name|args
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FDT_CWD_LEN
value|256
end_define

begin_define
define|#
directive|define
name|FDT_MAX_DEPTH
value|6
end_define

begin_define
define|#
directive|define
name|FDT_PROP_SEP
value|" = "
end_define

begin_define
define|#
directive|define
name|COPYOUT
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|archsw.arch_copyout(s, d, l)
end_define

begin_define
define|#
directive|define
name|COPYIN
parameter_list|(
name|s
parameter_list|,
name|d
parameter_list|,
name|l
parameter_list|)
value|archsw.arch_copyin(s, d, l)
end_define

begin_define
define|#
directive|define
name|FDT_STATIC_DTB_SYMBOL
value|"fdt_static_dtb"
end_define

begin_define
define|#
directive|define
name|CMD_REQUIRES_BLOB
value|0x01
end_define

begin_comment
comment|/* Location of FDT yet to be loaded. */
end_comment

begin_comment
comment|/* This may be in read-only memory, so can't be manipulated directly. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fdt_header
modifier|*
name|fdt_to_load
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of FDT on heap. */
end_comment

begin_comment
comment|/* This is the copy we actually manipulate. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fdt_header
modifier|*
name|fdtp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of FDT blob */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|fdtp_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Location of FDT in kernel or module. */
end_comment

begin_comment
comment|/* This won't be set if FDT is loaded from disk or memory. */
end_comment

begin_comment
comment|/* If it is set, we'll update it when fdt_copy() gets called. */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|fdtp_va
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|fdt_load_dtb
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_nyi
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_addr
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_mkprop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_cd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_hdr
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_ls
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_prop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_pwd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_rm
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_mknode
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fdt_cmd_mres
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|int
name|cmdf_t
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
index|[]
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|cmdtab
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|cmdf_t
modifier|*
name|handler
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cmdtab
name|commands
index|[]
init|=
block|{
block|{
literal|"addr"
block|,
operator|&
name|fdt_cmd_addr
block|,
literal|0
block|}
block|,
block|{
literal|"alias"
block|,
operator|&
name|fdt_cmd_nyi
block|,
literal|0
block|}
block|,
block|{
literal|"cd"
block|,
operator|&
name|fdt_cmd_cd
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"header"
block|,
operator|&
name|fdt_cmd_hdr
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"ls"
block|,
operator|&
name|fdt_cmd_ls
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"mknode"
block|,
operator|&
name|fdt_cmd_mknode
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"mkprop"
block|,
operator|&
name|fdt_cmd_mkprop
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"mres"
block|,
operator|&
name|fdt_cmd_mres
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"prop"
block|,
operator|&
name|fdt_cmd_prop
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"pwd"
block|,
operator|&
name|fdt_cmd_pwd
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
literal|"rm"
block|,
operator|&
name|fdt_cmd_rm
block|,
name|CMD_REQUIRES_BLOB
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cwd
index|[
name|FDT_CWD_LEN
index|]
init|=
literal|"/"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|vm_offset_t
name|fdt_find_static_dtb
parameter_list|()
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|Elf_Sym
name|sym
decl_stmt|;
name|vm_offset_t
name|strtab
decl_stmt|,
name|symtab
decl_stmt|,
name|fdt_start
decl_stmt|;
name|uint64_t
name|offs
decl_stmt|;
name|struct
name|preloaded_file
modifier|*
name|kfp
decl_stmt|;
name|struct
name|file_metadata
modifier|*
name|md
decl_stmt|;
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sym_count
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_find_static_dtb()\n"
argument_list|)
expr_stmt|;
name|sym_count
operator|=
name|symtab
operator|=
name|strtab
operator|=
literal|0
expr_stmt|;
name|strp
operator|=
name|NULL
expr_stmt|;
name|offs
operator|=
name|__elfN
argument_list|(
name|relocation_offset
argument_list|)
expr_stmt|;
name|kfp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kfp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Locate the dynamic symbols and strtab. */
name|md
operator|=
name|file_findmetadata
argument_list|(
name|kfp
argument_list|,
name|MODINFOMD_ELFHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|md
operator|->
name|md_data
expr_stmt|;
name|md
operator|=
name|file_findmetadata
argument_list|(
name|kfp
argument_list|,
name|MODINFOMD_SHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|shdr
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
name|md
operator|->
name|md_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ehdr
operator|->
name|e_shnum
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_DYNSYM
operator|&&
name|symtab
operator|==
literal|0
condition|)
block|{
name|symtab
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|+
name|offs
expr_stmt|;
name|sym_count
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_STRTAB
operator|&&
name|strtab
operator|==
literal|0
condition|)
block|{
name|strtab
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|+
name|offs
expr_stmt|;
block|}
block|}
comment|/* 	 * The most efficent way to find a symbol would be to calculate a 	 * hash, find proper bucket and chain, and thus find a symbol. 	 * However, that would involve code duplication (e.g. for hash 	 * function). So we're using simpler and a bit slower way: we're 	 * iterating through symbols, searching for the one which name is 	 * 'equal' to 'fdt_static_dtb'. To speed up the process a little bit, 	 * we are eliminating symbols type of which is not STT_NOTYPE, or(and) 	 * those which binding attribute is not STB_GLOBAL. 	 */
name|fdt_start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|sym_count
operator|>
literal|0
operator|&&
name|fdt_start
operator|==
literal|0
condition|)
block|{
name|COPYOUT
argument_list|(
name|symtab
argument_list|,
operator|&
name|sym
argument_list|,
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|symtab
operator|+=
sizeof|sizeof
argument_list|(
name|sym
argument_list|)
expr_stmt|;
operator|--
name|sym_count
expr_stmt|;
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STB_GLOBAL
operator|||
name|ELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_NOTYPE
condition|)
continue|continue;
name|strp
operator|=
name|strdupout
argument_list|(
name|strtab
operator|+
name|sym
operator|.
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|strp
argument_list|,
name|FDT_STATIC_DTB_SYMBOL
argument_list|)
operator|==
literal|0
condition|)
name|fdt_start
operator|=
operator|(
name|vm_offset_t
operator|)
name|sym
operator|.
name|st_value
operator|+
name|offs
expr_stmt|;
name|free
argument_list|(
name|strp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fdt_start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_load_dtb
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|fdt_header
name|header
decl_stmt|;
name|int
name|err
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_load_dtb(0x%08jx)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|va
argument_list|)
expr_stmt|;
name|COPYOUT
argument_list|(
name|va
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdt_check_header
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|FDT_ERR_BADVERSION
condition|)
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"incompatible blob version: %d, should be: %d"
argument_list|,
name|fdt_version
argument_list|(
name|fdtp
argument_list|)
argument_list|,
name|FDT_LAST_SUPPORTED_VERSION
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"error validating blob: %s"
argument_list|,
name|fdt_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Release previous blob 	 */
if|if
condition|(
name|fdtp
condition|)
name|free
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
name|fdtp_size
operator|=
name|fdt_totalsize
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
name|fdtp
operator|=
name|malloc
argument_list|(
name|fdtp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdtp
operator|==
name|NULL
condition|)
block|{
name|command_errmsg
operator|=
literal|"can't allocate memory for device tree copy"
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fdtp_va
operator|=
name|va
expr_stmt|;
name|COPYOUT
argument_list|(
name|va
argument_list|,
name|fdtp
argument_list|,
name|fdtp_size
argument_list|)
expr_stmt|;
name|debugf
argument_list|(
literal|"DTB blob found at 0x%jx, size: 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|va
argument_list|,
operator|(
name|uintmax_t
operator|)
name|fdtp_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdt_load_dtb_addr
parameter_list|(
name|struct
name|fdt_header
modifier|*
name|header
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_load_dtb_addr(%p)\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|fdtp_size
operator|=
name|fdt_totalsize
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdt_check_header
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"error validating blob: %s"
argument_list|,
name|fdt_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|free
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fdtp
operator|=
name|malloc
argument_list|(
name|fdtp_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|command_errmsg
operator|=
literal|"can't allocate memory for device tree copy"
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fdtp_va
operator|=
literal|0
expr_stmt|;
comment|// Don't write this back into module or kernel.
name|bcopy
argument_list|(
name|header
argument_list|,
name|fdtp
argument_list|,
name|fdtp_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdt_load_dtb_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|preloaded_file
modifier|*
name|bfp
decl_stmt|,
modifier|*
name|oldbfp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_load_dtb_file(%s)\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|oldbfp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
literal|"dtb"
argument_list|)
expr_stmt|;
comment|/* Attempt to load and validate a new dtb from a file. */
if|if
condition|(
operator|(
name|bfp
operator|=
name|file_loadraw
argument_list|(
name|filename
argument_list|,
literal|"dtb"
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"failed to load file '%s'"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|fdt_load_dtb
argument_list|(
name|bfp
operator|->
name|f_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|file_discard
argument_list|(
name|bfp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* A new dtb was validated, discard any previous file. */
if|if
condition|(
name|oldbfp
condition|)
name|file_discard
argument_list|(
name|oldbfp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_load_dtb_overlay
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|preloaded_file
modifier|*
name|bfp
decl_stmt|,
modifier|*
name|oldbfp
decl_stmt|;
name|struct
name|fdt_header
name|header
decl_stmt|;
name|int
name|err
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_load_dtb_overlay(%s)\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|oldbfp
operator|=
name|file_findfile
argument_list|(
name|filename
argument_list|,
literal|"dtbo"
argument_list|)
expr_stmt|;
comment|/* Attempt to load and validate a new dtb from a file. */
if|if
condition|(
operator|(
name|bfp
operator|=
name|file_loadraw
argument_list|(
name|filename
argument_list|,
literal|"dtbo"
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to load file '%s'\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|COPYOUT
argument_list|(
name|bfp
operator|->
name|f_addr
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|fdt_check_header
argument_list|(
operator|&
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|file_discard
argument_list|(
name|bfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|FDT_ERR_BADVERSION
condition|)
name|printf
argument_list|(
literal|"incompatible blob version: %d, should be: %d\n"
argument_list|,
name|fdt_version
argument_list|(
name|fdtp
argument_list|)
argument_list|,
name|FDT_LAST_SUPPORTED_VERSION
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"error validating blob: %s\n"
argument_list|,
name|fdt_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* A new dtb was validated, discard any previous file. */
if|if
condition|(
name|oldbfp
condition|)
name|file_discard
argument_list|(
name|oldbfp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fdt_load_dtb_overlays
parameter_list|(
specifier|const
name|char
modifier|*
name|filenames
parameter_list|)
block|{
name|char
modifier|*
name|names
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|comaptr
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_load_dtb_overlay(%s)\n"
argument_list|,
name|filenames
argument_list|)
expr_stmt|;
name|names
operator|=
name|strdup
argument_list|(
name|filenames
argument_list|)
expr_stmt|;
if|if
condition|(
name|names
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|name
operator|=
name|names
expr_stmt|;
do|do
block|{
name|comaptr
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|comaptr
condition|)
operator|*
name|comaptr
operator|=
literal|'\0'
expr_stmt|;
name|fdt_load_dtb_overlay
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|comaptr
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|comaptr
condition|)
do|;
name|free
argument_list|(
name|names
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fdt_apply_overlays
parameter_list|()
block|{
name|struct
name|preloaded_file
modifier|*
name|fp
decl_stmt|;
name|size_t
name|overlays_size
decl_stmt|,
name|max_overlay_size
decl_stmt|,
name|new_fdtp_size
decl_stmt|;
name|void
modifier|*
name|new_fdtp
decl_stmt|;
name|void
modifier|*
name|overlay
decl_stmt|;
name|int
name|rv
decl_stmt|;
if|if
condition|(
operator|(
name|fdtp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|fdtp_size
operator|==
literal|0
operator|)
condition|)
return|return;
name|overlays_size
operator|=
literal|0
expr_stmt|;
name|max_overlay_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
literal|"dtbo"
argument_list|)
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|f_next
control|)
block|{
if|if
condition|(
name|max_overlay_size
operator|<
name|fp
operator|->
name|f_size
condition|)
name|max_overlay_size
operator|=
name|fp
operator|->
name|f_size
expr_stmt|;
name|overlays_size
operator|+=
name|fp
operator|->
name|f_size
expr_stmt|;
block|}
comment|/* Nothing to apply */
if|if
condition|(
name|overlays_size
operator|==
literal|0
condition|)
return|return;
comment|/* It's actually more than enough */
name|new_fdtp_size
operator|=
name|fdtp_size
operator|+
name|overlays_size
expr_stmt|;
name|new_fdtp
operator|=
name|malloc
argument_list|(
name|new_fdtp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_fdtp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to allocate memory for DTB blob with overlays\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|overlay
operator|=
name|malloc
argument_list|(
name|max_overlay_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlay
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed to allocate memory for DTB blob with overlays\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|new_fdtp
argument_list|)
expr_stmt|;
return|return;
block|}
name|rv
operator|=
name|fdt_open_into
argument_list|(
name|fdtp
argument_list|,
name|new_fdtp
argument_list|,
name|new_fdtp_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"failed to open DTB blob for applying overlays\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|fp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
literal|"dtbo"
argument_list|)
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|f_next
control|)
block|{
name|printf
argument_list|(
literal|"applying DTB overlay '%s'\n"
argument_list|,
name|fp
operator|->
name|f_name
argument_list|)
expr_stmt|;
name|COPYOUT
argument_list|(
name|fp
operator|->
name|f_addr
argument_list|,
name|overlay
argument_list|,
name|fp
operator|->
name|f_size
argument_list|)
expr_stmt|;
name|fdt_overlay_apply
argument_list|(
name|new_fdtp
argument_list|,
name|overlay
argument_list|,
name|fp
operator|->
name|f_size
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
name|fdtp
operator|=
name|new_fdtp
expr_stmt|;
name|fdtp_size
operator|=
name|new_fdtp_size
expr_stmt|;
name|free
argument_list|(
name|overlay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fdt_setup_fdtp
parameter_list|()
block|{
name|struct
name|preloaded_file
modifier|*
name|bfp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_setup_fdtp()\n"
argument_list|)
expr_stmt|;
comment|/* If we already loaded a file, use it. */
if|if
condition|(
operator|(
name|bfp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
literal|"dtb"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fdt_load_dtb
argument_list|(
name|bfp
operator|->
name|f_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Using DTB from loaded file '%s'.\n"
argument_list|,
name|bfp
operator|->
name|f_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* If we were given the address of a valid blob in memory, use it. */
if|if
condition|(
name|fdt_to_load
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fdt_load_dtb_addr
argument_list|(
name|fdt_to_load
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Using DTB from memory address 0x%p.\n"
argument_list|,
name|fdt_to_load
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fdt_platform_load_dtb
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If there is a dtb compiled into the kernel, use it. */
if|if
condition|(
operator|(
name|va
operator|=
name|fdt_find_static_dtb
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fdt_load_dtb
argument_list|(
name|va
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Using DTB compiled into kernel.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|command_errmsg
operator|=
literal|"No device tree blob found!\n"
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|fdt_strtovect
parameter_list|(
name|str
parameter_list|,
name|cellbuf
parameter_list|,
name|lim
parameter_list|,
name|cellsize
parameter_list|)
value|_fdt_strtovect((str), \     (cellbuf), (lim), (cellsize), 0);
end_define

begin_comment
comment|/* Force using base 16 */
end_comment

begin_define
define|#
directive|define
name|fdt_strtovectx
parameter_list|(
name|str
parameter_list|,
name|cellbuf
parameter_list|,
name|lim
parameter_list|,
name|cellsize
parameter_list|)
value|_fdt_strtovect((str), \     (cellbuf), (lim), (cellsize), 16);
end_define

begin_function
specifier|static
name|int
name|_fdt_strtovect
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|void
modifier|*
name|cellbuf
parameter_list|,
name|int
name|lim
parameter_list|,
name|unsigned
name|char
name|cellsize
parameter_list|,
name|uint8_t
name|base
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|buf
init|=
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|2
decl_stmt|;
name|uint32_t
modifier|*
name|u32buf
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|u8buf
init|=
name|NULL
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cellsize
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|u32buf
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|cellbuf
expr_stmt|;
else|else
name|u8buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cellbuf
expr_stmt|;
if|if
condition|(
name|lim
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|buf
operator|<
name|end
condition|)
block|{
comment|/* Skip white whitespace(s)/separators */
while|while
condition|(
operator|!
name|isxdigit
argument_list|(
operator|*
name|buf
argument_list|)
operator|&&
name|buf
operator|<
name|end
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
name|u32buf
operator|!=
name|NULL
condition|)
name|u32buf
index|[
name|cnt
index|]
operator|=
name|cpu_to_fdt32
argument_list|(
operator|(
name|uint32_t
operator|)
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|base
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|u8buf
index|[
name|cnt
index|]
operator|=
operator|(
name|uint8_t
operator|)
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|+
literal|1
operator|<=
name|lim
operator|-
literal|1
condition|)
name|cnt
operator|++
expr_stmt|;
else|else
break|break;
name|buf
operator|++
expr_stmt|;
comment|/* Find another number */
while|while
condition|(
operator|(
name|isxdigit
argument_list|(
operator|*
name|buf
argument_list|)
operator|||
operator|*
name|buf
operator|==
literal|'x'
operator|)
operator|&&
name|buf
operator|<
name|end
condition|)
name|buf
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fdt_fixup_ethernet
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|ethstr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|uint8_t
name|tmp_addr
index|[
literal|6
index|]
decl_stmt|;
comment|/* Convert macaddr string into a vector of uints */
name|fdt_strtovectx
argument_list|(
name|str
argument_list|,
operator|&
name|tmp_addr
argument_list|,
literal|6
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set actual property to a value from vect */
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|ethstr
argument_list|)
argument_list|,
literal|"local-mac-address"
argument_list|,
operator|&
name|tmp_addr
argument_list|,
literal|6
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdt_fixup_cpubusfreqs
parameter_list|(
name|unsigned
name|long
name|cpufreq
parameter_list|,
name|unsigned
name|long
name|busfreq
parameter_list|)
block|{
name|int
name|lo
decl_stmt|,
name|o
init|=
literal|0
decl_stmt|,
name|o2
decl_stmt|,
name|maxo
init|=
literal|0
decl_stmt|,
name|depth
decl_stmt|;
specifier|const
name|uint32_t
name|zero
init|=
literal|0
decl_stmt|;
comment|/* We want to modify every subnode of /cpus */
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
literal|"/cpus"
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
return|return;
comment|/* maxo should contain offset of node next to /cpus */
name|depth
operator|=
literal|0
expr_stmt|;
name|maxo
operator|=
name|o
expr_stmt|;
while|while
condition|(
name|depth
operator|!=
operator|-
literal|1
condition|)
name|maxo
operator|=
name|fdt_next_node
argument_list|(
name|fdtp
argument_list|,
name|maxo
argument_list|,
operator|&
name|depth
argument_list|)
expr_stmt|;
comment|/* Find CPU frequency properties */
name|o
operator|=
name|fdt_node_offset_by_prop_value
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|o2
operator|=
name|fdt_node_offset_by_prop_value
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
literal|"bus-frequency"
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|lo
operator|=
name|MIN
argument_list|(
name|o
argument_list|,
name|o2
argument_list|)
expr_stmt|;
while|while
condition|(
name|o
operator|!=
operator|-
name|FDT_ERR_NOTFOUND
operator|&&
name|o2
operator|!=
operator|-
name|FDT_ERR_NOTFOUND
condition|)
block|{
name|o
operator|=
name|fdt_node_offset_by_prop_value
argument_list|(
name|fdtp
argument_list|,
name|lo
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|o2
operator|=
name|fdt_node_offset_by_prop_value
argument_list|(
name|fdtp
argument_list|,
name|lo
argument_list|,
literal|"bus-frequency"
argument_list|,
operator|&
name|zero
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're only interested in /cpus subnode(s) */
if|if
condition|(
name|lo
operator|>
name|maxo
condition|)
break|break;
name|fdt_setprop_inplace_cell
argument_list|(
name|fdtp
argument_list|,
name|lo
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|(
name|uint32_t
operator|)
name|cpufreq
argument_list|)
expr_stmt|;
name|fdt_setprop_inplace_cell
argument_list|(
name|fdtp
argument_list|,
name|lo
argument_list|,
literal|"bus-frequency"
argument_list|,
operator|(
name|uint32_t
operator|)
name|busfreq
argument_list|)
expr_stmt|;
name|lo
operator|=
name|MIN
argument_list|(
name|o
argument_list|,
name|o2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|fdt_reg_valid
parameter_list|(
name|uint32_t
modifier|*
name|reg
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|addr_cells
parameter_list|,
name|int
name|size_cells
parameter_list|)
block|{
name|int
name|cells_in_tuple
decl_stmt|,
name|i
decl_stmt|,
name|tuples
decl_stmt|,
name|tuple_size
decl_stmt|;
name|uint32_t
name|cur_start
decl_stmt|,
name|cur_size
decl_stmt|;
name|cells_in_tuple
operator|=
operator|(
name|addr_cells
operator|+
name|size_cells
operator|)
expr_stmt|;
name|tuple_size
operator|=
name|cells_in_tuple
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|tuples
operator|=
name|len
operator|/
name|tuple_size
expr_stmt|;
if|if
condition|(
name|tuples
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tuples
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|addr_cells
operator|==
literal|2
condition|)
name|cur_start
operator|=
name|fdt64_to_cpu
argument_list|(
name|reg
index|[
name|i
operator|*
name|cells_in_tuple
index|]
argument_list|)
expr_stmt|;
else|else
name|cur_start
operator|=
name|fdt32_to_cpu
argument_list|(
name|reg
index|[
name|i
operator|*
name|cells_in_tuple
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_cells
operator|==
literal|2
condition|)
name|cur_size
operator|=
name|fdt64_to_cpu
argument_list|(
name|reg
index|[
name|i
operator|*
name|cells_in_tuple
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|cur_size
operator|=
name|fdt32_to_cpu
argument_list|(
name|reg
index|[
name|i
operator|*
name|cells_in_tuple
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|debugf
argument_list|(
literal|" reg#%d (start: 0x%0x size: 0x%0x) valid!\n"
argument_list|,
name|i
argument_list|,
name|cur_start
argument_list|,
name|cur_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|fdt_fixup_memory
parameter_list|(
name|struct
name|fdt_mem_region
modifier|*
name|region
parameter_list|,
name|size_t
name|num
parameter_list|)
block|{
name|struct
name|fdt_mem_region
modifier|*
name|curmr
decl_stmt|;
name|uint32_t
name|addr_cells
decl_stmt|,
name|size_cells
decl_stmt|;
name|uint32_t
modifier|*
name|addr_cellsp
decl_stmt|,
modifier|*
name|size_cellsp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|memory
decl_stmt|,
name|root
decl_stmt|;
name|size_t
name|realmrno
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|,
modifier|*
name|sb
decl_stmt|;
name|uint64_t
name|rstart
decl_stmt|,
name|rsize
decl_stmt|;
name|int
name|reserved
decl_stmt|;
name|root
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
if|if
condition|(
name|root
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not find root node !"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memory
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
literal|"/memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory
operator|<=
literal|0
condition|)
block|{
comment|/* Create proper '/memory' node. */
name|memory
operator|=
name|fdt_add_subnode
argument_list|(
name|fdtp
argument_list|,
name|root
argument_list|,
literal|"memory"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory
operator|<=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not fixup '/memory' "
literal|"node, error code : %d!\n"
argument_list|,
name|memory
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator|=
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|memory
argument_list|,
literal|"device_type"
argument_list|,
literal|"memory"
argument_list|,
sizeof|sizeof
argument_list|(
literal|"memory"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
return|return;
block|}
name|addr_cellsp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdtp
argument_list|,
name|root
argument_list|,
literal|"#address-cells"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|size_cellsp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdtp
argument_list|,
name|root
argument_list|,
literal|"#size-cells"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_cellsp
operator|==
name|NULL
operator|||
name|size_cellsp
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not fixup '/memory' node : "
literal|"%s %s property not found in root node!\n"
argument_list|,
operator|(
operator|!
name|addr_cellsp
operator|)
condition|?
literal|"#address-cells"
else|:
literal|""
argument_list|,
operator|(
operator|!
name|size_cellsp
operator|)
condition|?
literal|"#size-cells"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr_cells
operator|=
name|fdt32_to_cpu
argument_list|(
operator|*
name|addr_cellsp
argument_list|)
expr_stmt|;
name|size_cells
operator|=
name|fdt32_to_cpu
argument_list|(
operator|*
name|size_cellsp
argument_list|)
expr_stmt|;
comment|/* 	 * Convert memreserve data to memreserve property 	 * Check if property already exists 	 */
name|reserved
operator|=
name|fdt_num_mem_rsv
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reserved
operator|&&
operator|(
name|fdt_getprop
argument_list|(
name|fdtp
argument_list|,
name|root
argument_list|,
literal|"memreserve"
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|len
operator|=
operator|(
name|addr_cells
operator|+
name|size_cells
operator|)
operator|*
name|reserved
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|sb
operator|=
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reserved
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdt_get_mem_rsv
argument_list|(
name|fdtp
argument_list|,
name|i
argument_list|,
operator|&
name|rstart
argument_list|,
operator|&
name|rsize
argument_list|)
condition|)
break|break;
if|if
condition|(
name|rsize
condition|)
block|{
comment|/* Ensure endianess, and put cells into a buffer */
if|if
condition|(
name|addr_cells
operator|==
literal|2
condition|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt64
argument_list|(
name|rstart
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt32
argument_list|(
name|rstart
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|addr_cells
expr_stmt|;
if|if
condition|(
name|size_cells
operator|==
literal|2
condition|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt64
argument_list|(
name|rsize
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt32
argument_list|(
name|rsize
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|size_cells
expr_stmt|;
block|}
block|}
comment|/* Set property */
if|if
condition|(
operator|(
name|err
operator|=
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|root
argument_list|,
literal|"memreserve"
argument_list|,
name|sb
argument_list|,
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"Could not fixup 'memreserve' property.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
comment|/* Count valid memory regions entries in sysinfo. */
name|realmrno
operator|=
name|num
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|region
index|[
name|i
index|]
operator|.
name|start
operator|==
literal|0
operator|&&
name|region
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
name|realmrno
operator|--
expr_stmt|;
if|if
condition|(
name|realmrno
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not fixup '/memory' node : "
literal|"sysinfo doesn't contain valid memory regions info!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
operator|(
name|addr_cells
operator|+
name|size_cells
operator|)
operator|*
name|realmrno
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|sb
operator|=
name|buf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return;
name|bzero
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|curmr
operator|=
operator|&
name|region
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|curmr
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* Ensure endianess, and put cells into a buffer */
if|if
condition|(
name|addr_cells
operator|==
literal|2
condition|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt64
argument_list|(
name|curmr
operator|->
name|start
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt32
argument_list|(
name|curmr
operator|->
name|start
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|addr_cells
expr_stmt|;
if|if
condition|(
name|size_cells
operator|==
literal|2
condition|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt64
argument_list|(
name|curmr
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|buf
operator|=
name|cpu_to_fdt32
argument_list|(
name|curmr
operator|->
name|size
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|size_cells
expr_stmt|;
block|}
block|}
comment|/* Set property */
if|if
condition|(
operator|(
name|err
operator|=
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|memory
argument_list|,
literal|"reg"
argument_list|,
name|sb
argument_list|,
name|len
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not fixup '/memory' node.\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdt_fixup_stdout
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|serialno
decl_stmt|;
name|int
name|len
decl_stmt|,
name|no
decl_stmt|,
name|sero
decl_stmt|;
specifier|const
name|struct
name|fdt_property
modifier|*
name|prop
decl_stmt|;
name|char
modifier|*
name|tmp
index|[
literal|10
index|]
decl_stmt|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ptr
operator|>
name|str
operator|&&
name|isdigit
argument_list|(
operator|*
operator|(
name|str
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|str
operator|--
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|str
condition|)
return|return;
name|serialno
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|ptr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|no
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
literal|"/chosen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|no
operator|<
literal|0
condition|)
return|return;
name|prop
operator|=
name|fdt_get_property
argument_list|(
name|fdtp
argument_list|,
name|no
argument_list|,
literal|"stdout"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* If /chosen/stdout does not extist, create it */
if|if
condition|(
name|prop
operator|==
name|NULL
operator|||
operator|(
name|prop
operator|!=
name|NULL
operator|&&
name|len
operator|==
literal|0
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|tmp
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|,
literal|"serial"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ptr
argument_list|)
operator|>
literal|3
condition|)
comment|/* Serial number too long */
return|return;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|tmp
operator|+
literal|6
argument_list|,
name|ptr
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sero
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sero
operator|<
literal|0
condition|)
comment|/* 			 * If serial device we're trying to assign 			 * stdout to doesn't exist in DT -- return. 			 */
return|return;
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|no
argument_list|,
literal|"stdout"
argument_list|,
operator|&
name|tmp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|no
argument_list|,
literal|"stdin"
argument_list|,
operator|&
name|tmp
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Locate the blob, fix it up and return its location.  */
end_comment

begin_function
specifier|static
name|int
name|fdt_fixup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|chosen
decl_stmt|,
name|len
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|debugf
argument_list|(
literal|"fdt_fixup()\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdtp
operator|==
name|NULL
operator|&&
name|fdt_setup_fdtp
argument_list|()
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Create /chosen node (if not exists) */
if|if
condition|(
operator|(
name|chosen
operator|=
name|fdt_subnode_offset
argument_list|(
name|fdtp
argument_list|,
literal|0
argument_list|,
literal|"chosen"
argument_list|)
operator|)
operator|==
operator|-
name|FDT_ERR_NOTFOUND
condition|)
name|chosen
operator|=
name|fdt_add_subnode
argument_list|(
name|fdtp
argument_list|,
literal|0
argument_list|,
literal|"chosen"
argument_list|)
expr_stmt|;
comment|/* Value assigned to fixup-applied does not matter. */
if|if
condition|(
name|fdt_getprop
argument_list|(
name|fdtp
argument_list|,
name|chosen
argument_list|,
literal|"fixup-applied"
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|fdt_platform_fixups
argument_list|()
expr_stmt|;
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|chosen
argument_list|,
literal|"fixup-applied"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy DTB blob to specified location and return size  */
end_comment

begin_function
name|int
name|fdt_copy
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|debugf
argument_list|(
literal|"fdt_copy va 0x%08x\n"
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdtp
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|fdt_setup_fdtp
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"No valid device tree blob found!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fdt_fixup
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fdtp_va
operator|!=
literal|0
condition|)
block|{
comment|/* Overwrite the FDT with the fixed version. */
comment|/* XXX Is this really appropriate? */
name|COPYIN
argument_list|(
name|fdtp
argument_list|,
name|fdtp_va
argument_list|,
name|fdtp_size
argument_list|)
expr_stmt|;
block|}
name|COPYIN
argument_list|(
name|fdtp
argument_list|,
name|va
argument_list|,
name|fdtp_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|fdtp_size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|command_fdt_internal
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|cmdf_t
modifier|*
name|cmdh
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|command_errmsg
operator|=
literal|"usage is 'fdt<command> [<args>]"
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
comment|/* 	 * Validate fdt<command>. 	 */
name|cmd
operator|=
name|strdup
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|cmdh
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|commands
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
name|commands
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
name|cmdh
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|handler
expr_stmt|;
name|flags
operator|=
name|commands
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cmdh
operator|==
name|NULL
condition|)
block|{
name|command_errmsg
operator|=
literal|"unknown command"
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|CMD_REQUIRES_BLOB
condition|)
block|{
comment|/* 		 * Check if uboot env vars were parsed already. If not, do it now. 		 */
if|if
condition|(
name|fdt_fixup
argument_list|()
operator|==
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
comment|/* 	 * Call command handler. 	 */
name|err
operator|=
call|(
modifier|*
name|cmdh
call|)
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_addr
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|preloaded_file
modifier|*
name|fp
decl_stmt|;
name|struct
name|fdt_header
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|fdt_to_load
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|addr
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"no address specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|hdr
operator|=
operator|(
expr|struct
name|fdt_header
operator|*
operator|)
name|strtoul
argument_list|(
name|addr
argument_list|,
operator|&
name|cp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|addr
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Invalid address: %s"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|fp
operator|=
name|file_findfile
argument_list|(
name|NULL
argument_list|,
literal|"dtb"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|file_discard
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|fdt_to_load
operator|=
name|hdr
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_cd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|char
name|tmp
index|[
name|FDT_CWD_LEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|o
decl_stmt|;
name|path
operator|=
operator|(
name|argc
operator|>
literal|2
operator|)
condition|?
name|argv
index|[
literal|2
index|]
else|:
literal|"/"
expr_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|FDT_CWD_LEN
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
comment|/* Handle path specification relative to cwd */
name|len
operator|=
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|FDT_CWD_LEN
condition|)
goto|goto
name|fail
goto|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmp
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|tmp
expr_stmt|;
block|}
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not find node: '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|cwd
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
name|fail
label|:
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"path too long: %d, max allowed: %d"
argument_list|,
name|len
argument_list|,
name|FDT_CWD_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_hdr
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|__unused
parameter_list|)
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|int
name|ver
decl_stmt|;
if|if
condition|(
name|fdtp
operator|==
name|NULL
condition|)
block|{
name|command_errmsg
operator|=
literal|"no device tree blob pointer?!"
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|ver
operator|=
name|fdt_version
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
name|pager_open
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"\nFlattened device tree header (%p):\n"
argument_list|,
name|fdtp
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" magic                   = 0x%08x\n"
argument_list|,
name|fdt_magic
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" size                    = %d\n"
argument_list|,
name|fdt_totalsize
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" off_dt_struct           = 0x%08x\n"
argument_list|,
name|fdt_off_dt_struct
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" off_dt_strings          = 0x%08x\n"
argument_list|,
name|fdt_off_dt_strings
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" off_mem_rsvmap          = 0x%08x\n"
argument_list|,
name|fdt_off_mem_rsvmap
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" version                 = %d\n"
argument_list|,
name|ver
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" last compatible version = %d\n"
argument_list|,
name|fdt_last_comp_version
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ver
operator|>=
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" boot_cpuid              = %d\n"
argument_list|,
name|fdt_boot_cpuid_phys
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ver
operator|>=
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" size_dt_strings         = %d\n"
argument_list|,
name|fdt_size_dt_strings
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ver
operator|>=
literal|17
condition|)
block|{
name|sprintf
argument_list|(
name|line
argument_list|,
literal|" size_dt_struct          = %d\n"
argument_list|,
name|fdt_size_dt_struct
argument_list|(
name|fdtp
argument_list|)
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|pager_close
argument_list|()
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_ls
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prevname
index|[
name|FDT_MAX_DEPTH
index|]
init|=
block|{
name|NULL
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|i
decl_stmt|,
name|o
decl_stmt|,
name|depth
decl_stmt|,
name|len
decl_stmt|;
name|path
operator|=
operator|(
name|argc
operator|>
literal|2
operator|)
condition|?
name|argv
index|[
literal|2
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|cwd
expr_stmt|;
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not find node: '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
for|for
control|(
name|depth
operator|=
literal|0
init|;
operator|(
name|o
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|depth
operator|>=
literal|0
operator|)
condition|;
name|o
operator|=
name|fdt_next_node
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
operator|&
name|depth
argument_list|)
control|)
block|{
name|name
operator|=
name|fdt_get_name
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|FDT_MAX_DEPTH
condition|)
block|{
name|printf
argument_list|(
literal|"max depth exceeded: %d\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|prevname
index|[
name|depth
index|]
operator|=
name|name
expr_stmt|;
comment|/* Skip root (i = 1) when printing devices */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|depth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|prevname
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|cwd
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"/"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|prevname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|isprint
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<=
literal|0x7e
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_isprint
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|count
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|int
name|yesno
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|d
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|d
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|yesno
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
operator|*
operator|(
name|d
operator|+
name|i
operator|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
operator|||
operator|(
name|ch
operator|==
literal|'\0'
operator|&&
name|i
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Count strings */
if|if
condition|(
name|ch
operator|==
literal|'\0'
condition|)
operator|(
operator|*
name|count
operator|)
operator|++
expr_stmt|;
continue|continue;
block|}
name|yesno
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|yesno
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_data_str
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|count
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|buf_len
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
comment|/* 	 * Calculate the length for the string and allocate memory. 	 * 	 * Note that 'len' already includes at least one terminator. 	 */
name|buf_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Each token had already a terminator buried in 'len', but we 		 * only need one eventually, don't count space for these. 		 */
name|buf_len
operator|-=
name|count
operator|-
literal|1
expr_stmt|;
comment|/* Each consecutive token requires a ", " separator. */
name|buf_len
operator|+=
name|count
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Add some space for surrounding double quotes. */
name|buf_len
operator|+=
name|count
operator|*
literal|2
expr_stmt|;
comment|/* Note that string being put in 'tmp' may be as big as 'buf_len'. */
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|buf_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|b
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Now that we have space, format the string. 	 */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|d
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
name|i
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"\"%s\"%s"
argument_list|,
name|d
argument_list|,
operator|(
name|i
operator|+
name|l
operator|)
operator|<
name|len
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|l
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|<
name|len
condition|)
do|;
operator|*
name|buf
operator|=
name|b
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_data_cell
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|uint32_t
modifier|*
name|c
decl_stmt|;
name|int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|l
decl_stmt|;
comment|/* Number of cells */
name|count
operator|=
name|len
operator|/
literal|4
expr_stmt|;
comment|/* 	 * Calculate the length for the string and allocate memory. 	 */
comment|/* Each byte translates to 2 output characters */
name|l
operator|=
name|len
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
comment|/* Each consecutive cell requires a " " separator. */
name|l
operator|+=
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|1
expr_stmt|;
block|}
comment|/* Each cell will have a "0x" prefix */
name|l
operator|+=
name|count
operator|*
literal|2
expr_stmt|;
comment|/* Space for surrounding<> and terminator */
name|l
operator|+=
literal|3
expr_stmt|;
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|b
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|c
operator|=
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
operator|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|data
operator|+
name|i
operator|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"0x%08x%s"
argument_list|,
name|fdt32_to_cpu
argument_list|(
operator|*
name|c
argument_list|)
argument_list|,
name|i
operator|<
operator|(
name|len
operator|-
literal|4
operator|)
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|b
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|b
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_data_bytes
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|b
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
comment|/* 	 * Calculate the length for the string and allocate memory. 	 */
comment|/* Each byte translates to 2 output characters */
name|l
operator|=
name|len
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
comment|/* Each consecutive byte requires a " " separator. */
name|l
operator|+=
operator|(
name|len
operator|-
literal|1
operator|)
operator|*
literal|1
expr_stmt|;
comment|/* Each byte will have a "0x" prefix */
name|l
operator|+=
name|len
operator|*
literal|2
expr_stmt|;
comment|/* Space for surrounding [] and terminator. */
name|l
operator|+=
literal|3
expr_stmt|;
name|b
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|tmp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|b
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
name|data
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"0x%02x%s"
argument_list|,
name|d
index|[
name|i
index|]
argument_list|,
name|i
operator|<
name|len
operator|-
literal|1
condition|?
literal|" "
else|:
literal|""
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|b
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|b
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_data_fmt
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|buf
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fdt_isprint
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|count
argument_list|)
condition|)
return|return
operator|(
name|fdt_data_str
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|count
argument_list|,
name|buf
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|len
operator|%
literal|4
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|fdt_data_cell
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|fdt_data_bytes
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_prop
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
specifier|const
name|struct
name|fdt_property
modifier|*
name|prop
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rv
decl_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|prop
operator|=
name|fdt_offset_ptr
argument_list|(
name|fdtp
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|name
operator|=
name|fdt_string
argument_list|(
name|fdtp
argument_list|,
name|fdt32_to_cpu
argument_list|(
name|prop
operator|->
name|nameoff
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|fdt32_to_cpu
argument_list|(
name|prop
operator|->
name|len
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Property without value */
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|rv
operator|=
literal|2
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
comment|/* 	 * Process property with value 	 */
name|data
operator|=
name|prop
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|fdt_data_fmt
argument_list|(
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
literal|3
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|FDT_PROP_SEP
argument_list|)
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not allocate space for string"
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|4
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s"
name|FDT_PROP_SEP
literal|"%s\n"
argument_list|,
name|name
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|out1
label|:
name|pager_open
argument_list|()
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|pager_close
argument_list|()
expr_stmt|;
name|out2
label|:
if|if
condition|(
name|buf
condition|)
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_modprop
parameter_list|(
name|int
name|nodeoff
parameter_list|,
name|char
modifier|*
name|propname
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|char
name|mode
parameter_list|)
block|{
name|uint32_t
name|cells
index|[
literal|100
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|,
name|rv
decl_stmt|;
specifier|const
name|struct
name|fdt_property
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|fdt_get_property
argument_list|(
name|fdtp
argument_list|,
name|nodeoff
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
comment|/* Adding inexistant value in mode 1 is forbidden */
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"property already exists!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"property does not exist!"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'&'
case|:
comment|/* phandles */
break|break;
case|case
literal|'<'
case|:
comment|/* Data cells */
name|len
operator|=
name|fdt_strtovect
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cells
argument_list|,
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|nodeoff
argument_list|,
name|propname
argument_list|,
operator|&
name|cells
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
comment|/* Data bytes */
name|len
operator|=
name|fdt_strtovect
argument_list|(
name|buf
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cells
argument_list|,
literal|100
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|fdt_setprop
argument_list|(
name|fdtp
argument_list|,
name|nodeoff
argument_list|,
name|propname
argument_list|,
operator|&
name|cells
argument_list|,
name|len
operator|*
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
default|default:
comment|/* Default -- string */
name|rv
operator|=
name|fdt_setprop_string
argument_list|(
name|fdtp
argument_list|,
name|nodeoff
argument_list|,
name|propname
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rv
operator|==
operator|-
name|FDT_ERR_NOSPACE
condition|)
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Device tree blob is too small!\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not add/modify property!\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Merge strings from argv into a single string */
end_comment

begin_function
specifier|static
name|int
name|fdt_merge_strings
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|int
name|start
parameter_list|,
name|char
modifier|*
modifier|*
name|buffer
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|,
name|sz
decl_stmt|;
operator|*
name|buffer
operator|=
name|NULL
expr_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|sz
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Additional bytes for whitespaces between args */
name|sz
operator|+=
name|argc
operator|-
name|start
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not allocate space "
literal|"for string"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|sz
argument_list|)
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
operator|,
name|idx
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|buf
operator|+
name|idx
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buf
index|[
name|idx
index|]
operator|=
literal|' '
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|sz
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|buffer
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extract offset and name of node/property from a given path */
end_comment

begin_function
specifier|static
name|int
name|fdt_extract_nameloc
parameter_list|(
name|char
modifier|*
modifier|*
name|pathp
parameter_list|,
name|char
modifier|*
modifier|*
name|namep
parameter_list|,
name|int
modifier|*
name|nodeoff
parameter_list|)
block|{
name|int
name|o
decl_stmt|;
name|char
modifier|*
name|path
init|=
operator|*
name|pathp
decl_stmt|,
modifier|*
name|name
init|=
name|NULL
decl_stmt|,
modifier|*
name|subpath
init|=
name|NULL
decl_stmt|;
name|subpath
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subpath
operator|==
name|NULL
condition|)
block|{
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|name
operator|=
name|path
expr_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|cwd
expr_stmt|;
block|}
else|else
block|{
operator|*
name|subpath
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|=
name|cwd
expr_stmt|;
name|name
operator|=
name|subpath
operator|+
literal|1
expr_stmt|;
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"name not specified"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not find node: '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|*
name|namep
operator|=
name|name
expr_stmt|;
operator|*
name|nodeoff
operator|=
name|o
expr_stmt|;
operator|*
name|pathp
operator|=
name|path
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_prop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|propname
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|o
decl_stmt|,
name|next
decl_stmt|,
name|depth
decl_stmt|,
name|rv
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|path
operator|=
operator|(
name|argc
operator|>
literal|2
operator|)
condition|?
name|argv
index|[
literal|2
index|]
else|:
name|NULL
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
comment|/* Merge property value strings into one */
if|if
condition|(
name|fdt_merge_strings
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
else|else
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
name|cwd
expr_stmt|;
name|rv
operator|=
name|CMD_OK
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
comment|/* If value is specified -- try to modify prop. */
if|if
condition|(
name|fdt_extract_nameloc
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|propname
argument_list|,
operator|&
name|o
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
name|rv
operator|=
name|fdt_modprop
argument_list|(
name|o
argument_list|,
name|propname
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
comment|/* User wants to display properties */
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not find node: '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|rv
operator|=
name|CMD_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|depth
operator|>=
literal|0
condition|)
block|{
name|tag
operator|=
name|fdt_next_tag
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
operator|&
name|next
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|FDT_NOP
case|:
break|break;
case|case
name|FDT_PROP
case|:
if|if
condition|(
name|depth
operator|>
literal|1
condition|)
comment|/* Don't process properties of nested nodes */
break|break;
if|if
condition|(
name|fdt_prop
argument_list|(
name|o
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not process "
literal|"property"
argument_list|)
expr_stmt|;
name|rv
operator|=
name|CMD_ERROR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|FDT_BEGIN_NODE
case|:
name|depth
operator|++
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|FDT_MAX_DEPTH
condition|)
block|{
name|printf
argument_list|(
literal|"warning: nesting too deep: %d\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|FDT_END_NODE
case|:
name|depth
operator|--
expr_stmt|;
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
comment|/* 				 * This is the end of our starting node, force 				 * the loop finish. 				 */
name|depth
operator|--
expr_stmt|;
break|break;
block|}
name|o
operator|=
name|next
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_mkprop
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|o
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|propname
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|path
operator|=
operator|(
name|argc
operator|>
literal|2
operator|)
condition|?
name|argv
index|[
literal|2
index|]
else|:
name|NULL
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
comment|/* Merge property value strings into one */
if|if
condition|(
name|fdt_merge_strings
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|3
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
else|else
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fdt_extract_nameloc
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|propname
argument_list|,
operator|&
name|o
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
if|if
condition|(
name|fdt_modprop
argument_list|(
name|o
argument_list|,
name|propname
argument_list|,
name|value
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_rm
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|o
decl_stmt|,
name|rv
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|propname
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|path
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"no node/property name specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
name|o
operator|=
name|fdt_path_offset
argument_list|(
name|fdtp
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|<
literal|0
condition|)
block|{
comment|/* If node not found -- try to find& delete property */
if|if
condition|(
name|fdt_extract_nameloc
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|propname
argument_list|,
operator|&
name|o
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
if|if
condition|(
operator|(
name|rv
operator|=
name|fdt_delprop
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
name|propname
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not delete"
literal|"%s\n"
argument_list|,
operator|(
name|rv
operator|==
operator|-
name|FDT_ERR_NOTFOUND
operator|)
condition|?
literal|"(property/node does not exist)"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
else|else
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
comment|/* If node exists -- remove node */
name|rv
operator|=
name|fdt_del_node
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"could not delete node"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_mknode
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|o
decl_stmt|,
name|rv
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|nodename
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|path
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"no node name specified"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|fdt_extract_nameloc
argument_list|(
operator|&
name|path
argument_list|,
operator|&
name|nodename
argument_list|,
operator|&
name|o
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
name|rv
operator|=
name|fdt_add_subnode
argument_list|(
name|fdtp
argument_list|,
name|o
argument_list|,
name|nodename
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rv
operator|==
operator|-
name|FDT_ERR_NOSPACE
condition|)
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Device tree blob is too small!\n"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|command_errbuf
argument_list|,
literal|"Could not add node!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_pwd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|line
index|[
name|FDT_CWD_LEN
index|]
decl_stmt|;
name|pager_open
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"%s\n"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|pager_close
argument_list|()
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_mres
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|uint64_t
name|start
decl_stmt|,
name|size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|total
decl_stmt|;
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|pager_open
argument_list|()
expr_stmt|;
name|total
operator|=
name|fdt_num_mem_rsv
argument_list|(
name|fdtp
argument_list|)
expr_stmt|;
if|if
condition|(
name|total
operator|>
literal|0
condition|)
block|{
name|pager_output
argument_list|(
literal|"Reserved memory regions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
block|{
name|fdt_get_mem_rsv
argument_list|(
name|fdtp
argument_list|,
name|i
argument_list|,
operator|&
name|start
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"reg#%d: (start: 0x%jx, size: 0x%jx)\n"
argument_list|,
name|i
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|pager_output
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|pager_output
argument_list|(
literal|"No reserved memory regions\n"
argument_list|)
expr_stmt|;
name|pager_close
argument_list|()
expr_stmt|;
return|return
operator|(
name|CMD_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fdt_cmd_nyi
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|printf
argument_list|(
literal|"command not yet implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMD_ERROR
operator|)
return|;
block|}
end_function

end_unit

