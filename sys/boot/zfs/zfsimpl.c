begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *	Stand-alone ZFS file reader.  */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|"zfsimpl.h"
end_include

begin_include
include|#
directive|include
file|"zfssubr.c"
end_include

begin_struct
struct|struct
name|zfsmount
block|{
specifier|const
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|objset_phys_t
name|objset
decl_stmt|;
name|uint64_t
name|rootobj
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * List of all vdevs, chained through v_alllink.  */
end_comment

begin_decl_stmt
specifier|static
name|vdev_list_t
name|zfs_vdevs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of ZFS features supported for read  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|features_for_read
index|[]
init|=
block|{
literal|"org.illumos:lz4_compress"
block|,
literal|"com.delphix:hole_birth"
block|,
literal|"com.delphix:extensible_dataset"
block|,
literal|"com.delphix:embedded_data"
block|,
literal|"org.open-zfs:large_blocks"
block|,
literal|"org.illumos:sha512"
block|,
literal|"org.illumos:skein"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of all pools, chained through spa_link.  */
end_comment

begin_decl_stmt
specifier|static
name|spa_list_t
name|zfs_pools
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|dnode_phys_t
modifier|*
name|dnode_cache_obj
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|dnode_cache_bn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dnode_cache_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zap_scratch
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zfs_temp_buf
decl_stmt|,
modifier|*
name|zfs_temp_end
decl_stmt|,
modifier|*
name|zfs_temp_ptr
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEMP_SIZE
value|(1024 * 1024)
end_define

begin_function_decl
specifier|static
name|int
name|zio_read
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_get_root
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
modifier|*
name|objid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_rlookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|objnum
parameter_list|,
name|char
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zap_lookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|zfs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|zfs_vdevs
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|zfs_pools
argument_list|)
expr_stmt|;
name|zfs_temp_buf
operator|=
name|malloc
argument_list|(
name|TEMP_SIZE
argument_list|)
expr_stmt|;
name|zfs_temp_end
operator|=
name|zfs_temp_buf
operator|+
name|TEMP_SIZE
expr_stmt|;
name|zfs_temp_ptr
operator|=
name|zfs_temp_buf
expr_stmt|;
name|dnode_cache_buf
operator|=
name|malloc
argument_list|(
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zap_scratch
operator|=
name|malloc
argument_list|(
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zfs_init_crc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|zfs_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|zfs_temp_ptr
operator|+
name|size
operator|>
name|zfs_temp_end
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: out of temporary buffer space\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
block|}
name|ptr
operator|=
name|zfs_temp_ptr
expr_stmt|;
name|zfs_temp_ptr
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|zfs_temp_ptr
operator|-=
name|size
expr_stmt|;
if|if
condition|(
name|zfs_temp_ptr
operator|!=
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: zfs_alloc()/zfs_free() mismatch\n"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
empty_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|xdr_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|xdr
parameter_list|,
name|int
modifier|*
name|ip
parameter_list|)
block|{
operator|*
name|ip
operator|=
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
operator|(
operator|*
name|xdr
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xdr_u_int
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|xdr
parameter_list|,
name|u_int
modifier|*
name|ip
parameter_list|)
block|{
operator|*
name|ip
operator|=
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|xdr
operator|)
index|[
literal|3
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
operator|(
operator|*
name|xdr
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|xdr_uint64_t
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
modifier|*
name|xdr
parameter_list|,
name|uint64_t
modifier|*
name|lp
parameter_list|)
block|{
name|u_int
name|hi
decl_stmt|,
name|lo
decl_stmt|;
name|xdr_u_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|hi
argument_list|)
expr_stmt|;
name|xdr_u_int
argument_list|(
name|xdr
argument_list|,
operator|&
name|lo
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|hi
operator|)
operator|<<
literal|32
operator|)
operator||
name|lo
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_find
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|elementsp
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pair
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
name|encoded_size
decl_stmt|,
name|decoded_size
decl_stmt|;
name|p
operator|=
name|nvlist
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|encoded_size
operator|&&
name|decoded_size
condition|)
block|{
name|int
name|namelen
decl_stmt|,
name|pairtype
decl_stmt|,
name|elements
decl_stmt|;
specifier|const
name|char
modifier|*
name|pairname
decl_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
name|pairname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|roundup
argument_list|(
name|namelen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|pairtype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|name
argument_list|,
name|pairname
argument_list|,
name|namelen
argument_list|)
operator|&&
name|type
operator|==
name|pairtype
condition|)
block|{
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|elements
argument_list|)
expr_stmt|;
if|if
condition|(
name|elementsp
condition|)
operator|*
name|elementsp
operator|=
name|elements
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
name|xdr_uint64_t
argument_list|(
operator|&
name|p
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
name|valuep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
name|int
name|len
decl_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|valuep
operator|)
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|DATA_TYPE_NVLIST
operator|||
name|type
operator|==
name|DATA_TYPE_NVLIST_ARRAY
condition|)
block|{
operator|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|*
operator|)
name|valuep
operator|)
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Not the pair we are looking for, skip to the next one. 			 */
name|p
operator|=
name|pair
operator|+
name|encoded_size
expr_stmt|;
block|}
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nvlist_check_features_for_read
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pair
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
name|encoded_size
decl_stmt|,
name|decoded_size
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|nvlist
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|encoded_size
operator|&&
name|decoded_size
condition|)
block|{
name|int
name|namelen
decl_stmt|,
name|pairtype
decl_stmt|;
specifier|const
name|char
modifier|*
name|pairname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
name|pairname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|roundup
argument_list|(
name|namelen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|pairtype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|features_for_read
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|pairname
argument_list|,
name|features_for_read
index|[
name|i
index|]
argument_list|,
name|namelen
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unsupported feature: %s\n"
argument_list|,
name|pairname
argument_list|)
expr_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
block|}
name|p
operator|=
name|pair
operator|+
name|encoded_size
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the next nvlist in an nvlist array.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist_next
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pair
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
name|encoded_size
decl_stmt|,
name|decoded_size
decl_stmt|;
name|p
operator|=
name|nvlist
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|encoded_size
operator|&&
name|decoded_size
condition|)
block|{
name|p
operator|=
name|pair
operator|+
name|encoded_size
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist_print
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
parameter_list|,
name|unsigned
name|int
name|indent
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|typenames
index|[]
init|=
block|{
literal|"DATA_TYPE_UNKNOWN"
block|,
literal|"DATA_TYPE_BOOLEAN"
block|,
literal|"DATA_TYPE_BYTE"
block|,
literal|"DATA_TYPE_INT16"
block|,
literal|"DATA_TYPE_UINT16"
block|,
literal|"DATA_TYPE_INT32"
block|,
literal|"DATA_TYPE_UINT32"
block|,
literal|"DATA_TYPE_INT64"
block|,
literal|"DATA_TYPE_UINT64"
block|,
literal|"DATA_TYPE_STRING"
block|,
literal|"DATA_TYPE_BYTE_ARRAY"
block|,
literal|"DATA_TYPE_INT16_ARRAY"
block|,
literal|"DATA_TYPE_UINT16_ARRAY"
block|,
literal|"DATA_TYPE_INT32_ARRAY"
block|,
literal|"DATA_TYPE_UINT32_ARRAY"
block|,
literal|"DATA_TYPE_INT64_ARRAY"
block|,
literal|"DATA_TYPE_UINT64_ARRAY"
block|,
literal|"DATA_TYPE_STRING_ARRAY"
block|,
literal|"DATA_TYPE_HRTIME"
block|,
literal|"DATA_TYPE_NVLIST"
block|,
literal|"DATA_TYPE_NVLIST_ARRAY"
block|,
literal|"DATA_TYPE_BOOLEAN_VALUE"
block|,
literal|"DATA_TYPE_INT8"
block|,
literal|"DATA_TYPE_UINT8"
block|,
literal|"DATA_TYPE_BOOLEAN_ARRAY"
block|,
literal|"DATA_TYPE_INT8_ARRAY"
block|,
literal|"DATA_TYPE_UINT8_ARRAY"
block|}
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|pair
decl_stmt|;
name|int
name|junk
decl_stmt|;
name|int
name|encoded_size
decl_stmt|,
name|decoded_size
decl_stmt|;
name|p
operator|=
name|nvlist
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|junk
argument_list|)
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|encoded_size
operator|&&
name|decoded_size
condition|)
block|{
name|int
name|namelen
decl_stmt|,
name|pairtype
decl_stmt|,
name|elements
decl_stmt|;
specifier|const
name|char
modifier|*
name|pairname
decl_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
name|pairname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|roundup
argument_list|(
name|namelen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|pairtype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s"
argument_list|,
name|typenames
index|[
name|pairtype
index|]
argument_list|,
name|pairname
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|elements
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pairtype
condition|)
block|{
case|case
name|DATA_TYPE_UINT64
case|:
block|{
name|uint64_t
name|val
decl_stmt|;
name|xdr_uint64_t
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_STRING
case|:
block|{
name|int
name|len
decl_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = \"%s\"\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DATA_TYPE_NVLIST
case|:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|nvlist_print
argument_list|(
name|p
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|elements
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"[%d]\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p
operator|=
name|nvlist_print
argument_list|(
name|p
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
name|elements
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %s"
argument_list|,
name|typenames
index|[
name|pairtype
index|]
argument_list|,
name|pairname
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|pair
operator|+
name|encoded_size
expr_stmt|;
name|pair
operator|=
name|p
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|encoded_size
argument_list|)
expr_stmt|;
name|xdr_int
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|decoded_size
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vdev_read_phys
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|psize
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|!
name|vdev
operator|->
name|v_phys_read
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|bp
condition|)
block|{
name|psize
operator|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|psize
operator|=
name|size
expr_stmt|;
block|}
comment|/*printf("ZFS: reading %d bytes at 0x%jx to %p\n", psize, (uintmax_t)offset, buf);*/
name|rc
operator|=
name|vdev
operator|->
name|v_phys_read
argument_list|(
name|vdev
argument_list|,
name|vdev
operator|->
name|v_read_priv
argument_list|,
name|offset
argument_list|,
name|buf
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|bp
operator|&&
name|zio_checksum_verify
argument_list|(
name|vdev
operator|->
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_disk_read
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
return|return
operator|(
name|vdev_read_phys
argument_list|(
name|vdev
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|,
name|offset
operator|+
name|VDEV_LABEL_START_SIZE
argument_list|,
name|bytes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_mirror_read
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|vdev_t
modifier|*
name|kid
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|EIO
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kid
argument_list|,
argument|&vdev->v_children
argument_list|,
argument|v_childlink
argument_list|)
block|{
if|if
condition|(
name|kid
operator|->
name|v_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
continue|continue;
name|rc
operator|=
name|kid
operator|->
name|v_read
argument_list|(
name|kid
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_replacing_read
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|bytes
parameter_list|)
block|{
name|vdev_t
modifier|*
name|kid
decl_stmt|;
comment|/* 	 * Here we should have two kids: 	 * First one which is the one we are replacing and we can trust 	 * only this one to have valid data, but it might not be present. 	 * Second one is that one we are replacing with. It is most likely 	 * healthy, but we can't trust it has needed data, so we won't use it. 	 */
name|kid
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|kid
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|kid
operator|->
name|v_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
name|kid
operator|->
name|v_read
argument_list|(
name|kid
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|bytes
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_find
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vdev
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vdev
argument_list|,
argument|&zfs_vdevs
argument_list|,
argument|v_alllink
argument_list|)
if|if
condition|(
name|vdev
operator|->
name|v_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vdev
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|vdev_create
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|vdev_read_t
modifier|*
name|_read
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vdev
decl_stmt|;
name|vdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|vdev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|)
expr_stmt|;
name|vdev
operator|->
name|v_guid
operator|=
name|guid
expr_stmt|;
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
name|vdev
operator|->
name|v_read
operator|=
name|_read
expr_stmt|;
name|vdev
operator|->
name|v_phys_read
operator|=
literal|0
expr_stmt|;
name|vdev
operator|->
name|v_read_priv
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|zfs_vdevs
argument_list|,
name|vdev
argument_list|,
name|v_alllink
argument_list|)
expr_stmt|;
return|return
operator|(
name|vdev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_init_from_nvlist
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
parameter_list|,
name|vdev_t
modifier|*
name|pvdev
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdevp
parameter_list|,
name|int
name|is_newer
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|id
decl_stmt|,
name|ashift
decl_stmt|,
name|nparity
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|vdev_t
modifier|*
name|vdev
decl_stmt|,
modifier|*
name|kid
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|kids
decl_stmt|;
name|int
name|nkids
decl_stmt|,
name|i
decl_stmt|,
name|is_new
decl_stmt|;
name|uint64_t
name|is_offline
decl_stmt|,
name|is_faulted
decl_stmt|,
name|is_degraded
decl_stmt|,
name|is_removed
decl_stmt|,
name|isnt_present
decl_stmt|;
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|guid
argument_list|)
operator|||
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|id
argument_list|)
operator|||
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|NULL
argument_list|,
operator|&
name|type
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find vdev details\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
ifdef|#
directive|ifdef
name|ZFS_TEST
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_FILE
argument_list|)
endif|#
directive|endif
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can only boot from disk, mirror, raidz1, raidz2 and raidz3 vdevs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|is_offline
operator|=
name|is_removed
operator|=
name|is_faulted
operator|=
name|is_degraded
operator|=
name|isnt_present
operator|=
literal|0
expr_stmt|;
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_offline
argument_list|)
expr_stmt|;
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_removed
argument_list|)
expr_stmt|;
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_faulted
argument_list|)
expr_stmt|;
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_DEGRADED
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|is_degraded
argument_list|)
expr_stmt|;
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|isnt_present
argument_list|)
expr_stmt|;
name|vdev
operator|=
name|vdev_find
argument_list|(
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdev
condition|)
block|{
name|is_new
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_MIRROR
argument_list|)
condition|)
name|vdev
operator|=
name|vdev_create
argument_list|(
name|guid
argument_list|,
name|vdev_mirror_read
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
condition|)
name|vdev
operator|=
name|vdev_create
argument_list|(
name|guid
argument_list|,
name|vdev_raidz_read
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|VDEV_TYPE_REPLACING
argument_list|)
condition|)
name|vdev
operator|=
name|vdev_create
argument_list|(
name|guid
argument_list|,
name|vdev_replacing_read
argument_list|)
expr_stmt|;
else|else
name|vdev
operator|=
name|vdev_create
argument_list|(
name|guid
argument_list|,
name|vdev_disk_read
argument_list|)
expr_stmt|;
name|vdev
operator|->
name|v_id
operator|=
name|id
expr_stmt|;
name|vdev
operator|->
name|v_top
operator|=
name|pvdev
operator|!=
name|NULL
condition|?
name|pvdev
else|:
name|vdev
expr_stmt|;
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|ashift
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vdev
operator|->
name|v_ashift
operator|=
name|ashift
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|->
name|v_ashift
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|nparity
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vdev
operator|->
name|v_nparity
operator|=
name|nparity
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|->
name|v_nparity
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|NULL
argument_list|,
operator|&
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|path
operator|+=
literal|5
expr_stmt|;
name|vdev
operator|->
name|v_name
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"raidz"
argument_list|)
condition|)
block|{
if|if
condition|(
name|vdev
operator|->
name|v_nparity
operator|==
literal|1
condition|)
name|vdev
operator|->
name|v_name
operator|=
literal|"raidz1"
expr_stmt|;
elseif|else
if|if
condition|(
name|vdev
operator|->
name|v_nparity
operator|==
literal|2
condition|)
name|vdev
operator|->
name|v_name
operator|=
literal|"raidz2"
expr_stmt|;
elseif|else
if|if
condition|(
name|vdev
operator|->
name|v_nparity
operator|==
literal|3
condition|)
name|vdev
operator|->
name|v_name
operator|=
literal|"raidz3"
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"ZFS: can only boot from disk, mirror, raidz1, raidz2 and raidz3 vdevs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
else|else
block|{
name|vdev
operator|->
name|v_name
operator|=
name|strdup
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|is_new
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|is_new
operator|||
name|is_newer
condition|)
block|{
comment|/* 		 * This is either new vdev or we've already seen this vdev, 		 * but from an older vdev label, so let's refresh its state 		 * from the newer label. 		 */
if|if
condition|(
name|is_offline
condition|)
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
elseif|else
if|if
condition|(
name|is_removed
condition|)
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_REMOVED
expr_stmt|;
elseif|else
if|if
condition|(
name|is_faulted
condition|)
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_FAULTED
expr_stmt|;
elseif|else
if|if
condition|(
name|is_degraded
condition|)
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
elseif|else
if|if
condition|(
name|isnt_present
condition|)
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_CANT_OPEN
expr_stmt|;
block|}
name|rc
operator|=
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|,
operator|&
name|nkids
argument_list|,
operator|&
name|kids
argument_list|)
expr_stmt|;
comment|/* 	 * Its ok if we don't have any kids. 	 */
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|vdev
operator|->
name|v_nchildren
operator|=
name|nkids
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nkids
condition|;
name|i
operator|++
control|)
block|{
name|rc
operator|=
name|vdev_init_from_nvlist
argument_list|(
name|kids
argument_list|,
name|vdev
argument_list|,
operator|&
name|kid
argument_list|,
name|is_newer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|is_new
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|,
name|kid
argument_list|,
name|v_childlink
argument_list|)
expr_stmt|;
name|kids
operator|=
name|nvlist_next
argument_list|(
name|kids
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vdev
operator|->
name|v_nchildren
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vdevp
condition|)
operator|*
name|vdevp
operator|=
name|vdev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_set_state
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|)
block|{
name|vdev_t
modifier|*
name|kid
decl_stmt|;
name|int
name|good_kids
decl_stmt|;
name|int
name|bad_kids
decl_stmt|;
comment|/* 	 * A mirror or raidz is healthy if all its kids are healthy. A 	 * mirror is degraded if any of its kids is healthy; a raidz 	 * is degraded if at most nparity kids are offline. 	 */
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|)
condition|)
block|{
name|good_kids
operator|=
literal|0
expr_stmt|;
name|bad_kids
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|kid
argument_list|,
argument|&vdev->v_children
argument_list|,
argument|v_childlink
argument_list|)
block|{
if|if
condition|(
name|kid
operator|->
name|v_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
name|good_kids
operator|++
expr_stmt|;
else|else
name|bad_kids
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bad_kids
operator|==
literal|0
condition|)
block|{
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_HEALTHY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vdev
operator|->
name|v_read
operator|==
name|vdev_mirror_read
condition|)
block|{
if|if
condition|(
name|good_kids
condition|)
block|{
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vdev
operator|->
name|v_read
operator|==
name|vdev_raidz_read
condition|)
block|{
if|if
condition|(
name|bad_kids
operator|>
name|vdev
operator|->
name|v_nparity
condition|)
block|{
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_OFFLINE
expr_stmt|;
block|}
else|else
block|{
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|spa_t
modifier|*
name|spa_find_by_guid
parameter_list|(
name|uint64_t
name|guid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|spa
argument_list|,
argument|&zfs_pools
argument_list|,
argument|spa_link
argument_list|)
if|if
condition|(
name|spa
operator|->
name|spa_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|spa
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|spa_t
modifier|*
name|spa_find_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|spa
argument_list|,
argument|&zfs_pools
argument_list|,
argument|spa_link
argument_list|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|spa
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BOOT2
end_ifdef

begin_function
specifier|static
name|spa_t
modifier|*
name|spa_get_primary
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|zfs_pools
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vdev_t
modifier|*
name|spa_get_primary_vdev
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vdev
decl_stmt|;
name|vdev_t
modifier|*
name|kid
decl_stmt|;
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
name|spa
operator|=
name|spa_get_primary
argument_list|()
expr_stmt|;
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vdev
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdevs
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|kid
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|)
init|;
name|kid
operator|!=
name|NULL
condition|;
name|kid
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|vdev
operator|->
name|v_children
argument_list|)
control|)
name|vdev
operator|=
name|kid
expr_stmt|;
return|return
operator|(
name|vdev
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|spa_t
modifier|*
name|spa_create
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|spa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|->
name|spa_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|spa
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|STAILQ_INIT
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdevs
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_guid
operator|=
name|guid
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|zfs_pools
argument_list|,
name|spa
argument_list|,
name|spa_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|state_name
parameter_list|(
name|vdev_state_t
name|state
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|names
index|[]
init|=
block|{
literal|"UNKNOWN"
block|,
literal|"CLOSED"
block|,
literal|"OFFLINE"
block|,
literal|"REMOVED"
block|,
literal|"CANT_OPEN"
block|,
literal|"FAULTED"
block|,
literal|"DEGRADED"
block|,
literal|"ONLINE"
block|}
decl_stmt|;
return|return
name|names
index|[
name|state
index|]
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BOOT2
end_ifdef

begin_define
define|#
directive|define
name|pager_printf
value|printf
end_define

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|pager_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|line
index|[
literal|80
index|]
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|line
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager_output
argument_list|(
name|line
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|STATUS_FORMAT
value|"        %s %s\n"
end_define

begin_function
specifier|static
name|int
name|print_state
parameter_list|(
name|int
name|indent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|vdev_state_t
name|state
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|buf
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|pager_printf
argument_list|(
name|STATUS_FORMAT
argument_list|,
name|buf
argument_list|,
name|state_name
argument_list|(
name|state
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_status
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|vdev_t
modifier|*
name|kid
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|print_state
argument_list|(
name|indent
argument_list|,
name|vdev
operator|->
name|v_name
argument_list|,
name|vdev
operator|->
name|v_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|STAILQ_FOREACH
argument_list|(
argument|kid
argument_list|,
argument|&vdev->v_children
argument_list|,
argument|v_childlink
argument_list|)
block|{
name|ret
operator|=
name|vdev_status
argument_list|(
name|kid
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_status
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
specifier|static
name|char
name|bootfs
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|uint64_t
name|rootid
decl_stmt|;
name|vdev_t
modifier|*
name|vdev
decl_stmt|;
name|int
name|good_kids
decl_stmt|,
name|bad_kids
decl_stmt|,
name|degraded_kids
decl_stmt|,
name|ret
decl_stmt|;
name|vdev_state_t
name|state
decl_stmt|;
name|ret
operator|=
name|pager_printf
argument_list|(
literal|"  pool: %s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|zfs_get_root
argument_list|(
name|spa
argument_list|,
operator|&
name|rootid
argument_list|)
operator|==
literal|0
operator|&&
name|zfs_rlookup
argument_list|(
name|spa
argument_list|,
name|rootid
argument_list|,
name|bootfs
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootfs
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|ret
operator|=
name|pager_printf
argument_list|(
literal|"bootfs: %s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|pager_printf
argument_list|(
literal|"bootfs: %s/%s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|bootfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ret
operator|=
name|pager_printf
argument_list|(
literal|"config:\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|pager_printf
argument_list|(
name|STATUS_FORMAT
argument_list|,
literal|"NAME"
argument_list|,
literal|"STATE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|good_kids
operator|=
literal|0
expr_stmt|;
name|degraded_kids
operator|=
literal|0
expr_stmt|;
name|bad_kids
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vdev
argument_list|,
argument|&spa->spa_vdevs
argument_list|,
argument|v_childlink
argument_list|)
block|{
if|if
condition|(
name|vdev
operator|->
name|v_state
operator|==
name|VDEV_STATE_HEALTHY
condition|)
name|good_kids
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|vdev
operator|->
name|v_state
operator|==
name|VDEV_STATE_DEGRADED
condition|)
name|degraded_kids
operator|++
expr_stmt|;
else|else
name|bad_kids
operator|++
expr_stmt|;
block|}
name|state
operator|=
name|VDEV_STATE_CLOSED
expr_stmt|;
if|if
condition|(
name|good_kids
operator|>
literal|0
operator|&&
operator|(
name|degraded_kids
operator|+
name|bad_kids
operator|)
operator|==
literal|0
condition|)
name|state
operator|=
name|VDEV_STATE_HEALTHY
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|good_kids
operator|+
name|degraded_kids
operator|)
operator|>
literal|0
condition|)
name|state
operator|=
name|VDEV_STATE_DEGRADED
expr_stmt|;
name|ret
operator|=
name|print_state
argument_list|(
literal|0
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|STAILQ_FOREACH
argument_list|(
argument|vdev
argument_list|,
argument|&spa->spa_vdevs
argument_list|,
argument|v_childlink
argument_list|)
block|{
name|ret
operator|=
name|vdev_status
argument_list|(
name|vdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_all_status
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|spa
argument_list|,
argument|&zfs_pools
argument_list|,
argument|spa_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|ret
operator|=
name|pager_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|spa_status
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|vdev_label_offset
parameter_list|(
name|uint64_t
name|psize
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|uint64_t
name|label_offset
decl_stmt|;
if|if
condition|(
name|l
operator|<
name|VDEV_LABELS
operator|/
literal|2
condition|)
name|label_offset
operator|=
literal|0
expr_stmt|;
else|else
name|label_offset
operator|=
name|psize
operator|-
name|VDEV_LABELS
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|+
name|l
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|+
name|label_offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_probe
parameter_list|(
name|vdev_phys_read_t
modifier|*
name|_read
parameter_list|,
name|void
modifier|*
name|read_priv
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spap
parameter_list|)
block|{
name|vdev_t
name|vtmp
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vdev_label
init|=
operator|(
name|vdev_phys_t
operator|*
operator|)
name|zap_scratch
decl_stmt|;
name|vdev_phys_t
modifier|*
name|tmp_label
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|vdev_t
modifier|*
name|vdev
decl_stmt|,
modifier|*
name|top_vdev
decl_stmt|,
modifier|*
name|pool_vdev
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|blkptr_t
name|bp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|uint64_t
name|best_txg
init|=
literal|0
decl_stmt|;
name|uint64_t
name|pool_txg
decl_stmt|,
name|pool_guid
decl_stmt|;
name|uint64_t
name|psize
decl_stmt|;
specifier|const
name|char
modifier|*
name|pool_name
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|vdevs
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|features
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|rc
decl_stmt|,
name|is_newer
decl_stmt|;
name|char
modifier|*
name|upbuf
decl_stmt|;
specifier|const
name|struct
name|uberblock
modifier|*
name|up
decl_stmt|;
comment|/* 	 * Load the vdev label and figure out which 	 * uberblock is most current. 	 */
name|memset
argument_list|(
operator|&
name|vtmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vtmp
argument_list|)
argument_list|)
expr_stmt|;
name|vtmp
operator|.
name|v_phys_read
operator|=
name|_read
expr_stmt|;
name|vtmp
operator|.
name|v_read_priv
operator|=
name|read_priv
expr_stmt|;
name|psize
operator|=
name|P2ALIGN
argument_list|(
name|ldi_get_size
argument_list|(
name|read_priv
argument_list|)
argument_list|,
operator|(
name|uint64_t
operator|)
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Test for minimum pool size. */
if|if
condition|(
name|psize
operator|<
name|SPA_MINDEVSIZE
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|tmp_label
operator|=
name|zfs_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|off
operator|=
name|vdev_label_offset
argument_list|(
name|psize
argument_list|,
name|l
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
operator|&
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
operator|&
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
operator|&
name|bp
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
operator|&
name|bp
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|DVA_SET_OFFSET
argument_list|(
name|BP_IDENTITY
argument_list|(
operator|&
name|bp
argument_list|)
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
operator|&
name|bp
operator|.
name|blk_cksum
argument_list|,
name|off
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_read_phys
argument_list|(
operator|&
name|vtmp
argument_list|,
operator|&
name|bp
argument_list|,
name|tmp_label
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tmp_label
operator|->
name|vp_nvlist
index|[
literal|0
index|]
operator|!=
name|NV_ENCODE_XDR
condition|)
continue|continue;
name|nvlist
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|tmp_label
operator|->
name|vp_nvlist
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|pool_txg
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|best_txg
operator|<=
name|pool_txg
condition|)
block|{
name|best_txg
operator|=
name|pool_txg
expr_stmt|;
name|memcpy
argument_list|(
name|vdev_label
argument_list|,
name|tmp_label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_free
argument_list|(
name|tmp_label
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|best_txg
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|vdev_label
operator|->
name|vp_nvlist
index|[
literal|0
index|]
operator|!=
name|NV_ENCODE_XDR
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|nvlist
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|vdev_label
operator|->
name|vp_nvlist
operator|+
literal|4
expr_stmt|;
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unsupported ZFS version %u (should be %u)\n"
argument_list|,
operator|(
name|unsigned
operator|)
name|val
argument_list|,
operator|(
name|unsigned
operator|)
name|SPA_VERSION
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* Check ZFS features for read */
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_FEATURES_FOR_READ
argument_list|,
name|DATA_TYPE_NVLIST
argument_list|,
name|NULL
argument_list|,
operator|&
name|features
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_check_features_for_read
argument_list|(
name|features
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|val
operator|==
name|POOL_STATE_DESTROYED
condition|)
block|{
comment|/* We don't boot only from destroyed pools. */
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|pool_txg
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|DATA_TYPE_STRING
argument_list|,
name|NULL
argument_list|,
operator|&
name|pool_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Cache and spare devices end up here - just ignore 		 * them. 		 */
comment|/*printf("ZFS: can't find pool details\n");*/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
operator|&&
name|val
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Create the pool if this is the first time we've seen it. 	 */
name|spa
operator|=
name|spa_find_by_guid
argument_list|(
name|pool_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
block|{
name|spa
operator|=
name|spa_create
argument_list|(
name|pool_guid
argument_list|,
name|pool_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|pool_txg
operator|>
name|spa
operator|->
name|spa_txg
condition|)
block|{
name|spa
operator|->
name|spa_txg
operator|=
name|pool_txg
expr_stmt|;
name|is_newer
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|is_newer
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Get the vdev tree and create our in-core copy of it. 	 * If we already have a vdev with this guid, this must 	 * be some kind of alias (overlapping slices, dangerously dedicated 	 * disks etc). 	 */
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|DATA_TYPE_UINT64
argument_list|,
name|NULL
argument_list|,
operator|&
name|guid
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|vdev
operator|=
name|vdev_find
argument_list|(
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
operator|&&
name|vdev
operator|->
name|v_phys_read
condition|)
comment|/* Has this vdev already been inited? */
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|nvlist_find
argument_list|(
name|nvlist
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|DATA_TYPE_NVLIST
argument_list|,
name|NULL
argument_list|,
operator|&
name|vdevs
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|rc
operator|=
name|vdev_init_from_nvlist
argument_list|(
name|vdevs
argument_list|,
name|NULL
argument_list|,
operator|&
name|top_vdev
argument_list|,
name|is_newer
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
comment|/* 	 * Add the toplevel vdev to the pool if its not already there. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|pool_vdev
argument_list|,
argument|&spa->spa_vdevs
argument_list|,
argument|v_childlink
argument_list|)
if|if
condition|(
name|top_vdev
operator|==
name|pool_vdev
condition|)
break|break;
if|if
condition|(
operator|!
name|pool_vdev
operator|&&
name|top_vdev
condition|)
block|{
name|top_vdev
operator|->
name|spa
operator|=
name|spa
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdevs
argument_list|,
name|top_vdev
argument_list|,
name|v_childlink
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We should already have created an incomplete vdev for this 	 * vdev. Find it and initialise it with our read proc. 	 */
name|vdev
operator|=
name|vdev_find
argument_list|(
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
condition|)
block|{
name|vdev
operator|->
name|v_phys_read
operator|=
name|_read
expr_stmt|;
name|vdev
operator|->
name|v_read_priv
operator|=
name|read_priv
expr_stmt|;
name|vdev
operator|->
name|v_state
operator|=
name|VDEV_STATE_HEALTHY
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ZFS: inconsistent nvlist contents\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Re-evaluate top-level vdev state. 	 */
name|vdev_set_state
argument_list|(
name|top_vdev
argument_list|)
expr_stmt|;
comment|/* 	 * Ok, we are happy with the pool so far. Lets find 	 * the best uberblock and then we can actually access 	 * the contents of the pool. 	 */
name|upbuf
operator|=
name|zfs_alloc
argument_list|(
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
name|up
operator|=
operator|(
specifier|const
expr|struct
name|uberblock
operator|*
operator|)
name|upbuf
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vdev
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|off
operator|=
name|vdev_label_offset
argument_list|(
name|psize
argument_list|,
name|l
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vdev
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
name|DVA_SET_OFFSET
argument_list|(
operator|&
name|bp
operator|.
name|blk_dva
index|[
literal|0
index|]
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
operator|&
name|bp
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
operator|&
name|bp
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
operator|&
name|bp
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
operator|&
name|bp
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
operator|&
name|bp
operator|.
name|blk_cksum
argument_list|,
name|off
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_read_phys
argument_list|(
name|vdev
argument_list|,
operator|&
name|bp
argument_list|,
name|upbuf
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|up
operator|->
name|ub_magic
operator|!=
name|UBERBLOCK_MAGIC
condition|)
continue|continue;
if|if
condition|(
name|up
operator|->
name|ub_txg
operator|<
name|spa
operator|->
name|spa_txg
condition|)
continue|continue;
if|if
condition|(
name|up
operator|->
name|ub_txg
operator|>
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|||
operator|(
name|up
operator|->
name|ub_txg
operator|==
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|&&
name|up
operator|->
name|ub_timestamp
operator|>
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
operator|)
condition|)
block|{
name|spa
operator|->
name|spa_uberblock
operator|=
operator|*
name|up
expr_stmt|;
block|}
block|}
block|}
name|zfs_free
argument_list|(
name|upbuf
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vdev
argument_list|)
argument_list|)
expr_stmt|;
name|vdev
operator|->
name|spa
operator|=
name|spa
expr_stmt|;
if|if
condition|(
name|spap
operator|!=
name|NULL
condition|)
operator|*
name|spap
operator|=
name|spa
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ilog2
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
literal|0
init|;
name|v
operator|<
literal|32
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|n
operator|==
operator|(
literal|1
operator|<<
name|v
operator|)
condition|)
return|return
name|v
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_read_gang
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|blkptr_t
name|gbh_bp
decl_stmt|;
name|zio_gbh_phys_t
name|zio_gb
decl_stmt|;
name|char
modifier|*
name|pbuf
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Artificial BP for gang block header. */
name|gbh_bp
operator|=
operator|*
name|bp
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
operator|&
name|gbh_bp
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
operator|&
name|gbh_bp
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
operator|&
name|gbh_bp
argument_list|,
name|ZIO_CHECKSUM_GANG_HEADER
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
operator|&
name|gbh_bp
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|i
operator|++
control|)
name|DVA_SET_GANG
argument_list|(
operator|&
name|gbh_bp
operator|.
name|blk_dva
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read gang header block using the artificial BP. */
if|if
condition|(
name|zio_read
argument_list|(
name|spa
argument_list|,
operator|&
name|gbh_bp
argument_list|,
operator|&
name|zio_gb
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|pbuf
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|i
operator|++
control|)
block|{
name|blkptr_t
modifier|*
name|gbp
init|=
operator|&
name|zio_gb
operator|.
name|zg_blkptr
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|gbp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|zio_read
argument_list|(
name|spa
argument_list|,
name|gbp
argument_list|,
name|pbuf
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|pbuf
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|gbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_checksum_verify
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_read
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|cpfunc
init|=
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|align
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|pbuf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * Process data embedded in block pointer 	 */
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|BPE_GET_ETYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_EMBEDDED_TYPE_DATA
argument_list|)
expr_stmt|;
name|size
operator|=
name|BPE_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|<=
name|BPE_PAYLOAD_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpfunc
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
name|pbuf
operator|=
name|zfs_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|pbuf
operator|=
name|buf
expr_stmt|;
name|decode_embedded_bp_compressed
argument_list|(
name|bp
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cpfunc
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
block|{
name|error
operator|=
name|zio_decompress_data
argument_list|(
name|cpfunc
argument_list|,
name|pbuf
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_free
argument_list|(
name|pbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ZFS: i/o error - unable to decompress block pointer data, error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|EIO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPA_DVAS_PER_BP
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
decl_stmt|;
name|vdev_t
modifier|*
name|vdev
decl_stmt|;
name|int
name|vdevid
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
if|if
condition|(
operator|!
name|dva
operator|->
name|dva_word
index|[
literal|0
index|]
operator|&&
operator|!
name|dva
operator|->
name|dva_word
index|[
literal|1
index|]
condition|)
continue|continue;
name|vdevid
operator|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
expr_stmt|;
name|offset
operator|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|vdev
argument_list|,
argument|&spa->spa_vdevs
argument_list|,
argument|v_childlink
argument_list|)
block|{
if|if
condition|(
name|vdev
operator|->
name|v_id
operator|==
name|vdevid
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|vdev
operator|||
operator|!
name|vdev
operator|->
name|v_read
condition|)
continue|continue;
name|size
operator|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev
operator|->
name|v_read
operator|==
name|vdev_raidz_read
condition|)
block|{
name|align
operator|=
literal|1ULL
operator|<<
name|vdev
operator|->
name|v_top
operator|->
name|v_ashift
expr_stmt|;
if|if
condition|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
operator|!=
literal|0
condition|)
name|size
operator|=
name|P2ROUNDUP
argument_list|(
name|size
argument_list|,
name|align
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|!=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|||
name|cpfunc
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
name|pbuf
operator|=
name|zfs_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|pbuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
condition|)
name|error
operator|=
name|zio_read_gang
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|pbuf
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|vdev
operator|->
name|v_read
argument_list|(
name|vdev
argument_list|,
name|bp
argument_list|,
name|pbuf
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cpfunc
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
name|error
operator|=
name|zio_decompress_data
argument_list|(
name|cpfunc
argument_list|,
name|pbuf
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|buf
argument_list|,
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|!=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
condition|)
name|bcopy
argument_list|(
name|pbuf
argument_list|,
name|buf
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
operator|!=
name|pbuf
condition|)
name|zfs_free
argument_list|(
name|pbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"ZFS: i/o error - all block copies unavailable\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dnode_read
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|ibshift
init|=
name|dnode
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
decl_stmt|;
name|int
name|bsize
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|int
name|nlevels
init|=
name|dnode
operator|->
name|dn_nlevels
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|bsize
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: I/O error - blocks larger than %llu are not "
literal|"supported\n"
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Note: bsize may not be a power of two here so we need to do an 	 * actual divide rather than a bitshift. 	 */
while|while
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
name|uint64_t
name|bn
init|=
name|offset
operator|/
name|bsize
decl_stmt|;
name|int
name|boff
init|=
name|offset
operator|%
name|bsize
decl_stmt|;
name|int
name|ibn
decl_stmt|;
specifier|const
name|blkptr_t
modifier|*
name|indbp
decl_stmt|;
name|blkptr_t
name|bp
decl_stmt|;
if|if
condition|(
name|bn
operator|>
name|dnode
operator|->
name|dn_maxblkid
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|dnode
operator|==
name|dnode_cache_obj
operator|&&
name|bn
operator|==
name|dnode_cache_bn
condition|)
goto|goto
name|cached
goto|;
name|indbp
operator|=
name|dnode
operator|->
name|dn_blkptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlevels
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Copy the bp from the indirect array so that 			 * we can re-use the scratch buffer for multi-level 			 * objects. 			 */
name|ibn
operator|=
name|bn
operator|>>
operator|(
operator|(
name|nlevels
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
name|ibshift
operator|)
expr_stmt|;
name|ibn
operator|&=
operator|(
operator|(
literal|1
operator|<<
name|ibshift
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|bp
operator|=
name|indbp
index|[
name|ibn
index|]
expr_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|bp
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|dnode_cache_buf
argument_list|,
literal|0
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
break|break;
block|}
name|rc
operator|=
name|zio_read
argument_list|(
name|spa
argument_list|,
operator|&
name|bp
argument_list|,
name|dnode_cache_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|indbp
operator|=
operator|(
specifier|const
name|blkptr_t
operator|*
operator|)
name|dnode_cache_buf
expr_stmt|;
block|}
name|dnode_cache_obj
operator|=
name|dnode
expr_stmt|;
name|dnode_cache_bn
operator|=
name|bn
expr_stmt|;
name|cached
label|:
comment|/* 		 * The buffer contains our data block. Copy what we 		 * need from it and loop. 		 */
name|i
operator|=
name|bsize
operator|-
name|boff
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|buflen
condition|)
name|i
operator|=
name|buflen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|dnode_cache_buf
index|[
name|boff
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|)
operator|+
name|i
expr_stmt|;
name|offset
operator|+=
name|i
expr_stmt|;
name|buflen
operator|-=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a value in a microzap directory. Assumes that the zap  * scratch buffer contains the directory contents.  */
end_comment

begin_function
specifier|static
name|int
name|mzap_lookup
parameter_list|(
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|mzap_phys_t
modifier|*
name|mz
decl_stmt|;
specifier|const
name|mzap_ent_phys_t
modifier|*
name|mze
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|chunks
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Microzap objects use exactly one block. Read the whole 	 * thing. 	 */
name|size
operator|=
name|dnode
operator|->
name|dn_datablkszsec
operator|*
literal|512
expr_stmt|;
name|mz
operator|=
operator|(
specifier|const
name|mzap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
name|chunks
operator|=
name|size
operator|/
name|MZAP_ENT_LEN
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunks
condition|;
name|i
operator|++
control|)
block|{
name|mze
operator|=
operator|&
name|mz
operator|->
name|mz_chunk
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|mze
operator|->
name|mze_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|value
operator|=
name|mze
operator|->
name|mze_value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare a name with a zap leaf entry. Return non-zero if the name  * matches.  */
end_comment

begin_function
specifier|static
name|int
name|fzap_name_equal
parameter_list|(
specifier|const
name|zap_leaf_t
modifier|*
name|zl
parameter_list|,
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|zc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|namelen
decl_stmt|;
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|nc
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|namelen
operator|=
name|zc
operator|->
name|l_entry
operator|.
name|le_name_numints
expr_stmt|;
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|zc
operator|->
name|l_entry
operator|.
name|le_name_chunk
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|namelen
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|namelen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ZAP_LEAF_ARRAY_BYTES
condition|)
name|len
operator|=
name|ZAP_LEAF_ARRAY_BYTES
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_array
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|+=
name|len
expr_stmt|;
name|namelen
operator|-=
name|len
expr_stmt|;
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_next
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Extract a uint64_t value from a zap leaf entry.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|fzap_leaf_value
parameter_list|(
specifier|const
name|zap_leaf_t
modifier|*
name|zl
parameter_list|,
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|zc
parameter_list|)
block|{
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|vc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|vc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|zc
operator|->
name|l_entry
operator|.
name|le_value_chunk
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|value
operator|=
literal|0
operator|,
name|p
operator|=
name|vc
operator|->
name|l_array
operator|.
name|la_array
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|p
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stv
parameter_list|(
name|int
name|len
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|4
case|:
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|8
case|:
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract a array from a zap leaf entry.  */
end_comment

begin_function
specifier|static
name|void
name|fzap_leaf_array
parameter_list|(
specifier|const
name|zap_leaf_t
modifier|*
name|zl
parameter_list|,
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|zc
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|uint64_t
name|array_int_len
init|=
name|zc
operator|->
name|l_entry
operator|.
name|le_value_intlen
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|uint64_t
modifier|*
name|u64
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|int
name|len
init|=
name|MIN
argument_list|(
name|zc
operator|->
name|l_entry
operator|.
name|le_value_numints
argument_list|,
name|num_integers
argument_list|)
decl_stmt|;
name|int
name|chunk
init|=
name|zc
operator|->
name|l_entry
operator|.
name|le_value_chunk
decl_stmt|;
name|int
name|byten
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|integer_size
operator|==
literal|8
operator|&&
name|len
operator|==
literal|1
condition|)
block|{
operator|*
name|u64
operator|=
name|fzap_leaf_value
argument_list|(
name|zl
argument_list|,
name|zc
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|zl
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_ARRAY_BYTES
operator|&&
name|len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|la
operator|->
name|la_array
index|[
name|i
index|]
expr_stmt|;
name|byten
operator|++
expr_stmt|;
if|if
condition|(
name|byten
operator|==
name|array_int_len
condition|)
block|{
name|stv
argument_list|(
name|integer_size
argument_list|,
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|byten
operator|=
literal|0
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|p
operator|+=
name|integer_size
expr_stmt|;
block|}
block|}
name|chunk
operator|=
name|la
operator|->
name|la_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup a value in a fatzap directory. Assumes that the zap scratch  * buffer contains the directory header.  */
end_comment

begin_function
specifier|static
name|int
name|fzap_lookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|int
name|bsize
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|zap_phys_t
name|zh
init|=
operator|*
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
decl_stmt|;
name|fat_zap_t
name|z
decl_stmt|;
name|uint64_t
modifier|*
name|ptrtbl
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|zh
operator|.
name|zap_magic
operator|!=
name|ZAP_MAGIC
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|z
operator|.
name|zap_block_shift
operator|=
name|ilog2
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|z
operator|.
name|zap_phys
operator|=
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
comment|/* 	 * Figure out where the pointer table is and read it in if necessary. 	 */
if|if
condition|(
name|zh
operator|.
name|zap_ptrtbl
operator|.
name|zt_blk
condition|)
block|{
name|rc
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|zh
operator|.
name|zap_ptrtbl
operator|.
name|zt_blk
operator|*
name|bsize
argument_list|,
name|zap_scratch
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|ptrtbl
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
block|}
else|else
block|{
name|ptrtbl
operator|=
operator|&
name|ZAP_EMBEDDED_PTRTBL_ENT
argument_list|(
operator|&
name|z
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|hash
operator|=
name|zap_hash
argument_list|(
name|zh
operator|.
name|zap_salt
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|zap_leaf_t
name|zl
decl_stmt|;
name|zl
operator|.
name|l_bs
operator|=
name|z
operator|.
name|zap_block_shift
expr_stmt|;
name|off_t
name|off
init|=
name|ptrtbl
index|[
name|hash
operator|>>
operator|(
literal|64
operator|-
name|zh
operator|.
name|zap_ptrtbl
operator|.
name|zt_shift
operator|)
index|]
operator|<<
name|zl
operator|.
name|l_bs
decl_stmt|;
name|zap_leaf_chunk_t
modifier|*
name|zc
decl_stmt|;
name|rc
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|off
argument_list|,
name|zap_scratch
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|zl
operator|.
name|l_phys
operator|=
operator|(
name|zap_leaf_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
comment|/* 	 * Make sure this chunk matches our hash. 	 */
if|if
condition|(
name|zl
operator|.
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|>
literal|0
operator|&&
name|zl
operator|.
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator|!=
name|hash
operator|>>
operator|(
literal|64
operator|-
name|zl
operator|.
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* 	 * Hash within the chunk to find our entry. 	 */
name|int
name|shift
init|=
operator|(
literal|64
operator|-
name|ZAP_LEAF_HASH_SHIFT
argument_list|(
operator|&
name|zl
argument_list|)
operator|-
name|zl
operator|.
name|l_phys
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|)
decl_stmt|;
name|int
name|h
init|=
operator|(
name|hash
operator|>>
name|shift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|ZAP_LEAF_HASH_SHIFT
argument_list|(
operator|&
name|zl
argument_list|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|h
operator|=
name|zl
operator|.
name|l_phys
operator|->
name|l_hash
index|[
name|h
index|]
expr_stmt|;
if|if
condition|(
name|h
operator|==
literal|0xffff
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|zc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|h
argument_list|)
expr_stmt|;
while|while
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_hash
operator|!=
name|hash
condition|)
block|{
if|if
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_next
operator|==
literal|0xffff
condition|)
block|{
name|zc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|zc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
operator|->
name|l_entry
operator|.
name|le_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fzap_name_equal
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_value_intlen
operator|*
name|zc
operator|->
name|l_entry
operator|.
name|le_value_numints
operator|>
name|integer_size
operator|*
name|num_integers
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
name|fzap_leaf_array
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a name in a zap object and return its value as a uint64_t.  */
end_comment

begin_function
specifier|static
name|int
name|zap_lookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint64_t
name|zap_type
decl_stmt|;
name|size_t
name|size
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|rc
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
literal|0
argument_list|,
name|zap_scratch
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|zap_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
if|if
condition|(
name|zap_type
operator|==
name|ZBT_MICRO
condition|)
return|return
name|mzap_lookup
argument_list|(
name|dnode
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
return|;
elseif|else
if|if
condition|(
name|zap_type
operator|==
name|ZBT_HEADER
condition|)
block|{
return|return
name|fzap_lookup
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|name
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|value
argument_list|)
return|;
block|}
name|printf
argument_list|(
literal|"ZFS: invalid zap_type=%d\n"
argument_list|,
operator|(
name|int
operator|)
name|zap_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * List a microzap directory. Assumes that the zap scratch buffer contains  * the directory contents.  */
end_comment

begin_function
specifier|static
name|int
name|mzap_list
parameter_list|(
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
parameter_list|)
block|{
specifier|const
name|mzap_phys_t
modifier|*
name|mz
decl_stmt|;
specifier|const
name|mzap_ent_phys_t
modifier|*
name|mze
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|chunks
decl_stmt|,
name|i
decl_stmt|,
name|rc
decl_stmt|;
comment|/* 	 * Microzap objects use exactly one block. Read the whole 	 * thing. 	 */
name|size
operator|=
name|dnode
operator|->
name|dn_datablkszsec
operator|*
literal|512
expr_stmt|;
name|mz
operator|=
operator|(
specifier|const
name|mzap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
name|chunks
operator|=
name|size
operator|/
name|MZAP_ENT_LEN
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunks
condition|;
name|i
operator|++
control|)
block|{
name|mze
operator|=
operator|&
name|mz
operator|->
name|mz_chunk
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mze
operator|->
name|mze_name
index|[
literal|0
index|]
condition|)
block|{
name|rc
operator|=
name|callback
argument_list|(
name|mze
operator|->
name|mze_name
argument_list|,
name|mze
operator|->
name|mze_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * List a fatzap directory. Assumes that the zap scratch buffer contains  * the directory header.  */
end_comment

begin_function
specifier|static
name|int
name|fzap_list
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
parameter_list|)
block|{
name|int
name|bsize
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|zap_phys_t
name|zh
init|=
operator|*
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
decl_stmt|;
name|fat_zap_t
name|z
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rc
decl_stmt|;
if|if
condition|(
name|zh
operator|.
name|zap_magic
operator|!=
name|ZAP_MAGIC
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|z
operator|.
name|zap_block_shift
operator|=
name|ilog2
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|z
operator|.
name|zap_phys
operator|=
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
comment|/* 	 * This assumes that the leaf blocks start at block 1. The 	 * documentation isn't exactly clear on this. 	 */
name|zap_leaf_t
name|zl
decl_stmt|;
name|zl
operator|.
name|l_bs
operator|=
name|z
operator|.
name|zap_block_shift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zh
operator|.
name|zap_num_leafs
condition|;
name|i
operator|++
control|)
block|{
name|off_t
name|off
init|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|zl
operator|.
name|l_bs
decl_stmt|;
name|char
name|name
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
if|if
condition|(
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|off
argument_list|,
name|zap_scratch
argument_list|,
name|bsize
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|zl
operator|.
name|l_phys
operator|=
operator|(
name|zap_leaf_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
operator|&
name|zl
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|zap_leaf_chunk_t
modifier|*
name|zc
decl_stmt|,
modifier|*
name|nc
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|zc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_type
operator|!=
name|ZAP_CHUNK_ENTRY
condition|)
continue|continue;
name|namelen
operator|=
name|zc
operator|->
name|l_entry
operator|.
name|le_name_numints
expr_stmt|;
if|if
condition|(
name|namelen
operator|>
sizeof|sizeof
argument_list|(
name|name
argument_list|)
condition|)
name|namelen
operator|=
sizeof|sizeof
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* 			 * Paste the name back together. 			 */
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
operator|->
name|l_entry
operator|.
name|le_name_chunk
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|namelen
operator|>
literal|0
condition|)
block|{
name|int
name|len
decl_stmt|;
name|len
operator|=
name|namelen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ZAP_LEAF_ARRAY_BYTES
condition|)
name|len
operator|=
name|ZAP_LEAF_ARRAY_BYTES
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_array
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|namelen
operator|-=
name|len
expr_stmt|;
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_next
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Assume the first eight bytes of the value are 			 * a uint64_t. 			 */
name|value
operator|=
name|fzap_leaf_value
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
argument_list|)
expr_stmt|;
comment|//printf("%s 0x%jx\n", name, (uintmax_t)value);
name|rc
operator|=
name|callback
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
name|__unused
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * List a zap directory.  */
end_comment

begin_function
specifier|static
name|int
name|zap_list
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|)
block|{
name|uint64_t
name|zap_type
decl_stmt|;
name|size_t
name|size
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|*
literal|512
decl_stmt|;
if|if
condition|(
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
literal|0
argument_list|,
name|zap_scratch
argument_list|,
name|size
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|zap_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
if|if
condition|(
name|zap_type
operator|==
name|ZBT_MICRO
condition|)
return|return
name|mzap_list
argument_list|(
name|dnode
argument_list|,
name|zfs_printf
argument_list|)
return|;
else|else
return|return
name|fzap_list
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|zfs_printf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|objset_get_dnode
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|objset_phys_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|objnum
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|)
block|{
name|off_t
name|offset
decl_stmt|;
name|offset
operator|=
name|objnum
operator|*
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
expr_stmt|;
return|return
name|dnode_read
argument_list|(
name|spa
argument_list|,
operator|&
name|os
operator|->
name|os_meta_dnode
argument_list|,
name|offset
argument_list|,
name|dnode
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_phys_t
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mzap_rlookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
specifier|const
name|mzap_phys_t
modifier|*
name|mz
decl_stmt|;
specifier|const
name|mzap_ent_phys_t
modifier|*
name|mze
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|chunks
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Microzap objects use exactly one block. Read the whole 	 * thing. 	 */
name|size
operator|=
name|dnode
operator|->
name|dn_datablkszsec
operator|*
literal|512
expr_stmt|;
name|mz
operator|=
operator|(
specifier|const
name|mzap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
name|chunks
operator|=
name|size
operator|/
name|MZAP_ENT_LEN
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunks
condition|;
name|i
operator|++
control|)
block|{
name|mze
operator|=
operator|&
name|mz
operator|->
name|mz_chunk
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|mze
operator|->
name|mze_value
condition|)
block|{
name|strcpy
argument_list|(
name|name
argument_list|,
name|mze
operator|->
name|mze_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fzap_name_copy
parameter_list|(
specifier|const
name|zap_leaf_t
modifier|*
name|zl
parameter_list|,
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|zc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|namelen
decl_stmt|;
specifier|const
name|zap_leaf_chunk_t
modifier|*
name|nc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|namelen
operator|=
name|zc
operator|->
name|l_entry
operator|.
name|le_name_numints
expr_stmt|;
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|zc
operator|->
name|l_entry
operator|.
name|le_name_chunk
argument_list|)
expr_stmt|;
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|namelen
operator|>
literal|0
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|namelen
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ZAP_LEAF_ARRAY_BYTES
condition|)
name|len
operator|=
name|ZAP_LEAF_ARRAY_BYTES
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_array
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|+=
name|len
expr_stmt|;
name|namelen
operator|-=
name|len
expr_stmt|;
name|nc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|zl
argument_list|,
name|nc
operator|->
name|l_array
operator|.
name|la_next
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fzap_rlookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|bsize
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|zap_phys_t
name|zh
init|=
operator|*
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
decl_stmt|;
name|fat_zap_t
name|z
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|zh
operator|.
name|zap_magic
operator|!=
name|ZAP_MAGIC
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|z
operator|.
name|zap_block_shift
operator|=
name|ilog2
argument_list|(
name|bsize
argument_list|)
expr_stmt|;
name|z
operator|.
name|zap_phys
operator|=
operator|(
name|zap_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
comment|/* 	 * This assumes that the leaf blocks start at block 1. The 	 * documentation isn't exactly clear on this. 	 */
name|zap_leaf_t
name|zl
decl_stmt|;
name|zl
operator|.
name|l_bs
operator|=
name|z
operator|.
name|zap_block_shift
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zh
operator|.
name|zap_num_leafs
condition|;
name|i
operator|++
control|)
block|{
name|off_t
name|off
init|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|<<
name|zl
operator|.
name|l_bs
decl_stmt|;
if|if
condition|(
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|off
argument_list|,
name|zap_scratch
argument_list|,
name|bsize
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|zl
operator|.
name|l_phys
operator|=
operator|(
name|zap_leaf_phys_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
operator|&
name|zl
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|zap_leaf_chunk_t
modifier|*
name|zc
decl_stmt|;
name|zc
operator|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|zl
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_type
operator|!=
name|ZAP_CHUNK_ENTRY
condition|)
continue|continue;
if|if
condition|(
name|zc
operator|->
name|l_entry
operator|.
name|le_value_intlen
operator|!=
literal|8
operator|||
name|zc
operator|->
name|l_entry
operator|.
name|le_value_numints
operator|!=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|fzap_leaf_value
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
argument_list|)
operator|==
name|value
condition|)
block|{
name|fzap_name_copy
argument_list|(
operator|&
name|zl
argument_list|,
name|zc
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zap_rlookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint64_t
name|zap_type
decl_stmt|;
name|size_t
name|size
init|=
name|dnode
operator|->
name|dn_datablkszsec
operator|*
literal|512
decl_stmt|;
name|rc
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
literal|0
argument_list|,
name|zap_scratch
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|zap_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
if|if
condition|(
name|zap_type
operator|==
name|ZBT_MICRO
condition|)
return|return
name|mzap_rlookup
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
return|;
else|else
return|return
name|fzap_rlookup
argument_list|(
name|spa
argument_list|,
name|dnode
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_rlookup
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|objnum
parameter_list|,
name|char
modifier|*
name|result
parameter_list|)
block|{
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|component
index|[
literal|256
index|]
decl_stmt|;
name|uint64_t
name|dir_obj
decl_stmt|,
name|parent_obj
decl_stmt|,
name|child_dir_zapobj
decl_stmt|;
name|dnode_phys_t
name|child_dir_zap
decl_stmt|,
name|dataset
decl_stmt|,
name|dir
decl_stmt|,
name|parent
decl_stmt|;
name|dsl_dir_phys_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
name|p
operator|=
operator|&
name|name
index|[
sizeof|sizeof
argument_list|(
name|name
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|objnum
argument_list|,
operator|&
name|dataset
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dataset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|objnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ds
operator|=
operator|(
name|dsl_dataset_phys_t
operator|*
operator|)
operator|&
name|dataset
operator|.
name|dn_bonus
expr_stmt|;
name|dir_obj
operator|=
name|ds
operator|->
name|ds_dir_obj
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|dir_obj
argument_list|,
operator|&
name|dir
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|dd
operator|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|dir
operator|.
name|dn_bonus
expr_stmt|;
comment|/* Actual loop condition. */
name|parent_obj
operator|=
name|dd
operator|->
name|dd_parent_obj
expr_stmt|;
if|if
condition|(
name|parent_obj
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|parent_obj
argument_list|,
operator|&
name|parent
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|dd
operator|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|parent
operator|.
name|dn_bonus
expr_stmt|;
name|child_dir_zapobj
operator|=
name|dd
operator|->
name|dd_child_dir_zapobj
expr_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|child_dir_zapobj
argument_list|,
operator|&
name|child_dir_zap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|zap_rlookup
argument_list|(
name|spa
argument_list|,
operator|&
name|child_dir_zap
argument_list|,
name|component
argument_list|,
name|dir_obj
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|component
argument_list|)
expr_stmt|;
name|p
operator|-=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|component
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* Actual loop iteration. */
name|dir_obj
operator|=
name|parent_obj
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
operator|++
name|p
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_lookup_dataset
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|objnum
parameter_list|)
block|{
name|char
name|element
index|[
literal|256
index|]
decl_stmt|;
name|uint64_t
name|dir_obj
decl_stmt|,
name|child_dir_zapobj
decl_stmt|;
name|dnode_phys_t
name|child_dir_zap
decl_stmt|,
name|dir
decl_stmt|;
name|dsl_dir_phys_t
modifier|*
name|dd
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|DMU_POOL_ROOT_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dir_obj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dir_obj
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|p
operator|=
name|name
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|dir_obj
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|dd
operator|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|dir
operator|.
name|dn_bonus
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Actual loop condition #1. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|q
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
block|{
name|memcpy
argument_list|(
name|element
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|element
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|q
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|element
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|child_dir_zapobj
operator|=
name|dd
operator|->
name|dd_child_dir_zapobj
expr_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|child_dir_zapobj
argument_list|,
operator|&
name|child_dir_zap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* Actual loop condition #2. */
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|child_dir_zap
argument_list|,
name|element
argument_list|,
sizeof|sizeof
argument_list|(
name|dir_obj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dir_obj
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
operator|*
name|objnum
operator|=
name|dd
operator|->
name|dd_head_dataset_obj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BOOT2
end_ifndef

begin_function
specifier|static
name|int
name|zfs_list_dataset
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|objnum
comment|/*, int pos, char *entry*/
parameter_list|)
block|{
name|uint64_t
name|dir_obj
decl_stmt|,
name|child_dir_zapobj
decl_stmt|;
name|dnode_phys_t
name|child_dir_zap
decl_stmt|,
name|dir
decl_stmt|,
name|dataset
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dir_phys_t
modifier|*
name|dd
decl_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|objnum
argument_list|,
operator|&
name|dataset
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dataset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|objnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ds
operator|=
operator|(
name|dsl_dataset_phys_t
operator|*
operator|)
operator|&
name|dataset
operator|.
name|dn_bonus
expr_stmt|;
name|dir_obj
operator|=
name|ds
operator|->
name|ds_dir_obj
expr_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|dir_obj
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dirobj %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dir_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|dd
operator|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|dir
operator|.
name|dn_bonus
expr_stmt|;
name|child_dir_zapobj
operator|=
name|dd
operator|->
name|dd_child_dir_zapobj
expr_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|child_dir_zapobj
argument_list|,
operator|&
name|child_dir_zap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find child zap %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dir_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
name|zap_list
argument_list|(
name|spa
argument_list|,
operator|&
name|child_dir_zap
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_callback_dataset
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|objnum
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|uint64_t
parameter_list|)
parameter_list|)
block|{
name|uint64_t
name|dir_obj
decl_stmt|,
name|child_dir_zapobj
decl_stmt|,
name|zap_type
decl_stmt|;
name|dnode_phys_t
name|child_dir_zap
decl_stmt|,
name|dir
decl_stmt|,
name|dataset
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dir_phys_t
modifier|*
name|dd
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|objnum
argument_list|,
operator|&
name|dataset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dataset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|objnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ds
operator|=
operator|(
name|dsl_dataset_phys_t
operator|*
operator|)
operator|&
name|dataset
operator|.
name|dn_bonus
expr_stmt|;
name|dir_obj
operator|=
name|ds
operator|->
name|ds_dir_obj
expr_stmt|;
name|err
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|dir_obj
argument_list|,
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dirobj %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dir_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dd
operator|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|dir
operator|.
name|dn_bonus
expr_stmt|;
name|child_dir_zapobj
operator|=
name|dd
operator|->
name|dd_child_dir_zapobj
expr_stmt|;
name|err
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|child_dir_zapobj
argument_list|,
operator|&
name|child_dir_zap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find child zap %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|dir_obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
operator|&
name|child_dir_zap
argument_list|,
literal|0
argument_list|,
name|zap_scratch
argument_list|,
name|child_dir_zap
operator|.
name|dn_datablkszsec
operator|*
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|zap_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
if|if
condition|(
name|zap_type
operator|==
name|ZBT_MICRO
condition|)
return|return
name|mzap_list
argument_list|(
operator|&
name|child_dir_zap
argument_list|,
name|callback
argument_list|)
return|;
else|else
return|return
name|fzap_list
argument_list|(
name|spa
argument_list|,
operator|&
name|child_dir_zap
argument_list|,
name|callback
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Find the object set given the object number of its dataset object  * and return its details in *objset  */
end_comment

begin_function
specifier|static
name|int
name|zfs_mount_dataset
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|objnum
parameter_list|,
name|objset_phys_t
modifier|*
name|objset
parameter_list|)
block|{
name|dnode_phys_t
name|dataset
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|objnum
argument_list|,
operator|&
name|dataset
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find dataset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|objnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|ds
operator|=
operator|(
name|dsl_dataset_phys_t
operator|*
operator|)
operator|&
name|dataset
operator|.
name|dn_bonus
expr_stmt|;
if|if
condition|(
name|zio_read
argument_list|(
name|spa
argument_list|,
operator|&
name|ds
operator|->
name|ds_bp
argument_list|,
name|objset
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't read object set for dataset %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|objnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the object set pointed to by the BOOTFS property or the root  * dataset if there is none and return its details in *objset  */
end_comment

begin_function
specifier|static
name|int
name|zfs_get_root
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
modifier|*
name|objid
parameter_list|)
block|{
name|dnode_phys_t
name|dir
decl_stmt|,
name|propdir
decl_stmt|;
name|uint64_t
name|props
decl_stmt|,
name|bootfs
decl_stmt|,
name|root
decl_stmt|;
operator|*
name|objid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Start with the MOS directory object. 	 */
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't read MOS object directory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Lookup the pool_props and see if we can find a bootfs. 	 */
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
sizeof|sizeof
argument_list|(
name|props
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|props
argument_list|)
operator|==
literal|0
operator|&&
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|props
argument_list|,
operator|&
name|propdir
argument_list|)
operator|==
literal|0
operator|&&
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|propdir
argument_list|,
literal|"bootfs"
argument_list|,
sizeof|sizeof
argument_list|(
name|bootfs
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|bootfs
argument_list|)
operator|==
literal|0
operator|&&
name|bootfs
operator|!=
literal|0
condition|)
block|{
operator|*
name|objid
operator|=
name|bootfs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Lookup the root dataset directory 	 */
if|if
condition|(
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|DMU_POOL_ROOT_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|root
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|root
argument_list|)
operator|||
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|root
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find root dsl_dir\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Use the information from the dataset directory's bonus buffer 	 * to find the dataset object and from that the object set itself. 	 */
name|dsl_dir_phys_t
modifier|*
name|dd
init|=
operator|(
name|dsl_dir_phys_t
operator|*
operator|)
operator|&
name|dir
operator|.
name|dn_bonus
decl_stmt|;
operator|*
name|objid
operator|=
name|dd
operator|->
name|dd_head_dataset_obj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_mount
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|rootobj
parameter_list|,
name|struct
name|zfsmount
modifier|*
name|mount
parameter_list|)
block|{
name|mount
operator|->
name|spa
operator|=
name|spa
expr_stmt|;
comment|/* 	 * Find the root object set if not explicitly provided 	 */
if|if
condition|(
name|rootobj
operator|==
literal|0
operator|&&
name|zfs_get_root
argument_list|(
name|spa
argument_list|,
operator|&
name|rootobj
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't find root filesystem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|zfs_mount_dataset
argument_list|(
name|spa
argument_list|,
name|rootobj
argument_list|,
operator|&
name|mount
operator|->
name|objset
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't open root filesystem\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|mount
operator|->
name|rootobj
operator|=
name|rootobj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * callback function for feature name checks.  */
end_comment

begin_function
specifier|static
name|int
name|check_feature
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|features_for_read
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|features_for_read
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"ZFS: unsupported feature: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks whether the MOS features that are active are supported.  */
end_comment

begin_function
specifier|static
name|int
name|check_mos_features
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|dnode_phys_t
name|dir
decl_stmt|;
name|uint64_t
name|objnum
decl_stmt|,
name|zap_type
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|DMU_OT_OBJECT_DIRECTORY
argument_list|,
operator|&
name|dir
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
operator|(
name|rc
operator|=
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|DMU_POOL_FEATURES_FOR_READ
argument_list|,
sizeof|sizeof
argument_list|(
name|objnum
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|objnum
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * It is older pool without features. As we have already 		 * tested the label, just return without raising the error. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|objnum
argument_list|,
operator|&
name|dir
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
if|if
condition|(
name|dir
operator|.
name|dn_type
operator|!=
name|DMU_OTN_ZAP_METADATA
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|size
operator|=
name|dir
operator|.
name|dn_datablkszsec
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|dnode_read
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
literal|0
argument_list|,
name|zap_scratch
argument_list|,
name|size
argument_list|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|zap_type
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|zap_scratch
expr_stmt|;
if|if
condition|(
name|zap_type
operator|==
name|ZBT_MICRO
condition|)
name|rc
operator|=
name|mzap_list
argument_list|(
operator|&
name|dir
argument_list|,
name|check_feature
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|fzap_list
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|check_feature
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_spa_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|dnode_phys_t
name|dir
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|zio_read
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: can't read MOS of pool %s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_mos
operator|.
name|os_type
operator|!=
name|DMU_OST_META
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: corrupted MOS of pool %s\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
operator|&
name|dir
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: failed to read pool %s directory object\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* this is allowed to fail, older pools do not have salt */
name|rc
operator|=
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dir
argument_list|,
name|DMU_POOL_CHECKSUM_SALT
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
expr_stmt|;
name|rc
operator|=
name|check_mos_features
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: pool %s is not supported\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_dnode_stat
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dnode_phys_t
modifier|*
name|dn
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
if|if
condition|(
name|dn
operator|->
name|dn_bonustype
operator|!=
name|DMU_OT_SA
condition|)
block|{
name|znode_phys_t
modifier|*
name|zp
init|=
operator|(
name|znode_phys_t
operator|*
operator|)
name|dn
operator|->
name|dn_bonus
decl_stmt|;
name|sb
operator|->
name|st_mode
operator|=
name|zp
operator|->
name|zp_mode
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
name|zp
operator|->
name|zp_uid
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
name|zp
operator|->
name|zp_gid
expr_stmt|;
name|sb
operator|->
name|st_size
operator|=
name|zp
operator|->
name|zp_size
expr_stmt|;
block|}
else|else
block|{
name|sa_hdr_phys_t
modifier|*
name|sahdrp
decl_stmt|;
name|int
name|hdrsize
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
name|sahdrp
operator|=
operator|(
name|sa_hdr_phys_t
operator|*
operator|)
name|DN_BONUS
argument_list|(
name|dn
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|dn
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
operator|)
operator|!=
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|dn
operator|->
name|dn_spill
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|buf
operator|=
name|zfs_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio_read
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|zfs_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sahdrp
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
name|hdrsize
operator|=
name|SA_HDR_SIZE
argument_list|(
name|sahdrp
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_mode
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sahdrp
operator|+
name|hdrsize
operator|+
name|SA_MODE_OFFSET
operator|)
expr_stmt|;
name|sb
operator|->
name|st_uid
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sahdrp
operator|+
name|hdrsize
operator|+
name|SA_UID_OFFSET
operator|)
expr_stmt|;
name|sb
operator|->
name|st_gid
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sahdrp
operator|+
name|hdrsize
operator|+
name|SA_GID_OFFSET
operator|)
expr_stmt|;
name|sb
operator|->
name|st_size
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|sahdrp
operator|+
name|hdrsize
operator|+
name|SA_SIZE_OFFSET
operator|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|zfs_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_dnode_readlink
parameter_list|(
specifier|const
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dnode_phys_t
modifier|*
name|dn
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|psize
parameter_list|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonustype
operator|==
name|DMU_OT_SA
condition|)
block|{
name|sa_hdr_phys_t
modifier|*
name|sahdrp
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|hdrsize
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
name|sahdrp
operator|=
operator|(
name|sa_hdr_phys_t
operator|*
operator|)
name|DN_BONUS
argument_list|(
name|dn
argument_list|)
expr_stmt|;
else|else
block|{
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|dn
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_SPILL_BLKPTR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|bp
operator|=
operator|&
name|dn
operator|->
name|dn_spill
expr_stmt|;
name|size
operator|=
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|buf
operator|=
name|zfs_alloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|rc
operator|=
name|zio_read
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|zfs_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|sahdrp
operator|=
name|buf
expr_stmt|;
block|}
name|hdrsize
operator|=
name|SA_HDR_SIZE
argument_list|(
name|sahdrp
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sahdrp
operator|+
name|hdrsize
operator|+
name|SA_SYMLINK_OFFSET
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
argument_list|,
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|zfs_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Second test is purely to silence bogus compiler 	 * warning about accessing past the end of dn_bonus. 	 */
if|if
condition|(
name|psize
operator|+
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
operator|<=
name|dn
operator|->
name|dn_bonuslen
operator|&&
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|dn
operator|->
name|dn_bonus
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|path
argument_list|,
operator|&
name|dn
operator|->
name|dn_bonus
index|[
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
index|]
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
name|dnode_read
argument_list|(
name|spa
argument_list|,
name|dn
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|obj_list
block|{
name|uint64_t
name|objnum
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|obj_list
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Lookup a file and return its dnode.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_lookup
parameter_list|(
specifier|const
name|struct
name|zfsmount
modifier|*
name|mount
parameter_list|,
specifier|const
name|char
modifier|*
name|upath
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnode
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint64_t
name|objnum
decl_stmt|;
specifier|const
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|dnode_phys_t
name|dn
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|char
name|element
index|[
literal|256
index|]
decl_stmt|;
name|char
name|path
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|symlinks_followed
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|obj_list
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tentry
decl_stmt|;
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|obj_list
argument_list|)
name|on_cache
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|on_cache
argument_list|)
expr_stmt|;
name|spa
operator|=
name|mount
operator|->
name|spa
expr_stmt|;
if|if
condition|(
name|mount
operator|->
name|objset
operator|.
name|os_type
operator|!=
name|DMU_OST_ZFS
condition|)
block|{
name|printf
argument_list|(
literal|"ZFS: unexpected object set type %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mount
operator|->
name|objset
operator|.
name|os_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Get the root directory dnode. 	 */
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|mount
operator|->
name|objset
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|rc
operator|=
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dn
argument_list|,
name|ZFS_ROOT_OBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|objnum
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|objnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
block|{
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|entry
operator|->
name|objnum
operator|=
name|objnum
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|on_cache
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|mount
operator|->
name|objset
argument_list|,
name|objnum
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|p
operator|=
name|upath
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
condition|)
block|{
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|mount
operator|->
name|objset
argument_list|,
name|objnum
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
while|while
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
break|break;
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|*
name|q
operator|!=
literal|'/'
condition|)
name|q
operator|++
expr_stmt|;
comment|/* skip dot */
if|if
condition|(
name|p
operator|+
literal|1
operator|==
name|q
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* double dot */
if|if
condition|(
name|p
operator|+
literal|2
operator|==
name|q
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
operator|==
name|STAILQ_LAST
argument_list|(
operator|&
name|on_cache
argument_list|,
name|obj_list
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|on_cache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|objnum
operator|=
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
operator|)
operator|->
name|objnum
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|q
operator|-
name|p
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|element
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|memcpy
argument_list|(
name|element
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
expr_stmt|;
name|element
index|[
name|q
operator|-
name|p
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|zfs_dnode_stat
argument_list|(
name|spa
argument_list|,
operator|&
name|dn
argument_list|,
operator|&
name|sb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|rc
operator|=
name|zap_lookup
argument_list|(
name|spa
argument_list|,
operator|&
name|dn
argument_list|,
name|element
argument_list|,
sizeof|sizeof
argument_list|(
name|objnum
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|objnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
name|objnum
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
name|objnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|obj_list
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|rc
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|entry
operator|->
name|objnum
operator|=
name|objnum
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|on_cache
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|rc
operator|=
name|objset_get_dnode
argument_list|(
name|spa
argument_list|,
operator|&
name|mount
operator|->
name|objset
argument_list|,
name|objnum
argument_list|,
operator|&
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * Check for symlink. 		 */
name|rc
operator|=
name|zfs_dnode_stat
argument_list|(
name|spa
argument_list|,
operator|&
name|dn
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|symlinks_followed
operator|>
literal|10
condition|)
block|{
name|rc
operator|=
name|EMLINK
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|symlinks_followed
operator|++
expr_stmt|;
comment|/* 			 * Read the link value and copy the tail of our 			 * current path onto the end. 			 */
if|if
condition|(
name|sb
operator|.
name|st_size
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
operator|>
sizeof|sizeof
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|rc
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|strcpy
argument_list|(
operator|&
name|path
index|[
name|sb
operator|.
name|st_size
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|rc
operator|=
name|zfs_dnode_readlink
argument_list|(
name|spa
argument_list|,
operator|&
name|dn
argument_list|,
name|path
argument_list|,
name|sb
operator|.
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 			 * Restart with the new path, starting either at 			 * the root or at the parent depending whether or 			 * not the link is relative. 			 */
name|p
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
while|while
condition|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
operator|!=
name|STAILQ_LAST
argument_list|(
operator|&
name|on_cache
argument_list|,
name|obj_list
argument_list|,
name|entry
argument_list|)
condition|)
block|{
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|on_cache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|entry
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|on_cache
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|objnum
operator|=
operator|(
name|STAILQ_FIRST
argument_list|(
operator|&
name|on_cache
argument_list|)
operator|)
operator|->
name|objnum
expr_stmt|;
block|}
block|}
operator|*
name|dnode
operator|=
name|dn
expr_stmt|;
name|done
label|:
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|entry
argument_list|,
argument|&on_cache
argument_list|,
argument|entry
argument_list|,
argument|tentry
argument_list|)
name|free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

end_unit

