begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Filename: loader_prompt.c  *  * Instantiation of the interactive loader functions.  *  * Revision information:  *  * 20AUG2004	kb_admin	initial creation  * 12JAN2005	kb_admin	massive changes for tftp, strings, and more  * 05JUL2005	kb_admin	save tag address, and set registers on boot  *  * BEGIN_KBDD_BLOCK  * No warranty, expressed or implied, is included with this software.  It is  * provided "AS IS" and no warranty of any kind including statutory or aspects  * relating to merchantability or fitness for any purpose is provided.  All  * intellectual property rights of others is maintained with the respective  * owners.  This software is not copyrighted and is intended for reference  * only.  * END_BLOCK  *  * $FreeBSD$  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"at91rm9200_lowlevel.h"
end_include

begin_include
include|#
directive|include
file|"p_string.h"
end_include

begin_include
include|#
directive|include
file|"eeprom.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SUPPORT_TAG_LIST
end_ifdef

begin_include
include|#
directive|include
file|"tag_list.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"emac.h"
end_include

begin_include
include|#
directive|include
file|"loader_prompt.h"
end_include

begin_include
include|#
directive|include
file|"env_vars.h"
end_include

begin_include
include|#
directive|include
file|"lib.h"
end_include

begin_comment
comment|/******************************* GLOBALS *************************************/
end_comment

begin_comment
comment|/*********************** PRIVATE FUNCTIONS/DATA ******************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|inputBuffer
index|[
name|MAX_INPUT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buffCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|// argv pointer are either NULL or point to locations in inputBuffer
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|argv
index|[
name|MAX_COMMAND_PARAMS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|backspaceString
index|[]
init|=
block|{
literal|0x8
block|,
literal|' '
block|,
literal|0x8
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|command_entry_t
name|CommandTable
index|[]
init|=
block|{
block|{
name|COMMAND_COPY
block|,
literal|"c"
block|}
block|,
block|{
name|COMMAND_DUMP
block|,
literal|"d"
block|}
block|,
block|{
name|COMMAND_EXEC
block|,
literal|"e"
block|}
block|,
block|{
name|COMMAND_HELP
block|,
literal|"?"
block|}
block|,
block|{
name|COMMAND_LOCAL_IP
block|,
literal|"ip"
block|}
block|,
block|{
name|COMMAND_MAC
block|,
literal|"m"
block|}
block|,
block|{
name|COMMAND_SERVER_IP
block|,
literal|"server_ip"
block|}
block|,
block|{
name|COMMAND_SET
block|,
literal|"s"
block|}
block|,
ifdef|#
directive|ifdef
name|SUPPORT_TAG_LIST
block|{
name|COMMAND_TAG
block|,
literal|"t"
block|}
block|,
endif|#
directive|endif
block|{
name|COMMAND_TFTP
block|,
literal|"tftp"
block|}
block|,
block|{
name|COMMAND_WRITE
block|,
literal|"w"
block|}
block|,
block|{
name|COMMAND_XMODEM
block|,
literal|"x"
block|}
block|,
block|{
name|COMMAND_FINAL_FLAG
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|tagAddress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * unsigned BuildIP(void)  *  This private function packs the test IP info to an unsigned value.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|unsigned
name|BuildIP
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * int StringToCommand(char *cPtr)  *  This private function converts a command string to a command code.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|int
name|StringToCommand
parameter_list|(
name|char
modifier|*
name|cPtr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|command
operator|!=
name|COMMAND_FINAL_FLAG
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|p_strcmp
argument_list|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|c_string
argument_list|,
name|cPtr
argument_list|)
condition|)
return|return
operator|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|command
operator|)
return|;
return|return
operator|(
name|COMMAND_INVALID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void RestoreSpace(int)  *  This private function restores NULL characters to spaces in order to  * process the remaining args as a string.  The number passed is the argc  * of the first entry to begin restoring space in the inputBuffer.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|void
name|RestoreSpace
parameter_list|(
name|int
name|startArgc
parameter_list|)
block|{
name|char
modifier|*
name|cPtr
decl_stmt|;
for|for
control|(
name|startArgc
operator|++
init|;
name|startArgc
operator|<
name|MAX_COMMAND_PARAMS
condition|;
name|startArgc
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cPtr
operator|=
name|argv
index|[
name|startArgc
index|]
operator|)
condition|)
operator|*
operator|(
name|cPtr
operator|-
literal|1
operator|)
operator|=
literal|' '
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * int BreakCommand(char *)  *  This private function splits the buffer into separate strings as pointed  * by argv and returns the number of parameters (< 0 on failure).  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|int
name|BreakCommand
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|pCount
decl_stmt|,
name|cCount
decl_stmt|,
name|state
decl_stmt|;
name|state
operator|=
name|pCount
operator|=
literal|0
expr_stmt|;
name|p_memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cCount
operator|=
literal|0
init|;
name|cCount
operator|<
name|MAX_INPUT_SIZE
condition|;
operator|++
name|cCount
control|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
block|{
comment|/* look for next command */
if|if
condition|(
operator|!
name|p_IsWhiteSpace
argument_list|(
name|buffer
index|[
name|cCount
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
name|pCount
operator|++
index|]
operator|=
operator|&
name|buffer
index|[
name|cCount
index|]
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|cCount
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in command, find next white space */
if|if
condition|(
name|p_IsWhiteSpace
argument_list|(
name|buffer
index|[
name|cCount
index|]
argument_list|)
condition|)
block|{
name|buffer
index|[
name|cCount
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pCount
operator|>=
name|MAX_COMMAND_PARAMS
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pCount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void ParseCommand(char *)  *  This private function executes matching functions.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|void
name|ParseCommand
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|argc
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|=
name|BreakCommand
argument_list|(
name|buffer
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
return|return ;
block|}
switch|switch
condition|(
name|StringToCommand
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|COMMAND_COPY
case|:
block|{
comment|// "c<to><from><size in bytes>"
comment|// copy memory
name|char
modifier|*
name|to
decl_stmt|,
modifier|*
name|from
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|3
condition|)
block|{
name|to
operator|=
operator|(
name|char
operator|*
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|from
operator|=
operator|(
name|char
operator|*
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|p_memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COMMAND_DUMP
case|:
comment|// display boot commands
name|DumpBootCommands
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMMAND_EXEC
case|:
block|{
comment|// "e<address>"
comment|// execute at address
name|void
function_decl|(
modifier|*
name|execAddr
function_decl|)
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* in future, include machtypes (MACH_KB9200 = 612) */
name|execAddr
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|unsigned
argument_list|,
name|unsigned
argument_list|,
name|unsigned
argument_list|)
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|execAddr
call|)
argument_list|(
literal|0
argument_list|,
literal|612
argument_list|,
name|tagAddress
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COMMAND_TFTP
case|:
block|{
comment|// "tftp<local_dest_addr filename>"
comment|//  tftp download
name|unsigned
name|address
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|address
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TFTP_Download
argument_list|(
name|address
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMMAND_SERVER_IP
case|:
comment|// "server_ip<server IP 192 200 1 20>"
comment|// set download server address
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|SetServerIPAddress
argument_list|(
name|BuildIP
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_HELP
case|:
comment|// dump command info
name|printf
argument_list|(
literal|"Commands:\r\n"
literal|"\tc\r\n"
literal|"\td\r\n"
literal|"\te\r\n"
literal|"\tip\r\n"
literal|"\tserver_ip\r\n"
literal|"\tm\r\n"
literal|"\ttftp\r\n"
literal|"\ts\r\n"
ifdef|#
directive|ifdef
name|SUPPORT_TAG_LIST
literal|"\tt\r\n"
endif|#
directive|endif
literal|"\tw\r\n"
literal|"\tx\r\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_LOCAL_IP
case|:
comment|// "local_ip<local IP 192 200 1 21>
comment|// set ip of this module
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|SetLocalIPAddress
argument_list|(
name|BuildIP
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_MAC
case|:
block|{
comment|// "m<mac address 12 34 56 78 9a bc>
comment|// set mac address using 6 byte values
name|unsigned
name|low_addr
decl_stmt|,
name|high_addr
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|6
condition|)
block|{
name|low_addr
operator|=
operator|(
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|high_addr
operator|=
operator|(
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|6
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|SetMACAddress
argument_list|(
name|low_addr
argument_list|,
name|high_addr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|COMMAND_SET
case|:
block|{
comment|// s<index><new boot command>
comment|// set the boot command at index (0-based)
name|unsigned
name|index
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|RestoreSpace
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|index
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|SetBootCommand
argument_list|(
name|index
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|SUPPORT_TAG_LIST
case|case
name|COMMAND_TAG
case|:
block|{
comment|// t<address><boot command line>
comment|// create tag-list for linux boot
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|RestoreSpace
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|tagAddress
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|InitTagList
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tagAddress
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
endif|#
directive|endif
case|case
name|COMMAND_WRITE
case|:
comment|// write the command table to non-volatile
name|WriteCommandTable
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMMAND_XMODEM
case|:
block|{
comment|// "x<address>"
comment|// download X-modem record at address
name|char
modifier|*
name|destAddr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|destAddr
operator|=
operator|(
name|char
operator|*
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|xmodem_rx
argument_list|(
name|destAddr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void ServicePrompt(char)  *  This private function process each character checking for valid commands.  * This function is only executed if the character is considered valid.  * Each command is terminated with NULL (0) or '\r'.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|void
name|ServicePrompt
parameter_list|(
name|char
name|p_char
parameter_list|)
block|{
if|if
condition|(
name|p_char
operator|==
literal|'\r'
condition|)
block|{
name|p_char
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p_char
operator|!=
literal|0x8
condition|)
block|{
if|if
condition|(
name|buffCount
operator|<
name|MAX_INPUT_SIZE
operator|-
literal|1
condition|)
block|{
name|inputBuffer
index|[
name|buffCount
index|]
operator|=
name|p_char
expr_stmt|;
operator|++
name|buffCount
expr_stmt|;
name|putchar
argument_list|(
name|p_char
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|buffCount
condition|)
block|{
comment|/* handle backspace BS */
operator|--
name|buffCount
expr_stmt|;
name|inputBuffer
index|[
name|buffCount
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|backspaceString
argument_list|)
expr_stmt|;
return|return ;
block|}
if|if
condition|(
operator|!
name|p_char
condition|)
block|{
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|ParseCommand
argument_list|(
name|inputBuffer
argument_list|)
expr_stmt|;
name|p_memset
argument_list|(
name|inputBuffer
argument_list|,
literal|0
argument_list|,
name|MAX_INPUT_SIZE
argument_list|)
expr_stmt|;
name|buffCount
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************** GLOBAL FUNCTIONS ********************************/
end_comment

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void Bootloader(void *inputFunction)  *  This global function is the entry point for the bootloader.  If the  * inputFunction pointer is NULL, the loader input will be serviced from  * the uart.  Otherwise, inputFunction is called to get characters which  * the loader will parse.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
name|void
name|Bootloader
parameter_list|(
name|int
function_decl|(
modifier|*
name|inputFunction
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|ch
init|=
literal|0
decl_stmt|;
name|p_memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|inputBuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inputBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffCount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|inputFunction
condition|)
block|{
name|inputFunction
operator|=
name|getc
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\r\n>"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|>=
literal|0
condition|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|(
call|(
modifier|*
name|inputFunction
call|)
argument_list|(
literal|0
argument_list|)
operator|)
operator|)
operator|>
literal|0
condition|)
name|ServicePrompt
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

