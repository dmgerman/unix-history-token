begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************************  *  * Filename: loader_prompt.c  *  * Instantiation of the interactive loader functions.  *  * Revision information:  *  * 20AUG2004	kb_admin	initial creation  * 12JAN2005	kb_admin	massive changes for tftp, strings, and more  * 05JUL2005	kb_admin	save tag address, and set registers on boot  *  * BEGIN_KBDD_BLOCK  * No warranty, expressed or implied, is included with this software.  It is  * provided "AS IS" and no warranty of any kind including statutory or aspects  * relating to merchantability or fitness for any purpose is provided.  All  * intellectual property rights of others is maintained with the respective  * owners.  This software is not copyrighted and is intended for reference  * only.  * END_BLOCK  *  * $FreeBSD$  *****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"at91rm9200_lowlevel.h"
end_include

begin_include
include|#
directive|include
file|"at91rm9200.h"
end_include

begin_include
include|#
directive|include
file|"emac.h"
end_include

begin_include
include|#
directive|include
file|"loader_prompt.h"
end_include

begin_include
include|#
directive|include
file|"env_vars.h"
end_include

begin_include
include|#
directive|include
file|"lib.h"
end_include

begin_include
include|#
directive|include
file|"spi_flash.h"
end_include

begin_comment
comment|/******************************* GLOBALS *************************************/
end_comment

begin_comment
comment|/*********************** PRIVATE FUNCTIONS/DATA ******************************/
end_comment

begin_decl_stmt
specifier|static
name|char
name|inputBuffer
index|[
name|MAX_INPUT_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|buffCount
decl_stmt|;
end_decl_stmt

begin_comment
comment|// argv pointer are either NULL or point to locations in inputBuffer
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|argv
index|[
name|MAX_COMMAND_PARAMS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FLASH_OFFSET
value|(0 * FLASH_PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|FPGA_OFFSET
value|(15 * FLASH_PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|FPGA_LEN
value|(212608)
end_define

begin_define
define|#
directive|define
name|KERNEL_OFFSET
value|(220 * FLASH_PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|KERNEL_LEN
value|(6 * 1024 * FLASH_PAGE_SIZE)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|backspaceString
init|=
literal|"\010 \010"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|command_entry_t
name|CommandTable
index|[]
init|=
block|{
block|{
name|COMMAND_DUMP
block|,
literal|"d"
block|}
block|,
block|{
name|COMMAND_EXEC
block|,
literal|"e"
block|}
block|,
block|{
name|COMMAND_LOCAL_IP
block|,
literal|"ip"
block|}
block|,
block|{
name|COMMAND_MAC
block|,
literal|"m"
block|}
block|,
block|{
name|COMMAND_SERVER_IP
block|,
literal|"server_ip"
block|}
block|,
block|{
name|COMMAND_TFTP
block|,
literal|"tftp"
block|}
block|,
block|{
name|COMMAND_XMODEM
block|,
literal|"x"
block|}
block|,
block|{
name|COMMAND_RESET
block|,
literal|"R"
block|}
block|,
block|{
name|COMMAND_LOAD_SPI_KERNEL
block|,
literal|"k"
block|}
block|,
block|{
name|COMMAND_REPLACE_KERNEL_VIA_XMODEM
block|,
literal|"K"
block|}
block|,
block|{
name|COMMAND_REPLACE_FLASH_VIA_XMODEM
block|,
literal|"I"
block|}
block|,
block|{
name|COMMAND_REPLACE_FPGA_VIA_XMODEM
block|,
literal|"F"
block|}
block|,
block|{
name|COMMAND_REPLACE_ID_EEPROM
block|,
literal|"E"
block|}
block|,
block|{
name|COMMAND_FINAL_FLAG
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * unsigned BuildIP(void)  *  This private function packs the test IP info to an unsigned value.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|unsigned
name|BuildIP
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|24
operator|)
operator||
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|16
operator|)
operator||
operator|(
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|3
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|p_ASCIIToDec
argument_list|(
name|argv
index|[
literal|4
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * int StringToCommand(char *cPtr)  *  This private function converts a command string to a command code.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|int
name|StringToCommand
parameter_list|(
name|char
modifier|*
name|cPtr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|CommandTable
index|[
name|i
index|]
operator|.
name|command
operator|!=
name|COMMAND_FINAL_FLAG
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|p_strcmp
argument_list|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|c_string
argument_list|,
name|cPtr
argument_list|)
condition|)
return|return
operator|(
name|CommandTable
index|[
name|i
index|]
operator|.
name|command
operator|)
return|;
return|return
operator|(
name|COMMAND_INVALID
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * int BreakCommand(char *)  *  This private function splits the buffer into separate strings as pointed  * by argv and returns the number of parameters (< 0 on failure).  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|int
name|BreakCommand
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|pCount
decl_stmt|,
name|cCount
decl_stmt|,
name|state
decl_stmt|;
name|state
operator|=
name|pCount
operator|=
literal|0
expr_stmt|;
name|p_memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|argv
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|cCount
operator|=
literal|0
init|;
name|cCount
operator|<
name|MAX_INPUT_SIZE
condition|;
operator|++
name|cCount
control|)
block|{
if|if
condition|(
operator|!
name|state
condition|)
block|{
comment|/* look for next command */
if|if
condition|(
operator|!
name|p_IsWhiteSpace
argument_list|(
name|buffer
index|[
name|cCount
index|]
argument_list|)
condition|)
block|{
name|argv
index|[
name|pCount
operator|++
index|]
operator|=
operator|&
name|buffer
index|[
name|cCount
index|]
expr_stmt|;
name|state
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|buffer
index|[
name|cCount
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* in command, find next white space */
if|if
condition|(
name|p_IsWhiteSpace
argument_list|(
name|buffer
index|[
name|cCount
index|]
argument_list|)
condition|)
block|{
name|buffer
index|[
name|cCount
index|]
operator|=
literal|0
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pCount
operator|>=
name|MAX_COMMAND_PARAMS
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|pCount
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void UpdateEEProm(int eeaddr) { 	char *addr = (char *)SDRAM_BASE + (1<< 20);
comment|/* Load to base + 1MB */
end_comment

begin_endif
unit|int len;  	while ((len = xmodem_rx(addr)) == -1) 		continue; 	printf("\r\nDownloaded %u bytes.\r\n", len); 	WriteEEPROM(eeaddr, 0, addr, len); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|UpdateFlash
parameter_list|(
name|int
name|offset
parameter_list|)
block|{
name|char
modifier|*
name|addr
init|=
operator|(
name|char
operator|*
operator|)
name|SDRAM_BASE
operator|+
operator|(
literal|1
operator|<<
literal|20
operator|)
decl_stmt|;
comment|/* Load to base + 1MB */
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|off
decl_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|xmodem_rx
argument_list|(
name|addr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|printf
argument_list|(
literal|"\r\nDownloaded %u bytes.\r\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|FLASH_PAGE_SIZE
control|)
block|{
name|off
operator|=
name|i
operator|+
name|offset
expr_stmt|;
name|SPI_WriteFlash
argument_list|(
name|off
argument_list|,
name|addr
operator|+
name|i
argument_list|,
name|FLASH_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|LoadKernelFromSpi
parameter_list|(
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|off
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KERNEL_LEN
condition|;
name|i
operator|+=
name|FLASH_PAGE_SIZE
control|)
block|{
name|off
operator|=
name|i
operator|+
name|KERNEL_OFFSET
expr_stmt|;
name|SPI_ReadFlash
argument_list|(
name|off
argument_list|,
name|addr
operator|+
name|i
argument_list|,
name|FLASH_PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void ParseCommand(char *)  *  This private function executes matching functions.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|void
name|ParseCommand
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|argc
operator|=
name|BreakCommand
argument_list|(
name|buffer
argument_list|)
operator|)
operator|<
literal|1
condition|)
return|return;
switch|switch
condition|(
name|StringToCommand
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
case|case
name|COMMAND_DUMP
case|:
comment|// display boot commands
name|DumpBootCommands
argument_list|()
expr_stmt|;
break|break;
case|case
name|COMMAND_EXEC
case|:
block|{
comment|// "e<address>"
comment|// execute at address
name|void
function_decl|(
modifier|*
name|execAddr
function_decl|)
parameter_list|(
name|unsigned
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
comment|/* in future, include machtypes (MACH_KB9200 = 612) */
name|execAddr
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|unsigned
argument_list|,
name|unsigned
argument_list|)
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
call|(
modifier|*
name|execAddr
call|)
argument_list|(
literal|0
argument_list|,
literal|612
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|COMMAND_TFTP
case|:
block|{
comment|// "tftp<local_dest_addr filename>"
comment|//  tftp download
name|unsigned
name|address
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
name|address
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|TFTP_Download
argument_list|(
name|address
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|COMMAND_SERVER_IP
case|:
comment|// "server_ip<server IP 192 200 1 20>"
comment|// set download server address
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|SetServerIPAddress
argument_list|(
name|BuildIP
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_LOCAL_IP
case|:
comment|// "local_ip<local IP 192 200 1 21>
comment|// set ip of this module
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
name|SetLocalIPAddress
argument_list|(
name|BuildIP
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_MAC
case|:
block|{
comment|// "m<mac address 12 34 56 78 9a bc>
comment|// set mac address using 6 byte values
name|unsigned
name|char
name|mac
index|[
literal|6
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|6
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|mac
index|[
name|i
index|]
operator|=
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|EMAC_SetMACAddress
argument_list|(
name|mac
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|COMMAND_LOAD_SPI_KERNEL
case|:
comment|// "k<address>"
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|LoadKernelFromSpi
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_XMODEM
case|:
comment|// "x<address>"
comment|// download X-modem record at address
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|xmodem_rx
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p_ASCIIToHex
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_RESET
case|:
name|printf
argument_list|(
literal|"Reset\r\n"
argument_list|)
expr_stmt|;
name|reset
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
continue|continue;
break|break;
case|case
name|COMMAND_REPLACE_KERNEL_VIA_XMODEM
case|:
name|printf
argument_list|(
literal|"Updating KERNEL image\r\n"
argument_list|)
expr_stmt|;
name|UpdateFlash
argument_list|(
name|KERNEL_OFFSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_REPLACE_FPGA_VIA_XMODEM
case|:
name|printf
argument_list|(
literal|"Updating FPGA image\r\n"
argument_list|)
expr_stmt|;
name|UpdateFlash
argument_list|(
name|FPGA_OFFSET
argument_list|)
expr_stmt|;
break|break;
case|case
name|COMMAND_REPLACE_FLASH_VIA_XMODEM
case|:
name|printf
argument_list|(
literal|"Updating FLASH image\r\n"
argument_list|)
expr_stmt|;
name|UpdateFlash
argument_list|(
name|FLASH_OFFSET
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void ServicePrompt(char)  *  This private function process each character checking for valid commands.  * This function is only executed if the character is considered valid.  * Each command is terminated with NULL (0) or '\r'.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
specifier|static
name|void
name|ServicePrompt
parameter_list|(
name|char
name|p_char
parameter_list|)
block|{
if|if
condition|(
name|p_char
operator|==
literal|'\r'
condition|)
name|p_char
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p_char
operator|==
literal|'\010'
condition|)
block|{
if|if
condition|(
name|buffCount
condition|)
block|{
comment|/* handle backspace BS */
name|inputBuffer
index|[
operator|--
name|buffCount
index|]
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
name|backspaceString
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|buffCount
operator|<
name|MAX_INPUT_SIZE
operator|-
literal|1
condition|)
block|{
name|inputBuffer
index|[
name|buffCount
operator|++
index|]
operator|=
name|p_char
expr_stmt|;
name|putchar
argument_list|(
name|p_char
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|p_char
condition|)
block|{
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|ParseCommand
argument_list|(
name|inputBuffer
argument_list|)
expr_stmt|;
name|p_memset
argument_list|(
name|inputBuffer
argument_list|,
literal|0
argument_list|,
name|MAX_INPUT_SIZE
argument_list|)
expr_stmt|;
name|buffCount
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ************************** GLOBAL FUNCTIONS ********************************/
end_comment

begin_comment
comment|/*  * .KB_C_FN_DEFINITION_START  * void Bootloader(void *inputFunction)  *  This global function is the entry point for the bootloader.  If the  * inputFunction pointer is NULL, the loader input will be serviced from  * the uart.  Otherwise, inputFunction is called to get characters which  * the loader will parse.  * .KB_C_FN_DEFINITION_END  */
end_comment

begin_function
name|void
name|Bootloader
parameter_list|(
name|int
function_decl|(
modifier|*
name|inputFunction
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|)
block|{
name|int
name|ch
init|=
literal|0
decl_stmt|;
name|p_memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|inputBuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inputBuffer
argument_list|)
argument_list|)
expr_stmt|;
name|buffCount
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n>"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
if|if
condition|(
operator|(
name|ch
operator|=
operator|(
call|(
modifier|*
name|inputFunction
call|)
argument_list|(
literal|0
argument_list|)
operator|)
operator|)
operator|>
literal|0
condition|)
name|ServicePrompt
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

