begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** t o o l s . c ** Forth Inspired Command Language - programming tools ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 20 June 2000 ** $Id: tools.c,v 1.11 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* ** NOTES: ** SEE needs information about the addresses of functions that ** are the CFAs of colon definitions, constants, variables, DOES> ** words, and so on. It gets this information from a table and supporting ** functions in words.c. ** colonParen doDoes createParen variableParen userParen constantParen ** ** Step and break debugger for Ficl ** debug  ( xt -- )   Start debugging an xt ** Set a breakpoint ** Specify breakpoint default action */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* sprintf */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* ** nBREAKPOINTS sizes the breakpoint array. One breakpoint (bp 0) is reserved ** for the STEP command. The rest are user programmable.  */
end_comment

begin_define
define|#
directive|define
name|nBREAKPOINTS
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         v m S e t B r e a k ** Set a breakpoint at the current value of IP by ** storing that address in a BREAKPOINT record **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|vmSetBreak
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_BREAKPOINT
modifier|*
name|pBP
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pStep
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"step-break"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pStep
argument_list|)
expr_stmt|;
name|pBP
operator|->
name|address
operator|=
name|pVM
operator|->
name|ip
expr_stmt|;
name|pBP
operator|->
name|origXT
operator|=
operator|*
name|pVM
operator|->
name|ip
expr_stmt|;
operator|*
name|pVM
operator|->
name|ip
operator|=
name|pStep
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                      d e b u g P r o m p t **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|debugPrompt
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"dbg> "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/************************************************************************** **                      i s A F i c l W o r d ** Vet a candidate pointer carefully to make sure ** it's not some chunk o' inline data... ** It has to have a name, and it has to look ** like it's in the dictionary address range. ** NOTE: this excludes :noname words! **************************************************************************/
end_comment

begin_function
name|int
name|isAFiclWord
parameter_list|(
name|FICL_DICT
modifier|*
name|pd
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
name|pFW
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|pFW
operator|->
name|link
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
name|pFW
operator|->
name|link
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|pFW
operator|->
name|nName
operator|<=
literal|0
operator|)
operator|||
operator|(
name|pFW
operator|->
name|name
index|[
name|pFW
operator|->
name|nName
index|]
operator|!=
literal|'\0'
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|strlen
argument_list|(
name|pFW
operator|->
name|name
argument_list|)
operator|!=
name|pFW
operator|->
name|nName
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int isPrimitive(FICL_WORD *pFW) {     WORDKIND wk = ficlWordClassify(pFW);     return ((wk != COLON)&& (wk != DOES)); }
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                         f i n d E n c l o s i n g W o r d ** Given a pointer to something, check to make sure it's an address in the  ** dictionary. If so, search backwards until we find something that looks ** like a dictionary header. If successful, return the address of the  ** FICL_WORD found. Otherwise return NULL. ** nSEARCH_CELLS sets the maximum neighborhood this func will search before giving up **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|nSEARCH_CELLS
value|100
end_define

begin_function
specifier|static
name|FICL_WORD
modifier|*
name|findEnclosingWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|CELL
modifier|*
name|cp
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|FICL_DICT
modifier|*
name|pd
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dictIncludes
argument_list|(
name|pd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
name|nSEARCH_CELLS
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
operator|,
operator|--
name|cp
control|)
block|{
name|pFW
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|cp
operator|+
literal|1
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|FICL_WORD
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|isAFiclWord
argument_list|(
name|pd
argument_list|,
name|pFW
argument_list|)
condition|)
return|return
name|pFW
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s e e  ** TOOLS ( "<spaces>name" -- ) ** Display a human-readable representation of the named word's definition. ** The source of the representation (object-code decompilation, source ** block, etc.) and the particular form of the display is implementation ** defined.  **************************************************************************/
end_comment

begin_comment
comment|/* ** seeColon (for proctologists only) ** Walks a colon definition, decompiling ** on the fly. Knows about primitive control structures. */
end_comment

begin_function
specifier|static
name|void
name|seeColon
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|CELL
modifier|*
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|CELL
modifier|*
name|param0
init|=
name|pc
decl_stmt|;
name|FICL_DICT
modifier|*
name|pd
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pSemiParen
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"(;)"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pSemiParen
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|pc
operator|->
name|p
operator|!=
name|pSemiParen
condition|;
name|pc
operator|++
control|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
operator|(
name|FICL_WORD
operator|*
operator|)
operator|(
name|pc
operator|->
name|p
operator|)
decl_stmt|;
name|cp
operator|=
name|pVM
operator|->
name|pad
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|pc
operator|==
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|ip
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'>'
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
name|cp
operator|+=
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%3d   "
argument_list|,
name|pc
operator|-
name|param0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isAFiclWord
argument_list|(
name|pd
argument_list|,
name|pFW
argument_list|)
condition|)
block|{
name|WORDKIND
name|kind
init|=
name|ficlWordClassify
argument_list|(
name|pFW
argument_list|)
decl_stmt|;
name|CELL
name|c
decl_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|LITERAL
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
if|if
condition|(
name|isAFiclWord
argument_list|(
name|pd
argument_list|,
name|c
operator|.
name|p
argument_list|)
condition|)
block|{
name|FICL_WORD
modifier|*
name|pLit
init|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|c
operator|.
name|p
decl_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%.*s ( %#lx literal )"
argument_list|,
name|pLit
operator|->
name|nName
argument_list|,
name|pLit
operator|->
name|name
argument_list|,
name|c
operator|.
name|u
argument_list|)
expr_stmt|;
block|}
else|else
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"literal %ld (%#lx)"
argument_list|,
name|c
operator|.
name|i
argument_list|,
name|c
operator|.
name|u
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRINGLIT
case|:
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|++
name|pc
decl_stmt|;
name|pc
operator|=
operator|(
name|CELL
operator|*
operator|)
name|alignPtr
argument_list|(
name|sp
operator|->
name|text
operator|+
name|sp
operator|->
name|count
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"s\" %.*s\""
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CSTRINGLIT
case|:
block|{
name|FICL_STRING
modifier|*
name|sp
init|=
operator|(
name|FICL_STRING
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|++
name|pc
decl_stmt|;
name|pc
operator|=
operator|(
name|CELL
operator|*
operator|)
name|alignPtr
argument_list|(
name|sp
operator|->
name|text
operator|+
name|sp
operator|->
name|count
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"c\" %.*s\""
argument_list|,
name|sp
operator|->
name|count
argument_list|,
name|sp
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IF
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"if / while (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"until (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BRANCH
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|i
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"repeat (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|.
name|i
operator|==
literal|1
condition|)
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"else (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"endof (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|OF
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"of (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|QDO
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"?do (leave %d)"
argument_list|,
operator|(
name|CELL
operator|*
operator|)
name|c
operator|.
name|p
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"do (leave %d)"
argument_list|,
operator|(
name|CELL
operator|*
operator|)
name|c
operator|.
name|p
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOOP
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"loop (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
case|case
name|PLOOP
case|:
name|c
operator|=
operator|*
operator|++
name|pc
expr_stmt|;
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"+loop (branch %d)"
argument_list|,
name|pc
operator|+
name|c
operator|.
name|i
operator|-
name|param0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%.*s"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
comment|/* probably not a word - punt and print value */
block|{
name|sprintf
argument_list|(
name|cp
argument_list|,
literal|"%ld ( %#lx )"
argument_list|,
name|pc
operator|->
name|i
argument_list|,
name|pc
operator|->
name|u
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|";"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** Here's the outer part of the decompiler. It's  ** just a big nested conditional that checks the ** CFA of the word to decompile for each kind of ** known word-builder code, and tries to do  ** something appropriate. If the CFA is not recognized, ** just indicate that it is a primitive. */
end_comment

begin_function
specifier|static
name|void
name|seeXT
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|WORDKIND
name|kind
decl_stmt|;
name|pFW
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|kind
operator|=
name|ficlWordClassify
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COLON
case|:
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|": %.*s"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seeColon
argument_list|(
name|pVM
argument_list|,
name|pFW
operator|->
name|param
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOES
case|:
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"does>"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|seeColon
argument_list|(
name|pVM
argument_list|,
operator|(
name|CELL
operator|*
operator|)
name|pFW
operator|->
name|param
operator|->
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CREATE
case|:
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"create"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARIABLE
case|:
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"variable = %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|FICL_WANT_USER
case|case
name|USER
case|:
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"user variable %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|CONSTANT
case|:
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"constant = %ld (%#lx)"
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|i
argument_list|,
name|pFW
operator|->
name|param
operator|->
name|u
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
default|default:
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"%.*s is a primitive"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pFW
operator|->
name|flags
operator|&
name|FW_IMMEDIATE
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"immediate"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pFW
operator|->
name|flags
operator|&
name|FW_COMPILE
condition|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"compile-only"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|see
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|ficlTick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|seeXT
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l D e b u g X T ** debug  ( xt -- ) ** Given an xt of a colon definition or a word defined by DOES>, set the ** VM up to debug the word: push IP, set the xt as the next thing to execute, ** set a breakpoint at its first instruction, and run to the breakpoint. ** Note: the semantics of this word are equivalent to "step in" **************************************************************************/
end_comment

begin_function
name|void
name|ficlDebugXT
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|xt
init|=
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|WORDKIND
name|wk
init|=
name|ficlWordClassify
argument_list|(
name|xt
argument_list|)
decl_stmt|;
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|seeXT
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|wk
condition|)
block|{
case|case
name|COLON
case|:
case|case
name|DOES
case|:
comment|/*         ** Run the colon code and set a breakpoint at the next instruction         */
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|vmSetBreak
argument_list|(
name|pVM
argument_list|,
operator|&
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|xt
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t e p I n ** FICL  ** Execute the next instruction, stepping into it if it's a colon definition  ** or a does> word. This is the easy kind of step. **************************************************************************/
end_comment

begin_function
name|void
name|stepIn
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
comment|/*     ** Do one step of the inner loop     */
block|{
name|M_VM_STEP
argument_list|(
argument|pVM
argument_list|)
block|}
comment|/*     ** Now set a breakpoint at the next instruction     */
name|vmSetBreak
argument_list|(
name|pVM
argument_list|,
operator|&
operator|(
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t e p O v e r ** FICL  ** Execute the next instruction atomically. This requires some insight into  ** the memory layout of compiled code. Set a breakpoint at the next instruction ** in this word, and run until we hit it **************************************************************************/
end_comment

begin_function
name|void
name|stepOver
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|WORDKIND
name|kind
decl_stmt|;
name|FICL_WORD
modifier|*
name|pStep
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"step-break"
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pStep
argument_list|)
expr_stmt|;
name|pFW
operator|=
operator|*
name|pVM
operator|->
name|ip
expr_stmt|;
name|kind
operator|=
name|ficlWordClassify
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|COLON
case|:
case|case
name|DOES
case|:
comment|/*         ** assume that the next cell holds an instruction          ** set a breakpoint there and return to the inner interp         */
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|address
operator|=
name|pVM
operator|->
name|ip
operator|+
literal|1
expr_stmt|;
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|origXT
operator|=
name|pVM
operator|->
name|ip
index|[
literal|1
index|]
expr_stmt|;
name|pVM
operator|->
name|ip
index|[
literal|1
index|]
operator|=
name|pStep
expr_stmt|;
break|break;
default|default:
name|stepIn
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t e p - b r e a k ** FICL ** Handles breakpoints for stepped execution. ** Upon entry, bpStep contains the address and replaced instruction ** of the current breakpoint. ** Clear the breakpoint ** Get a command from the console.  ** i (step in) - execute the current instruction and set a new breakpoint  **    at the IP ** o (step over) - execute the current instruction to completion and set **    a new breakpoint at the IP ** g (go) - execute the current instruction and exit ** q (quit) - abort current word ** b (toggle breakpoint) **************************************************************************/
end_comment

begin_function
name|void
name|stepBreak
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|FICL_WORD
modifier|*
name|pOnStep
decl_stmt|;
if|if
condition|(
operator|!
name|pVM
operator|->
name|fRestart
condition|)
block|{
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|address
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|origXT
argument_list|)
expr_stmt|;
comment|/*         ** Clear the breakpoint that caused me to run         ** Restore the original instruction at the breakpoint,          ** and restore the IP         */
name|pVM
operator|->
name|ip
operator|=
call|(
name|IPTYPE
call|)
argument_list|(
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|address
argument_list|)
expr_stmt|;
operator|*
name|pVM
operator|->
name|ip
operator|=
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|origXT
expr_stmt|;
comment|/*         ** If there's an onStep, do it         */
name|pOnStep
operator|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"on-step"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pOnStep
condition|)
name|ficlExecXT
argument_list|(
name|pVM
argument_list|,
name|pOnStep
argument_list|)
expr_stmt|;
comment|/*         ** Print the name of the next instruction         */
name|pFW
operator|=
name|pVM
operator|->
name|pSys
operator|->
name|bpStep
operator|.
name|origXT
expr_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"next: %.*s"
argument_list|,
name|pFW
operator|->
name|nName
argument_list|,
name|pFW
operator|->
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (isPrimitive(pFW))         {             strcat(pVM->pad, " ( primitive )");         }
endif|#
directive|endif
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debugPrompt
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
block|}
name|si
operator|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"i"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
name|stepIn
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"g"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"l"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
name|FICL_WORD
modifier|*
name|xt
decl_stmt|;
name|xt
operator|=
name|findEnclosingWord
argument_list|(
name|pVM
argument_list|,
operator|(
name|CELL
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xt
condition|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|seeXT
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"sorry - can't do that"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"o"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
name|stepOver
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"q"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
name|ficlTextOut
argument_list|(
name|pVM
argument_list|,
name|FICL_PROMPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_ABORT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
literal|"x"
argument_list|,
name|si
operator|.
name|count
argument_list|)
condition|)
block|{
comment|/*         ** Take whatever's left in the TIB and feed it to a subordinate ficlExec         */
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|pVM
operator|->
name|tib
operator|.
name|cp
operator|+
name|pVM
operator|->
name|tib
operator|.
name|index
decl_stmt|;
name|int
name|count
init|=
name|pVM
operator|->
name|tib
operator|.
name|end
operator|-
name|cp
decl_stmt|;
name|FICL_WORD
modifier|*
name|oldRun
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
name|ret
operator|=
name|ficlExecC
argument_list|(
name|pVM
argument_list|,
name|cp
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|VM_OUTOFTEXT
condition|)
block|{
name|ret
operator|=
name|VM_RESTART
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|=
name|oldRun
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"i -- step In"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"o -- step Over"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"g -- Go (execute to completion)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"l -- List source code"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"q -- Quit (stop debugging and abort)"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"x -- eXecute the rest of the line as ficl words"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|debugPrompt
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         b y e ** TOOLS ** Signal the system to shut down - this causes ficlExec to return ** VM_USEREXIT. The rest is up to you. **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|bye
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_USEREXIT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i s p l a y S t a c k ** TOOLS  ** Display the parameter stack (code for ".s") **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|displayPStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STACK
modifier|*
name|pStk
init|=
name|pVM
operator|->
name|pStack
decl_stmt|;
name|int
name|d
init|=
name|stackDepth
argument_list|(
name|pStk
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CELL
modifier|*
name|pCell
decl_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"(Stack Empty) "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|pCell
operator|=
name|pStk
operator|->
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|ltoa
argument_list|(
operator|(
operator|*
name|pCell
operator|++
operator|)
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|displayRStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_STACK
modifier|*
name|pStk
init|=
name|pVM
operator|->
name|rStack
decl_stmt|;
name|int
name|d
init|=
name|stackDepth
argument_list|(
name|pStk
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CELL
modifier|*
name|pCell
decl_stmt|;
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"(Stack Empty) "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|pCell
operator|=
name|pStk
operator|->
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|CELL
name|c
init|=
operator|*
name|pCell
operator|++
decl_stmt|;
comment|/*             ** Attempt to find the word that contains the             ** stacked address (as if it is part of a colon definition).             ** If this works, print the name of the word. Otherwise print             ** the value as a number.             */
if|if
condition|(
name|dictIncludes
argument_list|(
name|dp
argument_list|,
name|c
operator|.
name|p
argument_list|)
condition|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|findEnclosingWord
argument_list|(
name|pVM
argument_list|,
name|c
operator|.
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|pFW
condition|)
block|{
name|int
name|offset
init|=
operator|(
name|CELL
operator|*
operator|)
name|c
operator|.
name|p
operator|-
operator|&
name|pFW
operator|->
name|param
index|[
literal|0
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"%s+%d "
argument_list|,
name|pFW
operator|->
name|name
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* no need to print the numeric value */
block|}
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|ltoa
argument_list|(
name|c
operator|.
name|i
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f o r g e t - w i d **  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|forgetWid
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|pHash
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|hashForget
argument_list|(
name|pHash
argument_list|,
name|pDict
operator|->
name|here
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f o r g e t ** TOOLS EXT  ( "<spaces>name" -- ) ** Skip leading space delimiters. Parse name delimited by a space. ** Find name, then delete name from the dictionary along with all ** words added to the dictionary after name. An ambiguous ** condition exists if name cannot be found.  **  ** If the Search-Order word set is present, FORGET searches the ** compilation word list. An ambiguous condition exists if the ** compilation word list is deleted.  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|forget
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|void
modifier|*
name|where
decl_stmt|;
name|FICL_DICT
modifier|*
name|pDict
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|pDict
operator|->
name|pCompile
decl_stmt|;
name|ficlTick
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|where
operator|=
operator|(
operator|(
name|FICL_WORD
operator|*
operator|)
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
operator|)
operator|->
name|name
expr_stmt|;
name|hashForget
argument_list|(
name|pHash
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|here
operator|=
name|PTRtoCELL
name|where
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i s t W o r d s **  **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|nCOLWIDTH
value|8
end_define

begin_function
specifier|static
name|void
name|listWords
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|dp
operator|->
name|pSearch
index|[
name|dp
operator|->
name|nLists
operator|-
literal|1
index|]
decl_stmt|;
name|FICL_WORD
modifier|*
name|wp
decl_stmt|;
name|int
name|nChars
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|y
init|=
literal|0
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|nWords
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|pPad
init|=
name|pVM
operator|->
name|pad
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|wp
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
init|;
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|=
name|wp
operator|->
name|link
operator|,
name|nWords
operator|++
control|)
block|{
if|if
condition|(
name|wp
operator|->
name|nName
operator|==
literal|0
condition|)
comment|/* ignore :noname defs */
continue|continue;
name|cp
operator|=
name|wp
operator|->
name|name
expr_stmt|;
name|nChars
operator|+=
name|sprintf
argument_list|(
name|pPad
operator|+
name|nChars
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nChars
operator|>
literal|70
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|23
condition|)
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"--- Press Enter to continue ---"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|nCOLWIDTH
operator|-
name|nChars
operator|%
name|nCOLWIDTH
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|pPad
index|[
name|nChars
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|nChars
operator|>
literal|70
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|y
operator|++
expr_stmt|;
if|if
condition|(
name|y
operator|>
literal|23
condition|)
block|{
name|y
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"--- Press Enter to continue ---"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|getchar
argument_list|()
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nChars
operator|>
literal|0
condition|)
block|{
name|pPad
index|[
name|nChars
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nChars
operator|=
literal|0
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pPad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"Dictionary: %d words, %ld cells used of %u total"
argument_list|,
name|nWords
argument_list|,
call|(
name|long
call|)
argument_list|(
name|dp
operator|->
name|here
operator|-
name|dp
operator|->
name|dict
argument_list|)
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l i s t E n v ** Print symbols defined in the environment  **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|listEnv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pVM
operator|->
name|pSys
operator|->
name|envp
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|dp
operator|->
name|pForthWords
decl_stmt|;
name|FICL_WORD
modifier|*
name|wp
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|nWords
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|wp
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
init|;
name|wp
operator|!=
name|NULL
condition|;
name|wp
operator|=
name|wp
operator|->
name|link
operator|,
name|nWords
operator|++
control|)
block|{
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|wp
operator|->
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"Environment: %d words, %ld cells used of %u total"
argument_list|,
name|nWords
argument_list|,
call|(
name|long
call|)
argument_list|(
name|dp
operator|->
name|here
operator|-
name|dp
operator|->
name|dict
argument_list|)
argument_list|,
name|dp
operator|->
name|size
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         e n v C o n s t a n t ** Ficl interface to ficlSetEnv and ficlSetEnvD - allow ficl code to set ** environment constants... **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|envConstant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|unsigned
name|value
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vmGetWordToPad
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|value
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|env2Constant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|unsigned
name|v1
decl_stmt|,
name|v2
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vmGetWordToPad
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|v2
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|v1
operator|=
name|POPUNS
argument_list|()
expr_stmt|;
name|ficlSetEnvD
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
name|v1
argument_list|,
name|v2
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l C o m p i l e T o o l s ** Builds wordset for debugger and TOOLS optional word set **************************************************************************/
end_comment

begin_function
name|void
name|ficlCompileTools
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|assert
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/*     ** TOOLS and TOOLS EXT     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".s"
argument_list|,
name|displayPStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"bye"
argument_list|,
name|bye
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"forget"
argument_list|,
name|forget
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"see"
argument_list|,
name|see
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"words"
argument_list|,
name|listWords
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** Set TOOLS environment query values     */
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"tools"
argument_list|,
name|FICL_TRUE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"tools-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
comment|/*     ** Ficl extras     */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"r.s"
argument_list|,
name|displayRStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* guy carver */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|".env"
argument_list|,
name|listEnv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"env-constant"
argument_list|,
name|envConstant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"env-2constant"
argument_list|,
name|env2Constant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"debug-xt"
argument_list|,
name|ficlDebugXT
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"parse-order"
argument_list|,
name|ficlListParseSteps
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"step-break"
argument_list|,
name|stepBreak
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"forget-wid"
argument_list|,
name|forgetWid
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"see-xt"
argument_list|,
name|seeXT
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

