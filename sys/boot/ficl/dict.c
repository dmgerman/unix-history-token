begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** d i c t . c ** Forth Inspired Command Language - dictionary methods ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* ** This file implements the dictionary -- FICL's model of  ** memory management. All FICL words are stored in the ** dictionary. A word is a named chunk of data with its ** associated code. FICL treats all words the same, even ** precompiled ones, so your words become first-class ** extensions of the language. You can even define new  ** control structures. ** ** 29 jun 1998 (sadler) added variable sized hash table support */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_function_decl
specifier|static
name|char
modifier|*
name|dictCopyName
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**************************************************************************                         d i c t A b o r t D e f i n i t i o n ** Abort a definition in process: reclaim its memory and unlink it ** from the dictionary list. Assumes that there is a smudged  ** definition in process...otherwise does nothing. ** NOTE: this function is not smart enough to unlink a word that ** has been successfully defined (ie linked into a hash). It ** only works for defs in process. If the def has been unsmudged, ** nothing happens. **************************************************************************/
end_comment

begin_function
name|void
name|dictAbortDefinition
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|pFW
operator|=
name|pDict
operator|->
name|smudge
expr_stmt|;
if|if
condition|(
name|pFW
operator|->
name|flags
operator|&
name|FW_SMUDGE
condition|)
name|pDict
operator|->
name|here
operator|=
operator|(
name|CELL
operator|*
operator|)
name|pFW
operator|->
name|name
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         a l i g n P t r ** Aligns the given pointer to FICL_ALIGN address units. ** Returns the aligned pointer value. **************************************************************************/
end_comment

begin_function
name|void
modifier|*
name|alignPtr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
if|#
directive|if
name|FICL_ALIGN
operator|>
literal|0
name|char
modifier|*
name|cp
decl_stmt|;
name|CELL
name|c
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|FICL_ALIGN_ADD
expr_stmt|;
name|c
operator|.
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|cp
expr_stmt|;
name|c
operator|.
name|u
operator|=
name|c
operator|.
name|u
operator|&
operator|(
operator|~
name|FICL_ALIGN_ADD
operator|)
expr_stmt|;
name|ptr
operator|=
operator|(
name|CELL
operator|*
operator|)
name|c
operator|.
name|p
expr_stmt|;
endif|#
directive|endif
return|return
name|ptr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A l i g n ** Align the dictionary's free space pointer **************************************************************************/
end_comment

begin_function
name|void
name|dictAlign
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|pDict
operator|->
name|here
operator|=
name|alignPtr
argument_list|(
name|pDict
operator|->
name|here
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A l l o t ** Allocate or remove n chars of dictionary space, with ** checks for underrun and overrun **************************************************************************/
end_comment

begin_function
name|int
name|dictAllot
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|pDict
operator|->
name|here
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|n
operator|<=
name|dictCellsAvail
argument_list|(
name|pDict
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
condition|)
name|cp
operator|+=
name|n
expr_stmt|;
else|else
return|return
literal|1
return|;
comment|/* dict is full */
block|}
else|else
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|n
operator|<=
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
condition|)
name|cp
operator|-=
name|n
expr_stmt|;
else|else
comment|/* prevent underflow */
name|cp
operator|-=
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|cp
operator|+=
name|n
expr_stmt|;
endif|#
directive|endif
name|pDict
operator|->
name|here
operator|=
name|PTRtoCELL
name|cp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A l l o t C e l l s ** Reserve space for the requested number of cells in the ** dictionary. If nCells< 0 , removes space from the dictionary. **************************************************************************/
end_comment

begin_function
name|int
name|dictAllotCells
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|int
name|nCells
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
if|if
condition|(
name|nCells
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nCells
operator|<=
name|dictCellsAvail
argument_list|(
name|pDict
argument_list|)
condition|)
name|pDict
operator|->
name|here
operator|+=
name|nCells
expr_stmt|;
else|else
return|return
literal|1
return|;
comment|/* dict is full */
block|}
else|else
block|{
name|nCells
operator|=
operator|-
name|nCells
expr_stmt|;
if|if
condition|(
name|nCells
operator|<=
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
condition|)
name|pDict
operator|->
name|here
operator|-=
name|nCells
expr_stmt|;
else|else
comment|/* prevent underflow */
name|pDict
operator|->
name|here
operator|-=
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pDict
operator|->
name|here
operator|+=
name|nCells
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A p p e n d C e l l ** Append the specified cell to the dictionary **************************************************************************/
end_comment

begin_function
name|void
name|dictAppendCell
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|CELL
name|c
parameter_list|)
block|{
operator|*
name|pDict
operator|->
name|here
operator|++
operator|=
name|c
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A p p e n d C h a r ** Append the specified char to the dictionary **************************************************************************/
end_comment

begin_function
name|void
name|dictAppendChar
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|pDict
operator|->
name|here
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
name|pDict
operator|->
name|here
operator|=
name|PTRtoCELL
name|cp
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A p p e n d W o r d ** Create a new word in the dictionary with the specified ** name, code, and flags. Name must be NULL-terminated. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|dictAppendWord
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|dictAppendWord2
argument_list|(
name|pDict
argument_list|,
name|si
argument_list|,
name|pCode
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A p p e n d W o r d 2 ** Create a new word in the dictionary with the specified ** STRINGINFO, code, and flags. Does not require a NULL-terminated ** name. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|dictAppendWord2
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|FICL_CODE
name|pCode
parameter_list|,
name|UNS8
name|flags
parameter_list|)
block|{
name|FICL_COUNT
name|len
init|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pName
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|ficlLockDictionary
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/*     ** NOTE: dictCopyName advances "here" as a side-effect.     ** It must execute before pFW is initialized.     */
name|pName
operator|=
name|dictCopyName
argument_list|(
name|pDict
argument_list|,
name|si
argument_list|)
expr_stmt|;
name|pFW
operator|=
operator|(
name|FICL_WORD
operator|*
operator|)
name|pDict
operator|->
name|here
expr_stmt|;
name|pDict
operator|->
name|smudge
operator|=
name|pFW
expr_stmt|;
name|pFW
operator|->
name|hash
operator|=
name|hashHashCode
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|code
operator|=
name|pCode
expr_stmt|;
name|pFW
operator|->
name|flags
operator|=
call|(
name|UNS8
call|)
argument_list|(
name|flags
operator||
name|FW_SMUDGE
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|nName
operator|=
operator|(
name|char
operator|)
name|len
expr_stmt|;
name|pFW
operator|->
name|name
operator|=
name|pName
expr_stmt|;
comment|/*     ** Point "here" to first cell of new word's param area...     */
name|pDict
operator|->
name|here
operator|=
name|pFW
operator|->
name|param
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FW_SMUDGE
operator|)
condition|)
name|dictUnsmudge
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|pFW
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t A p p e n d U N S 3 2 ** Append the specified UNS32 to the dictionary **************************************************************************/
end_comment

begin_function
name|void
name|dictAppendUNS
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|UNS32
name|u
parameter_list|)
block|{
operator|*
name|pDict
operator|->
name|here
operator|++
operator|=
name|LVALUEtoCELL
argument_list|(
name|u
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t C e l l s A v a i l ** Returns the number of empty cells left in the dictionary **************************************************************************/
end_comment

begin_function
name|int
name|dictCellsAvail
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
return|return
name|pDict
operator|->
name|size
operator|-
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t C e l l s U s e d ** Returns the number of cells consumed in the dicionary **************************************************************************/
end_comment

begin_function
name|int
name|dictCellsUsed
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
return|return
name|pDict
operator|->
name|here
operator|-
name|pDict
operator|->
name|dict
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t C h e c k ** Checks the dictionary for corruption and throws appropriate ** errors **************************************************************************/
end_comment

begin_function
name|void
name|dictCheck
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|nCells
parameter_list|)
block|{
if|if
condition|(
operator|(
name|nCells
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|dictCellsAvail
argument_list|(
name|pDict
argument_list|)
operator|<
name|nCells
operator|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: dictionary full"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nCells
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|dictCellsUsed
argument_list|(
name|pDict
argument_list|)
operator|<
operator|-
name|nCells
operator|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: dictionary underflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pDict
operator|->
name|nLists
operator|>
name|FICL_DEFAULT_VOCS
condition|)
block|{
name|dictResetSearchOrder
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: search order overflow"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pDict
operator|->
name|nLists
operator|<
literal|0
condition|)
block|{
name|dictResetSearchOrder
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: search order underflow"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t C o p y N a m e ** Copy up to nFICLNAME characters of the name specified by si into ** the dictionary starting at "here", then NULL-terminate the name, ** point "here" to the next available byte, and return the address of ** the beginning of the name. Used by dictAppendWord. ** N O T E S : ** 1. "here" is guaranteed to be aligned after this operation. ** 2. If the string has zero length, align and return "here" **************************************************************************/
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dictCopyName
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|char
modifier|*
name|oldCP
init|=
operator|(
name|char
operator|*
operator|)
name|pDict
operator|->
name|here
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|oldCP
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|SI_PTR
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|dictAlign
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
return|return
operator|(
name|char
operator|*
operator|)
name|pDict
operator|->
name|here
return|;
block|}
if|if
condition|(
name|i
operator|>
name|nFICLNAME
condition|)
name|i
operator|=
name|nFICLNAME
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pDict
operator|->
name|here
operator|=
name|PTRtoCELL
name|cp
expr_stmt|;
name|dictAlign
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
return|return
name|oldCP
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t C r e a t e ** Create and initialize a dictionary with the specified number ** of cells capacity, and no hashing (hash size == 1). **************************************************************************/
end_comment

begin_function
name|FICL_DICT
modifier|*
name|dictCreate
parameter_list|(
name|unsigned
name|nCells
parameter_list|)
block|{
return|return
name|dictCreateHashed
argument_list|(
name|nCells
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|FICL_DICT
modifier|*
name|dictCreateHashed
parameter_list|(
name|unsigned
name|nCells
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|pDict
decl_stmt|;
name|size_t
name|nAlloc
decl_stmt|;
name|nAlloc
operator|=
sizeof|sizeof
argument_list|(
name|FICL_DICT
argument_list|)
operator|+
name|nCells
operator|*
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|FICL_HASH
argument_list|)
operator|+
operator|(
name|nHash
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FICL_WORD
operator|*
argument_list|)
expr_stmt|;
name|pDict
operator|=
name|ficlMalloc
argument_list|(
name|nAlloc
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pDict
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_DICT
argument_list|)
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|size
operator|=
name|nCells
expr_stmt|;
name|dictEmpty
argument_list|(
name|pDict
argument_list|,
name|nHash
argument_list|)
expr_stmt|;
return|return
name|pDict
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t D e l e t e  ** Free all memory allocated for the given dictionary  **************************************************************************/
end_comment

begin_function
name|void
name|dictDelete
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t E m p t y ** Empty the dictionary, reset its hash table, and reset its search order. ** Clears and (re-)creates the main hash table (pForthWords) with the ** size specified by nHash. **************************************************************************/
end_comment

begin_function
name|void
name|dictEmpty
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|unsigned
name|nHash
parameter_list|)
block|{
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|pDict
operator|->
name|here
operator|=
name|pDict
operator|->
name|dict
expr_stmt|;
name|dictAlign
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|pHash
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
name|pDict
operator|->
name|here
expr_stmt|;
name|dictAllot
argument_list|(
name|pDict
argument_list|,
sizeof|sizeof
argument_list|(
name|FICL_HASH
argument_list|)
operator|+
operator|(
name|nHash
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|FICL_WORD
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|pHash
operator|->
name|size
operator|=
name|nHash
expr_stmt|;
name|hashReset
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|pForthWords
operator|=
name|pHash
expr_stmt|;
name|pDict
operator|->
name|smudge
operator|=
name|NULL
expr_stmt|;
name|dictResetSearchOrder
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t I n c l u d e s ** Returns TRUE iff the given pointer is within the address range of  ** the dictionary. **************************************************************************/
end_comment

begin_function
name|int
name|dictIncludes
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
operator|(
name|p
operator|>=
operator|(
name|void
operator|*
operator|)
operator|&
name|pDict
operator|->
name|dict
operator|)
operator|&&
operator|(
name|p
operator|<
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|pDict
operator|->
name|dict
operator|+
name|pDict
operator|->
name|size
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t L o o k u p ** Find the FICL_WORD that matches the given name and length. ** If found, returns the word's address. Otherwise returns NULL. ** Uses the search order list to search multiple wordlists. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|dictLookup
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|NULL
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|int
name|i
decl_stmt|;
name|UNS16
name|hashCode
init|=
name|hashHashCode
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|pDict
operator|->
name|nLists
operator|-
literal|1
init|;
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|pFW
operator|)
condition|;
operator|--
name|i
control|)
block|{
name|pHash
operator|=
name|pDict
operator|->
name|pSearch
index|[
name|i
index|]
expr_stmt|;
name|pFW
operator|=
name|hashLookup
argument_list|(
name|pHash
argument_list|,
name|si
argument_list|,
name|hashCode
argument_list|)
expr_stmt|;
block|}
name|ficlLockDictionary
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|pFW
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t L o o k u p L o c ** Same as dictLookup, but looks in system locals dictionary first... ** Assumes locals dictionary has only one wordlist... **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|FICL_WANT_LOCALS
end_if

begin_function
name|FICL_WORD
modifier|*
name|dictLookupLoc
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|NULL
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|ficlGetLoc
argument_list|()
operator|->
name|pForthWords
decl_stmt|;
name|int
name|i
decl_stmt|;
name|UNS16
name|hashCode
init|=
name|hashHashCode
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|ficlLockDictionary
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/*      ** check the locals dict first...      */
name|pFW
operator|=
name|hashLookup
argument_list|(
name|pHash
argument_list|,
name|si
argument_list|,
name|hashCode
argument_list|)
expr_stmt|;
comment|/*      ** If no joy, (!pFW) --------------------------v     ** iterate over the search list in the main dict      */
for|for
control|(
name|i
operator|=
operator|(
name|int
operator|)
name|pDict
operator|->
name|nLists
operator|-
literal|1
init|;
operator|(
name|i
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|!
name|pFW
operator|)
condition|;
operator|--
name|i
control|)
block|{
name|pHash
operator|=
name|pDict
operator|->
name|pSearch
index|[
name|i
index|]
expr_stmt|;
name|pFW
operator|=
name|hashLookup
argument_list|(
name|pHash
argument_list|,
name|si
argument_list|,
name|hashCode
argument_list|)
expr_stmt|;
block|}
name|ficlLockDictionary
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|pFW
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**************************************************************************                     d i c t R e s e t S e a r c h O r d e r ** Initialize the dictionary search order list to sane state **************************************************************************/
end_comment

begin_function
name|void
name|dictResetSearchOrder
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|assert
argument_list|(
name|pDict
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|pCompile
operator|=
name|pDict
operator|->
name|pForthWords
expr_stmt|;
name|pDict
operator|->
name|nLists
operator|=
literal|1
expr_stmt|;
name|pDict
operator|->
name|pSearch
index|[
literal|0
index|]
operator|=
name|pDict
operator|->
name|pForthWords
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t S e t F l a g s ** Changes the flags field of the most recently defined word: ** Set all bits that are ones in the set parameter, clear all bits ** that are ones in the clr parameter. Clear wins in case the same bit ** is set in both parameters. **************************************************************************/
end_comment

begin_function
name|void
name|dictSetFlags
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|,
name|UNS8
name|set
parameter_list|,
name|UNS8
name|clr
parameter_list|)
block|{
name|assert
argument_list|(
name|pDict
operator|->
name|smudge
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|smudge
operator|->
name|flags
operator||=
name|set
expr_stmt|;
name|pDict
operator|->
name|smudge
operator|->
name|flags
operator|&=
operator|~
name|clr
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t S e t I m m e d i a t e  ** Set the most recently defined word as IMMEDIATE **************************************************************************/
end_comment

begin_function
name|void
name|dictSetImmediate
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|assert
argument_list|(
name|pDict
operator|->
name|smudge
argument_list|)
expr_stmt|;
name|pDict
operator|->
name|smudge
operator|->
name|flags
operator||=
name|FW_IMMEDIATE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t U n s m u d g e  ** Completes the definition of a word by linking it ** into the main list **************************************************************************/
end_comment

begin_function
name|void
name|dictUnsmudge
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pDict
operator|->
name|smudge
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
init|=
name|pDict
operator|->
name|pCompile
decl_stmt|;
name|assert
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
comment|/*     ** :noname words never get linked into the list...     */
if|if
condition|(
name|pFW
operator|->
name|nName
operator|>
literal|0
condition|)
name|hashInsertWord
argument_list|(
name|pHash
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
name|pFW
operator|->
name|flags
operator|&=
operator|~
operator|(
name|FW_SMUDGE
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i c t W h e r e ** Returns the value of the HERE pointer -- the address ** of the next free cell in the dictionary **************************************************************************/
end_comment

begin_function
name|CELL
modifier|*
name|dictWhere
parameter_list|(
name|FICL_DICT
modifier|*
name|pDict
parameter_list|)
block|{
return|return
name|pDict
operator|->
name|here
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h F o r g e t ** Unlink all words in the hash that have addresses greater than or ** equal to the address supplied. Implementation factor for FORGET ** and MARKER. **************************************************************************/
end_comment

begin_function
name|void
name|hashForget
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|void
modifier|*
name|where
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pWord
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|assert
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|where
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|pWord
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|void
operator|*
operator|)
name|pWord
operator|>=
name|where
condition|)
block|{
name|pWord
operator|=
name|pWord
operator|->
name|link
expr_stmt|;
block|}
name|pHash
operator|->
name|table
index|[
name|i
index|]
operator|=
name|pWord
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h H a s h C o d e **  ** Generate a 16 bit hashcode from a character string using a rolling ** shift and add stolen from PJ Weinberger of Bell Labs fame. Case folds ** the name before hashing it... ** N O T E : If string has zero length, returns zero. **************************************************************************/
end_comment

begin_function
name|UNS16
name|hashHashCode
parameter_list|(
name|STRINGINFO
name|si
parameter_list|)
block|{
comment|/* hashPJW */
name|UNS8
modifier|*
name|cp
decl_stmt|;
name|UNS16
name|code
init|=
operator|(
name|UNS16
operator|)
name|si
operator|.
name|count
decl_stmt|;
name|UNS16
name|shift
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|.
name|count
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|cp
operator|=
operator|(
name|UNS8
operator|*
operator|)
name|si
operator|.
name|cp
init|;
operator|*
name|cp
operator|&&
name|si
operator|.
name|count
condition|;
name|cp
operator|++
operator|,
name|si
operator|.
name|count
operator|--
control|)
block|{
name|code
operator|=
call|(
name|UNS16
call|)
argument_list|(
operator|(
name|code
operator|<<
literal|4
operator|)
operator|+
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|shift
operator|=
call|(
name|UNS16
call|)
argument_list|(
name|code
operator|&
literal|0xf000
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
condition|)
block|{
name|code
operator|^=
call|(
name|UNS16
call|)
argument_list|(
name|shift
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|code
operator|^=
operator|(
name|UNS16
operator|)
name|shift
expr_stmt|;
block|}
block|}
return|return
operator|(
name|UNS16
operator|)
name|code
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h I n s e r t W o r d ** Put a word into the hash table using the word's hashcode as ** an index (modulo the table size). **************************************************************************/
end_comment

begin_function
name|void
name|hashInsertWord
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
name|FICL_WORD
modifier|*
modifier|*
name|pList
decl_stmt|;
name|assert
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pFW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pHash
operator|->
name|size
operator|==
literal|1
condition|)
block|{
name|pList
operator|=
name|pHash
operator|->
name|table
expr_stmt|;
block|}
else|else
block|{
name|pList
operator|=
name|pHash
operator|->
name|table
operator|+
operator|(
name|pFW
operator|->
name|hash
operator|%
name|pHash
operator|->
name|size
operator|)
expr_stmt|;
block|}
name|pFW
operator|->
name|link
operator|=
operator|*
name|pList
expr_stmt|;
operator|*
name|pList
operator|=
name|pFW
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         h a s h L o o k u p ** Find a name in the hash table given the hashcode and text of the name. ** Returns the address of the corresponding FICL_WORD if found,  ** otherwise NULL. ** Note: outer loop on link field supports inheritance in wordlists. ** It's not part of ANS Forth - ficl only. hashReset creates wordlists ** with NULL link fields. **************************************************************************/
end_comment

begin_function
name|FICL_WORD
modifier|*
name|hashLookup
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|,
name|STRINGINFO
name|si
parameter_list|,
name|UNS16
name|hashCode
parameter_list|)
block|{
name|FICL_COUNT
name|nCmp
init|=
operator|(
name|FICL_COUNT
operator|)
name|si
operator|.
name|count
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
name|UNS16
name|hashIdx
decl_stmt|;
if|if
condition|(
name|nCmp
operator|>
name|nFICLNAME
condition|)
name|nCmp
operator|=
name|nFICLNAME
expr_stmt|;
for|for
control|(
init|;
name|pHash
operator|!=
name|NULL
condition|;
name|pHash
operator|=
name|pHash
operator|->
name|link
control|)
block|{
if|if
condition|(
name|pHash
operator|->
name|size
operator|>
literal|1
condition|)
name|hashIdx
operator|=
call|(
name|UNS16
call|)
argument_list|(
name|hashCode
operator|%
name|pHash
operator|->
name|size
argument_list|)
expr_stmt|;
else|else
comment|/* avoid the modulo op for single threaded lists */
name|hashIdx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pFW
operator|=
name|pHash
operator|->
name|table
index|[
name|hashIdx
index|]
init|;
name|pFW
condition|;
name|pFW
operator|=
name|pFW
operator|->
name|link
control|)
block|{
if|if
condition|(
operator|(
name|pFW
operator|->
name|nName
operator|==
name|si
operator|.
name|count
operator|)
operator|&&
operator|(
operator|!
name|strincmp
argument_list|(
name|si
operator|.
name|cp
argument_list|,
name|pFW
operator|->
name|name
argument_list|,
name|nCmp
argument_list|)
operator|)
condition|)
return|return
name|pFW
return|;
if|#
directive|if
name|FICL_ROBUST
name|assert
argument_list|(
name|pFW
operator|!=
name|pFW
operator|->
name|link
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                              h a s h R e s e t ** Initialize a FICL_HASH to empty state. **************************************************************************/
end_comment

begin_function
name|void
name|hashReset
parameter_list|(
name|FICL_HASH
modifier|*
name|pHash
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|assert
argument_list|(
name|pHash
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|pHash
operator|->
name|table
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|pHash
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

end_unit

