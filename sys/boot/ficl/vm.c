begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** v m . c ** Forth Inspired Command Language - virtual machine methods ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 19 July 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* ** This file implements the virtual machine of FICL. Each virtual ** machine retains the state of an interpreter. A virtual machine ** owns a pair of stacks for parameters and return addresses, as ** well as a pile of state variables and the two dedicated registers ** of the interp. */
end_comment

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         v m B r a n c h R e l a t i v e  **  **************************************************************************/
end_comment

begin_function
name|void
name|vmBranchRelative
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|pVM
operator|->
name|ip
operator|+=
name|offset
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m C r e a t e **  **************************************************************************/
end_comment

begin_function
name|FICL_VM
modifier|*
name|vmCreate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|unsigned
name|nPStack
parameter_list|,
name|unsigned
name|nRStack
parameter_list|)
block|{
if|if
condition|(
name|pVM
operator|==
name|NULL
condition|)
block|{
name|pVM
operator|=
operator|(
name|FICL_VM
operator|*
operator|)
name|ficlMalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|FICL_VM
argument_list|)
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|pStack
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|rStack
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|link
operator|=
name|NULL
expr_stmt|;
block|}
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|pStack
condition|)
name|stackDelete
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|pStack
operator|=
name|stackCreate
argument_list|(
name|nPStack
argument_list|)
expr_stmt|;
if|if
condition|(
name|pVM
operator|->
name|rStack
condition|)
name|stackDelete
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|rStack
operator|=
name|stackCreate
argument_list|(
name|nRStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|textOut
operator|=
name|ficlTextOut
expr_stmt|;
name|vmReset
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return
name|pVM
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m D e l e t e **  **************************************************************************/
end_comment

begin_function
name|void
name|vmDelete
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|if
condition|(
name|pVM
condition|)
block|{
name|ficlFree
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
name|ficlFree
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m E x e c u t e **  **************************************************************************/
end_comment

begin_function
name|void
name|vmExecute
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_WORD
modifier|*
name|pWord
parameter_list|)
block|{
name|pVM
operator|->
name|runningWord
operator|=
name|pWord
expr_stmt|;
name|pWord
operator|->
name|code
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t S t r i n g ** Parses a string out of the VM input buffer and copies up to the first ** FICL_STRING_MAX characters to the supplied destination buffer, a ** FICL_STRING. The destination string is NULL terminated. **  ** Returns the address of the first unused character in the dest buffer. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|vmGetString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|FICL_STRING
modifier|*
name|spDest
parameter_list|,
name|char
name|delimiter
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmParseString
argument_list|(
name|pVM
argument_list|,
name|delimiter
argument_list|)
decl_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|FICL_STRING_MAX
condition|)
block|{
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|FICL_STRING_MAX
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|spDest
operator|->
name|text
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|spDest
operator|->
name|text
index|[
name|SI_COUNT
argument_list|(
name|si
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spDest
operator|->
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
return|return
name|spDest
operator|->
name|text
operator|+
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d ** vmGetWord calls vmGetWord0 repeatedly until it gets a string with  ** non-zero length. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmGetWord
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
init|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vmThrow
argument_list|(
name|pVM
argument_list|,
name|VM_RESTART
argument_list|)
expr_stmt|;
block|}
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d 0 ** Skip leading whitespace and parse a space delimited word from the tib. ** Returns the start address and length of the word. Updates the tib ** to reflect characters consumed, including the trailing delimiter. ** If there's nothing of interest in the tib, returns zero. This function ** does not use vmParseString because it uses isspace() rather than a ** single  delimiter character. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmGetWord0
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
decl_stmt|;
name|UNS32
name|count
init|=
literal|0
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|pSrc
operator|=
name|skipSpace
argument_list|(
name|pSrc
argument_list|)
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
operator|*
name|pSrc
init|;
name|ch
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
name|ch
argument_list|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|pSrc
control|)
block|{
name|count
operator|++
expr_stmt|;
block|}
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
comment|/* skip one trailing delimiter */
name|pSrc
operator|++
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m G e t W o r d T o P a d ** Does vmGetWord0 and copies the result to the pad as a NULL terminated ** string. Returns the length of the string. If the string is too long  ** to fit in the pad, it is truncated. **************************************************************************/
end_comment

begin_function
name|int
name|vmGetWordToPad
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|pVM
operator|->
name|pad
decl_stmt|;
name|si
operator|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
operator|>
name|nPAD
condition|)
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|nPAD
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|cp
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|SI_COUNT
argument_list|(
name|si
argument_list|)
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|SI_COUNT
argument_list|(
name|si
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P a r s e S t r i n g ** Parses a string out of the input buffer using the delimiter ** specified. Skips leading delimiters, marks the start of the string, ** and counts characters to the next delimiter it encounters. It then  ** updates the vm input buffer to consume all these chars, including the ** trailing delimiter.  ** Returns the address and length of the parsed string, not including the ** trailing delimiter. **************************************************************************/
end_comment

begin_function
name|STRINGINFO
name|vmParseString
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
name|delim
parameter_list|)
block|{
name|STRINGINFO
name|si
decl_stmt|;
name|char
modifier|*
name|pSrc
init|=
name|vmGetInBuf
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
operator|*
name|pSrc
operator|==
name|delim
condition|)
comment|/* skip lead delimiters */
name|pSrc
operator|++
expr_stmt|;
name|SI_SETPTR
argument_list|(
name|si
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
comment|/* mark start of text */
for|for
control|(
name|ch
operator|=
operator|*
name|pSrc
init|;
operator|(
name|ch
operator|!=
name|delim
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\r'
operator|)
operator|&&
operator|(
name|ch
operator|!=
literal|'\n'
operator|)
condition|;
name|ch
operator|=
operator|*
operator|++
name|pSrc
control|)
block|{
empty_stmt|;
comment|/* find next delimiter or end of line */
block|}
comment|/* set length of result */
name|SI_SETLEN
argument_list|(
name|si
argument_list|,
name|pSrc
operator|-
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pSrc
operator|==
name|delim
condition|)
comment|/* gobble trailing delimiter */
name|pSrc
operator|++
expr_stmt|;
name|vmUpdateTib
argument_list|(
name|pVM
argument_list|,
name|pSrc
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P o p I P **  **************************************************************************/
end_comment

begin_function
name|void
name|vmPopIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|pVM
operator|->
name|ip
operator|=
call|(
name|IPTYPE
call|)
argument_list|(
name|stackPopPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P u s h I P **  **************************************************************************/
end_comment

begin_function
name|void
name|vmPushIP
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|IPTYPE
name|newIP
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pVM
operator|->
name|ip
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
name|newIP
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m P u s h T i b ** Binds the specified input string to the VM and clears>IN (the index) **************************************************************************/
end_comment

begin_function
name|void
name|vmPushTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|TIB
modifier|*
name|pSaveTib
parameter_list|)
block|{
if|if
condition|(
name|pSaveTib
condition|)
block|{
operator|*
name|pSaveTib
operator|=
name|pVM
operator|->
name|tib
expr_stmt|;
block|}
name|pVM
operator|->
name|tib
operator|.
name|cp
operator|=
name|text
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|index
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmPopTib
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|TIB
modifier|*
name|pTib
parameter_list|)
block|{
if|if
condition|(
name|pTib
condition|)
block|{
name|pVM
operator|->
name|tib
operator|=
operator|*
name|pTib
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m Q u i t **  **************************************************************************/
end_comment

begin_function
name|void
name|vmQuit
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
specifier|static
name|FICL_WORD
modifier|*
name|pInterp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|pInterp
condition|)
name|pInterp
operator|=
name|ficlLookup
argument_list|(
literal|"interpret"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pInterp
argument_list|)
expr_stmt|;
name|stackReset
argument_list|(
name|pVM
operator|->
name|rStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|fRestart
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|ip
operator|=
operator|&
name|pInterp
expr_stmt|;
name|pVM
operator|->
name|runningWord
operator|=
name|pInterp
expr_stmt|;
name|pVM
operator|->
name|state
operator|=
name|INTERPRET
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|cp
operator|=
name|NULL
expr_stmt|;
name|pVM
operator|->
name|tib
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|pVM
operator|->
name|pad
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pVM
operator|->
name|sourceID
operator|.
name|i
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m R e s e t  **  **************************************************************************/
end_comment

begin_function
name|void
name|vmReset
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|vmQuit
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|stackReset
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|base
operator|=
literal|10
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m S e t T e x t O u t ** Binds the specified output callback to the vm. If you pass NULL, ** binds the default output function (ficlTextOut) **************************************************************************/
end_comment

begin_function
name|void
name|vmSetTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|OUTFUNC
name|textOut
parameter_list|)
block|{
if|if
condition|(
name|textOut
condition|)
name|pVM
operator|->
name|textOut
operator|=
name|textOut
expr_stmt|;
else|else
name|pVM
operator|->
name|textOut
operator|=
name|ficlTextOut
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m T e x t O u t ** Feeds text to the vm's output callback **************************************************************************/
end_comment

begin_function
name|void
name|vmTextOut
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|text
parameter_list|,
name|int
name|fNewline
parameter_list|)
block|{
name|assert
argument_list|(
name|pVM
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pVM
operator|->
name|textOut
argument_list|)
expr_stmt|;
call|(
name|pVM
operator|->
name|textOut
call|)
argument_list|(
name|pVM
argument_list|,
name|text
argument_list|,
name|fNewline
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         v m T h r o w **  **************************************************************************/
end_comment

begin_function
name|void
name|vmThrow
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|except
parameter_list|)
block|{
name|longjmp
argument_list|(
operator|*
operator|(
name|pVM
operator|->
name|pState
operator|)
argument_list|,
name|except
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vmThrowErr
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|va
decl_stmt|;
name|va_start
argument_list|(
name|va
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
name|fmt
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
operator|*
operator|(
name|pVM
operator|->
name|pState
operator|)
argument_list|,
name|VM_ERREXIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d I s I m m e d i a t e **  **************************************************************************/
end_comment

begin_function
name|int
name|wordIsImmediate
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pFW
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|flags
operator|&
name|FW_IMMEDIATE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         w o r d I s C o m p i l e O n l y **  **************************************************************************/
end_comment

begin_function
name|int
name|wordIsCompileOnly
parameter_list|(
name|FICL_WORD
modifier|*
name|pFW
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pFW
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|pFW
operator|->
name|flags
operator|&
name|FW_COMPILE
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r r e v **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|strrev
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
comment|/* reverse a string in-place */
name|int
name|i
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|string
decl_stmt|;
comment|/* first char of string */
name|char
modifier|*
name|p2
init|=
name|string
operator|+
name|i
operator|-
literal|1
decl_stmt|;
comment|/* last non-NULL char of string */
name|char
name|c
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
while|while
condition|(
name|p1
operator|<
name|p2
condition|)
block|{
name|c
operator|=
operator|*
name|p2
expr_stmt|;
operator|*
name|p2
operator|=
operator|*
name|p1
expr_stmt|;
operator|*
name|p1
operator|=
name|c
expr_stmt|;
name|p1
operator|++
expr_stmt|;
name|p2
operator|--
expr_stmt|;
block|}
block|}
return|return
name|string
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i g i t _ t o _ c h a r **  **************************************************************************/
end_comment

begin_function
name|char
name|digit_to_char
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
name|digits
index|[
name|value
index|]
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         l t o a **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|ltoa
parameter_list|(
name|INT32
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
block|{
comment|/* convert long to string, any base */
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
name|int
name|sign
init|=
operator|(
operator|(
name|radix
operator|==
literal|10
operator|)
operator|&&
operator|(
name|value
operator|<
literal|0
operator|)
operator|)
decl_stmt|;
name|UNSQR
name|result
decl_stmt|;
name|UNS64
name|v
decl_stmt|;
name|assert
argument_list|(
name|radix
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|radix
operator|<
literal|37
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
name|v
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|v
operator|.
name|lo
operator|=
operator|(
name|UNS32
operator|)
name|value
expr_stmt|;
while|while
condition|(
name|v
operator|.
name|lo
condition|)
block|{
name|result
operator|=
name|ficlLongDiv
argument_list|(
name|v
argument_list|,
operator|(
name|UNS32
operator|)
name|radix
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
name|result
operator|.
name|rem
index|]
expr_stmt|;
name|v
operator|.
name|lo
operator|=
name|result
operator|.
name|quot
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sign
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'-'
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strrev
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         u l t o a **  **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|ultoa
parameter_list|(
name|UNS32
name|value
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|int
name|radix
parameter_list|)
block|{
comment|/* convert long to string, any base */
name|char
modifier|*
name|cp
init|=
name|string
decl_stmt|;
name|UNS64
name|ud
decl_stmt|;
name|UNSQR
name|result
decl_stmt|;
name|assert
argument_list|(
name|radix
operator|>
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|radix
operator|<
literal|37
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'0'
expr_stmt|;
else|else
block|{
name|ud
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|value
expr_stmt|;
name|result
operator|.
name|quot
operator|=
name|value
expr_stmt|;
while|while
condition|(
name|ud
operator|.
name|lo
condition|)
block|{
name|result
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|UNS32
operator|)
name|radix
argument_list|)
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|result
operator|.
name|quot
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
name|result
operator|.
name|rem
index|]
expr_stmt|;
block|}
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
name|strrev
argument_list|(
name|string
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         c a s e F o l d ** Case folds a NULL terminated string in place. All characters ** get converted to lower case. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|caseFold
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|char
modifier|*
name|oldCp
init|=
name|cp
decl_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
name|tolower
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
block|}
return|return
name|oldCp
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s t r i n c m p **  **************************************************************************/
end_comment

begin_function
name|int
name|strincmp
parameter_list|(
name|char
modifier|*
name|cp1
parameter_list|,
name|char
modifier|*
name|cp2
parameter_list|,
name|FICL_COUNT
name|count
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|char
name|c1
decl_stmt|,
name|c2
decl_stmt|;
for|for
control|(
name|c1
operator|=
operator|*
name|cp1
operator|,
name|c2
operator|=
operator|*
name|cp2
init|;
operator|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
name|count
operator|&&
name|c1
operator|&&
name|c2
operator|)
condition|;
name|c1
operator|=
operator|*
operator|++
name|cp1
operator|,
name|c2
operator|=
operator|*
operator|++
name|cp2
operator|,
name|count
operator|--
control|)
block|{
name|i
operator|=
name|tolower
argument_list|(
name|c1
argument_list|)
operator|-
name|tolower
argument_list|(
name|c2
argument_list|)
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         s k i p S p a c e ** Given a string pointer, returns a pointer to the first non-space ** char of the string, or to the NULL terminator if no such char found. **************************************************************************/
end_comment

begin_function
name|char
modifier|*
name|skipSpace
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|assert
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
return|return
name|cp
return|;
block|}
end_function

end_unit

