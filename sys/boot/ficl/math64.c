begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** m a t h 6 4 . c ** Forth Inspired Command Language - 64 bit math support routines ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 25 January 1998 ** *******************************************************************/
end_comment

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_include
include|#
directive|include
file|"math64.h"
end_include

begin_comment
comment|/**************************************************************************                         m 6 4 A b s ** Returns the absolute value of an INT64 **************************************************************************/
end_comment

begin_function
name|INT64
name|m64Abs
parameter_list|(
name|INT64
name|x
parameter_list|)
block|{
if|if
condition|(
name|m64IsNegative
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|m64Negate
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 F l o o r e d D i v I **  ** FROM THE FORTH ANS... ** Floored division is integer division in which the remainder carries ** the sign of the divisor or is zero, and the quotient is rounded to ** its arithmetic floor. Symmetric division is integer division in which ** the remainder carries the sign of the dividend or is zero and the ** quotient is the mathematical quotient rounded towards zero or ** truncated. Examples of each are shown in tables 3.3 and 3.4.  **  ** Table 3.3 - Floored Division Example ** Dividend        Divisor Remainder       Quotient ** --------        ------- ---------       -------- **  10                7       3                1 ** -10                7       4               -2 **  10               -7      -4               -2 ** -10               -7      -3                1 **  **  ** Table 3.4 - Symmetric Division Example ** Dividend        Divisor Remainder       Quotient ** --------        ------- ---------       -------- **  10                7       3                1 ** -10                7      -3               -1 **  10               -7       3               -1 ** -10               -7      -3                1 **************************************************************************/
end_comment

begin_function
name|INTQR
name|m64FlooredDivI
parameter_list|(
name|INT64
name|num
parameter_list|,
name|INT32
name|den
parameter_list|)
block|{
name|INTQR
name|qr
decl_stmt|;
name|UNSQR
name|uqr
decl_stmt|;
name|int
name|signRem
init|=
literal|1
decl_stmt|;
name|int
name|signQuot
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|m64IsNegative
argument_list|(
name|num
argument_list|)
condition|)
block|{
name|num
operator|=
name|m64Negate
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
if|if
condition|(
name|den
operator|<
literal|0
condition|)
block|{
name|den
operator|=
operator|-
name|den
expr_stmt|;
name|signRem
operator|=
operator|-
name|signRem
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
name|uqr
operator|=
name|ficlLongDiv
argument_list|(
name|m64CastIU
argument_list|(
name|num
argument_list|)
argument_list|,
operator|(
name|UNS32
operator|)
name|den
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64CastQRUI
argument_list|(
name|uqr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signQuot
operator|<
literal|0
condition|)
block|{
name|qr
operator|.
name|quot
operator|=
operator|-
name|qr
operator|.
name|quot
expr_stmt|;
if|if
condition|(
name|qr
operator|.
name|rem
operator|!=
literal|0
condition|)
block|{
name|qr
operator|.
name|quot
operator|--
expr_stmt|;
name|qr
operator|.
name|rem
operator|=
name|den
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signRem
operator|<
literal|0
condition|)
name|qr
operator|.
name|rem
operator|=
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
return|return
name|qr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 I s N e g a t i v e ** Returns TRUE if the specified INT64 has its sign bit set. **************************************************************************/
end_comment

begin_function
name|int
name|m64IsNegative
parameter_list|(
name|INT64
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|.
name|hi
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 M a c ** Mixed precision multiply and accumulate primitive for number building. ** Multiplies UNS64 u by UNS32 mul and adds UNS32 add. Mul is typically ** the numeric base, and add represents a digit to be appended to the  ** growing number.  ** Returns the result of the operation **************************************************************************/
end_comment

begin_function
name|UNS64
name|m64Mac
parameter_list|(
name|UNS64
name|u
parameter_list|,
name|UNS32
name|mul
parameter_list|,
name|UNS32
name|add
parameter_list|)
block|{
name|UNS64
name|resultLo
init|=
name|ficlLongMul
argument_list|(
name|u
operator|.
name|lo
argument_list|,
name|mul
argument_list|)
decl_stmt|;
name|UNS64
name|resultHi
init|=
name|ficlLongMul
argument_list|(
name|u
operator|.
name|hi
argument_list|,
name|mul
argument_list|)
decl_stmt|;
name|resultLo
operator|.
name|hi
operator|+=
name|resultHi
operator|.
name|lo
expr_stmt|;
name|resultHi
operator|.
name|lo
operator|=
name|resultLo
operator|.
name|lo
operator|+
name|add
expr_stmt|;
if|if
condition|(
name|resultHi
operator|.
name|lo
operator|<
name|resultLo
operator|.
name|lo
condition|)
name|resultLo
operator|.
name|hi
operator|++
expr_stmt|;
name|resultLo
operator|.
name|lo
operator|=
name|resultHi
operator|.
name|lo
expr_stmt|;
return|return
name|resultLo
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 M u l I ** Multiplies a pair of INT32s and returns an INT64 result. **************************************************************************/
end_comment

begin_function
name|INT64
name|m64MulI
parameter_list|(
name|INT32
name|x
parameter_list|,
name|INT32
name|y
parameter_list|)
block|{
name|UNS64
name|prod
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
name|prod
operator|=
name|ficlLongMul
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
return|return
name|m64CastUI
argument_list|(
name|prod
argument_list|)
return|;
else|else
return|return
name|m64Negate
argument_list|(
name|m64CastUI
argument_list|(
name|prod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 N e g a t e ** Negates an INT64 by complementing and incrementing. **************************************************************************/
end_comment

begin_function
name|INT64
name|m64Negate
parameter_list|(
name|INT64
name|x
parameter_list|)
block|{
name|x
operator|.
name|hi
operator|=
operator|~
name|x
operator|.
name|hi
expr_stmt|;
name|x
operator|.
name|lo
operator|=
operator|~
name|x
operator|.
name|lo
expr_stmt|;
name|x
operator|.
name|lo
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|lo
operator|==
literal|0
condition|)
name|x
operator|.
name|hi
operator|++
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 P u s h ** Push an INT64 onto the specified stack in the order required ** by ANS Forth (most significant cell on top) ** These should probably be macros... **************************************************************************/
end_comment

begin_function
name|void
name|i64Push
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|INT64
name|i64
parameter_list|)
block|{
name|stackPushINT32
argument_list|(
name|pStack
argument_list|,
name|i64
operator|.
name|lo
argument_list|)
expr_stmt|;
name|stackPushINT32
argument_list|(
name|pStack
argument_list|,
name|i64
operator|.
name|hi
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|u64Push
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|UNS64
name|u64
parameter_list|)
block|{
name|stackPushINT32
argument_list|(
name|pStack
argument_list|,
name|u64
operator|.
name|lo
argument_list|)
expr_stmt|;
name|stackPushINT32
argument_list|(
name|pStack
argument_list|,
name|u64
operator|.
name|hi
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 P o p ** Pops an INT64 off the stack in the order required by ANS Forth ** (most significant cell on top) ** These should probably be macros... **************************************************************************/
end_comment

begin_function
name|INT64
name|i64Pop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|INT64
name|ret
decl_stmt|;
name|ret
operator|.
name|hi
operator|=
name|stackPopINT32
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
name|ret
operator|.
name|lo
operator|=
name|stackPopINT32
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|UNS64
name|u64Pop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|UNS64
name|ret
decl_stmt|;
name|ret
operator|.
name|hi
operator|=
name|stackPopINT32
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
name|ret
operator|.
name|lo
operator|=
name|stackPopINT32
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 S y m m e t r i c D i v ** Divide an INT64 by an INT32 and return an INT32 quotient and an INT32 ** remainder. The absolute values of quotient and remainder are not ** affected by the signs of the numerator and denominator (the operation ** is symmetric on the number line) **************************************************************************/
end_comment

begin_function
name|INTQR
name|m64SymmetricDivI
parameter_list|(
name|INT64
name|num
parameter_list|,
name|INT32
name|den
parameter_list|)
block|{
name|INTQR
name|qr
decl_stmt|;
name|UNSQR
name|uqr
decl_stmt|;
name|int
name|signRem
init|=
literal|1
decl_stmt|;
name|int
name|signQuot
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|m64IsNegative
argument_list|(
name|num
argument_list|)
condition|)
block|{
name|num
operator|=
name|m64Negate
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|signRem
operator|=
operator|-
name|signRem
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
if|if
condition|(
name|den
operator|<
literal|0
condition|)
block|{
name|den
operator|=
operator|-
name|den
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
name|uqr
operator|=
name|ficlLongDiv
argument_list|(
name|m64CastIU
argument_list|(
name|num
argument_list|)
argument_list|,
operator|(
name|UNS32
operator|)
name|den
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64CastQRUI
argument_list|(
name|uqr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signRem
operator|<
literal|0
condition|)
name|qr
operator|.
name|rem
operator|=
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
if|if
condition|(
name|signQuot
operator|<
literal|0
condition|)
name|qr
operator|.
name|quot
operator|=
operator|-
name|qr
operator|.
name|quot
expr_stmt|;
return|return
name|qr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 U M o d ** Divides an UNS64 by base (an UNS16) and returns an UNS16 remainder. ** Writes the quotient back to the original UNS64 as a side effect. ** This operation is typically used to convert an UNS64 to a text string ** in any base. See words.c:numberSignS, for example. ** Mechanics: performs 4 ficlLongDivs, each of which produces 16 bits ** of the quotient. C does not provide a way to divide an UNS32 by an ** UNS16 and get an UNS32 quotient (ldiv is closest, but it's signed, ** unfortunately), so I've used ficlLongDiv. **************************************************************************/
end_comment

begin_function
name|UNS16
name|m64UMod
parameter_list|(
name|UNS64
modifier|*
name|pUD
parameter_list|,
name|UNS16
name|base
parameter_list|)
block|{
name|UNS64
name|ud
decl_stmt|;
name|UNSQR
name|qr
decl_stmt|;
name|UNS64
name|result
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|result
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|pUD
operator|->
name|hi
operator|>>
literal|16
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|UNS32
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|hi
operator|=
name|qr
operator|.
name|quot
operator|<<
literal|16
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
literal|16
operator|)
operator||
operator|(
name|pUD
operator|->
name|hi
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|UNS32
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|hi
operator||=
name|qr
operator|.
name|quot
operator|&
literal|0x0000ffff
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
literal|16
operator|)
operator||
operator|(
name|pUD
operator|->
name|lo
operator|>>
literal|16
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|UNS32
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|lo
operator|=
name|qr
operator|.
name|quot
operator|<<
literal|16
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
literal|16
operator|)
operator||
operator|(
name|pUD
operator|->
name|lo
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|UNS32
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|lo
operator||=
name|qr
operator|.
name|quot
operator|&
literal|0x0000ffff
expr_stmt|;
operator|*
name|pUD
operator|=
name|result
expr_stmt|;
return|return
call|(
name|UNS16
call|)
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
return|;
block|}
end_function

end_unit

