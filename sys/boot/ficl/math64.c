begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** m a t h 6 4 . c ** Forth Inspired Command Language - 64 bit math support routines ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 25 January 1998 ** Rev 2.03: Support for 128 bit DP math. This file really ouught to ** be renamed! *******************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_include
include|#
directive|include
file|"math64.h"
end_include

begin_comment
comment|/**************************************************************************                         m 6 4 A b s ** Returns the absolute value of an DPINT **************************************************************************/
end_comment

begin_function
name|DPINT
name|m64Abs
parameter_list|(
name|DPINT
name|x
parameter_list|)
block|{
if|if
condition|(
name|m64IsNegative
argument_list|(
name|x
argument_list|)
condition|)
name|x
operator|=
name|m64Negate
argument_list|(
name|x
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 F l o o r e d D i v I **  ** FROM THE FORTH ANS... ** Floored division is integer division in which the remainder carries ** the sign of the divisor or is zero, and the quotient is rounded to ** its arithmetic floor. Symmetric division is integer division in which ** the remainder carries the sign of the dividend or is zero and the ** quotient is the mathematical quotient rounded towards zero or ** truncated. Examples of each are shown in tables 3.3 and 3.4.  **  ** Table 3.3 - Floored Division Example ** Dividend        Divisor Remainder       Quotient ** --------        ------- ---------       -------- **  10                7       3                1 ** -10                7       4               -2 **  10               -7      -4               -2 ** -10               -7      -3                1 **  **  ** Table 3.4 - Symmetric Division Example ** Dividend        Divisor Remainder       Quotient ** --------        ------- ---------       -------- **  10                7       3                1 ** -10                7      -3               -1 **  10               -7       3               -1 ** -10               -7      -3                1 **************************************************************************/
end_comment

begin_function
name|INTQR
name|m64FlooredDivI
parameter_list|(
name|DPINT
name|num
parameter_list|,
name|FICL_INT
name|den
parameter_list|)
block|{
name|INTQR
name|qr
decl_stmt|;
name|UNSQR
name|uqr
decl_stmt|;
name|int
name|signRem
init|=
literal|1
decl_stmt|;
name|int
name|signQuot
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|m64IsNegative
argument_list|(
name|num
argument_list|)
condition|)
block|{
name|num
operator|=
name|m64Negate
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
if|if
condition|(
name|den
operator|<
literal|0
condition|)
block|{
name|den
operator|=
operator|-
name|den
expr_stmt|;
name|signRem
operator|=
operator|-
name|signRem
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
name|uqr
operator|=
name|ficlLongDiv
argument_list|(
name|m64CastIU
argument_list|(
name|num
argument_list|)
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|den
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64CastQRUI
argument_list|(
name|uqr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signQuot
operator|<
literal|0
condition|)
block|{
name|qr
operator|.
name|quot
operator|=
operator|-
name|qr
operator|.
name|quot
expr_stmt|;
if|if
condition|(
name|qr
operator|.
name|rem
operator|!=
literal|0
condition|)
block|{
name|qr
operator|.
name|quot
operator|--
expr_stmt|;
name|qr
operator|.
name|rem
operator|=
name|den
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
block|}
block|}
if|if
condition|(
name|signRem
operator|<
literal|0
condition|)
name|qr
operator|.
name|rem
operator|=
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
return|return
name|qr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 I s N e g a t i v e ** Returns TRUE if the specified DPINT has its sign bit set. **************************************************************************/
end_comment

begin_function
name|int
name|m64IsNegative
parameter_list|(
name|DPINT
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|.
name|hi
operator|<
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 M a c ** Mixed precision multiply and accumulate primitive for number building. ** Multiplies DPUNS u by FICL_UNS mul and adds FICL_UNS add. Mul is typically ** the numeric base, and add represents a digit to be appended to the  ** growing number.  ** Returns the result of the operation **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64Mac
parameter_list|(
name|DPUNS
name|u
parameter_list|,
name|FICL_UNS
name|mul
parameter_list|,
name|FICL_UNS
name|add
parameter_list|)
block|{
name|DPUNS
name|resultLo
init|=
name|ficlLongMul
argument_list|(
name|u
operator|.
name|lo
argument_list|,
name|mul
argument_list|)
decl_stmt|;
name|DPUNS
name|resultHi
init|=
name|ficlLongMul
argument_list|(
name|u
operator|.
name|hi
argument_list|,
name|mul
argument_list|)
decl_stmt|;
name|resultLo
operator|.
name|hi
operator|+=
name|resultHi
operator|.
name|lo
expr_stmt|;
name|resultHi
operator|.
name|lo
operator|=
name|resultLo
operator|.
name|lo
operator|+
name|add
expr_stmt|;
if|if
condition|(
name|resultHi
operator|.
name|lo
operator|<
name|resultLo
operator|.
name|lo
condition|)
name|resultLo
operator|.
name|hi
operator|++
expr_stmt|;
name|resultLo
operator|.
name|lo
operator|=
name|resultHi
operator|.
name|lo
expr_stmt|;
return|return
name|resultLo
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 M u l I ** Multiplies a pair of FICL_INTs and returns an DPINT result. **************************************************************************/
end_comment

begin_function
name|DPINT
name|m64MulI
parameter_list|(
name|FICL_INT
name|x
parameter_list|,
name|FICL_INT
name|y
parameter_list|)
block|{
name|DPUNS
name|prod
decl_stmt|;
name|int
name|sign
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
name|x
operator|=
operator|-
name|x
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
name|sign
expr_stmt|;
name|y
operator|=
operator|-
name|y
expr_stmt|;
block|}
name|prod
operator|=
name|ficlLongMul
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign
operator|>
literal|0
condition|)
return|return
name|m64CastUI
argument_list|(
name|prod
argument_list|)
return|;
else|else
return|return
name|m64Negate
argument_list|(
name|m64CastUI
argument_list|(
name|prod
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 N e g a t e ** Negates an DPINT by complementing and incrementing. **************************************************************************/
end_comment

begin_function
name|DPINT
name|m64Negate
parameter_list|(
name|DPINT
name|x
parameter_list|)
block|{
name|x
operator|.
name|hi
operator|=
operator|~
name|x
operator|.
name|hi
expr_stmt|;
name|x
operator|.
name|lo
operator|=
operator|~
name|x
operator|.
name|lo
expr_stmt|;
name|x
operator|.
name|lo
operator|++
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|lo
operator|==
literal|0
condition|)
name|x
operator|.
name|hi
operator|++
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 P u s h ** Push an DPINT onto the specified stack in the order required ** by ANS Forth (most significant cell on top) ** These should probably be macros... **************************************************************************/
end_comment

begin_function
name|void
name|i64Push
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|DPINT
name|i64
parameter_list|)
block|{
name|stackPushINT
argument_list|(
name|pStack
argument_list|,
name|i64
operator|.
name|lo
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pStack
argument_list|,
name|i64
operator|.
name|hi
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|u64Push
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|DPUNS
name|u64
parameter_list|)
block|{
name|stackPushINT
argument_list|(
name|pStack
argument_list|,
name|u64
operator|.
name|lo
argument_list|)
expr_stmt|;
name|stackPushINT
argument_list|(
name|pStack
argument_list|,
name|u64
operator|.
name|hi
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 P o p ** Pops an DPINT off the stack in the order required by ANS Forth ** (most significant cell on top) ** These should probably be macros... **************************************************************************/
end_comment

begin_function
name|DPINT
name|i64Pop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|DPINT
name|ret
decl_stmt|;
name|ret
operator|.
name|hi
operator|=
name|stackPopINT
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
name|ret
operator|.
name|lo
operator|=
name|stackPopINT
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|DPUNS
name|u64Pop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|DPUNS
name|ret
decl_stmt|;
name|ret
operator|.
name|hi
operator|=
name|stackPopINT
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
name|ret
operator|.
name|lo
operator|=
name|stackPopINT
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 S y m m e t r i c D i v ** Divide an DPINT by a FICL_INT and return a FICL_INT quotient and a ** FICL_INT remainder. The absolute values of quotient and remainder are not ** affected by the signs of the numerator and denominator (the operation ** is symmetric on the number line) **************************************************************************/
end_comment

begin_function
name|INTQR
name|m64SymmetricDivI
parameter_list|(
name|DPINT
name|num
parameter_list|,
name|FICL_INT
name|den
parameter_list|)
block|{
name|INTQR
name|qr
decl_stmt|;
name|UNSQR
name|uqr
decl_stmt|;
name|int
name|signRem
init|=
literal|1
decl_stmt|;
name|int
name|signQuot
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|m64IsNegative
argument_list|(
name|num
argument_list|)
condition|)
block|{
name|num
operator|=
name|m64Negate
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|signRem
operator|=
operator|-
name|signRem
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
if|if
condition|(
name|den
operator|<
literal|0
condition|)
block|{
name|den
operator|=
operator|-
name|den
expr_stmt|;
name|signQuot
operator|=
operator|-
name|signQuot
expr_stmt|;
block|}
name|uqr
operator|=
name|ficlLongDiv
argument_list|(
name|m64CastIU
argument_list|(
name|num
argument_list|)
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|den
argument_list|)
expr_stmt|;
name|qr
operator|=
name|m64CastQRUI
argument_list|(
name|uqr
argument_list|)
expr_stmt|;
if|if
condition|(
name|signRem
operator|<
literal|0
condition|)
name|qr
operator|.
name|rem
operator|=
operator|-
name|qr
operator|.
name|rem
expr_stmt|;
if|if
condition|(
name|signQuot
operator|<
literal|0
condition|)
name|qr
operator|.
name|quot
operator|=
operator|-
name|qr
operator|.
name|quot
expr_stmt|;
return|return
name|qr
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 U M o d ** Divides a DPUNS by base (an UNS16) and returns an UNS16 remainder. ** Writes the quotient back to the original DPUNS as a side effect. ** This operation is typically used to convert an DPUNS to a text string ** in any base. See words.c:numberSignS, for example. ** Mechanics: performs 4 ficlLongDivs, each of which produces 16 bits ** of the quotient. C does not provide a way to divide an FICL_UNS by an ** UNS16 and get an FICL_UNS quotient (ldiv is closest, but it's signed, ** unfortunately), so I've used ficlLongDiv. **************************************************************************/
end_comment

begin_if
if|#
directive|if
operator|(
name|BITS_PER_CELL
operator|==
literal|32
operator|)
end_if

begin_define
define|#
directive|define
name|UMOD_SHIFT
value|16
end_define

begin_define
define|#
directive|define
name|UMOD_MASK
value|0x0000ffff
end_define

begin_elif
elif|#
directive|elif
operator|(
name|BITS_PER_CELL
operator|==
literal|64
operator|)
end_elif

begin_define
define|#
directive|define
name|UMOD_SHIFT
value|32
end_define

begin_define
define|#
directive|define
name|UMOD_MASK
value|0x00000000ffffffff
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|UNS16
name|m64UMod
parameter_list|(
name|DPUNS
modifier|*
name|pUD
parameter_list|,
name|UNS16
name|base
parameter_list|)
block|{
name|DPUNS
name|ud
decl_stmt|;
name|UNSQR
name|qr
decl_stmt|;
name|DPUNS
name|result
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|result
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
name|pUD
operator|->
name|hi
operator|>>
name|UMOD_SHIFT
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|hi
operator|=
name|qr
operator|.
name|quot
operator|<<
name|UMOD_SHIFT
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
name|UMOD_SHIFT
operator|)
operator||
operator|(
name|pUD
operator|->
name|hi
operator|&
name|UMOD_MASK
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|hi
operator||=
name|qr
operator|.
name|quot
operator|&
name|UMOD_MASK
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
name|UMOD_SHIFT
operator|)
operator||
operator|(
name|pUD
operator|->
name|lo
operator|>>
name|UMOD_SHIFT
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|lo
operator|=
name|qr
operator|.
name|quot
operator|<<
name|UMOD_SHIFT
expr_stmt|;
name|ud
operator|.
name|lo
operator|=
operator|(
name|qr
operator|.
name|rem
operator|<<
name|UMOD_SHIFT
operator|)
operator||
operator|(
name|pUD
operator|->
name|lo
operator|&
name|UMOD_MASK
operator|)
expr_stmt|;
name|qr
operator|=
name|ficlLongDiv
argument_list|(
name|ud
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|base
argument_list|)
expr_stmt|;
name|result
operator|.
name|lo
operator||=
name|qr
operator|.
name|quot
operator|&
name|UMOD_MASK
expr_stmt|;
operator|*
name|pUD
operator|=
name|result
expr_stmt|;
return|return
call|(
name|UNS16
call|)
argument_list|(
name|qr
operator|.
name|rem
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/************************************************************************** ** Contributed by ** Michael A. Gauland	gaulandm@mdhost.cse.tek.com   **************************************************************************/
end_comment

begin_if
if|#
directive|if
name|PORTABLE_LONGMULDIV
operator|!=
literal|0
end_if

begin_comment
comment|/**************************************************************************                         m 6 4 A d d **  **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64Add
parameter_list|(
name|DPUNS
name|x
parameter_list|,
name|DPUNS
name|y
parameter_list|)
block|{
name|DPUNS
name|result
decl_stmt|;
name|int
name|carry
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|x
operator|.
name|hi
operator|+
name|y
operator|.
name|hi
expr_stmt|;
name|result
operator|.
name|lo
operator|=
name|x
operator|.
name|lo
operator|+
name|y
operator|.
name|lo
expr_stmt|;
name|carry
operator|=
operator|(
operator|(
name|x
operator|.
name|lo
operator||
name|y
operator|.
name|lo
operator|)
operator|&
name|CELL_HI_BIT
operator|)
operator|&&
operator|!
operator|(
name|result
operator|.
name|lo
operator|&
name|CELL_HI_BIT
operator|)
expr_stmt|;
name|carry
operator||=
operator|(
operator|(
name|x
operator|.
name|lo
operator|&
name|y
operator|.
name|lo
operator|)
operator|&
name|CELL_HI_BIT
operator|)
expr_stmt|;
if|if
condition|(
name|carry
condition|)
block|{
name|result
operator|.
name|hi
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 S u b **  **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64Sub
parameter_list|(
name|DPUNS
name|x
parameter_list|,
name|DPUNS
name|y
parameter_list|)
block|{
name|DPUNS
name|result
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|x
operator|.
name|hi
operator|-
name|y
operator|.
name|hi
expr_stmt|;
name|result
operator|.
name|lo
operator|=
name|x
operator|.
name|lo
operator|-
name|y
operator|.
name|lo
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|lo
operator|<
name|y
operator|.
name|lo
condition|)
block|{
name|result
operator|.
name|hi
operator|--
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 A S L ** 64 bit left shift **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64ASL
parameter_list|(
name|DPUNS
name|x
parameter_list|)
block|{
name|DPUNS
name|result
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|x
operator|.
name|hi
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|lo
operator|&
name|CELL_HI_BIT
condition|)
block|{
name|result
operator|.
name|hi
operator|++
expr_stmt|;
block|}
name|result
operator|.
name|lo
operator|=
name|x
operator|.
name|lo
operator|<<
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 A S R ** 64 bit right shift (unsigned - no sign extend) **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64ASR
parameter_list|(
name|DPUNS
name|x
parameter_list|)
block|{
name|DPUNS
name|result
decl_stmt|;
name|result
operator|.
name|lo
operator|=
name|x
operator|.
name|lo
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|x
operator|.
name|hi
operator|&
literal|1
condition|)
block|{
name|result
operator|.
name|lo
operator||=
name|CELL_HI_BIT
expr_stmt|;
block|}
name|result
operator|.
name|hi
operator|=
name|x
operator|.
name|hi
operator|>>
literal|1
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 O r ** 64 bit bitwise OR **************************************************************************/
end_comment

begin_function
name|DPUNS
name|m64Or
parameter_list|(
name|DPUNS
name|x
parameter_list|,
name|DPUNS
name|y
parameter_list|)
block|{
name|DPUNS
name|result
decl_stmt|;
name|result
operator|.
name|hi
operator|=
name|x
operator|.
name|hi
operator||
name|y
operator|.
name|hi
expr_stmt|;
name|result
operator|.
name|lo
operator|=
name|x
operator|.
name|lo
operator||
name|y
operator|.
name|lo
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         m 6 4 C o m p a r e ** Return -1 if x< y; 0 if x==y, and 1 if x> y. **************************************************************************/
end_comment

begin_function
name|int
name|m64Compare
parameter_list|(
name|DPUNS
name|x
parameter_list|,
name|DPUNS
name|y
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|x
operator|.
name|hi
operator|>
name|y
operator|.
name|hi
condition|)
block|{
name|result
operator|=
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|hi
operator|<
name|y
operator|.
name|hi
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* High parts are equal */
if|if
condition|(
name|x
operator|.
name|lo
operator|>
name|y
operator|.
name|lo
condition|)
block|{
name|result
operator|=
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|.
name|lo
operator|<
name|y
operator|.
name|lo
condition|)
block|{
name|result
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l L o n g M u l ** Portable versions of ficlLongMul and ficlLongDiv in C ** Contributed by: ** Michael A. Gauland	gaulandm@mdhost.cse.tek.com   **************************************************************************/
end_comment

begin_function
name|DPUNS
name|ficlLongMul
parameter_list|(
name|FICL_UNS
name|x
parameter_list|,
name|FICL_UNS
name|y
parameter_list|)
block|{
name|DPUNS
name|result
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|DPUNS
name|addend
decl_stmt|;
name|addend
operator|.
name|lo
operator|=
name|y
expr_stmt|;
name|addend
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
comment|/* No sign extension--arguments are unsigned */
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
block|{
name|result
operator|=
name|m64Add
argument_list|(
name|result
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
name|x
operator|>>=
literal|1
expr_stmt|;
name|addend
operator|=
name|m64ASL
argument_list|(
name|addend
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l L o n g D i v ** Portable versions of ficlLongMul and ficlLongDiv in C ** Contributed by: ** Michael A. Gauland	gaulandm@mdhost.cse.tek.com   **************************************************************************/
end_comment

begin_function
name|UNSQR
name|ficlLongDiv
parameter_list|(
name|DPUNS
name|q
parameter_list|,
name|FICL_UNS
name|y
parameter_list|)
block|{
name|UNSQR
name|result
decl_stmt|;
name|DPUNS
name|quotient
decl_stmt|;
name|DPUNS
name|subtrahend
decl_stmt|;
name|DPUNS
name|mask
decl_stmt|;
name|quotient
operator|.
name|lo
operator|=
literal|0
expr_stmt|;
name|quotient
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|subtrahend
operator|.
name|lo
operator|=
name|y
expr_stmt|;
name|subtrahend
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
name|mask
operator|.
name|lo
operator|=
literal|1
expr_stmt|;
name|mask
operator|.
name|hi
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|m64Compare
argument_list|(
name|subtrahend
argument_list|,
name|q
argument_list|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|subtrahend
operator|.
name|hi
operator|&
name|CELL_HI_BIT
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
name|m64ASL
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|subtrahend
operator|=
name|m64ASL
argument_list|(
name|subtrahend
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|mask
operator|.
name|lo
operator|!=
literal|0
operator|||
name|mask
operator|.
name|hi
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m64Compare
argument_list|(
name|subtrahend
argument_list|,
name|q
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|q
operator|=
name|m64Sub
argument_list|(
name|q
argument_list|,
name|subtrahend
argument_list|)
expr_stmt|;
name|quotient
operator|=
name|m64Or
argument_list|(
name|quotient
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
name|m64ASR
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|subtrahend
operator|=
name|m64ASR
argument_list|(
name|subtrahend
argument_list|)
expr_stmt|;
block|}
name|result
operator|.
name|quot
operator|=
name|quotient
operator|.
name|lo
expr_stmt|;
name|result
operator|.
name|rem
operator|=
name|q
operator|.
name|lo
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

