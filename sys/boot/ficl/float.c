begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** f l o a t . c ** Forth Inspired Command Language ** ANS Forth FLOAT word-set written in C ** Author: Guy Carver& John Sadler (john_sadler@alum.mit.edu) ** Created: Apr 2001 ** $Id: float.c,v 1.8 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_if
if|#
directive|if
name|FICL_WANT_FLOAT
end_if

begin_comment
comment|/******************************************************************* ** Do float addition r1 + r2. ** f+ ( r1 r2 -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fadd
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|f
operator|+=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float subtraction r1 - r2. ** f- ( r1 r2 -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fsub
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|f
operator|=
name|GETTOPF
argument_list|()
operator|.
name|f
operator|-
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float multiplication r1 * r2. ** f* ( r1 r2 -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fmul
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|f
operator|*=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float negation. ** fnegate ( r -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fnegate
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|-
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float division r1 / r2. ** f/ ( r1 r2 -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fdiv
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|f
operator|=
name|GETTOPF
argument_list|()
operator|.
name|f
operator|/
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float + integer r + n. ** f+i ( r n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Faddi
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|f
operator|+=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float - integer r - n. ** f-i ( r n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fsubi
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|f
operator|-=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float * integer r * n. ** f*i ( r n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fmuli
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|f
operator|*=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float / integer r / n. ** f/i ( r n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fdivi
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|f
operator|/=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do integer - float n - r. ** i-f ( n r -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|isubf
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|f
operator|-=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do integer / float n / r. ** i/f ( n r -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|idivf
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_FLOAT
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|(
name|FICL_FLOAT
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|f
operator|/=
name|GETTOPF
argument_list|()
operator|.
name|f
expr_stmt|;
name|SETTOPF
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do integer to float conversion. ** int>float ( n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|itof
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
operator|(
name|float
operator|)
name|POPINT
argument_list|()
expr_stmt|;
name|PUSHFLOAT
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float to integer conversion. ** float>int ( r -- n ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Ftoi
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_INT
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
operator|(
name|FICL_INT
operator|)
name|POPFLOAT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Floating point constant execution word. *******************************************************************/
end_comment

begin_function
name|void
name|FconstantParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_WORD
modifier|*
name|pFW
init|=
name|pVM
operator|->
name|runningWord
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHFLOAT
argument_list|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Create a floating point constant. ** fconstant ( r -"name"- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fconstant
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAppendWord2
argument_list|(
name|dp
argument_list|,
name|si
argument_list|,
name|FconstantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Display a float in decimal format. ** f. ( r -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"%#f "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Display a float in engineering format. ** fe. ( r -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|EDot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|f
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"%#e "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         d i s p l a y FS t a c k ** Display the parameter stack (code for "f.s") ** f.s ( -- ) **************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|displayFStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|d
init|=
name|stackDepth
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CELL
modifier|*
name|pCell
decl_stmt|;
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"F:"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
literal|0
condition|)
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
literal|"[0]"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|ltoa
argument_list|(
name|d
argument_list|,
operator|&
name|pVM
operator|->
name|pad
index|[
literal|1
index|]
argument_list|,
name|pVM
operator|->
name|base
argument_list|)
expr_stmt|;
name|pVM
operator|->
name|pad
index|[
literal|0
index|]
operator|=
literal|'['
expr_stmt|;
name|strcat
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"] "
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pCell
operator|=
name|pVM
operator|->
name|fStack
operator|->
name|sp
operator|-
name|d
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|pVM
operator|->
name|pad
argument_list|,
literal|"%#f "
argument_list|,
operator|(
operator|*
name|pCell
operator|++
operator|)
operator|.
name|f
argument_list|)
expr_stmt|;
name|vmTextOut
argument_list|(
name|pVM
argument_list|,
name|pVM
operator|->
name|pad
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack depth. ** fdepth ( -- n ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fdepth
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
name|stackDepth
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
expr_stmt|;
name|PUSHINT
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack drop. ** fdrop ( r -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fdrop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DROPF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack 2drop. ** f2drop ( r r -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FtwoDrop
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DROPF
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack dup. ** fdup ( r -- r r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fdup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack 2dup. ** f2dup ( r1 r2 -- r1 r2 r1 r2 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FtwoDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|PICKF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack over. ** fover ( r1 r2 -- r1 r2 r1 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fover
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack 2over. ** f2over ( r1 r2 r3 -- r1 r2 r3 r1 r2 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FtwoOver
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKF
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|PICKF
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack pick. ** fpick ( n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fpick
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
init|=
name|POP
argument_list|()
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
name|c
operator|.
name|i
operator|+
literal|1
argument_list|,
name|c
operator|.
name|i
operator|+
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKF
argument_list|(
name|c
operator|.
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack ?dup. ** f?dup ( r -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FquestionDup
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|GETTOPF
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|.
name|f
operator|!=
literal|0
condition|)
name|PICKF
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack roll. ** froll ( n -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Froll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|POP
argument_list|()
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack -roll. ** f-roll ( n -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FminusRoll
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|i
init|=
name|POP
argument_list|()
operator|.
name|i
decl_stmt|;
name|i
operator|=
operator|(
name|i
operator|>
literal|0
operator|)
condition|?
name|i
else|:
literal|0
expr_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack rot. ** frot ( r1 r2 r3  -- r2 r3 r1 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Frot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack -rot. ** f-rot ( r1 r2 r3  -- r3 r1 r2 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fminusrot
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack swap. ** fswap ( r1 r2 -- r2 r1 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fswap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float stack 2swap ** f2swap ( r1 r2 r3 r4  -- r3 r4 r1 r2 ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FtwoSwap
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ROLLF
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|ROLLF
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Get a floating point number from a variable. ** f@ ( n -- r ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Ffetch
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|POPPTR
argument_list|()
expr_stmt|;
name|PUSHFLOAT
argument_list|(
name|pCell
operator|->
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Store a floating point number into a variable. ** f! ( r n -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Fstore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|POPPTR
argument_list|()
expr_stmt|;
name|pCell
operator|->
name|f
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Add a floating point number to contents of a variable. ** f+! ( r n -- ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FplusStore
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pCell
operator|=
operator|(
name|CELL
operator|*
operator|)
name|POPPTR
argument_list|()
expr_stmt|;
name|pCell
operator|->
name|f
operator|+=
name|POPFLOAT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Floating point literal execution word. *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fliteralParen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PUSHFLOAT
argument_list|(
operator|*
operator|(
name|float
operator|*
operator|)
operator|(
name|pVM
operator|->
name|ip
operator|)
argument_list|)
expr_stmt|;
name|vmBranchRelative
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Compile a floating point literal. *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|fliteralIm
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|vmGetDict
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|FICL_WORD
modifier|*
name|pfLitParen
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
literal|"(fliteral)"
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pfLitParen
argument_list|)
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|stackPop
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float 0= comparison r = 0.0. ** f0= ( r -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FzeroEquals
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure something on float stack. */
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure room for result. */
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|POPFLOAT
argument_list|()
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float 0< comparison r< 0.0. ** f0< ( r -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FzeroLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure something on float stack. */
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure room for result. */
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|POPFLOAT
argument_list|()
operator|<
literal|0
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float 0> comparison r> 0.0. ** f0> ( r -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FzeroGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|.
name|i
operator|=
name|FICL_BOOL
argument_list|(
name|POPFLOAT
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
name|PUSH
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float = comparison r1 = r2. ** f= ( r1 r2 -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FisEqual
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|x
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|y
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|==
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float< comparison r1< r2. ** f< ( r1 r2 -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FisLess
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|x
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|<
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Do float> comparison r1> r2. ** f> ( r1 r2 -- T/F ) *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FisGreater
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|float
name|x
decl_stmt|,
name|y
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|y
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|x
operator|=
name|POPFLOAT
argument_list|()
expr_stmt|;
name|PUSHINT
argument_list|(
name|FICL_BOOL
argument_list|(
name|x
operator|>
name|y
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************* ** Move float to param stack (assumes they both fit in a single CELL) ** f>s  *******************************************************************/
end_comment

begin_function
specifier|static
name|void
name|FFrom
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ToF
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vmCheckStack
argument_list|(
name|pVM
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|stackPop
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
expr_stmt|;
name|stackPush
argument_list|(
name|pVM
operator|->
name|fStack
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**************************************************************************                      F l o a t P a r s e S t a t e ** Enum to determine the current segement of a floating point number ** being parsed. **************************************************************************/
end_comment

begin_define
define|#
directive|define
name|NUMISNEG
value|1
end_define

begin_define
define|#
directive|define
name|EXPISNEG
value|2
end_define

begin_typedef
typedef|typedef
enum|enum
name|_floatParseState
block|{
name|FPS_START
block|,
name|FPS_ININT
block|,
name|FPS_INMANT
block|,
name|FPS_STARTEXP
block|,
name|FPS_INEXP
block|}
name|FloatParseState
typedef|;
end_typedef

begin_comment
comment|/**************************************************************************                      f i c l P a r s e F l o a t N u m b e r ** pVM -- Virtual Machine pointer. ** si -- String to parse. ** Returns 1 if successful, 0 if not. **************************************************************************/
end_comment

begin_function
name|int
name|ficlParseFloatNumber
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|,
name|digit
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|FICL_COUNT
name|count
decl_stmt|;
name|float
name|power
decl_stmt|;
name|float
name|accum
init|=
literal|0.0f
decl_stmt|;
name|float
name|mant
init|=
literal|0.1f
decl_stmt|;
name|FICL_INT
name|exponent
init|=
literal|0
decl_stmt|;
name|char
name|flag
init|=
literal|0
decl_stmt|;
name|FloatParseState
name|estate
init|=
name|FPS_START
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
operator|>
literal|1
name|vmCheckFStack
argument_list|(
name|pVM
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*     ** floating point numbers only allowed in base 10      */
if|if
condition|(
name|pVM
operator|->
name|base
operator|!=
literal|10
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|=
name|SI_PTR
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
name|FICL_COUNT
operator|)
name|SI_COUNT
argument_list|(
name|si
argument_list|)
expr_stmt|;
comment|/* Loop through the string's characters. */
while|while
condition|(
operator|(
name|count
operator|--
operator|)
operator|&&
operator|(
operator|(
name|ch
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|estate
condition|)
block|{
comment|/* At start of the number so look for a sign. */
case|case
name|FPS_START
case|:
block|{
name|estate
operator|=
name|FPS_ININT
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|flag
operator||=
name|NUMISNEG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
break|break;
block|}
block|}
comment|/* Note!  Drop through to FPS_ININT */
comment|/*             **Converting integer part of number.             ** Only allow digits, decimal and 'E'.              */
case|case
name|FPS_ININT
case|:
block|{
if|if
condition|(
name|ch
operator|==
literal|'.'
condition|)
block|{
name|estate
operator|=
name|FPS_INMANT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'E'
operator|)
condition|)
block|{
name|estate
operator|=
name|FPS_STARTEXP
expr_stmt|;
block|}
else|else
block|{
name|digit
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|accum
operator|=
name|accum
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
block|}
break|break;
block|}
comment|/*             ** Processing the fraction part of number.             ** Only allow digits and 'E'              */
case|case
name|FPS_INMANT
case|:
block|{
if|if
condition|(
operator|(
name|ch
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'E'
operator|)
condition|)
block|{
name|estate
operator|=
name|FPS_STARTEXP
expr_stmt|;
block|}
else|else
block|{
name|digit
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|accum
operator|+=
name|digit
operator|*
name|mant
expr_stmt|;
name|mant
operator|*=
literal|0.1f
expr_stmt|;
block|}
break|break;
block|}
comment|/* Start processing the exponent part of number. */
comment|/* Look for sign. */
case|case
name|FPS_STARTEXP
case|:
block|{
name|estate
operator|=
name|FPS_INEXP
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|flag
operator||=
name|EXPISNEG
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
block|{
break|break;
block|}
block|}
comment|/* Note!  Drop through to FPS_INEXP */
comment|/*             ** Processing the exponent part of number.             ** Only allow digits.              */
case|case
name|FPS_INEXP
case|:
block|{
name|digit
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|ch
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|digit
operator|>
literal|9
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|exponent
operator|=
name|exponent
operator|*
literal|10
operator|+
name|digit
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If parser never made it to the exponent this is not a float. */
if|if
condition|(
name|estate
operator|<
name|FPS_STARTEXP
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Set the sign of the number. */
if|if
condition|(
name|flag
operator|&
name|NUMISNEG
condition|)
name|accum
operator|=
operator|-
name|accum
expr_stmt|;
comment|/* If exponent is not 0 then adjust number by it. */
if|if
condition|(
name|exponent
operator|!=
literal|0
condition|)
block|{
comment|/* Determine if exponent is negative. */
if|if
condition|(
name|flag
operator|&
name|EXPISNEG
condition|)
block|{
name|exponent
operator|=
operator|-
name|exponent
expr_stmt|;
block|}
comment|/* power = 10^x */
name|power
operator|=
operator|(
name|float
operator|)
name|pow
argument_list|(
literal|10.0
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
name|accum
operator|*=
name|power
expr_stmt|;
block|}
name|PUSHFLOAT
argument_list|(
name|accum
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FICL_WANT_FLOAT */
end_comment

begin_comment
comment|/************************************************************************** ** Add float words to a system's dictionary. ** pSys -- Pointer to the FICL sytem to add float words to. **************************************************************************/
end_comment

begin_function
name|void
name|ficlCompileFloat
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|assert
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|#
directive|if
name|FICL_WANT_FLOAT
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|">float"
argument_list|,
name|ToF
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/* d>f */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f!"
argument_list|,
name|Fstore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f*"
argument_list|,
name|Fmul
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f+"
argument_list|,
name|Fadd
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f-"
argument_list|,
name|Fsub
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f/"
argument_list|,
name|Fdiv
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f0<"
argument_list|,
name|FzeroLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f0="
argument_list|,
name|FzeroEquals
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f<"
argument_list|,
name|FisLess
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*      f>d   */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f@"
argument_list|,
name|Ffetch
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*      falign      faligned   */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fconstant"
argument_list|,
name|Fconstant
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fdepth"
argument_list|,
name|Fdepth
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fdrop"
argument_list|,
name|Fdrop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fdup"
argument_list|,
name|Fdup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fliteral"
argument_list|,
name|fliteralIm
argument_list|,
name|FW_IMMEDIATE
argument_list|)
expr_stmt|;
comment|/*     float+     floats     floor     fmax     fmin */
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f?dup"
argument_list|,
name|FquestionDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f="
argument_list|,
name|FisEqual
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f>"
argument_list|,
name|FisGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f0>"
argument_list|,
name|FzeroGreater
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f2drop"
argument_list|,
name|FtwoDrop
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f2dup"
argument_list|,
name|FtwoDup
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f2over"
argument_list|,
name|FtwoOver
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f2swap"
argument_list|,
name|FtwoSwap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f+!"
argument_list|,
name|FplusStore
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f+i"
argument_list|,
name|Faddi
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f-i"
argument_list|,
name|Fsubi
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f*i"
argument_list|,
name|Fmuli
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f/i"
argument_list|,
name|Fdivi
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"int>float"
argument_list|,
name|itof
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"float>int"
argument_list|,
name|Ftoi
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f."
argument_list|,
name|FDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f.s"
argument_list|,
name|displayFStack
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fe."
argument_list|,
name|EDot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fover"
argument_list|,
name|Fover
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fnegate"
argument_list|,
name|Fnegate
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fpick"
argument_list|,
name|Fpick
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"froll"
argument_list|,
name|Froll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"frot"
argument_list|,
name|Frot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"fswap"
argument_list|,
name|Fswap
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"i-f"
argument_list|,
name|isubf
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"i/f"
argument_list|,
name|idivf
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"float>"
argument_list|,
name|FFrom
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f-roll"
argument_list|,
name|FminusRoll
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"f-rot"
argument_list|,
name|Fminusrot
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"(fliteral)"
argument_list|,
name|fliteralParen
argument_list|,
name|FW_COMPILE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"floating"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
comment|/* not all required words are present */
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"floating-ext"
argument_list|,
name|FICL_FALSE
argument_list|)
expr_stmt|;
name|ficlSetEnv
argument_list|(
name|pSys
argument_list|,
literal|"floating-stack"
argument_list|,
name|FICL_DEFAULT_STACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

end_unit

