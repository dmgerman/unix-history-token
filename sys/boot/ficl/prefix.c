begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** p r e f i x . c ** Forth Inspired Command Language ** Parser extensions for Ficl ** Authors: Larry Hastings& John Sadler (john_sadler@alum.mit.edu) ** Created: April 2001 ** $Id: prefix.c,v 1.6 2001/12/05 07:21:34 jsadler Exp $ *******************************************************************/
end_comment

begin_comment
comment|/* ** Copyright (c) 1997-2001 John Sadler (john_sadler@alum.mit.edu) ** All rights reserved. ** ** Get the latest Ficl release at http://ficl.sourceforge.net ** ** I am interested in hearing from anyone who uses ficl. If you have ** a problem, a success story, a defect, an enhancement request, or ** if you would like to contribute to the ficl release, please ** contact me by email at the address above. ** ** L I C E N S E  and  D I S C L A I M E R **  ** Redistribution and use in source and binary forms, with or without ** modification, are permitted provided that the following conditions ** are met: ** 1. Redistributions of source code must retain the above copyright **    notice, this list of conditions and the following disclaimer. ** 2. Redistributions in binary form must reproduce the above copyright **    notice, this list of conditions and the following disclaimer in the **    documentation and/or other materials provided with the distribution. ** ** THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ** ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE ** IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ** ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE ** FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL ** DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS ** OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ** HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT ** LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY ** OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF ** SUCH DAMAGE. */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_include
include|#
directive|include
file|"math64.h"
end_include

begin_comment
comment|/* ** (jws) revisions:  ** A prefix is a word in a dedicated wordlist (name stored in list_name below) ** that is searched in a special way by the prefix parse step. When a prefix ** matches the beginning of an incoming token, push the non-prefix part of the ** token back onto the input stream and execute the prefix code. ** ** The parse step is called ficlParsePrefix.  ** Storing prefix entries in the dictionary greatly simplifies ** the process of matching and dispatching prefixes, avoids the ** need to clean up a dynamically allocated prefix list when the system ** goes away, but still allows prefixes to be allocated at runtime. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|list_name
index|[]
init|=
literal|"<prefixes>"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**************************************************************************                         f i c l P a r s e P r e f i x ** This is the parse step for prefixes - it checks an incoming word ** to see if it starts with a prefix, and if so runs the corrseponding ** code against the remainder of the word and returns true. **************************************************************************/
end_comment

begin_function
name|int
name|ficlParsePrefix
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|STRINGINFO
name|si
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|FICL_WORD
modifier|*
name|pFW
init|=
name|ficlLookup
argument_list|(
name|pVM
operator|->
name|pSys
argument_list|,
name|list_name
argument_list|)
decl_stmt|;
comment|/*      ** Make sure we found the prefix dictionary - otherwise silently fail     ** If forth-wordlist is not in the search order, we won't find the prefixes.     */
if|if
condition|(
operator|!
name|pFW
condition|)
return|return
name|FICL_FALSE
return|;
name|pHash
operator|=
operator|(
name|FICL_HASH
operator|*
operator|)
operator|(
name|pFW
operator|->
name|param
index|[
literal|0
index|]
operator|.
name|p
operator|)
expr_stmt|;
comment|/*     ** Walk the list looking for a match with the beginning of the incoming token     */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|pHash
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|pFW
operator|=
name|pHash
operator|->
name|table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|pFW
operator|!=
name|NULL
condition|)
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|pFW
operator|->
name|nName
expr_stmt|;
comment|/*             ** If we find a match, adjust the TIB to give back the non-prefix characters             ** and execute the prefix word.             */
if|if
condition|(
operator|!
name|strincmp
argument_list|(
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|,
name|pFW
operator|->
name|name
argument_list|,
operator|(
name|FICL_UNS
operator|)
name|n
argument_list|)
condition|)
block|{
comment|/* (sadler) fixed off-by-one error when the token has no trailing space in the TIB */
name|vmSetTibIndex
argument_list|(
name|pVM
argument_list|,
name|si
operator|.
name|cp
operator|+
name|n
operator|-
name|pVM
operator|->
name|tib
operator|.
name|cp
argument_list|)
expr_stmt|;
name|vmExecute
argument_list|(
name|pVM
argument_list|,
name|pFW
argument_list|)
expr_stmt|;
return|return
name|FICL_TRUE
return|;
block|}
name|pFW
operator|=
name|pFW
operator|->
name|link
expr_stmt|;
block|}
block|}
return|return
name|FICL_FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tempBase
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|int
name|oldbase
init|=
name|pVM
operator|->
name|base
decl_stmt|;
name|STRINGINFO
name|si
init|=
name|vmGetWord0
argument_list|(
name|pVM
argument_list|)
decl_stmt|;
name|pVM
operator|->
name|base
operator|=
name|base
expr_stmt|;
if|if
condition|(
operator|!
name|ficlParseNumber
argument_list|(
name|pVM
argument_list|,
name|si
argument_list|)
condition|)
block|{
name|int
name|i
init|=
name|SI_COUNT
argument_list|(
name|si
argument_list|)
decl_stmt|;
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"%.*s not recognized"
argument_list|,
name|i
argument_list|,
name|SI_PTR
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pVM
operator|->
name|base
operator|=
name|oldbase
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|fTempBase
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|int
name|base
init|=
name|stackPopINT
argument_list|(
name|pVM
operator|->
name|pStack
argument_list|)
decl_stmt|;
name|tempBase
argument_list|(
name|pVM
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|prefixHex
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|tempBase
argument_list|(
name|pVM
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|prefixTen
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|)
block|{
name|tempBase
argument_list|(
name|pVM
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**************************************************************************                         f i c l C o m p i l e P r e f i x ** Build prefix support into the dictionary and the parser ** Note: since prefixes always execute, they are effectively IMMEDIATE. ** If they need to generate code in compile state you must add ** this code explicitly. **************************************************************************/
end_comment

begin_function
name|void
name|ficlCompilePrefix
parameter_list|(
name|FICL_SYSTEM
modifier|*
name|pSys
parameter_list|)
block|{
name|FICL_DICT
modifier|*
name|dp
init|=
name|pSys
operator|->
name|dp
decl_stmt|;
name|FICL_HASH
modifier|*
name|pHash
decl_stmt|;
name|FICL_HASH
modifier|*
name|pPrevCompile
init|=
name|dp
operator|->
name|pCompile
decl_stmt|;
if|#
directive|if
operator|(
name|FICL_EXTENDED_PREFIX
operator|)
name|FICL_WORD
modifier|*
name|pFW
decl_stmt|;
endif|#
directive|endif
comment|/*     ** Create a named wordlist for prefixes to reside in...     ** Since we're doing a special kind of search, make it     ** a single bucket hashtable - hashing does not help here.     */
name|pHash
operator|=
name|dictCreateWordlist
argument_list|(
name|dp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pHash
operator|->
name|name
operator|=
name|list_name
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
name|list_name
argument_list|,
name|constantParen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendCell
argument_list|(
name|dp
argument_list|,
name|LVALUEtoCELL
argument_list|(
name|pHash
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	** Put __tempbase in the forth-wordlist 	*/
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"__tempbase"
argument_list|,
name|fTempBase
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
comment|/*     ** Temporarily make the prefix list the compile wordlist so that     ** we can create some precompiled prefixes.     */
name|dp
operator|->
name|pCompile
operator|=
name|pHash
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0x"
argument_list|,
name|prefixHex
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"0d"
argument_list|,
name|prefixTen
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
if|#
directive|if
operator|(
name|FICL_EXTENDED_PREFIX
operator|)
name|pFW
operator|=
name|ficlLookup
argument_list|(
name|pSys
argument_list|,
literal|"\\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pFW
condition|)
block|{
name|dictAppendWord
argument_list|(
name|dp
argument_list|,
literal|"//"
argument_list|,
name|pFW
operator|->
name|code
argument_list|,
name|FW_DEFAULT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|dp
operator|->
name|pCompile
operator|=
name|pPrevCompile
expr_stmt|;
return|return;
block|}
end_function

end_unit

