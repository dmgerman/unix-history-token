begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/******************************************************************* ** s t a c k . c ** Forth Inspired Command Language ** Author: John Sadler (john_sadler@alum.mit.edu) ** Created: 16 Oct 1997 **  *******************************************************************/
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TESTMAIN
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stand.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"ficl.h"
end_include

begin_define
define|#
directive|define
name|STKDEPTH
parameter_list|(
name|s
parameter_list|)
value|((s)->sp - (s)->base)
end_define

begin_comment
comment|/* ** N O T E: Stack convention: ** ** sp points to the first available cell ** push: store value at sp, increment sp ** pop:  decrement sp, fetch value at sp ** Stack grows from low to high memory */
end_comment

begin_comment
comment|/*******************************************************************                     v m C h e c k S t a c k ** Check the parameter stack for underflow or overflow. ** nCells controls the type of check: if nCells is zero, ** the function checks the stack state for underflow and overflow. ** If nCells> 0, checks to see that the stack has room to push ** that many cells. If less than zero, checks to see that the ** stack has room to pop that many cells. If any test fails, ** the function throws (via vmThrow) a VM_ERREXIT exception. *******************************************************************/
end_comment

begin_function
name|void
name|vmCheckStack
parameter_list|(
name|FICL_VM
modifier|*
name|pVM
parameter_list|,
name|int
name|popCells
parameter_list|,
name|int
name|pushCells
parameter_list|)
block|{
name|FICL_STACK
modifier|*
name|pStack
init|=
name|pVM
operator|->
name|pStack
decl_stmt|;
name|int
name|nFree
init|=
name|pStack
operator|->
name|base
operator|+
name|pStack
operator|->
name|nCells
operator|-
name|pStack
operator|->
name|sp
decl_stmt|;
if|if
condition|(
name|popCells
operator|>
name|STKDEPTH
argument_list|(
name|pStack
argument_list|)
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: stack underflow"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nFree
operator|<
name|pushCells
operator|-
name|popCells
condition|)
block|{
name|vmThrowErr
argument_list|(
name|pVM
argument_list|,
literal|"Error: stack overflow"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k C r e a t e **  *******************************************************************/
end_comment

begin_function
name|FICL_STACK
modifier|*
name|stackCreate
parameter_list|(
name|unsigned
name|nCells
parameter_list|)
block|{
name|size_t
name|size
init|=
sizeof|sizeof
argument_list|(
name|FICL_STACK
argument_list|)
operator|+
name|nCells
operator|*
sizeof|sizeof
argument_list|(
name|CELL
argument_list|)
decl_stmt|;
name|FICL_STACK
modifier|*
name|pStack
init|=
name|ficlMalloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|#
directive|if
name|FICL_ROBUST
name|assert
argument_list|(
name|nCells
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pStack
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pStack
operator|->
name|nCells
operator|=
name|nCells
expr_stmt|;
name|pStack
operator|->
name|sp
operator|=
name|pStack
operator|->
name|base
expr_stmt|;
name|pStack
operator|->
name|pFrame
operator|=
name|NULL
expr_stmt|;
return|return
name|pStack
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k D e l e t e **  *******************************************************************/
end_comment

begin_function
name|void
name|stackDelete
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
if|if
condition|(
name|pStack
condition|)
name|ficlFree
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k D e p t h  **  *******************************************************************/
end_comment

begin_function
name|int
name|stackDepth
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
name|STKDEPTH
argument_list|(
name|pStack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k D r o p **  *******************************************************************/
end_comment

begin_function
name|void
name|stackDrop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|#
directive|if
name|FICL_ROBUST
name|assert
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pStack
operator|->
name|sp
operator|-=
name|n
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k F e t c h **  *******************************************************************/
end_comment

begin_function
name|CELL
name|stackFetch
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|pStack
operator|->
name|sp
index|[
operator|-
name|n
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
name|void
name|stackStore
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|,
name|CELL
name|c
parameter_list|)
block|{
name|pStack
operator|->
name|sp
index|[
operator|-
name|n
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k G e t T o p **  *******************************************************************/
end_comment

begin_function
name|CELL
name|stackGetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
name|pStack
operator|->
name|sp
index|[
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k L i n k ** Link a frame using the stack's frame pointer. Allot space for ** nCells cells in the frame ** 1) Push pFrame ** 2) pFrame = sp ** 3) sp += nCells *******************************************************************/
end_comment

begin_function
name|void
name|stackLink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|nCells
parameter_list|)
block|{
name|stackPushPtr
argument_list|(
name|pStack
argument_list|,
name|pStack
operator|->
name|pFrame
argument_list|)
expr_stmt|;
name|pStack
operator|->
name|pFrame
operator|=
name|pStack
operator|->
name|sp
expr_stmt|;
name|pStack
operator|->
name|sp
operator|+=
name|nCells
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k U n l i n k ** Unink a stack frame previously created by stackLink ** 1) sp = pFrame ** 2) pFrame = pop() *******************************************************************/
end_comment

begin_function
name|void
name|stackUnlink
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|pStack
operator|->
name|sp
operator|=
name|pStack
operator|->
name|pFrame
expr_stmt|;
name|pStack
operator|->
name|pFrame
operator|=
name|stackPopPtr
argument_list|(
name|pStack
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k P i c k **  *******************************************************************/
end_comment

begin_function
name|void
name|stackPick
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|stackPush
argument_list|(
name|pStack
argument_list|,
name|stackFetch
argument_list|(
name|pStack
argument_list|,
name|n
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k P o p **  *******************************************************************/
end_comment

begin_function
name|CELL
name|stackPop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
operator|*
operator|--
name|pStack
operator|->
name|sp
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|stackPopPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|--
name|pStack
operator|->
name|sp
operator|)
operator|.
name|p
return|;
block|}
end_function

begin_function
name|FICL_UNS
name|stackPopUNS
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|--
name|pStack
operator|->
name|sp
operator|)
operator|.
name|u
return|;
block|}
end_function

begin_function
name|FICL_INT
name|stackPopINT
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|--
name|pStack
operator|->
name|sp
operator|)
operator|.
name|i
return|;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k P u s h **  *******************************************************************/
end_comment

begin_function
name|void
name|stackPush
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
block|{
operator|*
name|pStack
operator|->
name|sp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stackPushPtr
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
operator|*
name|pStack
operator|->
name|sp
operator|++
operator|=
name|LVALUEtoCELL
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stackPushUNS
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|FICL_UNS
name|u
parameter_list|)
block|{
operator|*
name|pStack
operator|->
name|sp
operator|++
operator|=
name|LVALUEtoCELL
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|stackPushINT
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|FICL_INT
name|i
parameter_list|)
block|{
operator|*
name|pStack
operator|->
name|sp
operator|++
operator|=
name|LVALUEtoCELL
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k R e s e t **  *******************************************************************/
end_comment

begin_function
name|void
name|stackReset
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|)
block|{
name|pStack
operator|->
name|sp
operator|=
name|pStack
operator|->
name|base
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k R o l l  ** Roll nth stack entry to the top (counting from zero), if n is  **>= 0. Drop other entries as needed to fill the hole. ** If n< 0, roll top-of-stack to nth entry, pushing others ** upward as needed to fill the hole. *******************************************************************/
end_comment

begin_function
name|void
name|stackRoll
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|CELL
name|c
decl_stmt|;
name|CELL
modifier|*
name|pCell
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
elseif|else
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|pCell
operator|=
name|pStack
operator|->
name|sp
operator|-
name|n
operator|-
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|pCell
expr_stmt|;
for|for
control|(
init|;
name|n
operator|>
literal|0
condition|;
operator|--
name|n
operator|,
name|pCell
operator|++
control|)
block|{
operator|*
name|pCell
operator|=
name|pCell
index|[
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|pCell
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|pCell
operator|=
name|pStack
operator|->
name|sp
operator|-
literal|1
expr_stmt|;
name|c
operator|=
operator|*
name|pCell
expr_stmt|;
for|for
control|(
init|;
name|n
operator|<
literal|0
condition|;
operator|++
name|n
operator|,
name|pCell
operator|--
control|)
block|{
operator|*
name|pCell
operator|=
name|pCell
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|pCell
operator|=
name|c
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************************                     s t a c k S e t T o p **  *******************************************************************/
end_comment

begin_function
name|void
name|stackSetTop
parameter_list|(
name|FICL_STACK
modifier|*
name|pStack
parameter_list|,
name|CELL
name|c
parameter_list|)
block|{
name|pStack
operator|->
name|sp
index|[
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
return|return;
block|}
end_function

end_unit

